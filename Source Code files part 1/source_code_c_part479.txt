e "marqlyt.hxx"
#endif

#ifndef X_CONTLYT_HXX_
#define X_CONTLYT_HXX_
#include "contlyt.hxx"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

ExternTag(tagNotifyPath);

DeclareTag(tagLayoutAry, "Layout: Layout Ary", "Trace CLayoutAry fns");

//+--------------------------------------------------------------------------------------
//+--------------------------------------------------------------------------------------
//
//  General CElement Layout related functions
//
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     GetLayoutFromFactory
//
//  Synopsis:   Creates the layout object to be associated with the current element
//
//--------------------------------------------------------------------------
HRESULT GetLayoutFromFactory(CElement * pElement, CLayoutContext *pLayoutContext, DWORD dwFlags, CLayout ** ppLayout)
{
    CLayout *   pLayout                 = NULL;
    HRESULT     hr                      = S_OK;
    BOOL        fCreateGenericLayout;

    if (!ppLayout)
        return E_POINTER;

    *ppLayout = NULL;

#if DBG
    if ( pLayoutContext )
    {
        AssertSz( pLayoutContext->IsValid(), "Context should have an owner at this point.  Unowned contexts shouldn't be used to create layouts." );
        // Contexts must be defined by either LAYOUTRECTs or DEVICERECTs.  In the former case,
        // the element that wants a layout in the context must be in a difference markup,
        // in the latter, it must be in the same markup (the template).
        Assert(   (   pLayoutContext->GetLayoutOwner()->ElementOwner()->IsLinkedContentElement()
                     && pLayoutContext->GetLayoutOwner()->GetOwnerMarkup() != pElement->GetMarkup() )
                 || (   !FormsStringICmp(pLayoutContext->GetLayoutOwner()->ElementOwner()->TagName(), _T("DEVICERECT") )
                     && pLayoutContext->GetLayoutOwner()->GetOwnerMarkup() == pElement->GetMarkup() ) );
    }
#endif

    if (!pElement || pElement->HasMasterPtr())
        return E_INVALIDARG;

#ifdef TEMP_UNASSERT  // temporarily removing this to help test. we should fix this situation in V4
    Assert(!pElement->IsPassivating());
#endif

    Assert(!pElement->IsPassivated());
    Assert(!pElement->IsDestructing());

    fCreateGenericLayout = pElement->HasSlavePtr();

    // this is our basic LayoutFactory.  It will match the appropriate default
    // layout with the tag. the generic C1DLayout is used for tags which do not
    // have their own specific layout.
    switch (pElement->TagType())
    {
    case ETAG_INPUT:
        {
            switch (DYNCAST(CInput, pElement)->GetType())
            {
            case htmlInputButton:
            case htmlInputReset:
            case htmlInputSubmit:
                Assert(fCreateGenericLayout);
                fCreateGenericLayout = FALSE;
                pLayout = new CInputButtonLayout(pElement, pLayoutContext);
                break;
            case htmlInputFile:
                Assert(fCreateGenericLayout);
                fCreateGenericLayout = FALSE;
                pLayout = new CInputFileLayout(pElement, pLayoutContext);
                break;
            case htmlInputText:
            case htmlInputPassword:
            case htmlInputHidden:
                Assert(fCreateGenericLayout);
                fCreateGenericLayout = FALSE;
                pLayout = new CInputTextLayout(pElement, pLayoutContext);
                break;
            case htmlInputCheckbox:
            case htmlInputRadio:
                if (!fCreateGenericLayout)
                {
                    pLayout = new CCheckboxLayout(pElement, pLayoutContext);
                }
                break;
            case htmlInputImage:
                if (!fCreateGenericLayout)
                {
                    pLayout = new CInputImageLayout(pElement, pLayoutContext);
                }
                break;
            default:
                AssertSz(FALSE, "Illegal Input Type");
            }
        }
        break;

    case ETAG_IMG:
        if (!fCreateGenericLayout)
        {
            pLayout = new CImgElementLayout(pElement, pLayoutContext);
        }
        break;

    case ETAG_HTML:
        fCreateGenericLayout = FALSE;
        pLayout = new CHtmlLayout(pElement, pLayoutContext);
        break;

    case ETAG_BODY:
        fCreateGenericLayout = FALSE;
        pLayout = new CBodyLayout(pElement, pLayoutContext);
        break;

    case ETAG_BUTTON:
        fCreateGenericLayout = FALSE;
        pLayout = new CButtonLayout(pElement, pLayoutContext);
        break;

    case ETAG_MARQUEE:
        fCreateGenericLayout = FALSE;
        pLayout = new CMarqueeLayout(pElement, pLayoutContext);
        break;

    case ETAG_TABLE:
        if (pElement->HasLayoutAry())
        {
            // If this is a view chain case create block layout 
            pLayout = new CTableLayoutBlock(pElement, pLayoutContext);
        }
        else
        {
            pLayout = new CTableLayout(pElement, pLayoutContext);
        }
        break;

    case ETAG_TD:
    case ETAG_TC:
    case ETAG_TH:
    case ETAG_CAPTION:
        fCreateGenericLayout = FALSE;
        pLayout = new CTableCellLayout(pElement, pLayoutContext);
        break;

    case ETAG_TEXTAREA:
        fCreateGenericLayout = FALSE;
        pLayout = new CTextAreaLayout(pElement, pLayoutContext);
        break;

    case ETAG_TR:
        if (pElement->HasLayoutAry())
        {
            pLayout = new CTableRowLayoutBlock(pElement, pLayoutContext);
        }
        else
        {
            pLayout = new CTableRowLayout(pElement, pLayoutContext);
        }
        break;

    case ETAG_LEGEND:
        fCreateGenericLayout = FALSE;
        pLayout = new CLegendLayout(pElement, pLayoutContext);
        break;

    case ETAG_FIELDSET:
        fCreateGenericLayout = FALSE;
        pLayout = new CFieldSetLayout(pElement, pLayoutContext);
        break;

    case ETAG_SELECT:
        pLayout = new CSelectLayout(pElement, pLayoutContext);
        break;

    case ETAG_HR:
        pLayout = new CHRLayout(pElement, pLayoutContext);
        break;

    case ETAG_FRAMESET:
        pLayout = new CFrameSetLayout(pElement, pLayoutContext);
        break;

    case ETAG_IFRAME:
    case ETAG_FRAME:
        fCreateGenericLayout = TRUE;
        break;

    case ETAG_OBJECT:
    case ETAG_EMBED:
    case ETAG_APPLET:
        pLayout = new COleLayout(pElement, pLayoutContext);
        break;

    case ETAG_GENERIC:
        if (pElement->IsLinkedContentElement())
        {
            fCreateGenericLayout = FALSE;
            pLayout = new CContainerLayout(pElement, pLayoutContext);
        }
        else
        {
            fCreateGenericLayout = TRUE;
        }
        break;

    default:
        fCreateGenericLayout = TRUE;
        break;
    }


    if (fCreateGenericLayout)
    {
        Assert(!pLayout);
        pLayout = new C1DLayout(pElement, pLayoutContext);
        if (pLayout)
        {
            pElement->_fOwnsRuns = TRUE;
        }
    }

    if (!pLayout)
        hr = E_OUTOFMEMORY;
    else
    {
        pLayout->Init();        //  For now, this can be called at creation time.
    }
    
    *ppLayout = pLayout;

    RRETURN(hr);
}


CLayout *
CElement::CreateLayout( CLayoutContext * pLayoutContext )
{
    CLayout *   pLayout = NULL;
    HRESULT     hr;

    Assert(   ( pLayoutContext && !CurrentlyHasLayoutInContext( pLayoutContext ) )
           || ( !HasLayoutPtr() && !HasLayoutAry() ) );

    // GetLayoutFromFactory is a static function in this file.
    hr = THR(GetLayoutFromFactory(this, pLayoutContext, 0, &pLayout));
    if( SUCCEEDED( hr ) )
    {
        Assert( pLayout );
        if ( pLayoutContext )
        {
            CLayoutAry *pLA = EnsureLayoutAry();
            Assert( pLA && pLA == _pLayoutAryDbg );
            if ( !pLA )
            {
                return NULL;
            }
            
            Assert( pLayout->LayoutContext() == pLayoutContext );
            pLA->AddLayoutWithContext( pLayout );
        }
        else
        {
            SetLayoutPtr(pLayout);
        }

        CPeerHolder *   pPeerHolder = GetRenderPeerHolder();

        if (pPeerHolder)
        {
            hr = THR(pPeerHolder->OnLayoutAvailable(pLayout));
        }
    }

    return pLayout;
}

CFlowLayout *
CTreeNode::GetFlowLayout( CLayoutContext * pLayoutContext )
{
    CTreeNode   * pNode = this;
    CFlowLayout * pFL;

    while(pNode)
    {
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
            if (!pNode)
                break;
        }
        pFL = pNode->HasFlowLayout( pLayoutContext );
        if (pFL)
            return pFL;
        pNode = pNode->Parent();
    }

    return NULL;
}


CTreeNode *
CTreeNode::GetFlowLayoutNode( CLayoutContext * pLayoutContext )
{
    CTreeNode   * pNode = this;

    while(pNode)
    {
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
            if (!pNode)
                break;
        }
        if(pNode->HasFlowLayout( pLayoutContext ))
            return pNode;
        pNode = pNode->Parent();
    }

    return NULL;
}

// TODO (MohanB, KTam): why weren't the rest of the GetUpdated*Layout* fns changed to also
// climb out of the slave tree?
CTreeNode *
CTreeNode::GetUpdatedParentLayoutNode()
{
    CTreeNode   * pNode = this;
    /*
                            Element()->HasMasterPtr() ?
                            Element()->GetMasterPtr()->GetFirstBranch() :
                            this;
*/
    for(;;)
    {
        Assert(pNode);
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterIfSlave()->GetFirstBranch();
        }
        else
        {
            pNode = pNode->Parent();
        }
        if (!pNode)
            break;
        if (pNode->ShouldHaveLayout())
            return pNode;
    }
    return NULL;
}


//+----------------------------------------------------------------------------
//+----------------------------------------------------------------------------
//              
//  CLayoutAry implementation
//              
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

CLayoutAry::CLayoutAry( CElement *pElementOwner ) :
    CLayoutInfo( pElementOwner )
{
     _fHasMarkupPtr = FALSE;
    // $$ktam: CLayoutAry doesn't have lookasides right now; if it ever does, we
    // should assert a _pDocDbg->AreLookasidesClear() check here.
}

CLayoutAry::~CLayoutAry()
{
    // Clean up all the CLayout's we're holding onto
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    for ( i=0 ; i < nLayouts ; ++i)
    {
        pLayout = _aryLE[i];
        Assert( pLayout && "Layout array shouldn't have NULL entries!" );
        pLayout->Detach();
        pLayout->Release();
    }

    if (nLayouts)
    {
        _aryLE.DeleteMultiple(0, nLayouts-1);
    }

    __pvChain = NULL;
    _fHasMarkupPtr = FALSE;
    
#if DBG == 1
    _snLast = 0;
    _pDocDbg = NULL;
    _pMarkupDbg = NULL;
#endif
}

void
CLayoutAry::DelMarkupPtr()
{
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;
    for ( i = nLayouts-1 ; i >= 0 ; --i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        pLayout->DelMarkupPtr();
    }

    Assert(_fHasMarkupPtr);
    Assert( _pMarkup == _pMarkupDbg);
    WHEN_DBG(_pMarkupDbg = NULL );

    // Delete out CMarkup *
    _pDoc = _pMarkup->Doc();
    _fHasMarkupPtr = FALSE;
}

void
CLayoutAry::SetMarkupPtr(CMarkup *pMarkup)
{
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;
    for ( i = nLayouts-1 ; i >= 0 ; --i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        pLayout->SetMarkupPtr(pMarkup);
    }

    Assert( !_fHasMarkupPtr );
    Assert( pMarkup );
    Assert( pMarkup->Doc() == _pDocDbg );

     _pMarkup = pMarkup;
     WHEN_DBG( _pMarkupDbg = pMarkup );
     _fHasMarkupPtr = TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     AddLayoutWithContext
//
//--------------------------------------------------------------------------
void
CLayoutAry::AddLayoutWithContext( CLayout *pLayout )
{
    TraceTagEx((tagLayoutAry, TAG_NONAME,
                "CLytAry::AddLayoutWithContext lyt=0x%x, lc=0x%x, e=[0x%x,%d] (%S)",
                pLayout,
                pLayout->LayoutContext(), 
                pLayout->ElementOwner(), 
                pLayout->ElementOwner()->SN(), 
                pLayout->ElementOwner()->TagName()));

    AssertSz( pLayout->LayoutContext() && pLayout->LayoutContext()->IsValid(),
              "Illegal to add a layout w/o valid context to a layout array!" );
    
#if DBG == 1
    // Assert that a layout with the same context doesn't already exist in the array.
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayoutIter;

    for ( i=0 ; i < nLayouts ; ++i)
    {
        pLayoutIter = _aryLE[i];
        Assert( !(pLayoutIter->LayoutContext()->IsEqual( pLayout->LayoutContext() )) );
    }
#endif

    _aryLE.AppendIndirect( &pLayout );

    // NOTE (KTam): There's general concern here that layouts should
    // probably be ref-counted.  Think about doing this.. they aren't
    // CBase derived right now, so we have no current support for it.

    Assert( ! pLayout->_fHasMarkupPtr );    // new layout shouldn't already have a markup

    // Layouts within an array share the same _pvChain info
    pLayout->__pvChain = __pvChain; 
    pLayout->_fHasMarkupPtr = _fHasMarkupPtr;

#if DBG ==1
    if ( _fHasMarkupPtr )
    {
        Assert( _pMarkupDbg );
        pLayout->_pMarkupDbg = _pMarkupDbg;
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Method:     GetLayoutWithContext
//
//--------------------------------------------------------------------------
CLayout *
CLayoutAry::GetLayoutWithContext( CLayoutContext *pLayoutContext )
{
    int i;
    int nLayouts = Size();
    CLayout *pLayout;

    // TODO (KTam): Remove this when we no longer support "allowing GUL bugs".
    if ( !pLayoutContext )
    {
        Assert( Size() );
        pLayout = _aryLE[0];
        Assert( pLayout && "Layout array shouldn't have NULL entries!" );
        return pLayout;
    }

    AssertSz( pLayoutContext->IsValid(), "Should not be asking for a layout using an invalid context!" );

    // Linear seach array to see if there's a layout associated with this
    // context.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        Assert( pLayout->LayoutContext() && "Layouts in array must have context!" );
        if ( pLayout->LayoutContext()->IsEqual( pLayoutContext ) )
            return pLayout;
    }

    // No layout corresponding to this context
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     RemoveLayoutWithContext
//
//  Synopsis:   Searches for a layout that is associated with pLayoutContext,
//              removing it from the array and returning it if found.
//
//              NOTE: The test for association is currently layout context
//              pointer equality: this means 2 contexts w/ the same layout
//              owner are not equal, and thus compatible contexts need to be
//              treated separately.
//
//--------------------------------------------------------------------------
CLayout *
CLayoutAry::RemoveLayoutWithContext( CLayoutContext *pLayoutContext )
{
    int i;
    int nLayouts = Size();
    CLayout *pLayout = NULL;

    Assert( pLayoutContext );
    // Depending on how we use this function, this assert may not be true.
    // We may for example choose to use this fn to remove layouts that have
    // invalid contexts!
    Assert( pLayoutContext->IsValid() );

    // Linear seach array to see if there's a layout associated with this
    // context.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        CLayout *pL = _aryLE[i];
        Assert( pL->LayoutContext() && "Layouts in array must have context!" );
        if ( pL->LayoutContext()->IsEqual( pLayoutContext ) )
        {
            // Remove the layout from the array, and return it
            Verify(_aryLE.DeleteByValueIndirect( &pL ));
            pLayout = pL;
            goto Cleanup;
        }
    }

Cleanup:
    TraceTagEx((tagLayoutAry, TAG_NONAME,
                "CLytAry::RemoveLayoutWithContext lyt=0x%x, lc=0x%x, e=[0x%x,%d] (%S)",
                pLayout,
                pLayout ? pLayout->LayoutContext() : NULL, 
                pLayout ? pLayout->ElementOwner() : NULL, 
                pLayout ? pLayout->ElementOwner()->SN() : -1, 
                pLayout ? pLayout->ElementOwner()->TagName() : TEXT("")));

    return pLayout;
}

//+----------------------------------------------------------------------------
//  Helpers delegated from CElement
//-----------------------------------------------------------------------------
BOOL
CLayoutAry::ContainsRelative()
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array to see if there's a layout that contains relative stuff.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            if ( pLayout->_fContainsRelative )
                return TRUE;
        }
    }

    return FALSE;
}

BOOL
CLayoutAry::GetEditableDirty()
{
    Assert( _aryLE.Size() );

    BOOL fEditableDirty = (_aryLE[GetFirstValidLayoutIndex()])->_fEditableDirty;

#if DBG
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // All layouts in collection should have same value for fEditableDirty
    // Linear seach array to assert this is true.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            Assert( !!pLayout->_fEditableDirty == !!fEditableDirty );
        }
    }
#endif

    return fEditableDirty;
}

void
CLayoutAry::SetEditableDirty( BOOL fEditableDirty )
{
    Assert( _aryLE.Size() );
    
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array to set flag on each of them.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            pLayout->_fEditableDirty = fEditableDirty;
        }
    }
}

CLayoutAry::WantsMinMaxNotification()
{
    Assert( _aryLE.Size() );
    
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            // If any layout wants minmax notifications, then the array wants to be notified.
            // Make sure "if" condition stays in sync with what's in CElement::MinMaxElement
            if ( pLayout->_fMinMaxValid )
            {
                return TRUE;
            }
        }
    }

    // No layouts in the array wants a resize notification
    return FALSE;
}


BOOL
CLayoutAry::WantsResizeNotification()
{
    Assert( _aryLE.Size() );
    
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Linear seach array.
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            // If any layout wants resize notifications, then the array wants to be notified.
            // Make sure "if" condition stays in sync with what's in CElement::ResizeElement
            // TODO (KTam): THIS CONDITION IS NO LONGER IN SYNC, but that's OK for IE5.5.
            // NOTE (KTam): consider unifying condition in a CLayout::WantsResizeNotification() fn
            if ( !pLayout->IsSizeThis() && !pLayout->IsCalcingSize() )
            {
                return TRUE;
            }
        }
    }

    // No layouts in the array wants a resize notification
    return FALSE;
}

void
CLayoutAry::Notify(
    CNotification * pnf)
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Most notifications that come to the layout array should be passed on to each layout.
    // However, some are actually mean for the array.
    switch ( pnf->Type() )
    {    
        case NTYPE_MULTILAYOUT_CLEANUP:
        {
            // Iterate over array deleting layouts with invalid contexts.  Do it in
            // reverse to simplify iteration during deletion.
            for ( i = nLayouts-1 ; i >= 0 ; --i )
            {
                pLayout = _aryLE[i];
                AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
                if ( !pLayout->LayoutContext()->IsValid() )
                {
                    // Remove the layout from the array
                    _aryLE.Delete(i);
                    // Get rid of the layout
                    pLayout->Detach();
                    pLayout->Release();
                }
            }
            break;
        }

        case NTYPE_ELEMENT_ZCHANGE:
        case NTYPE_ELEMENT_REPOSITION:
            if (pnf->LayoutContext())
            {
                // Iterate over array finding specified layout.  Do it in
                // reverse because in most cases this is a last layout added.
                for ( i = nLayouts-1 ; i >= 0 ; --i )
                {
                    pLayout = _aryLE[i];
                    AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
                    if (   pLayout->LayoutContext()->IsValid() 
                        && pLayout->LayoutContext() == pnf->LayoutContext() )
                    {
                        TraceTagEx((tagNotifyPath, TAG_NONAME,
                                   "NotifyPath: (%d) sent to pLayout(0x%x, %S) via layout array",
                                   pnf->_sn,
                                   pLayout,
                                   pLayout->ElementOwner()->TagName()));

                        pLayout->Notify( pnf );
                        break;
                    }
                }

                //
                // Getting here means that this elementOwner has no layout in the context of the
                // notification.  If the ElemetnOwner is a LayoutRect then that means the notification
                // has come from somewhere inside us and we do not want this to continue to bubble 
                // up through the view link to the outside document
                //
                if (ElementOwner()->IsLinkedContentElement())
                {
                    pnf->SetHandler(ElementOwner());
                }
                break;
            }
        // do not insert other cases here !!! previous case is sensitive to position of default case !!!
        default:
        // Notification meant for individual layouts: tell each layout in the array about it
        {
            for ( i=0 ; i < nLayouts ; ++i )
            {
                pLayout = _aryLE[i];
                AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
                if ( pLayout->LayoutContext()->IsValid() )
                {
                    TraceTagEx((tagNotifyPath, TAG_NONAME,
                               "NotifyPath: (%d) sent to pLayout(0x%x, %S) via layout array",
                               pnf->_sn,
                               pLayout,
                               pLayout->ElementOwner()->TagName()));

                    pLayout->Notify( pnf );
                }
            }
            break;
        }
    }
}

//////////////////////////////////////////////////////
//
// CLayoutInfo overrides
//
//////////////////////////////////////////////////////

// $$ktam: It might be a good idea to implement some kind of CLayoutAry iterator class.
// Most of these overrides iterate the array..

HRESULT
CLayoutAry::OnPropertyChange( DISPID dispid, DWORD dwFlags )
{
    Assert( _aryLE.Size() );

    HRESULT hr = S_OK;
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Tell each layout in the array about the property change  
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            hr = pLayout->OnPropertyChange(dispid, dwFlags);
            Assert( SUCCEEDED(hr) );
        }
    }

    return hr;
}

HRESULT
CLayoutAry::OnExitTree()
{
    Assert( _aryLE.Size() );

    HRESULT hr = S_OK;
    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Tell each layout in the array that it's exiting the tree
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        // We deliberately ignore the valid state on the layout's context; since we're
        // exiting the tree, it's OK to let invalid layouts know.
        // TODO (KTam): it shouldn't make a difference either way, maybe be consistent?
        hr = pLayout->OnExitTree();
        Assert( SUCCEEDED(hr) );
    }

    return hr;
}

// Currently all implementations of OnFormatsChange actually only do work
// on their element (not on the layout).  This means that even in a multi-
// layout world, we only want to call on one of the layouts.  It also suggests
// that OnFormatsChange ought to be on CElement rather than CLayout.
HRESULT
CLayoutAry::OnFormatsChange(DWORD dwFlags)
{
    int i = GetFirstValidLayoutIndex();
    if ( _aryLE.Size() )
        return _aryLE[i]->OnFormatsChange(dwFlags);

    return E_FAIL;
}

void
CLayoutAry::Dirty( DWORD grfLayout )
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    // Tell each layout in the array that it's dirty
    
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
        {
            pLayout->Dirty( grfLayout );
        }
    }
}

BOOL
CLayoutAry::IsFlowLayout()
{
    // CLayoutAry's are homogenous - delegate to the first layout in the array
    int i = GetFirstValidLayoutIndex();
    return (   _aryLE.Size()
            && _aryLE[i]->IsFlowLayout() );
}
BOOL
CLayoutAry::IsFlowOrSelectLayout()
{
    // CLayoutAry's are homogenous - delegate to the first layout in the array
    int i = GetFirstValidLayoutIndex();
    return (   _aryLE.Size()
            && _aryLE[i]->IsFlowOrSelectLayout() );
}

// You should set the var pointed by *pnLayoutCookie to 0 to start the iterations
// It will be set to -1 if there are no more layouts or an error occured
CLayout *
CLayoutAry::GetNextLayout(int *pnLayoutCookie)
{
    CLayout * pLayout;

    Assert(pnLayoutCookie);
    int nArySize = Size();

    Assert(*pnLayoutCookie >= 0);
 
    if(*pnLayoutCookie < 0 || *pnLayoutCookie >= nArySize)
    {
        *pnLayoutCookie = -1;
        return NULL;
    }

    do
    {
        pLayout = _aryLE[*pnLayoutCookie];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );

        (*pnLayoutCookie)++;

        if ( pLayout->LayoutContext()->IsValid() )
            return pLayout;
    }
    while(*pnLayoutCookie < nArySize);

    *pnLayoutCookie = -1;

    return NULL;
}


#if DBG
void
CLayoutAry::DumpLayoutInfo( BOOL fDumpLines )
{
    Assert( _aryLE.Size() );

    int i;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    WriteHelp(g_f, _T("CLayoutAry: 0x<0x> - <1d> layouts\r\n"), this, (long)nLayouts );

    // Dump each layout
    for ( i=0 ; i < nLayouts ; ++i )
    {
        pLayout = _aryLE[i];
        pLayout->DumpLayoutInfo( fDumpLines );
    }
}
#endif

int
CLayoutAry::GetFirstValidLayoutIndex()
{
    Assert( _aryLE.Size() );

    int i = 0;
    int nLayouts = _aryLE.Size();
    CLayout *pLayout;

    while ( i < nLayouts )
    {
        pLayout = _aryLE[i];
        AssertSz( pLayout->LayoutContext(), "Layouts in array must have a context" );
        if ( pLayout->LayoutContext()->IsValid() )
            return i;
        ++i;
    }

    AssertSz( FALSE, "Shouldn't have an array that doesn't have a valid layout" );
    return 0;
}


//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsLinkedContentElement
//
//  Synopsis:   Returns true if this is a linkable-content element false otherwise.
//      in IE6M1, only the Layout:rect identity behavior will utilize this 
//      functionality.
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsLinkedContentElement()
{
    // TODO (alexz) this heavily hits perf - up to 2% across the board.
    // This is a tag name comparison performed very often. Even though it is
    // unsuccessfull in most cases and the string comparison itself is fast,
    // it still requires an attr array search to get the tagname.
    // Instead, workout issues why the peer is not there when layout rolls.
    // TODO (ktam) the Tag() check should make us a lot more efficient; 
    // we'll do what Alex suggests if it's still necessary.
#ifdef MULTI_LAYOUT
    // We no longer rely on QI'ing the peer holder for ILayoutRect,
    // because a) the peer holder isn't instantiated quickly enough
    // (ie it doesn't exist at parse time), and b) this is more
    // efficient and just as functional since we don't plan to expose
    // ILayoutRect as a 3rd party interface.

    if (Tag() != ETAG_GENERIC )
        return FALSE;

    return !FormsStringICmp(TagName(), _T("LAYOUTRECT"));
#else
    return FALSE;
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::GetLinkedContentAttr
//
//  Synopsis:  Gets attributes from layout rects.  Assumes that the
//     attribute named by pszAttr is a string; returns S_OK if the
//     attribute exists and its value is a non-empty string, S_FALSE
//     if it exists but its value is an empty string, E_* if any other
//     failure occurs.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::GetLinkedContentAttr( LPCTSTR pszAttr, CVariant *pVarRet /*[out]*/ )
{
    BSTR    bstrAttribute = NULL;
    HRESULT hr = E_FAIL;

    Assert( pszAttr && pVarRet );

    pVarRet->ZeroVariant(); // always zero "out" param.

    // Bail immediately if this isn't a linked content element.
    if (!IsLinkedContentElement())
        goto Cleanup;

    bstrAttribute = SysAllocString( pszAttr );
    if ( !bstrAttribute )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = getAttribute( bstrAttribute, 0, pVarRet );
    // Fail if couldn't get attribute, or if attribute type isn't BSTR.
    if ( FAILED(hr) )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (V_VT(pVarRet) == VT_BSTR)
    {
        // Return S_FALSE if attribute exists but is empty string.
        hr = V_BSTR(pVarRet) ? S_OK : S_FALSE;        
    }
    else if (   V_VT(pVarRet) == VT_DISPATCH
             || V_VT(pVarRet) == VT_UNKNOWN)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

Cleanup:
    if ( bstrAttribute )
    {
        SysFreeString( bstrAttribute );
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::GetNextLinkedContentElem
//
//  Synopsis:   returns the element that this element overflows to, but only if
//      this is a valid linkable element.
//
//-----------------------------------------------------------------------------
CElement *
CElement::GetNextLinkedContentElem()
{
    BSTR          bstrLinkName = NULL;
    CElement    * pElement     = NULL;
    CMarkup     * pMarkup      = NULL;
    CVariant      cvarName;

    if ( GetLinkedContentAttr( _T("nextRect"), &cvarName ) != S_OK )
        goto Cleanup;

    pMarkup = GetMarkup();
    if (!pMarkup)
        goto Cleanup;

    if (FAILED(pMarkup->GetElementByNameOrID((LPTSTR)(V_BSTR(&cvarName)), 
                                                      &pElement)))
    {
        // before we bail it it possible that the "nextRectElement" attribute
        // may have our element.
        cvarName.Clear();
        SysFreeString(bstrLinkName);

        bstrLinkName = SysAllocString(_T("nextRectElement"));
        if (!bstrLinkName)
            goto Cleanup;

        Assert(pElement == NULL);

        if (FAILED(getAttribute(bstrLinkName, 0, &cvarName)))
            goto Cleanup;

        if (V_VT(&cvarName) != VT_DISPATCH)
            goto Cleanup;

        // To get a CElement we need to either QI for the clsid, 
        // this doesn't Addref, so just clear the variant to transfer
        // ownership of the dispatch pointer.
        if (pElement)
            IGNORE_HR(pElement->QueryInterface(CLSID_CElement, (void**) &pElement));
    }

    if (!pElement)
        goto Cleanup;

    // now that we have the element, lets verify that it is indeed linkable
    //---------------------------------------------------------------------
    if (!pElement->IsLinkedContentElement())
    {
        // ERROR, we linked to something that isn't linkable
        pElement = NULL;
    }

Cleanup:
    if (bstrLinkName)
        SysFreeString(bstrLinkName);

    return (pElement);
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::ConnectLinkedContentElems
//
//  Synopsis:   Connects a "new" layout rect element (that doesn't belong to a
//      viewchain) to an existing layout rect (the "src" elem), hooking the
//      new element up to the viewchain of the src elem.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::ConnectLinkedContentElems( CElement *pSrcElem, CElement *pNewElem )
{
    Assert( pSrcElem && pNewElem );
    Assert( pSrcElem->IsLinkedContentElement() && pNewElem->IsLinkedContentElement() );

    // NOTE (KTam): Layout iterators here, to handle layout rect elements having
    // multiple layouts?
    CLayout  * pSrcLayout = pSrcElem->EnsureLayoutInDefaultContext();
    CLayout  * pNewLayout = pNewElem->EnsureLayoutInDefaultContext();
    AssertSz( pSrcLayout, "Source element for linking must have layout" );
    AssertSz( pSrcLayout->ViewChain(), "Source element for linking must have view chain" );
    AssertSz( pNewLayout, "New element for linking must have layout" );
    AssertSz( (!pNewLayout->ViewChain() || (pNewLayout->ViewChain() == pSrcLayout->ViewChain()) ),
              "New elem should either not already have a view chain, or its viewchain should match what we're about to give it" );

    pNewLayout->SetViewChain(pSrcLayout->ViewChain(),
                             pSrcLayout->DefinedLayoutContext());

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::UpdateLinkedContentChain()
//
//  Synopsis:   Called when a link chain is invalid this function makes sure that
//      all of the slave markup pointers for the genericElements and viewChains 
//      for the associated CContainerLayouts are upto date.
//
//   Note : for future usage, this function assumes that when a chain is invalidated,
//      (e.g. the contentSrc property of the head container is changed), then the
//      viewChain pointers for the whole list will have been cleared.  If they are
//      marked invalid instead then this function will need to be updated.
//  
// TODO (KTam): Need to find/notify other chains (redundant displays).  So far
// we still only have one master, so notifications from the content tree will be
// directed to the single master element -- perhaps it needs to be able to know
// about all chains?
//
//-----------------------------------------------------------------------------

HRESULT
CElement::UpdateLinkedContentChain()
{
    CElement *  pNextElem;
    CElement *  pPrevElem;
    // Assert that this fn is only called on heads of chains
    WHEN_DBG( CVariant cvarAttr );
    AssertSz( GetLinkedContentAttr( _T("contentSrc"), &cvarAttr ) == S_OK, "UpdateLinkedContentChain() called for elem w/o contentSrc" );
    AssertSz( HasSlavePtr(), "Head of chain must have slave by now" );

    // Remeasure the head
    RemeasureElement(NFLAGS_FORCE);

    // Iterate through the chain, hooking up elements to the chain/setting slave
    // ptrs as needed, and then ask each element of the chain to remeasure.
    pPrevElem = this;
    pNextElem = GetNextLinkedContentElem();

    while ( pNextElem )
    {
        ConnectLinkedContentElems( pPrevElem, pNextElem );

        // Remeasure this link in the chain by forcing container to recalculate its size.
        pNextElem->RemeasureElement(NFLAGS_FORCE);

        pPrevElem = pNextElem;
        pNextElem = pNextElem->GetNextLinkedContentElem();
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member : Fire_onlayoutcomplete
//
// Synopsis : event firing helper, this is called asynch from the layout 
//      process.  it is responsible for creating the eventparam object, and
//      setting up the properties on it.
//
//--------------------------------------------------------------------
void
CElement::Fire_onlayoutcomplete(BOOL fMoreContent, DWORD dwExtra)
{
    Assert(dwExtra == 0 || fMoreContent);

    EVENTPARAM param(Doc(), this, NULL, FALSE, TRUE);

    param._pNode = GetFirstBranch();
    param._fOverflow = fMoreContent;
    param._overflowType = (OVERFLOWTYPE)dwExtra;
    param.SetType(_T("layoutcomplete"));

    FireEvent( &s_propdescCElementonlayoutcomplete, FALSE );
}

#if DBG==1
void
CElement::DumpLayouts()
{
    CLayoutInfo *pLI = NULL;

    if ( CurrentlyHasAnyLayout() )
        pLI = GetLayoutInfo();

    if ( pLI )
        pLI->DumpLayoutInfo( TRUE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\element.cxx ===
//+---------------------------------------------------------------------
//
//   File:      element.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include "cguid.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif


#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"    // for body's dispids
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_OCIDL_H_
#define X_OCIDL_H_
#include <ocidl.h>
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

// Note - The enums in types are defined in this file

#ifndef X_STRING_H_
#define X_STRING_H_
#include "string.h"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_IEXTAG_HXX_
#define X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_ACCHDRS_HXX_
#define X_ACCHDRS_HXX_
#include "acchdrs.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_DXTRANS_H_
#define X_DXTRANS_H_
#include "dxtrans.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_COMMENT_HXX
#define X_COMMENT_HXX
#include "comment.hxx"
#endif

#ifdef UNIX
#include "mainwin.h"
extern "C" HANDLE MwGetPrimarySelectionData();
#include "quxcopy.hxx"
#endif

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

BEGIN_TEAROFF_TABLE(CElement, IProvideMultipleClassInfo)
    TEAROFF_METHOD(super, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(super, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CElement, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CElement, GetInfoOfIndex, getinfoofindex, (ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource))
END_TEAROFF_TABLE()

MtDefine(Elements, Mem, "Elements")
MtDefine(CElementCLock, Locals, "CElement::CLock")
MtDefine(CElementHitTestPoint_aryRects_pv, Locals, "CElement::HitTestPoint aryRects::_pv")
MtDefine(CElementHitTestPoint_aryElements_pv, Locals, "CElement::HitTestPoint aryElements::_pv")
MtDefine(CElementGetElementRc_aryRects_pv, Locals, "CElement::GetElementRc aryRects::_pv")

MtDefine(CMessage, Locals, "CMessage")

MtDefine(CLayoutAry_aryLE_pv, Layout, "CLayoutAry::_aryLE::_pv")

#define _cxx_
#include "types.hdl"

#define _cxx_
#include "element.hdl"

DeclareTag(tagNotifyZChange,       "Notify: ZChange", "Trace ELEMENT_ZCHANGE notification");
DeclareTagOther(tagFormatTooltips, "Format", "Show format indices with tooltips");
ExternTag(tagDisableLockAR);

ExternTag(tagHtmSrcTest);

class CAnchorElement;

// Each property which has a url image has an associated internal property
// which holds the cookie for the image stored in the cache.

static const struct {
    DISPID propID;          // url image property
    DISPID cacheID;         // internal cookie property
}

// make sure that DeleteImageCtx is modified, if any dispid's
// are added to this array
s_aryImgDispID[] = {
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX },
    { DISPID_A_LISTSTYLEIMAGE,  DISPID_A_LIURLIMGCTXCACHEINDEX },
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE },
    { DISPID_A_BACKGROUNDIMAGE, DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER }
};

extern "C" const IID IID_DataSource;

BEGIN_TEAROFF_TABLE_(CElement, IServiceProvider)
        TEAROFF_METHOD(CElement, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(CElement, IRecalcProperty)
    TEAROFF_METHOD(CElement, GetCanonicalProperty, getcanonicalproperty, (DISPID dispid, IUnknown **ppUnk, DISPID *pdispid))
END_TEAROFF_TABLE()

//  Default property page list for elements that don't have their own.
//  This gives them the allpage by default.

#ifndef NO_PROPERTY_PAGE
const CLSID * const CElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1
    NULL
};
#endif // NO_PROPERTY_PAGE

class CControlledFormatter
{
public:
    CControlledFormatter(CElement *pElement, DISPID dispid, DWORD dwFlags);
    ~CControlledFormatter();
    BOOL Init(HRESULT *phr);

    CLayout *GetUpdatedNearestLayout() const { ok(); return _pNearestLayout; }
    CLayoutInfo *GetUpdatedNearestLayoutInfo() const { ok(); return _pNearestLayoutInfo;}
    BOOL HadLayoutBeforeFormatsChange() const { return _fHadLayoutBeforeFormatsChange; }
    BOOL HasLayoutAfterFormatsChange() const { ok(); return _fHasLayoutAfterFormatsChange; }
    BOOL ShouldComputeFormats() { Assert(_fInited); return _fShouldComputeFormatsForDISPID; }
    
private:
    BOOL ShouldComputeFormatsForDISPID();
    HRESULT SetupToComputeFormats();
    BOOL SendZNotification();
    
#if DBG==1
    VOID ok() const
    {
        AssertSz(_fInited, "Not initialized yet!");
        AssertSz(_fShouldComputeFormatsForDISPID, "Calling compute formats during OPP incorrectly");
    }
#else
    VOID ok() const {}
#endif
    
private:
    CElement  *_pElement;
    CTreeNode *_pNode;
    DISPID     _dispid;
    DWORD      _dwFlags;
    
    WHEN_DBG(BOOL      _fInited;)

    // Following not valid before we call Init
    BOOL         _fHadLayoutBeforeFormatsChange;
    BOOL         _fShouldComputeFormatsForDISPID;
    BOOL         _fHasLayoutAfterFormatsChange;
    CLayoutInfo *_pNearestLayoutInfo;
    CLayout     *_pNearestLayout;
};

typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG);
extern NOTIFYWINEVENTPROC g_pfnNotifyWinEvent;
extern CAccBase * GetAccObjOfElement( CElement* pElem );

//+------------------------------------------------------------------------
//
//  Class:     CMessage
//
//-------------------------------------------------------------------------

DWORD
FormsGetKeyState()
{
    static int vk[] =
    {
        VK_LBUTTON,     // MK_LBUTTON = 0x0001
        VK_RBUTTON,     // MK_RBUTTON = 0x0002
        VK_SHIFT,       // MK_SHIFT   = 0x0004
        VK_CONTROL,     // MK_CONTROL = 0x0008
        VK_MBUTTON,     // MK_MBUTTON = 0x0010
        VK_MENU,        // MK_ALT     = 0x0020
    };

    DWORD dwKeyState = 0;

    for (int i = 0; i < ARRAY_SIZE(vk); i++)
    {
        if (GetKeyState(vk[i]) & 0x8000)
        {
            dwKeyState |= (1 << i);
        }
    }

    return dwKeyState;
}

void
CMessage::CommonCtor()
{
    memset(this, 0, sizeof(*this));
    dwKeyState = FormsGetKeyState();
    resultsHitTest._cpHit = -1;
    pLayoutContext = GUL_USEFIRSTLAYOUT;
}

CMessage::CMessage(const MSG * pmsg)
{
    CommonCtor();
    if (pmsg)
    {
        memcpy(this, pmsg, sizeof(MSG));
        htc = HTC_YES;
    }
}


CMessage::CMessage(
    HWND hwndIn,
    UINT msg,
    WPARAM wParamIn,
    LPARAM lParamIn)
{
    CommonCtor();
    hwnd      = hwndIn;
    message   = msg;
    wParam    = wParamIn;
    lParam    = lParamIn;
    htc       = HTC_YES;
    time      = GetMessageTime();
    DWORD  dw = GetMessagePos();
    MSG::pt.x = (short)LOWORD(dw);
    MSG::pt.y = (short)HIWORD(dw);

    Assert(!fEventsFired);
    Assert(!fSelectionHMCalled);
}

CMessage::~CMessage()
{
    // NEWTREE: same subref note here
    Verify( !CTreeNode::ReplacePtr(&pNodeHit, NULL) );
}

//+---------------------------------------------------------------------------
//
// Member : CMessage : SetNodeHit
//
//  Synopsis : things like the tracker cache the message and then access it
//  on a timer callback. inorder to ensure that the elements that are in the
//  message are still there, we need to sub(?) addref the element.
//
//----------------------------------------------------------------------------

HRESULT
CMessage::SetNodeHit( CTreeNode * pNodeHitIn )
{
    // NEWTREE: same subref note here
    RRETURN( CTreeNode::ReplacePtr( &pNodeHit, pNodeHitIn ) );
}

//+-----------------------------------------------------------------------------
//
//  Member : CMessage::SetElementClk
//
//  Synopsis : consolidating the click firing code requires a helper function
//      to set the click element member of the message structure.
//              this function should only be called from handling a mouse buttonup
//      event message which could fire off a click (i.e. LButton only)
//
//------------------------------------------------------------------------------
void
CMessage::SetNodeClk( CTreeNode * pNodeClkIn )
{
    CTreeNode * pNodeDown = NULL;

    Assert(pNodeClkIn && !pNodeClk || pNodeClkIn == pNodeClk);

    // get the element that this message is related to or if there
    // isn't one use the pointer passed in
    pNodeClk = (pNodeHit) ? pNodeHit : pNodeClkIn;

    Assert( pNodeClk );

    // if this is not a LButtonUP just return, using the value
    // set (i.e. we do not need to look for a common ancester)
    if ( message != WM_LBUTTONUP)
    {
        return;
    }

    // now go get the _pEltGotButtonDown from the doc and look for
    // the first common ancester between the two. this is the lowest
    // element that the mouse went down and up over.
    pNodeDown = pNodeClk->Element()->Doc()->_pNodeGotButtonDown;

    if (!pNodeDown)
    {
        // Button down was not on this doc, or cleared due to capture.
        // so this is not a click
        pNodeClk = NULL;
    }
    else
    {
        // Convert both nodes from from slave to master before comparison
        if (pNodeDown->Element()->HasMasterPtr())
        {
            pNodeDown = pNodeDown->Element()->GetMasterPtr()->GetFirstBranch();
        }
        if (pNodeClk->Element()->HasMasterPtr())
        {
            pNodeClk = pNodeClk->Element()->GetMasterPtr()->GetFirstBranch();
        }

        if (!pNodeDown)
            pNodeClk = NULL;
        if (!pNodeClk)
            return;

        if (pNodeDown != pNodeClk)
        {
            if (!pNodeDown->Element()->TestClassFlag(CElement::ELEMENTDESC_NOANCESTORCLICK))
            {
                // The mouse up is on a different element than us.  This
                // can only happen if someone got capture and
                // forwarded the message to us.  Now we find the first
                // common anscestor and fire the click event from
                // there.
                pNodeClk = pNodeDown->GetFirstCommonAncestor(pNodeClk, NULL);
            }
            else
                pNodeClk = NULL;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::CElement
//
//-------------------------------------------------------------------------

CElement::CElement (ELEMENT_TAG etag, CDoc *pDoc)
#if DBG == 1 || defined(DUMPTREE)
    : _nSerialNumber( CTreeNode::s_NextSerialNumber++ )
#endif
{
    _pDoc = pDoc;
    WHEN_DBG( _pDocDbg = pDoc );
    pDoc->SubAddRef();

    Assert( pDoc && pDoc->AreLookasidesClear( this, LOOKASIDE_ELEMENT_NUMBER ) );
    Assert( pDoc->AreLookasides2Clear( this, LOOKASIDE2_ELEMENT_NUMBER ) );

    IncrementObjectCount(&_dwObjCnt);

     _etag = etag;
     WHEN_DBG( _etagDbg = etag );
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::~CElement
//
//-------------------------------------------------------------------------

CElement::~CElement()
{
    // NOTE:  Please cleanup in Passivate() if at all possible.
    //        Thread local storage can be deleted by the time this runs.
    Assert(!IsInMarkup());
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::CLock::CLock
//
//  Synopsis:   Lock resources in CElement object.
//
//-------------------------------------------------------------------------

CElement::CLock::CLock(CElement *pElement, ELEMENTLOCK_FLAG enumLockFlags)
{
    Assert(enumLockFlags < (1 <<(sizeof(_wLockFlags)*8) ));//USHRT_MAX);

#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pElement = pElement;
    if (_pElement)
    {
        _wLockFlags = pElement->_wLockFlags;
        pElement->_wLockFlags |= (WORD) enumLockFlags;
#if DBG==1
        if (!IsTagEnabled(tagDisableLockAR))
#endif
        {
            pElement->PrivateAddRef();
        }
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}


//+------------------------------------------------------------------------
//
//  Member:     CElement::CLock::~CLock
//
//  Synopsis:   Unlock resources in CElement object.
//
//-------------------------------------------------------------------------

CElement::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    if (_pElement)
    {
        _pElement->_wLockFlags = _wLockFlags;
#if DBG==1
        if (!IsTagEnabled(tagDisableLockAR))
#endif
        {
            _pElement->PrivateRelease();
        }
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}

//+------------------------------------------------------------------------
//
//  Member:     Passivate
//
//-------------------------------------------------------------------------

void
CElement::Passivate()
{
    CDoc * pDoc = Doc();

    // If we are in a tree, the tree will keep us alive
    Assert(!IsInMarkup());

    // Make sure we aren't on some delay release list somewhere
    Assert(!_fDelayRelease);

    // If we are passivating the current element (can only be the root), set it to NULL
    if (this == pDoc->_pElemCurrent)
    {
        Assert(Tag() == ETAG_ROOT);   // needed because ROOT doesn't get ExitTree
        pDoc->_pElemCurrent = NULL;
    }

    // Make sure we don't have any pending event tasks on the view
    if (_fHasPendingEvent)
    {
        pDoc->GetView()->RemoveEventTasks(this);
    }

    Assert(!HasMasterPtr());

    // Destroy slave markup, if any
    if (HasSlavePtr())
    {
        CElement * pElemSlave = DelSlavePtr();

        pElemSlave->DelMasterPtr();
        pElemSlave->Release();
    }

    if (HasPeerHolder())
    {
#if DBG == 1
        if (HasIdentityPeerHolder())
        {
            Assert (GetIdentityPeerHolder()->_ulRefs == 1);
        }
#endif
        // delete peer holder ptr and release the peer holder
        DelPeerHolder()->PrivateRelease();
    }

    if (HasPeerMgr())
    {
        CPeerMgr::EnsureDeletePeerMgr(this, /* fForce = */ TRUE);
    }

    if( HasWindowedMarkupContextPtr() )
    {
        CMarkup *pMakup = DelWindowedMarkupContextPtr();
        if (pMakup)
            pMakup->SubRelease();
    }

#ifndef NO_DATABINDING
    if (HasDataBindPtr())
    {
        DetachDataBindings();
    }
#endif // ndef NO_DATABINDING

    TakeCapture(FALSE);

    GWKillMethodCall (this, NULL, 0);

    if (_fHasImage)
    {
        ReleaseImageCtxts();
    }

    // Release layout engines if any.
    // Usual case is that we have at most one layout (HasLayoutPtr() == TRUE)
    if ( HasLayoutPtr() )
    {
        CLayout * pLayout = DelLayoutPtr();

        pLayout->Detach();
        pLayout->Release();
    }
    // We may have multiple layouts!
    else if ( HasLayoutAry() )
    {
        DelLayoutAry(); // will take care of detaching/releasing its layouts
    }

    //delete the related accessible object if there is one
    if ( HasAccObjPtr() )
    {
        delete DelAccObjPtr();
    }

    if (_fHasPendingFilterTask)
        Doc()->RemoveFilterTask(this);

    if (_fHasPendingRecalcTask)
        Doc()->RemoveExpressionTask(this);

    if (_pAA)
    {
        // clear up the FiltersCollection

        if( _fHasFilterSitePtr )
        {
            GetFilterSitePtr()->Release();
        }

        // Kill the cached style pointer if present.  super::passivate
        // will delete the attribute array holding it.
        if (_pAA->IsStylePtrCachePossible())
        {
            delete GetInLineStylePtr();
            delete GetRuntimeStylePtr();
        }
#if DBG==1
        else
            Assert( !GetInLineStylePtr() && !GetRuntimeStylePtr() );
#endif
    }

    super::Passivate();

    // Ensure Lookaside cleanup.  Go directly to document to avoid bogus flags
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_DATABIND) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_PEER) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_PEERMGR) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_ACCESSIBLE) == NULL);
    Assert(Doc()->GetLookasidePtr((DWORD *) this + LOOKASIDE_SLAVE) == NULL);
    Assert(Doc()->GetLookasidePtr2((DWORD *) this + LOOKASIDE2_MASTER) == NULL);
    Assert(Doc()->GetLookasidePtr2((DWORD *) this + LOOKASIDE2_WINDOWEDMARKUP) == NULL);

    pDoc->SubRelease();

    DecrementObjectCount(&_dwObjCnt);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF((CBase *)this, ISpecifyPropertyPages, NULL)
        QI_TEAROFF((CBase *)this, IPerPropertyBrowsing, NULL)
        QI_TEAROFF(this, ISupportErrorInfo, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement3, NULL)
        QI_HTML_TEAROFF(this, IHTMLElement4, NULL)
        QI_TEAROFF(this, IHTMLUniqueName, NULL);
        QI_TEAROFF(this, IHTMLDOMNode, NULL);
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_TEAROFF(this, IHTMLElementRender, NULL);
        QI_TEAROFF(this, IObjectIdentity, NULL);
        QI_TEAROFF(this, IServiceProvider, NULL);
        QI_TEAROFF(this, IRecalcProperty, NULL);
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) =
                    new CConnectionPointContainer(this, NULL);

            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);

            SetEventsShouldFire();
            break;
        }
#ifndef NO_DATABINDING
        QI_CASE(IHTMLDatabinding)
        {
            if (GetDBindMethods() == NULL)
                RRETURN(E_NOINTERFACE);

            hr = THR(CreateTearOffThunk(this, s_apfnIHTMLDatabinding, NULL, ppv));
            if (hr)
                RRETURN(hr);
            break;
        }
#endif // ndef NO_DATABINDING

        default:
        {
            const CLASSDESC *pclassdesc = ElementDesc();

            if (iid == CLSID_CElement)
            {
                *ppv = this;    // Weak ref
                return S_OK;
            }
            
            // If QI for IMarshal do not delegate to the behavior
            // because Trident does not support free-threaded calls in the case 
            // where the behavior supports custom marshaling
            if (iid == IID_IMarshal)
            {
                hr = E_NOINTERFACE;
                RRETURN (hr);
            }

            // Primary default interface, or the non dual
            // dispinterface return the same object -- the primary interface
            // tearoff.
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface ||
                 DispNonDualDIID(iid)))
            {
#ifndef WIN16
                hr = THR(CreateTearOffThunk(this, pclassdesc->_apfnTearOff, NULL, ppv, (void *)pclassdesc->_classdescBase._apHdlDesc->ppVtblPropDescs));
#else
                BYTE *pThis = ((BYTE *) (void *) ((CBase *) this)) - m_baseOffset;
                hr = THR(CreateTearOffThunk(pThis, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
#endif
                if (hr)
                    RRETURN(hr);

                break;
            }

            if (HasIdentityPeerHolder())
            {
                CPeerHolder *   pPeerHolder = GetIdentityPeerHolder();
                IUnknown *      pUnk;

                //
                // delegate to identity behavior;
                // thunk the interface pointers to element identity -
                // use element's IUnknown for subsequent QIs
                //
                hr = THR_NOTRACE(pPeerHolder->QueryPeerInterface(iid, (void**)&pUnk));
                if (S_OK == hr)
                {
                    hr = THR(::CreateTearOffThunk(
                        pUnk,
                        *(void **)pUnk,
                        NULL,
                        ppv,
                        (IPrivateUnknown*)this,
                        *(void **)(IPrivateUnknown*)this,
                        QI_MASK,
                        NULL));
                    ReleaseInterface(pUnk);
                }

                break;
            }

            hr = E_NOINTERFACE;
            RRETURN (hr);
            break;
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    DbgTrackItf(iid, "CElement", FALSE, ppv);

    return S_OK;
}


#if DBG == 1
BOOL        g_fDisableMarkupTrace;
CMarkup *   g_pMarkupTrace;
int         g_nSNMarkupTrace;
#endif

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateAddRef, IUnknown
//
//  Synopsis:   Private unknown AddRef.
//
//-------------------------------------------------------------------------
ULONG
CElement::PrivateAddRef()
{
    if( _ulRefs == 1 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        GetMarkupPtr()->AddRef();

#if DBG==1
        if (g_pMarkupTrace && !g_fDisableMarkupTrace &&
            (g_nSNMarkupTrace == 0 || g_nSNMarkupTrace == SN()) &&
            g_pMarkupTrace == GetMarkupPtr())
        {
            TraceTag((0, "markup %x AR from %ls %d", g_pMarkupTrace, TagName(), SN()));
            TraceCallers(0, 0, 12);
        }
#endif

    }

    return super::PrivateAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------
ULONG
CElement::PrivateRelease()
{
    CMarkup * pMarkup = NULL;

    if( _ulRefs == 2 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        pMarkup = GetMarkupPtr();

#if DBG==1
        if (g_pMarkupTrace && !g_fDisableMarkupTrace &&
            (g_nSNMarkupTrace == 0 || g_nSNMarkupTrace == SN()) &&
            g_pMarkupTrace == pMarkup)
        {
            TraceTag((0, "markup %x Rel from  %ls %d", g_pMarkupTrace, TagName(), SN()));
            TraceCallers(0, 0, 12);
        }
#endif

    }

    ULONG ret =  super::PrivateRelease();

    if( pMarkup )
    {
        pMarkup->Release();
    }

    return ret;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateEnterTree
//
//  Synopsis:   Ref counting fixup as tree entered.
//
//-------------------------------------------------------------------------
void
CElement::PrivateEnterTree()
{
    Assert( IsInMarkup() );
    super::PrivateAddRef();
    GetMarkupPtr()->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::PrivateExitTree
//
//  Synopsis:   Ref counting fixup as tree exited.
//
//-------------------------------------------------------------------------
void
CElement::PrivateExitTree( CMarkup * pMarkupOld)
{
    BOOL fReleaseMarkup = _ulRefs > 1;

    Assert( ! IsInMarkup() );
    Assert( pMarkupOld );

    // If we sent the EXITTREE_PASSIVATEPENDING bit then we
    // must also passivate right here.
    AssertSz( !_fPassivatePending || _ulRefs == 1, 
        "EXITTREE_PASSIVATEPENDING set and element did not passivate.  Talk to JBeda." );

    super::PrivateRelease();

    if ( fReleaseMarkup )
    {
        pMarkupOld->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     contains
//
//  Synopsis:   IHTMLElement method. returns a boolean  if PIelement is within
//              the scope of this
//
//-----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::contains(IHTMLElement * pIElement, VARIANT_BOOL *pfResult)
{
    CTreeNode     *pNode = NULL;
    HRESULT hr = S_OK;

    Assert ( pfResult );

    if ( !pfResult )
        goto Cleanup;

    *pfResult = VB_FALSE;
    if ( !pIElement )
        goto Cleanup;

    // get a CTreeNode pointer
    hr = THR(pIElement->QueryInterface(CLSID_CTreeNode, (void **)&pNode) );
    if ( hr == E_NOINTERFACE )
    {
        CElement *pElement;
        hr = THR(pIElement->QueryInterface(CLSID_CElement, (void **)&pElement) );
        if( hr )
            goto Cleanup;

        pNode = pElement->GetFirstBranch();
    }
    else if( hr )
        goto Cleanup;

    while (pNode &&
           DifferentScope(pNode, this))
    {
        // stop after the HTML tag
        if (pNode->Tag() == ETAG_ROOT)
            pNode = NULL;
        else
            pNode = pNode->Parent();
    }

    if ( pNode )
        *pfResult = VB_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::ClearRunCaches(DWORD dwFlags)
{
    CMarkup * pMarkup = GetMarkup();

    if (pMarkup)
    {
        pMarkup->ClearRunCaches(dwFlags, this);
    }

    RRETURN(S_OK);
}

BOOL
CElement::IsFormatCacheValid()
{
    CTreeNode * pNode;
    
    pNode = GetFirstBranch();
    while (pNode)
    {
        if (!pNode->IsFancyFormatValid() ||
            !pNode->IsCharFormatValid() ||
            !pNode->IsParaFormatValid())
            return FALSE;
        pNode = pNode->NextBranch();
    }

    return TRUE;
}


HRESULT
CElement::EnsureFormatCacheChange ( DWORD dwFlags)
{
    HRESULT hr = S_OK;

    //
    // If we're not in the tree, it really isn't
    // very safe to do what we do.  Since putting
    // the element in the tree will call us again,
    // simply returning should be safe
    //
    if (GetFirstBranch() == 0)
        goto Cleanup;

    if ( dwFlags & (ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF) )
    {
        hr = THR(ClearRunCaches(dwFlags));
        if(hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CElement::FireAccessibilityEvents(DISPID dispidEvent)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();

    if (pDoc)
    {
        // fire accesibility state change event.
        hr = THR(pDoc->FireAccessibilityEvents( dispidEvent, (CBase *)this, FALSE));
    }

    RRETURN(hr);
}

DeclareTag(tagPropChange, "Property changes", "OnPropertyChange");

//+------------------------------------------------------------------------
//
//  Member:     CElement::OnPropertyChange
//
//
//-------------------------------------------------------------------------

HRESULT
CElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT             hr = S_OK;
    CControlledFormatter cfo(this, dispid, dwFlags);
    BOOL                fYieldCurrency = FALSE;
    CTreeNode *         pNode = GetFirstBranch();
    CDoc *              pDoc = Doc();
    CCollectionCache *  pCollectionCache;
    CElement *          pElemCurrent = pDoc->_pElemCurrent;
    
    Assert( !ppropdesc || ppropdesc->GetDispid() == dispid );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );


    TraceTag((tagPropChange, "Property changed, flags:%ld", dwFlags));

    // if this is an event property that has just been hooked up then we need to 
    // start firing events for this element. we want to do this event if this 
    // element is not yet in the tree (i.e. no pNode) so that when it IS put into
    // the tree we can fire events.
    //
    // NOTE: a good alternative implementation is to have this flag on the AttrArray.
    // then with dword stored, we could have event level granularity and control.
    // to support this all we need to do is change the implementation fo SetEventsShouldFire()
    // and ShouldEventsFire() to use the AA.
    if (dispid >= DISPID_EVENTS && dispid < DISPID_EVENTS + DISPID_EVPROPS_COUNT)
    {
        SetEventsShouldFire();

        // don't expose this to the outside.
        if ( dispid == DISPID_EVPROP_ONATTACHEVENT)
            goto Cleanup;
    }

    if (DISPID_A_BEHAVIOR == dispid || DISPID_CElement_className == dispid || DISPID_UNKNOWN == dispid)
    {
        if (DISPID_A_BEHAVIOR == dispid)
        {
            pDoc->SetCssPeersPossible();
        }

        hr = THR(ProcessPeerTask(PEERTASK_RECOMPUTEBEHAVIORS));
        if (hr)
            goto Cleanup;
    }

    // NOTE (alexz) a lot of stuff below this check is supposed to work when the element is not in a markup
    if(!IsInMarkup() || !pNode)
        goto Cleanup;

    Verify(OpenView());

    // some changes invalidate collections
    if ( dwFlags & ELEMCHNG_UPDATECOLLECTION )
    {
        // TODO rgardner, for now Inval all the collections, whether they are filtered on property values
        // or not. We should tweak the PDL code to indicate which collections should be invaled, or do
        // this intelligently through some other mechanism, we should tweak this
        // when we remove the all collection.
        Assert(IsInMarkup());

        pCollectionCache = GetMarkup()->CollectionCache();
        if (pCollectionCache)
            pCollectionCache->InvalidateAllSmartCollections();

        // Clear this flag: exclusive or
        dwFlags ^= ELEMCHNG_UPDATECOLLECTION;
    }

    switch(dispid)
    {
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_A_LISTSTYLEIMAGE:
        // Release any dispid's which hold image contexts
        DeleteImageCtx(dispid);
        break;
    }

    if (!cfo.Init(&hr))
        goto Cleanup;
    
    switch (dispid)
    {
    case DISPID_A_CURSOR:
        // Do a lazy cursor update
        pDoc->DeferSetCursor();
        break;
    case DISPID_A_HIDEFOCUS:
        if (this == pDoc->_pElemCurrent)
        {
            //Refresh the focus rect
            pDoc->GetView()->SetFocus(this, pDoc->_lSubCurrent);
        }
        break;
    case DISPID_A_POSITION:
        if (IsInMarkup())
        {
            pCollectionCache = GetMarkup()->CollectionCache();
            if (pCollectionCache)
                pCollectionCache->InvalidateItem(CMarkup::REGION_COLLECTION);

            SendNotification(NTYPE_ZPARENT_CHANGE);
        }
        break;

    case STDPROPID_XOBJ_LEFT:
    case STDPROPID_XOBJ_RIGHT:
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            const CCharFormat  * pCF = pNode->GetCharFormat();
            BOOL fElementVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            if (pFF->IsPositioned())
            {
                //
                // If positioned absolute and width is auto, left & right control the width
                // of the element, so fire a resize instead of reposition.
                // Relatively positioned elements reposition, not resize.
                // Also, We do not resize absolute positioned table cells, so reposition. (bug 77275)
                //
                if(   pFF->IsAbsolute() 
                   && pFF->GetLogicalWidth(fElementVertical, fWritingModeUsed).IsNullOrEnum() 
                   && !IsTablePart())
                {
                    dwFlags |= ELEMCHNG_SIZECHANGED;
                }               
                else
                {
                    RepositionElement();
                }
            }

            if (dispid == STDPROPID_XOBJ_LEFT)
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELLEFT));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSLEFT));
            }
            else
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_PIXELRIGHT));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_POSRIGHT));
            }
        }
        break;

    case STDPROPID_XOBJ_TOP:
    case STDPROPID_XOBJ_BOTTOM:
        {
            CTreeNode * pNode = GetFirstBranch();
            const CFancyFormat * pFF = pNode->GetFancyFormat();
            const CCharFormat  * pCF = pNode->GetCharFormat();
            BOOL fElementVertical = pCF->HasVerticalLayoutFlow();
            BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

            //
            // if height is auto, and the bottom is not auto then the size
            // of the element if absolute can change based on it's top & bottom.
            // So, fire a resize instead of reposition. If bottom is auto,
            // then the element is sized to content.
            //
            if (    pFF->IsAbsolute()
                &&  pFF->GetLogicalHeight(fElementVertical, fWritingModeUsed).IsNullOrEnum()
                &&  (dispid != STDPROPID_XOBJ_TOP || !pFF->GetLogicalPosition(SIDE_BOTTOM, fElementVertical, fWritingModeUsed).IsNullOrEnum()))
            {
                dwFlags |= ELEMCHNG_SIZECHANGED;
            }
            else if (!pFF->IsPositionStatic())
            {
                RepositionElement();
            }

            if (dispid == STDPROPID_XOBJ_TOP)
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELTOP));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSTOP));
            }
            else
            {
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_PIXELBOTTOM));
                IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE2_POSBOTTOM));
            }
        }
        break;

    case STDPROPID_XOBJ_WIDTH:
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELWIDTH));
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSWIDTH));
        break;

    case STDPROPID_XOBJ_HEIGHT:
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_PIXELHEIGHT));
        IGNORE_HR(FireOnChanged(DISPID_IHTMLSTYLE_POSHEIGHT));
        break;

    case DISPID_A_ZINDEX:
        if (!IsPositionStatic())
        {
            ZChangeElement();
        }

        pDoc->FixZOrder();
        break;

    case DISPID_CElement_tabIndex:
        hr = OnTabIndexChange();
        break;
    
    case DISPID_CElement_disabled:
        // if (fHasLayout)
        {
            BOOL        fEnabled    = !GetAAdisabled();
            CElement *  pNewDefault = 0;
            CElement *  pOldDefault = 0;
            CElement *  pSavDefault = 0;

            // we should not be the default button before becoming enabled
            Assert(!(fEnabled && _fDefault));

            if (!_fDefault && fEnabled)
            {
                // this is not the previous default button
                // look for it
                pOldDefault = FindDefaultElem(TRUE);
            }

            if (pDoc->_pElemCurrent == this && !fEnabled)
            {
                // this is the case where the button disables itself
                pOldDefault = this;
            }

            // if this element act like a button
            // becomes disabled or enabled
            // we need to make sure this is recorded in the cached
            // default element of the doc or form
            if (TestClassFlag(CElement::ELEMENTDESC_DEFAULT))
            {
                // try to find a new default
                // set _fDefault to FALSE in order to avoid
                // FindDefaultLayout returning this site again.
                // because FindDefaultLayout will use _fDefault
                _fDefault = FALSE;
                pSavDefault = FindDefaultElem(TRUE, TRUE);
                if (pSavDefault == this || !fEnabled)
                {
                    CFormElement    *pForm = GetParentForm(); 
                    if (pSavDefault)
                    {
                        pSavDefault->_fDefault = TRUE;
                    }
                    if (pForm)
                        pForm->_pElemDefault = pSavDefault;
                    else
                        pDoc->_pElemDefault = pSavDefault;
                }
            }
            if (!pDoc->_pElemCurrent->_fActsLikeButton || _fDefault)
            {
                _fDefault = FALSE;
                pNewDefault = pSavDefault ? pSavDefault : FindDefaultElem(TRUE, TRUE);
            }

            // if this was the default, and now becoming disabled
            _fDefault = FALSE;

            if (pNewDefault != pOldDefault)
            {
                if (pOldDefault)
                {
                    CNotification   nf;

                    nf.AmbientPropChange(pOldDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);

                    // refresh the old button
                    pOldDefault->_fDefault = FALSE;
                    pOldDefault->Notify(&nf);
                    pOldDefault->Invalidate();
                }

                if (pNewDefault)
                {
                    CNotification   nf;

                    Assert(pNewDefault->_fActsLikeButton);
                    nf.AmbientPropChange(pNewDefault, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                    pNewDefault->_fDefault = TRUE;
                    pNewDefault->Notify(&nf);
                    pNewDefault->Invalidate();
                }
            }
        }
        break;

    case DISPID_A_VISIBILITY:
        {
            //
            //  Notify element and all descendents of the change
            //

            SendNotification(NTYPE_VISIBILITY_CHANGE);

            //
            //  If the element is being hidden, ensure it and any descendent which inherits visibility are the current element
            //  (Do this by, within this routine, pretending that this element is the current element)
            //

            fYieldCurrency = !!pNode->GetCharFormat()->IsVisibilityHidden();

            CTreeNode *pMasterCurrent = pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup( GetMarkupPtr() );

            if (    fYieldCurrency
                &&  pElemCurrent
                &&  ( pMasterCurrent && pMasterCurrent->SearchBranchToRootForScope(this) )
                &&  pElemCurrent->GetFirstBranch()->GetCharFormat()->IsVisibilityHidden())
            {
                pElemCurrent = this;
            }
        }
        break;

    case DISPID_A_DISPLAY:
        //
        //  If the element is being hidden, ensure it and none of its descendents are the current element
        //  (Do this by, within this routine, pretending that this element is the current element)
        //

        if (pNode->GetCharFormat()->IsDisplayNone())
        {
            fYieldCurrency = TRUE;

            if (pElemCurrent && pElemCurrent->GetFirstBranch()->SearchBranchToRootForScope(this))
            {
                pElemCurrent = this;
            }
        }
#ifdef NEVER
        else
        {
            dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;
        }
#endif
        break;

    case DISPID_A_ROTATE:
    case DISPID_A_ZOOM:
        // Explicit tranformation forces us to have a layout
        // Change of layoutness will be handled by common code below.
        
        // If layoutness doesn't change, the element doesn't need to
        // be remeasured, but parents need to be resized because of change 
        // in aparent bounds of this element.
        if (   cfo.HasLayoutAfterFormatsChange()
            && cfo.HadLayoutBeforeFormatsChange()
           )
        {
            dwFlags |= ELEMCHNG_REMEASUREINPARENT;
        }
        break;

    case DISPID_A_MARGINTOP:
    case DISPID_A_MARGINLEFT:
    case DISPID_A_MARGINRIGHT:
    case DISPID_A_MARGINBOTTOM:
        // BackCompat: Margins act like padding on the BODY
        // StrictCSS1: Margins act normally.
        if (    (   Tag() == ETAG_FRAMESET
                 || Tag() == ETAG_BODY     )
            &&  !GetMarkup()->IsHtmlLayout() )
        {
            dwFlags |= ELEMCHNG_REMEASURECONTENTS;
            dwFlags &= ~(ELEMCHNG_SIZECHANGED | ELEMCHNG_REMEASUREINPARENT);
        }
        break;
    case DISPID_A_CLIP:
    case DISPID_A_CLIPRECTTOP:
    case DISPID_A_CLIPRECTRIGHT:
    case DISPID_A_CLIPRECTBOTTOM:
    case DISPID_A_CLIPRECTLEFT:
        // NOTE (KTam): If element providing pNearestLayout has multi layouts, we need
        // to figure out how to apply clip rects to all of them.  Fix this later, for now
        // we'll just get the nearest layout.
        if (cfo.HasLayoutAfterFormatsChange())
        {
            CDispNode* pDispNode = cfo.GetUpdatedNearestLayout()->GetElementDispNode(this);
            if (pDispNode)
            {
                if (pDispNode->HasUserClip())
                {
                    CSize size;

                    cfo.GetUpdatedNearestLayout()->GetSize(&size);
                    cfo.GetUpdatedNearestLayout()->SizeDispNodeUserClip(pDoc->GetView()->GetMeasuringDevice(mediaTypeNotSet), size);
                }

                // we need to create a display node that can have user
                // clip information, and ResizeElement will force this
                // node to be created.  Someday, we might be able to morph
                // the existing display node for greater efficiency.
                else
                {
                    ResizeElement();
                }
            }
        }
        break;
    }

    if(cfo.ShouldComputeFormats())
    {
        //
        // Notify the layout of the property change, layout fixes up
        // its display node to handle visibility/background changes.
        //
        if (cfo.HasLayoutAfterFormatsChange())
        {
            cfo.GetUpdatedNearestLayoutInfo()->OnPropertyChange(dispid, dwFlags);
        }
    
        if(     (cfo.HadLayoutBeforeFormatsChange() && !cfo.HasLayoutAfterFormatsChange())
            ||  (!cfo.HadLayoutBeforeFormatsChange() && cfo.HasLayoutAfterFormatsChange()))
        {
            if(this == pDoc->_pElemCurrent)
            {
                cfo.GetUpdatedNearestLayoutInfo()->ElementOwner()->BecomeCurrent(pDoc->_lSubCurrent);
            }

            dwFlags |= ELEMCHNG_REMEASUREINPARENT;
            dwFlags &= ~ELEMCHNG_SIZECHANGED;
        }
    }
    
    if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED))
    {
        MinMaxElement();
    }

    // TODO (dmitryt, 8/22/00) I need to cleanup this code.
    // 1. Some ELEMCHNG_ bits come from PDL files, like style.pdl, while others are 
    //      calculated here. This should be in one single place - in the code.
    // 2. I need to eliminate "RemeasureElement" and "RemeasureAndResize" 
    //      and "RemeasureInParentContext" and replace them all with "ResizeElement"
    //      There is no difference between them except layered bugs.
    //      RESIZE starts recalc from the element in question and if its size changes as a result
    //      of recalc - then cp range in parent is invalidated. Remeasure starts recalc right 
    //      at the cp range in parent. The only case when we need a remeasure is when 
    //      size of child doesn't change but we need action in parent (to hook the child's 
    //      dispnode, like in case when child is getting display:block back)
    // 3. Invalidate the whole text of element in this combined notification (as in
    //    code below where CharsResize+ResizeElement are called)
    
    if(dispid == DISPID_A_DISPLAY)
    {
        CNotification   nf;
        nf.CharsResize(0, GetElementCch(), pNode);
        GetMarkup()->Notify(nf);

        RemeasureInParentContext();
    }
    else if(dispid == DISPID_A_ZOOM)
    {
        ResizeElement(NFLAGS_FORCE);
    }
    else if (dwFlags & ELEMCHNG_REMEASUREINPARENT)
    {
        //(dmitryt) should be ResizeElement
        RemeasureInParentContext();
    }
    else if (   dwFlags & ELEMCHNG_SIZECHANGED
             || (   (dwFlags & ELEMCHNG_RESIZENONSITESONLY)
                 && !cfo.HasLayoutAfterFormatsChange()
                )
            )
    {
        ResizeElement();
    }

    if (dwFlags & (ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS))
    {
        RemeasureElement( dwFlags & ELEMCHNG_REMEASUREALLCONTENTS
                            ? NFLAGS_FORCE
                            : 0);
    }

    // we need to send the display change notification after sending
    // the RemeasureInParent notification. RemeasureInParent marks the
    // ancestors dirty, therefore any ZParentChange notifications fired
    // from DisplayChange are queued up until the ZParent is calced.
    if (    dispid == DISPID_A_DISPLAY
        ||  dispid == DISPID_CElement_className
        ||  dispid == DISPID_UNKNOWN)
    {
        CNotification   nf;

        nf.DisplayChange(this);

        SendNotification(&nf);
    }


    if (this == pElemCurrent)
    {

        
        if (    !IsEnabled()
            ||  fYieldCurrency)
        {         
            CElement* pElemPrev = pDoc->_pElemCurrent;
            
            IGNORE_HR(pNode->Parent()->Element()->BubbleBecomeCurrent(0));

            if ( pDoc->_pCaret &&               
                 pDoc->_pCaret->IsInsideElement( pElemPrev ) == S_OK )
            {
                pDoc->_pCaret->Hide();
            }                   
        }

        else if (   dispid == DISPID_A_VISIBILITY
                ||  dispid == DISPID_A_DISPLAY)
        {
            pDoc->GetView()->SetFocus(pDoc->_pElemCurrent, pDoc->_lSubCurrent);
        }
    }

    if (!(dwFlags & ELEMCHNG_DONTFIREEVENTS))
    {
    
        // once we start firing events, the pLayout Old is not reliable since script can
        // change the page.


        IGNORE_HR(FireOnChanged(dispid));

        pDoc->OnDataChange();

        // fire the onpropertychange script event, but only if it is possible
        //   that someone is actually listeing. otherwise, don't waste the time.
        //
        if (ShouldFireEvents() && DISPID_UNKNOWN != dispid)
        {
            hr = THR(Fire_PropertyChangeHelper(dispid, dwFlags, ppropdesc));
            if ( hr )
                goto Cleanup;
        }

        // Accessibility state change check and event firing
        if (   (   (    (ppropdesc 
                    && ((dwFlags | ppropdesc->GetdwFlags()) & ELEMCHNG_ACCESSIBILITY) )
                || (dwFlags & ELEMCHNG_ACCESSIBILITY) ))
            && (HasAccObjPtr() || IsSupportedElement(this)))
        {
            hr = THR(FireAccessibilityEvents(NULL));
        }        
    }

    dwFlags &= ~(ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF);

    if ( dispid == DISPID_A_EDITABLE )
    {
        IUnknown* pUnknown = NULL;
        IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
        IGNORE_HR( pDoc->NotifySelection( EDITOR_NOTIFY_EDITABLE_CHANGE, pUnknown ));
        ReleaseInterface( pUnknown );
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     OpenView
//
//  Synopsis:   Open the view associated with the element - That view is the one
//              associated with the CDoc (the only view there is right now!)
//
//  Returns:    TRUE if the view was successfully opened, FALSE if we're in the
//              middle of rendering
//
//-----------------------------------------------------------------------------
BOOL
CElement::OpenView()
{
    // So far there's only 1 view, so just get it from the doc.  Multiple views
    // will obviously change this.

    return Doc()->OpenView();
}


//+----------------------------------------------------------------------------
//
//  Member:     MinMaxElement
//              ResizeElement
//              RemeasureElement
//              RemeasureInParentContext
//              RepositionElement
//              ZChangeElement
//
//  Synopsis:   Notfication send helpers
//
//  Arguments:  grfFlags - NFLAGS_xxxx flags
//
//-----------------------------------------------------------------------------

// NOTE (KTam): There may be an issue here wrt elements with
// multiple layouts sending notifications to layouts which haven't
// been expecting them.  E.g. consider MinMaxElement called on an
// element w/ 2 layouts, one of which is _fMinMaxValid and one which
// isn't.  Currently, because at least one is _fMinMaxValid, the
// notification will be sent, and the generic broadcast mechanism
// in CMarkup::NotifyElement() will send it to all its layouts,
// even the one for which _fMinMaxValid == FALSE (and hence, if it
// were the only layout, would not have gotten this notification).
// The same situation arises with ResizeElement() CMarkup::NotifyElement() will send it to all its layouts,
// even the one for which _fMinMaxValid == FALSE (and hence, if it
// were the only layout, would not have gotten this notification).
// The same situation arises with ResizeElement().  The approach I've
// taken is that it's safer to fire more notifications than fewer,
// and if we discover we can optimize (say, by unifying checking with
// sending for multiple layouts such that "check and send" for
// each layout int he array) later, then we can do so.
void
CElement::MinMaxElement(DWORD grfFlags)
{

    CLayout * pLayout;
    if ( !HasLayoutAry() )
    {
        // Element has at most 1 layout.  GetLayoutPtr() will ret.
        // NULL if it doesn't have a layout (we have never created
        // layouts in this fn, and so don't want to call GetUpdatedLayout)
        // It probably doesn't make sense to create layouts here anyways,
        // because they would get created w/ _fMinMaxValid == FALSE, and
        // hence the notification still wouldn't fire (i.e. the only
        // effect of this fn would be to create a layout, which should
        // not be an intentional sideeffect).

        pLayout = GetLayoutPtr();


        if (    pLayout
            &&  (   pLayout->_fMinMaxValid 
                //  Table row does it on behalf of table cells
                ||  Tag() == ETAG_TR)
            )
        {
            SendNotification(NTYPE_ELEMENT_MINMAX, grfFlags);
        }
    }
    else
    {
        if ( EnsureLayoutAry()->WantsMinMaxNotification() )
            SendNotification(NTYPE_ELEMENT_MINMAX, grfFlags);
    }
}

void
CElement::ResizeElement(DWORD grfFlags)
{
    //
    //  Resize notifications are only fired when:
    //    a) The element does not have a layout (and must always notify its container) or
    //    b) It has a layout, but it's currently "clean" and
    //        The element is not presently being sized by its container
    //

    CLayout * pLayout;
    CLayout * pParentLayout = NULL;
    CElement * pParentElement = NULL;

    if ( !HasLayoutAry() )
    {
        // Element has at most 1 layout.  GetLayoutPtr() will ret.
        // NULL if it doesn't have a layout (we have never created
        // layouts in this fn, and so don't want to call GetUpdatedLayout)
        pLayout = GetLayoutPtr();

        // TODO: IsCalcingSize() tells us whether we are being calc'ed,
        // but not whether our parent is calcing us (since we can be in
        // CalcSize() either due to our parent calling us, or due to
        // a DoLayout() on us).  So in order to meet condition b, we need
        // to check out Parent->IsCalcingSize().

        // THIS CHANGE IS NOT REFLECTED IN CLayoutAry::WantsResizeNotification()
        // since it's not an interesting scenario for IE5.5 RTM.  Revisit for
        // live view templates.

        pParentElement = GetUpdatedParentLayoutElement();
        if ( pParentElement )
            pParentLayout = pParentElement->HasLayoutPtr() ? pParentElement->GetLayoutPtr() : NULL;

        //don't send notification if (pLayout && pParentLayout && pParentLayout->IsCalcingSize())

        if (    !pLayout
            ||  !pParentLayout 
            ||  !pParentLayout->IsCalcingSize())
        {
            SendNotification(NTYPE_ELEMENT_RESIZE, grfFlags);
        }
    }
    else
    {
        if ( EnsureLayoutAry()->WantsResizeNotification() )
            SendNotification(NTYPE_ELEMENT_RESIZE, grfFlags);
    }
}

void
CElement::RemeasureInParentContext(DWORD grfFlags)
{
    SendNotification(NTYPE_ELEMENT_RESIZEANDREMEASURE, grfFlags);
}

void
CElement::RemeasureElement(DWORD grfFlags)
{
    SendNotification(NTYPE_ELEMENT_REMEASURE, grfFlags);
}

void
CElement::RepositionElement(DWORD grfFlags, CPoint *ppt, CLayoutContext *pLayoutContext FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    CNotification   nf;
    Assert(!IsPositionStatic(FCPARAM) || GetFirstBranch()->GetCharFormat(FCPARAM)->_fRelative);

    nf.Initialize(NTYPE_ELEMENT_REPOSITION, this, GetFirstBranch(), NULL, grfFlags);
    if (ppt)
        nf.SetData(*ppt);

    nf.SetLayoutContext(pLayoutContext);

    SendNotification(&nf);
}

void
CElement::ZChangeElement(DWORD grfFlags, CPoint * ppt, CLayoutContext *pLayoutContext FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // NOTE (KTam): Another way to create this notification is via the generated
    // ElementZChange fn -- currently not in use.
    
    CMarkup *       pMarkup = GetMarkup();
    CNotification   nf;

    Assert(!IsPositionStatic(FCPARAM) || GetFirstBranch()->GetCharFormat(FCPARAM)->_fRelative);
    Assert(pMarkup);

    nf.Initialize(NTYPE_ELEMENT_ZCHANGE, this, GetFirstBranch(), NULL, grfFlags);
    if (ppt)
        nf.SetData(*ppt);

    nf.SetLayoutContext(pLayoutContext);

    TraceTagEx((tagNotifyZChange, TAG_NONAME|TAG_INDENT, "(ZChangeElement: e=0x%x,%s pt(%d,%d)",
                this, TagName(), ppt ? ppt->x : 0, ppt ? ppt->y : 0 ));
    TraceCallers(tagNotifyZChange, 1, 1);

    pMarkup->Notify(nf);

    TraceTagEx((tagNotifyZChange, TAG_NONAME|TAG_OUTDENT, ")ZChangeElement"));
}


//+----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send a notification associated with this element
//
//-----------------------------------------------------------------------------

void
CElement::SendNotification(CNotification *pNF)
{
    CMarkup * pMarkup = GetMarkup();

    if (pMarkup)
    {
        pMarkup->Notify(pNF);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SendNotification
//
//  Synopsis:   Send a notification associated with this element
//
//  Arguments:  ntype    - NTYPE_xxxxx flag
//              grfFlags - NFLAGS_xxxx flags
//
//-----------------------------------------------------------------------------
void
CElement::SendNotification(
    NOTIFYTYPE  ntype,
    DWORD       grfFlags,
    void *      pvData)
{
    CMarkup *   pMarkup = GetMarkup();

    if ( pMarkup )
    {
        CNotification   nf;

        Assert( GetFirstBranch() );

        nf.Initialize(ntype, this, GetFirstBranch(), pvData, grfFlags);

        pMarkup->Notify(nf);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     DirtyLayout
//
//  Synopsis:   Dirty the layout engine associated with an element
//
//-----------------------------------------------------------------------------
void
CElement::DirtyLayout(
    DWORD   grfLayout)
{
    if (ShouldHaveLayout())
    {
        GetUpdatedLayoutInfo()->Dirty( grfLayout );
    }
}

#ifdef WIN16
#pragma code_seg ("ELEMENT_2_TEXT")
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CElement::HitTestPoint, public
//
//  Synopsis:   Determines if this element is hit by the given point
//
//  Arguments:  [pt]        -- Point to check against.
//              [ppSite]    -- If there's a hit, the site that was hit.
//              [ppElement] -- If there's a hit, the element that was hit.
//              [dwFlags]   -- HitTest flags.
//
//  Returns:    HTC
//
//  Notes:      Only ever returns a hit if this element is a relatively
//              positioned element.
//
//----------------------------------------------------------------------------

HTC
CElement::HitTestPoint(CMessage*    pMessage,
                       CTreeNode ** ppNodeElement,
                       DWORD        dwFlags)
{
    // TODO (KTam): I suspect we don't even need to get a layout here; the only
    // apparent reason for its retrieval is to get the view.  However, there may
    // be issues with this call creating the layout in question?
    CLayout *   pLayout = GetUpdatedNearestLayout( GUL_USEFIRSTLAYOUT );
    HTC         htc     = HTC_NO;
    CLayoutContext * pLayoutContext = NULL;

    if (pLayout)
    {
        CDispNode * pDispNodeOut = NULL;
        COORDINATE_SYSTEM cs = COORDSYS_GLOBAL;
        CView *     pView        = pLayout->GetView();
        POINT       ptContent;

        if (pView)
        {
            *ppNodeElement = GetFirstBranch();

            htc = pLayout->GetView()->HitTestPoint(
                                                pMessage->pt,
                                                &cs,
                                                this,
                                                dwFlags,
                                                &pMessage->resultsHitTest,
                                                ppNodeElement,
                                                ptContent,
                                                &pDispNodeOut,
                                                &pLayoutContext);
        }
    }

    return htc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetRange
//
//  Synopsis:   Returns the range of char's under this element including the
//              end nodes
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetRange(long * pcpStart, long * pcch)
{
    CTreePos *ptpStart, *ptpEnd;

    Assert(GetFirstBranch());

    GetTreeExtent(&ptpStart, &ptpEnd);

    //
    // The range returned include the WCH_NODE characters for the element
    //
    *pcpStart = ptpStart->GetCp();
    *pcch = ptpEnd->GetCp() - *pcpStart + 1;
    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//  Notes:      This default implementation assumes that the element encloses
//              a text range (e.g. anchor, label). Other elements (buttons,
//              body, image, checkbox, radio button, input file, image map
//              area) must override this function to supply the correct shape.
//
//  $$ktam:     Think about what is the desired behaviour for focus shapes in
//              multilayout scenarios; consider an element broken across two
//              containers -- we may need to return a collection of shapes.
//              Right now we just return the shape corresponding to the first
//              layout.
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    HRESULT hr = S_FALSE;

    Assert(ppShape);

    *ppShape = NULL;

    if (GetAAhideFocus())
    {
        hr = S_OK;
        goto Cleanup;
    }

    // First check if the identity behavior wants to supply a focus rect
    if (HasIdentityPeerHolder())
    {
        IElementBehaviorFocus * pIFocus = NULL;

        if (S_OK == GetIdentityPeerHolder()->QueryPeerInterface(
                                            IID_IElementBehaviorFocus,
                                            (void**)&pIFocus))
        {
            RECT rect = g_Zero.rc;

            if (S_OK == pIFocus->GetFocusRect(&rect))
            {
                CRectShape *pShape = new CRectShape;
                if (!pShape)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    pShape->_rect = rect;
                    *ppShape = pShape;
                    hr = S_OK;
                }
            }
            ReleaseInterface(pIFocus);
            goto Cleanup;
        }
    }

    // By default, provide focus shape only for 
    // 1) elements that had focus shape in IE4 (compat)
    // 2) elements that have a tab index specified (#40434)
    //
    // In IE6, we will introduce a CSS style that lets elements override this
    // this behavior to turn on/off focus shapes.

    if (GetAAtabIndex() < 0)
    {
        switch (Tag())
        {
        case ETAG_A:
        case ETAG_LABEL:
        case ETAG_IMG:
            break;
        default:
            {
                CDefaults * pDefaults = GetDefaults();

                // Draw the focus rect if defaults.tabStop is set.
                if (pDefaults && pDefaults->GetAAtabStop())
                    break;
            }
            goto Cleanup;
        }
    }

    if (ShouldHaveLayout())
    {
        CRect       rc;
        CLayout *   pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );

        if (!pLayout)
            goto Cleanup;

        pLayout->GetClientRect(&rc);
        if (rc.IsEmpty())
            goto Cleanup;

        CRectShape *pShape = new CRectShape;
        if (!pShape)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        if (_fEditable && GetFirstBranch()->GetFancyFormat()->_fContentEditable)
            rc.InflateRect(1, 1);

        pShape->_rect = rc;
        *ppShape = pShape;

        hr = S_OK;
    }
    else
    {
        long            cpStart, cch;
        CFlowLayout *   pFlowLayout     = GetFlowLayout( GUL_USEFIRSTLAYOUT );

        if (!pFlowLayout)
            goto Cleanup;

        cch = GetFirstAndLastCp( &cpStart, NULL );
        // GetFirstAndLast gets a cpStart + 1. We need the element's real cpStart
        // Also, the cch is less than the real cch by 2. We need to add this back
        // in so RegionFromElement can get the correct width of this element.
        hr = THR(pFlowLayout->GetWigglyFromRange(pdci, cpStart - 1, cch + 2, ppShape));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  CElement::GetImageUrlCookie
//
//  Returns a Adds the specified URL to the url image cache on the doc
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetImageUrlCookie(LPCTSTR lpszURL, LONG *plCtxCookie, BOOL fForceReload)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    LONG            lNewCookie = 0;

    // Element better be in the tree when this function is called
    Assert (pDoc);

    if (lpszURL && *lpszURL)
    {
        hr = pDoc->AddRefUrlImgCtx(lpszURL, this, &lNewCookie, fForceReload);
        if(hr)
            goto Cleanup;
    }

Cleanup:
    *plCtxCookie = lNewCookie;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  CElement::AddImgCtx
//
//  Adds the info specified in ImgCtxInfo on the attr array, releasing
//  the current value if there is one.
//
//-------------------------------------------------------------------------

HRESULT
CElement::AddImgCtx(DISPID dispID, LONG lCookie)
{
    HRESULT hr = S_OK;
    CDoc    * pDoc = Doc();
    AAINDEX iCookieIndex;

    iCookieIndex = FindAAIndex(dispID, CAttrValue::AA_Internal);

    if (iCookieIndex != AA_IDX_UNKNOWN)
    {
        // Remove the current entry
        DWORD dwCookieOld = 0;

        if (GetSimpleAt(iCookieIndex, &dwCookieOld) == S_OK)
        {
            pDoc->ReleaseUrlImgCtx(LONG(dwCookieOld), this);
        }
    }

    _fHasImage = TRUE;

    hr = THR(AddSimple(dispID, DWORD(lCookie), CAttrValue::AA_Internal));

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseImageCtxts
//
//  Synopsis:   Finds any image contexts associated with this element,
//              and frees them up.  Cookies can be held for LI bullets
//              and for background images.
//
//-----------------------------------------------------------------------------

void
CElement::ReleaseImageCtxts()
{
    CDoc * pDoc = Doc();
    AAINDEX iCookieIndex;
    DWORD   dwCookieOld = 0;
    int     n;

    if (!_fHasImage)
        return;         // nothing to do, bail

    for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
    {
        // Check for a bg url image cookie in the standard attr array
        iCookieIndex = FindAAIndex(s_aryImgDispID[n].cacheID,
                                   CAttrValue::AA_Internal);

        if (iCookieIndex != AA_IDX_UNKNOWN &&
            GetSimpleAt(iCookieIndex, &dwCookieOld) == S_OK)
        {
            pDoc->ReleaseUrlImgCtx((LONG)dwCookieOld, this);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteImageCtx
//
//  Synopsis:   Finds any image contexts associated with this element,
//              corresponding to the dispid and free it up.  Cookies
//              can be held for LI bullets and for background images.
//
//-----------------------------------------------------------------------------

void
CElement::DeleteImageCtx(DISPID dispid)
{
    CDoc *      pDoc = Doc();
    CAttrArray* pAA;

    if (_fHasImage && (pAA = *GetAttrArray()) != NULL)
    {
        int n;
        for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
        {
            if (dispid == s_aryImgDispID[n].propID)
            {
                long lCookie;

                if ( pAA->FindSimpleInt4AndDelete(s_aryImgDispID[n].cacheID,
                                               (DWORD *)&lCookie) )
                {
                    // Release UrlImgCtxCacheEntry
                    pDoc->ReleaseUrlImgCtx(lCookie, this);
                }
                break;
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     GetSourceIndex
//
//-------------------------------------------------------------------------


long
CElement::GetSourceIndex ()
{
    CTreeNode * pNodeCurr;

    if ( Tag() == ETAG_ROOT )
        return -1;

    pNodeCurr = GetFirstBranch();
    if ( !pNodeCurr )
        return -1;
    else
    {
        Assert( !pNodeCurr->GetBeginPos()->IsUninit() );
        return pNodeCurr->GetBeginPos()->SourceIndex()-1; // subtract one because of ETAG_ROOT
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CompareZOrder
//
//  Synopsis:   Compare the z-order of two elements
//
//  Arguments:  pElement - The CElement to compare against
//
//  Returns:    Greater than zero if this element is greater
//              Less than zero if this element is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------

MtDefine( ZCompares, Metrics, "Calls to CElement::CompareZOrder" )

long
CElement::CompareZOrder(
    CElement *  pElement)
{
    long    lCompare;

    MtAdd( Mt(ZCompares), +1, 0 );

    lCompare = GetFirstBranch()->GetCascadedzIndex() - pElement->GetFirstBranch()->GetCascadedzIndex();

    if (!lCompare)
    {
        lCompare = GetSourceIndex() - pElement->GetSourceIndex();
    }

    return lCompare;
}


//+------------------------------------------------------------------------
//
//  Member:     GetTreeExtent
//
//  Synopsis:   Return the edge node pos' for this element.  Pretty
//              much just walks the context chain and gets the first
//              and last node pos'.
//
//-------------------------------------------------------------------------
void
CElement::GetTreeExtent(
    CTreePos ** pptpStart,
    CTreePos ** pptpEnd )
{
    CTreeNode * pNodeCurr = GetFirstBranch();

    if (pptpStart)
        *pptpStart = NULL;

    if (pptpEnd)
        *pptpEnd = NULL;

    if (!pNodeCurr)
        goto Cleanup;

    Assert(     ! pNodeCurr->GetBeginPos()->IsUninit()
            &&  ! pNodeCurr->GetEndPos()->IsUninit() );

    if (pptpStart)
    {
        *pptpStart = pNodeCurr->GetBeginPos();

        Assert( *pptpStart );
        Assert( (*pptpStart)->IsBeginNode() && (*pptpStart)->IsEdgeScope() );
        Assert( (*pptpStart)->Branch() == pNodeCurr );
    }

    if (pptpEnd)
    {
        while( pNodeCurr->NextBranch() )
            pNodeCurr = pNodeCurr->NextBranch();

        Assert( pNodeCurr );

        *pptpEnd = pNodeCurr->GetEndPos();

        Assert( *pptpEnd );
        Assert( (*pptpEnd)->IsEndNode() && (*pptpEnd)->IsEdgeScope() );
        Assert( (*pptpEnd)->Branch() == pNodeCurr );
    }

Cleanup:
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     GetLastBranch
//
//  Synopsis:   Like GetFirstBranch, but gives the last one.
//
//-------------------------------------------------------------------------
CTreeNode *
CElement::GetLastBranch()
{
    CTreeNode *pNode = GetFirstBranch();
    CTreeNode *pNodeLast = pNode;

    while (pNode)
    {
        pNodeLast = pNode;
        pNode = pNode->NextBranch();
    }

    return pNodeLast;
}

//+------------------------------------------------------------------------
//
//  Member:     ParanoidGetLastBranch
//
//  Synopsis:   Like GetFirstBranch, but gives the last one.  More resistent to
//              corrupt data structures.
//
//-------------------------------------------------------------------------
CTreeNode *
CElement::ParanoidGetLastBranch()
{
    CTreeNode *pNode = GetFirstBranch();
    CTreeNode *pNodeLast = pNode;

    while (pNode)
    {
        pNodeLast = pNode;
        pNode = pNode->ParanoidNextBranch();
    }

    return pNodeLast;
}

//+------------------------------------------------------------------------
//
//  Static Member:  CElement::ReplacePtr, CElement::ClearPtr
//
//  Synopsis:   Do a CElement* assignment, but worry about refcounts
//
//-------------------------------------------------------------------------

void
CElement::ReplacePtr ( CElement * * pplhs, CElement * prhs )
{
    if (pplhs)
    {
        CElement * plhsLocal = *pplhs;
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
        if (plhsLocal)
        {
            plhsLocal->Release();
        }
    }
}

//+------------------------------------------------------------------------
//
//  Static Member:  CElement::ReplacePtrSub, CElement::ClearPtr
//
//  Synopsis:   Do a CElement* assignment, but worry about weak refcounts
//
//-------------------------------------------------------------------------

void
CElement::ReplacePtrSub ( CElement * * pplhs, CElement * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->SubAddRef();
        }
        if (*pplhs)
        {
            (*pplhs)->SubRelease();
        }
        *pplhs = prhs;
    }
}

void
CElement::SetPtr ( CElement ** pplhs, CElement * prhs )
{
    if (pplhs)
    {
        if (prhs)
        {
            prhs->AddRef();
        }
        *pplhs = prhs;
    }
}

void
CElement::StealPtrSet ( CElement ** pplhs, CElement * prhs )
{
    SetPtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CElement::StealPtrReplace ( CElement ** pplhs, CElement * prhs )
{
    ReplacePtr( pplhs, prhs );

    if (pplhs && *pplhs)
        (*pplhs)->Release();
}

void
CElement::ClearPtr ( CElement * * pplhs )
{
    if (pplhs && * pplhs)
    {
        CElement * pElement = *pplhs;
        *pplhs = NULL;
        pElement->Release();
    }
}

void
CElement::ReleasePtr ( CElement * pElement )
{
    if (pElement)
    {
        pElement->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsBlockElement
//
//  Synopsis:   Describes whether or not this node is a block element
//
//  Returns:    BOOL indicating a block element
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsBlockElement ( FORMAT_CONTEXT FCPARAM )
{
    CTreeNode * pTreeNode = GetFirstBranch();

    if (pTreeNode->_iFF == -1)
        pTreeNode->GetFancyFormat(FCPARAM);

    return BOOL( pTreeNode->_fBlockNess );
}

HRESULT
CElement::get_canHaveHTML(VARIANT_BOOL *pfCanHaveHTML)
{
    HRESULT hr = S_OK;
    CDefaults *pDefaults;
    
    if (!pfCanHaveHTML)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsNoScope() ||
        Tag() == ETAG_PLAINTEXT ||
        Tag() == ETAG_SELECT ||
        Tag() == ETAG_XMP)
    {
        *pfCanHaveHTML = VARIANT_FALSE;
        goto Cleanup;
    }

    // see if behaviour set default canHaveHTML
    pDefaults = GetDefaults();
    if (pDefaults && pDefaults->GetAAcanHaveHTML(pfCanHaveHTML))
        goto Cleanup;
    else if (IsInMarkup())
    {
        CTreeNode *pNode = GetFirstBranch();
        Assert(pNode);
        if (!pNode->Parent() || pNode->Parent()->Tag() != ETAG_ROOT || pNode->Tag() == ETAG_HTML)
        {
            CElement *pContainer = pNode->GetContainer();
            *pfCanHaveHTML = (pContainer && pContainer->HasFlag(TAGDESC_ACCEPTHTML)) ? VARIANT_TRUE : VARIANT_FALSE;
            goto Cleanup;
        }
    }

    // if we are here, this element is in ether or is directly parented to the root and is not an <HTML> Element
    *pfCanHaveHTML = HasFlag(TAGDESC_CONTAINER) && !HasFlag(TAGDESC_ACCEPTHTML) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT 
CElement::get_isMultiLine(VARIANT_BOOL *pfMultiLine) 
{
    HRESULT hr = S_OK;
    CDefaults *pDefaults;

    if (!pfMultiLine)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfMultiLine = VARIANT_TRUE;

    // see if behaviour set default isMultiLine
    pDefaults = GetDefaults();
    if (pDefaults)
    {
        *pfMultiLine = pDefaults->GetAAisMultiLine();
        goto Cleanup;
    }

    if (Tag() == ETAG_INPUT)
        *pfMultiLine = IsTypeMultiline(DYNCAST(CInput, this)->GetType()) ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_inflateBlock(VARIANT_BOOL *pfInflate)
{
    HRESULT hr = S_OK;
    
    if (!pfInflate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfInflate = _fBreakOnEmpty ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::put_inflateBlock(VARIANT_BOOL fInflate)
{
    HRESULT hr = S_OK;
    
    if (_fBreakOnEmpty ^ !!fInflate)
    {
        CNotification nf;
        CMarkup      *pMarkupNotify;

        _fBreakOnEmpty  = fInflate;

        pMarkupNotify = GetMarkup();
        if (!pMarkupNotify)
            goto Cleanup;

        nf.ElementResize(this, 0);
        pMarkupNotify->Notify(&nf);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::get_isContentEditable(VARIANT_BOOL *pfEditable)
{
    HRESULT hr = S_OK;
    
    if (!pfEditable)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfEditable = IsEditable(/*fCheckContainerOnly*/FALSE) ? VARIANT_TRUE : VARIANT_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::get_isDisabled(VARIANT_BOOL *pfDisabled)
{
    HRESULT hr = S_OK;
    
    if (!pfDisabled)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfDisabled = IsEnabled() ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsOwnLineElement
//
//  Synopsis:   Tells us if the element is a ownline element
//
//  Returns:    BOOL indicating an ownline element
//
//-----------------------------------------------------------------------------
BOOL
CElement::IsOwnLineElement(CFlowLayout *pFlowLayoutContext)
{
    BOOL fRet;
    
    if (   (   HasFlag(TAGDESC_OWNLINE)
            || pFlowLayoutContext->IsElementBlockInContext(this)
           )
        && IsInlinedElement(LC_TO_FC(pFlowLayoutContext->LayoutContext()))
       )
    {
        fRet = TRUE;
    }
    else
        fRet = FALSE;
    
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::IsBlockTag
//
//  Synopsis:   Describes whether or not this element is a block tag
//              This should rarely be used - it returns the same value no
//              matter what the display: style setting on the element is.
//              To determine if you should break lines before and after the
//              element use IsBlockElement().
//
//  Returns:    BOOL indicating a block tag
//
//-----------------------------------------------------------------------------

BOOL
CElement::IsBlockTag ( void )
{
    return HasFlag(TAGDESC_BLOCKELEMENT) || Tag() == ETAG_OBJECT;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::BreaksLine
//
//  Synopsis:   Describes whether or not this node starts a new line
//
//  Returns:    BOOL indicating start of new line
//
//-------------------------------------------------------------------------

BOOL
CElement::BreaksLine ( void )
{
    return (IsBlockElement() &&
                !HasFlag(TAGDESC_WONTBREAKLINE));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::HasFlag
//
//  Synopsis:   Checks if the element has an given tag
//
//  Returns:    TRUE if it has an end tag else FALSE
//
//-------------------------------------------------------------------------

BOOL
CElement::HasFlag(TAGDESC_FLAGS flag) const
{
    const CTagDesc *ptd = TagDescFromEtag(Tag());
    return ptd ? (ptd->_dwTagDescFlags & flag) ? TRUE : ptd->HasFlag(flag)
               : FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::TagName
//
//  Synopsis:   Chases the proxy and the returns the tag name of
//
//  Returns:    const TCHAR *
//
//-------------------------------------------------------------------------

const TCHAR *
CElement::TagName ()
{
    CExtendedTagDesc * pTagDesc = GetExtendedTagDesc();
    if (!pTagDesc)
    {
        return NameFromEtag(Tag());
    }
    else
    {
        Assert (pTagDesc->TagName());
        return pTagDesc->TagName();
    }
}

const TCHAR *
CElement::Namespace( )
{
    CExtendedTagDesc * pTagDesc = GetExtendedTagDesc();
    if (!pTagDesc)
    {
        return NULL;
    }
    else
    {
        Assert (pTagDesc->Namespace());
        return pTagDesc->Namespace();
    }
}

const TCHAR *
CElement::NamespaceHtml()
{
    LPCTSTR  pchNamespace = Namespace();

    return pchNamespace ? pchNamespace : _T("HTML");
}

BOOL
SameScope ( CTreeNode * pNode1, const CElement * pElement2 )
{
    // Both NULL
    if(!pNode1 && !pElement2)
        return TRUE;

    return pNode1 && pElement2
        ? pNode1->Element() == pElement2
        : FALSE;
}

BOOL
SameScope ( const CElement * pElement1, CTreeNode * pNode2 )
{
    // Both NULL
    if(!pElement1 && !pNode2)
        return TRUE;

    return pElement1 && pNode2
        ? pElement1 == pNode2->Element()
        : FALSE;
}

BOOL
SameScope ( CTreeNode * pNode1, CTreeNode * pNode2 )
{
    if (pNode1 == pNode2)
        return TRUE;

    return pNode1 && pNode2
        ? pNode1->Element() == pNode2->Element()
        : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::NameOrIDOfParentForm
//
//  Synopsis:   Return the name or id of a parent form if one exists.
//              NULL if not.
//
//-------------------------------------------------------------------------

LPCTSTR
CElement::NameOrIDOfParentForm()
{
    CElement *  pElementForm;
    LPCTSTR     pchName = NULL;

    pElementForm = GetFirstBranch()->SearchBranchToRootForTag( ETAG_FORM )->SafeElement();

    if (pElementForm)
    {
        pchName = pElementForm->GetIdentifier();
    }
    return pchName;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttribute
//
//  Synopsis:   Save a single attribute to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttribute (
    CStreamWriteBuff *      pStreamWrBuff,
    LPTSTR                  pchName,
    LPTSTR                  pchValue,
    const PROPERTYDESC *    pPropDesc /* = NULL */,
    CBase *                 pBaseObj /* = NULL */,
    BOOL                    fEqualSpaces /* = TRUE */,    // TODO (dbau) fix all the test cases so that it never has spaces
    BOOL                    fAlwaysQuote /* = FALSE */)
    
{
    HRESULT     hr;
    DWORD       dwOldFlags;

    hr = THR(pStreamWrBuff->Write(_T(" "), 1));
    if (hr)
        goto Cleanup;

    hr = THR(pStreamWrBuff->Write(pchName, _tcslen(pchName)));
    if (hr)
        goto Cleanup;

    if (pchValue || pPropDesc)
    {
        // Quotes are necessary for pages like ASP, that might have
        // <% =x %>. This will mess up the parser if we don't output
        // the quotes around such ASP expressions.
        BOOL fForceQuotes = fAlwaysQuote || !pchValue || !pchValue[0] || 
            (pchValue && ( StrChr(pchValue, _T('<')) || StrChr(pchValue, _T('>')) ));

        if (fEqualSpaces)
            hr = THR(pStreamWrBuff->Write(_T(" = ")));
        else
            hr = THR(pStreamWrBuff->Write(_T("=")));
        if (hr)
            goto Cleanup;

        // We dont want to break the line in the middle of an attribute value
        dwOldFlags = pStreamWrBuff->SetFlags(WBF_NO_WRAP);

        if (pchValue)
        {
            hr = THR(pStreamWrBuff->WriteQuotedText(pchValue, fForceQuotes));
        }
        else
        {
            Assert (pPropDesc && pBaseObj);
            hr = THR(pPropDesc->HandleSaveToHTMLStream (pBaseObj, (void *)pStreamWrBuff));
        }
        if (hr)
            goto Cleanup;

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
// Member:     CElement::SaveUnknown
//
// Synopsis:   Write these guys out
//
// Returns:    HRESULT
//
//+------------------------------------------------------------------------

HRESULT
CElement::SaveUnknown(CStreamWriteBuff * pStreamWrBuff, BOOL *pfAny)
{
    HRESULT hr = S_OK;
    AAINDEX aaix = AA_IDX_UNKNOWN;
    LPCTSTR lpPropName;
    LPCTSTR lpszValue = NULL;
    BSTR bstrTemp = NULL;
    DISPID expandoDISPID;
    BOOL fAny = FALSE;

    // Look for all expandos & dump them out
    while ( (aaix = FindAAType (CAttrValue::AA_Expando, aaix ) )
        != AA_IDX_UNKNOWN )
    {
        CAttrValue *pAV = _pAA->FindAt(aaix);

        Assert (pAV);

        // Get value into a string, but skip VT_DISPATCH & VT_UNKNOWN
        if (pAV->GetAVType() == VT_DISPATCH || pAV->GetAVType() == VT_UNKNOWN )
            continue;

        // TODO rgardner - we should smarten this up so we don't need to allocate a string

        // Found a literal attrValue
        hr = pAV->GetIntoString( &bstrTemp, &lpszValue );

        if ( hr == S_FALSE )
        {
            // Can't convert to string
            continue;
        }
        else if ( hr )
        {
            goto Cleanup;
        }

        fAny = TRUE;

        expandoDISPID = GetDispIDAt ( aaix );
        if (TestClassFlag(ELEMENTDESC_OLESITE))
        {
            expandoDISPID = expandoDISPID + DISPID_EXPANDO_BASE - DISPID_ACTIVEX_EXPANDO_BASE;
        }

        hr = GetExpandoName ( expandoDISPID, &lpPropName );
        if (hr)
            goto Cleanup;

        hr = THR(SaveAttribute(pStreamWrBuff, (LPTSTR)lpPropName, (LPTSTR)lpszValue, NULL, NULL, FALSE, TRUE)); // Always quote value: IE5 57717
        if (hr)
            goto Cleanup;

        if ( bstrTemp )
        {
            SysFreeString ( bstrTemp );
            bstrTemp = NULL;
        }
    }

    if (pfAny)
        *pfAny = fAny;

Cleanup:
    if ( bstrTemp )
        FormsFreeString ( bstrTemp );
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
// Member:     CElement::SaveUnknown
//
// Synopsis:   Write these guys out
//
// Returns:    HRESULT
//
//+------------------------------------------------------------------------

HRESULT
CElement::SaveUnknown(IPropertyBag * pPropBag, BOOL fSaveBlankAttributes )
{
    HRESULT     hr = S_OK;
    AAINDEX     aaix = AA_IDX_UNKNOWN;
    LPCTSTR     lpPropName;
    CVariant    var;
    DISPID      dispidExpando;

    while ( (aaix = FindAAType ( CAttrValue::AA_Expando, aaix )) != AA_IDX_UNKNOWN )
    {
        var.vt = VT_EMPTY;

        hr = THR(GetIntoBSTRAt(aaix, &(var.bstrVal)));
        if (hr == S_FALSE)
        {
            // Can't convert to string
            continue;
        }
        else if (hr)
        {
            goto Cleanup;
        }

        // We do not save attributes with null string values for netscape compatibility of
        // <EMBED src=thisthat loop> attributes which have no value - the loop attribute
        // in the example.   Pluginst.cxx passes in FALSE for fSaveBlankAttributes, everybody
        // else passes in TRUE via a default param value.
        if( !fSaveBlankAttributes && (var.bstrVal == NULL || *var.bstrVal == _T('\0') ) )
        {
            VariantClear (&var);
            continue;
        }

        var.vt = VT_BSTR;

        dispidExpando = GetDispIDAt(aaix);
        if (TestClassFlag(ELEMENTDESC_OLESITE))
        {
            dispidExpando = dispidExpando +
                DISPID_EXPANDO_BASE - DISPID_ACTIVEX_EXPANDO_BASE;
        }
        hr = THR(GetExpandoName(dispidExpando, &lpPropName));
        if (hr)
            goto Cleanup;

        hr = THR(pPropBag->Write(lpPropName, &var));
        if (hr)
            goto Cleanup;

        VariantClear (&var);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Helper:     StoreLineAndOffsetInfo
//
//  Synopsis:   stores line and offset information for a property in attr array of the object
//
//-------------------------------------------------------------------------

HRESULT
StoreLineAndOffsetInfo(CBase * pBaseObj, DISPID dispid, ULONG uLine, ULONG uOffset)
{
    HRESULT         hr;
    // pchData will be of the form "ulLine ulOffset", for example: "13 1313"
    TCHAR           pchData [30];   // in only needs to be 21, but let's be safe

    hr = Format(0, &pchData, 30, _T("<0du> <1du>"), uLine, uOffset);
    if (hr)
        goto Cleanup;

    hr = THR(pBaseObj->AddString(dispid, pchData, CAttrValue::AA_Internal));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetLineAndOffsetInfo
//
//  Synopsis:   retrieves line and offset information for a property from attr array
//
//  Returns:    S_OK        successfully retrieved the data
//              S_FALSE     no error, but the information in attr array is not
//                          a line/offset string
//              FAILED(hr)  generic error condition
//
//-------------------------------------------------------------------------

HRESULT
GetLineAndOffsetInfo(CAttrArray * pAA, DISPID dispid, ULONG * puLine, ULONG * puOffset)
{
    HRESULT         hr;
    CAttrValue *    pAV;
    AAINDEX         aaIdx;
    LPTSTR          pchData;
    TCHAR *         pchTempStart;
    TCHAR *         pchTempEnd;

    Assert (puOffset && puLine);

    (*puOffset) = (*puLine) = 0;      // set defaults

    //
    // get the information string
    //

    aaIdx = AA_IDX_UNKNOWN;
    pAV = pAA->Find(dispid, CAttrValue::AA_Internal, &aaIdx);
    if (!pAV || VT_LPWSTR != pAV->GetAVType())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    pchData = pAV->GetString();

    //
    // pchData is of the format: "lLine lOffset", for example: "13 1313"
    // Here we crack the string apart.
    //

    pchTempStart = pchData;
    pchTempEnd = _tcschr(pchData, _T(' '));

    Assert (pchTempEnd);

    *pchTempEnd = _T('\0');
    hr = THR(ttol_with_error(pchTempStart, (LONG*)puLine));
    *pchTempEnd = _T(' ');
    if (hr)
        goto Cleanup;

    pchTempStart = ++pchTempEnd;

    hr = THR(ttol_with_error(pchTempStart, (LONG*)puOffset));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ConnectEventHandler
//
//  Synopsis:   retrieves string with the specified dispid from attr array, constructs
//              code from the string and puts it in attr array with dispidCode.
//              When fStandard is set, meaning that the event handler is standard,
//              such as onclick, dispid identifies script text in AA_Attribute
//              section of attr array. If fStandard is false, then dispid identifies script
//              text in AA_Expando section of attr array.
//              Also caches language attribute in ppchLanguageCached if provided.
//              uOffset and uLine specify line and offset of script text in source html -
//              this information is necessary for script debugger.
//
//-------------------------------------------------------------------------

HRESULT
CElement::ConnectInlineEventHandler(
    DISPID      dispid,
    DISPID      dispidCode,
    ULONG       uOffset,
    ULONG       uLine,
    BOOL        fStandard,
    LPCTSTR *   ppchLanguageCached,
    CHtmlComponent *pComponent)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pchCode = NULL;
    IDispatch *     pDispCode = NULL;
    CAttrArray *    pAA = *GetAttrArray();
    CAttrValue *    pAV = NULL;
    CBase *         pBaseObj;
    LPCTSTR         pchLanguageLocal;
    CMarkup *       pMarkup = GetMarkup();
    WHEN_DBG(CDoc *          pDoc = Doc();)

    Assert(pMarkup);

    // Don't hook up script event handlers in print mode
    // TODO (KTam): It may be more correct to put a query to
    // ProcessURLAction(URLACTION_SCRIPT_RUN) in the callers of this fn;
    // this is already happening in some cases (consider changing
    // CPeerSite::GetEventCookieHelper)
    if (pMarkup->DontRunScripts())
        goto Cleanup;
    //
    // get language
    //

    if (!ppchLanguageCached)
    {
        pchLanguageLocal = NULL;
        ppchLanguageCached = &pchLanguageLocal;
    }

    if (!(*ppchLanguageCached))
    {
        if (pAA == NULL || !pAA->FindString (DISPID_A_LANGUAGE, ppchLanguageCached, CAttrValue::AA_Attribute))
        {
            (*ppchLanguageCached) = _T("");
        }
    }

    //
    // get base object and code
    //

    pBaseObj = GetBaseObjectFor (dispid);

    if (!pBaseObj || !(*(pBaseObj->GetAttrArray())))
        goto Cleanup;

    // this is supposed to be found because of the logic dispid-s passed in this function (alexz)
    //   however, for peers on the object tag, the expandos are saved as activeX_EXPANDOS and we
    //   need to search for a differnt dispid
    // (JHarding) It's also possible the dispatch has already been set up.  We'll take that, too.
    pAV = (*(pBaseObj->GetAttrArray()))->Find( dispid, fStandard ? CAttrValue::AA_Attribute :
                                                                   CAttrValue::AA_Expando );
    if( !pAV )
        pAV = (*(pBaseObj->GetAttrArray()))->Find( ((dispid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE),
                                                   CAttrValue::AA_Expando );
    if( !pAV )
        goto Cleanup;

    if( pAV->GetAVType() == VT_DISPATCH )
    {
        pDispCode = pAV->GetDispatch();
        if( pDispCode )
            pDispCode->AddRef();
    }
    else if( pAV->GetAVType() == VT_LPWSTR )
    {
        pchCode = pAV->GetLPWSTR();
    }

    if( !pchCode && !pDispCode )
        goto Cleanup;

    //
    // debug stuff
    //

#if DBG==1
    if (pchCode && IsTagEnabled(tagHtmSrcTest))
    {
        TCHAR achSrc[512];
        ULONG cch;

        HRESULT hrT;

        hrT = pDoc->GetHtmSourceText(uOffset, ARRAY_SIZE(achSrc) - 1,
                achSrc, &cch);

        if (hrT == S_OK)
        {
            cch = min(cch, (ULONG)_tcslen(pchCode));
            achSrc[cch] = 0;

            TraceTag((
                tagHtmSrcTest,
                "Expect \"%.64ls\", (ln=%ld pos=%ld) \"%.64ls\"",
                pchCode, uLine, uOffset, achSrc));
        }
    }
#endif

    //
    // get previously stored line/offset information
    //

    if (!fStandard && !pDispCode)
    {
        Assert (0 == uLine && 0 == uOffset);

        hr = THR(GetLineAndOffsetInfo(pAA, dispid, &uLine, &uOffset));
        if (!OK(hr))        // if not S_OK or S_FALSE
            goto Cleanup;
    }

    //
    // construct code and handle result
    //

    if( !pDispCode )
    {
        CScriptCollection *pScriptCollection;
        TCHAR *pchNamespace = (LPTSTR)NameOrIDOfParentForm();
        
        if (!pchNamespace && !pMarkup->HasWindowPending())
        {
            if (pComponent)
            {
                pchNamespace = pComponent->GetNamespace();
            }
            else
            {
                CMarkupScriptContext *pScriptContext;
                hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
                if (!hr)
                    pchNamespace = pScriptContext->GetNamespace();
            }

            Assert(pchNamespace || (pMarkup->_fMarkupServicesParsing && (Tag() == ETAG_OBJECT)));
        }

        pScriptCollection = pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                pchNamespace,                       // pchScope
                (LPTSTR)pchCode,                    // pchCode
                NULL,                               // pchFormalParams
                (LPTSTR)(*ppchLanguageCached),      // pchLanguage
                pMarkup,                            // pMarkup
                NULL,                               // pchType (valid on script tags only)
                uOffset,                            // ulOffset
                uLine,                              // ulStartingLine
                pMarkup,                            // pSourceObject
                SCRIPTPROC_HOSTMANAGESSOURCE,       // dwFlags
                &pDispCode,                         // ppDispCode result
                TRUE,                               // fSingleLine
                pComponent));                       // An instance of lightwight behavior whose <ATTACH> tag is being hooked up
        }
    }

    if (S_OK == hr && pDispCode)
    {
        // pDispCode can be NULL if the script was parsed
        // but it contained no executeable statements
        hr = THR(pBaseObj->AddDispatchObject(
            dispidCode,
            pDispCode,
            CAttrValue::AA_Internal,
            CAttrValue::AA_Extra_OldEventStyle));
        ClearInterface (&pDispCode);
        if (hr)
            goto Cleanup;

        // if we add a data event to an element, make sure the event can fire
        CDataMemberMgr::EnsureDataEventsFor(pBaseObj, dispid);
    }
    else if (E_NOTIMPL == hr && !pDispCode)
    {
        //
        // ConstructCode must have failed because we are parsing VBScript and it does not support
        // function pointers. In this case, we will do AddScriptlet in CElement::AddAllScriptlets.
        // The only thing we need to do now is to store line/offset numbers in attr array in
        // AA_Internal section, if it is not there yet.
        // There are 2 codepaths which can lead us here:
        // 1.   We call this method from CElement::InitAttrBag to connect standard inline
        // event handlers, such as onclick. We call it passing actual line/offset information
        // available there from CHtmlTag * pht. In this case line/offset information is passed
        // and we store it
        // 2.   We call this method from CPeerHolder::RegisterEvent to connect custom peer event
        // handler. In this case the event handler is an expando and line/offset information was
        // stored for it in CElement::InitAttrBag; we don't need to do anything.

        if (fStandard) // equivalent to condition (0 != uLine || 0 != uOffset)
        {
            hr = StoreLineAndOffsetInfo (pBaseObj, dispid, uLine, uOffset);
            if (hr)
                goto Cleanup;
        }
    }
    
    // Don't propagate the last error - code construction could have failed due to
    // syntax errors so try to construct other event handlers
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::InitAttrBag
//
//  Synopsis:   Fetch values from CHtmTag and put into the bag
//
//  Arguments:  pht : parsed attributes in text format
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::InitAttrBag(CHtmTag *pht, CMarkup * pMarkup)
{
    int i;
    CHtmTag::CAttr *pattr = NULL;
    HRESULT hr = S_OK;
    const PROPERTYDESC * ppropdesc;
    CBase *pBaseObj;
    InlineEvts  *pInlineEvts = NULL;
    WORD    wMaxstrlen = 0;
    TCHAR   chOld = _T('\0');
    THREADSTATE * pts = GetThreadState();
// HACK HACK 47681 start: ignore height/width for inputs not input/image
    BOOL    fHackForInput;
    BOOL    fHackForInputProp;
// HACK HACK 47681 end

    BOOL fIsStrictCSS1;

    if (*GetAttrArray())
    {
        // InitAttrBag must have already been called.
        return S_OK;
    }

    pts->fInInitAttrBag = TRUE;

// HACK HACK 47681 start: ignore height/width for inputs not input/image
    fHackForInput = (Tag() == ETAG_INPUT && DYNCAST(CInput, this)->GetType() != htmlInputImage);
// HACK HACK 47681 end

    // Loop over all attr pairs in the tag, and see if their BYTE in the known-attr array
    // is set; if not, add the attr and any val to the CaryUnknownAttrs in the attr bag
    // (create one if needed).

    for (i = pht ? pht->GetAttrCount() : 0; --i >= 0; )
    {
        pattr = pht->GetAttr(i);

        if (!pattr->_pchName)
            continue;

// HACK HACK 47681 start: ignore height/width for inputs not input/image
        fHackForInputProp = fHackForInput && 
                (StrCmpIC(s_propdescCInputheight.a.pstrName, pattr->_pchName) == 0
                || StrCmpIC(s_propdescCInputwidth.a.pstrName, pattr->_pchName) == 0);

        if (!fHackForInputProp && (ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
//
// HACK HACK 47681 end. uncomment the following line when removing the HACK section
        // if ((ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
        {
            // Allow some elements to redirect to another attr array
            pBaseObj = GetBaseObjectFor(ppropdesc->GetDispid(), pMarkup);

            if (!pBaseObj)
            {
                continue;
            }

#ifndef WIN16
            // BUGWIN16: HandleLoadFromHTMLString is a class method, I am amazed that we can check
            // for it being non - null !? - vamshi - 4/29/97
#ifndef UNIX
// Unix gets, Error: Taking address of the bound function PROPERTYDESC::HandleLoadFromHTMLString(CBase*, wchar_t*) const.
//             AssertSz(ppropdesc->HandleLoadFromHTMLString != NULL, "attempt to load abstract property from html");
#endif
#endif
            wMaxstrlen = (ppropdesc->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 :
                         (ppropdesc->GetBasicPropParams()->wMaxstrlen ? ppropdesc->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE);

            if (wMaxstrlen && pattr->_pchVal && _tcslen(pattr->_pchVal) > wMaxstrlen)
            {
                chOld = pattr->_pchVal[wMaxstrlen];
                pattr->_pchVal[wMaxstrlen] = _T('\0');
            }

            // InitAttrBag (this function) is responsible for applying the attributes on an html element. Normal attributes, i.e. all attributes on html
            // except "style", doesn't take care about css1 strictness. Only when applying the inline style attribute value it has to be taken into account
            // if we are in strict css1 or not. In <HTMLELEM style="...">  the DISPID for the "style" attribute is DISPID_CElement_style_Str.
            fIsStrictCSS1 = pMarkup->IsStrictCSS1Document() && (ppropdesc->GetDispid() == DISPID_CElement_style_Str);

            hr = THR_NOTRACE( ppropdesc->HandleLoadFromHTMLString ( pBaseObj, pattr->_pchVal, fIsStrictCSS1 ? HANDLEPROP_STRICTCSS1 : 0 ));

            if (ppropdesc->GetPPFlags() & PROPPARAM_SCRIPTLET)
            {
                if (!pInlineEvts)
                    pInlineEvts = new InlineEvts;

                if (pInlineEvts)
                {
                    pInlineEvts->adispidScriptlets[pInlineEvts->cScriptlets] = ppropdesc->GetDispid();
                    pInlineEvts->aOffsetScriptlets[pInlineEvts->cScriptlets] = pattr->_ulOffset;
                    pInlineEvts->aLineScriptlets[pInlineEvts->cScriptlets++] = pattr->_ulLine;
                }
                else
                    goto Cleanup;
            }

            if ( hr )
            {
                // Create an "unknown" attribute containing the original string from the HTML
                // SetString with fIsUnkown set to TRUE
                if (chOld)
                {
                    pattr->_pchVal[wMaxstrlen] = chOld;
                    chOld = 0;
                }
                hr = CAttrArray::SetString ( pBaseObj->GetAttrArray(), ppropdesc,
                    pattr->_pchVal, TRUE, CAttrValue::AA_Extra_DefaultValue );
            }

            // If the parameter was invalid, value will get set to default &
            // parameter will go into the unknown bag
            if ( !hr )
            {
                if ( ppropdesc->GetDispid() == DISPID_A_BACKGROUNDIMAGE )
                {
                    // Fork off an early download for background images
                    LPCTSTR lpszURL;
                    if ( !(*(pBaseObj->GetAttrArray()))->FindString(DISPID_A_BACKGROUNDIMAGE, &lpszURL) )
                    {
                        LONG lCookie;

                        if (GetImageUrlCookie(lpszURL, &lCookie, TRUE) == S_OK)
                        {
                            hr = THR(AddImgCtx(DISPID_A_BGURLIMGCTXCACHEINDEX, lCookie));
                            if (hr)
                            {
                                Doc()->ReleaseUrlImgCtx(lCookie, this);
                                goto Cleanup;
                            }
                        }
                    }
                }
            }
            else if (hr == E_OUTOFMEMORY)
            {
                goto Cleanup;
            }
        }
        else if (pMarkup->_fExpando)
        {
            DISPID  expandoDISPID;

            if (pMarkup->HasBehaviorContext() && ETAG_GENERIC_BUILTIN == Tag())
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                // NOTE: Need to make sure that the parser ensures that the first buitin tag in a htc
                // is the HTC or COMPONENT tag for this to work reliably.
                if (pComponent &&
                    !pComponent->Dirty() &&
                    pComponent->_fFactoryComponent &&
                    !pComponent->_fLightWeight &&
                    (HTC_BEHAVIOR_DESC & TagNameToHtcBehaviorType(TagName())) &&
                    (StrCmpIC(_T("lightweight"), pattr->_pchName) == 0) &&
                    StringToBool(pattr->_pchVal))
                {
                    pComponent->_fLightWeight = TRUE;
                }

                if (pComponent &&
                    !pComponent->Dirty() &&
                    (pComponent->_fLightWeight || (!pComponent->_fFactoryComponent && pComponent->_fFirstInstance)) &&
                    pattr->_pchVal &&
                    *(pattr->_pchVal) &&
                    (HTC_BEHAVIOR_PROPERTYORMETHOD & TagNameToHtcBehaviorType(TagName())) &&
                    StrCmpIC(_T("NAME"), pattr->_pchName) == 0)
                {
                    if (pComponent->_fLightWeight)
                    {
                        Assert(pComponent->_fFactoryComponent);
                        pComponent->AddAtom(pattr->_pchVal, (LPVOID)this);
                    }
                    else if (!pComponent->_fFactoryComponent && pComponent->_fFirstInstance)
                    {
                        // cache the name of htc prop\method for faster retreival later in EnterTree
                        Assert(!DYNCAST(CGenericElement, this)->GetName());
                        DYNCAST(CGenericElement, this)->_cstrContents.Set(pattr->_pchVal);
                    }
                }
            }

            // Create an expando

            hr = THR_NOTRACE(AddExpando(pattr->_pchName, &expandoDISPID));

            Assert(expandoDISPID);

            if (hr == DISP_E_MEMBERNOTFOUND)
            {
                hr = S_OK;
                continue; // Expando not turned on
            }
            if (hr)
                goto Cleanup;

            if (TestClassFlag(ELEMENTDESC_OLESITE))
            {
                expandoDISPID = expandoDISPID - DISPID_EXPANDO_BASE +
                    DISPID_ACTIVEX_EXPANDO_BASE;
            }

            // Note that we always store expandos in the current object - we never redirect them
            hr = THR(AddString(
                    expandoDISPID,
                    pattr->_pchVal,
                    CAttrValue::AA_Expando));
            if (hr)
                goto Cleanup;

            // if begins with "on", this can be a peer registered event - need to store line/offset numbers
            if (0 == StrCmpNIC(_T("on"), pattr->_pchName, 2))
            {
                hr = THR(StoreLineAndOffsetInfo(this, expandoDISPID, pattr->_ulLine, pattr->_ulOffset));
                if (hr)
                    goto Cleanup;
            }
        }

        if (chOld)
        {
            pattr->_pchVal[wMaxstrlen] = chOld;
            chOld = _T('\0');
        }
    }

    if (pInlineEvts && pInlineEvts->cScriptlets && (ETAG_UNKNOWN != Tag()) && pMarkup && pMarkup->GetScriptCollection())
    {
        SetEventsShouldFire();

        StoreEventsToHook(pInlineEvts);
        pInlineEvts = NULL; // Make sure we don't free it.
    }

Cleanup:
    if (pInlineEvts)
        delete pInlineEvts;
    if (chOld)
        pattr->_pchVal[wMaxstrlen] = chOld;

    pts->fInInitAttrBag = FALSE;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::MergeAttrBag
//
//  Synopsis:   Add any value from CHtmTag that are not already present
//              in the attrbag
//
//              Note: currently, expandos are not merged.
//
//  Arguments:  pht : parsed attributes in text format
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::MergeAttrBag(CHtmTag *pht)
{
    int i;
    CHtmTag::CAttr *pattr = NULL;
    HRESULT hr = S_OK;
    const PROPERTYDESC * ppropdesc;
    InlineEvts inlineEvts;
    CBase *pBaseObj;
    WORD    wMaxstrlen = 0;
    TCHAR   chOld = _T('\0');
    CDoc *  pDoc = Doc();

    // Loop over all attr pairs in the tag, and see if their BYTE in the known-attr array
    // is set; if not, add the attr and any val to the CaryUnknownAttrs in the attr bag
    // (create one if needed).

    for (i = pht ? pht->GetAttrCount() : 0; --i >= 0; )
    {
        pattr = pht->GetAttr(i);

        if (!pattr->_pchName)
            continue;

        if ((ppropdesc = FindPropDescForName(pattr->_pchName)) != NULL)
        {
            // Allow some elements to redirect to another attr array
            pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

            // Only add the attribute if it has not been previously defined
            // style attribute requires special handling
            if (!pBaseObj
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_Attribute))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_UnknownAttr))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_Internal))
                || (AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(ppropdesc->GetDispid(), CAttrValue::AA_AttrArray))
                || (ppropdesc == (PROPERTYDESC *)&s_propdescCElementstyle_Str && AA_IDX_UNKNOWN != pBaseObj->FindAAIndex(DISPID_INTERNAL_INLINESTYLEAA, CAttrValue::AA_AttrArray)))
            {
                continue;
            }

            wMaxstrlen = (ppropdesc->GetBasicPropParams()->wMaxstrlen == pdlNoLimit) ? 0 :
                         (ppropdesc->GetBasicPropParams()->wMaxstrlen ? ppropdesc->GetBasicPropParams()->wMaxstrlen : DEFAULT_ATTR_SIZE);

            if (wMaxstrlen && pattr->_pchVal && _tcslen(pattr->_pchVal) > wMaxstrlen)
            {
                chOld = pattr->_pchVal[wMaxstrlen];
                pattr->_pchVal[wMaxstrlen] = _T('\0');
            }
            hr = THR ( ppropdesc->HandleMergeFromHTMLString ( pBaseObj, pattr->_pchVal ) );

            if (ppropdesc->GetPPFlags() & PROPPARAM_SCRIPTLET)
            {
                inlineEvts.adispidScriptlets[inlineEvts.cScriptlets] = ppropdesc->GetDispid();
                inlineEvts.aOffsetScriptlets[inlineEvts.cScriptlets] = pattr->_ulOffset;
                inlineEvts.aLineScriptlets[inlineEvts.cScriptlets++] = pattr->_ulLine;
            }

            if (hr)
            {
                // Create an "unknown" attribute containing the original string from the HTML
                // SetString with fIsUnkown set to TRUE
                hr = CAttrArray::SetString ( pBaseObj->GetAttrArray(), ppropdesc,
                    pattr->_pchVal, TRUE, CAttrValue::AA_Extra_DefaultValue );
            }

            // If the parameter was invalid, value will get set to default &
            // parameter will go into the unknown bag
            if ( !hr )
            {
                if ( ppropdesc->GetDispid() == DISPID_A_BACKGROUNDIMAGE )
                {
                    // Fork off an early download for background images
                    LPCTSTR lpszURL;
                    if ( !(*(pBaseObj->GetAttrArray()))->FindString(DISPID_A_BACKGROUNDIMAGE, &lpszURL) )
                    {
                        LONG lCookie;

                        if (GetImageUrlCookie(lpszURL, &lCookie, TRUE) == S_OK)
                        {
                            hr = THR(AddImgCtx(DISPID_A_BGURLIMGCTXCACHEINDEX, lCookie));
                            if (hr)
                            {
                                pDoc->ReleaseUrlImgCtx(lCookie, this);
                                goto Cleanup;
                            }
                        }
                    }
                }
            }
            else if (hr == E_OUTOFMEMORY)
            {
                goto Cleanup;
            }
        }
        
        if (chOld)
        {
            pattr->_pchVal[wMaxstrlen] = chOld;
            chOld = _T('\0');
        }
    }
    
     hr = THR(inlineEvts.Connect(pDoc, this));
     if (hr)
         goto Cleanup;

Cleanup:
    if (chOld)
        pattr->_pchVal[wMaxstrlen] = chOld;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Init2
//
//  Synopsis:   Perform any element level initialization
//
//-------------------------------------------------------------------------

HRESULT
CElement::Init2(CInit2Context * pContext)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pch;
    CDoc *          pDoc = Doc();
    CAttrArray *    pAAInline;

    Assert( !IsInMarkup() && pContext->_pTargetMarkup );
    Assert( !HasWindowedMarkupContextPtr() );
    
    hr = THR(SetWindowedMarkupContextPtr( pContext->_pTargetMarkup->GetWindowedMarkupContext() ) );
    if( hr )
        goto Cleanup;

    GetWindowedMarkupContextPtr()->SubAddRef();

    pch = GetIdentifier();
    if (pch)
    {
        hr = THR(pDoc->_AtomTable.AddNameToAtomTable(pch, NULL));
        if (hr)
            goto Cleanup;
    }

    //
    // behaviors support
    //

    // TODO (alexz) see if it is possible to make it without parsing inline styles here
    pAAInline = GetInLineStyleAttrArray();
    if (pAAInline && pAAInline->Find(DISPID_A_BEHAVIOR))
    {
        pDoc->SetCssPeersPossible();
    }

#ifdef NEVER
    //
    // Set the _fTabStop bit for all the default tags.
    //

    switch (etag)
    {
    case ETAG_HR:
    case ETAG_DIV:
    case ETAG_TABLE:
    case ETAG_IMG:
        if (pDoc->_fDesignMode)
        {
            _fTabStop = TRUE;
        }
        break;

    case ETAG_LABEL:
    case ETAG_A:
    case ETAG_FRAME:
    case ETAG_EMBED:
    case ETAG_LEGEND:
        if (etag == ETAG_FRAME && _fSynthesized)
            break;

        if (!pDoc->_fDesignMode)
        {
            _fTabStop = TRUE;
        }
        break;

    case ETAG_INPUT:
    case ETAG_SELECT:
    case ETAG_TEXTAREA:
    case ETAG_BUTTON:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_IFRAME:
    case ETAG_OBJECT:
    case ETAG_APPLET:
        if (etag == ETAG_IFRAME && _fSynthesized)
            break;

        _fTabStop = TRUE;
       break;

    case ETAG_MAP:
    case ETAG_AREA:
        _fTabStop = FALSE;
        break;

    default:
        if (GetAAtabIndex() > 0)
        {
            _fTabStop = TRUE;
        }
        break;
    }
#endif

    hr = THR(InitExtendedTag(pContext));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    if (fEnd && HasFlag(TAGDESC_SAVEINDENT))
    {
        pStreamWrBuff->EndIndent();
    }

    hr = WriteTag(pStreamWrBuff, fEnd);
    if(hr)
        goto Cleanup;

    if (!fEnd && HasFlag(TAGDESC_SAVEINDENT))
    {
        pStreamWrBuff->BeginIndent();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttributes
//
//  Synopsis:   Save the attributes to the stream
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttributes ( CStreamWriteBuff * pStreamWrBuff, BOOL *pfAny )
{
    HRESULT hr = S_OK;
    BOOL fSave;
    LPCTSTR lpstrUnknownValue;
    CBase *pBaseObj;
    BOOL fAny = FALSE;

    // For printing, we let behaviors save their attributes first -- this is a hack to get
    // around the fact that if both the behavior and the element have the same attribute, they'll
    // both be persisted.  The parser lets the first one encountered win, and we want the behavior
    // to win.  Bug #94236 (KTam, JHarding)
    if (pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if (HasPeerHolder())
        {
            IGNORE_HR(GetPeerHolder()->SaveMulti(pStreamWrBuff, fAny ? NULL : &fAny));
        }
    }
    
    CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());

    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        Assert(pVTblDesc);
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        // NOTE for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
        {
            continue;
        }

        pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

        if (!pBaseObj)
        {
            continue;
        }

        lpstrUnknownValue = NULL;
        if ( ppropdesc->GetPPFlags() & PROPPARAM_ATTRARRAY)
        {
            AAINDEX aaIx = AA_IDX_UNKNOWN;
            CAttrValue *pAV = NULL;
            CAttrArray *pAA = *(pBaseObj->GetAttrArray());

            if (pAA)
                pAV = pAA->Find(ppropdesc->GetDispid(), CAttrValue::AA_Attribute, &aaIx);

            if (pAA && (!pAV || pAV->IsDefault()))
            {
                if (pAV)
                    aaIx++;

                pAV = pAA->FindAt(aaIx);
                if (pAV)
                {
                    if ((pAV->GetDISPID() == ppropdesc->GetDispid()) &&
                        (pAV->GetAAType() == CAttrValue::AA_UnknownAttr))
                    {
                        // Unknown attrs are always strings
                        lpstrUnknownValue = pAV->GetLPWSTR();
                    }
                    else
                        pAV = NULL;
                }
            }
            fSave = !!pAV;

            // don't save databinding attributes during printing, so that we
            // print the current content instead of re-binding
            if (pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
            {
                DISPID dispid = ppropdesc->GetDispid();
                if (    dispid == DISPID_CElement_dataSrc ||
                        dispid == DISPID_CElement_dataFld ||
                        dispid == DISPID_CElement_dataFormatAs)
                    fSave = FALSE;
            }
        }
        else
        {
            // Save the property if it was not the same as the default.
            // Do not save if we got an error retrieving it.
            fSave = ppropdesc->HandleCompare ( pBaseObj,
                (void *)&ppropdesc->ulTagNotPresentDefault ) == S_FALSE;
        }

        if (fSave)
        {
            fAny = TRUE;

            if (lpstrUnknownValue)
            {
                hr = THR(SaveAttribute(
                    pStreamWrBuff,
                    (LPTSTR)ppropdesc->pstrName,
                    (LPTSTR)lpstrUnknownValue,  // pchValue
                    NULL,                       // ppropdesc
                    NULL,                       // pBaseObj
                    FALSE));                    // fEqualSpaces
            }
            else
            {
                if (ppropdesc->IsBOOLProperty())
                {
                    hr = THR(SaveAttribute(
                        pStreamWrBuff,
                        (LPTSTR)ppropdesc->pstrName,
                        NULL,                       // pchValue
                        NULL,                       // ppropdesc
                        NULL,                       // pBaseObj
                        FALSE));                    // fEqualSpaces
                }
                else
                    hr = THR(SaveAttribute(
                        pStreamWrBuff,
                        (LPTSTR)ppropdesc->pstrName,
                        NULL,                       // pchValue
                        ppropdesc,                  // ppropdesc
                        pBaseObj,                   // pBaseObj
                        FALSE));                    // fEqualSpaces
            }
        }
    }

    hr = SaveUnknown(pStreamWrBuff, fAny ? NULL : &fAny);
    if (hr)
        goto Cleanup;

    // If we are persisting for anything other than printing, then
    // save behavior attributes at this point (compat).
    if (!pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if (HasPeerHolder())
        {
            IGNORE_HR(GetPeerHolder()->SaveMulti(pStreamWrBuff, fAny ? NULL : &fAny));
        }
    }

    if (pfAny)
        *pfAny = fAny;

Cleanup:
    RRETURN (hr);

}


//+------------------------------------------------------------------------
//
//  Member:     CElement::SaveAttributes
//
//  Synopsis:   Save the attributes into property bag
//
//-------------------------------------------------------------------------

HRESULT
CElement::SaveAttributes ( IPropertyBag * pPropBag, BOOL fSaveBlankAttributes )
{
    CPtrBagVTableAggregate::CIterator vTableIterator(const_cast<CPtrBagVTableAggregate *>(GetStringTableAggregate()));

    HRESULT             hr = S_OK;
    CVariant            Var;
    BOOL                fSave;
    CBase               *pBaseObj;

    if (!vTableIterator._pAggregateTable)
        goto Cleanup;
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        Assert(pVTblDesc);
        const PROPERTYDESC *ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(ppropdesc);

        // NOTE for now check for the method pointer because of old property implementation...
        if (!ppropdesc->pfnHandleProperty)
        {
            continue;
        }

        pBaseObj = GetBaseObjectFor (ppropdesc->GetDispid());

        if (!pBaseObj)
        {
            continue;
        }

        if (ppropdesc->GetPPFlags() & PROPPARAM_ATTRARRAY)
        {
            AAINDEX aaIx;
            aaIx = pBaseObj->FindAAIndex ( ppropdesc->GetDispid(), CAttrValue::AA_Attribute );
            fSave = ( aaIx == AA_IDX_UNKNOWN ) ? FALSE : TRUE;
        }
        else
        {
            // Save the property if it was not the same as the default.
            // Do not save if we got an error retrieving it.
            fSave = ppropdesc->HandleCompare ( pBaseObj,
                (void *)&ppropdesc->ulTagNotPresentDefault ) == S_FALSE;
        }

        if (fSave)
        {
            // If we're dealing with a BOOL type, don't put a value
            if ( ppropdesc->IsBOOLProperty() )
            {
                // Boolean (flag), skip the =<val>
                Var.vt = VT_EMPTY;
            }
            else
            {
                hr = THR(ppropdesc->HandleGetIntoBSTR ( pBaseObj, &V_BSTR(&Var) ));
                if (hr)
                    continue;
                V_VT(&Var) = VT_BSTR;
            }
            hr = pPropBag->Write(ppropdesc->pstrName, &Var);
            if (hr)
                goto Cleanup;
            // if Var has an Allocated value, we need to free it before
            // going around the loop again.
            VariantClear(&Var);
        }
    }

    hr = SaveUnknown(pPropBag, fSaveBlankAttributes);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//  Notes:      pBranch should always be non-scoped. This is the only way
//              that the context information can be maintained. each element
//              HandleMessage which uses pBranch needs to be very careful
//              to scope first.
//
//-------------------------------------------------------------------------

HRESULT
CElement::HandleMessage(CMessage *pmsg)
{
    HRESULT     hr                  = S_FALSE;

    // Only the marquee is allowed to cheat and pass the wrong
    // context in
    Assert(IsInMarkup());

    if (pmsg->message == WM_SETCURSOR && pmsg->htc == HTC_BEHAVIOR && pmsg->lBehaviorCookie )
    {
        if ( CHECK_EDIT_BIT( GetMarkup(), _fOverrideCursor ))
        {
            hr = S_OK; // we don't touch the cursor - up to the host.        
            goto Cleanup;
        }
        
        CPeerHolder *pPH = FindPeerHolder(pmsg->lBehaviorCookie);

        if (pPH)
        {
            hr = pPH->SetCursor(pmsg->lBehaviorPartID);
        }
    }

    if (hr != S_OK)
    {
        CLayout * pLayout = GetUpdatedLayout( pmsg->pLayoutContext );

        if (pLayout)
        {
            Assert(!pmsg->fStopForward);
            hr = THR(pLayout->HandleMessage(pmsg));
            if (hr != S_FALSE || pmsg->fStopForward)
                goto Cleanup;
        }
        else if (   WM_CONTEXTMENU == pmsg->message
                &&  HasCapture()
                &&  !Doc()->_pInPlace->_fBubbleInsideOut)
        {
            hr = THR(OnContextMenu(
                    (short) LOWORD(pmsg->lParam),
                    (short) HIWORD(pmsg->lParam),
                    CONTEXT_MENU_DEFAULT));
        }


        if (pmsg->message == WM_SETCURSOR)
        {
            hr = THR_NOTRACE(SetCursorStyle((LPTSTR)NULL, GetFirstBranch()));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     DisallowSelection
//
//  Synopsis:   Returns TRUE iff selection must be diallowed.
//
//-------------------------------------------------------------------------

BOOL
CElement::DisallowSelection()
{
    // In dialogs, only editable controls can be selected
    return ((Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
         && !(ShouldHaveLayout() && GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->_fAllowSelectionInDialog && IsEnabled()));
}


//+------------------------------------------------------------------------
//
//  Member:     CloseErrorInfo
//
//  Synopsis:   Pass the call to the form so it can return its clsid
//              instead of the object's clsid as in CBase.
//
//-------------------------------------------------------------------------

HRESULT
CElement::CloseErrorInfo(HRESULT hr)
{
    Doc()->CloseErrorInfo(hr);

    return hr;
}

LPCTSTR GetCursorForStyle( BYTE iIndex )
{

    static const LPCTSTR aStyleToCursor[] = 
    {
        IDC_ARROW,                       // auto map to arrow
        IDC_CROSS,                       // map to crosshair
        IDC_ARROW,                       // default map to arrow
        MAKEINTRESOURCE(IDC_HYPERLINK),  // hand map to IDC_HYPERLINK
        IDC_SIZEALL,                     // move map to SIZEALL
        IDC_SIZEWE ,                     // e-resize
        IDC_SIZENESW,                    // ne-resize
        IDC_SIZENWSE,                    // nw-resize
        IDC_SIZENS,                      // n-resize
        IDC_SIZENWSE,                    // se-resize
        IDC_SIZENESW,                    // sw-resize
        IDC_SIZENS,                      // s-resize
        IDC_SIZEWE ,                     // w-resize
        IDC_IBEAM,                       // text
        IDC_WAIT,                        // wait
#if(WINVER >= 0x0400)
        IDC_HELP,                        // help as IDC_help
#else
        IDC_ARROW,                       // help as IDC_ARROW
#endif
        MAKEINTRESOURCE(IDC_HYPERLINK),  // pointer maps to IDC_HYPERLINK

        //
        // New cursors
        //
        IDC_APPSTARTING,                 // "spinning"
        IDC_NO,                          // "not-allowed"
                
        MAKEINTRESOURCE(IDC_HYPERLINK_OFFLINE),               // "no-drop"        
        MAKEINTRESOURCE(IDC_HIBEAM),                          // vertical text
        MAKEINTRESOURCE(IDC_NOSCROLLVH),                      // all-scroll - need to find    
        MAKEINTRESOURCE(IDC_RESIZECOL2),                      // "col-resize"
        MAKEINTRESOURCE(IDC_RESIZEROW2),                      // "row-resize"
    };
    Assert(iIndex >= 0 && iIndex < ARRAY_SIZE(aStyleToCursor));

    return aStyleToCursor[iIndex];
}

CCustomCursor*
GetCustomCursorForNode(CTreeNode* pStartNode)
{
    const CFancyFormat* pFF = pStartNode->GetFancyFormat();  
    CTreeNode * pNodeParent;

    if ( pStartNode->Element()->HasMasterPtr() )
    {
        pNodeParent = pStartNode->Element()->GetMasterIfSlave()->GetFirstBranch();
    }
    else
        pNodeParent = pStartNode->Parent();
                
    while (  pFF->_iCustomCursor == -1 && pNodeParent )
    {            
        pFF = pNodeParent->GetFancyFormat();

        if ( pNodeParent->Element()->HasMasterPtr() )
        {
            pNodeParent = pNodeParent->Element()->GetMasterIfSlave()->GetFirstBranch();
        }
        else
            pNodeParent = pNodeParent->Parent();
    }
    
    if ( pFF->_iCustomCursor != -1 )
    {
        return GetCustomCursorFromCacheEx( pFF->_iCustomCursor );             
    }          

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member  :   SetCursorStyle
//
//  Synopsis : if the element.style.cursor property is set then on the handling
//      of the WM_CURSOR we should set the cursor to the one specified in
//      the style.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::SetCursorStyle(LPCTSTR idcArg, CTreeNode* pContext /* = NULL */)
{
    HRESULT hr = E_FAIL;
    LPCTSTR idc = NULL;
    HCURSOR hCurNew = NULL;
    
    
    const CCharFormat * pCF;

    if (!IsInMarkup())
        goto Cleanup;

    if (CHECK_EDIT_BIT( GetMarkup(), _fOverrideCursor ))
    {
        return S_OK; // we don't touch the cursor - up to the host.        
    }

    
    pContext = pContext ? pContext : GetFirstBranch();
    if (!pContext)
        goto Cleanup;

    pCF = pContext->GetCharFormat();
    Assert(pCF);


    if (GetMarkup()->_fShowWaitCursor)
    {
        // Waiting for page to navigate.  Show wait cursor.
        idc = IDC_APPSTARTING;
    }
    else if (  !IsParentEditable() 
             && pCF->_bCursorIdx 
             && pCF->_bCursorIdx  != styleCursorNotSet)
    {
        // The style is set to something other than auto
        // so use g_aStyleToCursor to map the enum to a cursor id.

        if ( pCF->_bCursorIdx != styleCursorcustom )
        {
            idc = GetCursorForStyle( pCF->_bCursorIdx );
        }
        else
        {
            CCustomCursor* pCust = GetCustomCursorForNode( pContext );
            if ( pCust )
            {
                hCurNew = pCust->GetCursor();
            }
#if DBG == 1
            else
            {
                AssertSz(0,"Didn't find Custom Cursor");
            }
#endif      
        }
    }
    else if (pCF->HasVerticalLayoutFlow() && idcArg == IDC_IBEAM)
    {
        idc = MAKEINTRESOURCE(IDC_HIBEAM);
    }
    else if (idcArg)
    {
        idc = idcArg;
    }
    else
    {
        // We didn't handle it.
        idc = NULL;

        //
        // check for style of 'auto' + style set on parent. 
        //
        if ( ! IsParentEditable() &&
             pCF->_bCursorIdx == styleCursorAuto )
        {
            CTreeNode* pNode = pContext->Parent();
            pCF = pNode ? pNode->GetCharFormat() : NULL ;
            
            if ( pNode && pCF &&
                 pCF->_bCursorIdx != styleCursorAuto &&
                 pCF->_bCursorIdx != styleCursorNotSet )
            {
                idc = idcArg ? idcArg : 
                               ( pCF->HasVerticalLayoutFlow() ? MAKEINTRESOURCE(IDC_HIBEAM) : IDC_IBEAM);
            }                 
        }
    }

    if (idc || hCurNew )
    {
        SetCursorIDC(idc, hCurNew );
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE );
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMSuperscript
//
//  Synopsis:   Tests the element passed is a superscript
//
//  Arguments:  CTreeNode *  element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a superscript element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMSuperscript(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return etag == ETAG_SUP;
}

//+------------------------------------------------------------------------
//
//  Function:   IsIDMSubscript
//
//  Synopsis:   Tests the element passed is a subscript
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a subscript element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMSubscript(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return etag == ETAG_SUB;
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMBold
//
//  Synopsis:   Tests the element passed is a Bold or Strong element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a bold/strong element
//
//-----------------------------------------------------------------------------
BOOL
IsIDMBold(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return (etag == ETAG_B || etag == ETAG_STRONG);
}


//+------------------------------------------------------------------------
//
//  Function:   IsIDMCharAttr
//
//  Synopsis:   Tests the element passed is a character attribute.  This
//              function is used to determine whether an element is a
//              candidate for deletion when the user selects "remove
//              character formatting" (aka "set to normal.")
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a not "normal"
//
//-----------------------------------------------------------------------------

BOOL
IsIDMCharAttr(CTreeNode * pNode)
{
    return pNode->Element()->HasFlag(TAGDESC_EDITREMOVABLE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsIDMItalic
//
//  Synopsis:   Tests the element passed is a Italic or Cite element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a Italic/Cite element
//
//-----------------------------------------------------------------------------

BOOL
IsIDMItalic(CTreeNode * pNode)
{
    ELEMENT_TAG etag = pNode->Tag();

    return (etag == ETAG_I || etag == ETAG_EM || etag == ETAG_CITE);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsIDMUnderlined
//
//  Synopsis:   Tests the element passed is a Underline element
//
//  Arguments:  CTreeNode *   element to be tested.
//
//  Returns:    BOOL    TRUE if the element passed is a Underline element
//
//-----------------------------------------------------------------------------

BOOL
IsIDMUnderlined(CTreeNode * pNode)
{
    return (pNode->Tag() == ETAG_U);
}


//+----------------------------------------------------------------------------
//
//  Function:   WriteTag
//
//  Synopsis:   writes an open/end tag to the stream buffer
//
//  Arguments:  pStreamWrBuff   -   stream buffer
//              fEnd            -   TRUE if End tag is to be written out
//              fForce          -   Force writing of tag
//              fAtomic         -   Save as atomic tag (ie, <tagname />)
//
//  Returns:    S_OK    if  successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::WriteTag(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd, BOOL fForce, BOOL fAtomic)
{
    HRESULT         hr = S_OK;
    DWORD           dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    const TCHAR *   pszTagName = TagName();
    const TCHAR *   pszScopeName;
    ELEMENT_TAG     etag = Tag();

    //
    // Do not write tags out in plaintext mode or when we are
    // explicitly asked not to.
    //
    if (pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT)
        || !pszTagName[0]
        || (this == pStreamWrBuff->GetElementContext()
            && pStreamWrBuff->TestFlag(WBF_NO_TAG_FOR_CONTEXT)
           )
        || (fEnd
            && (TagHasNoEndTag(Tag())
                || (!_fExplicitEndTag
                    && !HasFlag(TAGDESC_SAVEALWAYSEND)
                    && !fForce
                   )
                || fAtomic
               )
           )
       )
    {
        goto Cleanup;
    }

    if(fEnd)
    {
        hr = pStreamWrBuff->Write(_T("</"), 2);
    }
    else
    {
        CExtendedTagDesc *  pExtendedTagDesc = GetExtendedTagDesc();
        if ( pExtendedTagDesc && !pStreamWrBuff->TestFlag( WBF_FOR_TREESYNC ) )
        {
            hr = THR(pStreamWrBuff->EnsurePIsSaved(this, pExtendedTagDesc, HasIdentityPeerHolder() ? XMLNAMESPACEDECL_IMPORT : XMLNAMESPACEDECL_TAG));
            if (hr)
                goto Cleanup;
        }

        if (pStreamWrBuff->TestFlag(WBF_FOR_RTF_CONV) &&
            Tag() == ETAG_DIV)
        {
            // For the RTF converter, transform DIV tags into P tags.
            pszTagName = SZTAG_P;
        }

        // NOTE: In IE4, we would save a NewLine before every
        // element that was a ped.  This is roughly equivalent
        // to saving it before every element that is a container now
        // However, this does not round trip properly so I'm taking
        // that check out.

        if (    ! pStreamWrBuff->TestFlag(WBF_NO_PRETTY_CRLF)
            &&  (   HasFlag(TAGDESC_SAVETAGOWNLINE)
                ||  IsBlockTag() ) )
        {
            hr = pStreamWrBuff->NewLine();
            if (hr)
                goto Cleanup;
        }
        hr = pStreamWrBuff->Write(_T("<"), 1);
    }

    if(hr)
        goto Cleanup;


    pszScopeName = pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && 
               pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML) &&
               Tag() != ETAG_GENERIC
                    ? NamespaceHtml() : Namespace();

    if (pszScopeName)
    {
        hr = pStreamWrBuff->Write(pszScopeName);
        if(hr)
            goto Cleanup;

        hr = pStreamWrBuff->Write(_T(":"));
        if(hr)
            goto Cleanup;
    }

    hr = pStreamWrBuff->Write(pszTagName);
    if(hr)
        goto Cleanup;

    if(!fEnd)
    {
        BOOL fAny;

        hr = SaveAttributes(pStreamWrBuff, &fAny);
        if(hr)
            goto Cleanup;

        if (ETAG_HTML == etag)
        {
            Assert (IsInMarkup());

            hr = THR(GetMarkup()->SaveXmlNamespaceAttrs(pStreamWrBuff));
            if (hr)
                goto Cleanup;
        }

        // If saving as an atomic tag, add a trailing slash
        if( fAtomic )
        {
            hr = THR( pStreamWrBuff->Write(_T(" /"), 2 ) );
            if( hr )
                goto Cleanup;
        }
    }

    hr = pStreamWrBuff->Write(_T(">"), 1);
    if (hr)
        goto Cleanup;

#if 0
    if(fEnd && HasFlag(TAGDESC_SAVENEWLINEATEND))
    {
            hr = pStreamWrBuff->NewLine();
            if (hr)
                    goto Cleanup;
    }
#endif

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldFlags);

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE
CElement::scrollIntoView(VARIANTARG varargStart)
{
    HRESULT                hr;
    SCROLLPIN              spVert;
    BOOL                   fStart;
    CVariant               varBOOLStart;

    hr = THR(varBOOLStart.CoerceVariantArg(&varargStart, VT_BOOL));
    if ( hr == S_OK )
    {
        fStart = V_BOOL(&varBOOLStart);
    }
    else if ( hr == S_FALSE )
    {
        // when no argument
        fStart = TRUE;
    }
    else
        goto Cleanup;

    spVert = fStart ? SP_TOPLEFT : SP_BOTTOMRIGHT;

    hr = THR(ScrollIntoView(spVert, SP_TOPLEFT));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::DeferScrollIntoView(SCROLLPIN spVert, SCROLLPIN spHorz )
{
    HRESULT hr;

    GWKillMethodCall (this, ONCALL_METHOD(CElement, DeferredScrollIntoView, deferredscrollintoview), 0);
    hr = THR(GWPostMethodCall (this, ONCALL_METHOD(CElement, DeferredScrollIntoView, deferredscrollintoview),
                                (DWORD_PTR)(spVert | (spHorz << 16)), FALSE, "CElement::DeferredScrollIntoView"));
    return hr;
}

void
CElement::DeferredScrollIntoView(DWORD_PTR dwParam)
{
    SCROLLPIN spVert = (SCROLLPIN)((DWORD)dwParam & 0xffff);
    SCROLLPIN spHorz = (SCROLLPIN)((DWORD)dwParam >> 16);

    IGNORE_HR(ScrollIntoView(spVert, spHorz));
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetAtomTable, virtual override from CBase
//
//-------------------------------------------------------------------------

CAtomTable *
CElement::GetAtomTable (BOOL *pfExpando)
{
    CAtomTable  *pat = NULL;
    CDoc        *pDoc;

    pDoc = Doc();
    if (pDoc)
    {
        pat = &(pDoc->_AtomTable);
        if (pfExpando)
        {
            CMarkup *pMarkupContext = IsInMarkup() ? GetMarkupPtr()->GetWindowedMarkupContext()
                                                   : (HasWindowedMarkupContextPtr() ?  GetWindowedMarkupContextPtr() : NULL);
            *pfExpando = pMarkupContext ? pMarkupContext->_fExpando : TRUE;
        }
    }

    // We should have an atom table otherwise there's a problem.
    Assert(pat && "Element is not associated with a CDoc.");

    return pat;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::GetPlainTextInScope
//
//  Synopsis:   Returns a text string containing all the plain text in the
//              scope of this element. The caller must free the memory.
//              This function can be used to merely retrieve the text
//              length by setting ppchText to NULL.
//
//  Arguments:  pstrText    If NULL,
//                              no text is returned.
//                          If not NULL but there is no text,
//                              *pstrText is set to NULL.
//                          Otherwise
//                              *pstrText points to a new CStr
//
//-------------------------------------------------------------------------

HRESULT
CElement::GetPlainTextInScope(CStr * pstrText)
{
    HRESULT     hr = S_OK;
    long        cp, cch;

    Assert(pstrText);

    if(!IsInMarkup())
    {
        pstrText->Set(NULL);
        goto Cleanup;
    }

    cp = GetFirstCp();
    cch = GetElementCch();

    {
        CTxtPtr     tp( GetMarkup(), cp );

        cch = tp.GetPlainTextLength(cch);

        // copy text into buffer

        pstrText->SetLengthNoAlloc(0);
        hr = pstrText->ReAlloc(cch);
        if (hr)
        {
            pstrText->Set(NULL);
            goto Cleanup;
        }

        cch = tp.GetPlainText(cch, (LPTSTR)*pstrText);

        Assert(cch >= 0);

        if (cch)
        {
            // Terminate with 0. GetPlainText() does not seem to do this.
            pstrText->SetLengthNoAlloc(cch);
            *(LPTSTR(*pstrText) + cch) = 0;
        }
        else
        {
            // just making sure...
            pstrText->Free();
        }
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
// Member: GetAccessKey & MatchAccessKey
//
//-----------------------------------------------------------------------------

// In lieu of the C Run-time function _totlower() that we are not linking with
#define TOTLOWER(ch)  (TCHAR((DWORD)(DWORD_PTR)CharLower((LPTSTR)(DWORD_PTR)ch)))
// TODO - yinxie, need to make sure this will work for non IBM compatible keyboards
// Caps Lock scan code = 0x3a, all keys higher than this will not be allowed in access key
#ifndef UNIX
#define ISVALIDKEY(x)   (((x >> 16) & 0x00FF) < 0x3a)
#else
inline BOOL ISVALIDKEY(LPARAM x) { return (MwCharacterFromWM_KEY(x) != 0); }
#endif

#define VIRTKEY_TO_SCAN 0

VOID
ConvertMessageToUnicode(CMessage* pmsg, WCHAR* pwchKey )
{
    Assert( pwchKey );
    *pwchKey = (TCHAR) pmsg->wParam;

    if(pmsg->message == WM_SYSKEYDOWN && pmsg->wParam > 31)
    {
        BYTE bKeyState[256];
        if(GetKeyboardState(bKeyState))
        {
            WORD cBuf[2];
            int cchBuf;
            HKL hkl = GetKeyboardLayout(0);

            UINT wScanCode = MapVirtualKeyEx(pmsg->wParam, VIRTKEY_TO_SCAN, hkl);
            cchBuf = ToAsciiEx(pmsg->wParam, wScanCode, bKeyState, cBuf, 1, hkl);

            if(cchBuf == 1)
            {
                WCHAR wBuf[2];
                UINT  uKbdCodePage = GetKeyboardCodePage();

                MultiByteToWideChar(uKbdCodePage, 0, (char *)cBuf, 2, wBuf, 2);
                *pwchKey = wBuf[0];
            }
        }
    }   
}

BOOL
CElement::MatchAccessKey(CMessage * pmsg, long lSubDivision, WCHAR* pwch )
{
    // TODO (MohanB) lSubDivision is ignored for now. Should make this work
    // to get accesskey working on AREAs.

    BOOL    fMatched = FALSE;
    LPCTSTR lpAccKey = GetAAaccessKey();
    WCHAR chKey;
    
    // Raid 57053
    // If we are in HTML dialog, accessKey can be matched with/without
    // SHIFT/CTRL/ALT keys.
    //
    if ( ! pwch )
    {
        pwch = & chKey;     
        ConvertMessageToUnicode( pmsg, pwch );
    }
    
    // 60711 - Translate the virtkey to unicode for foreign languages.
    // We only test for 0x20 (space key) or above. This way we avoid
    // coming in here for other system type keys

 
    if ((pmsg->message == WM_SYSKEYDOWN ||
                    (Doc()->_fInHTMLDlg && pmsg->message == WM_CHAR))
            && lpAccKey
            && lpAccKey[0]
            && TOTLOWER((TCHAR) *pwch) == TOTLOWER(lpAccKey[0])
            && ISVALIDKEY(pmsg->lParam))
    {
        fMatched = TRUE;
    }
    return fMatched;
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowMessage
//
//--------------------------------------------------------------------------

HRESULT __cdecl
CElement::ShowMessage(
        int * pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT  idsMessage, ...)
{
    CDoc *              pDoc = Doc();
    HRESULT             hr = S_OK;
    va_list             arg;

    va_start(arg, idsMessage);

    if (pDoc)
    {
        hr = THR(pDoc->ShowMessageV(
            pnResult,
            dwFlags,
            dwHelpContext,
            idsMessage,
            &arg));
    }

    va_end(arg);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowMessageV
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowMessageV(
                int   * pnResult,
                DWORD   dwFlags,
                DWORD   dwHelpContext,
                UINT    idsMessage,
                void  * pvArgs)
{
    RRETURN (Doc()->ShowMessageV(pnResult, dwFlags, dwHelpContext, idsMessage, pvArgs));
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowLastErrorInfo
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowLastErrorInfo(HRESULT hr, int iIDSDefault)
{
    RRETURN (Doc()->ShowLastErrorInfo(hr, iIDSDefault));
}

//+-------------------------------------------------------------------------
//
// Member::    CElement::ShowHelp
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowHelp(TCHAR * szHelpFile, DWORD dwData, UINT uCmd, POINT pt)
{
    RRETURN (Doc()->ShowHelp(szHelpFile, dwData, uCmd, pt));
}

CBase *CElement::GetOmWindow(CMarkup * pMarkup /* = NULL */)
{
    if (!pMarkup && IsInMarkup())
    {
        pMarkup = GetMarkup();
    }

    if (pMarkup)
    {
        Assert(!IsInMarkup() || pMarkup == GetMarkup());
      
        return pMarkup->Window();
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::UndoManager
//
//  Synopsis:   Get the undo manager
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
IOleUndoManager *
CElement::UndoManager()
{
    return Doc()->UndoManager();
}
#endif // NO_EDIT

//+-------------------------------------------------------------------------
//
//  Method:     CElement::QueryCreateUndo
//
//  Synopsis:   Query whether to create undo or not.  Also dirties the doc.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
BOOL
CElement::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( pfTreeSync )
    {
        CMarkup * pMarkup;
        *pfTreeSync = FALSE;

        if( IsInMarkup() )
        {
            pMarkup = GetMarkup();
            
            *pfTreeSync = pMarkup->HasLogManager() && pMarkup->GetLogManager()->IsAnyoneListening();
        }
    }

    if( fDirtyChange && IsInMarkup() )
    {
        GetMarkup()->SetDirtyFlag();
    }

    return Doc()->QueryCreateUndo( fRequiresParent, fDirtyChange, NULL );
}

HRESULT
CElement::LogAttributeChange( CStyle * pStyle, DISPID dispidProp, VARIANT * pvarOld, VARIANT * pvarNew )
{
    CMarkup * pMarkup;
    ATTR_CHANGE_FLAGS lFlags = ATTR_CHANGE_NONE;
    CBase * pBase = this;

    AssertSz( IsInMarkup(), "Shouldn't be trying to log attr change w/out a markup" );
    pMarkup = GetMarkup();

    Assert( pMarkup->HasLogManager() && pMarkup->GetLogManager()->IsAnyoneListening() );

    if( pStyle )
    {
        lFlags = ( GetRuntimeStylePtr() == pStyle ) ? ATTR_CHANGE_RUNTIMESTYLE : ATTR_CHANGE_INLINESTYLE;
        pBase = pStyle;
    }

    IGNORE_HR( pMarkup->GetLogManager()->AttrChangeProp( this, pBase, lFlags, dispidProp, pvarOld, pvarNew ) );

    return S_OK;
}

#endif // NO_EDIT


//+-------------------------------------------------------------------------
//
//  Method:     CElement::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CElement::ShowTooltipInternal(CMessage *pmsg, POINT pt, CDoc * pDoc)
{
    HRESULT hr = S_FALSE;
    RECT    rc;
    TCHAR * pchString;
    BOOL fRTL = FALSE;

    if (pDoc->State() < OS_INPLACE)
        goto Cleanup;

#if DBG == 1
    TCHAR  achBuf[100];

    if (IsTagEnabled(tagFormatTooltips))
    {
        CTreeNode *pNode = pmsg->pNodeHit;

        Format(0,
               achBuf,
               100,
               L"<0s>  SN=<1d>\n_iCF=<2d>  _iPF=<3d>  _iFF=<4d>",
               pNode->Element()->TagName(),
               pNode->SN(),
               pNode->_iCF,
               pNode->_iPF,
               pNode->_iFF);

        pchString = achBuf;
    }
    else
#endif
    //
    // if there is a title property, use it as tooltip
    //

    pchString = (LPTSTR) GetAAtitle();
    if (pchString != NULL)
    {
        GetElementRc(&rc, GERC_CLIPPED | GERC_ONALINE, &pt);

        //It is possible to have an empty rect when an
        //element doesn't have a TxtSite above it.
        //Should this be an ASSERT or TODO?
        if(IsRectEmpty(&rc))
        {
            rc.left = pt.x - 10;
            rc.right = pt.x + 10;
            rc.top = pt.y - 10;
            rc.bottom = pt.y + 10;
        }

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        // COMPLEXSCRIPT - determine if element is right to left for tooltip style setting
        if(GetFirstBranch())
        {
            fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        }
        
        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(pchString, pDoc->_pInPlace->_hwnd, *pmsg, &rc, (DWORD_PTR) GetMarkup(), (DWORD_PTR) this, fRTL);
        }

        hr = S_OK;
    }

Cleanup:
    return hr;
}

#ifndef WIN16
BEGIN_TEAROFF_TABLE(CElementFactory, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(super, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(super, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(super, GetIDsOfNames, getidsofnames, (REFIID riid,
                                          LPOLESTR *prgpsz,
                                          UINT cpsz,
                                          LCID lcid,
                                          DISPID *prgid))
    TEAROFF_METHOD(super, Invoke, invoke, (DISPID dispidMember,
                                   REFIID riid,
                                   LCID lcid,
                                   WORD wFlags,
                                   DISPPARAMS * pdispparams,
                                   VARIANT * pvarResult,
                                   EXCEPINFO * pexcepinfo,
                                   UINT * puArgErr))
    TEAROFF_METHOD(super, GetDispID, getdispid, (BSTR bstrName,
                                      DWORD grfdex,
                                      DISPID *pid))
    TEAROFF_METHOD(CElementFactory, InvokeEx, invokeex, (DISPID id,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS *pdp,
                             VARIANT *pvarRes,
                             EXCEPINFO *pei,
                             IServiceProvider *pSrvProvider))
    TEAROFF_METHOD(super, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(super, DeleteMemberByDispID, deletememberbydispid, (DISPID id))
    TEAROFF_METHOD(super, GetMemberProperties, getmemberproperties, (DISPID id,
                                                DWORD grfdexFetch,
                                                DWORD *pgrfdex))
    TEAROFF_METHOD(super, GetMemberName, getmembername, (DISPID id,
                                          BSTR *pbstrName))
    TEAROFF_METHOD(super, GetNextDispID, getnextdispid, (DWORD grfdex,
                                          DISPID id,
                                          DISPID *pid))
    TEAROFF_METHOD(super, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()
#endif

HRESULT
CElementFactory::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
#ifndef WIN16
        QI_TEAROFF_DISPEX(this, NULL)
#else
    case Data1_IDispatchEx:
        CBase::PrivateQueryInterface(iid, ppv);
        break;
#endif
    QI_TEAROFF(this, IObjectIdentity, NULL)

    default:
        {
            const CLASSDESC *pclassdesc = (const CLASSDESC *) BaseDesc();
            if (pclassdesc &&
                pclassdesc->_apfnTearOff &&
                pclassdesc->_classdescBase._piidDispinterface &&
                (iid == *pclassdesc->_classdescBase._piidDispinterface ))
            {
                hr = THR(CreateTearOffThunk(this, (void *)(pclassdesc->_apfnTearOff), NULL, ppv));
            }
        }
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

HRESULT
CElementFactory::InvokeEx(DISPID dispidMember,
                          LCID lcid,
                          WORD wFlags,
                          DISPPARAMS * pdispparams,
                          VARIANT * pvarResult,
                          EXCEPINFO * pexcepinfo,
                          IServiceProvider *pSrvProvider)
{
    if ( (wFlags & DISPATCH_CONSTRUCT) && (dispidMember == DISPID_VALUE) )
    {
        // turn it into a method call ( expect dispid=0 )
        wFlags &= ~DISPATCH_CONSTRUCT;
        wFlags |= DISPATCH_METHOD;
    }

    RRETURN(super::InvokeEx(dispidMember,
                            lcid,
                            wFlags,
                            pdispparams,
                            pvarResult,
                            pexcepinfo,
                            pSrvProvider));
}


//+----------------------------------------------------------------------------
//
//  Method: LogAttrArray
//
//  Synopsis: Logs the attribute array differences to the Log Manager
//      One AttrArray can be null signifying a CLEAR of an attr array.
//
//      [CStyle *]      pStyle          -   Style object for attr arrays, or NULL
//      [CAttrArray *]  pAttrArrayOld   -   Attr Array of old values
//      [CAttrArray *]  pAttrArrayNew   -   Attr Array of new values
//
//+----------------------------------------------------------------------------
HRESULT CElement::LogAttrArray( CStyle * pStyle, CAttrArray * pAttrArrayOld, CAttrArray *pAttrArrayNew )
{
    CAttrValue * pAVOld;
    CAttrValue * pAVNew;
    CAttrValue * pAV;
    long         cAV;
    CBase      * pBase = pStyle ? (CBase *)pStyle : (CBase *)this;

    AssertSz( pAttrArrayOld || pAttrArrayNew, "Only one attr array can be null here" );

    if( pAttrArrayOld && pAttrArrayNew && pAttrArrayOld->Size() != pAttrArrayNew->Size() )
    {
        AssertSz( FALSE, "Unbalanced Attr Arrays" );
        return E_FAIL;
    }

    pAVOld = pAttrArrayOld ? (CAttrValue *)*pAttrArrayOld : NULL;
    pAVNew = pAttrArrayNew ? (CAttrValue *)*pAttrArrayNew : NULL;
    pAV    = pAVOld ? pAVOld : pAVNew;
    cAV = pAttrArrayOld ? pAttrArrayOld->Size() : pAttrArrayNew->Size();

    for( ; cAV; cAV-- )
    {
        VARIANT                 vtOld;
        VARIANT                 vtNew;
        DISPID                  dispid;
        const PROPERTYDESC  *   pPropDesc;

        // TODO (JHarding): Skipping the nested inline style attr array for now
        if( pAV->GetAAType() == CAttrValue::AA_AttrArray )
            goto NextAttr;

        if( pAV->GetPropDesc() )
        {
            pPropDesc = pAV->GetPropDesc();
            dispid = pPropDesc->GetDispid();
        }
        else
        {
            dispid = pAV->GetDISPID();
            pBase->FindPropDescFromDispID( dispid, const_cast<PROPERTYDESC **>(&pPropDesc), NULL, NULL );
        }

        AssertSz( pPropDesc, "Couldn't find propdesc!" );
        if( pPropDesc )
        {
            VariantInit( &vtOld );
            VariantInit( &vtNew );

            if( pAVOld )
                pAVOld->GetIntoDispatchableVariant( &vtOld, pPropDesc );
            if( pAVNew )
                pAVNew->GetIntoDispatchableVariant( &vtNew, pPropDesc );

            IGNORE_HR( LogAttributeChange( pStyle, dispid, &vtOld, &vtNew ) );

            VariantClear(&vtOld);
            VariantClear(&vtNew);
        }

NextAttr:
        if( pAVOld )
            pAVOld++;
        if( pAVNew )
            pAVNew++;
        pAV++;
    }

    return S_OK;
}
//+----------------------------------------------------------------------------
//
// Member:      CopyCommonAttributes
//
// Synopsis:    Copy the common attributes for a given element to the current
//              element (generally used when replacing an element with another
//              while editing).
//
//-----------------------------------------------------------------------------

HRESULT
CElement::MergeAttributes(CElement *pElementFrom, BOOL fCopyID)
{
    HRESULT         hr = S_OK;
    CAttrArray *    pInLineStyleAAFrom;
    CAttrArray **   ppInLineStyleAATo;
    CAttrArray *    pAAFrom = *(pElementFrom->GetAttrArray());
    CBase *         pelTarget = this;
    CAttrArray *    pAttrUndo = NULL;
    CAttrArray *    pAttrSync = NULL;
    CAttrArray *    pAttrStyleUndo = NULL;
    CAttrArray *    pAttrStyleSync = NULL;
    CMergeAttributesUndo Undo( this );
    BOOL            fCreateUndo;
    BOOL            fTreeSync;

    if (pElementFrom->Tag() == Tag())
        pelTarget = NULL;

    Undo.SetWasNamed( _fIsNamed );
    Undo.SetCopyId( fCopyID );
    Undo.SetPassElTarget( !!pelTarget );

    fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );
    if( pAAFrom && ( fCreateUndo || fTreeSync ) )
    {
        pAttrUndo       = new CAttrArray();
        pAttrStyleUndo  = new CAttrArray();
        if( !pAttrUndo || !pAttrStyleUndo )
        {
            // If we couldn't make these two arrays, we're hosed.
            fTreeSync = FALSE;
            fCreateUndo = FALSE;

            delete pAttrUndo;
            delete pAttrStyleUndo;
        }

        if( fTreeSync )
        {
            pAttrSync      = new CAttrArray();
            pAttrStyleSync = new CAttrArray();

            if( !pAttrSync || !pAttrStyleSync )
            {
                // If we couldn't make these two arrays, tree sync is hosed
                fTreeSync = FALSE;

                delete pAttrSync;
                delete pAttrStyleSync;
            }
        }
    }

    if (pAAFrom)
    {
        CAttrArray     **ppAATo = GetAttrArray();

        hr = THR(pAAFrom->Merge(ppAATo, pelTarget, pAttrUndo, pAttrSync, FALSE, fCopyID));
        if (hr)
            goto Cleanup;

        SetEventsShouldFire();

        // If the From has is a named element then the element is probably changed.
        if (pElementFrom->_fIsNamed && fCopyID)
        {
            _fIsNamed = TRUE;
            // Inval all collections affected by a name change
            DoElementNameChangeCollections();
        }

        pInLineStyleAAFrom = pElementFrom->GetInLineStyleAttrArray();
        if (pInLineStyleAAFrom && pInLineStyleAAFrom->Size())
        {
            ppInLineStyleAATo = CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
            if (!ppInLineStyleAATo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = THR(pInLineStyleAAFrom->Merge(ppInLineStyleAATo, NULL, pAttrStyleUndo, pAttrStyleSync));
            if (hr)
                goto Cleanup;
        }

        if( fTreeSync )
        {
            CStyle     * pStyle = NULL;

            if( pAttrStyleSync->Size() )
                IGNORE_HR( GetStyleObject( &pStyle ) );

            IGNORE_HR( LogAttrArray( NULL, pAttrUndo, pAttrSync ) );
            IGNORE_HR( LogAttrArray( pStyle, pAttrStyleUndo, pAttrStyleSync ) );
                
            delete pAttrSync;
            delete pAttrStyleSync;
        }

        if( fCreateUndo )
        {
            Undo.SetAA( pAttrUndo );
            Undo.SetAAStyle( pAttrStyleUndo );
        }
        else
        {
            delete pAttrUndo;
            delete pAttrStyleUndo;
        }
    }

    IGNORE_HR(Undo.CreateAndSubmit());

Cleanup:

    RRETURN(hr);
}

HRESULT
CElement::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;
    CTreeNode * pNodeForm;
    CTreeNode * pNodeContext = GetFirstBranch();
    CMarkup *   pMarkup;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    if (pNodeContext && pNodeContext->Parent())
    {
        pNodeForm = pNodeContext->Parent()->SearchBranchToRootForTag( ETAG_FORM );

        if (pNodeForm)
        {
            hr = THR( pNodeForm->GetElementInterface( IID_IDispatchEx, (void **) ppunk ) );

            goto Cleanup;
        }
    }

    pMarkup = GetMarkup();
    if (!pMarkup)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(pMarkup->GetDefaultDocument()->PrivateQueryInterface(IID_IDispatchEx, (void**) ppunk));

Cleanup:

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::CanShow
//
//  Synopsis:   Determines whether an element can be shown at this moment.
//
//--------------------------------------------------------------------------
BOOL
CElement::CanShow()
{
    BOOL fRet = TRUE;
    CTreeNode *pNodeSite = GetFirstBranch()->GetUpdatedNearestLayoutNode();

    while (pNodeSite)
    {
        if (!pNodeSite->Element()->GetInfo(GETINFO_ISCOMPLETED))
        {
            fRet = FALSE;
            break;
        }
        pNodeSite = pNodeSite->GetUpdatedParentLayoutNode();
    }
    return fRet;
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::OnCssChangeStable
//
//-------------------------------------------------------------------------

HRESULT
CElement::OnCssChange(BOOL fStable, BOOL fRecomputePeers)
{
    HRESULT     hr = S_OK;

    if (IsInMarkup())
    {
        hr = THR(GetMarkup()->OnCssChange(fStable, fRecomputePeers));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::Invalidate
//
//  Synopsis:   Invalidates the area occupied by the element.
//
//-------------------------------------------------------------------------
void
CElement::Invalidate()
{
    if(!IsInMarkup())
        return;

    SendNotification(NTYPE_ELEMENT_INVALIDATE);
}

//+-------------------------------------------------------------------------
//
//  Method:     GetElementRc
//
//  Synopsis:   Get the bounding rect for the element
//
//  Arguments:  prc:      the rc to be returned
//              dwFlags:  flags indicating desired behaviour
//                           GERC_ONALINE: rc on a line, line indicated by ppt.
//                           GERC_CLIPPED: rc clipped by visible client rect.
//              ppt:      the point around which we want the rect
//
//  Returns:    hr
//
//--------------------------------------------------------------------------

HRESULT
CElement::GetElementRc(RECT *prc, DWORD dwFlags, POINT *ppt)
{
    CDataAry<RECT> aryRects(Mt(CElementGetElementRc_aryRects_pv));
    HRESULT        hr = S_FALSE;
    LONG           i;

    Assert(prc);

    // make sure that current will be calced
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    // Get the region for the element
    GetElementRegion(&aryRects,
                    !(dwFlags & GERC_ONALINE)
                        ? prc
                        : NULL,
                    RFE_SCREENCOORD);

    if (dwFlags & GERC_ONALINE)
    {
        Assert(ppt);
        for (i = 0; i < aryRects.Size(); i++)
        {
            if (PtInRect(&aryRects[i], *ppt))
            {
                *prc = aryRects[i];
                hr = S_OK;
                break;
            }
        }
    }

    if (   (S_OK == hr)
        && (dwFlags & GERC_CLIPPED)
       )
    {
        CRect      rcVisible;
        CDispNode *pDispNode;
        CLayout   *pLayout = GetUpdatedNearestLayout();

        if(!pLayout)
        {
            CElement *pElementClient = CMarkup::GetElementClientHelper(GetMarkup());
            if(pElementClient)
                pLayout = pElementClient->GetUpdatedNearestLayout();
            else
            {
                prc->left = prc->top = prc->right = prc->bottom = 0;
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        Assert(pLayout);
        pDispNode = pLayout->GetElementDispNode(this);

        if (!pDispNode)
        {
            pDispNode = pLayout->GetElementDispNode(pLayout->ElementOwner());
        }


        if (pDispNode)
        {
            pDispNode->GetClippedBounds(&rcVisible, COORDSYS_GLOBAL);
            IntersectRect(prc, prc, &rcVisible);
        }
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
// Member:      CElement::ComputeHorzBorderAndPadding
//
// Synopsis:    Compute horizontal border and padding for a given element
//              The results represent cumulative border and padding up the
//              element's ancestor chain, up to but NOT INCLUDING element's
//              containing layout.  The layout's border should not be counted
//              when determining a contained element's indent, because it lies
//              outside the box boundary from which we are measuring.  The 
//              layout's padding usually does need to be accounted for; the caller
//              must do this! (via GetPadding on the layout's CDisplay).
//
//-----------------------------------------------------------------------------

void
CElement::ComputeHorzBorderAndPadding(CCalcInfo * pci, CTreeNode * pNodeContext, CElement * pElementStop,
                                  LONG * pxBorderLeft, LONG * pxPaddingLeft,
                                  LONG * pxBorderRight, LONG * pxPaddingRight)
{
    Assert(pNodeContext && SameScope(this, pNodeContext));

    Assert(pxBorderLeft || pxPaddingLeft || pxBorderRight || pxPaddingRight);

    CTreeNode * pNode = pNodeContext;
    CBorderInfo borderinfo;
    CElement *  pElement;
    const CFancyFormat * pFF;
    const CParaFormat *  pPF;
    const CCharFormat *  pCF;
    BOOL fNodeVertical;
    BOOL fWritingModeUsed;

    Assert(pxBorderLeft && pxPaddingLeft && pxBorderRight && pxPaddingRight);

    *pxBorderLeft = 0;
    *pxBorderRight = 0;
    *pxPaddingLeft = 0;;
    *pxPaddingRight = 0;

    while(pNode && pNode->Element() != pElementStop)
    {
        pElement = pNode->Element();
        pFF = pNode->GetFancyFormat();
        pPF = pNode->GetParaFormat();
        pCF = pNode->GetCharFormat();
        fNodeVertical = pCF->HasVerticalLayoutFlow();
        fWritingModeUsed = pCF->_fWritingModeUsed;

        // We only want to compute the border and padding for 
        // block elements. Inline border and padding should not
        // be accounted for here.
        if (pFF->_fBlockNess)
        {
            if ( !pElement->_fDefinitelyNoBorders )
            {
                pElement->_fDefinitelyNoBorders = !GetBorderInfoHelper( pNode, pci, &borderinfo, GBIH_NONE );

                *pxBorderRight  += borderinfo.aiWidths[SIDE_RIGHT];
                *pxBorderLeft   += borderinfo.aiWidths[SIDE_LEFT];
            }

            *pxPaddingLeft  += pFF->GetLogicalPadding(SIDE_LEFT, fNodeVertical, fWritingModeUsed).XGetPixelValue(pci,
                                        pci->_sizeParent.cx, pPF->_lFontHeightTwips);
            *pxPaddingRight += pFF->GetLogicalPadding(SIDE_RIGHT, fNodeVertical, fWritingModeUsed).XGetPixelValue(pci,
                                        pci->_sizeParent.cx, pPF->_lFontHeightTwips);
        }

        pNode = pNode->Parent();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::Clone
//
//  Synopsis:   Make a new one just like this one
//
//-------------------------------------------------------------------------

HRESULT
CElement::Clone ( CElement * * ppElementClone, CDoc * pDoc )
{
    HRESULT          hr;
    CAttrArray *     pAA;
    CStr             cstrPch;
    CElement       * pElementNew = NULL;
    const CTagDesc * ptd;
    CHtmTag          ht;
    BOOL             fDie = FALSE;
    ELEMENT_TAG      etag = Tag();
    
    Assert( ppElementClone );

    if (IsGenericTag( etag ))
    {
        hr = THR( cstrPch.Set( Namespace() ) );

        if (hr)
            goto Cleanup;

        hr = THR( cstrPch.Append( _T( ":" ) ) );

        if (hr)
            goto Cleanup;

        hr = THR( cstrPch.Append( TagName() ) );

        if (hr)
            goto Cleanup;
    }
    else if (etag == ETAG_UNKNOWN)
    {
        hr = THR( cstrPch.Append( TagName() ) );

        if (hr)
            goto Cleanup;
    }

    ptd = TagDescFromEtag( etag );

    if (!ptd)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ht.Reset();
    ht.SetTag( etag );
    ht.SetPch( cstrPch );
    ht.SetCch( cstrPch.Length() );

    if (etag == ETAG_INPUT)
    {
        hr = THR(CInput::CreateElement(&ht, pDoc, &pElementNew, (htmlInput)(DYNCAST(CInput, this)->GetType())));
        if (hr)
            goto Cleanup;

        DYNCAST(CInput, pElementNew)->_fScriptCreated = TRUE;
    }
    else
        hr = ptd->_pfnElementCreator( & ht, pDoc, & pElementNew );

    if (hr)
        goto Cleanup;

    if (fDie)
        goto Die;

    hr = THR( pElementNew->Init() );

    if (hr)
        goto Cleanup;

    if (fDie)
        goto Die;

    pElementNew->_fBreakOnEmpty = _fBreakOnEmpty;
    pElementNew->_fExplicitEndTag = _fExplicitEndTag;

    pAA = * GetAttrArray();

    if (pAA)
    {
        CAttrArray * * ppAAClone = pElementNew->GetAttrArray();

        hr = THR( pAA->Clone( ppAAClone ) );

        if (hr)
            goto Cleanup;

        if (fDie)
            goto Die;
    }

    pElementNew->_fIsNamed = _fIsNamed;

    if( HasIdentityPeerHolder() )
    {
        ht.SetExtendedTag();
        ht.SetDynamic();
    }

    {
        CInit2Context   context(&ht, IsInMarkup() ? GetMarkupPtr() : GetWindowedMarkupContext(), INIT2FLAG_EXECUTE);

        hr = THR( pElementNew->Init2(&context) );
    }
    if (hr)
        goto Cleanup;

    if (etag == ETAG_INPUT)
    {
        CStr cstrValue;

        hr = THR(DYNCAST(CInput, this)->GetValueHelper(&cstrValue));
        if (hr)
            goto Cleanup;

        hr = THR(DYNCAST(CInput, pElementNew)->SetValueHelper(&cstrValue));
        if (hr)
            goto Cleanup;
    }

    if (fDie)
        goto Die;

    pElementNew->SetEventsShouldFire();

    if (ETAG_RAW_COMMENT == etag)
    {
        hr = THR(DYNCAST(CCommentElement, pElementNew)->_cstrText.Set(DYNCAST(CCommentElement, this)->_cstrText));
        if  (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr && pElementNew)
        CElement::ClearPtr( & pElementNew );

    *ppElementClone = pElementNew;
    RRETURN(hr);

Die:
    hr = E_ABORT;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::StealAttributes, public
//
//  Synopsis:   Steals the attributes from another element.
//
//  Arguments:  [pElementVictim] -- Element to steal attributes from.
//
//  Returns:    HRESULT
//
//  Notes:      Used when we want to replace one element with another, after
//              we've computed all the formats and created the attribute bag.
//
//----------------------------------------------------------------------------

HRESULT
CElement::StealAttributes(CElement * pElementVictim)
{
    _pAA = pElementVictim->_pAA;
    pElementVictim->_pAA = NULL;


    // TODO rgardner - Why do we do this ? Why not just steal the attr array & the format indices,
    // and set the indices in the victim to -1 ????


    // After we have stolen the attr array, we must adjust
    // any addrefs for images that the victim may be holding on to.

    if (pElementVictim->_fHasImage)
    {
        int n;
        long lCookie;

        // Add ref any image context cookies this element holds

        for (n = 0; n < ARRAY_SIZE(s_aryImgDispID); ++n)
        {
            if ( _pAA->FindSimple(s_aryImgDispID[n].cacheID, (DWORD *)&lCookie,
                                  CAttrValue::AA_Internal) )
            {
                CDoc *  pDoc = Doc();

                // Replace ref on victim with one on thief
                pDoc->AddRefUrlImgCtx(lCookie, this);
                pDoc->ReleaseUrlImgCtx(lCookie, pElementVictim);
            }
        }

        _fHasImage = TRUE;
        pElementVictim->_fHasImage = FALSE;
    }

    // some of the properties depend on the element being
    // a site so do not copy format indicies.

    return S_OK;
}



//+-----------------------------------------------------------------
//
//  members : get_filters
//
//  synopsis : IHTMLELement implementaion to return the filter collection
//
//-------------------------------------------------------------------
HRESULT
CElement::get_filters(IHTMLFiltersCollection **ppFilters)
{
    HRESULT    hr;
    BOOL       fAdded;

    CFilterBehaviorSite *  pFilterSite;

    // make sure ComputeFormats is called so that filter tasks are interted
    //  into the queue
    CTreeNode * pNode = GetFirstBranch();
    if (!pNode)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    // This will ensure that the filter string is available
    pNode->GetFancyFormatIndex();

    // Make sure that all the pending filters re created
    Doc()->ExecuteFilterTasks(&fAdded);

    hr = THR(EnsureFilterBehavior(FALSE, &pFilterSite));
    if(FAILED(hr))
        goto Cleanup;

    Assert(pFilterSite);

    hr = THR(pFilterSite->GetIHTMLFiltersCollection(ppFilters));

    if(fAdded)
    {
        // make sure GetSize is being called on filters
        hr = THR(EnsureRecalcNotify());
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CElement::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

HRESULT
CElement::setCapture(VARIANT_BOOL containerCapture)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    if (!pDoc || (pDoc->State() < OS_INPLACE) || pDoc->_fOnLoseCapture)
        goto Cleanup;

    pDoc->SetMouseCapture(
            MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage, handlecapturemessage),
            this,
            containerCapture == VB_TRUE);
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CElement::releaseCapture()
{
    TakeCapture(FALSE);
    RRETURN(SetErrorInfo(S_OK));
}

BOOL
CElement::HasCapture()
{
    return Doc()->HasCapture(this);
}

BOOL
CElement::WantTextChangeNotifications()
{
    if( !CurrentlyHasAnyLayout() )
        return FALSE;

    // TODO (KTam): Rewrite this to be cleaner.
    // Basically we're trying to do an IsListening call, which
    // tells us whether a flow layout has been calc'ed or not.
    // Think about implementing a virtual IsListening on CLayoutInfo
    // and keeping current CFlowLayout::IsListening as a non-virtual
    // helper (for perf, since IsListening is called heavily inside
    // CFlowLayout).
    CFlowLayout * pFlowLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->IsFlowLayout();
    if( pFlowLayout && pFlowLayout->IsListening() )
        return TRUE;

    return FALSE;
}

void
CElement::Notify(CNotification * pnf)
{
    CFilterBehaviorSite *  pFilterSite;
    IStream *              pStream = NULL;

    Assert(pnf);

    if (HasPeerHolder())
    {
        GetPeerHolder()->OnElementNotification(pnf);
    }

    switch (pnf->Type())
    {
    
    case NTYPE_MARKUP_RENDER_STYLE:
    {
        if ( HasSlavePtr() &&
             GetSlavePtr()->GetMarkup()->GetElementClient() )
        {
            CNotification nf;
            CTreePos* ptpFirst;
            CTreePos* ptpEnd;
            CMarkup* pMarkup = GetSlavePtr()->GetMarkup();
            
            pMarkup->GetElementClient()->GetTreeExtent( & ptpFirst, & ptpEnd );    
            nf.MarkupRenderStyle( ptpFirst->GetCp(), ptpEnd->GetCp() - ptpFirst->GetCp(), pnf->DataAsPtr() );
            
            pMarkup->Notify( & nf );
        }
    }
    break;
    
    case NTYPE_AMBIENT_PROP_CHANGE:
        pFilterSite = GetFilterSitePtr();
        if (pFilterSite)
        {
            DISPID  dispid;
            ICSSFilter   * pICSSFilter = NULL;

            pnf->Data(&dispid);
            if(!pFilterSite->GetICSSFilter(&pICSSFilter))
            {
                pICSSFilter->OnAmbientPropertyChange(dispid);
                pICSSFilter->Release();
            }
        }
        Invalidate();
        break;

    case NTYPE_COMMAND:
        pFilterSite = GetFilterSitePtr();
        if (pFilterSite)
        {
            COnCommandExecParams *  pParams;

            pnf->Data((void **)&pParams);
            pFilterSite->OnCommand(pParams);
        }
        break;

    case NTYPE_FAVORITES_LOAD:
    case NTYPE_XTAG_HISTORY_LOAD:
    case NTYPE_SNAP_SHOT_SAVE:
        {
            IHTMLPersistData *  pPersist = GetPeerPersist();

            if (pPersist)
            {
                CPtrAry<CElement *> *   pary;

                pnf->Data((void **)&pary);
                pary->Append(this);
                pPersist->Release();
            }
        }
        break;

    case NTYPE_ACTIVE_MOVIE:
        if (Tag() != ETAG_INPUT && HasSlavePtr())
        {
            CElement *      pElemSlave  = GetSlavePtr();
            CNotification   nf;
            void * pv;

            Assert(pElemSlave && pElemSlave->Tag() == ETAG_ROOT);

            pnf->Data(&pv);

            nf.ActiveMovie(pElemSlave, pv);
            pElemSlave->SendNotification(&nf);
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CElement *  pElemSlave = GetSlavePtr();
        
            if (pElemSlave->IsInMarkup())
            {
                pnf->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_XTAG_HISTORY_SAVE:
        {
            void * pv;

            pnf->Data(&pv);
            IGNORE_HR(TryPeerPersist(XTAG_HISTORY_SAVE, pv));
        }
        // Follow through in the normal SAVE_HISTORY notification since we need to
        // bubble the notification to any viewlinked elements.

    case NTYPE_SAVE_HISTORY_2:
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CElement *  pElemSlave = GetSlavePtr();
        
            if (pElemSlave->IsInMarkup())
            {
                HRESULT             hr = S_OK;
                CHistorySaveCtx *   phsc;

                pnf->Data((void **)&phsc);

                hr = THR(phsc->BeginSaveStream((0xF000000 | GetSourceIndex()), HistoryCode(), &pStream));
                if (hr)
                    goto Cleanup;

                pElemSlave->GetMarkup()->SaveHistoryInternal(pStream, phsc->_dwOptions);

                hr = THR(phsc->EndSaveStream());
                if (hr)
                    goto Cleanup;
            }
        }
        break;

    case NTYPE_FAVORITES_SAVE:
        {
            void * pv;

            pnf->Data(&pv);
            IGNORE_HR(TryPeerPersist(FAVORITES_SAVE, pv));
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        {
            CMarkup * pMarkup = GetMarkup();
            CDoc *  pDoc = pMarkup->Doc();
            CMarkupTransNavContext * ptnc = pMarkup->GetTransNavContext();

            if (ptnc && ptnc->_historyCurElem.lIndex >= 0 &&
                HistoryCode() == ptnc->_historyCurElem.dwCode)
            {
                long   lSrcIndex  = GetSourceIndex();

                Assert(lSrcIndex >= 0);

                if (   !pMarkup->_fUserInteracted 
                    &&  lSrcIndex == ptnc->_historyCurElem.lIndex)
                {
                    if (IsEnabled())
                    {
                        pDoc->_fFirstTimeTab = FALSE;
                        BecomeCurrent(ptnc->_historyCurElem.lSubDivision);
                    }
                    
                    // found the current element
                    ptnc->_historyCurElem.lIndex = -1;
                    pMarkup->EnsureDeleteTransNavContext(ptnc);
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITVIEW_1:
        // If we have expressions on this elements remove them from the recalc engine 
        // they will be re-added when the element comes back into view
        SuspendExpressionRecalc();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if( HasPeerHolder() || HasAccObjPtr() )
        {
            pnf->SetData( pnf->DataAsDWORD() | EXITTREE_DELAYRELEASENEEDED );
        }

#ifndef NO_DATABINDING
        if (GetDataMemberManager())
        {
            GetDataMemberManager()->Notify(pnf);
        }
#endif

        // Remove this element's expressions (if any) from the recalc engine
        SuspendExpressionRecalc();

        ExitTree( pnf->DataAsDWORD() );

        // Notify slave tree (however, INPUT slave tree is not interesting
        // and doesn't need to hear this).
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            Assert(_fExittreePending);
            if (IsConnectedToPrimaryWindow())
            {
                // Requrest second-chance since olesites may inplace-deactivate
                // on exitview.
                if (GetSlavePtr()->GetMarkup()->GetObjectRefs() > 1)
                {
                    pnf->SetSecondChanceRequested();
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        // Notify slave tree (however, INPUT slave tree is not interesting
        // and doesn't need to hear this).
        if (HasSlavePtr() && Tag() != ETAG_INPUT)
        {
            CNotification   nf;
            CElement *      pElemSlave = GetSlavePtr();

            Assert(pElemSlave->Tag() == ETAG_ROOT);

            // Send ExitView notify to the slave tree since it is
            // getting diconnected from the primary markup.
            // For perf reasons we do that only if there is more than 
            // one reference to the master

            nf.ElementExitview1(pElemSlave);

            // TODO (greglett)
            // ExitView does not notify self - so we need to manually notify the ROOT element.
            // Right now, self and second-chance are mutually exclusive.  We need to fix this.
            pElemSlave->Notify(&nf);

            pElemSlave->SendNotification(&nf);
        }
        break;

    case NTYPE_RELEASE_EXTERNAL_OBJECTS:
        // NOTE in most cases we don't receive the notification
        if (HasPeerHolder())
        {
            // delete peer holder ptr and release the peer holder
            DelPeerHolder()->PrivateRelease();
        }
        break;

    case NTYPE_RECOMPUTE_BEHAVIOR:
        IGNORE_HR(ProcessPeerTask(PEERTASK_RECOMPUTEBEHAVIORS));
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        EnterView();
        break;

    case NTYPE_VISIBILITY_CHANGE:
// TODO:   Sanitize this by making official throughout the code that layout-like notifications
//         targeted at positioned elements without layouts are re-directed to the nearest layout.
//         This redirection should be done in CMarkup::NotifyElement rather than ad hoc. (brendand)
//        Assert(GetFirstBranch()->GetCascadedposition() == stylePositionrelative);
        Assert(!ShouldHaveLayout());
        {
            CLayout *   pLayout = GetUpdatedNearestLayout();

            if (pLayout)
            {
                WHEN_DBG(pnf->ResetSN());
                pLayout->Notify(pnf);
            }
        }
        break;

    case NTYPE_MARKUP_UNLOAD_2:
        if (HasSlavePtr())
        {
            CElement *  pElemSlave = GetSlavePtr();
            
            if (pElemSlave && 
                pElemSlave->IsInMarkup() &&
                pElemSlave->GetMarkup()->HasWindow())
            {
                pElemSlave->GetMarkup()->TearDownMarkup();
            }
        }
        
        break;

    case NTYPE_MARKUP_UNLOAD_1:
        if (HasSlavePtr())
        {
            pnf->SetSecondChanceRequested();
        }

        // Fall thru
    case NTYPE_STOP_1:
        if (pnf->Type() != NTYPE_MARKUP_UNLOAD_1)
        {
            if (HasSlavePtr())
            {
                CElement *  pElemSlave = GetSlavePtr();
            
                if (pElemSlave && pElemSlave->IsInMarkup())
                {
                    pElemSlave->GetMarkup()->ExecStop();
                }
            }
        }
        // Fall thru
        
    case NTYPE_STOP_2:
    case NTYPE_BEFORE_UNLOAD:
        if (HasPeerMgr())
        {
            CPeerMgr * pPeerMgr = GetPeerMgr();
            pPeerMgr->DelDownloadProgress();
        }
#ifndef NO_DATABINDING
        if (GetDataMemberManager())
        {
            GetDataMemberManager()->Notify(pnf);
        }
#endif
        break;


    case NTYPE_ELEMENT_INVAL_Z_DESCENDANTS:
        {
            // TODO (carled) this notification should really be unnecessary. what it
            // (and the one above) are crying for is a Notifcation for OnPropertyChange
            // so that descendants can take specific action.  More generally, there are
            // other OPP things like VoidCachedInfo that are duplicating the Notification
            // logic (walking the subtree) which could get rolled into this.  unifiying 
            // these things could go a long way to streamlining the code, and preventing
            // inconsistencies and lots of workarounds. (like this notification)
            //
            // This notification is targeted at positioned elements which are children of 
            // the element that sent it. We do not want to delegate to the nearest Layout
            // since if they are positioned, they have thier own. Since the source element2
            // may not have a layout we have to use the element tree for the routing.

            CLayoutInfo *   pLayoutInfo = GetUpdatedLayoutInfo();

            if (IsPositioned())
            {
                if (pLayoutInfo)
                {
                    WHEN_DBG(pnf->ResetSN());
                    pLayoutInfo->Notify(pnf);
                }
                else
                {
                    Invalidate();
                }
            }
        }
        break;
    case NTYPE_SHOW_WAIT_CURSOR:
        if (HasSlavePtr())
        {
            CElement *pElemSlave = GetSlavePtr();

            if (pElemSlave && pElemSlave->IsInMarkup())
            {
                Assert(pnf->IsDataValid());
                pElemSlave->GetMarkup()->_fShowWaitCursor = pnf->DataAsDWORD() ? TRUE : FALSE;
            }
        }
        break;
    case NTYPE_CHANGE_ACCELERATOR:
        {
            for (CTreeNode *pNode = GetFirstBranch();
                 pNode != NULL;
                 pNode = pNode->NextBranch()
                )
            {
                if (pNode->GetCharFormat()->_fAccelerator)
                {
                    pNode->VoidCachedInfo();
                    Assert(pnf->IsDataValid());
                    // Indicate that there are still accelerators around
                    pnf->SetData((DWORD)1);
                }
            }
        }
        break;
    } // switch
    
Cleanup:
    ClearInterface(&pStream);
    return;
}

HRESULT
CElement::EnterTree()
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkup;
    InlineEvts *    pInlineEvts;
    BOOL            fInView = IsConnectedToPrimaryWindow();

    Assert( IsInMarkup() );

    pMarkup = GetMarkup();

    // hook up any script for\event handlers attached to this id'd element
    if (pMarkup->_fHasScriptForEvent && !pMarkup->_fMarkupServicesParsing && IsNamed() && (Tag() != ETAG_SCRIPT))
    {
        IGNORE_HR(pDoc->CommitScripts(pMarkup, this));
    }

    // Connect up event handlers...
    if (!pMarkup->_fMarkupServicesParsing || (Tag() == ETAG_OBJECT))
    {
        pInlineEvts = GetEventsToHook();
        if (pInlineEvts)
        {
            BOOL fConnect = TRUE;
            if (pMarkup->HasBehaviorContext())
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                fConnect = pComponent ? !pComponent->_fFactoryComponent : TRUE;
            }

            if (fConnect)
                pInlineEvts->Connect(pDoc, this);

            delete pInlineEvts;
            StoreEventsToHook(NULL);
        }
    }

    // While we're in a markup, we'll use its WMC ptr
    if ( HasWindowedMarkupContextPtr() )
        DelWindowedMarkupContextPtr()->SubRelease();

    // behaviors
    hr = THR(ProcessPeerTask(PEERTASK_ENTERTREE_UNSTABLE));
    if (hr)
        goto Cleanup;

    // other
    if (fInView)
    {
        EnterView();
    }
    
    //  Init is currently called in the procedure that actually creates the layout.
    //  It does not need to be called here.
    //if (ShouldHaveLayout())
    //{
    //    GetUpdatedLayout()->Init();
    //}
 
    if (pMarkup->CollectionCache())
    {
        OnEnterExitInvalidateCollections(FALSE);
    }

    if (HasSlavePtr() && HasDefaults())
    {
        CDefaults * pDefaults = GetDefaults();

        // Make sure that a cycle is not being created
        Assert(GetSlavePtr()->GetMarkup());

        if (IsCircularViewLink(GetSlavePtr()->GetMarkup()))
        {
            // Found a cycle! Break the viewLink
            hr = THR(pDefaults->put_viewLink(NULL));
            if (hr)
                goto Cleanup;

            Assert(!HasSlavePtr());
#if DBG == 1
            {
                IHTMLDocument * pISlave = NULL;
                Assert(S_OK == pDefaults->get_viewLink(&pISlave) && !pISlave);
            }
#endif
        }
    }

    if (fInView && HasSlavePtr())
    {
        // broadcast an ENTERVIEW notification to the slave content
        CElement *      pElemSlave  = GetSlavePtr();
        CNotification   nf;

        Assert(pElemSlave && pElemSlave->Tag() == ETAG_ROOT);
        nf.ElementEnterview1(pElemSlave);

        // TODO (greglett)
        // EnterView does not notify self - so we need to manually notify the ROOT element.
        // Right now, self and second-chance are mutually exclusive.  We need to fix this.
        pElemSlave->Notify(&nf);

        // INPUTs never have an interesting markup.  Their tree doesn't need to hear this.
        if (Tag() != ETAG_INPUT)
            pElemSlave->SendNotification(&nf);
    }

Cleanup:
    
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::EnterView
//
//  Synopsis:   Update the focus collection, initiate data binding, etc.
//
//-------------------------------------------------------------------------

void
CElement::EnterView()
{
    CDoc * pDoc = Doc();

    AttachDataBindings();
    if (_fSurface)
    {
        ++ pDoc->_cSurface;
    }
    if (_f3DSurface)
    {
        ++ pDoc->_c3DSurface;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::ExitTree
//
//  Synopsis:   Remove the element from the tree, cleanup
//
//-------------------------------------------------------------------------

void
CElement::ExitTree( DWORD dwExitFlags )
{
    CMarkup         * pMarkup = GetMarkup();
    CDoc            * pDoc  = pMarkup->Doc();
    CLayout         * pLayout;   

    Assert(IsInMarkup());
    
    pDoc->OnElementExit(this, dwExitFlags);
    
    if (!pMarkup->_fInnerHTMLMarkup)
    {
        if( !(dwExitFlags & EXITTREE_DESTROY))
        {
            pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
    
            if (!IsParentFrozen() &&
                ((pLayout &&  pLayout->IsAdorned()) ||
                ShouldHaveLayout()))
            {
                Assert( pLayout && "Should always have a layout due to, thought we might not need it" );
                //
                // We now send the notification for adorned elements - or 
                // any LayoutElement leaving the tree.
                //
                //
                // TODO marka - make this work via the adorner telling the selection manager
                // to change state. Also make sure _fAdorned is cleared on removal of the Adorner
                //
                IUnknown* pUnknown = NULL;
                IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
                IGNORE_HR( pDoc->NotifySelection( EDITOR_NOTIFY_EXIT_TREE , pUnknown ));
                ReleaseInterface( pUnknown );
            }
            pLayout = NULL;
        }
    
        if (pDoc->GetView()->HasAdorners())
        {
            Verify(pDoc->GetView()->OpenView());
            pDoc->GetView()->RemoveAdorners(this);
        }
    
    }
    if (pMarkup->HasCollectionCache())
    {
        OnEnterExitInvalidateCollections(FALSE);
    }

    //
    // Filters do not survive tree changes
    //
    if (_fHasPendingFilterTask)
    {
        pDoc->RemoveFilterTask(this);
        Assert(!_fHasPendingFilterTask);
    }

    // If we don't have any lookasides we don't have to do *any* of the following tests!
    if (_fHasLookasidePtr)
    {
        if (HasPeerHolder() && !(dwExitFlags & EXITTREE_PASSIVATEPENDING))
        {
            IGNORE_HR(ProcessPeerTask(PEERTASK_EXITTREE_UNSTABLE));
        }

#ifndef NO_DATABINDING
        if (HasDataBindPtr())
        {
            DetachDataBindings();
        }
#endif

        if (HasPeerMgr())
        {
            CPeerMgr * pPeerMgr = GetPeerMgr();
            pPeerMgr->OnExitTree();
        }

        //  According to an old, ex-comment: This must happen after the filter has been detached.
        if ( (_fSurface || _f3DSurface) &&
             ( (dwExitFlags & EXITTREE_DOSURFACECOUNT) ||
               (!(dwExitFlags & EXITTREE_DESTROY) && IsConnectedToPrimaryMarkup())
             ))
        {
            if (_fSurface)
            {
                Assert(Doc()->_cSurface > 0);
                Doc()->_cSurface--;
            }
            if (_f3DSurface)
            {
                Assert(Doc()->_c3DSurface > 0);
                Doc()->_c3DSurface--;
            }
        }

        // If we've queued layout requests on other layouts, we need to
        // mark the request as dead, since we're leaving the tree and don't
        // need to be serviced.  Refs on the CRequest obj are held by the
        // corresponding layouts, so we don't need to release here -- instead
        // we'll let the layout's ProcessRequests take care of it.
        if (HasRequestPtr())
        {
            GetRequestPtr()->RemoveFromLayouts();
            AssertSz( !HasRequestPtr(), "Removing from layouts should have caused request to go away!" );
        }
    }

    // Remember our WMC before we go back to the ether
    Assert( !HasWindowedMarkupContextPtr() );

    // TODO (JHarding) - If we can't set this pointer, this element is in bad shape.
    if( !SetWindowedMarkupContextPtr( GetWindowedMarkupContext() ) )
        GetWindowedMarkupContextPtr()->SubAddRef();

    if (HasLayoutPtr())
    {
        CLayout *   pLayout;

        GetUpdatedLayout()->OnExitTree();

        if (!_fLayoutAlwaysValid)
        {
            pLayout = DelLayoutPtr();

            pLayout->Detach();
            pLayout->Release();
        }
    }
    // We may have multiple layouts!
    else if ( HasLayoutAry() )
    {
        CLayoutAry *pLA;

        pLA = GetLayoutAry();
        pLA->OnExitTree();

        if ( !_fLayoutAlwaysValid )
        {
            DelLayoutAry(); // will take care of detaching/releasing its layouts
        }            
    }
}

//+------------------------------------------------------------------------
//  Member:     CElement::SuspendExpressionRecalc
//
//  Synopsis:   If we have expressions on this element remove them from the 
//              recalc engine - they will be re-added to the recalc engine 
//              when the element comes back into view
//-------------------------------------------------------------------------

void
CElement::SuspendExpressionRecalc()
{
    CDoc    * pDoc =  Doc();

    if (_fHasPendingRecalcTask)
        pDoc->RemoveExpressionTask(this);

    if (_fHasExpressions)
        pDoc->_recalcHost.removeAllExpressions(this);
}

//+---------------------------------------------------------------------------------
//
//  Member :    CElement::IsEqualObject()
//
//  Synopsis :  IObjectIdentity method implementation. it direct comparison of two
//              pUnks fails, then the script engines will QI for IObjectIdentity and
//              call IsEqualObject one one, passing in the other pointer.
//
//   Returns : S_OK if the Objects are the same
//             E_FAIL if the objects are different
//
//----------------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CElement::IsEqualObject(IUnknown * pUnk)
{
    HRESULT      hr = E_POINTER;
    IServiceProvider * pISP = NULL;
    IUnknown   * pUnkTarget = NULL;
    IUnknown   * pUnkThis = NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IUnknown, (void **)&pUnkThis));
    if (hr)
        goto Cleanup;

    if (pUnk == pUnkThis)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_ELEMENT_SCOPE_OBJECT,
                                        IID_IUnknown,
                                        (void**)&pUnkTarget));
    if (hr)
        goto Cleanup;

    hr = (pUnkThis == pUnkTarget) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    ReleaseInterface(pUnkTarget);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method : CElement :: QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//-----------------------------------------------------------------------------
HRESULT
CElement::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    if (IsEqualGUID(guidService, SID_ELEMENT_SCOPE_OBJECT))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
    }
    else if (IsEqualGUID(guidService, CLSID_HTMLWindow2))
    {
        CMarkup * pMarkup = GetNearestMarkupForScriptCollection();

        Assert(pMarkup);
        Assert(pMarkup->HasWindow());

        *ppvObject = pMarkup->Window()->Window();

        hr = S_OK;
    }
    else if (IsEqualGUID(guidService, IID_IAccessible))
    {
        CAccBase * pAccObj = GetAccObjOfElement(this);

        // The pointer we receive is not addref'd QI for IAccessible and return that.
        // To make sure, we expect that the riid == IID_IAccessible

        // It is possible to receive a NULL pointer from the function call in case
        // the element is not accessible.
        if (pAccObj)
        {
            hr = THR(pAccObj->QueryInterface( riid, ppvObject));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        hr = THR_NOTRACE(super::QueryService(guidService, riid, ppvObject));
        if (hr == E_NOINTERFACE)
        {
            if (IsInMarkup())
            {
                CDocument * pDocument = GetMarkup()->Document();
                
                if (pDocument)
                {
                    hr = THR_NOTRACE(pDocument->QueryService(guidService, riid, ppvObject));
                }
            }
            else
            {
                hr = THR_NOTRACE(Doc()->QueryService(guidService, riid, ppvObject));
            }
        }
    }

Cleanup:
    RRETURN1( hr, E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextThunk_Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CElement::ContextThunk_Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT         hr;
    IDispatchEx    *pDispEx;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    if (!pUnkContext)
        pUnkContext = (IUnknown*)this;

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->InvokeExMulti(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL));
        if (DISP_E_MEMBERNOTFOUND != hr) // if succeced or failed with error other then DISP_E_MEMBERNOTFOUND
            goto Cleanup;
    }

    hr = THR(pUnkContext->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = ContextInvokeEx(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            NULL,
            pUnkContext ? pUnkContext : (IUnknown*)this);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
        ReleaseInterface(pDispEx);
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextThunk_InvokeEx, IDispatchEx
//
//  Synopsis:   Gets node context from eax and passes it to ContextInvokeEx
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP CElement::ContextThunk_InvokeEx(DISPID dispidMember,
                                             LCID lcid,
                                             WORD wFlags,
                                             DISPPARAMS * pdispparams,
                                             VARIANT * pvarResult,
                                             EXCEPINFO * pexcepinfo,
                                             IServiceProvider *pSrvProvider)
{
    HRESULT     hr;
    IUnknown *  pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    hr = THR_NOTRACE(CElement::ContextInvokeEx(dispidMember,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  pSrvProvider,
                                  pUnkContext ? pUnkContext : (IUnknown*)this));

    RRETURN (hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CElement::ContextInvokeEx, IDispatchEx
//
//  Synopsis:   Real implementation of InvokeEx.  Uses context passed
//              in for actual calls
//
//--------------------------------------------------------------------------

STDMETHODIMP CElement::ContextInvokeEx(DISPID dispidMember,
                                    LCID lcid,
                                    WORD wFlags,
                                    DISPPARAMS * pdispparams,
                                    VARIANT * pvarResult,
                                    EXCEPINFO * pexcepinfo,
                                    IServiceProvider *pSrvProvider,
                                    IUnknown *pUnkContext)
{
    HRESULT     hr;

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->InvokeExMulti(
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider));
        if (DISP_E_MEMBERNOTFOUND != hr) // if succeced or failed with error other then DISP_E_MEMBERNOTFOUND
            goto Cleanup;
    }

    hr = THR_NOTRACE(CBase::ContextInvokeEx(dispidMember,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  pSrvProvider,
                                  pUnkContext ? pUnkContext : (IUnknown*)this));

Cleanup:
    RRETURN (hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT         hr;

    if (GetFrameOrPrimaryMarkup())
    {
        GetFrameOrPrimaryMarkup()->ProcessPeerTasks(0);
    }

    if (HasPeerHolder())
    {
        hr = THR_NOTRACE(GetPeerHolder()->GetDispIDMulti(bstrName, grfdex, pid));
        if (DISP_E_UNKNOWNNAME != hr) // if succeeded or failed with error other then DISP_E_UNKNOWNNAME
            goto Cleanup;
    }

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetExpandoDispID, helper
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetExpandoDispID(BSTR bstrName, DISPID * pid, DWORD grfdex)
{
    return GetExpandoDISPID(bstrName, pid, grfdex);
}

HRESULT
CElement::GetExpandoDISPID(LPTSTR pchName, DISPID *pid, DWORD grfdex)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetExpandoDispID(pchName, pid, grfdex));
    if (hr)
        goto Cleanup;

    if (TestClassFlag(ELEMENTDESC_OLESITE))
    {
        DYNCAST(COleSite, this)->RemapActivexExpandoDispid(pid);
    }

Cleanup:

    RRETURN (hr);
}


//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetNextDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetNextDispID(DWORD grfdex, DISPID dispid, DISPID * pdispid)
{
    HRESULT         hr = S_FALSE;
    CPeerHolder *   pPeerHolder;

    if (!IsPeerDispid(dispid))
    {
        hr = THR_NOTRACE(super::GetNextDispID(grfdex, dispid, pdispid));
        if (S_FALSE != hr)  // if (S_OK == hr || FAILED(hr))
            goto Cleanup;
    }

    pPeerHolder = GetPeerHolder();

    if (pPeerHolder)
    {
        hr = THR_NOTRACE(pPeerHolder->GetNextDispIDMulti(grfdex, dispid, pdispid));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CElement::GetMemberName, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CElement::GetMemberName(DISPID dispid, BSTR * pbstrName)
{
    HRESULT         hr;

    if (IsPeerDispid(dispid))
    {
        CPeerHolder *   pPeerHolder = GetPeerHolder();

        if (pPeerHolder)
        {
            hr = THR_NOTRACE(pPeerHolder->GetMemberNameMulti(dispid, pbstrName));
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }

        goto Cleanup;   // done
    }

    hr = THR_NOTRACE(super::GetMemberName(dispid, pbstrName));

Cleanup:
    RRETURN2(hr, DISP_E_MEMBERNOTFOUND, DISP_E_UNKNOWNNAME);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetMultiTypeInfoCount, per IProvideMultipleClassInfo
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetMultiTypeInfoCount(ULONG * pCount)
{
    HRESULT     hr;

    if (GetReadyState() < READYSTATE_COMPLETE)
        RRETURN (E_UNEXPECTED);

    Assert (pCount);
    if (!pCount)
        RRETURN (E_POINTER);

    hr = THR(super::GetMultiTypeInfoCount(pCount));
    if (hr)
        goto Cleanup;

    if (HasPeerHolder())
    {
        hr = THR(GetPeerHolder()->GetCustomEventsTypeInfoCount(pCount));
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::GetInfoOfIndex, per IProvideMultipleClassInfo
//
//----------------------------------------------------------------------------

HRESULT
CElement::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID *       piidPrimary,
    IID *       piidSource)
{
    HRESULT         hr;

    if (GetReadyState() < READYSTATE_COMPLETE)
        RRETURN (E_UNEXPECTED);

    if (HasPeerHolder())
    {
        hr = THR(GetPeerHolder()->CreateCustomEventsTypeInfo(iTI, ppTICoClass));
        if (S_FALSE != hr)  // if (S_OK == hr || FAILED(hr))
            goto Cleanup;   // nothing more to do
        // S_FALSE indicated that this belongs to super
    }

    hr = THR(super::GetInfoOfIndex(
        iTI, dwFlags, ppTICoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::CreateTearOffThunk
//
//----------------------------------------------------------------------------

HRESULT
CElement::CreateTearOffThunk(
    void *      pvObject1,
    const void * apfn1,
    IUnknown *  pUnkOuter,
    void **     ppvThunk,
    void *      appropdescsInVtblOrder)
{
    CPeerHolder *   pPeerHolderInQI = GetPeerHolderInQI();
    if (pPeerHolderInQI)
    {
        return ::CreateTearOffThunk(
            pvObject1,
            apfn1,
            pUnkOuter,
            ppvThunk,
            pPeerHolderInQI,
            *(void **)(IUnknown *)pPeerHolderInQI,
            QI_MASK | ADDREF_MASK | RELEASE_MASK,
            NULL,
            appropdescsInVtblOrder);
    }
    else
    {
        return ::CreateTearOffThunk(
            pvObject1,
            apfn1,
            pUnkOuter,
            ppvThunk,
            appropdescsInVtblOrder);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::CreateTearOffThunk
//
//----------------------------------------------------------------------------

HRESULT
CElement::CreateTearOffThunk(
    void*       pvObject1,
    const void * apfn1,
    IUnknown *  pUnkOuter,
    void **     ppvThunk,
    void *      pvObject2,
    void *      apfn2,
    DWORD       dwMask,
    const IID * const * apIID,
    void *      appropdescsInVtblOrder)
{
    CPeerHolder *   pPeerHolderInQI = GetPeerHolderInQI();
    if (pPeerHolderInQI && !pvObject2)
    {
        pvObject2 = pPeerHolderInQI;
        apfn2 = *(void **)(IUnknown *)pPeerHolderInQI;
        dwMask |= QI_MASK | ADDREF_MASK | RELEASE_MASK;
    }

    return ::CreateTearOffThunk(
        pvObject1,
        apfn1,
        pUnkOuter,
        ppvThunk,
        pvObject2,
        apfn2,
        dwMask,
        apIID,
        appropdescsInVtblOrder);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::get_dir
//
//  Synopsis: Object model entry point to get the dir property.
//
//  Arguments:
//            [p]  - where to return BSTR containing the string
//
//  Returns:  S_OK                  - this element supports this property
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_OUTOFMEMORY         - memory allocation failure
//            E_POINTER             - NULL pointer to receive BSTR
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElement::get_dir(BSTR * p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if ( p )
        *p = NULL;

    hr = s_propdescCElementdir.b.GetEnumStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::put_dir
//
//  Synopsis: Object model entry point to put the dir property.
//
//  Arguments:
//            [v]  - BSTR containing the new property value (ltr or rtl)
//
//  Returns:  S_OK                  - successful
//            DISP_E_MEMBERNOTFOUND - this element doesn't support this
//                                    property
//            E_INVALIDARG          - the argument is not one of the enum string
//                                    values (ltr or rtl)
//
//----------------------------------------------------------------------------
STDMETHODIMP
CElement::put_dir(BSTR v)
{
    HRESULT hr;

    hr = s_propdescCElementdir.b.SetEnumStringProperty(
                v,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CElement::GetLookasidePtr(int iPtr) const
{
#if DBG == 1
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CElement::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CElement::DelLookasidePtr(int iPtr)
{
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

void *
CElement::GetLookasidePtr2(int iPtr) const
{
#if DBG == 1
    if(HasLookasidePtr2(iPtr))
    {
        void * pLookasidePtr2 =  Doc()->GetLookasidePtr2((DWORD *)this + iPtr);

        Assert(pLookasidePtr2 == _apLookAside2[iPtr]);

        return pLookasidePtr2;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr2(iPtr) ? Doc()->GetLookasidePtr2((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CElement::SetLookasidePtr2(int iPtr, void * pvVal)
{
    Assert (!HasLookasidePtr2(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr2((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr2 |= 1 << iPtr;

#if DBG == 1
        _apLookAside2[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CElement::DelLookasidePtr2(int iPtr)
{
    if (HasLookasidePtr2(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr2((DWORD *)this + iPtr);
        _fHasLookasidePtr2 &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside2[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Native accessibility support
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//  Member  :   AccObjForTag
//
//  Synopsis:   Creates and returns a CAccBase derived instance, 
//              depending on the tag of the element. If the tag is not supported
//              the tabindex is checked if the flag is set. 
//----------------------------------------------------------------------------
CAccElement * 
CElement::AccObjForTag()
{
    switch (Tag())
    {
        case ETAG_BODY:
        case ETAG_FRAMESET:
            return new CAccBody( this );
            break;

        case ETAG_A:
          return new CAccAnchor( this );
          break;

        case ETAG_AREA:
            return new CAccArea( this );
            break;

        case ETAG_BUTTON:
            return new CAccButton( this );
            break;

        case ETAG_IMG:
            return new CAccImage( this );
            break;

        case ETAG_MARQUEE:
            return new CAccMarquee( this );
            break;

        case ETAG_TEXTAREA:
            return new CAccEdit( this, FALSE);
            break;

        case ETAG_INPUT:
            {
                htmlInput type = DYNCAST(CInput, this)->GetAAtype();
                switch(type)
                {
                case htmlInputCheckbox:
                    return new CAccCheckbox( this );

                case htmlInputRadio:
                   return new CAccRadio( this );

                case htmlInputImage:
                    return new CAccInputImg( this );

                case htmlInputButton:
                case htmlInputReset:
                case htmlInputSubmit:
                    return new CAccButton( this );

                case htmlInputPassword:
                    return new CAccEdit( this, TRUE );

                case htmlInputText:
                case htmlInputHidden:
                    return new CAccEdit( this, FALSE );

                case htmlInputFile:
                    return new CAccInputFile( this );
                }
            }
            break;

        case ETAG_LABEL:
            return new CAccLabel(this);
            break;

        case ETAG_OBJECT:
        case ETAG_EMBED:
        case ETAG_APPLET:
            return new CAccObject( this );
            break;

        case ETAG_TABLE:
            return new CAccTable( this );
            break;

        case ETAG_TH:
        case ETAG_TD:
            return new CAccTableCell( this );
            break;

        case ETAG_SELECT:
            return new CAccSelect( this );
            break;

        default:
            // but wait there is one more check, if this element is normally
            // unsupported (not in the about cases) then we still want to
            // create an accObject if this element has an explicit tabstop set.
            if (GetAAtabIndex() != htmlTabIndexNotSet)
            {
                return new CAccTabStopped( this );
            }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//  Member  :   AccObjForBehavior
//  
//  Synopsis:   Get the accessible object for a behavior implementation.
//
//    1. A behavior that implements IAccessible:                        We want to create an AccBehavior that delegates
//    2. A behavior that does not implement IAccessible                 Return NULL and let CreatAccObj handle it
//    3. A view link without an attached that implements IAccessible    We want to create an AccBehavior that does not delegate
//
//----------------------------------------------------------------------------

CAccElement * 
CElement::AccObjForBehavior()
{
    CAccBehavior *  pAccBehavior = NULL;

    if (IsIAccessiblePeer(this))
    {
        pAccBehavior = new CAccBehavior(this, TRUE);      
    }                                                
    else if (HasSlavePtr() && Tag() != ETAG_INPUT)
    {
        pAccBehavior = new CAccBehavior(this, FALSE); 

        Assert(pAccBehavior);

        if (pAccBehavior)
        {
            IGNORE_HR(pAccBehavior->EnsureSubElement());
        }
    }

    return pAccBehavior;
}

//----------------------------------------------------------------------------
//  Member:   CElement::CreateAccObj
//
//  Synopsis: Creates and returns the proper accessibility object for this element
//
//    1. A behavior that implements IAccessible:                        We want to create an AccBehavior that delegates
//    2. A behavior that does not implement IAccessible                 If the tag is supported or there is a tabindex we want to create the appropriate AccObj
//    3. A view link without an attached that implements IAccessible    We want to create an AccBehavior that does not delegate
//    4. A normal tag without an attached that implements IAccessible   If the tag is supported or there is a tabindex we want to create the appropriate AccObj
//
//----------------------------------------------------------------------------

CAccElement *
CElement::CreateAccObj()
{
    CAccElement * pAcc = NULL;

    if (HasPeerHolder())
    {
        pAcc = AccObjForBehavior(); // Cases 1 and 3 (If 2 AccObjForBehavior will return NULL)
    }
    
    if (pAcc == NULL)
    {
        pAcc = AccObjForTag();      // Case  2 and 4
    }

    return pAcc;
}

CElement *
CElement::GetParentAncestorSafe(ELEMENT_TAG etag) const
{
    CTreeNode *pNode = GetFirstBranch();
    CElement  *p = NULL;
    if (pNode)
    {
        pNode = pNode->Parent();
        if (pNode)
        {
            pNode = pNode->Ancestor(etag);
            if (pNode)
                p = pNode->Element();
        }
    }
    return p;
}

CElement *
CElement::GetParentAncestorSafe(const ELEMENT_TAG *arytag) const
{
    CTreeNode *pNode = GetFirstBranch();
    CElement  *p = NULL;
    if (pNode)
    {
        pNode = pNode->Parent();
        if (pNode)
        {
            pNode = pNode->Ancestor(arytag);
            if (pNode)
                p = pNode->Element();
        }
    }
    return p;
}

//
// CElement Collection Helpers - manage the WINDOW_COLLECTION
//
HRESULT
CElement::GetIDHelper ( CStr *pf )
{
    LPCTSTR lpszID = NULL;
    HRESULT hr;

    if (_pAA && _pAA->HasAnyAttribute())
        _pAA->FindString(DISPID_CElement_id, &lpszID);

    hr = THR(pf->Set ( lpszID ));

    return hr;
}

HRESULT 
CElement::SetIdentifierHelper ( LPCTSTR lpszValue, DISPID dspIDThis, DISPID dspOther1, DISPID dspOther2 )
{
    HRESULT     hr;
    BOOL        fNamed;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup = GetMarkup();

    // unhook any old script attached to this element.
    if (pMarkup && (Tag() != ETAG_SCRIPT) && IsNamed())
    {
        pDoc->CommitScripts(pMarkup, this, FALSE);
    }
    
    hr = AddString (dspIDThis, lpszValue, CAttrValue::AA_Attribute );
    if ( !hr )
    {
        // Remember if we're named, so that if this element moves into a different tree
        // we can inval the appropriate collections
        fNamed = lpszValue && lpszValue [ 0 ];
 
        // We're named if NAME= or ID= something or we have a unique name
        if ( !fNamed )
        {
            LPCTSTR lpsz = NULL;
            if (_pAA && _pAA->HasAnyAttribute())
            {
                _pAA->FindString(dspOther1, &lpsz);
                if ( !(lpsz && *lpsz ) )
                    _pAA->FindString(dspOther2, &lpsz);
            }
            fNamed = lpsz && *lpsz;
        }
        
        _fIsNamed = fNamed;
        // Inval all collections affected by a name change
        DoElementNameChangeCollections();

        // hook up any script for\event handlerw attached to this element thru new id
        if (pMarkup && (Tag() != ETAG_SCRIPT) && _fIsNamed)
        {
            pDoc->CommitScripts(pMarkup, this);
        }

    }

    RRETURN(hr);
}

HRESULT
CElement::SetIDHelper ( CStr *pf )
{
    RRETURN(SetIdentifierHelper((LPCTSTR)(*pf),
        DISPID_CElement_id,
        STDPROPID_XOBJ_NAME,
        DISPID_CElement_uniqueName));   
}

HRESULT
CElement::GetnameHelper ( CStr *pf )
{
    LPCTSTR lpszID = NULL;
    HRESULT hr;

    if (_pAA && _pAA->HasAnyAttribute())
        _pAA->FindString(STDPROPID_XOBJ_NAME, &lpszID);

    hr = THR(pf->Set ( lpszID ));

    return hr;
}

HRESULT
CElement::SetnameHelper ( CStr *pf )
{
    RRETURN(SetIdentifierHelper((LPCTSTR)(*pf),
        STDPROPID_XOBJ_NAME,
        DISPID_CElement_id,
        DISPID_CElement_uniqueName));   
}

HRESULT
CElement::SetUniqueNameHelper ( LPCTSTR szUniqueName )
{
    RRETURN(SetIdentifierHelper( szUniqueName,
        DISPID_CElement_uniqueName,
        DISPID_CElement_id,
        STDPROPID_XOBJ_NAME));   
}

void
CElement::InvalidateCollection ( long lIndex )
{
    CMarkup *pMarkup;
    CCollectionCache *pCollCache;

    pMarkup = GetMarkup();
    if ( pMarkup )
    {
        pCollCache = pMarkup->CollectionCache();
        if ( pCollCache )
        {
            pCollCache->InvalidateItem ( lIndex );
        }
    }
}

//
// Replace CBase::removeAttribute, need to special case some DISPID's
//

HRESULT 
CElement::removeAttribute(BSTR strPropertyName, LONG lFlags, VARIANT_BOOL *pfSuccess)
{
    DISPID dispID;
    IDispatchEx *pDEX = NULL;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    // TODO rgardner should move the STDPROPID_XOBJ_STYLE
    // code from CBase::removeAttribute to here

    if (THR_NOTRACE(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX )))
        goto Cleanup;

    if (THR_NOTRACE(pDEX->GetDispID(strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                    fdexNameCaseSensitive : 0, &dispID)))
        goto Cleanup;

    if (!removeAttributeDispid(dispID))
        goto Cleanup;


    // If we remove name or ID, update the WINDOW_COLLECTION if needed
    // Don't need to deal with uniqueName here - it's not exposed externaly

    if ( dispID == DISPID_CElement_id || dispID == STDPROPID_XOBJ_NAME )
    {
        LPCTSTR lpszNameID = NULL;
        BOOL fNamed;

        // Named if ID or name is present
        if (_pAA && _pAA->HasAnyAttribute())
        {
            _pAA->FindString( dispID == DISPID_CElement_id ?
                    STDPROPID_XOBJ_NAME : 
                    DISPID_CElement_id, 
                &lpszNameID);
            if ( !(lpszNameID && *lpszNameID ) )
                _pAA->FindString(DISPID_CElement_uniqueName, &lpszNameID);
        }

        fNamed = lpszNameID && *lpszNameID;

        if ( fNamed != !!_fIsNamed )
        {
            // Inval all collections affected by a name change
            DoElementNameChangeCollections();
            _fIsNamed = fNamed;
        }
    }

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    ReleaseInterface ( pDEX );

    RRETURN ( SetErrorInfo ( S_OK ) );
}


//----------------------------------------------------------------------------
//  Member:   CElement::Primitive(Get/Set)Expando
//
//  Synopsis: Gets or sets the given variant as an expando into the AA.
//            This does not fire any events, support undo, &c...
//
//----------------------------------------------------------------------------
HRESULT
CElement::PrimitiveSetExpando(BSTR bstrPropertyName, VARIANT varPropertyValue)
{
    HRESULT hr;
    DISPID  dispID;
    AAINDEX aaIdx;

    hr = THR(CBase::GetExpandoDispID(bstrPropertyName, &dispID, fdexNameEnsure));
    if (hr)
        goto Cleanup;

    aaIdx = FindAAIndex(dispID, CAttrValue::AA_Expando);

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        hr = AddVariant(dispID,
                        &varPropertyValue,
                        CAttrValue::AA_Expando);
    }
    else
    {
        hr = ChangeVariantAt(aaIdx, &varPropertyValue);
    }

Cleanup:
    return hr;
}

HRESULT
CElement::PrimitiveGetExpando(BSTR bstrPropertyName, VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DISPID  dispID;

    hr = CBase::GetExpandoDispID(bstrPropertyName, &dispID, 0);
    if (hr)
        goto Cleanup;

    hr = GetVariantAt(FindAAIndex(dispID, CAttrValue::AA_Expando),
                      pvarPropertyValue, /* fAllowNullVariant = */FALSE);

Cleanup:
    return hr;
}


HRESULT
CElement::PrimitiveRemoveExpando(BSTR bstrPropertyName)
{
    HRESULT hr;
    DISPID  dispID;

    hr = THR ( CBase::GetExpandoDispID(bstrPropertyName, &dispID, 0) );
    if (hr)
        goto Cleanup;

    DeleteAt(FindAAIndex(dispID, CAttrValue::AA_Expando));

Cleanup:
    return hr;
}

HRESULT
CElement::OnTabIndexChange()
{
    long                i;
    HRESULT             hr = S_OK;
    CMarkup           * pMarkup = GetMarkup();
    CAryFocusItem     * paryFocusItem;
    
    Assert (pMarkup);
    paryFocusItem = pMarkup->GetFocusItems(TRUE);
    Assert (paryFocusItem);

    for (i = 0; i < paryFocusItem->Size(); i++)
    {
        if ((*paryFocusItem)[i].pElement == this)
        {
            paryFocusItem->Delete(i);
        }
    }
    
    hr = THR(pMarkup->InsertFocusArrayItem(this));
    if (hr) 
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


void
CElement::OnEnterExitInvalidateCollections(BOOL fForceNamedBuild)
{
    //
    // Optimized collections
    // If a named (name= or ID=) element enters the tree, inval the collections
    //
    
    //
    // DEVNOTE rgardner
    // This code is tighly couples with CMarkup::AddToCollections and needs
    // to be kept in sync with any changes in that function
    //

    if (IsNamed() || fForceNamedBuild)
    {
        InvalidateCollection ( CMarkup::WINDOW_COLLECTION );
    }

    // Inval collections based on specific element types
    switch ( _etag )
    {
    case ETAG_LABEL:
        InvalidateCollection ( CMarkup::LABEL_COLLECTION );
        break;

    case ETAG_FRAME:
    case ETAG_IFRAME:
        InvalidateCollection ( CMarkup::FRAMES_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_IMG:
        InvalidateCollection ( CMarkup::IMAGES_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_OBJECT:
    case ETAG_APPLET:
        InvalidateCollection ( CMarkup::APPLETS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_SCRIPT:
        InvalidateCollection ( CMarkup::SCRIPTS_COLLECTION );
        break;

    case ETAG_MAP:
        InvalidateCollection ( CMarkup::MAPS_COLLECTION );
        break;

    case ETAG_AREA:
        InvalidateCollection ( CMarkup::LINKS_COLLECTION );
        break;

    case ETAG_EMBED:
        InvalidateCollection ( CMarkup::EMBEDS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_FORM:
        InvalidateCollection ( CMarkup::FORMS_COLLECTION );
        if ( IsNamed() || fForceNamedBuild )
            InvalidateCollection ( CMarkup::NAVDOCUMENT_COLLECTION );
        break;

    case ETAG_A:
        InvalidateCollection ( CMarkup::LINKS_COLLECTION );
        if (IsNamed() || fForceNamedBuild)
            InvalidateCollection ( CMarkup::ANCHORS_COLLECTION );
        break;
    }
}

void
CElement::DoElementNameChangeCollections(void)
{
    CMarkup *pMarkup;
    // Inval all the base collections, based on TAGNAme.
    // Force the WINDOW_COLLECTION to be built
    OnEnterExitInvalidateCollections ( TRUE );

    // Artificialy update the _lTreeVersion so any named collection derived from 
    // the ELEMENT_COLLECTION are inval'ed

    // This function is also called by the tree code when the page contains a 
    // <FORM> tag.  If we update the tree version here, CHtmRootParseCtx::FlushNotifications
    // will assume some thing is wrong and attempt to reload the page.
    // Assume the parser will update the version its self when needed.
        
    pMarkup = GetMarkup();
    if (pMarkup && !pMarkup->GetRootParseCtx())  // Parsing if GetRootParseCtx returns something.
        pMarkup->UpdateMarkupTreeVersion();    
}

HRESULT
InlineEvts::Connect(CDoc *pDoc, CElement *pElement)
{
    HRESULT     hr = S_OK;

    Assert(pDoc && pElement);

    //
    // Look over all scriptlets and hook them up
    //
    if (cScriptlets)
    {
        CMarkup *pMarkup = pElement->GetMarkup();
        if (pMarkup->GetScriptCollection())
        {
            BOOL        fRunScript;
            LPCTSTR     pchLanguage = NULL;
            hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            if (hr || !fRunScript)
                goto Cleanup;

            for (int i = 0; i < cScriptlets; i++)
            {
                IGNORE_HR(pElement->ConnectInlineEventHandler(
                    adispidScriptlets[i],   // dispid
                    adispidScriptlets[i],   // dispidCode - in this case it is the same
                    aOffsetScriptlets[i],
                    aLineScriptlets[i],
                    TRUE,                   // fStandard
                    &pchLanguage));
            }
        }
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     IsConnectedToPrimaryWindow
//
//  Synopsis:   Chescks if the element is in amrkup connected (possibly through
//              pending markups) to the primary window. 
//
//-----------------------------------------------------------------------------
// TODO (jbeda) Handle HTCs?
BOOL
CElement::IsConnectedToPrimaryWindow()
{
    CMarkup * pMarkup           = GetMarkup();
    CMarkup * pMarkupPrimary    = Doc()->PrimaryMarkup();

    while (pMarkup)
    {
        if (pMarkup == pMarkupPrimary)
            return TRUE;

        if (pMarkup->Root()->HasMasterPtr())
        {
            pMarkup = pMarkup->Root()->GetMasterPtr()->GetMarkup();
        }
        else if (pMarkup->_fWindowPending)
        {
            Assert(!pMarkup->_fWindow);
            Assert(pMarkup != pMarkup->GetWindowPending()->Window()->Markup());
            pMarkup = pMarkup->GetWindowPending()->Window()->Markup();
        }
        else
            pMarkup = NULL;
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     SetViewSlave
//
//  Synopsis:   Sets up the slave/master ptrs, invalidates the layout, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::SetViewSlave(CElement * pSlaveNew)
{
    HRESULT     hr          = S_OK;
    CElement*   pSlaveOld   = NULL;

    if (HasSlavePtr())
    {
        pSlaveOld = GetSlavePtr();
    }

    if (pSlaveOld == pSlaveNew)
        goto Cleanup;

    // A slave usually implies a flow layout, so we need to destroy the old layout if it is inappropriate.
    // TODO (greglett)
    // The slave may imply a CContainerLayout, in which case we want to destroy the old CContainerLayout
    // if it is not already the head of a chain.  Since this is optimization rather than critical logic,
    // we can revisit.
    if (HasLayoutPtr())
    {
        CLayout * pLayoutOld = GetLayoutPtr();

        BOOL fFlowLayout = !!pLayoutOld->IsFlowLayout();

        if (    !fFlowLayout
            || (    pSlaveOld
                &&  !pSlaveNew) )
        {
           Verify(pLayoutOld == DelLayoutPtr());
           pLayoutOld->Detach();
           pLayoutOld->Release();
        }
    }
    else if ( HasLayoutAry() )
    {
        BOOL fFlowLayout = GetLayoutAry()->IsFlowLayout();
        
        if (    !fFlowLayout
            || (    pSlaveOld
                &&  !pSlaveNew) )
        {
            DelLayoutAry(); // will take care of detaching/releasing its layouts
        }
    }


    // Detach old slave
    if (pSlaveOld)
    {
        if (Tag() != ETAG_INPUT && IsConnectedToPrimaryWindow())
        {
            CMarkup *       pMarkupOld = pSlaveOld->GetMarkup();
            CNotification   nf;

            Assert(pSlaveOld->Tag() == ETAG_ROOT);
            Assert(pMarkupOld);

            // TODO (MohanB) Hack for windowed slave markups not in frames (#106433)
            // These markups do not passivate due to a ref count loop. Should fix in v6.
            if (Tag() == ETAG_GENERIC && pMarkupOld->HasWindow())
            {
                pMarkupOld->TearDownMarkup(TRUE, TRUE);
            }

            // Send ExitView notify to the slave tree since it is
            // getting diconnected from the primary markup.
            // For perf reasons we do that only if there is more than 
            // one reference to the master

            if (pMarkupOld->GetObjectRefs() > 1)
            {
                pMarkupOld->_fSlaveInExitView = 1;
                nf.ElementExitview1(pSlaveOld);
                pSlaveOld->SendNotification(&nf);
                pMarkupOld->_fSlaveInExitView = 0;
            }
        }

        DelSlavePtr();
        pSlaveOld->DelMasterPtr();
        pSlaveOld->Release();
    }
    else
    {
        CNotification   nf;

        // no previous slave, but we still need to send exitview 
        // notifications to all the children of the generic element
        nf.ElementExitview1(this);
        SendNotification(&nf);
    }

    // validate & attach new slave
    if (pSlaveNew)
    {
        // Make sure that the slave and the master are in the same CDoc
        Assert(Doc() == pSlaveNew->Doc());

        // TODO (MohanB)
        // Move all this validation /cycle-detection code into another function
        // and call it lazily in EnsureView()
#if 0

        if (!IsInMarkup())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        if (!pSlaveNew->IsInMarkup())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        // check for potential cycles

        // 1. check that the slave is not on master's parent/master chain
        {
            CElement * pMaster = this;

            do
            {
                if (pSlaveNew == pMaster)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                if (pMaster->HasMasterPtr())
                {
                    pMaster = pMaster->GetMasterPtr();
                }
                else
                {
                    // TODO (MohanB) What about overlapping?
                    CTreeNode * pNode = pMaster->GetFirstBranch();

                    if (pNode)
                    {
                        pNode = pNode->Parent();
                    }
                    pMaster = pNode ? pNode->Element() : NULL;
                }
            }
            while (pMaster);
        }

        // 2. check that the slave is not already in someone else's layout
        {
            CTreeNode * pNodeTest = pSlaveNew->GetFirstBranch();

            Assert(pNodeTest);

            pNodeTest = pNodeTest->Parent();
            while (pNodeTest)
            {
                if (pNodeTest->Element()->HasMasterPtr())
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                if (pNodeTest->Element()->HasSlavePtr())
                {
                    // The parent has a slave, which implies that this
                    // element's content isn't being rendered in that.
                    break;
                }
                else if (pNodeTest->Element()->ShouldHaveLayout())
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                pNodeTest = pNodeTest->Parent();

            }
        }
#endif // End of validation code       
               
        // we're not actually exiting the tree, just trying to get the 
        // editor to reposition the caret in a valid position    

        // TODO For some reason, this repositioning crashes the VID test, 
        // perhaps due to the input tag's use of viewlinking. So for now
        // we only reposition on generic tags. (peterlee)        
        if (Tag() == ETAG_GENERIC)
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( this->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( Doc()->NotifySelection( EDITOR_NOTIFY_SETTING_VIEW_LINK , pUnknown ));
            ReleaseInterface( pUnknown );      
        }
        
        // attach
        SetSlavePtr(pSlaveNew);
        pSlaveNew->SetMasterPtr(this);
        pSlaveNew->AddRef();

        Doc()->_fHasViewSlave = TRUE;
    }

    // clear formats and force a lazy remeasure
    {
        DWORD dwFlags = ELEMCHNG_CLEARCACHES;
        
        if (Tag() != ETAG_INPUT && IsConnectedToPrimaryWindow())
        {
            dwFlags |= ELEMCHNG_SETTINGVIEWLINK;
        }

        EnsureFormatCacheChange(dwFlags);
    }

    //ResizeElement();
    RemeasureElement(NFLAGS_FORCE);

    if( pSlaveNew )
    {
        hr = THR(pSlaveNew->GetMarkup()->LoadSlaveMarkupHistory());
        pSlaveNew->GetMarkup()->_fLoadHistoryReady = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

BOOL
CElement::IsCircularViewLink(CMarkup * pMarkupSlave)
{
    CMarkup * pMarkupPrimary    = Doc()->PrimaryMarkup();
    CMarkup * pMarkupThis       = GetMarkup();

    Assert(pMarkupSlave);

    // Primary markup can never have a master
    Assert(pMarkupPrimary && !pMarkupPrimary->Root()->HasMasterPtr());

    while (pMarkupThis)
    {
        if (pMarkupThis == pMarkupSlave)
        {
            return TRUE;
        }
        if (pMarkupThis == pMarkupPrimary)
            break;
        pMarkupThis = pMarkupThis->Root()->HasMasterPtr()
                        ? pMarkupThis->Root()->GetMasterPtr()->GetMarkup()
                        : NULL;
    }
    return FALSE;
}


// KTam: If fTreatPrintingAsViewLink is true, elements inside a layoutrect will
// return true.
BOOL
CElement::IsInViewLinkBehavior( BOOL fTreatPrintingAsViewLink )
{
    AssertSz(IsInMarkup(), "Must be in a markup to answer this question");
    CElement * pRoot = GetMarkup()->Root();
    if (pRoot->HasMasterPtr())
    {
        CElement *pMaster = pRoot->GetMasterPtr();
        if ( pMaster->TagType() == ETAG_GENERIC )
        {
            if (   fTreatPrintingAsViewLink
                || !pMaster->IsLinkedContentElement() )
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
CElement::IsPrintMedia()
{
    return IsInMarkup() ? GetMarkup()->IsPrintMedia() : FALSE;
}

HTHEME
CElement::GetTheme(THEMECLASSID themeId)
{
    if (GetFirstBranch()->GetFancyFormat()->IsThemeDisabled())
    {
        return NULL;
    }
    else
    {
        CMarkup * pMarkup = GetMarkup();
        if (pMarkup)
        {
            return pMarkup->GetTheme(themeId);
        }
        else
        {
            return NULL;
        }
    }
}

#ifdef NEVER

BOOL
CElement::CanHaveViewSlave()
{
    // You cannot set a viewSlave for non-renderable tags (e.g. SCRIPT). I am doing
    // this just to play safe.
    // Also, you cannot set viewSlave for certain renderable elements (e.g. TABLE),
    // because they make specific assumptions about their layout/content. To support
    // arbitrary view on any element, we need to fix this.

    switch (Tag())
    {
        // Non-renderable tags (picked from GetDefaultFocussability with FOCUSSABILITY_NEVER)
    case ETAG_AREA:
    case ETAG_BASE:
    case ETAG_BASEFONT:
    case ETAG_BGSOUND:
    case ETAG_BR:
    case ETAG_CODE:
    case ETAG_COL:
    case ETAG_COLGROUP:
    case ETAG_COMMENT:
    case ETAG_HEAD:
    case ETAG_HTML:
    case ETAG_LINK:
    case ETAG_MAP:
    case ETAG_META:
    case ETAG_NEXTID:
    case ETAG_NOBR:
    case ETAG_NOEMBED:
    case ETAG_NOFRAMES:
    case ETAG_NOSCRIPT:
    case ETAG_OPTION:
    case ETAG_PARAM:
    case ETAG_RAW_BEGINFRAG:
    case ETAG_RAW_BEGINSEL:
    case ETAG_RAW_CODEPAGE:
    case ETAG_RAW_COMMENT:
    case ETAG_RAW_DOCSIZE:
    case ETAG_RAW_ENDFRAG:
    case ETAG_RAW_ENDSEL:
    case ETAG_RAW_EOF:
    case ETAG_RAW_SOURCE:
    case ETAG_RAW_TEXT:
    case ETAG_RAW_TEXTFRAG:
    case ETAG_SCRIPT:
    case ETAG_STYLE:
    case ETAG_TITLE_ELEMENT:
    case ETAG_TITLE_TAG:
    case ETAG_WBR:
    case ETAG_UNKNOWN:
        return FALSE;

        // Tags which make specific assumptions about their layout
    case ETAG_APPLET:
    case ETAG_EMBED:
    case ETAG_FRAMESET:
    case ETAG_HR:
    case ETAG_OBJECT:
    case ETAG_SELECT:
    case ETAG_TABLE:
    case ETAG_TR:
        return FALSE;

        // Certain types of INPUTs which make specific assumptions about their slave
    case ETAG_INPUT:
        switch (DYNCAST(CInput, this)->GetType())
        {
        case htmlInputButton:
        case htmlInputReset:
        case htmlInputSubmit:
        case htmlInputFile:
        case htmlInputText:
        case htmlInputPassword:
        case htmlInputHidden:
            return FALSE;
        }
        break;
    }
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// viewLink OM
//
#define DISPID_INTERNAL_PUBLIC_VIEWLINK   (DISPID_ELEMENT+??) // from element.pdl

//+----------------------------------------------------------------------------
//
//  Member:     PutViewLinkHelper
//
//  Synopsis:   Sets the slave element.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::PutViewLinkHelper(IHTMLElement * pISlave)
{
    HRESULT     hr          = S_OK;
    CElement*   pElemSlave  = NULL;

    if (!CanHaveViewSlave())
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    if (pISlave)
    {
        hr = THR(pISlave->QueryInterface(CLSID_CElement, (void**) &pElemSlave));
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert(pElemSlave);
    }

    hr = THR(SetViewSlave(pElemSlave));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     put_viewLink
//
//  Synopsis:   IHTMLElement3 method. Sets the slave element.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_viewLink(IHTMLElement * pISlave)
{
    HRESULT hr;
    AAINDEX aaIdx   = FindAAIndex(DISPID_INTERNAL_PUBLIC_VIEWLINK, CAttrValue::AA_Internal);

    if (aaIdx == AA_IDX_UNKNOWN)
    {
        hr = AddUnknownObject(DISPID_INTERNAL_PUBLIC_VIEWLINK, pISlave, CAttrValue::AA_Internal);
    }
    else
    {
        hr = ChangeUnknownObjectAt(aaIdx, pISlave);
    }
    if (hr)
        goto Cleanup;

    hr = PutViewLinkHelper(pISlave);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_viewLink
//
//  Synopsis:   IHTMLElement3 method. Returns the slave element.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_viewLink(IHTMLElement ** ppISlave)
{
    if (!ppISlave)
        return E_INVALIDARG;
#ifdef MULTI_LAYOUT
    if (HasSlavePtr()) {
        CElement * pSlave = GetSlavePtr();
        return pSlave->QueryInterface(IID_IHTMLElement, (void**)ppISlave);
    }
    else
    {
        CViewChain * pChain = GetUpdatedLayout()->ViewChain();
        if (pChain)
        {
            CElement * pSlave = GetUpdatedLayout()->ViewChain()->GetLayoutOwner()->ElementOwner()->GetSlavePtr();
            return pSlave->QueryInterface(IID_IHTMLElement, (void**)ppISlave);
        }
    }
#endif

    RRETURN(SetErrorInfo(GetUnknownObjectAt(
                            FindAAIndex(DISPID_INTERNAL_PUBLIC_VIEWLINK, CAttrValue::AA_Internal),
                            (IUnknown**)ppISlave)));
}
#endif // NEVER

BOOL
CElement::ShouldHaveLayout(CTreeNode *pBranchNode FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (Tag() == ETAG_OBJECT && IsInMarkup())
    {
        if (!GetMarkup() || GetMarkup()->SearchBranchForTagInStory(GetFirstBranch(), ETAG_HEAD))
            return FALSE;
    }

    //hack. (dmitryt) We calculate layoutness bit for HTML element when we calc its formats.
    //Unfortunately, to see if HTML has layout, we not only check 'Strict CSS' bit
    //on Markup but also _fDesignMode and IsPrintPreview (see IsHtmlLayout() implementation).
    //But because _fDesignMode on markup is playing funny games when markup gets loaded,
    //we can calculate and cache wrong FancyFormat bit for HTML layout.
    //To 'fix' this temporarily, I'm putting this hack for HTML element in hope 
    //it will help. The right solution would be to only check for CSS1 bit. Unfortunately,
    //it's too late in IE6 cycle.

    if(Tag() == ETAG_HTML)
        return (GetMarkup() && GetMarkup()->IsHtmlLayout());

    if (_fLayoutAlwaysValid)
        return (!TestClassFlag(ELEMENTDESC_NOLAYOUT));

    CTreeNode * pNode = ( pBranchNode ? pBranchNode : GetFirstBranch() );

    // If formats have been computed, then we know whether we should have layout (and that knowledge
    // is cached on the tree node).  Else we need to compute formats to figure it out.
    // COMPUTEFORMATS NO LONGER CREATES LAYOUTS, it only updates the _fShouldHaveLayout bits.
    
    // If we don't have a node, it means we're not in the tree.  In that case, we can't answer the
    // question "should this element have layout", so we'd like to make sure no one asks it.
    // Currently CElement::FireEvent calls GetUpdatedNearestLayout(), which causes us to come in here
    // with a null branch; this happens in the DRT's xtags tests.  Talk to them to figure out the
    // right fix, then enable this assert.
    // Assert( pNode );
    
    if ( pNode )
    {

#ifdef MULTI_FORMAT
        if ( IS_FC(FCPARAM) )
        {
            return pNode->GetFancyFormat(FCPARAM)->_fShouldHaveLayout;
        }
        else
#endif //MULTI_FORMAT
        {        
            return (pNode->_iFF != -1)
                    ? pNode->_fShouldHaveLayout
                    : pNode->GetFancyFormat()->_fShouldHaveLayout;                   
        }
    }

    return FALSE;
}

CBase *
CElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup /* = NULL */)
{
    return this;
}

CControlledFormatter::CControlledFormatter(CElement *pElement, DISPID dispid, DWORD dwFlags)
{
    _pElement = pElement;
    _pNode = _pElement->GetFirstBranch();
    _dispid = dispid;
    _dwFlags = dwFlags;
    WHEN_DBG(_fInited = FALSE;)
}

CControlledFormatter::~CControlledFormatter()
{
    AssertSz(   _fShouldComputeFormatsForDISPID
             || _pElement->AreAllMyFormatsAreDirty(_dwFlags),
             "Compute formats was called erroneously! Perf problem!"
            );
}

BOOL
CControlledFormatter::Init(HRESULT *phr)
{
    BOOL fRet = FALSE;

    AssertSz(!_fInited, "Do not init me twice!");
    _fHadLayoutBeforeFormatsChange = _pElement->CurrentlyHasAnyLayout();
    _fShouldComputeFormatsForDISPID = ShouldComputeFormatsForDISPID();
    if (_fShouldComputeFormatsForDISPID)
    {
        *phr = THR(_pElement->EnsureFormatCacheChange(_dwFlags));
        if (*phr != S_OK)
            goto Cleanup;

       //
       // In the case of an activex control, we may be in the process of computing formats  Sujalp owns
       // adding a better assert.
       //
       // AssertSz(_pElement->AreAllMyFormatsAreDirty(_dwFlags), "Ensure format cache change failed!");
        
        _fHasLayoutAfterFormatsChange = _pElement->ShouldHaveLayout();
        _pNearestLayoutInfo = _pElement->GetUpdatedNearestLayoutInfo();
        _pNearestLayout = _pElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        if (   !_pNearestLayoutInfo
            || !_pNearestLayoutInfo->ElementOwner()->IsInMarkup()
            || !_pNearestLayout
            || !_pNearestLayout->ElementOwner()->IsInMarkup()
           )
        {
            goto Cleanup;
        }
        SendZNotification();
    }
    else
    {
        SendZNotification();
        *phr = THR(_pElement->EnsureFormatCacheChange(_dwFlags));
        if (*phr != S_OK)
            goto Cleanup;
    }
    fRet = TRUE;
    
Cleanup:
    WHEN_DBG(_fInited = TRUE;)
    return fRet;
}

BOOL
CControlledFormatter::SendZNotification()
{
    // Invalidation on z-index changes will be handled by FixZOrder in CSite
    // unless the change is on a non-site
    if (    _pElement->Doc()->_state >= OS_INPLACE
        &&  !(_dispid == DISPID_A_ZINDEX && _pElement->CurrentlyHasAnyLayout()))
    {
        if (    (_dwFlags & (ELEMCHNG_SITEREDRAW | ELEMCHNG_CLEARCACHES | ELEMCHNG_CLEARFF))
             && !(_dwFlags & ELEMCHNG_SITEPOSITION && _pElement->CurrentlyHasAnyLayout()))
        {
            // NOTE: CLayout will get called *twice* on _pElement because of this code.
            // Once for the first invalidate and once for the INVAL_Z_DESCENDANTS
            // call.

            _pElement->Invalidate();

            // Invalidate() sends a notification ot the parent, however in OPC
            // descendant elemetns may inherit what has just changed, so we need
            // a notification that goes down to the positioned children
            // so that they know to invalidate.  This is necessary since
            // when a property is changed they may have a change in an 
            // inherited value that they need to display
            //
            //  if we wind up needing this notification fired from other 
            // places, consider moving it into InvalidateElement()
            _pElement->SendNotification(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS);
        }
    }
    return TRUE;
}

BOOL
CControlledFormatter::ShouldComputeFormatsForDISPID()
{
    return TRUE;
}

#ifdef NOT_NOW
BOOL
CControlledFormatter::ShouldComputeFormatsForDISPID()
{
    BOOL fRet;
    
#define D(Y)  case DISPID_A_##Y:
#define DE(Y) case DISPID_##Y:
#define S(Y)  case STDPROPID_XOBJ_##Y:
    switch(_dispid)
    {
    // These dispids could potentially change the layoutness of an element, in which case we are interested
    D(RECTANGULAR) S(WIDTH) S(HEIGHT) D(POSITION)
    D(FLOAT) D(ZOOM) D(ROTATE) D(LAYOUTFLOW) D(WRITINGMODE)
    DE(CElement_id) D(EDITABLE) D(STYLETEXT)
    
    // These dispids need to look at formats to do their OPC work
    S(LEFT) S(RIGHT) S(TOP) S(BOTTOM)
    D(ZINDEX) D(VISIBILITY) D(DISPLAY) D(CLIP) D(CLIPRECTTOP)
    D(CLIPRECTRIGHT) D(CLIPRECTBOTTOM) D(CLIPRECTLEFT)

    // These dispids need to look at the new layout to do their OPC work
    D(OVERFLOWY) DE(CElement_className) D(BACKGROUNDIMAGE)
    DE(UNKNOWN) DE(BACKCOLOR)
#undef D
#undef DE
#undef S
    {
        fRet = TRUE;
        break;
    }
    default:
    {
        fRet = FALSE;
        break;
    }
    }

    if (   !fRet
        && (_dwFlags & (ELEMCHNG_RESIZENONSITESONLY | ELEMCHNG_SITEPOSITION))
       )
    {
        fRet = TRUE;
    }
    return fRet;
}
#endif

#if DBG==1
BOOL
CElement::AreAllMyFormatsAreDirty(DWORD dwFlags)
{
    BOOL fAll = dwFlags & ELEMCHNG_CLEARCACHES;
    BOOL fFFOnly = dwFlags & ELEMCHNG_CLEARFF;
    
    CTreeNode *pNode = GetFirstBranch();

    while(pNode)
    {
        if (fAll && pNode->_iCF != -1)
            return FALSE;
        if (fFFOnly && pNode->_iFF != -1)
            return FALSE;
        pNode = pNode->NextBranch();
    }
    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\element2.cxx ===
//+---------------------------------------------------------------------
//
//   File:      element2.cxx
//
//  Contents:   Element class
//
//  Classes:    CElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"    // for body's dispids
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_OMRECT_HXX_
#define X_OMRECT_HXX_
#include "omrect.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_CURSTYLE_HXX_
#define X_CURSTYLE_HXX_
#include "curstyle.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_STRING_H_
#define X_STRING_H_
#include "string.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X_FRAMESET_HXX
#define X_FRAMESET_HXX
#include "frameset.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_COLLBASE_HXX_
#define X_COLLBASE_HXX_
#include "collbase.hxx"
#endif

#ifndef X_DOMCOLL_HXX_
#define X_DOMCOLL_HXX_
#include "domcoll.hxx"
#endif

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include "urlcomp.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_ACCELEM_HXX_
#define X_ACCELEM_HXX_
#include "accelem.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

MtDefine(CElementGetBoundingRect_aryRects_pv, Locals, "CElement::GetBoundingRect aryRects::_pv")
MtDefine(CElementgetClientRects_aryRects_pv, Locals, "CElement::getClientRects aryRects::_pv")
PerfDbgTag(tagInject, "Inject", "Inject");

DeclareTag(tagOM_DontFireMouseEvents, "ObjectModel", "don't fire mouse events");

ExternTag(tagRecalcStyle);
ExternTag(tagFilterChange);

class CAnchorElement;

// Helper for firing focus/mouse enter/leave events
CTreeNode *
ParentOrMaster(CTreeNode * pNode)
{
    Assert(pNode);
    return (pNode->Tag() == ETAG_ROOT && pNode->Element()->HasMasterPtr())
                ? pNode->Element()->GetMasterPtr()->GetFirstBranch()
                : pNode->Parent();
}

BOOL
IsAncestorMaster(CElement * pElem1, CTreeNode * pNode2)
{
    if (!pNode2 || !pElem1->HasSlavePtr())
        return FALSE;
    Assert(!pNode2->IsDead());
    Assert(pNode2->Element() != pElem1);

    CElement * pElem2 = pNode2->Element();

    for(;;)
    {
        pElem2 = pElem2->GetMarkup()->Root();
        if (!pElem2->HasMasterPtr())
            return FALSE;
        pElem2 = pElem2->GetMasterPtr();
        if (pElem1 == pElem2)
            return TRUE;
        if (!pElem2->IsInMarkup())
            return FALSE;
    }  
}

//+------------------------------------------------------------------------
//
//  Member:     IElement, Get_document
//
//  Synopsis:   Returns the Idocument of this
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_document(IDispatch ** ppIDoc)
{
    HRESULT     hr = CTL_E_METHODNOTAPPLICABLE;
    CMarkup *   pMarkup;
    CDocument * pDocument;
    BOOL        fIsDocFrag = FALSE;

    if (!ppIDoc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIDoc = NULL;

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkup = GetMarkup();

    Assert(pMarkup);

    if(!pMarkup->HasDocument())
        fIsDocFrag = TRUE;

    hr = THR(pMarkup->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;
    
    // Set the node type, if Document Fragment
    if (fIsDocFrag)
        pDocument->_lnodeType = 11;

    hr = THR_NOTRACE(pDocument->QueryInterface(IID_IHTMLDocument2, (void**)ppIDoc));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     GettagName
//
//  Synopsis:   Returns the tag name of the current node.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_tagName(BSTR * pTagName)
{
    *pTagName = SysAllocString(TagName());

    RRETURN( SetErrorInfoPGet(*pTagName ? S_OK : E_OUTOFMEMORY, DISPID_CElement_tagName));
}

//+------------------------------------------------------------------------
//
//  Member:     GetscopeName
//
//  Synopsis:   Returns the scope name of the current node.
//
//-------------------------------------------------------------------------

HRESULT
CElement::get_scopeName(BSTR * pScopeName)
{
    *pScopeName = SysAllocString(NamespaceHtml());

    RRETURN( SetErrorInfoPGet(*pScopeName ? S_OK : E_OUTOFMEMORY, DISPID_CElement_scopeName));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_parentElement
//
//  Synopsis:   Exposes the parent element of this element.
//
//  Note:       This pays close attention to whether or not this interface is
//              based on a proxy element.  If so, use the parent of the proxy.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_parentElement(IHTMLElement * * ppDispParent, CTreeNode * pNode)
{
    HRESULT hr = S_OK;

    *ppDispParent = NULL;

    // Root element by defintion has no parent.
    if( Tag() == ETAG_ROOT )
        goto Cleanup;

    if (!pNode || pNode->IsDead() )
    {
        pNode = GetFirstBranch();
        // Assert that either the node is not in the tree or that if it is, it is not dead
        Assert( !pNode || !pNode->IsDead() );
    }

    // if still no node, we are not in the tree, return NULL
    if (!pNode)
        goto Cleanup;

    Assert(pNode->Element() == this);

    pNode = pNode->Parent();

    // don't hand out root node
    if (!pNode || pNode->Tag() == ETAG_ROOT)
        goto Cleanup;

    hr = THR( pNode->GetElementInterface( IID_IHTMLElement, (void **) ppDispParent ) );

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, STDPROPID_XOBJ_PARENT));
}

STDMETHODIMP
CElement::get_children(IDispatch **ppDispChildren)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup;

    if ( !ppDispChildren )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDispChildren = NULL;

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkup = GetMarkupPtr();

    hr = THR(pMarkup->InitCollections());
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->CollectionCache()->CreateChildrenCollection(CMarkup::ELEMENT_COLLECTION, this, ppDispChildren, FALSE));

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CElement_children));
}

HRESULT
GetAll(CElement *pel, IDispatch **ppDispChildren)
{
    HRESULT             hr = S_OK;
    CMarkup           * pMarkup;

    if ( !ppDispChildren )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert(pel);
    *ppDispChildren = NULL;

    hr = THR(pel->EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkup = pel->GetMarkupPtr();

    hr = THR(pMarkup->InitCollections());
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->CollectionCache()->CreateChildrenCollection(CMarkup::ELEMENT_COLLECTION, pel, ppDispChildren, TRUE));

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CElement::get_all(IDispatch **ppDispChildren)
{
    HRESULT hr;
    hr = THR(GetAll(this, ppDispChildren));
    RRETURN(SetErrorInfoPGet(hr, DISPID_CElement_all));
}

HRESULT
CElement::getElementsByTagName(BSTR v, IHTMLElementCollection** ppDisp)
{
    HRESULT hr = E_INVALIDARG;
    IDispatch *pDispChildren = NULL;
    CElementCollection *pelColl = NULL;

    if (!ppDisp || !v)
        goto Cleanup;

    *ppDisp = NULL;

    if (IsInMarkup() && (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET) && !StrCmpIC(_T("PARAM"), v))
    {
        hr = THR(GetMarkup()->CollectionCache()->GetDisp(
                    CMarkup::ELEMENT_COLLECTION,
                    v,
                    CacheType_Tag,
                    (IDispatch **)ppDisp,
                    FALSE)); // Case sensitivity ignored for TagName

        goto Cleanup;
    }

    hr = THR(GetAll(this, &pDispChildren));
    if (hr)
        goto Cleanup;

    Assert(pDispChildren);

    // Check for '*' which means return the 'all' collection
    if ( !StrCmpIC(_T("*"), v) )
    {
        hr = THR(pDispChildren->QueryInterface(IID_IHTMLElementCollection, (void **)ppDisp));
    }
    else
    {
        hr = THR(pDispChildren->QueryInterface(CLSID_CElementCollection, (void **)&pelColl));
        if (hr)
            goto Cleanup;

        Assert(pelColl);

        // Get a collection of the specified tags.
        hr = THR(pelColl->Tags(v, (IDispatch **)ppDisp));
    }

Cleanup:
    ReleaseInterface(pDispChildren);
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------------
//
//  Memvber : IsOverflowFrame
//
//  Synopsis : Returns TRUE if the element passed in is a frame, and is in a frameset,
//      and is beyond the number of frames that are provided for in the frameset.
//      this is here for NS compat (and ie4.0X) compat.
//      e.g. <FRAMESET rows = "50%,50%> <Frame id=f1 /> <Frame id=f2 /> <Frame id-f3 /></FS>
//      only frame f1 & f2 are passed (false return) and f3 is blockec (returns true)
//+------------------------------------------------------------------------------

BOOL
CElement::IsOverflowFrame()
{
    BOOL fRes = FALSE;

    // do we have a frame element at all?
    if (Tag() != ETAG_FRAME &&
        Tag() != ETAG_IFRAME &&
        Tag() != ETAG_FRAMESET)
        goto Cleanup;

    // To fix bug 33055(et al.), don't remember this frame if it's overflowing
    if (GetFirstBranch())
    {
        if (GetFirstBranch()->Parent())
        {
            CTreeNode *pNodeFS = GetFirstBranch()->Parent()->SearchBranchToRootForTag(ETAG_FRAMESET);

            if (pNodeFS)
            {
                CFrameSetSite *pFS = DYNCAST(CFrameSetSite, pNodeFS->Element());
                if (pFS)
                {
                    fRes = pFS->IsOverflowFrame(this);
                }
            }
        }
    }

Cleanup:
    return fRes;
}

//+-------------------------------------------------------------------
//      Member : get_style
//
//      Synopsis : for use by IDispatch Invoke to retrieve the
//      IHTMLStyle for this object's inline style.  Get it from
//      CStyle. If none currently exists, make one.
//+-------------------------------------------------------------------

HRESULT
CElement::get_style(IHTMLStyle ** ppISTYLE)

{
    HRESULT hr = S_OK;
    CStyle *pStyleInline = NULL;
    *ppISTYLE = NULL;


    //
    // styles may have expressions in them, and these are not set up until we have 
    // measured.  Like the layout OM methods, we need to ensure that we have recalc'ed
    // before returning this object (bug 88449).
    //
    if (Doc()->_aryPendingExpressionElements.Size())
    {
        hr = THR(EnsureRecalcNotify());
        if (hr)
            goto Cleanup;
    }

    hr = GetStyleObject(&pStyleInline);
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pStyleInline->QueryInterface(IID_IHTMLStyle, (LPVOID *)ppISTYLE));

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, STDPROPID_XOBJ_STYLE));
}



//+----------------------------------------------------
//
//  member : get_currentStyle: IHTMLElement2
//
//  synopsis : returns the IHTMLCurrentStyle interface to
//             the currentStyle Object
//
//-----------------------------------------------------

HRESULT
CElement::get_currentStyle ( IHTMLCurrentStyle ** ppICurStyle, CTreeNode * pNode )
{
    HRESULT hr = S_OK;
    CCurrentStyle * pCurStyleObj = NULL;

    if (!ppICurStyle)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppICurStyle = NULL;

    if (!pNode || pNode->IsDead() )
    {
        pNode = GetFirstBranch();
        // Assert that either the node is not in the tree or that if it is, it is not dead
        Assert( !pNode || !pNode->IsDead() );
    }

    // if still no node, we are not in the tree, return NULL
    if (!pNode)
        goto Cleanup;

    Assert(pNode->Element() ==  this);

    // Reuse a current style object if we have one
    if( pNode->HasCurrentStyle() )
    {
        pCurStyleObj = pNode->GetCurrentStyle();
        pCurStyleObj->PrivateAddRef();
    }
    else
    {
        pCurStyleObj = new CCurrentStyle();
        if (!pCurStyleObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = THR( pCurStyleObj->Init(pNode) );
        if( hr )
            goto Cleanup;

        // Add the CCurrentStyle to a lookaside on the node
        // If we run out of memory here -- no big deal, we will
        // just won't ever reuse this current style
        IGNORE_HR( pNode->SetCurrentStyle( pCurStyleObj ) );
    }

    hr = THR_NOTRACE(pCurStyleObj->PrivateQueryInterface(IID_IHTMLCurrentStyle,
        (VOID **)ppICurStyle));
    if ( hr )
    {
        pCurStyleObj->PrivateRelease();
        goto Cleanup;
    }

Cleanup:
    if( pCurStyleObj )
        pCurStyleObj->PrivateRelease();

    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------------------
//  
//  Method:     CElement::EnsureRuntimeStyle
//  
//  Synopsis:   Ensures a runtime style object on the element.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CStyle ** ppStyle - CStyle returned
//
//+----------------------------------------------------------------------------

HRESULT
CElement::EnsureRuntimeStyle( CStyle ** ppStyle )
{
    HRESULT  hr = S_OK;
    CStyle * pStyleObj = NULL;

    Assert( ppStyle );

    pStyleObj = GetRuntimeStylePtr();

    if( !pStyleObj )
    {
        pStyleObj = new CStyle(
            this, DISPID_INTERNAL_RUNTIMESTYLEAA, 0);
        if (!pStyleObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( AddPointer ( DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE,
                               (void *)pStyleObj,
                               CAttrValue::AA_Internal ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    if( hr )
    {
        delete pStyleObj;
        pStyleObj = NULL;
    }

    *ppStyle = pStyleObj;

    RRETURN( hr );
}
    
//+----------------------------------------------------
//
//  member : get_runtimeStyle: IHTMLElement
//
//  synopsis : returns the runtime Style Object
//
//-----------------------------------------------------

HRESULT
CElement::get_runtimeStyle ( IHTMLStyle ** ppIStyle )
{
    HRESULT hr = S_OK;
    CStyle * pStyleObj = NULL;

    if (!ppIStyle)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIStyle = NULL;

    GetPointerAt ( FindAAIndex ( DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE,
                             CAttrValue::AA_Internal ),
                   (void **)&pStyleObj );

    //Get existing styleObject or create a new one
    if (pStyleObj)
    {
        hr = THR_NOTRACE(pStyleObj->PrivateQueryInterface(IID_IHTMLStyle,
            (VOID **)ppIStyle));
    }
    else
    {
        pStyleObj = new CStyle(
            this, DISPID_INTERNAL_RUNTIMESTYLEAA, 0);
        if (!pStyleObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR_NOTRACE(pStyleObj->PrivateQueryInterface(IID_IHTMLStyle,
            (VOID **)ppIStyle)); // My SubRef count +1
        if ( hr )
        {
            delete pStyleObj;
            goto Cleanup;
        }

        AddPointer ( DISPID_INTERNAL_CRUNTIMESTYLEPTRCACHE,
                     (void *)pStyleObj,
                     CAttrValue::AA_Internal );

    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_sourceIndex
//
//  Synopsis:   Returns the source index (order of appearance) of this element
//              If the element is no longer in the source tree, return -1
//              as source index and hr = S_OK.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_sourceIndex ( long *pSourceIndex )
{
    HRESULT hr = S_OK;

    if (!pSourceIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pSourceIndex = GetSourceIndex();

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+------------------------------------------------------------------------
//
//  Class:      CAAScriptletIterator
//
//  Synopsis:   a helper class iterating all scriptlets in attr array which
//              need to be commited to script engines via AddScriptlet.
//              While iterating, the class also collect all the necessary
//              data from attr array.
//
//-------------------------------------------------------------------------

class CScriptletIterator
{
public:

    // methods

    void    Init(CBase * pObj, CPeerHolder * pPeerHolder);
    HRESULT Next();
    HRESULT NextStd();
    HRESULT NextPeer();
    BOOL    Done() { return fStdDone && fPeerDone; };

    //data

    CBase *                 pObject;

    LPCTSTR                 pchScriptletName;
    LPTSTR                  pchCode;

    LPTSTR                  pchData;
    ULONG                   uOffset;
    ULONG                   uLine;

    BOOL                    fStdDone;
    BOOL                    fPeerDone;

    CAttrArray *            pAA;
    BASICPROPPARAMS *       pBPP;
    const PROPERTYDESC *    pPropDesc;
    CAttrValue *            pAttrValue;
    CAttrValue *            pAV;
    AAINDEX                 aaIdx;

    CPeerHolder *           pPeerHolder;
    CPeerHolder::CEventsBag * pPeerEvents;
    int                     iPeerEvents;
};

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::Init
//
//  Synopsis:   attaches iterator to CBase object and resets it.
//
//-------------------------------------------------------------------------

void
CScriptletIterator::Init(CBase * pObj, CPeerHolder * pPH)
{
    pObject = pObj;
    pAA = * pObject->GetAttrArray();

    aaIdx = (AAINDEX) -1;

    pPeerHolder = pPH;
    pPeerEvents = NULL;
    iPeerEvents = 0;

    fStdDone  = FALSE;
    fPeerDone = FALSE;
};

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::Next
//
//  Synopsis:   finds the next scriptlet to commit via AddScriptlet and
//              collects all the necessary information for that.
//
//-------------------------------------------------------------------------

HRESULT
CScriptletIterator::Next()
{
    HRESULT     hr = S_OK;

    Assert (!fStdDone || !fPeerDone);

    if (!fStdDone)
    {
        hr = THR(NextStd());
        if (hr)
            goto Cleanup;
    }

    // when standard events are iterated completely, fStdDone is set to true in NextStd.

    if (fStdDone)
    {
        hr = THR(NextPeer());
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::NextStd
//
//  Synposis:   finds the next standard scriptlet in AA_Attribute section
//
//-------------------------------------------------------------------------

HRESULT
CScriptletIterator::NextStd()
{
    HRESULT     hr = S_OK;

    while ((pAttrValue = pAA->Find(DISPID_UNKNOWN, CAttrValue::AA_Attribute, &aaIdx)) != NULL)
    {
        //
        // find out if it is a scriptlet
        //

        pPropDesc = pAttrValue->GetPropDesc();
        if (!pPropDesc)
            continue;

        pBPP = (BASICPROPPARAMS *)(pPropDesc + 1);

        if (!(pBPP->dwPPFlags & PROPPARAM_SCRIPTLET))
            continue;

        //
        // get code
        //

        hr = THR (pObject->GetStringAt(aaIdx, (const TCHAR**)&pchCode));
        if (hr)
            goto Cleanup;

        if (!pchCode)
            continue; // this could happen, e.g., in this case: <img language = VBScript onclick>

        //
        // try to get line/offset information
        //

        hr = THR(GetLineAndOffsetInfo(pAA, pBPP->dispid, &uLine, &uOffset));
        if (S_FALSE == hr)      // if no line/offset information stored, which happens if we connected the event
        {                       // using function pointers mechanism
            hr = S_OK;
            continue;
        }
        if (hr)
            goto Cleanup;

        //
        // finalize
        //

        pchScriptletName = pPropDesc->pstrName;

        goto Cleanup; // found the next scriptlet to commit; get out now
    }

    fStdDone = TRUE;   // done iterating standard scriptlets

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptletIterator::NextPeer
//
//  Synposis:   finds the next custom peer event in pPeerEvents bag
//
//-------------------------------------------------------------------------

HRESULT
CScriptletIterator::NextPeer()
{
    HRESULT     hr;
    DISPID      dispidEvent;
    DISPID      dispidExpando;

    //
    // find the next custom peer event to hook up
    //

    while (pPeerHolder)
    {
        pPeerEvents = pPeerHolder->_pEventsBag;

        while (pPeerEvents && iPeerEvents < pPeerHolder->CustomEventsCount())
        {
            pchScriptletName = pPeerHolder->CustomEventName  (iPeerEvents);
            dispidEvent      = pPeerHolder->CustomEventDispid(iPeerEvents);
            iPeerEvents++;

            hr = pObject->GetExpandoDispID((LPTSTR)pchScriptletName, &dispidExpando, 0);
            if (S_OK == hr)
            {
                //
                // check if it is connected already - as indicated by presence of
                // corresponding IDispatch attr in AA_Internal section of attr array
                //

                aaIdx = AA_IDX_UNKNOWN;
                pAV = pAA->Find(
                    dispidEvent,
                    CAttrValue::AA_Internal,
                    &aaIdx);
                if (pAV && VT_DISPATCH == pAV->GetAVType())
                {
                    continue;
                }

                //
                // try to get line/offset information (stored with dispid of expando)
                //

                hr = THR(GetLineAndOffsetInfo(pAA, dispidExpando, &uLine, &uOffset));
                // if no line/offset information stored, which happens if we connected the event
                // using function pointers mechanism, then the function returns S_FALSE and uLine = uOffset = 0
                if (FAILED(hr))
                    goto Cleanup;

                //
                // get code
                //

                aaIdx = AA_IDX_UNKNOWN;
                pAV = pAA->Find(dispidExpando, CAttrValue::AA_Expando, &aaIdx);
                if (!pAV || VT_LPWSTR != pAV->GetAVType())
                {
                    continue;
                }

                hr = pObject->GetStringAt(aaIdx, (LPCTSTR*)&pchCode);

                goto Cleanup; // found the next event
            }
        } // eo while (pPeerEvents && iPeerEvents < pPeerHolder->CustomEventsCount())

        iPeerEvents = 0;
        pPeerHolder = pPeerHolder->_pPeerHolderNext;
    } // eo for (;;)

    hr = S_OK;

    fPeerDone = true;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::AddAllScriptlets
//
//  Arguments:  pchExposedName  name exposed in type info; could be id, name,
//                              or calculated unique id. If incoming value is
//                              NULL, and there is a scriptlet here to hookup,
//                              it will be set in this function to unique id.
//
//-------------------------------------------------------------------------

HRESULT
CElement::AddAllScriptlets(TCHAR * pchExposedName)
{
    HRESULT                 hr = S_OK;
    TCHAR *                 pchScope;
    TCHAR *                 pchLanguage;
    BSTR                    bstrFuncName;
    BOOL                    fBodyOrFrameset=FALSE;
    CStr                    cstrUniqueName;
    CBase **                ppPropHost;
    CBase *                 pPropHosts[3];
    BOOL                    fSetUniqueName = FALSE;
    CAttrArray *            pAA = *GetAttrArray();
    CScriptCollection *     pScriptCollection = GetMarkup()->GetScriptCollection();
    CScriptletIterator      itr;

    switch (Tag())
    {
    case ETAG_BODY:
    case ETAG_FRAMESET:
        fBodyOrFrameset = TRUE;
        break;
    }

    if (!pScriptCollection)
        goto Cleanup;

    if (!fBodyOrFrameset &&     // (1) for body or frameset, always attempt the hookup -
                                // there may be attrs stored attr array of window
        !pAA)                   // (2) for other elements, attempt hookup only if attr array present
        goto Cleanup;

    SetEventsShouldFire();

    //
    // calculate scope
    //

    switch (Tag())
    {
    case ETAG_BODY:
    case ETAG_FRAMESET:
    case ETAG_A:
        pchScope = (TCHAR *)DEFAULT_OM_SCOPE;
        break;

    default:
        pchScope = (TCHAR *) NameOrIDOfParentForm(); // this can return NULL

        if (!pchScope)
            pchScope = (TCHAR *)DEFAULT_OM_SCOPE;

        break;
    }

    Assert (pchScope); // VBScript is paranoid about this

    //
    // get language
    //

    if (!pAA ||
        !pAA->FindString (DISPID_A_LANGUAGE, (const TCHAR **) &pchLanguage, CAttrValue::AA_Attribute))
    {
        pchLanguage = NULL;
    }

    //
    // setup prop hosts
    //
    // prop hosts are:
    //      (1) normally, only 'this' element,
    //      (2) for body or frameset, 'this' element and window

    if (fBodyOrFrameset)
    {
        Assert (3 <= ARRAY_SIZE(pPropHosts));

        pPropHosts[0] = this;
        pPropHosts[1] = GetOmWindow();
        pPropHosts[2] = NULL;
    }
    else
    {
        Assert (2 <= ARRAY_SIZE(pPropHosts));

        pPropHosts[0] = this;
        pPropHosts[1] = NULL;
    }

    //
    // for all prop hosts ...
    //

    for (
        ppPropHost = pPropHosts;
        *ppPropHost;
        ppPropHost++, pchExposedName = (TCHAR *)DEFAULT_OM_SCOPE)
    {
        if (!*((*ppPropHost)->GetAttrArray()))
            continue;

        //
        //  for each scriptlet in this prop host ...
        //

        itr.Init(
            *ppPropHost,
            (this == (*ppPropHost)) ? GetPeerHolder() : NULL);

        for (;;)
        {
            hr = THR(itr.Next());
            if (hr)
                goto Cleanup;

            if (itr.Done())
                break;

            // set pchExposedName if not yet
            if (!pchExposedName)
            {
                // pchExposedName could be empty only when we get here first time when
                // this == pPropHost; if pPropHost is OM window, then pchExposedName is set to "window".
                Assert (this == (*ppPropHost));

                // NOTE: because we are looping through attr array, we should not attempt to modify the
                // array by setting UniqueName into it within this loop
                hr = THR(GetUniqueIdentifier(&cstrUniqueName,FALSE));
                if (hr)
                    goto Cleanup;

                fSetUniqueName = TRUE;

                pchExposedName = (TCHAR*) cstrUniqueName;
            }

            //
            // add scriptlet
            //

            bstrFuncName = NULL;

            // we ignore hr so that in case of syntax error it still adds other scriptlets
            IGNORE_HR(pScriptCollection->AddScriptlet(
                pchLanguage,                    // pchLanguage
                GetMarkup(),                    // pMarkup
                NULL,                           // pchType
                itr.pchCode,                    // pchCode
                pchScope,                       // pchItemName
                pchExposedName,                 // pchSubItemName
                (LPTSTR) itr.pchScriptletName,  // pchEventName
                _T("\""),                       // pchDelimiter
                itr.uOffset,                    // ulOffset
                itr.uLine,                      // ulStartingLine
                GetMarkup(),                    // pSourceObject
                SCRIPTTEXT_ISVISIBLE | SCRIPTPROC_HOSTMANAGESSOURCE, // dwFlags
                &bstrFuncName));                // pbstrName

            FormsFreeString(bstrFuncName);

        } // eo for (;;)

        if (fSetUniqueName)
        {
            fSetUniqueName = FALSE;

            hr = THR(SetUniqueNameHelper(pchExposedName));
            if (hr)
                goto Cleanup;
        }
    } // eo for (ppPropHost)


Cleanup:

    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     Inject
//
//  Synopsis:   Stuff text or HTML is various places relative to an element
//
//-----------------------------------------------------------------------------

static BOOL
IsInTableThingy ( CTreeNode * pNode )
{
    //
    // See if we are between a table and its cells
    //
    
    for ( ; pNode ; pNode = pNode->Parent() )
    {
        switch ( pNode->Tag() )
        {
        case ETAG_TABLE :
            return TRUE;
            
        case ETAG_TH :
        case ETAG_TC :
        case ETAG_CAPTION :
        case ETAG_TD :
            return FALSE;
        }
    }

    return FALSE;
}

HRESULT
CElement::Inject (
    Where where, BOOL fIsHtml, LPTSTR pStr, long cch )
{
    HRESULT        hr = S_OK;
    CDoc *         pDoc = Doc();
    CMarkup *      pMarkup;
    BOOL           fEnsuredMarkup = FALSE;
    CMarkupPointer pointerStart ( pDoc );
    CMarkupPointer pointerFinish ( pDoc );
    CParentUndo    Undo(pDoc);
    ELEMENT_TAG    etag = Tag();
    IHTMLEditingServices * pedserv  = NULL;

    PerfDbgLog1( tagInject, this, "+Inject %ls", TagName() );

    //
    // See if one is attempting to place stuff IN a noscope element
    //

    if ((where == Inside || where == AfterBegin || where == BeforeEnd))
    {
        if (fIsHtml)
        {
            CDefaults *     pDefaults       = GetDefaults();
            VARIANT_BOOL    fSupportsHTML;

            if (    ETAG_INPUT == etag
                ||  (pDefaults && pDefaults->GetAAcanHaveHTML(&fSupportsHTML) && !fSupportsHTML)
               )
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }
        }

        if (IsNoScope())
        {
            //
            // Some elements can do inside, but in the slave tree.
            // Also, disallow HTML for those things with a slave markup.  If you
            // can't get to them with the DOM or makrup services, you should not
            // be able to with innerHTML.
            //

            Assert( Tag() != ETAG_GENERIC_NESTED_LITERAL );

            switch (Tag())
            {
            case ETAG_INPUT:

                if (HasSlavePtr() && IsContainer() && !TestClassFlag(CElement::ELEMENTDESC_OMREADONLY))
                {
                    hr = THR( GetSlavePtr()->Inject( where, fIsHtml, pStr, cch ) );

                    goto Cleanup; // done
                }
                break;
        
            case ETAG_GENERIC_LITERAL:

                {
                    CGenericElement *   pGenericElement = DYNCAST(CGenericElement, this);

                    pGenericElement->_cstrContents.Free();

                    hr = THR(pGenericElement->_cstrContents.Set(pStr));

                    goto Cleanup; // done
                }

                break;
            }

            hr = CTL_E_INVALIDPASTETARGET;
            goto Cleanup;
        }
    }

    //
    // Disallow inner/outer on the head and html elements
    //

    if ((etag == ETAG_HTML || etag == ETAG_HEAD || etag == ETAG_TITLE_ELEMENT) &&
        (where == Inside || where == Outside))
    {
        hr = CTL_E_INVALIDPASTETARGET;
        goto Cleanup;
    }

    //
    // Prevent the elimination of the client element
    //
    
    pMarkup = GetMarkup();
    
    if (pMarkup && (where == Inside || where == Outside))
    {
        CElement * pElementClient = pMarkup->GetElementClient();

        //
        // It's ok to do an inner on the client
        //

        if (pElementClient && (where != Inside || this != pElementClient))
        {
            //
            // If we can see the client above this, then the client
            // will get blown away.  Prevent this.
            //
            
            if (pMarkup->SearchBranchForScopeInStory( pElementClient->GetFirstBranch(), this ))
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }
        }
    }
    
    //
    // In IE4, an element had to be in a markup to do this operation.  Now,
    // we are looser.  In order to do validation, the element must be in a
    // markup.  Here we also remember is we placed the element in a markup
    // so that if the injection fails, we can restore it to its "original"
    // state.
    //

    if (!pMarkup)
    {
        hr = THR( EnsureInMarkup() );

        if (hr)
            goto Cleanup;
        
        fEnsuredMarkup = TRUE;
        
        pMarkup = GetMarkup();
        
        Assert( pMarkup );
    }

    //
    // Locate the pointer such that they surround the stuff which should
    // go away, and are located where the new stuff should be placed.
    //

    {
        ELEMENT_ADJACENCY adjLeft = ELEM_ADJ_BeforeEnd;
        ELEMENT_ADJACENCY adjRight = ELEM_ADJ_BeforeEnd;

        switch ( where )
        {
            case Inside :
                adjLeft = ELEM_ADJ_AfterBegin;
                adjRight = ELEM_ADJ_BeforeEnd;
                break;
                
            case Outside :
                adjLeft = ELEM_ADJ_BeforeBegin;
                adjRight = ELEM_ADJ_AfterEnd;
                break;
                
            case BeforeBegin :
                adjLeft = ELEM_ADJ_BeforeBegin;
                adjRight = ELEM_ADJ_BeforeBegin;
                break;
                
            case AfterBegin :
                adjLeft = ELEM_ADJ_AfterBegin;
                adjRight = ELEM_ADJ_AfterBegin;
                break;
                
            case BeforeEnd :
                adjLeft = ELEM_ADJ_BeforeEnd;
                adjRight = ELEM_ADJ_BeforeEnd;
                break;
                
            case AfterEnd :
                adjLeft = ELEM_ADJ_AfterEnd;
                adjRight = ELEM_ADJ_AfterEnd;
                break;
        }

        hr = THR( pointerStart.MoveAdjacentToElement( this, adjLeft ) );

        if (hr)
            goto Cleanup;

        hr = THR( pointerFinish.MoveAdjacentToElement( this, adjRight ) );

        if (hr)
            goto Cleanup;
    }

    Assert( pointerStart.IsPositioned() );
    Assert( pointerFinish.IsPositioned() );

    {
        CTreeNode * pNodeStart  = pointerStart.Branch();
        CTreeNode * pNodeFinish = pointerFinish.Branch();

        //
        // For the 5.0 version, because we don't have contextual parsing,
        // make sure tables can't be messed with.
        //

        if (fIsHtml)
        {
            //
            // See if the beginning of the inject is in a table thingy
            //
            
            if (pNodeStart && IsInTableThingy( pNodeStart ))
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }

            //
            // See if the end of the inject is different from the start.
            // If so, then also check it for being in a table thingy.
            //
            
            if (pNodeFinish && pNodeStart != pNodeFinish &&
                IsInTableThingy( pNodeStart ))
            {
                hr = CTL_E_INVALIDPASTETARGET;
                goto Cleanup;
            }
        }

        //
        // Make sure we record undo information if we should.  I believe that
        // here is where we make the decision to not remembers automation
        // like manipulation, but do remember user editing scenarios.
        //
        // Here, we check the elements above the start and finish to make sure
        // they are editable (in the user sense).
        //

        if (pNodeStart && pNodeFinish &&
            pNodeStart->IsEditable(/*fCheckContainerOnly*/FALSE) &&
            pNodeFinish->IsEditable(/*fCheckContainerOnly*/FALSE))
        {
            Undo.Start( IDS_UNDOGENERICTEXT );
        }
    }

    //
    // Perform the HTML/text injection
    //

    if (fIsHtml)
    {
        HRESULT HandleHTMLInjection (
            CMarkupPointer *, CMarkupPointer *,
            const TCHAR *, long, CElement * );

        hr = THR(
            HandleHTMLInjection(
                & pointerStart, & pointerFinish, pStr, cch,
                where == Inside ? this : NULL ) );

        if (hr == S_FALSE)
        {
            hr = CTL_E_INVALIDPASTESOURCE;
            goto Cleanup;
        }

        if (hr)
            goto Cleanup;
    }
    else
    {
        IHTMLEditor * phtmed;

        HRESULT RemoveWithBreakOnEmpty (
            CMarkupPointer * pPointerStart, CMarkupPointer * pPointerFinish );

        hr = THR( RemoveWithBreakOnEmpty( & pointerStart, & pointerFinish ) );
        
        if (hr)
            goto Cleanup;

        if (where == Inside)
        {
            HRESULT UnoverlapPartials ( CElement * );

            hr = THR( UnoverlapPartials( this ) );

            if (hr)
                goto Cleanup;
        }

        //
        // Get the editing services interface with which I can
        // insert sanitized text
        //

        phtmed = Doc()->GetHTMLEditor();

        if (!phtmed)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = THR(
            phtmed->QueryInterface(
                IID_IHTMLEditingServices, (void **) & pedserv ) );

        if (hr)
            goto Cleanup;

        hr = THR(
             pedserv->InsertSanitizedText(
                & pointerStart, pStr, cch, TRUE ) );

        if (hr)
            goto Cleanup;

        //
        // TODO - Launder spaces here on the edges
        //
    }

Cleanup:

    //
    // If we are failing, and we had to put this element into a markup
    // at the beginning, take it out now to restore to the origianl state.
    //

    if (hr != S_OK && fEnsuredMarkup && GetMarkup())
        IGNORE_HR( THR( Doc()->RemoveElement( this ) ) );
    
    //
    //
    //

    ReleaseInterface( pedserv );

    Undo.Finish( hr );

    PerfDbgLog( tagInject, this, "-Inject" );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     InsertAdjacent
//
//  Synopsis:   Inserts the given element into the tree, positioned relative
//              to 'this' element as specified.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::InsertAdjacent ( Where where, CElement * pElementInsert )
{
    HRESULT        hr = S_OK;
    CMarkupPointer pointer( Doc() );

    Assert( IsInMarkup() );
    Assert( pElementInsert && !pElementInsert->IsInMarkup() );
    Assert( !pElementInsert->IsRoot() );
    Assert( ! IsRoot() || where == AfterBegin || where == BeforeEnd );

    //
    // Figure out where to put the element
    //

    switch ( where )
    {
    case BeforeBegin :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_BeforeBegin ) );
        break;

    case AfterEnd :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_AfterEnd ) );
        break;

    case AfterBegin :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
        break;

    case BeforeEnd :
        hr = THR( pointer.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd ) );
        break;
    }

    if (hr)
        goto Cleanup;

    hr = THR( Doc()->InsertElement( pElementInsert, & pointer, NULL ) );

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     RemoveOuter
//
//  Synopsis:   Removes 'this' element and everything which 'this' element
//              influences.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::RemoveOuter ( )
{
    HRESULT        hr;
    CMarkupPointer p1( Doc() ), p2( Doc() );

    hr = THR( p1.MoveAdjacentToElement( this, ELEM_ADJ_BeforeBegin ) );

    if (hr)
        goto Cleanup;

    hr = THR( p2.MoveAdjacentToElement( this, ELEM_ADJ_AfterEnd ) );

    if (hr)
        goto Cleanup;

    hr = THR( Doc()->Remove( & p1, & p2 ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     GetText
//
//  Synopsis:   Gets the specified text for the element.
//
//  Note: invokes saver.  Use WBF_NO_TAG_FOR_CONTEXT to determine whether
//  or not the element itself is saved.
//
//-----------------------------------------------------------------------------

HRESULT
CElement::GetText(BSTR * pbstr, DWORD dwStmFlags)
{
    HRESULT     hr = S_OK;
    IStream * pstm = NULL;

    if(!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstr = NULL;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (hr)
        goto Cleanup;

    {
        CStreamWriteBuff swb(pstm, CP_UCS_2);

        hr = THR( swb.Init() );
        if( hr )
            goto Cleanup;

        swb.SetFlags(dwStmFlags);
        swb.SetElementContext(this);

        // Save the begin tag of the context element
        hr = THR( Save(&swb, FALSE) );
        if (hr)
            goto Cleanup;

        if (IsInMarkup())
        {
            CTreeSaver ts(this, &swb);
            hr = ts.Save();
            if (hr)
                goto Cleanup;
        }

        // Save the end tag of the context element
        hr = THR( Save(&swb, TRUE) );
        if (hr)
            goto Cleanup;

        hr = swb.Terminate();
        if (hr)
            goto Cleanup;
    }

    hr = GetBStrFromStream(pstm, pbstr, TRUE);

Cleanup:
    ReleaseInterface(pstm);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     put_innerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_innerHTML ( BSTR bstrHTML )
{
    RECALC_PUT_HELPER(DISPID_CElement_innerHTML)

    HRESULT hr = S_OK;

    hr = THR( Inject( Inside, TRUE, bstrHTML, FormsStringLen( bstrHTML ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        OnPropertyChange(
            s_propdescCElementinnerHTML.b.dispid,
            s_propdescCElementinnerHTML.b.dwFlags,
            (PROPERTYDESC *)&s_propdescCElementinnerHTML) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_innerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_innerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_innerHTML ( BSTR * bstrHTML )
{
    RECALC_GET_HELPER(DISPID_CElement_innerHTML)

    HRESULT hr = THR(GetText(bstrHTML, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_innerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_innerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_innerText ( BSTR bstrText )
{
    HRESULT hr = S_OK;

    hr = THR( Inject( Inside, FALSE, bstrText, FormsStringLen( bstrText ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(OnPropertyChange ( s_propdescCElementinnerText.b.dispid,
                                s_propdescCElementinnerText.b.dwFlags,
                                (PROPERTYDESC *)&s_propdescCElementinnerText ));

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_innerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_innerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_innerText ( BSTR * pbstrText )
{
    HRESULT hr = THR(GetText(pbstrText,
        WBF_SAVE_PLAINTEXT|WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_innerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_outerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_outerHTML ( BSTR bstrHTML )
{
    HRESULT hr = S_OK;
    CElement::CLock Lock(this);


    hr = THR( Inject( Outside, TRUE, bstrHTML, FormsStringLen( bstrHTML ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        OnPropertyChange(
            s_propdescCElementouterHTML.b.dispid,
            s_propdescCElementouterHTML.b.dwFlags,
            (PROPERTYDESC *)&s_propdescCElementouterHTML ) );

    if (hr)
        goto Cleanup;
    
    if ( GetFirstBranch() )
    {
        CTreeNode * pCurrentNode = GetFirstBranch()->Parent();

        // Our accessible parent needs to know that about the change

        while(   pCurrentNode != NULL
              && !((   pCurrentNode->Element()->HasAccObjPtr() 
                    || IsSupportedElement(pCurrentNode->Element()))))
        {
            pCurrentNode = pCurrentNode->Parent();
        }
        
        if (pCurrentNode)
            pCurrentNode->Element()->FireAccessibilityEvents(DISPID_IHTMLELEMENT_INNERHTML);
    }
    
Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_outerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_outerHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_outerHTML ( BSTR * pbstrHTML )
{
    HRESULT hr = THR(GetText(pbstrHTML, WBF_NO_WRAP));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_outerHTML ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_outerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::put_outerText ( BSTR bstrText )
{
    HRESULT hr = S_OK;
    CElement::CLock Lock(this);

    hr = THR( Inject( Outside, FALSE, bstrText, FormsStringLen( bstrText ) ) );

    if (hr)
        goto Cleanup;

    hr = THR(OnPropertyChange ( s_propdescCElementouterText.b.dispid,
                                s_propdescCElementouterText.b.dwFlags,
                                (PROPERTYDESC *)&s_propdescCElementouterText ));

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfoPSet( hr, DISPID_CElement_outerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_outerText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_outerText ( BSTR * pbstrText )
{
    HRESULT hr = THR(GetText(pbstrText,
        WBF_SAVE_PLAINTEXT|WBF_NO_WRAP));

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_outerText ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     insertAdjacentHTML
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

static inline CElement::Where ConvertAdjacent ( htmlAdjacency where )
{
    switch ( where )
    {
    case htmlAdjacencyBeforeBegin : return CElement::BeforeBegin;
    case htmlAdjacencyAfterBegin  : return CElement::AfterBegin;
    case htmlAdjacencyBeforeEnd   : return CElement::BeforeEnd;
    case htmlAdjacencyAfterEnd    : return CElement::AfterEnd;
    default                       : Assert( 0 );
    }

    return CElement::BeforeBegin;
}

STDMETHODIMP
CElement::insertAdjacentHTML ( BSTR bstrWhere, BSTR bstrHTML )
{
    HRESULT hr = S_OK;
    htmlAdjacency where;

    hr = THR( ENUMFROMSTRING( htmlAdjacency, bstrWhere, (long *) & where ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        Inject(
            ConvertAdjacent( where ), TRUE, bstrHTML, FormsStringLen( bstrHTML ) ) );

    if (hr)
        goto Cleanup;

    if ( GetFirstBranch() )
    {
        CTreeNode * pCurrentNode = GetFirstBranch();
        
        if (where == htmlAdjacencyBeforeBegin || where == htmlAdjacencyAfterEnd)
            pCurrentNode = pCurrentNode->Parent();

        // accessible clients need to know if we've added HTML
        while(   pCurrentNode != NULL
              && !((   pCurrentNode->Element()->HasAccObjPtr() 
                    || IsSupportedElement(pCurrentNode->Element()))))
        {
            pCurrentNode = pCurrentNode->Parent();
        }
        
        if (pCurrentNode)
            pCurrentNode->Element()->FireAccessibilityEvents(DISPID_IHTMLELEMENT_INNERHTML);    
    }    

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     insertAdjacentText
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::insertAdjacentText ( BSTR bstrWhere, BSTR bstrText )
{
    HRESULT hr = S_OK;
    htmlAdjacency where;

    hr = THR( ENUMFROMSTRING( htmlAdjacency, bstrWhere, (long *) & where ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        Inject(
            ConvertAdjacent( where ), FALSE, bstrText, FormsStringLen( bstrText ) ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_parentTextEdit
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_parentTextEdit ( IHTMLElement * * ppDispParent )
{
    HRESULT hr = S_OK;
    CTreeNode * pNodeContext;

    if (!ppDispParent)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDispParent = NULL;

    pNodeContext = GetFirstBranch();

    if (!pNodeContext)
        goto Cleanup;

    while ( (pNodeContext = pNodeContext->Parent()) != NULL )
    {
        VARIANT_BOOL vb;

        hr = THR( pNodeContext->Element()->get_isTextEdit ( & vb ) );

        if (hr)
            goto Cleanup;

        if (vb)
            break;
    }

    if (!pNodeContext)
        goto Cleanup;

    hr = THR( pNodeContext->Element()->QueryInterface(
        IID_IHTMLElement, (void * *) ppDispParent ) );

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_parentTextEdit ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_isTextEdit
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CElement::get_isTextEdit ( VARIANT_BOOL * pvb )
{
    HRESULT hr = S_OK;

    if (!pvb)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    switch ( Tag() )
    {
    case ETAG_BODY :
    case ETAG_TEXTAREA :
#ifdef  NEVER
    case ETAG_HTMLAREA :
#endif
    case ETAG_BUTTON :
        *pvb = VB_TRUE;
        break;

    case ETAG_INPUT :
        switch (DYNCAST(CInput, this)->GetType())
        {
            case htmlInputButton:
            case htmlInputReset:
            case htmlInputSubmit:
            case htmlInputText:
            case htmlInputPassword:
            case htmlInputHidden:
            case htmlInputFile:
                *pvb = VB_TRUE;
                break;
            default :
                *pvb = VB_FALSE;
                break;
        }
        break;

    default :
        *pvb = VB_FALSE;
        break;
    }

Cleanup:

    RRETURN( SetErrorInfoPGet( hr, DISPID_CElement_isTextEdit ) );
}

// Used to help determine if a Visual Hebrew codpage is specified
static BOOL LocateCodepageMeta ( CMetaElement * pMeta )
{
    return pMeta->IsCodePageMeta();
}


CAttrArray *CElement::GetInLineStyleAttrArray ( void )
{
    CAttrArray *pAA = NULL;
        
    // Apply the in-line style attributes
    AAINDEX aaix = FindAAIndex ( DISPID_INTERNAL_INLINESTYLEAA,
            CAttrValue::AA_AttrArray );
    if ( aaix != AA_IDX_UNKNOWN )
    {
        CAttrValue *pAttrValue = (CAttrValue *)**GetAttrArray();
        pAA = pAttrValue[aaix].GetAA();
    }
    return pAA;
}

CAttrArray **CElement::CreateStyleAttrArray ( DISPID dispID )
{
    AAINDEX aaix = AA_IDX_UNKNOWN;
    if ( ( aaix = FindAAIndex ( dispID,
            CAttrValue::AA_AttrArray ) ) == AA_IDX_UNKNOWN )
    {
            CAttrArray *pAA = new CAttrArray;
            AddAttrArray ( dispID, pAA,
                CAttrValue::AA_AttrArray );
            aaix = FindAAIndex ( dispID,
                CAttrValue::AA_AttrArray );
    }
    if ( aaix == AA_IDX_UNKNOWN )
    {
        return NULL;
    }
    else
    {
        CAttrValue *pAttrValue = (CAttrValue *)**GetAttrArray();
        return (CAttrArray**)(pAttrValue[aaix].GetppAA());
    }
}

//----------------------------------------------------------------
//
//      Member:         CElement::GetStyleObject
//
//  Description Helper function to create the .style sub-object
//
//----------------------------------------------------------------
HRESULT
CElement::GetStyleObject(CStyle **ppStyle)
{
    HRESULT hr;
    CStyle *pStyle = 0;

    hr = GetPointerAt(FindAAIndex( DISPID_INTERNAL_CSTYLEPTRCACHE,CAttrValue::AA_Internal), (void **)&pStyle);

    if (!pStyle)
    {
        pStyle = new CStyle(this, DISPID_INTERNAL_INLINESTYLEAA, 0);
        if (!pStyle)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = AddPointer(DISPID_INTERNAL_CSTYLEPTRCACHE, (void *)pStyle, CAttrValue::AA_Internal);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (!hr)
    {
        *ppStyle = pStyle;
    }
    else
    {
        *ppStyle = NULL;
        delete pStyle;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::SetDim, public
//
//  Synopsis:   Sets a given property (either on the inline style or the
//              attribute directly) to a given pixel value, preserving the
//              original units of that attribute.
//
//  Arguments:  [dispID]       -- Property to set the value of
//              [fValue]       -- Value of the property
//              [uvt]          -- Units [fValue] is in. If UNIT_NULLVALUE then
//                                 [fValue] is assumed to be in whatever the
//                                 current units are for this property.
//              [lDimOf]       -- For percentage values, what the percent is of
//              [fInlineStyle] -- If TRUE, the inline style is changed,
//                                otherwise the HTML attribute is changed
//              [pfChanged]    -- Place to indicate if the value actually
//                                changed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CElement::SetDim(DISPID                    dispID,
                 float                     fValue,
                 CUnitValue::UNITVALUETYPE uvt,
                 long                      lDimOf,
                 CAttrArray **             ppAttrArray,
                 BOOL                      fInlineStyle,
                 BOOL *                    pfChanged)
{
    CUnitValue          uvValue;
    HRESULT             hr;
    long                lRawValue;

    Assert(pfChanged);
    uvValue.SetNull();

    if (!ppAttrArray)
    {
        if (fInlineStyle)
        {
            ppAttrArray = CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
        }
        else
        {
            ppAttrArray = GetAttrArray();
        }
    }

    Assert(ppAttrArray);
    
    if (*ppAttrArray)
    {
        (*ppAttrArray)->GetSimpleAt(
            (*ppAttrArray)->FindAAIndex(dispID, CAttrValue::AA_Attribute),
            (DWORD*)&uvValue );
    }

    lRawValue = uvValue.GetRawValue();

    if (uvt == CUnitValue::UNIT_NULLVALUE)
    {
        uvt = uvValue.GetUnitType();

        if (uvt == CUnitValue::UNIT_NULLVALUE)
        {
            uvt = CUnitValue::UNIT_PIXELS;
        }
    }

    if ( dispID == STDPROPID_XOBJ_HEIGHT || dispID == STDPROPID_XOBJ_TOP )
    {
        hr = THR(uvValue.YSetFloatValueKeepUnits (fValue,
                                                  uvt,
                                                  lDimOf,
                                                  GetFirstBranch()->GetFontHeightInTwips(&uvValue)));
    }
    else
    {
        hr = THR(uvValue.XSetFloatValueKeepUnits(fValue,
                                                 uvt,
                                                 lDimOf,
                                                 GetFirstBranch()->GetFontHeightInTwips(&uvValue)));
    }
    if ( hr )
        goto Cleanup;

    if ( uvValue.GetRawValue() == lRawValue ) // Has anything changed ??
        goto Cleanup;

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            VARIANT vtProp;

            vtProp.vt = VT_I4;
            vtProp.lVal = lRawValue;

            if( fTreeSync )
            {
                PROPERTYDESC  * pPropDesc;
                CBase * pBase = this;

                if( fInlineStyle )
                {
                    CStyle * pStyle;

                    IGNORE_HR( GetStyleObject( &pStyle ) );
                    pBase = pStyle;
                }

                // NOTE (JHarding): This may be slow if we don't hit the GetIDsOfNames cache
                IGNORE_HR( pBase->FindPropDescFromDispID( dispID, &pPropDesc, NULL, NULL ) );
                Assert( pPropDesc );

                if( pPropDesc )
                {
                    CUnitValue  uvOld( lRawValue );
                    TCHAR       achOld[30];
                    TCHAR       achNew[30];

                    if( SUCCEEDED( uvOld.FormatBuffer( achOld, ARRAY_SIZE(achOld), pPropDesc ) ) &&
                        SUCCEEDED( uvValue.FormatBuffer( achNew, ARRAY_SIZE(achNew), pPropDesc ) ) )
                    {
                        VARIANT     vtNew;
                        VARIANT     vtOld;

                        // Shouldn't have been able to set to what converts to an empty string
                        Assert( achNew[0] );

                        vtNew.vt = VT_LPWSTR;
                        vtNew.byref = achNew;

                        if( !achOld[0] )
                        {
                            // No old value
                            V_VT(&vtOld) = VT_NULL;
                        }
                        else
                        {
                            vtOld.vt = VT_LPWSTR;
                            vtOld.byref = achOld;
                        }

                        // Log the change
                        pBase->LogAttributeChange( dispID, &vtOld, &vtNew );
                    }
                }
            }

            if( fCreateUndo )
            {
                IGNORE_HR(CreateUndoAttrValueSimpleChange(
                    dispID, vtProp, fInlineStyle, CAttrValue::AA_StyleAttribute ) );
            }
        }
    }
#endif // NO_EDIT

    hr = THR(CAttrArray::AddSimple ( ppAttrArray, dispID, uvValue.GetRawValue(),
                                     CAttrValue::AA_StyleAttribute ));

    if (hr)
        goto Cleanup;

    *pfChanged = TRUE;

Cleanup:
    RRETURN(hr);
}

HRESULT
CElement::fireEvent(BSTR bstrEventName, VARIANT *pvarEventObject, VARIANT_BOOL *pfCancelled)
{
    HRESULT hr = S_OK;
    const PROPERTYDESC *ppropdesc;
    EVENTPARAM *pParam = NULL;
    BOOL fCreateLocal = FALSE;
    CEventObj *pSrcEventObj = NULL;
    IHTMLEventObj *pIEventObject = NULL;
    CTreeNode *pNode = GetFirstBranch();
    CElement *pelFireWith = this;
    
    if (!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!bstrEventName || !*bstrEventName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (HasMasterPtr())
        pelFireWith = GetMasterPtr();

    //TODO(sramani): what about Case sensitivity?
    Assert(pelFireWith);
    ppropdesc = pelFireWith->FindPropDescForName(bstrEventName);
    if (!ppropdesc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pvarEventObject && V_VT(pvarEventObject) == VT_DISPATCH && V_DISPATCH(pvarEventObject))
    {
        pIEventObject = (IHTMLEventObj *)V_DISPATCH(pvarEventObject);

        hr = THR(pIEventObject->QueryInterface(CLSID_CEventObj, (void **)&pSrcEventObj));
        if (hr)
            goto Cleanup;

        pSrcEventObj->GetParam(&pParam);
        if (!pParam)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        // event object passed in already pushed on stack --- we are inside an event handler, copy it locally and use.
        if (pParam->_fOnStack)
            fCreateLocal = TRUE;
    }
    else // no event obj passed in, create one implicitly on the stack and init it.
    {
        fCreateLocal = TRUE;
    }

    if (fCreateLocal)
    {
        EVENTPARAM param(Doc(), this, NULL, !pParam, TRUE, pParam);

        param.SetType(ppropdesc->pstrName + 2); // all events start with on...

        // if offsetX or offsetY or both was explicity set on a eventobj that was locked on stack
        // (i.e from inside an event handler that was invoked by passing a heap eventobj to fireEvent)
        if (pSrcEventObj && pSrcEventObj->_fReadWrite && (pParam->_fOffsetXSet || pParam->_fOffsetYSet))
        {
            // srcElement; translate clientX, clientY , screenX, screenY based on offsetX, offsetY
            param.SetNodeAndCalcCoordsFromOffset(pNode);
            param._fOffsetXSet = FALSE;
            param._fOffsetYSet = FALSE;
        }
        else
        {
            // srcElement; translate x, y , offsetX, offsetY based on clientX, clientY
            param._pNode = pNode;
            param.CalcRestOfCoordinates();
        }

        if (ppropdesc->GetDispid() == DISPID_EVPROP_ONBEFOREEDITFOCUS)
           param._pNodeTo = pNode;

        param.fCancelBubble = FALSE;
        V_VT(&param.varReturnValue) = VT_EMPTY;

        hr = FireEvent((const PROPERTYDESC_BASIC *)ppropdesc, FALSE);
    }
    else // explicitly created event object passed in, re-use it by locking it on stack
    {
        Assert(pIEventObject);
        Assert(pParam);

        pParam->SetType(ppropdesc->pstrName + 2); // all events start with on...
        
        // if offsetX or offsetY or both was explicity set on a heap eventobj
        if (pParam->_fOffsetXSet || pParam->_fOffsetYSet)
        {
            // srcElement; translate clientX, clientY , screenX, screenY based on offsetX, offsetY
            pParam->SetNodeAndCalcCoordsFromOffset(pNode);
            pParam->_fOffsetXSet = FALSE;
            pParam->_fOffsetYSet = FALSE;
        }
        else
        {
            // srcElement; translate x, y , offsetX, offsetY based on clientX, clientY
            pParam->_pNode = pNode;
            pParam->CalcRestOfCoordinates(); 
        }

        pParam->fCancelBubble = FALSE;
        V_VT(&pParam->varReturnValue) = VT_EMPTY;

        CEventObj::COnStackLock onStackLock(pIEventObject);

        hr = FireEvent((const PROPERTYDESC_BASIC *)ppropdesc, FALSE);
    }

    if (pfCancelled && !FAILED(hr))
    {
        if (ppropdesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_CANCELABLE)
            *pfCancelled = (hr) ? VB_TRUE : VB_FALSE;
        else
            *pfCancelled = VB_TRUE;
    
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::FireEvent, public
//
//  Synopsis:   Central event firing routine that supports any combination of bubbling
//              and cancelable events for an ELEMENT
//
//  Arguments:  [pDesc]         -- propdesc of event fired, for access to DISPIDs
//                                 and event type string and cancel\bubble flags.
//              [fPush]         -- if FALSE, caller needs to push EVENTPARAM on
//                                 stack, else this function does.
//              [pNodeContext]  -- Reqd. for bubbling events
//              [lSubDivision]  -- Reqd. for bubbling events
//
//  Returns:    HRESULT if not cancelable;
//              if cancelable, 0(S_OK) == cancel; 1(S_FALSE) == default
//
//----------------------------------------------------------------------------

HRESULT
CElement::FireEvent(
    const PROPERTYDESC_BASIC *pDesc,
    BOOL fPush,
    CTreeNode *pNodeContext,
    long lSubDivision,
    EVENTINFO * pEvtInfo, BOOL fDontFireMSAA)
{
    Assert(pDesc);

    CDoc         * pDoc = Doc();
    CPeerHolder  * pPeerHolder = NULL;
    DWORD           dwPPFlags = pDesc->b.dwPPFlags;
    BOOL            fShouldFire = TRUE;
    BOOL            fCancelable = dwPPFlags & PROPPARAM_CANCELABLE;
    BOOL            fBubble = dwPPFlags & PROPPARAM_BUBBLING;
    DISPID          dispidEvent = (DISPID)(pDesc->c);
    DISPID          dispidProp = pDesc->b.dispid;

    // Note that we are using the HRESULT itself as the return value for cancelable events.
    // So the default value of the BOOL, TRUE (1) would be == the HRESULT, S_FALSE (also 1).
    HRESULT         hr = fCancelable ? S_FALSE : S_OK; 

    Assert(dispidEvent);
    Assert(!_fExittreePending);

    // HACKHACKHACK: (jbeda) There is a known reentrancy problem with ValidateSecureUrl.
    // The last clause here (pDoc->_cInSslPrompt) works around that so we don't see this
    // assert firing all over the place.

    //
    // HACKHACK2: marka - reentrancy issue during error during document.write
    // tree is in a bad place. script error hits and we bring up a scripting dialog
    // and then fire the OnFocusOut method.
    // 

    
    Assert(!GetMarkup() || !GetMarkup()->__fDbgLockTree || pDoc->_cInSslPrompt
           || (pDoc->_fModalDialogInScript ));

    BOOL fFireNormalEvent = !fBubble && !fCancelable;
    BOOL fBubbleCancelableEvent = fBubble && fCancelable;

    if (fBubble)
    {
        if (!pNodeContext)
            pNodeContext = GetFirstBranch();

        if (!pNodeContext)
            goto Cleanup;

        //  TODO: Moved this here because this event could possibly fire on a dead node.
        //  What should really happen though is that we should fire the event before the
        //  node is deleted from the tree.

        Assert(pNodeContext && (HasCapture() || pNodeContext->Element() == this));
    }
    else
    {
        // Onloads can happen before the document is done parsing and before the message pump is hit so
        // deferred scripts may not be hooked up when onload is fired.  If the onload is being fired then
        // hook up any event handlers.
        if (fFireNormalEvent && (dispidEvent == DISPID_EVMETH_ONLOAD))
        {
            IGNORE_HR(pDoc->CommitDeferredScripts(TRUE, GetMarkup()));
        }

        // No nearest layout->assume enabled (dbau)
        fShouldFire = ShouldFireEvents();
        if( fShouldFire )
        {
            CElement *pElem = GetUpdatedNearestLayoutElement();
            fShouldFire = (!pElem || !pElem->GetAAdisabled());
        }
    }

    if (fShouldFire)
    {
        if (fFireNormalEvent)
        {
            pPeerHolder = GetPeerHolder();

            // don't fire standard events if there is a behavior attached that wants to fire them instead
            //  or if there is no event handler or connection point attached to this element, don't bother 
            //  with the the work (perffix )
            if (pPeerHolder &&
                IsStandardDispid(dispidProp) &&
                pPeerHolder->CanElementFireStandardEventMulti(dispidProp)) 
                goto Cleanup;
        }
    
        {
            CPeerHolder::CLock lock(pPeerHolder);
            BOOL fRet = DISPID_EVMETH_ONMOUSEOVER != dispidEvent; // false for onmouseover

            EVENTPARAM  param(fPush ? pDoc : NULL, this, NULL, TRUE);

            if (fPush)
            {
                Assert(pDoc->_pparam == &param);
                CTreeNode *pNC = pNodeContext;

                if (fBubbleCancelableEvent && pDoc->HasCapture() && pDoc->_pNodeLastMouseOver &&
                    (   (dispidEvent == DISPID_EVMETH_ONCLICK)
                    ||  (dispidEvent == DISPID_EVMETH_ONDBLCLICK)
                    ||  (dispidEvent == DISPID_EVMETH_ONCONTEXTMENU)))
                {
                    if (dispidEvent == DISPID_EVMETH_ONCONTEXTMENU && !pEvtInfo->_fContextMenuFromMouse)
                    {
                        pNC = pDoc->_pElemCurrent ? pDoc->_pElemCurrent->GetFirstBranch() : pNodeContext;
                    }
                    else
                    {
                        pNC = pDoc->_pNodeLastMouseOver;
                    }
                }

                // NEWTREE: GetFirstBranch is iffy here
                //          I've seen this be null on a timer event.
                param.SetNodeAndCalcCoordinates(fBubble ? pNC : GetFirstBranch());
                param.SetType(pDesc->a.pstrName + 2); // all events start with on...
            }

            if (fBubble)
            {
                if (fPush)
                {
                    param._lSubDivisionSrc = lSubDivision;
                    if (fCancelable && dispidEvent == DISPID_EVMETH_ONBEFOREEDITFOCUS)
                        param._pNodeTo = pNodeContext;
                }

                if ( pEvtInfo )
                {
                    pEvtInfo->_dispId = dispidEvent;
                    //
                    // Deleted from destructor of EventObject.
                    //            
                    pEvtInfo->_pParam = new EVENTPARAM( & param );

                    if ( pEvtInfo->_fCopyButton )
                    {
                        param._lButton = pEvtInfo->_lButton ;
                    }

                    if( pEvtInfo->_fDontFireEvent )
                        goto Cleanup;            
                }
                
                hr = THR(BubbleEventHelper(pNodeContext, lSubDivision, dispidEvent, dispidProp, FALSE, (fCancelable ? &fRet : NULL)));
                if (fCancelable)
                {
                    Assert(pDoc->_pparam);
                    if (DISPID_EVMETH_ONMOUSEOVER != dispidEvent)
                        fRet = fRet && !pDoc->_pparam->IsCancelled();
                    else
                    {
                        // for the onmouseover event, returning true by EITHER methods 
                        // (event.returnValue or return statement) cancels the default action
                        fRet = (fRet || ((V_VT(&pDoc->_pparam->varReturnValue) == VT_BOOL) &&
                                         (V_BOOL(&pDoc->_pparam->varReturnValue) == VB_TRUE)));
                    }
                }
            }
            else
            {
                if ( pEvtInfo )
                {
                    pEvtInfo->_dispId = dispidEvent;
                    //
                    // Deleted from destructor of EventObject.
                    //            
                    pEvtInfo->_pParam = new EVENTPARAM( & param );

                    if ( pEvtInfo->_fCopyButton )
                    {
                        param._lButton = pEvtInfo->_lButton ;
                    }     

                    if( pEvtInfo->_fDontFireEvent )
                        goto Cleanup;            
                    
                }
            
                if (pDoc->_pparam->_pNode)
                    pDoc->_pparam->_pNode->NodeAddRef();
                hr = THR(CBase::FireEvent(pDoc, this, NULL, dispidEvent, dispidProp, NULL, (fCancelable ? &fRet : NULL)));
                if (pDoc->_pparam->_pNode)
                    pDoc->_pparam->_pNode->NodeRelease();
            }

            if (fCancelable)
            {
                // if this function doesn't, caller should have pushed EVENTPARAM
                Assert(!fPush && pDoc->_pparam || pDoc->_pparam == &param);
                hr = fRet;
            }
        }
    }

    if (fFireNormalEvent)
    {
        //
        // since focus/blur do not bubble, and things like accessibility
        // need to have a centralized place to handle focus changes, if
        // we just fired focus or blur for someone other than the doc,
        // then fire the doc's onfocuschange/onblurchange methods, keeping
        // the event param structure intact.
        //
        // TODO (carled) the ONCHANGEFOCUS/ONCHANGEBLUR need to be removed
        //   from the document's event interface
        //

        if (!fDontFireMSAA && !hr &&
            ((dispidEvent==DISPID_EVMETH_ONFOCUS)||(dispidEvent==DISPID_EVMETH_ONBLUR)) && 
            (Tag()!=ETAG_ROOT))
        {
            // We have to check is the document has the focus, before firing this, 
            // to prevent firing of accessible focus/blur events when the document
            // does not have the focus. 
            if (pDoc->HasFocus())
            {
                hr = THR(FireAccessibilityEvents(dispidEvent));
            }
        }
    }
    else if (!fDontFireMSAA && !hr && (dispidEvent==DISPID_EVMETH_ONACTIVATE) && (Tag()!=ETAG_ROOT) && pDoc->_fPopupDoc)
    {         
        hr = THR(FireAccessibilityEvents(DISPID_EVMETH_ONFOCUS));     
    }
    
    else if (!fDontFireMSAA && SUCCEEDED(hr) && dispidEvent == DISPID_ONCONTROLSELECT)
    {
        IGNORE_HR(FireAccessibilityEvents(DISPID_ONCONTROLSELECT));
    }
    

Cleanup:
    RRETURN1(hr, S_FALSE);
}


// Helper
void
TransformToThisMarkup(CTreeNode ** ppNode, CMarkup * pMarkup, long * plSubDiv)
{
    Assert(ppNode && pMarkup && plSubDiv);

    CTreeNode * pNode = *ppNode;
    while (pNode && pNode->GetMarkup() != pMarkup)
    {
        *plSubDiv = -1; // reset subdivision if going to a different markup
        while (pNode && !pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Parent();
        }
        if (pNode)
        {
            pNode = pNode->Element()->GetMasterPtr()->GetFirstBranch();
        }
    }
    *ppNode = pNode;
}

void
CheckAndReleaseNode(CTreeNode ** ppNode)
{
    Assert(ppNode);

    if (*ppNode)
    {
        BOOL fDead = (*ppNode)->IsDead();
        (*ppNode)->NodeRelease();
        if (fDead)
        {
            *ppNode = NULL;
        }
    }
}

BOOL
AllowBubbleToMaster(DISPID dispidEvent)
{
    switch (dispidEvent)
    {
    case DISPID_EVMETH_ONBEFORECOPY:
    case DISPID_EVMETH_ONBEFORECUT:
    case DISPID_EVMETH_ONBEFOREEDITFOCUS:
    case DISPID_EVMETH_ONBEFOREPASTE:
    case DISPID_EVMETH_ONCLICK:
    case DISPID_EVMETH_ONDBLCLICK:
    case DISPID_EVMETH_ONCONTEXTMENU:
    case DISPID_EVMETH_ONCUT:
    case DISPID_EVMETH_ONCOPY:
    case DISPID_EVMETH_ONPASTE:
    case DISPID_EVMETH_ONDRAG:
    case DISPID_EVMETH_ONDRAGEND:
    case DISPID_EVMETH_ONDRAGENTER:
    case DISPID_EVMETH_ONDRAGLEAVE:
    case DISPID_EVMETH_ONDRAGOVER:
    case DISPID_EVMETH_ONDRAGSTART:
    case DISPID_EVMETH_ONDROP:
    case DISPID_EVMETH_ONHELP:
    case DISPID_EVMETH_ONKEYDOWN:
    case DISPID_EVMETH_ONKEYPRESS:
    case DISPID_EVMETH_ONKEYUP:
    case DISPID_EVMETH_ONMOUSEDOWN:
    case DISPID_EVMETH_ONMOUSEMOVE:
    case DISPID_EVMETH_ONMOUSEWHEEL:
    case DISPID_EVMETH_ONMOUSEUP:
    case DISPID_EVMETH_ONSELECTSTART:
    case DISPID_ONCONTROLSELECT:
        return TRUE;
    default:
        return FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   BubbleEventHelper
//
//  Synopsis:   Fire the specified event. All the sites in the parent chain
//              are supposed to fire the events (if they can).  Caller has
//              responsibility for setting up any EVENTPARAM.
//
//  Arguments:  [dispidEvent]   -- dispid of the event to fire.
//              [dispidProp]    -- dispid of prop containing event func.
//              [pvb]           -- Boolean return value
//              [pbTypes]       -- Pointer to array giving the types of parms
//              [...]           -- Parameters
//
//  Returns:    S_OK if successful
//
//-----------------------------------------------------------------------------

HRESULT
CElement::BubbleEventHelper(
    CTreeNode * pNodeContext,
    long        lSubDivision,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    BOOL        fRaisedByPeer,
    BOOL      * pfRet)
{
    CPeerHolder *   pPeerHolder = GetPeerHolder();
    HRESULT         hr = S_OK;
    BOOL            fReleasepNode       = FALSE;
    BOOL            fReleasepNodeFrom   = FALSE;
    BOOL            fReleasepNodeTo     = FALSE;

    // don't fire standard events if there is a behavior attached that wants to fire them instead
    if (pPeerHolder && !fRaisedByPeer &&
        IsStandardDispid(dispidProp) &&
        pPeerHolder->CanElementFireStandardEventMulti(dispidProp))
        return S_OK;

    CPeerHolder::CLock lock(pPeerHolder);

    CDoc * pDoc = Doc();

    Assert(pNodeContext && (pNodeContext->Element() == this || HasCapture()));
    Assert(pDoc->_pparam);

    if (!pNodeContext)
        return S_OK;

    CTreeNode *     pNode = pNodeContext;
    CElement *      pElementReal;
    CElement *      pElementLayout = NULL;
    unsigned int    cInvalOld = pDoc->_cInval;
    long            cSub = 0;
    BOOL            fAllowBubbleToMaster = AllowBubbleToMaster(dispidEvent);

    // By default do not cancel events
    pDoc->_pparam->fCancelBubble = FALSE;

    //
    // If there are any subdivisions, let the subdivisions handle the
    // event.
    //

    if (OK(GetSubDivisionCount(&cSub)) && cSub)
    {
        IGNORE_HR(DoSubDivisionEvents(
                lSubDivision,
                dispidEvent,
                dispidProp,
                pfRet));
    }

    // if the srcElement is the rootsite, return the HTML element
    Assert(pDoc->_pparam->_pNode);

    if (    (pDoc->_pparam->_pNode->Element()->IsRoot())
        &&  !(fAllowBubbleToMaster && pDoc->_pparam->_pNode->Element()->HasMasterPtr())
        &&  !pDoc->HasCapture(this))
    {
        CElement * pElemHead;

        pElemHead = pDoc->_pparam->_pNode->Element()->GetMarkup()->GetHtmlElement();
        pDoc->_pparam->SetNodeAndCalcCoordinates(
                    pElemHead ? pElemHead->GetFirstBranch() : NULL);
    }

    CDoc::CLock Lock(pDoc);

    // if Bubbling cancelled by a sink. Don't bubble anymore
    while (pNode && !pDoc->_pparam->fCancelBubble)
    {
        BOOL fListenerPresent = FALSE;

        // if we're disabled 
        // then pass the event to the parent
        //
        pElementLayout = pNode->GetUpdatedNearestLayoutElement();
        if (pElementLayout && pElementLayout->GetAAdisabled() && ! pDoc->HasContainerCapture( pNode) )
        {
            pNode = pNode->GetUpdatedNearestLayoutNode()->Parent();
            continue;
        }

        pElementReal = pNode->Element();
        CBase * pBase = pElementReal;

        TransformToThisMarkup(&pDoc->_pparam->_pNodeFrom, pNode->GetMarkup(), &pDoc->_pparam->_lSubDivisionFrom);
        TransformToThisMarkup(&pDoc->_pparam->_pNodeTo, pNode->GetMarkup(), &pDoc->_pparam->_lSubDivisionTo);

        // If this is the root element in the tree, then the
        // event is to be fired by the CDoc containing the
        // rootsite, rather than the rootsite itself.
        // we do this so that the top of the bubble goes to the doc
        if (pElementReal->IsRoot())
        {
            CMarkup * pMarkup = pElementReal->GetMarkup();

            fListenerPresent = TRUE;
            if (pMarkup->HasDocument())
            {
                BOOL fBubbleToDoc = TRUE;
                if (pElementReal->HasMasterPtr())
                {
                    CElement *pElemMaster = pElementReal->GetMasterPtr();
                    if (pElemMaster->Tag() == ETAG_INPUT)
                        fBubbleToDoc = FALSE;
                }

                if (fBubbleToDoc)
                    pBase = pMarkup->Document();
            }
        }

        // this is an element in the tree. Check to see if there
        // are any possible listeners for this event. if so, continue
        // if not, don't call FireEvent and let the event continue 
        // in its bubbling.
        fListenerPresent = fListenerPresent || pElementReal->ShouldFireEvents();

        hr = THR( pNode->NodeAddRef() );
        if( hr )
            goto Cleanup;
        fReleasepNode = TRUE;

        if (pDoc->_pparam->_pNodeFrom)
        {
            hr = THR( pDoc->_pparam->_pNodeFrom->NodeAddRef() );
            if( hr )
                goto Cleanup;
            fReleasepNodeFrom = TRUE;
        }
        if (pDoc->_pparam->_pNodeTo)
        {
            hr = THR( pDoc->_pparam->_pNodeTo->NodeAddRef() );
            if( hr )
                goto Cleanup;
            fReleasepNodeTo = TRUE;
        }

        if (fListenerPresent && pBase)
        {
            IGNORE_HR(pBase->FireEvent(pDoc, this, NULL, dispidEvent, dispidProp, NULL, pfRet, TRUE));
        }

        CheckAndReleaseNode(&pDoc->_pparam->_pNodeFrom);
        CheckAndReleaseNode(&pDoc->_pparam->_pNodeTo);
        fReleasepNodeFrom = fReleasepNodeTo = FALSE;

        // If the node is no longer valid we're done.  Script in the event handler caused
        // the tree to change.
        if (!pNode->IsDead())
        {
            if (pNode->HasPrimaryTearoff())
                pNode->NodeRelease();
            fReleasepNode = FALSE;

            if (ETAG_MAP == pNode->Tag())
            {
                //
                // If we're the map, break out right now, since the associated
                // IMG has already fired its events.
                //
                break;
            }

            if (    fAllowBubbleToMaster
                &&  pElementReal->IsRoot()
                &&  pElementReal->HasMasterPtr())
            {
                CElement * pElemMaster = pElementReal->GetMasterPtr();

                if (    pElemMaster->IsInMarkup()
                    &&  pElemMaster->TagType() == ETAG_GENERIC
                   )
                {
                    pNode = pElemMaster->GetFirstBranch();
                    pDoc->_pparam->SetNodeAndCalcCoordinates(pNode, TRUE);
                }
                else
                {
                    pNode = NULL;
                }
            }
            else
            {
                pNode = pNode->Parent();
                if(!pNode)
                {
                    pNode = pElementReal->GetFirstBranch();
                    if(pNode)
                    {
                        pNode = pNode->Parent();
                    }
                }
            }
        }
        else
        {
            if (pNode->HasPrimaryTearoff())
                pNode->NodeRelease();
            fReleasepNode = FALSE;
            pNode = NULL;
        }
    }

    // if we're still bubbling, we need to go all the way up to the window also.
    // Currently the only event that does this, is onhelp so this test is here to
    // minimize the work
    if (!pDoc->_pparam->fCancelBubble &&
        IsInMarkup() &&
        GetMarkup()->HasWindow() &&
        dispidEvent == DISPID_EVMETH_ONHELP)
    {
        CBase      *pBase = GetOmWindow();

        IGNORE_HR(pBase->FireEvent(pDoc, this, NULL, dispidEvent, dispidProp, NULL, pfRet, TRUE));
    }

    // set a flag in doc, if the script caused an invalidation
    if (cInvalOld != pDoc->_cInval)
        pDoc->_fInvalInScript = TRUE;

Cleanup:
    Assert( ( !fReleasepNode && !fReleasepNodeFrom && !fReleasepNodeTo ) || hr );
    if( hr )
    {
        // These only should have been left on if there was an error.
        if( fReleasepNode )
        {
            pNode->NodeRelease();
        }
        if( fReleasepNodeFrom )
        {
            pDoc->_pparam->_pNodeFrom->NodeRelease();
        }
        if( fReleasepNodeTo )
        {
            pDoc->_pparam->_pNodeTo->NodeRelease();
        }
    }
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   DoSubDivisionEvents
//
//  Synopsis:   Fire the specified event on the given subdivision.
//
//  Arguments:  [dispidEvent]   -- dispid of the event to fire.
//              [dispidProp]    -- dispid of prop containing event func.
//              [pvb]           -- Boolean return value
//              [pbTypes]       -- Pointer to array giving the types of parms
//              [...]           -- Parameters
//
//-----------------------------------------------------------------------------

HRESULT
CElement::DoSubDivisionEvents(
    long        lSubDivision,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    BOOL      * pfRet)
{
    return S_OK;
}


BOOL AllowCancelKeydown(CMessage * pMessage)
{
    Assert(pMessage->message == WM_SYSKEYDOWN || pMessage->message == WM_KEYDOWN);

    WPARAM wParam = pMessage->wParam;
    DWORD  dwKeyState = pMessage->dwKeyState;
    int i;

    struct KEY
    { 
        WPARAM  wParam;
        DWORD   dwKeyState;
    };

    static KEY s_aryVK[] =
    {
        VK_F1,      0,
        VK_F2,      0,
        VK_F3,      0,
        VK_F4,      0,
        VK_F5,      0,
        VK_F7,      0,
        VK_F8,      0,
        VK_F9,      0,
        VK_F10,     0,
        VK_F11,     0,
        VK_F12,     0,
        VK_SHIFT,   MK_SHIFT,
        VK_F4,      MK_CONTROL,
        70,         MK_CONTROL, // ctrl-f
        79,         MK_CONTROL, // ctrl-o
        80,         MK_CONTROL, // ctrl-p
    };

    if (dwKeyState == MK_ALT && wParam != VK_LEFT && wParam != VK_RIGHT)
        return FALSE;

    for (i = 0; i < ARRAY_SIZE(s_aryVK); i++)
    {
        if (    s_aryVK[i].wParam == wParam
            &&  s_aryVK[i].dwKeyState == dwKeyState)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     FireEventOnMessage
//
//  Synopsis:   fires event corresponding to message
//
//  Arguments:  [pMessage]   -- message
//
//  Returns:    return value satisfies same rules as HandleMessage:
//              S_OK       don't do anything - event was cancelled;
//              S_FALSE    keep processing the message - event was not cancelled
//              other      error
//
//----------------------------------------------------------------------------

MtDefine(CStackAryMouseEnter_pv, Locals, "CStackAryMouseEnter::_pv")
DECLARE_CPtrAry(    CStackAryMouseEnter,
                    CElement *,
                    Mt(Mem),
                    Mt(CStackAryMouseEnter_pv))

HRESULT
CElement::FireStdEventOnMessage(CTreeNode * pNodeContext,
                                CMessage * pMessage,
                                CTreeNode * pNodeBeginBubbleWith /* = NULL */,
                                CTreeNode * pNodeEvent , /* = NULL */
                                EVENTINFO* pEvtInfo /* = NULL */ )
{
    Assert(pNodeContext && pNodeContext->Element() == this);

    if (pMessage->fEventsFired)
        return S_FALSE;

    HRESULT     hr = S_FALSE;
    HRESULT     hr2;
    POINT       ptEvent = pMessage->pt;
    CDoc *      pDoc = Doc();
    CTreeNode * pNodeThisCanFire = pNodeContext;
    CLayoutContext *pOldMsgContext;
    CTreeNode::CLock lock;

    hr2 = THR( lock.Init(pNodeThisCanFire) );
    if( hr2 )
    {
        hr = hr2;
        goto Cleanup;
    }

    // TODO (alexz) (anandra) need this done in a generic way for all events.
    // about to fire an event; if there are deferred scripts, commit them now.
    pDoc->CommitDeferredScripts(TRUE, GetMarkup()); // TRUE - early, so don't commit downloaded deferred scripts

    //
    // Keyboard events are fired only once before the message is
    // dispatched.
    //

    switch (pMessage->message)
    {
    case WM_HELP:
        hr = pNodeThisCanFire->Element()->Fire_onhelp(
                pNodeThisCanFire, pMessage ? pMessage->lSubDivision : 0) ? S_FALSE : S_OK;
        break;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        hr = pNodeThisCanFire->Element()->FireStdEvent_KeyHelper(
                                                        pNodeThisCanFire, 
                                                        pMessage, 
                                                        (int*)&pMessage->wParam,
                                                        pEvtInfo )
                                                            ? S_FALSE : S_OK;

        if (    hr == S_OK
            &&  (   (pDoc->_dwCompat & URLCOMPAT_KEYDOWN)
                 || (!(HasMarkupPtr() && GetMarkup()->IsMarkupTrusted()) 
                    && !AllowCancelKeydown(pMessage))))
        {
            hr = S_FALSE;
        }

        break;

    case WM_SYSKEYUP:
    case WM_KEYUP:
        pNodeThisCanFire->Element()->FireStdEvent_KeyHelper(
                                                    pNodeThisCanFire, 
                                                    pMessage, 
                                                    (int*)&pMessage->wParam,
                                                    pEvtInfo );
        break;

    case WM_CHAR:
        hr = pNodeThisCanFire->Element()->FireStdEvent_KeyHelper(
                    pNodeThisCanFire, 
                    pMessage, 
                    (int*)&pMessage->wParam,
                    pEvtInfo )
                        ? S_FALSE : S_OK;
        break;

    case WM_LBUTTONDBLCLK:
        pDoc->_fGotDblClk = TRUE;
        goto Cleanup;       // To not set the event fired bit.

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    {
        FireStdEvent_MouseHelper(
            pNodeContext,
            pMessage,
            VBButtonState((short)pMessage->wParam),
            VBShiftState(),
            ptEvent.x, ptEvent.y,
            pNodeContext,
            pNodeContext,
            pNodeBeginBubbleWith,
            pNodeEvent,
            pEvtInfo );
        break;
    }

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        {
            short      sParam;


            // pMessage->wParam represents the button state
            // not button transition, on up, nothing is down.
            if (pMessage->message == WM_LBUTTONUP)
                sParam = VB_LBUTTON;
            else if (pMessage->message == WM_RBUTTONUP)
                sParam = VB_RBUTTON;
            else if (pMessage->message == WM_MBUTTONUP)
                sParam = VB_MBUTTON;
            else
                sParam = 0;

            Assert( pNodeThisCanFire );
            
            pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                                pNodeThisCanFire,
                                pMessage,
                                sParam,
                                VBShiftState(),
                                ptEvent.x, ptEvent.y,
                                NULL,
                                NULL,
                                pNodeBeginBubbleWith,
                                pNodeEvent,
                                pEvtInfo );
        }
        break;

    case WM_MOUSELEAVE:   // fired for MouseOut event
        if (!HasCapture() && IsAncestorMaster(this, pDoc->_pNodeLastMouseOver))
            break;
        pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                            pNodeThisCanFire,
                            pMessage,
                            VBButtonState((short)pMessage->wParam),
                            VBShiftState(),
                            ptEvent.x,
                            ptEvent.y,
                            pNodeContext,
                            pDoc->_pNodeLastMouseOver,
                            pNodeBeginBubbleWith,
                            pNodeEvent,
                            pEvtInfo );

        // fire Mouseleave event
        if (pNodeContext == pDoc->_pNodeLastMouseOver || pEvtInfo->_fDontFireEvent)
            break;
        {
            CTreeNode *pNode;
            CElement  *pElement;

            for ( pNode = pNodeContext; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 0;
            }

            for ( pNode = pDoc->_pNodeLastMouseOver; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 1;
            }

            pOldMsgContext = pMessage->pLayoutContext;
            pMessage->pLayoutContext = GUL_USEFIRSTLAYOUT;

            for (   pNode = pNodeContext;
                    pNode && pNode->IsInMarkup();
                    pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                if (pElement->_fFirstCommonAncestor)
                    break;
                if (ETAG_ROOT == pElement->Tag())
                    continue;
                {
                    EVENTINFO evtInfo;
                    pElement->FireEventMouseEnterLeave(
                                        pNode,
                                        pMessage,
                                        VBButtonState((short)pMessage->wParam),
                                        VBShiftState(),
                                        ptEvent.x,
                                        ptEvent.y,
                                        pNodeContext,
                                        pDoc->_pNodeLastMouseOver,
                                        pNodeBeginBubbleWith,
                                        pNodeEvent,
                                        &evtInfo );
                }

                // If we reached a master starting from a slave node, fire onmouseout
                // on master
                if (pElement->HasSlavePtr() && pElement != pNodeContext->Element())
                {
                    EVENTINFO evtInfo;

                    pNode->Element()->FireStdEvent_MouseHelper(
                                        pNode,
                                        pMessage,
                                        VBButtonState((short)pMessage->wParam),
                                        VBShiftState(),
                                        ptEvent.x,
                                        ptEvent.y,
                                        pNodeContext,
                                        pDoc->_pNodeLastMouseOver,
                                        pNode,
                                        pNode,
                                        &evtInfo );
                }
            }
            pMessage->pLayoutContext = pOldMsgContext;
        }
        break;

    case WM_MOUSEOVER:    // essentially an Enter event
        if (!HasCapture() && IsAncestorMaster(this, pDoc->_pNodeLastMouseOver))
            break;
        pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                            pNodeThisCanFire,
                            pMessage,
                            VBButtonState((short)pMessage->wParam),
                            VBShiftState(),
                            ptEvent.x,
                            ptEvent.y,
                            pDoc->_pNodeLastMouseOver,
                            pNodeContext,
                            pNodeBeginBubbleWith,
                            pNodeEvent,
                            pEvtInfo );

        // fire Mouseenter event
        if (pNodeContext == pDoc->_pNodeLastMouseOver || pEvtInfo->_fDontFireEvent)
            break;
        {
            CTreeNode *pNode;
            CElement  *pElement;
            CStackAryMouseEnter aryStackMouseEnter;
            int        cMouseEnter = 0;
            int        i;

            for ( pNode = pNodeContext; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 0;
            }

            for ( pNode = pDoc->_pNodeLastMouseOver; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                pElement->_fFirstCommonAncestor = 1;
            }

            for ( pNode = pNodeContext; pNode; pNode = ParentOrMaster(pNode) )
            {
                pElement = pNode->Element();

                if (pElement->_fFirstCommonAncestor)
                    break;
                if (ETAG_ROOT == pElement->Tag())
                    continue;
                pElement->AddRef();
                aryStackMouseEnter.Append(pElement);
                cMouseEnter++;
            }

            pOldMsgContext = pMessage->pLayoutContext;
            pMessage->pLayoutContext = GUL_USEFIRSTLAYOUT;

            for (i = cMouseEnter - 1; i >= 0; i--)
            {
                EVENTINFO  evtInfo;

                pElement = aryStackMouseEnter[i];
                pNode    = pElement->GetFirstBranch();

                if (!pElement->IsInViewTree())
                {
                    pElement->Release();
                    continue;
                }

                pElement->FireEventMouseEnterLeave(
                                    pNode,
                                    pMessage,
                                    VBButtonState((short)pMessage->wParam),
                                    VBShiftState(),
                                    ptEvent.x,
                                    ptEvent.y,
                                    pDoc->_pNodeLastMouseOver,
                                    pNodeContext,
                                    pNodeBeginBubbleWith,
                                    pNodeEvent,
                                    &evtInfo);
                // If we reached a master starting from a slave node, fire onmouseover
                // on master

                if (pElement->HasSlavePtr() && pElement != pNodeContext->Element() && pElement->IsInViewTree())
                {
                    EVENTINFO  evtInfo;
    
                    pElement->FireStdEvent_MouseHelper(
                                        pNode,
                                        pMessage,
                                        VBButtonState((short)pMessage->wParam),
                                        VBShiftState(),
                                        ptEvent.x,
                                        ptEvent.y,
                                        pDoc->_pNodeLastMouseOver,
                                        pNode,
                                        pNode,
                                        pNode,
                                        &evtInfo );
                }

                pElement->Release();
            }

            pMessage->pLayoutContext = pOldMsgContext;
        }
        break;

    case WM_MOUSEWHEEL:
    case WM_MOUSEMOVE:
        // now fire the mousemove event
        hr = (pNodeThisCanFire->Element()->FireStdEvent_MouseHelper(
                            pNodeThisCanFire,
                            pMessage,
                            VBButtonState((short)pMessage->wParam),
                            VBShiftState(),
                            ptEvent.x,
                            ptEvent.y,
                            pDoc->_pNodeLastMouseOver,
                            pNodeContext,
                            pNodeBeginBubbleWith,
                            pNodeEvent,
                            pEvtInfo ))
                               ? S_FALSE : S_OK;
        break;

    case WM_CONTEXTMENU:
        {
            pEvtInfo->_fContextMenuFromMouse = MAKEPOINTS(pMessage->lParam).x != -1 || MAKEPOINTS(pMessage->lParam).y != -1;

            hr = pNodeThisCanFire->Element()->FireEvent(&s_propdescCElementoncontextmenu, TRUE, NULL, -1, pEvtInfo);
        }
        break;

    default:
        goto Cleanup;  // don't set fStdEventsFired
    }

    pMessage->fEventsFired = TRUE;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     CElement::FireStdEvent_KeyHelper
//
//  Synopsis:   Fire a key event.
//
//  Returns:    TRUE: Take default action, FALSE: Don't take default action
//
//-----------------------------------------------------------------------------

BOOL
CElement::FireStdEvent_KeyHelper(CTreeNode * pNodeContext, 
                                    CMessage *pMessage, 
                                    int *piKeyCode,
                                    EVENTINFO* pEvtInfo /*= NULL */)
{
    BOOL            fRet = TRUE;
    CDoc *          pDoc = Doc();
    const PROPERTYDESC_BASIC* pDesc;
    
    Assert(pNodeContext && pNodeContext->Element() == this);

    if (pDoc)
    {
        EVENTPARAM          param(pDoc, this, NULL, TRUE);

        pDoc->InitEventParamForKeyEvent(
                                & param, 
                                pNodeContext, 
                                pMessage, 
                                piKeyCode,
                                & pDesc );                                

        if ( pEvtInfo )
        {
            pEvtInfo->_dispId = (DISPID)(pDesc->c);
            //
            // Deleted from destructor of EventObject.
            //
            pEvtInfo->_pParam = new EVENTPARAM( & param );

            if( pEvtInfo->_fDontFireEvent )
                goto Cleanup;
        }

        fRet = !!FireEvent(
                    pDesc,
                    FALSE,
                    pNodeContext,
                    pMessage->lSubDivision);

        *piKeyCode = (int)param._lKeyCode;
        if (pEvtInfo && pEvtInfo->_pParam)
        {
            pEvtInfo->_pParam->_lKeyCode = (int)param._lKeyCode;
        }
    }
Cleanup:
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::FireEventMouseEnterLeave
//
//  Synopsis:   Fire mouse enter and mouse leave events.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

BOOL
CElement::FireEventMouseEnterLeave(
    CTreeNode * pNodeContext,
    CMessage *  pMessage,
    short       button,
    short       shift,
    long        x,
    long        y,
    CTreeNode * pNodeFrom,                   // = NULL
    CTreeNode * pNodeTo,                     // = NULL
    CTreeNode * pNodeBeginBubbleWith,        // = NULL
    CTreeNode * pNodeEvent,                  // = NULL
    EVENTINFO * pEvtInfo)
{
    BOOL            fRet = TRUE;
    CDoc          * pDoc = Doc();
    CMarkup       * pMarkupContext;
    CTreeNode     * pNodeSrcElement = pNodeEvent ? pNodeEvent : pNodeContext;
    HRESULT         hr = S_OK;
    EVENTPARAM      param(pDoc, this, NULL, FALSE);
    POINT           pt;
    const PROPERTYDESC_BASIC *pDesc;

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!pNodeBeginBubbleWith)
        pNodeBeginBubbleWith = pNodeContext;

    if (!pDoc)
        goto Cleanup;

    pt.x = x;
    pt.y = y;

    param.SetClientOrigin(this, &pt);

    param._pLayoutContext = pMessage->pLayoutContext;

    param.SetNodeAndCalcCoordinates(pNodeSrcElement);

    if (pDoc->_pInPlace)
        ClientToScreen(pDoc->_pInPlace->_hwnd, &pt);

    param._screenX = pt.x;
    param._screenY = pt.y;

    param._sKeyState = shift;

    param._fShiftLeft   = !!(GetKeyState(VK_LSHIFT) & 0x8000);
    param._fCtrlLeft    = !!(GetKeyState(VK_LCONTROL) & 0x8000);
    param._fAltLeft     = !!(GetKeyState(VK_LMENU) & 0x8000);

    param._lButton      = button;
    param._lSubDivisionSrc  = pMessage->lSubDivision;

    param._pNodeFrom    = pNodeFrom;
    param._pNodeTo      = pNodeTo;
    pMarkupContext = pNodeContext->GetMarkup();
    TransformToThisMarkup(&param._pNodeFrom, pMarkupContext, &param._lSubDivisionFrom);
    TransformToThisMarkup(&param._pNodeTo, pMarkupContext, &param._lSubDivisionTo);

    if (pMessage->message==WM_MOUSEOVER)
    {
        pDesc = &s_propdescCElementonmouseenter;
    }
    else
    {
        Assert(pMessage->message==WM_MOUSELEAVE);
        pDesc = &s_propdescCElementonmouseleave;
    }

    param.SetType(pDesc->a.pstrName + 2 );

    if ( pEvtInfo )
    {
        pEvtInfo->_dispId = (DISPID)(pDesc->c);
        //
        // Deleted from destructor of EventObject.
        //
        pEvtInfo->_pParam = new EVENTPARAM( & param );

        if( pEvtInfo->_fDontFireEvent )
            goto Cleanup;
    }

#if DBG == 1
    if (IsTagEnabled(tagOM_DontFireMouseEvents))
        goto Cleanup;
#endif

    hr = THR(pNodeBeginBubbleWith->Element()->FireEvent(
            pDesc,
            FALSE,
            pNodeBeginBubbleWith,
            pMessage->lSubDivision));

    fRet = !!hr;

Cleanup:
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::FireStdEvent_MouseHelper
//
//  Synopsis:   Fire any mouse event.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

BOOL
CElement::FireStdEvent_MouseHelper(
    CTreeNode * pNodeContext,
    CMessage *  pMessage,
    short       button,
    short       shift,
    long        x,
    long        y,
    CTreeNode * pNodeFrom,                   /* = NULL */
    CTreeNode * pNodeTo,                     /* = NULL */
    CTreeNode * pNodeBeginBubbleWith,        /* = NULL */
    CTreeNode * pNodeEvent,                   /* = NULL */
    EVENTINFO * pEvtInfo )
{
    BOOL    fRet = TRUE;
    CDoc *  pDoc = Doc();
    CTreeNode * pNodeSrcElement = pNodeEvent ? pNodeEvent : pNodeContext;

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!pNodeBeginBubbleWith)
        pNodeBeginBubbleWith = pNodeContext;

    if (pDoc)
    {
        HRESULT         hr = S_OK;
        EVENTPARAM      param(pDoc, this, NULL, FALSE);
        POINT           pt;
        BOOL            fOverOut = FALSE;
        BOOL            fCancelable = FALSE;
        BOOL            fHasMouseOverCancelled = FALSE;
        const PROPERTYDESC_BASIC *pDesc;

        pt.x = x;
        pt.y = y;

        param.SetClientOrigin(this, &pt);

        param._htc = pMessage->htc;
        param._lBehaviorCookie = pMessage->lBehaviorCookie;
        param._lBehaviorPartID = pMessage->lBehaviorPartID;

        param._pLayoutContext = pMessage->pLayoutContext;
        
        param.SetNodeAndCalcCoordinates(pNodeSrcElement);

        if (pDoc->_pInPlace)
            ClientToScreen(pDoc->_pInPlace->_hwnd, &pt);

        param._screenX = pt.x;
        param._screenY = pt.y;

        param._sKeyState = shift;
        
        param._fShiftLeft = !!(GetKeyState(VK_LSHIFT) & 0x8000);
        param._fCtrlLeft = !!(GetKeyState(VK_LCONTROL) & 0x8000);
        param._fAltLeft = !!(GetKeyState(VK_LMENU) & 0x8000);

        param._lButton = button;
        param._lSubDivisionSrc = pMessage->lSubDivision;

        switch(pMessage->message)
        {
            // these have a different parameter lists. i.e. none,
            //  and, they initialize two more members of EVENTPARAM
        case WM_MOUSEOVER:    
            fOverOut = TRUE;
            fHasMouseOverCancelled = TRUE;
            pDesc = &s_propdescCElementonmouseover;
            param._pNodeFrom   = pNodeFrom;
            param._pNodeTo     = pNodeTo;
            break;

        case WM_MOUSELEAVE: 
            fOverOut = TRUE;
            pDesc = &s_propdescCElementonmouseout;
            param._pNodeFrom   = pNodeFrom;
            param._pNodeTo     = pNodeTo;
            break;

        case WM_MOUSEMOVE:
            fCancelable = TRUE;
            pDesc = &s_propdescCElementonmousemove;
            break;

        case WM_MOUSEWHEEL:
            fCancelable = TRUE;
            param._wheelDelta = GET_WHEEL_DELTA_WPARAM(pMessage->wParam);
            pDesc = &s_propdescCElementonmousewheel;
            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
            pDesc = &s_propdescCElementonmouseup;
            break;

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            pDesc = &s_propdescCElementonmousedown;
            break;

        default:
            Assert(0 && "Unknown mouse event!");
            goto Cleanup;
        }

        param.SetType(pDesc->a.pstrName + 2 );

        if ( pEvtInfo )
        {
            pEvtInfo->_dispId = (DISPID)(pDesc->c);
            //
            // Deleted from destructor of EventObject.
            //            
            pEvtInfo->_pParam = new EVENTPARAM( & param );

            if( pEvtInfo->_fDontFireEvent )
                goto Cleanup;            
        }

#if DBG == 1
        if (!IsTagEnabled(tagOM_DontFireMouseEvents))
        {
#endif

            hr = THR(pNodeBeginBubbleWith->Element()->FireEvent(
                    pDesc,
                    FALSE,
                    pNodeBeginBubbleWith,
                    pMessage->lSubDivision));

            // Don't propagate ret value to caller(s) for onmouseover. Action that
            // needs to be done if it is cancelled is taken here itself.
            if (fCancelable)
            {
                Assert(OK(hr));
                fRet = !!hr;
            }
#if DBG == 1
        }
#endif

        // if the return value is true, then for anchors and areas we
        //  need to set the flag to prevent the status text from being
        //  set.
        if (fOverOut && (!fHasMouseOverCancelled || !!hr))
        {
            if ((Tag() == ETAG_A) || (Tag() == ETAG_AREA))
                DYNCAST(CHyperlink, this)->_fHasMouseOverCancelled = fHasMouseOverCancelled;
            else
            {
                // if we are within the scope of an anchor....
                CTreeNode * pAnchor = GetFirstBranch()->Ancestor(ETAG_A);
                if (pAnchor)
                    DYNCAST(CHyperlink, pAnchor->Element())->_fHasMouseOverCancelled = fHasMouseOverCancelled;
            }
        }
    }

Cleanup:
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  member  :   click()   IHTMLElement method
//
//-----------------------------------------------------------------------------

HRESULT BUGCALL
CElement::click(CTreeNode *pNodeContext)
{
    HRESULT hr = DoClick(NULL, pNodeContext, FALSE, NULL, TRUE );
    if(hr == S_FALSE)
        hr = S_OK;
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::DoClick
//
//  Arguments:  pMessage    Message that resulted in the click. NULL when
//                          called by OM method click().
//              if this is called on a disabled site, we still want to
//              fire the event (the event code knows to do the right thing
//              and start above the disabled site). and we still want to
//              call click action... but not on us, on the parent
//
//-------------------------------------------------------------------------

HRESULT
CElement::DoClick(CMessage * pMessage /*=NULL*/, CTreeNode *pNodeContext /*=NULL*/,
                  BOOL fFromLabel , /*=FALSE*/
                  EVENTINFO *pEvtInfo /*=NULL*/,
                  BOOL fFromClick /*=FALSE*/)
{
    HRESULT hr = S_OK;

    if(!pNodeContext)
        pNodeContext = GetFirstBranch();

    if(!pNodeContext)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!TestLock(ELEMENTLOCK_CLICK))
    {
        CLock              Lock(this, ELEMENTLOCK_CLICK);
        CTreeNode::CLock   NodeLock;

        hr = THR( NodeLock.Init(pNodeContext) );
        if( hr )
            goto Cleanup;
        
        if (Fire_onclick(pNodeContext, pMessage ? pMessage->lSubDivision : 0, pEvtInfo ))
        {
            // Bubble clickaction up the parent chain,
            CTreeNode * pNode = pNodeContext;
            while (pNode)
            {
                if (!(pNode->ShouldHaveLayout() && pNode->Element()->GetAAdisabled()))
                {
                    //
                    // if the node is editable - we want to not call click action - and not continue
                    // to bubble the event
                    
                    if ( pNode->Element()->IsEditable(/*fCheckContainerOnly*/FALSE) )
                    {
                        BOOL fSkipEdit = TRUE;

                        //
                        // Handle InputFile weirdness. Half of control is editable
                        // other half ( the button ) is not
                        // 
                        if( pNode->Element()->Tag() == ETAG_INPUT )
                        {
                            CInput * pInput = DYNCAST(CInput, pNode->Element());

                            // We only want the htmlInputFile version of CInput
                            if (pInput->GetType() == htmlInputFile)
                            {
                                CElement* pParent = pNode->Parent() && 
                                                    pNode->Parent()->Element() ? 
                                                        pNode->Parent()->Element()
                                                        : NULL ;
                                
                                // We are really in edit mode, if the button does not have focus
                                // or our parent is editable
                                // 
                                fSkipEdit = ( fFromClick ? FALSE : !pInput->_fButtonHasFocus ) || 
                                            ( pParent && pParent->IsEditable(/*fCheckContainerOnly*/FALSE) ) ;
                            }         
                        }  
                        
                        if ( fSkipEdit )
                        {
                            hr = S_FALSE;
                            break;
                        }
                    }
                    
                    
                    // we're not a disabled site
                    hr = THR(pNode->Element()->ClickAction(pMessage));
                    if (hr != S_FALSE)
                        break;
                }

                // We need to break if we are called because
                // a label was clicked in case the element is a child
                // of the label. (BUG 19132 - krisma)
                if (ETAG_MAP == pNode->Tag() || fFromLabel == TRUE)
                {
                    //
                    // If we're the map, break out right now, since the associated
                    // IMG has already fired its events.
                    //

                    break;
                }

                if (pNode->Element()->HasMasterPtr())
                {
                    pNode = pNode->Element()->GetMasterPtr()->GetFirstBranch();
                }
                else if (pNode->Parent())
                {
                    pNode = pNode->Parent();
                }
                else
                {
                    pNode = pNode->Element()->GetFirstBranch();
                    if(pNode)
                        pNode = pNode->Parent();
                }
            }

            // Propagate error codes from ClickAction, but not S_FALSE
            // because that could confuse callers into thinking that the
            // message was not handled.?
            if (S_FALSE == hr)
                hr = S_OK;
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ClickAction
//
//  Arguments:  pMessage    Message that resulted in the click. NULL when
//                          called by OM method click().
//
//  Synopsis:   Returns S_FALSE if this should bubble up to the parent.
//              Returns S_OK otherwise.
//
//-------------------------------------------------------------------------

HRESULT
CElement::ClickAction(CMessage * pMessage)
{
    return S_FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CElement::GetIdentifier
//
//  This fn looks in the current elements' attr array & picks out
// this
//-------------------------------------------------------------------------

LPCTSTR
CElement::GetIdentifier(void)
{
    LPCTSTR             pStr;
    CAttrArray         *pAA;
    
    if ( !IsNamed() )
        return NULL;

    pAA = *GetAttrArray();

    // We're leveraging the fact that we know the dispids of name & ID, & we
    // also have a single _pAA in CElement containing all the attributes
    if (pAA &&
        pAA->HasAnyAttribute() &&
        ((pAA->FindString (STDPROPID_XOBJ_NAME,        &pStr) && pStr) ||
         (pAA->FindString (DISPID_CElement_id,         &pStr) && pStr) ||
          pAA->FindString (DISPID_CElement_uniqueName, &pStr)))
    {
        // This looks dodgy but is safe as long as the return value is treated
        // as a temporary value that is used immediatly, then discarded
        return pStr;
    }
    else
    {
        return NULL;
    }
}


HRESULT
CElement::GetUniqueIdentifier (CStr * pcstr, BOOL fSetWhenCreated /* = FALSE */, BOOL *pfDidCreate /* = NULL */)
{
    HRESULT             hr;
    LPCTSTR             pchUniqueName = GetAAuniqueName();

    if ( pfDidCreate )
        *pfDidCreate = FALSE;

    if (!pchUniqueName)
    {
        CDoc * pDoc = Doc();

        hr = THR(pDoc->GetUniqueIdentifier(pcstr));
        if (hr)
            goto Cleanup;

        if (fSetWhenCreated)
        {
            if ( pfDidCreate )
                *pfDidCreate = TRUE;
            hr = THR(SetUniqueNameHelper(*pcstr));
        }
    }
    else
    {
        hr = THR(pcstr->Set(pchUniqueName));
    }

Cleanup:
    RRETURN(hr);
}

LPCTSTR CElement::GetAAname() const
{
    LPCTSTR     pv;
    CAttrArray *pAA;
    
    if ( !IsNamed() )
        return NULL;

    pAA = *GetAttrArray();

    // We're leveraging the fact that we know the dispids of name & ID, & we
    // also have a single _pAA in CElement containing all the attributes
    if ( pAA && pAA->FindString ( STDPROPID_XOBJ_NAME, &pv) )
    {
        return pv;
    }
    else
    {
        return NULL;
    }
}

BOOL CElement::IsDesignMode ( void )
{
    CMarkup *pMarkup = GetMarkup();
    return pMarkup ? pMarkup->_fDesignMode : GetWindowedMarkupContext()->_fDesignMode;
}

// abstract name property helpers
STDMETHODIMP CElement::put_name(BSTR v)
{
    // If Browse time, setting the name changes the submit name
    if ( IsDesignMode() )
    {
        return s_propdescCElementpropdescname.b.SetStringProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
    }
    else
    {
        return s_propdescCElementsubmitName.b.SetStringProperty(v, this, (CVoid *)(void *)(GetAttrArray()));
    }
}

STDMETHODIMP CElement::get_name(BSTR * p)
{
    // If browse time, get the submit name if set, else get the real name
    if ( IsDesignMode() )
    {
        return s_propdescCElementpropdescname.b.GetStringProperty(p, this, (CVoid *)(void *)(GetAttrArray()));
    }
    else
    {
        RRETURN( SetErrorInfo ( THR( FormsAllocString( GetAAsubmitname(), p ) ) ));
    }
}

LPCTSTR CElement::GetAAsubmitname() const
{
    LPCTSTR             pv;
    CAttrArray         *pAA = *GetAttrArray();

    // We're leveraging the fact that we know the dispids of name & ID, & we
    // also have a single _pAA in CElement containing all the attributes
    if ( pAA )
    {
        if (pAA->FindString ( DISPID_CElement_submitName, &pv) )
        {
            return pv;
        }
        else if (IsNamed() && pAA->FindString ( STDPROPID_XOBJ_NAME, &pv) )
        {
            return pv;
        }
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Member:      GetBgImgCtx()
//
// Synopsis:    Return the image ctx if the element has a background Image
//
//-----------------------------------------------------------------------------

CImgCtx *
CElement::GetBgImgCtx(FORMAT_CONTEXT FCPARAM)
{
    if (g_fHighContrastMode)
        return NULL;        // in high contrast mode there is no background image

    long lCookie = GetFirstBranch()->GetFancyFormat(FCPARAM)->_lImgCtxCookie;

    return lCookie ? Doc()->GetUrlImgCtx(lCookie) : NULL;
}

//+---------------------------------------------------------------------------
//
//  Members : the following get_on* and put_on* members are primarily here
//      in order to delegate the assigments to the window.  They are currently
//      mainly used by body and frameset to remap to the window object (Nav
//      compat & consistency).  You should also see GetBaseObjectFor() to see
//      the other place this assignment happens.
//
//      The other half of the work is in the fire_on* code which detects when we
//      are a body, and redirects.
//
//----------------------------------------------------------------------------

#define IMPLEMENT_PUT_PROP(prop)                    \
    HRESULT hr = S_OK;                              \
    if (    IsInMarkup()                            \
        &&  GetMarkup()->HasWindow())               \
    {                                               \
        hr = THR(GetMarkup()->Window()->put_##prop(v)); \
        if (hr)                                         \
            goto Cleanup;                               \
    }                                               \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_PUT_PROP_EX(prop)                 \
    HRESULT hr;                                     \
    if (    (   Tag()==ETAG_BODY                    \
            ||  Tag()==ETAG_FRAMESET)               \
        &&  IsInMarkup()                            \
        &&  GetMarkup()->HasWindow())               \
    {                                               \
        hr = THR(GetMarkup()->Window()->put_##prop(v)); \
        if (hr)                                     \
            goto Cleanup;                           \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty( \
                    HANDLEPROP_SET | HANDLEPROP_AUTOMATION |    \
                    (PROPTYPE_VARIANT << 16),                   \
                    &v,                                         \
                    this,                                       \
                    CVOID_CAST(GetAttrArray())));               \
    }                                                           \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_PUT_PROP_EX2(prop)                \
    HRESULT hr;                                     \
    if (    IsInMarkup()                            \
        &&  (   (   (   Tag()==ETAG_BODY                    \
                    ||  Tag()==ETAG_FRAMESET)               \
                &&  !GetMarkup()->IsHtmlLayout())   \
            ||  (   Tag() == ETAG_HTML              \
                &&  GetMarkup()->IsHtmlLayout()))   \
        &&  GetMarkup()->HasWindow())               \
    {                                               \
        hr = THR(GetMarkup()->Window()->put_##prop(v)); \
        if (hr)                                     \
            goto Cleanup;                           \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty( \
                    HANDLEPROP_SET | HANDLEPROP_AUTOMATION |    \
                    (PROPTYPE_VARIANT << 16),                   \
                    &v,                                         \
                    this,                                       \
                    CVOID_CAST(GetAttrArray())));               \
    }                                                           \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \


#define IMPLEMENT_GET_PROP(prop)                    \
    HRESULT hr = S_OK;                              \
    if (IsInMarkup())                               \
    {                                               \
        CMarkup *pMarkup = GetMarkup();             \
        if (pMarkup->HasWindow())                   \
        {                                           \
            hr = THR(pMarkup->Window()->get_##prop(v));\
            goto Cleanup;                           \
        }                                           \
    }                                               \
    V_VT(v) = VT_EMPTY;                             \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_GET_PROP_EX(prop)                 \
    HRESULT hr = S_OK;                              \
    if ((Tag() == ETAG_BODY) || Tag() == ETAG_FRAMESET) \
    {                                               \
        if (IsInMarkup())                           \
        {                                           \
            CMarkup *pMarkup = GetMarkup();         \
            if (pMarkup->HasWindow())               \
            {                                       \
                hr = THR(pMarkup->Window()->get_##prop(v));\
                goto Cleanup;                       \
            }                                       \
        }                                           \
        V_VT(v) = VT_EMPTY;                         \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty(     \
                HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),   \
                v,                                                  \
                this,                                               \
                CVOID_CAST(GetAttrArray())));                       \
    }                                               \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

#define IMPLEMENT_GET_PROP_EX2(prop)                \
    HRESULT hr = S_OK;                              \
    if  (   (   Tag() == ETAG_HTML                  \
            &&  IsInMarkup()                        \
            &&  GetMarkup()->IsHtmlLayout())\
        ||  (   (   Tag() == ETAG_BODY              \
                ||  Tag() == ETAG_FRAMESET)         \
            && !(   IsInMarkup()                    \
                &&  GetMarkup()->IsHtmlLayout())))  \
    {                                               \
        if (IsInMarkup())                           \
        {                                           \
            CMarkup *pMarkup = GetMarkup();         \
            if (pMarkup->HasWindow())               \
            {                                       \
                hr = THR(pMarkup->Window()->get_##prop(v));\
                goto Cleanup;                       \
            }                                       \
        }                                           \
        V_VT(v) = VT_EMPTY;                         \
    }                                               \
    else                                            \
    {                                               \
        hr = THR(s_propdescCElement##prop.a.HandleCodeProperty(     \
                HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),   \
                v,                                                  \
                this,                                               \
                CVOID_CAST(GetAttrArray())));                       \
    }                                               \
Cleanup:                                            \
    RRETURN( SetErrorInfo( hr ));                   \

HRESULT
CElement:: put_onload(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onload)
}

HRESULT
CElement:: get_onload(VARIANT *v)
{
    IMPLEMENT_GET_PROP(onload)
}


HRESULT
CElement:: put_onunload(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onunload)
}
HRESULT
CElement:: get_onunload(VARIANT *v)
{
    IMPLEMENT_GET_PROP(onunload)
}


STDMETHODIMP
CElement::put_onbeforeunload(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onbeforeunload)
}

STDMETHODIMP
CElement::get_onbeforeunload(VARIANT * v)
{
    IMPLEMENT_GET_PROP(onbeforeunload)
}

STDMETHODIMP
CElement::get_onhelp(VARIANT * v)
{
    IMPLEMENT_GET_PROP_EX(onhelp)
}

STDMETHODIMP
CElement::put_onhelp(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onhelp)
}


HRESULT
CElement:: put_onblur(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onblur)
}

HRESULT
CElement:: get_onblur(VARIANT *v)
{
    IMPLEMENT_GET_PROP_EX(onblur)
}

HRESULT
CElement:: put_onfocus(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onfocus)
}

HRESULT
CElement:: get_onfocus(VARIANT *v)
{
    IMPLEMENT_GET_PROP_EX(onfocus)
}

// NOTE (greglett): onafterprint/onbeforeprint events are implemented
// on CElement only for the body and frameset elements

STDMETHODIMP
CElement::put_onbeforeprint(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onbeforeprint)
}

STDMETHODIMP
CElement::get_onbeforeprint(VARIANT * v)
{
    IMPLEMENT_GET_PROP(onbeforeprint)
}

STDMETHODIMP
CElement::put_onafterprint(VARIANT v)
{
    IMPLEMENT_PUT_PROP(onafterprint)
}

STDMETHODIMP
CElement::get_onafterprint(VARIANT * v)
{
    IMPLEMENT_GET_PROP(onafterprint)
}


STDMETHODIMP
CElement::put_onscroll(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX2(onscroll)
}


STDMETHODIMP
CElement::get_onscroll(VARIANT * v)
{
    IMPLEMENT_GET_PROP_EX2(onscroll)
}


//+-----------------------------------------------------------------
//
//  member : Fire_onresize
//
//  synopsis : IHTMLTextContainer event implementation
//
//------------------------------------------------------------------

void
CElement::Fire_onresize()
{
    if (    (   Tag() == ETAG_BODY        
            ||  Tag() == ETAG_FRAMESET )    
        &&  IsInMarkup() 
        &&  GetMarkup()->HasWindow())
    {                                    
     
        GetMarkup()->Window()->Fire_onresize();                         
    }
    else
    {
        FireEvent(&s_propdescCElementonresize);
    }
}


//+-----------------------------------------------------------------
//
//  member : Fire_onscroll
//
//  synopsis : IHTMLTextContainer event implementation
//
//------------------------------------------------------------------
void
CElement::Fire_onscroll()
{    
    if (    IsInMarkup() 
        &&  this == GetMarkup()->GetCanvasElement()
        &&  GetMarkup()->HasWindow())
    {
            GetMarkup()->Window()->Fire_onscroll();                     
    }
    else
    {
        FireOnChanged(DISPID_IHTMLELEMENT2_SCROLLTOP);
        FireOnChanged(DISPID_IHTMLELEMENT2_SCROLLLEFT);

        FireEvent(&s_propdescCElementonscroll);
    }
}

STDMETHODIMP
CElement::put_onresize(VARIANT v)
{
    IMPLEMENT_PUT_PROP_EX(onresize)
}


STDMETHODIMP
CElement::get_onresize(VARIANT * v)
{
    IMPLEMENT_GET_PROP_EX(onresize)
}

void CElement::Fire_onfocus(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();
    if (!IsConnectedToPrimaryMarkup() || pDoc->IsPassivated())
        return;

    CDoc::CLock LockForm(pDoc, FORMLOCK_CURRENT);
    CLock LockFocus(this, ELEMENTLOCK_FOCUS);
    FireEvent(&s_propdescCElementonfocus, TRUE, NULL, -1, NULL, dwContext);    
}

void CElement::Fire_onblur(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();
    if (!IsConnectedToPrimaryMarkup() || pDoc->IsPassivated())
        return;

    CDoc::CLock LockForm(pDoc, FORMLOCK_CURRENT);
    CLock LockBlur(this, ELEMENTLOCK_BLUR);
    pDoc->_fModalDialogInOnblur = (BOOL)dwContext;
    FireEvent(&s_propdescCElementonblur);
    pDoc->_fModalDialogInOnblur = FALSE;
}

void CElement::Fire_onfilterchange(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();
    if (!IsInMarkup() || pDoc->IsPassivated())
        return;

    TraceTag((tagFilterChange, "Fire onfilterchange for %ls-%d",
                TagName(), SN()));

    CDoc::CLock LockForm(pDoc, FORMLOCK_CURRENT);
    FireEvent(&s_propdescCElementonfilterchange);
}

BOOL
CElement::Fire_ActivationHelper(long        lSubThis,
                                CElement *  pElemOther,
                                long        lSubOther,
                                BOOL        fPreEvent,
                                BOOL        fDeactivation,
                                BOOL        fFireFocusBlurEvents, 
                                EVENTINFO * pEvtInfo,               /* = NULL */
                                BOOL        fFireActivationEvents   /* = TRUE */)
{
    CElement *  pElement;
    BOOL        fRet        = TRUE;
    CDoc *      pDoc        = Doc();
    CElement *  pElemFire;

    Assert( fPreEvent && pEvtInfo || ! pEvtInfo ); // we only expect an event info for OnBeforeDeactivate
    Assert(!fPreEvent || fFireActivationEvents);
    
    if (    !IsConnectedToPrimaryMarkup()
        ||  pDoc->IsPassivated())
    {
        return fRet;
    }

    if (fDeactivation && pDoc->_fForceCurrentElem)
    {
        // Don't post blur event if shutting down
        fFireFocusBlurEvents = FALSE;
    }
    else if (!fFireFocusBlurEvents && pDoc->HasFocus())
    {
        // always fire focus/blur events if Doc has focus
        fFireFocusBlurEvents = TRUE;
    }

    pElement = this;
    for(;;)
    {
        pElement->_fFirstCommonAncestor = 0;
        
        pElement = pElement->GetMarkup()->Root();
        if (!pElement->HasMasterPtr())
            break;
        pElement = pElement->GetMasterPtr();
    }

    if (pElemOther)
    {
        pElement = pElemOther;
        for (;;)
        {
            pElement->_fFirstCommonAncestor = 1;

            if (!pElement->IsInMarkup())
                break;
            pElement = pElement->GetMarkup()->Root();
            if (!pElement->HasMasterPtr())
                break;
            pElement = pElement->GetMasterPtr();
        }
    }

    pElement = this;
    for(;;)
    {
        if (pElement->_fFirstCommonAncestor)
        {
            if (this == pElement && this == pElemOther)
            {
                Assert(lSubThis != lSubOther); // continue to fire the events
            }
            else
                break;
        }
        EVENTPARAM  param(pDoc, pElement, NULL, TRUE);
        CTreeNode * pNodeOtherLoop;
        long lSubOtherLoop = lSubOther;
        
        Assert(!param._pNodeTo);
        Assert(param._lSubDivisionTo == -1);
        Assert(!param._pNodeFrom);
        Assert(param._lSubDivisionFrom == -1);
        param.SetNodeAndCalcCoordinates(pElement->GetFirstBranch());
        if (pElement->IsInMarkup() && pElemOther && pElemOther->IsInMarkup())
        {
            pNodeOtherLoop = pElemOther->GetFirstBranch()->GetNodeInMarkup(pElement->GetMarkup());
        }
        else
        {
            pNodeOtherLoop = NULL;
        }
        if (!pNodeOtherLoop || pNodeOtherLoop->Element() != pElemOther)
        {
            lSubOtherLoop = -1;
        }

        if (fPreEvent)
        {
            if (fDeactivation)
            {
                param.SetType(s_propdescCElementonbeforedeactivate.a.pstrName + 2);
                param._pNodeTo = pNodeOtherLoop;
                param._lSubDivisionTo = lSubOtherLoop;

                if ( pEvtInfo )
                {
                    pEvtInfo->_dispId = (DISPID) s_propdescCElementonbeforedeactivate.c ;
                    //  
                    //  The check-in by marka 2000/07/05 indicates that we only populate
                    //  pEvtInfo for OnBeforeDeactivate. However, this process could have
                    //  been repeated due to nested viewlinking and event routing outside
                    //  viewlink. For now, we only care about the first param._pNodeTo in 
                    //  the viewlink chain.
                    //  
                    //  [zhenbinx]
                    //
                    if (!pEvtInfo->_pParam)
                    {
                        pEvtInfo->_pParam = new EVENTPARAM( & param );                 // Deleted from destructor of EventObject.
                        //
                        // HACKHACK-IEV6-5397-2000/07/26-zhenbinx:
                        //
                        // We need _pNodeTo to be the same as pElemOther! Before we expose
                        // OnBeforeDeactivate to Designers, Trident was routing pElemOther
                        // to Editor, So the Editor was written based on the assumption that
                        // the new element could be in different markup than the source element.
                        // Now we are routing Event Object and both Src/To elements are in 
                        // the same markup! This breaks Editor so here I am hacking to
                        // put the _pNodeTo back to the element that is in a different markup.
                        //
                        //
                        pEvtInfo->_pParam->_pNodeTo = pElemOther->GetFirstBranch();
                    }
                }    
                
                fRet = (S_FALSE == pElement->FireEvent(&s_propdescCElementonbeforedeactivate, FALSE, NULL, lSubThis));
                if (!fRet)
                    break;
            }
            else
            {
                if ( ! pElement->TestLock(CElement::ELEMENTLOCK_BEFOREACTIVATE))
                {
                    param.SetType(s_propdescCElementonbeforeactivate.a.pstrName + 2);
                    param._pNodeFrom = pNodeOtherLoop;
                    param._lSubDivisionFrom = lSubOtherLoop;

                    CLock LockFocus(this, ELEMENTLOCK_BEFOREACTIVATE);
        
                    fRet = (S_FALSE == pElement->FireEvent(&s_propdescCElementonbeforeactivate, FALSE, NULL, lSubThis));
                    if (!fRet)
                        break;
                }                    
            }
        }
        else if (fDeactivation)
        {
            if (fFireActivationEvents)
            {
                param.SetType(s_propdescCElementondeactivate.a.pstrName + 2);
                param._pNodeTo = pNodeOtherLoop;
                param._lSubDivisionTo = lSubOtherLoop;
                pElement->FireEvent(&s_propdescCElementondeactivate, FALSE, NULL, lSubThis);
            }
            if (fFireFocusBlurEvents && !pDoc->_fPopupDoc)
            {
                EVENTPARAM  param2(pDoc, pElement, NULL, TRUE);

                pElemFire = (this == pElement) ? GetFocusBlurFireTarget(lSubThis) : pElement;

                if (pElemFire->Doc() == Doc())
                {
                    // fire onfocusout
                    param2.SetNodeAndCalcCoordinates(pElement->GetFirstBranch());
                    param2.SetType(s_propdescCElementonfocusout.a.pstrName + 2);
                    param2._pNodeTo = pNodeOtherLoop;
                    param2._lSubDivisionTo = lSubOtherLoop;
                    pElemFire->FireEvent(&s_propdescCElementonfocusout, FALSE, NULL, 0);

                    // post onblur
                    Verify(S_OK == GWPostMethodCall(
                                        pElemFire,
                                        ONCALL_METHOD(CElement, Fire_onblur, fire_onblur),
                                        0, TRUE, "CElement::Fire_onblur"));
                }
            }
        }
        else
        {
            if (fFireActivationEvents)
            {
                param.SetType(s_propdescCElementonactivate.a.pstrName + 2);
                param._pNodeFrom = pNodeOtherLoop;
                param._lSubDivisionFrom = lSubOtherLoop;
                pElement->FireEvent(&s_propdescCElementonactivate, FALSE, NULL, lSubThis);
            }
            if (   fFireFocusBlurEvents && !pDoc->_fPopupDoc)
            {
                EVENTPARAM  param2(pDoc, pElement, NULL, TRUE);
                
                pElemFire = (this == pElement) ? GetFocusBlurFireTarget(lSubThis) : pElement;                

                BOOL fDontFireMSAAEvent = (this != pElemFire) && 
                                          ((pElemFire->Tag() == ETAG_IFRAME) || 
                                          (pElemFire->Tag() == ETAG_FRAME) || 
                                          (pElemFire->Tag() == ETAG_GENERIC));
                
                if (pElemFire->Doc() == Doc())
                {
                    // fire onfocusin
                    param2.SetNodeAndCalcCoordinates(pElement->GetFirstBranch());
                    param2.SetType(s_propdescCElementonfocusin.a.pstrName + 2);
                    param2._pNodeFrom = pNodeOtherLoop;
                    param2._lSubDivisionFrom = lSubOtherLoop;
                    pElemFire->FireEvent(&s_propdescCElementonfocusin, FALSE, NULL, 0);

                    // post onfocus
                    Verify(S_OK == GWPostMethodCall(
                                        pElemFire,
                                        ONCALL_METHOD(CElement, Fire_onfocus, fire_onfocus),
                                        fDontFireMSAAEvent, TRUE, "CElement::Fire_onfocus"));
                }
            }
        }
        if (!pElement->IsInMarkup() || pElement->_fExittreePending)
            break;

        pElement = pElement->GetMarkup()->Root();
        if (!pElement->HasMasterPtr())
            break;
        pElement = pElement->GetMasterPtr();
    }

    return fRet;
}

//+----------------------------------------------------
//
//  member : get_offsetTop, IHTMLElement
//
//  synopsis : returns the top, coordinate of the
//      element
//
//-----------------------------------------------------

HRESULT
CElement::get_offsetTop ( long *plValue )
{
    HRESULT         hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if(!IsInMarkup() || !Doc()->GetView()->IsActive())
    {
        *plValue = 0;
    }
    else
    {
        *plValue = 0;
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        switch (_etag)
        {
        case ETAG_MAP :
            break;

        case ETAG_AREA:
            {
                RECT rectBound;
                DYNCAST(CAreaElement, this)->GetBoundingRect(&rectBound);
                *plValue = rectBound.top;
            }
            break;

        default :
            {
                POINT     pt = g_Zero.pt;
                CLayout * pLayout = NULL;                
                CLayoutContext *pContext;
                
                hr = THR(EnsureRecalcNotify());

                if (!hr)
                    hr = THR(GetElementTopLeft(pt));
                else
                    goto Cleanup;
                
                *plValue = pt.y;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);  // Incorrect for paginated element behaviors (greglett)
                pContext  = pLayout
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());
                   pUnitInfo = pdiTemp->GetUnitInfo();
                }
            }
            break;
        }
        *plValue = pUnitInfo->DocPixelsFromDeviceY(*plValue);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+----------------------------------------------------
//
//  member : get_OffsetLeft, IHTMLElement
//
//  synopsis : returns the left coordinate of the
//      element
//
//-----------------------------------------------------

HRESULT
CElement::get_offsetLeft ( long *plValue )
{
    HRESULT       hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if(!IsInMarkup() || !Doc()->GetView()->IsActive())
    {
        *plValue = 0;
    }
    else
    {
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        *plValue = 0;
        switch (_etag)
        {
        case ETAG_MAP :
            break;

        case ETAG_AREA:
            {
                RECT rectBound;
                DYNCAST(CAreaElement, this)->GetBoundingRect(&rectBound);

                *plValue = rectBound.left;
            }
            break;

        default :
            {
                POINT     pt = g_Zero.pt;
                CLayout * pLayout = NULL;
                CLayoutContext *pContext;
                
                hr = THR(EnsureRecalcNotify());
                if (!hr)
                    hr = THR(GetElementTopLeft(pt));
                else
                    goto Cleanup;
                
                *plValue = pt.x;

                //
                // but wait, if we are in a media resolution measurement, the value returned is in 
                // a different metric, so we need to untransform it before returning this to the OM call.
                //
                pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);    // Incorrect for paginated element behaviors (greglett)
                pContext  = pLayout
                                ? (pLayout->LayoutContext()) 
                                        ? pLayout->LayoutContext() 
                                        : pLayout->DefinedLayoutContext() 
                                : NULL;

                if (   pContext 
                    && pContext->GetMedia() != mediaTypeNotSet)
                {
                   const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                            pContext->GetMedia());

                   pUnitInfo = pdiTemp->GetUnitInfo();
                }
            }
            break;
        }
        *plValue = pUnitInfo->DocPixelsFromDeviceX(*plValue);
    }
    
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

// helper function for offset left and top
HRESULT
CElement::GetElementTopLeft(POINT & pt)
{
    HRESULT hr = S_OK;

    pt = g_Zero.pt;

    if (IsInMarkup())
    {
        Assert(GetFirstBranch());

        CLayout *   pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        if (pLayout)
        {
            CDispNode *pDispNode = pLayout->GetElementDispNode();

            //--------------------------------------------------------------------------
            //
            // If you look inside GetPosition, you will see a hack to handle TR's. Instead
            // of duplicating that hack here, we just call GetPosition instead of calling
            // GetApparentBounds on the TR. Since the TR is always horizontal, this hack
            // is actually a good one which is also compat with what it used to do before.
            //
            //--------------------------------------------------------------------------
            if (ETAG_TR == Tag())
            {
                pLayout->GetPosition(&pt);
            }
            else if (pDispNode && ShouldHaveLayout())
            {
                CRect rcBounds;
                BOOL fParentVertical = FALSE;
                CLayout *pParentLayout = NULL;

                if (   GetFirstBranch()
                    && GetFirstBranch()->ZParentBranch()
                   )
                {
                    CElement *pParentElement = GetFirstBranch()->ZParentBranch()->Element();
                    if (   pParentElement
                        && pParentElement->HasVerticalLayoutFlow()
                       )
                    {
                        fParentVertical = TRUE;
                        pParentLayout = pParentElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
                    }
                }
                pDispNode->GetApparentBounds(&rcBounds);
                if (!fParentVertical)
                {
                    pt.x = rcBounds.left;
                    pt.y = rcBounds.top;
                }
                else
                {
                    Assert(pParentLayout);
                    pt.x = pParentLayout->GetContentHeight(FALSE) - rcBounds.bottom;
                    pt.y = rcBounds.left;
                }
                
                // NOTE(SujalP): None of the following transformations being applied
                // to the pt are different in a vertical-layout enabled scenario. That
                // is because the table is *never* vertical. Hence all the transformations
                // between a table and a TD are always the same irrespective of the
                // orientation of the TD.
                
                // if we are a table, then adjust for a caption and table borders.
                //---------------------------------------------------------------
                if (   (Tag() == ETAG_TD)
                    || (Tag() == ETAG_TH))
                {
                    CTableCellLayout *   pCellLayout  = (CTableCellLayout *)pLayout;
                    CTableLayout * pTableLayout = pCellLayout->TableLayout();
                    if (pTableLayout)
                    {
                        CDispNode * pGridNode = pTableLayout->GetTableInnerDispNode();
                        if (     pCellLayout->_pDispNode
                             && (pCellLayout->_pDispNode->GetParentNode() == pGridNode))
                        {
                            // if cell is positioned or lives inside of the positioned row - do nothing.
                            if (pTableLayout->_pDispNode != pGridNode)
                            {
                                // if table has a caption and as a result GridNode and the Table Display Node is 
                                // not the same, we need to offset the cell by the caption height and the table border
                                pGridNode->TransformPoint(pt, COORDSYS_FLOWCONTENT, (CPoint *)&pt, COORDSYS_PARENT);
                            }
                            else
                            {
                                // need to offset the cell by the border width
                                if (pGridNode->HasBorder())
                                {
                                    CRect rcBorderWidths;
                                    pGridNode->GetBorderWidths(&rcBorderWidths);
                                    pt.x += rcBorderWidths.left;
                                    pt.y += rcBorderWidths.top;
                                }
                            }
                        }
                    }
                }
                else if (!pLayout->ElementOwner()->IsAbsolute())
                {
                    // Absolutely positined elements are already properly reporting their position
                    //
                    // we are not a TD/TH, but our PARENT might be!
                    // if we are in a table cell, then we need to adjust for the cell insets,
                    // in case the content is vertically aligned.
                    //-----------------------------------------------------------
                    CLayout *pParentLayout = pLayout->GetUpdatedParentLayout();

                    if (   pParentLayout 
                        && (   (pParentLayout->Tag() == ETAG_TD) 
                            || (pParentLayout->Tag() == ETAG_TH) 
                            || (pParentLayout->Tag() == ETAG_CAPTION) ))
                    {
                        CDispNode * pDispNode = pParentLayout->GetElementDispNode();

                        if (pDispNode && pDispNode->HasInset())
                        {
                            const CSize & sizeInset = pDispNode->GetInset();
                            pt.x += sizeInset.cx;
                            pt.y += sizeInset.cy;
                        }
                    }

                }
            }
            else if (!ShouldHaveLayout())
            {
                // there is a display node from the nearest layout, but the layout
                //   is not Our OWN

                hr = THR(pLayout->GetChildElementTopLeft(pt, this));

                // If we're a positioned elem w/o layout (and only relatively positioned
                // elements can possibly not have layouts), the situation is more complicated.
                // We need to determine the layout parent's relationship to the positioning
                // (offset) parent.  The pt we've retrieved is wrt to the layout parent,
                // but it needs to be wrt the positioning parent.
                if ( IsRelative() )
                {
                    Assert( GetOffsetParentHelper() );

                    POINT     ptAdjust = g_Zero.pt;
                    CElement *pOffsetParentElement = GetOffsetParentHelper()->Element();
                    CElement *pLayoutParentElement = pLayout->ElementOwner();
                    CTreeNode *pIterNode = GetFirstBranch()->Parent();   // start looking from our parent
                    BOOL      fLayoutParentFirst = FALSE;
                    BOOL      fOffsetParentFirst = FALSE;

                    Assert( this != pLayoutParentElement && this != pOffsetParentElement );

                    // If our offset parent and layout parent are the same, no
                    // adjustment work needs to be done.
                    if ( pOffsetParentElement != pLayoutParentElement )
                    {
                        // Discover the relationship between the offset parent and
                        // the layout parent: which is nested under which?
                        while (pIterNode)
                        {
                            if (pIterNode->Element() == pLayoutParentElement)
                            {
                                fLayoutParentFirst = TRUE;
                                break;
                            }
                            if (pIterNode->Element() == pOffsetParentElement)
                            {
                                fOffsetParentFirst = TRUE;
                                break;
                            }
                            pIterNode = pIterNode->Parent();
                        }

                        if (pIterNode)
                        {
                            if (fLayoutParentFirst)
                            {
                                // TODO: Our relative story for nesting of the form 
                                // <rel non-layout><layout><layout><rel non-layout>
                                // has always been broken (bug #105716).  This code only tries to make
                                // <positioned layout><layout>...<rel non-layout> work.

                                // pt is wrt the layout parent, which we found first.  We need to
                                // keep walking outwards, accumulating into pt the offsets of all
                                // layouts between us and our offset parent.

                                while (   pLayoutParentElement
                                       && pLayoutParentElement != pOffsetParentElement)
                                {
                                    Assert( !pLayoutParentElement->IsPositioned() );
                                    Assert( pLayoutParentElement->IsInMarkup() );

                                    pLayoutParentElement->GetElementTopLeft( ptAdjust );
                                    pt.x += ptAdjust.x;
                                    pt.y += ptAdjust.y;

                                    pLayoutParentElement = pLayoutParentElement->GetFirstBranch()->ZParentBranch()->Element();
                                }
                            }
                            else if (fOffsetParentFirst)
                            {
                                // Since we found our offset parent before our nearest layout, our offset parent
                                // can't have layout.  In fact, it must be true that our offset parent has the
                                // same nearest layout as us.
                                Assert(    pOffsetParentElement->IsInMarkup()
                                        && !pOffsetParentElement->ShouldHaveLayout()
                                        && pOffsetParentElement->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT) == pLayout );

                                hr = THR(pLayout->GetChildElementTopLeft(ptAdjust, pOffsetParentElement));

                                // Fix pt so that it's wrt our offset parent
                                pt.x -= ptAdjust.x;
                                pt.y -= ptAdjust.y;
                            }
                        }
                    }
                }
            }
            //else
            //{
            //      TODO (carled) in this case, we HAVE a layout but no Display node.  
            //      We should not get here, but occasionally are. and so we should just 
            //      return 0,0
            //}
        }
    }

    RRETURN(hr);
}

//************************************************
//
// IF YOU CHANGE THIS ROUTINE - YOU MUST CHANGE THE FUNCTION OF THE SAME NAME IN EDTRACK
// OR ELSE SELECTION IN FRAMES WILL HAVE ISSUES
//
//************************************************

void
CElement::GetClientOrigin(POINT * ppt)
{
    *ppt = g_Zero.pt;

    if (!HasMarkupPtr())
        return;

    CElement*   pRoot = GetMarkup()->Root();

    if (!pRoot->HasMasterPtr())
        return;

    CLayout * pLayout = pRoot->GetMasterPtr()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

    if (!pLayout)
        return;

    // TODO (MohanB) Need to subtract the master's borders, etc.
    CPoint pt(*ppt);
    pLayout->TransformPoint(&pt, COORDSYS_SCROLL, COORDSYS_GLOBAL);
    *ppt = pt;
}


//+----------------------------------------------------
//
//  member : GetInheritedBackgroundColor
//
//  synopsis : returns the actual background color
//
//-----------------------------------------------------

COLORREF
CElement::GetInheritedBackgroundColor(CTreeNode * pNodeContext /* = NULL */)
{
    CColorValue ccv;

    IGNORE_HR(GetInheritedBackgroundColorValue(&ccv, pNodeContext));

    return ccv.GetColorRef();
}


//+----------------------------------------------------
//
//  member : GetInheritedBackgroundColorValue
//
//  synopsis : returns the actual background color as a CColorValue
//
//-----------------------------------------------------

HRESULT
CElement::GetInheritedBackgroundColorValue(CColorValue *pVal, CTreeNode * pNodeContext /* = NULL */ )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode = pNodeContext ? pNodeContext : GetFirstBranch();

    if(!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(pVal != NULL);

    do
    {
        *pVal   = pNode->GetFancyFormat()->_ccvBackColor;
        if (pVal->IsDefined())
            break;

        // Inherit from the master if this element is in a viewlink behavior and
        // wants to inherit style from the master.
        if (pNode->Tag() == ETAG_ROOT && pNode->Element()->IsInViewLinkBehavior(FALSE))
        {
            CElement * pElemMaster = pNode->Element()->GetMasterPtr();

            Assert(     pElemMaster
                    &&  pElemMaster->TagType() == ETAG_GENERIC
                    &&  (   !pElemMaster->HasDefaults()
                         || pElemMaster->GetDefaults()->GetAAviewInheritStyle()
                        )
                  );
            pNode = pElemMaster->GetFirstBranch();
        }
        else
        {
            pNode = pNode->Parent();
        }
    }
    while (pNode);

    // The root site should always have a background color defined.
    Assert(pVal->IsDefined());

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------
//
//  member  :   get_offsetWidth,  IHTMLElement
//
//  Synopsis:   Get the calculated height in doc units. if *this*
//          is a site then just return based on the size
//          if it is an element, then we need to get the regions
//          of its parts and add it up.
//
//-------------------------------------------------------------

HRESULT
CElement::get_offsetWidth ( long *plValue )
{
    HRESULT hr = S_OK;
    SIZE    size;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout * pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(GetBoundingSize(size));
        if (hr)
            goto Cleanup;

        *plValue = HasVerticalLayoutFlow() ? size.cy : size.cx;

        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());

           pUnitInfo = pdiTemp->GetUnitInfo();
        }
        *plValue = HasVerticalLayoutFlow() 
                        ? pUnitInfo->DocPixelsFromDeviceY(size.cy) 
                        : pUnitInfo->DocPixelsFromDeviceX(size.cx);
    }
    else
    {
        *plValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------
//
//  member  :   get_offsetHeight,  IHTMLElement
//
//  Synopsis:   Get the calculated height in doc units. if *this*
//          is a site then just return based on the size
//          if it is an element, then we need to get the regions
//          of its parts and add it up.
//
//-------------------------------------------------------------

HRESULT
CElement::get_offsetHeight ( long *plValue )
{
    HRESULT hr = S_OK;
    SIZE    size;

    if (!plValue)
    {
        hr = E_POINTER;
    }
    else if (IsInMarkup() && Doc()->GetView()->IsActive())
    {
        CLayout * pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(GetBoundingSize(size));
        if (hr)
            goto Cleanup;

        *plValue = HasVerticalLayoutFlow() ? size.cx : size.cy;

        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());
            pUnitInfo = pdiTemp->GetUnitInfo();
        }

        *plValue = HasVerticalLayoutFlow() 
                        ? pUnitInfo->DocPixelsFromDeviceX(size.cx) 
                        : pUnitInfo->DocPixelsFromDeviceY(size.cy);
    }
    else
    {
        *plValue = 0;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

// helper function for offset height and width
HRESULT
CElement::GetBoundingSize(SIZE & sizeBounds)
{
    CRect       rcBound;

    sizeBounds.cx=0;
    sizeBounds.cy=0;

    if (S_OK != EnsureRecalcNotify())
        return E_FAIL;

    GetBoundingRect(&rcBound);

    sizeBounds = rcBound.Size();

    return S_OK;
}


//+----------------------------------------------------
//
//  member : get_offsetParent, IHTMLElement
//
//  synopsis : returns the parent container (site) which
//      defines the coordinate system of the offset*
//      properties above.
//              returns NULL when no parent makes sense
//
//-----------------------------------------------------

HRESULT
CElement::get_offsetParent (IHTMLElement ** ppIElement)
{
    HRESULT  hr = S_OK;
    CTreeNode * pNodeRet = NULL;

    if (!ppIElement)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    else if(!GetFirstBranch())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppIElement= NULL;

    pNodeRet = GetOffsetParentHelper();

    if (pNodeRet &&
        pNodeRet->Tag() != ETAG_ROOT)
    {
        hr = THR( pNodeRet->GetElementInterface( IID_IHTMLElement, (void**) ppIElement ) );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

CTreeNode *
CElement::GetOffsetParentHelper()
{
    CTreeNode * pNodeRet = NULL;
    CTreeNode * pNodeContext = GetFirstBranch();

    switch( _etag)
    {
    case ETAG_HTML:
    case ETAG_BODY:
    case ETAG_MAP :
        // return NULL. Maps don't necessarily have a parent
        break;

    case ETAG_AREA:
        // the area's parent is the map
        if (pNodeContext->Parent())
        {
            pNodeRet = pNodeContext->Parent();
        }
        break;

    case ETAG_TD:
    case ETAG_TH:
        if (pNodeContext->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT))
        {
            pNodeRet = (ShouldHaveLayout())
                                ? pNodeContext->ZParentBranch()
                                : pNodeContext->GetUpdatedNearestLayoutNode();

            if (pNodeRet && pNodeRet->IsPositionStatic())
            {
                // return pNodeRet's parent
                pNodeRet = pNodeRet->ZParentBranch();
                Assert(pNodeRet && pNodeRet->Tag()==ETAG_TABLE);

            }
        }
        break;

    default:
        if (pNodeContext->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT))
            pNodeRet = pNodeContext->ZParentBranch();
        break;
    }

    return pNodeRet;
}

htmlComponent 
CElement::ComponentFromHTC(HTC htc)
{
    switch (htc)
    {
    case HTC_YES:
        return htmlComponentClient;
    case HTC_NO:
        return htmlComponentOutside;
    case HTC_TOPLEFTHANDLE :
        return htmlComponentGHTopLeft;
    case HTC_LEFTHANDLE :
        return htmlComponentGHLeft;
    case HTC_TOPHANDLE :
        return htmlComponentGHTop;
    case HTC_BOTTOMLEFTHANDLE :
        return htmlComponentGHBottomLeft;
    case HTC_TOPRIGHTHANDLE :
        return htmlComponentGHTopRight;
    case HTC_BOTTOMHANDLE :
        return htmlComponentGHBottom;
    case HTC_RIGHTHANDLE :
        return htmlComponentGHRight;
    case HTC_BOTTOMRIGHTHANDLE :
        return htmlComponentGHBottomRight;
    }
    return htmlComponentOutside;
}

HTC
CElement::HTCFromComponent(htmlComponent component)
{
    switch (component)
    {
    case htmlComponentClient:
        return HTC_YES;
    case htmlComponentOutside:
        return HTC_NO;
    case htmlComponentSbLeft:
    case htmlComponentSbPageLeft:
    case htmlComponentSbHThumb:
    case htmlComponentSbPageRight:
    case htmlComponentSbRight:
    case htmlComponentSbLeft2:
    case htmlComponentSbPageLeft2:
    case htmlComponentSbRight2:
    case htmlComponentSbPageRight2:
    case htmlComponentSbUp2:
    case htmlComponentSbPageUp2:
    case htmlComponentSbDown2:
    case htmlComponentSbPageDown2:
        return HTC_HSCROLLBAR;
    case htmlComponentSbUp:
    case htmlComponentSbPageUp:
    case htmlComponentSbVThumb:
    case htmlComponentSbPageDown:
    case htmlComponentSbDown:
    case htmlComponentSbTop:
    case htmlComponentSbBottom:
        return HTC_VSCROLLBAR;
    case htmlComponentGHTopLeft:
        return HTC_TOPLEFTHANDLE;
    case htmlComponentGHLeft:
        return HTC_LEFTHANDLE;
    case htmlComponentGHTop:
        return HTC_TOPHANDLE;
    case htmlComponentGHBottomLeft:
        return HTC_BOTTOMLEFTHANDLE;
    case htmlComponentGHTopRight:
        return HTC_TOPRIGHTHANDLE;
    case htmlComponentGHBottom:
        return HTC_BOTTOMHANDLE;
    case htmlComponentGHRight:
        return HTC_RIGHTHANDLE;
    case htmlComponentGHBottomRight:
        return HTC_BOTTOMRIGHTHANDLE;
    }

    return HTC_YES;
}


//+-------------------------------------------------------------------------------
//
//  Member:     componentFromPoint
//
//  Synopsis:   Base Implementation of the automation interface IHTMLELEMENT2 method.
//              This method returns none, meaning no component is hit, and is here
//              for future expansion when the component list includes borders and
//              margins and such.
//              Currently, only scrollbar components are implemented, so there is an
//              overriding implementation in CLayout which handles the hit testing
//              against the scrollbar, and determines which component is hit.
//
//+-------------------------------------------------------------------------------
STDMETHODIMP
CElement::componentFromPoint( long x, long y, BSTR * pbstrComponent)
{
    HRESULT         hr              = S_OK;
    WORD            eComp           = htmlComponentOutside;
    CTreeNode *     pNodeElement    = NULL;
    HTC             htc;
    CMessage        msg;
    CElement *      pRoot;

    x = g_uiDisplay.DeviceFromDocPixelsX(x);
    y = g_uiDisplay.DeviceFromDocPixelsY(y);

    msg.pt.x = x;
    msg.pt.y = y;
    msg.lBehaviorPartID = 0;

    if (!pbstrComponent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (!IsInViewTree())
        goto Cleanup;

    pRoot = GetMarkup()->Root();
    // If this isn't the primary document, transform to the global coordinate system.
    if (pRoot->HasMasterPtr())
    {
        CLayout *   pLayout;
        CElement *  pElemMaster = pRoot->GetMasterPtr();

        if (S_OK != pElemMaster->EnsureRecalcNotify())
            goto Cleanup;

        pLayout = pElemMaster->GetUpdatedLayout();
        Assert(pLayout);

        pLayout->TransformPoint(&msg.pt, COORDSYS_SCROLL, COORDSYS_GLOBAL);
    }

    //
    // Thinking of making changes ? Pls regress against bugs
    // 101383 & 98334
    //
    // Bear in mind that the hit test has to go to the peer
    // if there's a peer attached or you will break access
    // 

    // find what element we are hitting
    htc = Doc()->HitTestPoint(&msg, &pNodeElement, HT_VIRTUALHITTEST);

    if (htc == HTC_BEHAVIOR)
    {
        CPeerHolder *pPH = pNodeElement->Element()->FindPeerHolder(msg.lBehaviorCookie);
        if (pPH)
        {
            hr = pPH->StringFromPartID(msg.lBehaviorPartID, pbstrComponent);
            if (hr != S_FALSE)
                goto Cleanup;
        }
    }
    
    if (ShouldHaveLayout())
    {
        eComp = GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->ComponentFromPoint(msg.pt.x, msg.pt.y);
    }
    else 
    {         
        eComp = ComponentFromHTC(htc);

        if (this != pNodeElement->Element())
        {
            eComp = htmlComponentOutside;
        }
        else
        {
            Assert(eComp == htmlComponentClient);
        }
    }
    hr = THR( STRINGFROMENUM( htmlComponent, eComp, pbstrComponent));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+-------------------------------------------------------------------------------
//
//  Member:     doScroll
//
//  Synopsis:   Implementation of the automation interface method.
//              this simulates a click on the particular component of the scrollbar
//              (if this txtsite has one)
//
//+-------------------------------------------------------------------------------
STDMETHODIMP
CElement::doScroll( VARIANT varComponent)
{
    HRESULT       hr;
    htmlComponent eComp;
    int           iDir;
    WORD          wComp;
    CVariant      varCompStr;
    CDoc *        pDoc = Doc();
    CLayout *     pLayout;
    BOOL          fVert = HasVerticalLayoutFlow();
    
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    pLayout = GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

    //
    // don't scroll if we are still loading the page or not UIActive
    if (pDoc->IsLoading() || pDoc->State() < OS_INPLACE)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    //
    // the paramter is optional, and if nothing was provide then use the default
    hr = THR(varCompStr.CoerceVariantArg(&varComponent, VT_BSTR));
    if ( hr == S_OK )
    {
        if (!SysStringLen(V_BSTR(&varCompStr)))
            eComp = htmlComponentSbPageDown;
        else
        {
            hr = THR( ENUMFROMSTRING( htmlComponent,
                                  V_BSTR(&varCompStr),
                                  (long *) &eComp) );
            if (hr)
                goto Cleanup;
        }
    }
    else if ( hr == S_FALSE )
    {
        // when no argument
        eComp = htmlComponentSbPageDown;
        hr = S_OK;
    }
    else
        goto Cleanup;


    // no that we know what we are doing, initialize the parametes for
    // the onscroll helper fx
    switch (eComp) {
    case htmlComponentSbLeft :
    case htmlComponentSbLeft2:
        iDir = 0;
        wComp = !fVert ? SB_LINELEFT : SB_LINEDOWN;
        break;
    case htmlComponentSbPageLeft :
    case htmlComponentSbPageLeft2:
        iDir = 0;
        wComp = !fVert ? SB_PAGELEFT : SB_PAGEDOWN;
        break;
    case htmlComponentSbPageRight :
    case htmlComponentSbPageRight2:
        iDir = 0;
        wComp = !fVert ? SB_PAGERIGHT : SB_PAGEUP;
        break;
    case htmlComponentSbRight :
    case htmlComponentSbRight2:
        iDir = 0;
        wComp = !fVert ? SB_LINERIGHT : SB_LINEUP;
        break;
    case htmlComponentSbUp :
    case htmlComponentSbUp2:
        // equivalent to up arrow
        iDir = 1;
        wComp = !fVert ? SB_LINEUP : SB_LINELEFT;
        break;
    case htmlComponentSbPageUp :
    case htmlComponentSbPageUp2:
        iDir = 1;
        wComp = !fVert ? SB_PAGEUP : SB_PAGELEFT;
        break;
    case htmlComponentSbPageDown :
    case htmlComponentSbPageDown2:
        iDir = 1;
        wComp = !fVert ? SB_PAGEDOWN : SB_PAGERIGHT;
        break;
    case htmlComponentSbDown :
    case htmlComponentSbDown2:
        iDir = 1;
        wComp = !fVert ? SB_LINEDOWN: SB_LINERIGHT;
        break;
    case htmlComponentSbTop:
        iDir = 1;
        wComp = SB_TOP;
        break;
    case htmlComponentSbBottom:
        iDir = 1;
        wComp = SB_BOTTOM;
        break;
    default:
        // nothing to do in this case.  hr is S_OK
        goto Cleanup;

    }

    if (fVert)
    {
        iDir = iDir == 0 ? 1 : 0;
    }
    
    //  Send the request to the layout, if any
    if (pLayout)
    {
        hr = THR(pLayout->OnScroll(iDir, wComp, 0));
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_onpropertychange
//
//  Synopsis:   Fires the onpropertychange event, sets up the event param
//
//+----------------------------------------------------------------------------

void
CElement::Fire_onpropertychange(LPCTSTR strPropName)
{
    CDoc *pDoc = Doc();
    EVENTPARAM param(pDoc, this, NULL, TRUE);

    param.SetType(s_propdescCElementonpropertychange.a.pstrName + 2);
    param.SetPropName(strPropName);
    param.SetNodeAndCalcCoordinates(GetFirstBranch());

    FireEvent(&s_propdescCElementonpropertychange, FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_PropertyChangeHelper
//
//  Synopsis:   Fires the onpropertychange event, sets up the event param
//
//+----------------------------------------------------------------------------
HRESULT
CElement::Fire_PropertyChangeHelper(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT       hr = S_OK;
    BSTR          bstrName = NULL;
    DISPID        expDispid;
    PROPERTYDESC  *pPropDesc = (PROPERTYDESC *)ppropdesc;
    LPCTSTR       pchName = NULL;
    CBufferedStr  cBuf;

    Assert(!ppropdesc || ppropdesc->GetDispid() == dispid);
    //Assert(!ppropdesc || ppropdesc->GetdwFlags() == dwFlags);

    // first, find the appropriate propdesc for this property.
    // NOTE: If you change the "if" conditions, make sure you confirm
    // that the deferred event firing code below works!
    if (dwFlags & ELEMCHNG_INLINESTYLE_PROPERTY)
    {
        CBase *pStyleObj = GetInLineStylePtr();

        if (pStyleObj)
        {

            cBuf.Set( (dwFlags & ELEMCHNG_INLINESTYLE_PROPERTY) ? 
                _T("style.") : 
                _T("runtimeStyle."));
            // if we still can't find it, or have no inline
            // then bag this, and continue
            if (!pPropDesc)
            {
                hr = THR(pStyleObj->FindPropDescFromDispID(dispid, &pPropDesc, NULL, NULL));
            }
            if (S_OK == hr)
            {

                cBuf.QuickAppend((pPropDesc->pstrExposedName)?
                                    pPropDesc->pstrExposedName :
                                    pPropDesc->pstrName);
                pchName = LPTSTR(cBuf);
            }
            else if (IsExpandoDISPID(dispid, &expDispid))
            {
                LPCTSTR pszName;
                if (S_OK == pStyleObj->GetExpandoName(expDispid, &pszName))
                {
                    cBuf.QuickAppend(pszName);
                    pchName = LPTSTR(cBuf);
                }
            }
        }
    }
    else
    {
        HRESULT     hr2;

        if( !ppropdesc )
        {
            hr2 = THR_NOTRACE(GetMemberName(dispid, &bstrName));
            if(hr2)
            {
                bstrName = NULL;
            }
            else
            {
                pchName = bstrName;
            }
        }
        else
        {
            pchName = ppropdesc->pstrExposedName ?
                        ppropdesc->pstrExposedName :
                        ppropdesc->pstrName;
        }
    }

    // we have a property name, and can fire the event
    if(pchName)
    {
        // If the element is currently being sized, we don't want to fire the event synchronously,
        // because script for the event might cause us to do things that are only possible when we
        // aren't being sized (pasting text etc).  In that case, defer the event firing until the
        // next EnsureView. (Bug #101803)
        if (   TestLock(CElement::ELEMENTLOCK_SIZING)
            && !(dwFlags & ELEMCHNG_INLINESTYLE_PROPERTY)) // TODO: Ditch this condition; requires reworking event queues to clean up data inside 'em
        {
            // don't want to pass a strName (then we need to manage its lifetime),
            // so we use the dispid.  See CView::ExecuteEventTasks().
            Doc()->GetView()->AddEventTask(this, DISPID_EVMETH_ONPROPERTYCHANGE, dispid );
        }
        else
        {
            Fire_onpropertychange(pchName);
        }

        SysFreeString(bstrName);
    }

    return S_OK;
}




CDragStartInfo::CDragStartInfo(CElement *pElementDrag, DWORD dwStateKey, IUniformResourceLocator * pUrlToDrag)
{
    _pElementDrag = pElementDrag;
    _pElementDrag->SubAddRef();
    _dwStateKey = dwStateKey;
    _pUrlToDrag = pUrlToDrag;
    if (_pUrlToDrag)
        _pUrlToDrag->AddRef();
    _dwEffectAllowed = DROPEFFECT_UNINITIALIZED;
}

CDragStartInfo::~CDragStartInfo()
{
    _pElementDrag->SubRelease();
    ReleaseInterface(_pUrlToDrag);
    ReleaseInterface(_pDataObj);
    ReleaseInterface(_pDropSource);
}

HRESULT
CDragStartInfo::CreateDataObj()
{
    CLayout * pLayout = _pElementDrag->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);

    RRETURN(pLayout ? pLayout->DoDrag(_dwStateKey, _pUrlToDrag, TRUE) : E_FAIL);
}

HRESULT
CElement::dragDrop(VARIANT_BOOL *pfRet)
{
    HRESULT hr = S_OK;
    BOOL fRet;
    CTreeNode* pNode;
    CLayout *pLayout ;
    CDoc *pDoc = Doc();
    CElement* pElemCurrentReally;
    
    if (pDoc->_pElemCurrent)
    {
        if ( pDoc->_pElemCurrent->_etag == ETAG_FRAMESET )
        {
            pElemCurrentReally = GetFlowLayoutElement();
        }
        else
            pElemCurrentReally = pDoc->_pElemCurrent;
            
        pNode = pElemCurrentReally->GetFirstBranch();
        if (!pNode)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        //
        // call GetUpdated to ensure we have a layout.
        //
        pElemCurrentReally->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
        
        pLayout = pNode->GetFlowLayout();
    }
    else
    {
        pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);
    }     
    
    if (!pLayout)
    {
        hr = E_FAIL;
        AssertSz(0,"No layout to drag with");
        goto Cleanup;
    }

    fRet = DragElement(pLayout, 0, NULL, -1, TRUE /*fCheckSelection*/ );

    if (pfRet)
        *pfRet = fRet ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::DragElement
//
//  Synopsis:   calls Fire_ondragstart then executes DoDrag on the
//              layout
//
//-----------------------------------------------------------------------------
BOOL
CElement::DragElement(CLayout *                 pLayout,
                      DWORD                     dwStateKey,
                      IUniformResourceLocator * pUrlToDrag,
                      long                      lSubDivision,
                      BOOL                      fCheckSelection /*=FALSE*/ )
{
    BOOL fRet = FALSE;
    CDoc * pDoc = Doc();
    CTreeNode::CLock  Lock;

    // Layouts are detached and released when their elementOwner leaves the tree. because
    // drag/drop can cause this to happen, we need to be careful that pLayout doesn't release
    // out from under us. 
    if (pLayout)
        pLayout->AddRef();

    if( Lock.Init(GetFirstBranch()) )
    {
        Assert( !fRet );
        goto Cleanup;
    }

    if (IsUnselectable())
        goto Cleanup;

    Assert(!pDoc->_pDragStartInfo);
    pDoc->_pDragStartInfo = new CDragStartInfo(this, dwStateKey, pUrlToDrag);

    if (!pDoc->_pDragStartInfo)
        goto Cleanup;

    fRet = Fire_ondragstart(NULL, lSubDivision);

    if (!GetFirstBranch())
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (fRet)
    {
        Assert(pLayout->ElementOwner()->IsInMarkup());
        IGNORE_HR(pLayout->DoDrag(dwStateKey, pUrlToDrag, FALSE, & fRet, fCheckSelection) );
    }

Cleanup:
    if (pLayout)
        pLayout->Release();

    if (pDoc->_pDragStartInfo)
    {
        delete pDoc->_pDragStartInfo;
        pDoc->_pDragStartInfo = NULL;
    }
    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_ondragenterover
//
//  Synopsis:   Fires the ondragenter or ondragover event, sets up the event param
//              and returns the dropeffect
//
//+----------------------------------------------------------------------------

BOOL
CElement::Fire_ondragHelper(
    long lSubDivision,
    const PROPERTYDESC_BASIC *pDesc,
    DWORD * pdwDropEffect)
{
    EVENTPARAM param(Doc(), this, NULL, TRUE);
    BOOL fRet;
    CTreeNode *pNodeContext = GetFirstBranch();

    Assert(pdwDropEffect);

    param.dwDropEffect = *pdwDropEffect;

    param.SetNodeAndCalcCoordinates(pNodeContext);
    param.SetType(pDesc->a.pstrName + 2);

    fRet = !!FireEvent(
            pDesc,
            FALSE,
            pNodeContext,
            lSubDivision);

    if (!fRet)
        *pdwDropEffect = param.dwDropEffect;

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member:     CElement::Fire_ondragend
//
//  Synopsis:   Fires the ondragend event
//
//+----------------------------------------------------------------------------
void
CElement::Fire_ondragend(long lSubDivision, DWORD dwDropEffect)
{
    EVENTPARAM param(Doc(), this, NULL, TRUE);
    CTreeNode *pNodeContext = GetFirstBranch();

    param.dwDropEffect = dwDropEffect;

    param.SetNodeAndCalcCoordinates(pNodeContext);
    param.SetType(s_propdescCElementondragend.a.pstrName + 2);

    FireEvent(
        &s_propdescCElementondragend,
        FALSE,
        pNodeContext,
        lSubDivision);
}

//+-----------------------------------------------------------------
//
//  member : CElement::getBoundingClientRect() - External method
//
//  Synopsis:   Returns Bounding rect of the text under element's
//              influence in client coordinates
//------------------------------------------------------------------

HRESULT
CElement::getBoundingClientRect(IHTMLRect **ppIRect)
{
    HRESULT             hr = S_OK;
    CRect               Rect;
    COMRect           * pOMRect = NULL;
    POINT               ptOrg;

    if (!ppIRect)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppIRect = NULL;

    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;

    hr = THR(GetBoundingRect(&Rect, RFE_SCREENCOORD));
    if (hr)
        goto Cleanup;

    GetClientOrigin(&ptOrg);
    Rect.OffsetRect(-ptOrg.x, -ptOrg.y);

    g_uiDisplay.DocPixelsFromDevice(Rect, Rect);

    // Create the rectangle object
    pOMRect = new COMRect(&Rect);
    if (!pOMRect)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Return  rectangle
    *ppIRect = (IHTMLRect *) pOMRect;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-----------------------------------------------------------------
//
//  member : CElement::GetBoundingRect
//
//  Synopsis:   Get the region corresponding to the element
//
//  Arguments:  pRect   - bounding rect of the element
//              dwFlags - flags to control the coordinate system
//                        the rect.
//                        0 - returns the region relative to the
//                            parent content
//                        RFE_SCREENCOORD - window/document/global
//
//------------------------------------------------------------------

HRESULT
CElement::GetBoundingRect(CRect *pRect, DWORD dwFlags)
{
    HRESULT         hr      = S_OK;
    CTreeNode *     pNode   = GetFirstBranch();
    CDataAry<RECT>  aryRects(Mt(CElementGetBoundingRect_aryRects_pv));

    Assert(pRect);
    pRect->SetRectEmpty();

    if (!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    GetElementRegion(&aryRects, pRect, dwFlags);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-----------------------------------------------------------------
//
//  Member :    CElement::GetElementRegion
//
//  Synopsis:   Get the region corresponding to the element
//
//  Arguments:  paryRects - array to hold the rects corresponding to
//                          region
//              dwFlags   - flags to control the coordinate system
//                          the rects are returned in.
//                          0 - returns the region relative to the
//                              parent content
//                          RFE_SCREENCOORD - window/document/global
//
//------------------------------------------------------------------

void
CElement::GetElementRegion(CDataAry<RECT> * paryRects, RECT * prcBound, DWORD dwFlags)
{
    CRect   rect;
    BOOL    fAppendRect = FALSE;

    if(!prcBound)
        prcBound = &rect;

    switch (Tag())
    {
    case ETAG_MAP :
        DYNCAST(CMapElement, this)->GetBoundingRect(prcBound);
        fAppendRect = TRUE;
        break;

    case ETAG_AREA:
        DYNCAST(CAreaElement, this)->GetBoundingRect(prcBound);
        fAppendRect = TRUE;
        break;

    case ETAG_OPTION:
    case ETAG_OPTGROUP:
        *prcBound = g_Zero.rc;
        fAppendRect = TRUE;
        break;

    case ETAG_HTML:
        if (!GetMarkup()->IsHtmlLayout())
        {
            if (GetMarkup()->Root()->HasMasterPtr())
            {
                // We are viewslaved.  Get the size of our master element.
                // (greglett) Will the rect be at the correct position?
                Assert(GetMarkup()->Root()->HasMasterPtr());
                GetMarkup()->Root()->GetMasterPtr()->GetElementRegion(paryRects, prcBound, dwFlags);
            }
            else
            {
                CSize  size;

                // We are the primary HTML element.  As such, we own the view.
                Doc()->GetView()->GetViewSize(&size);
                prcBound->top =
                prcBound->left = 0;
                prcBound->right = size.cx;
                prcBound->bottom = size.cy;
            }

            fAppendRect = TRUE;
            break;
        }

    //  NOTE: Intentional fallthrough for ETAG_HTML, StrictCSS!
    default:
        {
            CLayout * pLayout = GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);

            if (pLayout)
            {
                // Get the array that contains bounding rects for each line of the text
                // We want to account for aligned content contained within the element
                // when computing the region.
                dwFlags |= RFE_ELEMENT_RECT | RFE_INCLUDE_BORDERS;
                pLayout->RegionFromElement(this, paryRects, prcBound, dwFlags);
            }
        }
        break;
    }

    if(fAppendRect)
    {
        paryRects->AppendIndirect((RECT *)prcBound);
    }
}

//+-----------------------------------------------------------------
//
//  member : CElement::getClientRects() - External method
//
//  Synopsis:   Returns the collection of rectangles for the text under
//               element's influence in client coordinates.
//              Each rectangle represents a line of text on the screen.
//------------------------------------------------------------------

HRESULT
CElement::getClientRects(IHTMLRectCollection **ppIRects)
{
    HRESULT              hr;
    COMRectCollection  * pOMRectCollection;
    CDataAry<RECT>       aryRects(Mt(CElementgetClientRects_aryRects_pv));
    CTreeNode          * pNode;

    if (!ppIRects)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppIRects = NULL;

    pNode = GetFirstBranch();
    if(!pNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // make sure that current will be calced
    hr = THR(EnsureRecalcNotify());
    if (hr)
        goto Cleanup;


    GetElementRegion(&aryRects, NULL, RFE_SCREENCOORD);
    for (int i = 0; i < aryRects.Size(); i++)
    {
        g_uiDisplay.DocPixelsFromDevice(aryRects[i], aryRects[i]);
    }

    // Create a rectangle collection class instance
    pOMRectCollection = new COMRectCollection();
    if (!pOMRectCollection)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Fill the collection with values from aryRects
    hr = THR(pOMRectCollection->SetRects(&aryRects));
    if(hr)
        goto Cleanup;

    // Return  rectangle
    *ppIRects = (IHTMLRectCollection *) pOMRectCollection;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


CDOMChildrenCollection *
CElement::EnsureDOMChildrenCollectionPtr ( )
{
    CDOMChildrenCollection *pDOMPtr = NULL;
    GetPointerAt ( FindAAIndex ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,CAttrValue::AA_Internal ),
        (void **)&pDOMPtr );
    if ( !pDOMPtr )
    {
        pDOMPtr = new CDOMChildrenCollection ( this, TRUE /* fIsElement */ );
        if ( pDOMPtr )
        {
            AddPointer ( DISPID_INTERNAL_CDOMCHILDRENPTRCACHE,
                (void *)pDOMPtr,
                CAttrValue::AA_Internal );
            }
    }
    else
    {
        pDOMPtr->AddRef();
    }
    return pDOMPtr;
}



#ifndef NO_EDIT
HRESULT
CElement::CreateUndoAttrValueSimpleChange(
    DISPID dispid,
    VARIANT &  vtProp,
    BOOL fInlineStyle,
    CAttrValue::AATYPE aaType )
{
    HRESULT                      hr;
    CUndoAttrValueSimpleChange * pUndo = NULL;

    if (!QueryCreateUndo(TRUE))
        return S_OK;

    TraceTag((tagUndo,
              "CElement::CreateUndoAttrValueSimpleChange creating an object."));

    pUndo = new CUndoAttrValueSimpleChange(this);
    if (!pUndo)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pUndo->Init(dispid, vtProp, fInlineStyle, aaType));
    if (hr)
        goto Cleanup;

    hr = THR(UndoManager()->Add(pUndo));

Cleanup:

    ReleaseInterface(pUndo);

    RRETURN(hr);
}

HRESULT
CElement::CreateUndoPropChangeNotification(
    DISPID dispid,
    DWORD dwFlags,
    BOOL fPlaceHolder )
{
    HRESULT                       hr;
    CUndoPropChangeNotification * pUndo = NULL;

    if (!QueryCreateUndo(TRUE))
        return S_OK;

    TraceTag((tagUndo,
              "CElement::CreateUndoPropChangeNotification creating an object."));

    pUndo = new CUndoPropChangeNotification( this );
    if (!pUndo)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pUndo->Init(dispid, dwFlags, fPlaceHolder));
    if (hr)
        goto Cleanup;

    hr = THR(UndoManager()->Add(pUndo));

Cleanup:

    ReleaseInterface(pUndo);

    RRETURN(hr);
}

#endif // NO_EDIT


//
// Recalc methods
// These methods are tiny stubs that point directly to the recalc host code
//
STDMETHODIMP
CElement::removeExpression(BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    CTreeNode *pNode = GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(Doc()->_recalcHost.removeExpression(this, strPropertyName, pfSuccess)));
}

STDMETHODIMP
CElement::setExpression(BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    if ( IsPrintMedia() )
        return S_OK;
                   
    _fHasExpressions = TRUE;

    CTreeNode *pNode = GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(Doc()->_recalcHost.setExpression(this, strPropertyName, strExpression, strLanguage)));
}

STDMETHODIMP
CElement::getExpression(BSTR strPropertyName, VARIANT *pvExpression)
{
    CTreeNode *pNode = GetUpdatedNearestLayoutNode();
    if (pNode)
        pNode->GetFancyFormatIndex();

    RRETURN(SetErrorInfo(Doc()->_recalcHost.getExpression(this, strPropertyName, pvExpression)));
}

//+---------------------------------------------------------------------
//
// Method: Fire_ondblclick
//
// Synopsis: Fire On Double Click. We construct the _pparam object
//           and push on the doc - in case the pEvtInfo is not null 
//           ( to copy the param for editing)
//
//+---------------------------------------------------------------------

BOOL 
CElement::Fire_ondblclick(CTreeNode * pNodeContext /*= NULL*/, long lSubDivision /*= -1*/, EVENTINFO * pEvtInfo /*=NULL*/)
{
    if (!Doc()->_fCanFireDblClick)
        return FALSE;
        
    return !!FireEvent(&s_propdescCElementondblclick, TRUE, pNodeContext, lSubDivision, pEvtInfo );
}

BOOL 
CElement::Fire_onclick(CTreeNode * pNodeContext /*= NULL*/, long lSubDivision /*= -1*/, EVENTINFO * pEvtInfo /*=NULL*/)
{
    return !!FireEvent(&s_propdescCElementonclick, TRUE, pNodeContext, lSubDivision, pEvtInfo );
}

//+------------------------------------------------------------------------------------------
//
// Member : EnsureRecalcNotify
//
// called when synchronous calls (usually OM) require layout to be up to
// date to return a property.
//
//   Parameter : fForceEnsure - this flag indicates that the View queues should be processed .
//          This is true by default, because all OM GET operations require that the queued 
//          work be done synchronously in order to answer the query appropriately.
//          HOWEVER (!) some callers (e.g. MoveMarkupPointerToPointEx) MAY have the view open
//          because they are actively changing the queues.  In this case we want to 
//          process the view queues if the tree is *closed*, and if the tree is open, the 
//          queues will be processed later when the postcloseview happens.
//
// WARNING (greglett)
//    EnsureRecalcNotify may cause calcs which will propagate contexts down from containers to submarkups.
//    This means that elements in markups that are paginated (LayoutRects) or WYSIWYG (DeviceRects)
//    may throw away their layouts and replace them with layout arrays.
//    This means that any refernces you have to layouts through this call may become invalid.
//    Do not assume any layout pointers you have are still valid (including this pointers!)
//    This is good policy anyway, as need-for-layout status may change due to format computation.
//
//------------------------------------------------------------------------------------------
HRESULT
CElement::EnsureRecalcNotify(BOOL fForceEnsure /* == true */)
{
    CView * pView = Doc()->GetView();
    CMarkup * pMarkup = GetMarkup();

    Assert(pView);

    // if we are blocked for OM calls, fail
    if (pView->IsInState(CView::VS_BLOCKED))
    {
        return E_FAIL;
    }

    // send the notification that work is about to be done
    // (greglett) Oh, the pain.  See warnings on EnsureRecalcNotify.
    //            This prevents us from being in a layout and deleting our this *
    //            This should really be for paginated elements, not PrintMedia elements.
    if (    pMarkup
        &&  !pMarkup->IsPrintMedia() )
    {
        SendNotification(NTYPE_ELEMENT_ENSURERECALC);
    }

    // ensure view will pick up any addition work gets done.
    if (   fForceEnsure
        || !(pView->IsInState(CView::VS_OPEN)))
    {
        pView->EnsureView(LAYOUT_SYNCHRONOUS);
    }
    // else
    // the view is open which means someone is making changes.
    // in this case, we can't necessarily answer correctly, but 
    // the work will be done eventually. 

    return S_OK;
}

CPeerHolder *
CElement::FindPeerHolder(LONG lCookie)
{
    CPeerHolder::CPeerHolderIterator iter;

    for (iter.Start(GetPeerHolder()); !iter.IsEnd(); iter.Step())
    {
        if (iter.PH()->CookieID() == lCookie)
        {
            return iter.PH();
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\fframe.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  Contents:   Fake frame implementation.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

inline CFormInPlace * CFakeUIWindow::InPlace()
{ 
    return Doc()->InPlace(); 
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::AddRef
//
//  Synopsis:   Per IUnknown
//
//-------------------------------------------------------------------------

ULONG CFakeUIWindow::AddRef()
{
    return Doc()->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::Release
//
//  Synopsis:   Per IUnknown
//
//-------------------------------------------------------------------------

ULONG CFakeUIWindow::Release()
{
    return Doc()->SubRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IOleWindow ||
        iid == IID_IOleInPlaceUIWindow)
    {
        *ppv = (IOleInPlaceUIWindow *)this;
    }
    else if (this == &Doc()->_FakeInPlaceFrame &&
        iid == IID_IOleInPlaceFrame)
    {
        *ppv = (IOleInPlaceFrame *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::GetWindow, IOleWindow
//
//  Synopsis:   Get HWND
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::GetWindow(HWND *phwnd)
{
    RRETURN(THR(RealInPlaceUIWindow()->GetWindow(phwnd)));
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::ContextSensitiveHelp, IOleWindow
//
//  Synopsis:   Controls enabling of context sensitive help.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::ContextSensitiveHelp(BOOL fEnterMode)
{
    RRETURN(THR(RealInPlaceUIWindow()->ContextSensitiveHelp(fEnterMode)));
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::GetBorderSpace, IOleInplaceUIWindow
//
//  Synopsis:   Get frame size.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::GetBorder(LPOLERECT lprectBorder)
{
    RRETURN(THR(RealInPlaceUIWindow()->GetBorder(lprectBorder)));
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::RequestBorderSpace, IOleInplaceUIWindow
//
//  Synopsis:   Get border space for tools.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    RRETURN(THR(RealInPlaceUIWindow()->RequestBorderSpace(pborderwidths)));
}


//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetBorderSpace, IOleInplaceUIWindow
//
//  Synopsis:   Get border space for tools.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    HRESULT hr = S_OK;

#ifndef NO_OLEUI
    if (pborderwidths)
    {
        Doc()->InPlace()->_fForwardSetBorderSpace = TRUE;
        Doc()->RemoveUI();
        hr = THR(RealInPlaceUIWindow()->SetBorderSpace(pborderwidths));
    }
    else
    {
        if (Doc()->InPlace()->_fForwardSetBorderSpace)
        {
            hr = THR(RealInPlaceUIWindow()->SetBorderSpace(pborderwidths));
            if (hr)
                RRETURN(hr);
            Doc()->InPlace()->_fForwardSetBorderSpace = FALSE;
        }
        
        if (Doc()->InPlace()->_fUIDown &&
            !Doc()->InPlace()->_fChildActivating &&
            !Doc()->InPlace()->_fDeactivating &&
            Doc()->State() >= OS_UIACTIVE)
        {
            hr = THR(Doc()->InstallUI(FALSE));
        }
    }
#endif // NO_OLEUI

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetActiveObject, IOleInplaceUIWindow
//
//  Synopsis:   Notify currently active object.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    IOleInPlaceUIWindow *   p = RealInPlaceUIWindow();
    HRESULT                 hr = S_OK;

    //
    // If an ocx is not going active and another ocx calls SetActiveObject
    // with NULL and we happen to be UI-Active, tell frame that we're the
    // active object instead.
    //
    
    if (p)
    {
        if (!pActiveObject && 
            !Doc()->InPlace()->_fChildActivating &&
            !Doc()->InPlace()->_fDeactivating &&
            Doc()->State() >= OS_UIACTIVE)
        {
            hr = THR(Doc()->SetActiveObject());
        }
        else
        {
            hr = THR(p->SetActiveObject(pActiveObject, pszObjName));
        }
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::InsertMenus, IOleInPlaceFrame
//
//  Synopsis:   Allow container to insert menus.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
#ifdef NO_OLEUI
	RRETURN(S_OK);
#else
    Doc()->RemoveUI();
    RRETURN(THR(InPlace()->_pFrame->InsertMenus(hmenuShared, lpMenuWidths)));
#endif // NO_OLEUI
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetMenu, IOleInPlaceFrame
//
//  Synopsis:   Add composite menu to window frame.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    HRESULT             hr = S_OK;

#ifndef NO_OLEUI
    if (InPlace() && InPlace()->_pFrame)
    {
        if (hmenuShared && holemenu)
        {
            Doc()->InPlace()->_fForwardSetMenu = TRUE;
            Doc()->RemoveUI();
            hr = THR(InPlace()->_pFrame->SetMenu(hmenuShared, holemenu, hwndActiveObject));
        }
        else
        {
            if (Doc()->InPlace()->_fForwardSetMenu)
            {
                hr = THR(InPlace()->_pFrame->SetMenu(
                        NULL, 
                        NULL, 
                        hwndActiveObject));
                if (hr)
                    RRETURN(hr);
                Doc()->InPlace()->_fForwardSetMenu = FALSE;
            }
            
            if (Doc()->InPlace()->_fUIDown &&
                !Doc()->InPlace()->_fChildActivating &&
                !Doc()->InPlace()->_fDeactivating &&
                Doc()->State() >= OS_UIACTIVE)
            {
                hr = THR(Doc()->InstallUI(FALSE));
            }
        }
    }
#endif // NO_OLEUI
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetMenu, IOleInPlaceFrame
//
//  Synopsis:   Remove container's menus.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::RemoveMenus(HMENU hmenuShared)
{
    HRESULT hr;

    if (hmenuShared && InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->RemoveMenus(hmenuShared));
    }
    else
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::SetStatusText, IOleInPlaceFrame
//
//  Synopsis:   Set and display status text.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::SetStatusText(LPCOLESTR pszStatusText)
{
    HRESULT hr;
    
    if (InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->SetStatusText(pszStatusText));
    }
    else
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::EnableModeless, IOleInPlaceFrame
//
//  Synopsis:   Enable / Disable modeless dialogs.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::EnableModeless(BOOL fEnable)
{
    HRESULT hr;
    
    if (InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->EnableModeless(fEnable));
    }
    else
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeUIWindow::TranslateAccelerator, IOleInPlaceFrame
//
//  Synopsis:   Translate keystrokes.
//
//-------------------------------------------------------------------------

HRESULT
CFakeUIWindow::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    HRESULT hr;

    if (InPlace() && InPlace()->_pFrame)
    {
        hr = THR(InPlace()->_pFrame->TranslateAccelerator(lpmsg, wID));
    }
    else
    {
        hr = S_FALSE;
    }
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CFakeInPlaceFrame::RealInPlaceUIWindow, CFakeUIWindow
//
//  Synopsis:   Return the true frame.
//
//-------------------------------------------------------------------------

IOleInPlaceUIWindow *
CFakeInPlaceFrame::RealInPlaceUIWindow()
{
    CDoc *pDoc = Doc();
    return pDoc->InPlace() ? pDoc->InPlace()->_pFrame : NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CFakeDocUIWindow::RealInPlaceUIWindow, CFakeUIWindow
//
//  Synopsis:   Return the true document window.
//
//-------------------------------------------------------------------------

IOleInPlaceUIWindow *
CFakeDocUIWindow::RealInPlaceUIWindow()
{
    return Doc()->InPlace()->_pDoc;
}

CDoc * CFakeDocUIWindow::Doc()
{
    return CONTAINING_RECORD(this, CDoc, _FakeDocUIWindow);
}   

CDoc * CFakeInPlaceFrame::Doc()
{
    return CONTAINING_RECORD(this, CDoc, _FakeInPlaceFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\folectrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olectrl.cxx
//
//  Contents:   Implementation of IOleControl methods
//
//  Classes:    CDoc (partial)
//
//  History:    05-Feb-94     LyleC    Created
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

extern BOOL g_fInPhotoSuiteIII;
extern BOOL g_fInIexplorer;
extern BOOL g_fDisableUnTrustedProtocol;

void
CDoc::GetLoadFlag(DISPID dispidProp)
{

    BOOL fVal = FALSE;
    DWORD dwCurrFlag = (dispidProp == DISPID_AMBIENT_SILENT) ? DLCTL_SILENT : DLCTL_OFFLINEIFNOTCONNECTED;
    fVal = GetAmbientBool(dispidProp, FALSE);
    if(fVal)
        _dwLoadf |= dwCurrFlag;
    else
        _dwLoadf &= (~dwCurrFlag);

    return;
}

HRESULT
CDoc::UpdateDocHostUI(BOOL fCalledFromSwitchMarkup /* = FALSE */)
{
    HRESULT hr = S_OK;

    DOCHOSTUIINFO   docHostUIInfo;
    CBodyElement *  pBody;
    DWORD           dwFlagsHostInfoOld = _dwFlagsHostInfo;
    
    if (!_pHostUIHandler)
    {
        goto Cleanup;
    }    

    // Initialize
    memset(&docHostUIInfo, 0, sizeof(DOCHOSTUIINFO));
    docHostUIInfo.cbSize = sizeof(DOCHOSTUIINFO);
    if (OK(_pHostUIHandler->GetHostInfo(&docHostUIInfo)))
    {
        if (g_fInIexplorer)
        {
            docHostUIInfo.dwFlags |= DOCHOSTUIFLAG_DISABLE_UNTRUSTEDPROTOCOL;
            g_fDisableUnTrustedProtocol = TRUE;
        }
        else if (docHostUIInfo.dwFlags & DOCHOSTUIFLAG_DISABLE_UNTRUSTEDPROTOCOL)
        {
            g_fDisableUnTrustedProtocol = TRUE;
        }

        if (docHostUIInfo.pchHostNS)
        {
            hr = THR(_cstrHostNS.Set(docHostUIInfo.pchHostNS));
            if (hr)
                goto Cleanup;
            
            hr = THR(EnsureExtendedTagTableHost());
            if (hr)
                goto Cleanup;
            
            hr = THR(_pExtendedTagTableHost->EnsureHostNamespaces());
            if (hr)
                goto Cleanup;
        }
        
        if (docHostUIInfo.pchHostCss)
        {
            hr = THR(_cstrHostCss.Set(docHostUIInfo.pchHostCss));
            if (hr)
                goto Cleanup;
            
            hr = THR(EnsureHostStyleSheets());
            if (hr)
                goto Cleanup;
            
            SetCssPeersPossible();
        }

        //
        // HACKALERT (jeffwall) PhotoSuite III wrongly changes the host flags when called from switchmarkup.  Bug 109411
        //
        if (!fCalledFromSwitchMarkup || ( fCalledFromSwitchMarkup && !g_fInPhotoSuiteIII ))
        {
            _dwFlagsHostInfo = docHostUIInfo.dwFlags;
        }

        // What we use for a default block tag.
        if (_dwFlagsHostInfo & DOCHOSTUIFLAG_DIV_BLOCKDEFAULT)
            SetDefaultBlockTag(ETAG_DIV);
        else
            SetDefaultBlockTag(ETAG_P);
        
        CoTaskMemFree(docHostUIInfo.pchHostCss);
        CoTaskMemFree(docHostUIInfo.pchHostNS);
    }
    
    IGNORE_HR(PrimaryMarkup()->GetBodyElement(&pBody));

    if (    pBody
        &&  dwFlagsHostInfoOld != _dwFlagsHostInfo
        &&  GetView()->IsActive())
    {
        pBody->ResizeElement();
    }
                
Cleanup:
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnAmbientPropertyChange, public
//
//  Synopsis:   Captures ambient property changes and takes appropriate action.
//
//  Arguments:  [dispidProp] -- Property which changed.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::OnAmbientPropertyChange(DISPID dispidProp)
{
    HRESULT         hr = S_OK;
    BOOL            fAll = (dispidProp == DISPID_UNKNOWN);
    BOOL            fMode;
    CNotification   nf;  

    // Update dochostui flags - helps us read DOCHOSTUIFLAG_FLAT_SCROILLBAR
    // correctly when we switch to/from full screen mode
    if (fAll && _pHostUIHandler)
    {
        hr = UpdateDocHostUI();
        if (hr)
            goto Cleanup;
    }

    if (fAll)
    {
        // Update the scrollbar info
        IGNORE_HR(OnFrameOptionScrollChange());
    }

    // Check to see if DesignMode should be set. If the ambient is
    // not supported by the client site then set DesignMode.

    if ((fAll || dispidProp == DISPID_AMBIENT_USERMODE) &&
            PrimaryMarkup()->_fInheritDesignMode)
    {
        BOOL fDesignMode = PrimaryMarkup()->_fDesignMode;
        if (!PrimaryMarkup()->_fFrameSet)
        {
            fMode = !GetAmbientBool(DISPID_AMBIENT_USERMODE, !fDesignMode);
        }
        else
        {
            // Can't go into edit (design) mode if our top-level site is a
            // frameset.
            fMode = FALSE;
        }

        if (fMode != fDesignMode)
        {
            IGNORE_HR(UpdateDesignMode(PrimaryMarkup()->Document(), fMode));
        }

    }

    if (fAll ||
        dispidProp == DISPID_AMBIENT_DLCONTROL ||
        dispidProp == DISPID_AMBIENT_SILENT ||
        dispidProp == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED)
    {
        CVariant var;

        if (!GetAmbientVariant(DISPID_AMBIENT_DLCONTROL, &var) &&
            V_VT(&var) == VT_I4)
        {
            _dwLoadf = (DWORD) V_I4(&var);
            _fGotAmbientDlcontrol = TRUE;
        }
        else
        {
            _fGotAmbientDlcontrol = FALSE;
            if (fAll)
            {
                GetLoadFlag(DISPID_AMBIENT_SILENT);
                GetLoadFlag(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);
            }
            else
            {
                Assert(dispidProp == DISPID_AMBIENT_SILENT ||
                       dispidProp == DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);
                GetLoadFlag(dispidProp);
            }
        }
    }

    if (fAll || dispidProp == DISPID_AMBIENT_USERAGENT)
    {
        FormsFreeString(_bstrUserAgent);
        GetAmbientBstr(DISPID_AMBIENT_USERAGENT, &_bstrUserAgent);
    }

    if (fAll || dispidProp == DISPID_AMBIENT_PALETTE)
    {
        HPALETTE hpalAmbient = GetAmbientPalette();

        if (hpalAmbient != _hpalAmbient)
        {
            _hpalAmbient = hpalAmbient;
            _fHtAmbientPalette = IsHalftonePalette(hpalAmbient);
            
            Invalidate();
            if (_hpalDocument)
            {
                DeleteObject(_hpalDocument);
                _hpalDocument = 0;
                _fHtDocumentPalette = FALSE;
            }
        }
    }

    //
    // Forward to all the sites.
    //

    if (CMarkup::GetElementClientHelper(PrimaryMarkup()))
    {
        nf.AmbientPropChange(PrimaryRoot(), (void *)(DWORD_PTR)dispidProp);
        BroadcastNotify(&nf);
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnControlInfoChanged, public
//
//  Synopsis:   To be called when our control info has changed.  This normally
//              happens when a site gets an OnControlInfoChanged call from
//              its control.  Calls OnControlInfoChanged on our site.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------
void
CDoc::OnControlInfoChanged(DWORD_PTR dwContext)
{
    IOleControlSite * pCtrlSite;

    if (_pClientSite &&
        OK(_pClientSite->QueryInterface(IID_IOleControlSite, (void **) &pCtrlSite)))
    {
        IGNORE_HR(pCtrlSite->OnControlInfoChanged());
        pCtrlSite->Release();
    }

    _fOnControlInfoChangedPosted = FALSE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetControlInfo, public
//
//  Synopsis:   Returns a filled-in CONTROLINFO.
//
//  Arguments:  [pCI] -- CONTROLINFO to fill in
//
//  Returns:    HRESULT
//
//  Notes:      Note that the hAccel we hand out is not valid past our own
//              lifetime, because we call DestroyAcceleratorTable in our
//              destructor.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::GetControlInfo(CONTROLINFO *pCI)
{
#ifdef WIN16
    MessageBox(NULL, "CDoc::GetControlInfo:: need CreateAcceleratorTable.", "BUGWIN16", MB_OK);
    return E_FAIL;
#else
    ACCEL       aaccel[2];

    if (!pCI)
        RRETURN(E_POINTER);

    // TODO -- is this desired behavior?
    if (pCI->cb != sizeof(CONTROLINFO))
        RRETURN(E_INVALIDARG);

    pCI->cAccel = 0;

    aaccel[0].fVirt = FVIRTKEY | FALT | FCONTROL | FSHIFT;
    aaccel[0].key   = 0;    // any key
    aaccel[0].cmd   = 0;    // Not used.

    aaccel[1].fVirt = FALT | FCONTROL | FSHIFT;
    aaccel[1].key   = 0;    // any key
    aaccel[1].cmd   = 0;    // Not used.

    pCI->hAccel = CreateAcceleratorTable(aaccel, 2);
    if (pCI->hAccel == NULL)
        return E_OUTOFMEMORY;

    pCI->cAccel = 2;

    //
    // We don't eat return or escape because we always delegate those keys
    // to our parent before we take action on them.
    //
    pCI->dwFlags = 0;

    //  CONSIDER don't we eat return or escape if the active control in
    //    the form eats it?


    return S_OK;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnMnemonic, public
//
//  Synopsis:   Indicates one of our mnemonics has been pressed by the user
//              and we need to take the appropriate action.
//
//  Arguments:  [pMsg] -- Message which corresponds to a mnemonic.
//
//  Returns:    S_OK
//
//  History:    02-Feb-94     LyleC    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::OnMnemonic(LPMSG lpmsg)
{
    HRESULT hr;
    CMessage Message(lpmsg);

    hr = TransitionTo(OS_UIACTIVE);
    if (!hr)
    {
        hr = PumpMessage(&Message, PrimaryRoot()->GetFirstBranch());
    }

    RRETURN1(hr, S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CDoc::FreezeEvents
//
//  Synopsis:   Broadcast the freeze events notification to all of our
//              controls
//
//  Arguments:  [fFreeze]   TRUE if events are being frozen by the
//                          development environment, FALSE if not.
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDoc::FreezeEvents(BOOL fFreeze)
{
    //
    // Assert that the freeze count is not going below zero.
    //
    //AssertSz(fFreeze || _cFreeze, "Too many FreezeEvents(FALSE) calls received by the document");

    _cFreeze = fFreeze ? _cFreeze + 1 : _cFreeze - 1;



    //
    // Notify sites if there was a change in freeze status
    //

    if (    _fHasOleSite
        &&  CMarkup::GetElementClientHelper(PrimaryMarkup())
        &&  (!_cFreeze || (fFreeze && (_cFreeze == 1))))
    {
        CNotification   nf;
        nf.FreezeEvents(PrimaryRoot(), (void *)(DWORD_PTR)fFreeze);
        BroadcastNotify(&nf);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\formats.cxx ===
//+ ---------------------------------------------------------------------------
//
//  File:       formats.cxx
//
//  Contents:   ComputeFormats and associated utilities
//
//  Classes:
//
// ----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FCACHE_HXX_
#define X_FCACHE_HXX_
#include "fcache.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_CURSTYLE_HXX_
#define X_CURSTYLE_HXX_
#include "curstyle.hxx"
#endif

#ifndef X_FILTCOL_HXX_
#define X_FILTCOL_HXX_
#include "filtcol.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_RECALC_H_
#define X_RECALC_H_
#include "recalc.h"
#endif

#ifndef X_RECALC_HXX_
#define X_RECALC_HXX_
#include "recalc.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_CUSTCUR_HXX_
#define X_CUSTCUR_HXX_
#include "custcur.hxx"
#endif

#ifndef X_LOI_HXX_
#define X_LOI_HXX_
#include <loi.hxx>
#endif

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif


// Debugging ------------------------------------------------------------------

DeclareTag(tagMetrics, "Metrics", "Metrics");
DeclareTag(tagFormatCaches, "FormatCaches", "Trace format caching");
DeclareTag(tagNoPrintFilters, "Filter", "Don't print filters");
ExternTag(tagRecalcStyle);
ExternTag(tagLayoutTasks);
MtExtern( CCustomCursor)

PerfDbgExtern(tagDataCacheDisable);
MtDefine(THREADSTATE_pCharFormatCache, THREADSTATE, "THREADSTATE::_pCharFormatCache")
MtDefine(THREADSTATE_pParaFormatCache, THREADSTATE, "THREADSTATE::_pParaFormatCache")
MtDefine(THREADSTATE_pFancyFormatCache, THREADSTATE, "THREADSTATE::_pFancyFormatCache")
MtDefine(THREADSTATE_pStyleExpandoCache, THREADSTATE, "THREADSTATE::_pStyleExpandoCache")
MtDefine(THREADSTATE_pLineInfoCache, THREADSTATE, "THREADSTATE::_pLineInfoCache")
MtDefine(THREADSTATE_pPseudoElementInfoCache, THREADSTATE, "THREADSTATE::_pPseudoElementInfoCache")
MtDefine(THREADSTATE_pCustomCursorCache, THREADSTATE, "THREADSTATE::_pCustomCursorCache")
MtDefine(CStyleSheetHref, CStyleSheet, "CStyleSheet::GetAbsoluteHref")
MtDefine(ComputeFormats, Metrics, "ComputeFormats")
MtDefine(CharFormatAddRef, ComputeFormats, "CharFormat simple AddRef")
MtDefine(CharFormatTouched, ComputeFormats, "CharFormat touched needlessly")
MtDefine(CharFormatCached, ComputeFormats, "CharFormat cached")
MtDefine(ParaFormatAddRef, ComputeFormats, "ParaFormat simple AddRef")
MtDefine(ParaFormatTouched, ComputeFormats, "ParaFormat touched needlessly")
MtDefine(ParaFormatCached, ComputeFormats, "ParaFormat cached")
MtDefine(FancyFormatAddRef, ComputeFormats, "FancyFormat simple AddRef")
MtDefine(FancyFormatTouched, ComputeFormats, "FancyFormat touched needlessly")
MtDefine(FancyFormatCached, ComputeFormats, "FancyFormat cached")
MtDefine(CharParaFormatVoided, ComputeFormats, "Char/ParaFormat voided");
MtDefine(FancyFormatVoided, ComputeFormats, "FancyFormat voided");
MtDefine(StyleExpandoCached, ComputeFormats, "StyleExpando cached")
MtDefine(StyleExpandoAddRef, ComputeFormats, "StyleExpando simple AddRef")
MtDefine(PseudoElementInfoCached, ComputeFormats, "Pseudo element info cached")
MtDefine(PseudoElementInfoAddRef, ComputeFormats, "Pseudo element info simple AddRef")

#ifdef MULTI_FORMAT
MtDefine(CFormatTable_aryFC_pv, ComputeFormats, "CFormatTable::_aryFC::_pv")
#endif //MULTI_FORMAT

// Globals --------------------------------------------------------------------

CCharFormat     g_cfStock;
CParaFormat     g_pfStock;
CFancyFormat    g_ffStock;
CLineOtherInfo  g_loiStock;
BOOL            g_fStockFormatsInitialized = FALSE;

#define MAX_FORMAT_INDEX 0x7FFF

// Thread Init + Deinit -------------------------------------------------------

void
DeinitFormatCache (THREADSTATE * pts)
{
#if DBG == 1
    if(pts->_pCharFormatCache)
    {
        TraceTag((tagMetrics, "Format Metrics:"));

        TraceTag((tagMetrics, "\tSize of formats char:%ld para:%ld fancy: %ld",
                                sizeof (CCharFormat),
                                sizeof (CParaFormat),
                                sizeof (CFancyFormat)));

        TraceTag((tagMetrics, "\tMax char format cache entries: %ld",
                                pts->_pCharFormatCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax para format cache entries: %ld",
                                pts->_pParaFormatCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax fancy format cache entries: %ld",
                                pts->_pFancyFormatCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax currentStyle expando cache entries: %ld",
                                pts->_pStyleExpandoCache->_cMaxEls));
        TraceTag((tagMetrics, "\tMax CustomCursor cache entries: %ld",
                                pts->_pCustomCursorCache->_cMaxEls));                                
    }
#endif

    if (pts->_pParaFormatCache)
    {
        if (pts->_ipfDefault >= 0)
            pts->_pParaFormatCache->ReleaseData(pts->_ipfDefault);
        delete pts->_pParaFormatCache;
        pts->_pParaFormatCache = NULL;
    }

    if (pts->_pFancyFormatCache)
    {
        if (pts->_iffDefault >= 0)
            pts->_pFancyFormatCache->ReleaseData(pts->_iffDefault);
        delete pts->_pFancyFormatCache;
        pts->_pFancyFormatCache = NULL;
    }

    
    delete pts->_pCharFormatCache;
    pts->_pCharFormatCache = NULL;
    
    delete pts->_pStyleExpandoCache;
    pts->_pStyleExpandoCache = NULL;
    
    delete pts->_pLineInfoCache;
    pts->_pLineInfoCache = NULL;

    delete pts->_pCustomCursorCache;
    pts->_pCustomCursorCache = NULL;

    if (pts->_pPseudoElementInfoCache)
    {
        if (pts->_iPEIDefault >= 0)
            pts->_pPseudoElementInfoCache->ReleaseData(pts->_iPEIDefault);
        delete pts->_pPseudoElementInfoCache;
        pts->_pPseudoElementInfoCache = NULL;
    }
}

HRESULT InitFormatCache(THREADSTATE * pts)                     // Called by CDoc::Init()
{
    CParaFormat pf;
    CFancyFormat ff;
    CPseudoElementInfo pei;
    HRESULT hr = S_OK;

#ifdef GENERALISED_STEALING
    void InitETagsTable();
    
    InitETagsTable();
#endif
    
    if (!g_fStockFormatsInitialized)
    {
        g_cfStock._ccvTextColor = RGB(0,0,0);
        g_ffStock._ccvBackColor = RGB(0xff, 0xff, 0xff);
        g_pfStock._lFontHeightTwips = 240;
        g_loiStock.InitDefault();

        //we only set this bit in Stock object. This prevents
        //successful comparisions with Stock object and therefore,
        //it prevents -1 from being a valid index in the LOI cache.
        //So we can Assert(iLOI == -1) in suspicious places.
        g_loiStock._fIsStockObject = 1;

        g_fStockFormatsInitialized = TRUE;
    }

    pts->_pCharFormatCache = new(Mt(THREADSTATE_pCharFormatCache)) CCharFormatCache;
    if(!pts->_pCharFormatCache)
        goto MemoryError;

    pts->_pParaFormatCache = new(Mt(THREADSTATE_pParaFormatCache)) CParaFormatCache;
    if(!pts->_pParaFormatCache)
        goto MemoryError;

    pts->_ipfDefault = -1;
    pf.InitDefault();
    pf._fHasDirtyInnerFormats = pf.AreInnerFormatsDirty();
    hr = THR(pts->_pParaFormatCache->CacheData(&pf, &pts->_ipfDefault));
    if (hr)
        goto Cleanup;

    pts->_ppfDefault = &(*pts->_pParaFormatCache)[pts->_ipfDefault];

    pts->_pFancyFormatCache = new(Mt(THREADSTATE_pFancyFormatCache)) CFancyFormatCache;
    if(!pts->_pFancyFormatCache)
        goto MemoryError;

    pts->_iffDefault = -1;
    ff.InitDefault();
    hr = THR(pts->_pFancyFormatCache->CacheData(&ff, &pts->_iffDefault));
    if (hr)
        goto Cleanup;

    pts->_pffDefault = &(*pts->_pFancyFormatCache)[pts->_iffDefault];

    pts->_pStyleExpandoCache = new(Mt(THREADSTATE_pStyleExpandoCache)) CStyleExpandoCache;
    if(!pts->_pStyleExpandoCache)
        goto MemoryError;

    pts->_pLineInfoCache = new(Mt(THREADSTATE_pLineInfoCache)) CLineInfoCache;
    if(!pts->_pLineInfoCache)
        goto MemoryError;
    pts->_iloiCache = -1;

    pts->_iPEIDefault = -1;
    pts->_pPseudoElementInfoCache = new(Mt(THREADSTATE_pPseudoElementInfoCache)) CPseudoElementInfoCache;
    if (!pts->_pPseudoElementInfoCache)
        goto MemoryError;
    pei.InitDefault();
    hr = THR(pts->_pPseudoElementInfoCache->CacheData(&pei, &pts->_iPEIDefault));
    if (hr)
        goto MemoryError;
    pts->_pPEIDefault = &(*pts->_pPseudoElementInfoCache)[pts->_iPEIDefault];

    pts->_pCustomCursorCache = new(Mt(THREADSTATE_pCustomCursorCache)) CCustomCursorCache;
    if(!pts->_pCustomCursorCache)
        goto MemoryError;

    
Cleanup:
    RRETURN(hr);

MemoryError:
    DeinitFormatCache(pts);
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureUserStyleSheets
//
//  Synopsis:   Ensure the user stylesheets collection exists if specified by
//              user in option setting, creates it if not..
//
//----------------------------------------------------------------------------

HRESULT EnsureUserStyleSheets(LPTSTR pchUserStylesheet)
{
    CCSSParser       *pcssp;
    HRESULT          hr = S_OK;
    CStyleSheetArray *pUSSA = TLS(pUserStyleSheets);
    CStyleSheet      *pUserStyleSheet = NULL;  // The stylesheet built from user specified file in Option settings
    const TCHAR      achFileProtocol[8] = _T("file://");

    if (pUSSA)
    {
        if (!_tcsicmp(pchUserStylesheet, pUSSA->_cstrUserStylesheet))
            goto Cleanup;
        else
        {
            // Force the user stylesheets collection to release its refs on stylesheets/rules.
            // No need to rel as no owner,
            pUSSA->Free( );

            // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
            // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
            pUSSA->CBase::PrivateRelease();
            pUSSA = TLS(pUserStyleSheets) = NULL;
        }
    }

    // bail out if user SS file is not specified, but "Use My Stylesheet" is checked in options
    if (!*pchUserStylesheet)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pUSSA = new CStyleSheetArray(NULL, NULL, 0);
    if (!pUSSA || pUSSA->_fInvalid)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pUSSA->CreateNewStyleSheet(NULL, &pUserStyleSheet));
    if (!SUCCEEDED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE);  // need download...
    hr = S_OK;

    pcssp = new CCSSParser(pUserStyleSheet, NULL);
    if (!pcssp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(!pUserStyleSheet->GetAbsoluteHref() && "absoluteHref already computed.");

    pUserStyleSheet->SetAbsoluteHref((TCHAR *)MemAlloc(Mt(CStyleSheetHref), (_tcslen(pchUserStylesheet) + ARRAY_SIZE(achFileProtocol)) * sizeof(TCHAR)));
    if (! pUserStyleSheet->GetAbsoluteHref())
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy(pUserStyleSheet->GetAbsoluteHref(), achFileProtocol);
    _tcscat(pUserStyleSheet->GetAbsoluteHref(), pchUserStylesheet);

    hr = THR(pcssp->LoadFromFile(pchUserStylesheet, g_cpDefault));
    delete pcssp;
    if (hr)
        goto Cleanup;

    TLS(pUserStyleSheets) = pUSSA;
    pUSSA->_cstrUserStylesheet.Set(pchUserStylesheet);

Cleanup:
    if (hr && pUSSA)
    {
        // Force the user stylesheets collection to release its refs on stylesheets/rules.
        // No need to rel as no owner,
        pUSSA->Free( );

        // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
        // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
        pUSSA->CBase::PrivateRelease();
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureUserStyleSheets
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureUserStyleSheets()
{
    HRESULT     hr = S_OK;
    CStyleSheetArray *pUSSA = TLS(pUserStyleSheets);

    if (   _pOptionSettings 
        && _pOptionSettings->fUseMyStylesheet 
        && !_pOptionSettings->cstrUserStylesheet.IsNull())
    {
        hr = THR(::EnsureUserStyleSheets(_pOptionSettings->cstrUserStylesheet));
    }
    else if (pUSSA)
    {
        // Force the user stylesheets collection to release its refs on stylesheets/rules.
        // No need to rel as no owner,
        pUSSA->Free( );

        // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
        // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
        pUSSA->CBase::PrivateRelease();
        TLS(pUserStyleSheets) = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   DeinitUserStyleSheets
//
//  Synopsis:   Deallocates thread local memory for User supplied Style
//              sheets if allocated. Called from DllThreadDetach.
//
//-------------------------------------------------------------------------

void DeinitUserStyleSheets(THREADSTATE *pts)
{
    if (pts->pUserStyleSheets)
    {
        // Force the user stylesheets collection to release its refs on stylesheets/rules.
        // No need to rel as no owner,
        pts->pUserStyleSheets->Free( );

        // Destroy stylesheets collection subobject. delete is not directly called in order to assure that
        // the CBase part of the CSSA is properly destroyed (CBase::Passivate gets called etc.)
        pts->pUserStyleSheets->CBase::PrivateRelease();
        pts->pUserStyleSheets = NULL;
    }
}

// Default CharFormat ---------------------------------------------------------

HRESULT
CMarkup::CacheDefaultCharFormat()
{
    CDoc * pDoc = Doc();

    Assert(!_fDefaultCharFormatCached);
    Assert(pDoc->_pOptionSettings);
    Assert(pDoc->_icfDefault == -1 || !_fHasDefaultCharFormat);

    THREADSTATE * pts = GetThreadState();
    CCharFormat cf;
    HRESULT hr = S_OK;

    cf.InitDefault(pDoc->_pOptionSettings, GetCodepageSettings());
    cf._bCrcFont = cf.ComputeFontCrc();
    cf._fHasDirtyInnerFormats = !!cf.AreInnerFormatsDirty();

    if (pDoc->_icfDefault < 0)
    {
        hr = THR(pts->_pCharFormatCache->CacheData(&cf, &pDoc->_icfDefault));
        if (hr == S_OK)
            pDoc->_pcfDefault = &(*pts->_pCharFormatCache)[pDoc->_icfDefault];
        else
            pDoc->_icfDefault = -1;
    }
    else if (memcmp(&cf, pDoc->_pcfDefault, sizeof(CCharFormat)))
    {
        long icfDefault;

        hr = THR(pts->_pCharFormatCache->CacheData(&cf, &icfDefault));
        if (S_OK == hr)
        {
            hr = SetDefaultCharFormatIndex(icfDefault);
            if (S_OK == hr)
                _fHasDefaultCharFormat = TRUE;
        }
    }

    _fDefaultCharFormatCached = TRUE;

    RRETURN(hr);
}

void
CMarkup::ClearDefaultCharFormat()
{
    if (_fHasDefaultCharFormat)
    {
        TLS(_pCharFormatCache)->ReleaseData(GetDefaultCharFormatIndex());
        _fHasDefaultCharFormat = FALSE;
    }
    _fDefaultCharFormatCached = FALSE;
}

void
CDoc::ClearDefaultCharFormat()
{
    if (_icfDefault >= 0)
    {
        TLS(_pCharFormatCache)->ReleaseData(_icfDefault);
        _icfDefault = -1;
        _pcfDefault = NULL;
    }
}

// CFormatInfo ----------------------------------------------------------------

#if DBG==1

void
CFormatInfo::UnprepareForDebug()
{
    _fPreparedCharFormatDebug = FALSE;
    _fPreparedParaFormatDebug = FALSE;
    _fPreparedFancyFormatDebug = FALSE;
    _fPreparedPEIDebug = FALSE;
}

void
CFormatInfo::PrepareCharFormat()
{
    if (!_fPreparedCharFormat)
        PrepareCharFormatHelper();
    _fPreparedCharFormatDebug = TRUE;
}

void
CFormatInfo::PrepareParaFormat()
{
    if (!_fPreparedParaFormat)
        PrepareParaFormatHelper();
    _fPreparedParaFormatDebug = TRUE;
}

void
CFormatInfo::PrepareFancyFormat()
{
    if (!_fPreparedFancyFormat)
        PrepareFancyFormatHelper();
    _fPreparedFancyFormatDebug = TRUE;
}

void
CFormatInfo::PreparePEI()
{
    if (!_fPreparedPEI)
        PreparePEIHelper();
    _fPreparedPEIDebug = TRUE;
}

CCharFormat &
CFormatInfo::_cf()
{
    AssertSz(_fPreparedCharFormatDebug, "Attempt to access _cf without calling PrepareCharFormat");
    return(_cfDst);
}

CParaFormat &
CFormatInfo::_pf()
{
    AssertSz(_fPreparedParaFormatDebug, "Attempt to access _pf without calling PrepareParaFormat");
    return(_pfDst);
}

CFancyFormat &
CFormatInfo::_ff()
{
    AssertSz(_fPreparedFancyFormatDebug, "Attempt to access _ff without calling PrepareFancyFormat");
    return(_ffDst);
}

CPseudoElementInfo &
CFormatInfo::_pei()
{
    AssertSz(_fPreparedPEIDebug, "Attempt to access _PEI without calling PreparePEI");
    return(_PEI);
}

#endif

void
CFormatInfo::Cleanup()
{
    if (_pAAExpando)
    {
        _pAAExpando->Free();
        _pAAExpando = NULL;
    }

    if ( _pCustomCursor )
    {
        delete _pCustomCursor;
        _pCustomCursor = NULL;
    }
    _cstrBgImgUrl.Free();
    _cstrLiImgUrl.Free();
    _cstrFilters.Free();
    _cstrPseudoBgImgUrl.Free();
}


CAttrArray *
CFormatInfo::GetAAExpando()
{
    if (_pAAExpando == NULL)
    {
        memset(&_AAExpando, 0, sizeof(_AAExpando));
        _pAAExpando = &_AAExpando;

        if (_pff->_iExpandos >= 0)
        {
            IGNORE_HR(_pAAExpando->CopyExpandos(GetExpandosAttrArrayFromCacheEx(_pff->_iExpandos)));
        }

        _fHasExpandos = TRUE;
    }

    return(_pAAExpando);
}


CCustomCursor*
CFormatInfo::GetCustomCursor()
{
    if (_pCustomCursor == NULL)
    {
        _pCustomCursor = new CCustomCursor();        
    }

    return(_pCustomCursor);
}

void
CFormatInfo::PrepareCharFormatHelper()
{
    Assert(_pcfSrc != NULL && _pcf == _pcfSrc);
    _pcf = &_cfDst;
    memcpy(&_cfDst, _pcfSrc, sizeof(CCharFormat));
    _fPreparedCharFormat = TRUE;
}

void
CFormatInfo::PrepareParaFormatHelper()
{
    Assert(_ppfSrc != NULL && _ppf == _ppfSrc);
    _ppf = &_pfDst;
    memcpy(&_pfDst, _ppfSrc, sizeof(CParaFormat));
    _fPreparedParaFormat = TRUE;
}

void
CFormatInfo::PrepareFancyFormatHelper()
{
    Assert(_pffSrc != NULL && _pff == _pffSrc);
    _pff = &_ffDst;
    memcpy(&_ffDst, _pffSrc, sizeof(CFancyFormat));
    _fPreparedFancyFormat = TRUE;
}

void
CFormatInfo::PreparePEIHelper()
{
    _PEI.InitDefault();
    _fPreparedPEI = TRUE;
}

HRESULT
CFormatInfo::ProcessImgUrl(CElement * pElem, LPCTSTR lpszUrl, DISPID dispID,
    LONG * plCookie, BOOL fHasLayout)
{
    HRESULT hr = S_OK;
    BOOL fForPseudo =    dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE
                      || dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER

                      // These two take care to not reload bg images for
                      // for element backgrounds if the element has any
                      // pseudo-element on it.
                      || _ppf->_fHasPseudoElement           // Normal compute formats
                      || pElem->GetMarkup()->HasCFState();  // Pseudoelement compute formats

        
    if (lpszUrl && *lpszUrl)
    {
        NoStealing();
        hr = THR(pElem->GetImageUrlCookie(lpszUrl, plCookie, !fForPseudo));
        if (hr)
            goto Cleanup;
    }
    else
    {
        //
        // Return a null cookie.
        //
        *plCookie = 0;
    }

    hr = THR(pElem->AddImgCtx(dispID, *plCookie));
    if (hr)
    {
        pElem->Doc()->ReleaseUrlImgCtx(*plCookie, pElem);
        goto Cleanup;
    }


    if (dispID == DISPID_A_LIURLIMGCTXCACHEINDEX)
    {
        // url images require a request resize when modified
        pElem->_fResizeOnImageChange = *plCookie != 0;
    }
    else if (   dispID == DISPID_A_BGURLIMGCTXCACHEINDEX
             || dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE
             || dispID == DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER
            )
    {
        // sites draw their own background, so we don't have to inherit
        // their background info
        if (!fHasLayout)
        {
            PrepareCharFormat();
            _cf()._fHasBgImage = (*plCookie != 0);
            UnprepareForDebug();
        }
    }

Cleanup:
    RRETURN(hr);
}

// ComputeFormats Helpers -----------------------------------------------------

const CCharFormat *
CTreeNode::GetCharFormatHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context (except in a few cases)
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM))) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM);
#ifdef MULTI_FORMAT
    long iCF = GetICF(FCPARAM);        
    return(iCF >= 0 ? GetCharFormatEx(iCF) : &g_cfStock);
#else
    return(_iCF >= 0 ? GetCharFormatEx(_iCF) : &g_cfStock);
#endif //MULTI_FORMAT
}

const CParaFormat *
CTreeNode::GetParaFormatHelper( FORMAT_CONTEXT FCPARAM)
{
    // If we shold have context, we should be called with context 
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM))) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM);
#ifdef MULTI_FORMAT
    long iPF = GetIPF(FCPARAM);        
    return(iPF >= 0 ? GetParaFormatEx(iPF) : &g_pfStock);
#else
    return(_iPF >= 0 ? GetParaFormatEx(_iPF) : &g_pfStock);
#endif //MULTI_FORMAT
}

const CFancyFormat *
CTreeNode::GetFancyFormatHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context 
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM))) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM);
#ifdef MULTI_FORMAT
    long iFF = GetIFF(FCPARAM);        
    return(iFF >= 0 ? GetFancyFormatEx(iFF) : &g_ffStock);
#else
    return(_iFF >= 0 ? GetFancyFormatEx(_iFF) : &g_ffStock);
#endif //MULTI_FORMAT
}

long
CTreeNode::GetCharFormatIndexHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM)) ) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM );
    
    return(GetICF(FCPARAM));
}

long
CTreeNode::GetParaFormatIndexHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM)) ) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM );
    
    return(GetIPF(FCPARAM));
}

long
CTreeNode::GetFancyFormatIndexHelper( FORMAT_CONTEXT FCPARAM )
{
    // If we shold have context, we should be called with context
    Assert ( ! (ShouldHaveContext() && !(IS_FC(FCPARAM)) ) );
    
    BYTE ab[sizeof(CFormatInfo)];
    ((CFormatInfo *)ab)->_eExtraValues = ComputeFormatsType_Normal;
    ((CFormatInfo *)ab)->_lRecursionDepth = 0;
    Element()->ComputeFormats((CFormatInfo *)ab, this FCCOMMA FCPARAM );
    
    return(GetIFF(FCPARAM));
}

//+----------------------------------------------------------------------------
//
//  Member:     CNode::CacheNewFormats
//
//  Synopsis:   This function is called on conclusion on ComputeFormats
//              It caches the XFormat's we have just computed.
//              This exists so we can share more code between
//              CElement::ComputeFormats and CTable::ComputeFormats
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------------

HRESULT
CTreeNode::CacheNewFormats(CFormatInfo * pCFI FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    THREADSTATE * pts = GetThreadState();
    LONG lIndex, iExpando = -1, iPEI = -1, iCustomCursor = -1 ;
    HRESULT hr = S_OK;
    
#ifdef MULTI_FORMAT
    if (!EnsureFormatAry()) 
    {
        goto Error;
    }
#endif

    Assert(   (   GetICF(FCPARAM) == -1 
               && GetIPF(FCPARAM) == -1
              )
           || (   GetICF(FCPARAM) != -1 
               && GetIPF(FCPARAM) != -1
              )
          );
    Assert(GetIFF(FCPARAM) == -1);
   
#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDataCacheDisable))
    {
        pCFI->PrepareCharFormat();
        pCFI->PrepareParaFormat();
        pCFI->PrepareFancyFormat();
    }
#endif

    if ( GetICF(FCPARAM) == -1 )
    {
        //
        // CCharFormat
        //

        if (!pCFI->_fPreparedCharFormat)
        {
            MtAdd(Mt(CharFormatAddRef), 1, 0);
            SetICF(pCFI->_icfSrc FCCOMMA FCPARAM);
            pts->_pCharFormatCache->AddRefData(pCFI->_icfSrc);
        }
        else
        {
            WHEN_DBG(pCFI->_fPreparedCharFormatDebug = TRUE;)

            pCFI->_cf()._bCrcFont = pCFI->_cf().ComputeFontCrc();
            pCFI->_cf()._fHasDirtyInnerFormats = !!pCFI->_cf().AreInnerFormatsDirty();

            MtAdd(pCFI->_pcfSrc->Compare(&pCFI->_cf()) ? Mt(CharFormatTouched) : Mt(CharFormatCached), 1, 0);

            hr = THR(pts->_pCharFormatCache->CacheData(&pCFI->_cf(), &lIndex));
            if (hr)
                goto Error;

            //protection from overflowing 15-bit _iCF... Use stock, don't crash (IE6 26698)
            if(lIndex >= MAX_FORMAT_INDEX)
            {
                CMarkup *pMarkup = GetMarkup();
                if(pMarkup && pMarkup->_fDefaultCharFormatCached)
                {
                    pts->_pCharFormatCache->ReleaseData(lIndex);

                    Assert(Doc()->_icfDefault != -1 || pMarkup->_fHasDefaultCharFormat);

                    if (pMarkup->_fHasDefaultCharFormat)
                    {
                        lIndex = pMarkup->GetDefaultCharFormatIndex(); 
                    }
                    else
                    {
                        lIndex = Doc()->_icfDefault;
                    }

                    pts->_pCharFormatCache->AddRefData(lIndex);
                }
            }

            Assert(lIndex < MAX_FORMAT_INDEX && lIndex >= 0);
            SetICF(lIndex FCCOMMA FCPARAM);
        }

        //
        // ParaFormat
        //

        if (!pCFI->_fPreparedParaFormat)
        {
            MtAdd(Mt(ParaFormatAddRef), 1, 0);
            SetIPF(pCFI->_ipfSrc FCCOMMA FCPARAM);
            pts->_pParaFormatCache->AddRefData(pCFI->_ipfSrc);
        }
        else
        {
            WHEN_DBG(pCFI->_fPreparedParaFormatDebug = TRUE;)

            pCFI->_pf()._fHasDirtyInnerFormats = pCFI->_pf().AreInnerFormatsDirty();

            MtAdd(pCFI->_ppfSrc->Compare(&pCFI->_pf()) ? Mt(ParaFormatTouched) : Mt(ParaFormatCached), 1, 0);

            hr = THR(pts->_pParaFormatCache->CacheData(&pCFI->_pf(), &lIndex));
            if (hr)
                goto Error;

            //protection from overflowing 15-bit _iPF... Use stock, don't crash (IE6 26698)
            if(lIndex >= MAX_FORMAT_INDEX)
            {
                pts->_pParaFormatCache->ReleaseData(lIndex);
                lIndex = pts->_ipfDefault; 
                pts->_pParaFormatCache->AddRefData(lIndex);
            }

            Assert( lIndex < MAX_FORMAT_INDEX && lIndex >= 0 );
            SetIPF(lIndex FCCOMMA FCPARAM);
           
        }

        TraceTag((
            tagFormatCaches,
            "Caching char & para format for "
            "element (tag: %ls, SN: E%d N%d) in %d, %d",
            Element()->TagName(), Element()->SN(), SN(), _iCF, _iPF ));
    }

    //
    // CFancyFormat
    //

    if (pCFI->_pAAExpando)
    {
        MtAdd(Mt(StyleExpandoCached), 1, 0);

        hr = THR(pts->_pStyleExpandoCache->CacheData(pCFI->_pAAExpando, &iExpando));
        if (hr)
            goto Error;

        if (pCFI->_pff->_iExpandos != iExpando)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._iExpandos = iExpando;
            pCFI->UnprepareForDebug();
        }

        pCFI->_pAAExpando->Free();
        pCFI->_pAAExpando = NULL;
    }
    else
    {
        #ifdef PERFMETER
        if (pCFI->_pff->_iExpandos >= 0)
            MtAdd(Mt(StyleExpandoAddRef), 1, 0);
        #endif
    }


    if (pCFI->_pCustomCursor)
    {
        hr = THR(pts->_pCustomCursorCache->CacheData(pCFI->_pCustomCursor, &iCustomCursor));
        if (hr)
            goto Error;

        if (pCFI->_pff->_iCustomCursor != iCustomCursor)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._iCustomCursor = iCustomCursor;
            pCFI->UnprepareForDebug();
        }

        //
        // Begin download 
        //
        CCustomCursor* pCursor = GetCustomCursorFromCacheEx( iCustomCursor );
        pCursor->StartDownload();
        
        delete( pCFI->_pCustomCursor ) ;
        pCFI->_pCustomCursor = NULL;
    }

    if (pCFI->_fPreparedPEI)
    {
        MtAdd(Mt(PseudoElementInfoCached), 1, 0);

        hr = THR(pts->_pPseudoElementInfoCache->CacheData(&pCFI->_PEI, &iPEI));
        if (hr)
            goto Error;

        if (pCFI->_pff->_iPEI != iPEI)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._iPEI = iPEI;
            pCFI->UnprepareForDebug();
        }
    }
    else
    {
#ifdef PERFMETER
        if (pCFI->_pff->_iPEI >= 0)
            MtAdd(Mt(PseudoElementInfoAddRef), 1, 0);
#endif
    }

    if (!pCFI->_fPreparedFancyFormat)
    {
        MtAdd(Mt(FancyFormatAddRef), 1, 0);
        SetIFF(pCFI->_iffSrc FCCOMMA FCPARAM);
        pts->_pFancyFormatCache->AddRefData(pCFI->_iffSrc);
    }
    else
    {
        WHEN_DBG(pCFI->_fPreparedFancyFormatDebug = TRUE;)

        MtAdd(pCFI->_pffSrc->Compare(&pCFI->_ff()) ? Mt(FancyFormatTouched) : Mt(FancyFormatCached), 1, 0);

        hr = THR(pts->_pFancyFormatCache->CacheData(&pCFI->_ff(), &lIndex));
        if (hr)
            goto Error;

        //protection from overflowing 15-bit _iFF... Use stock, don't crash (IE6 26698)
        if(lIndex >= MAX_FORMAT_INDEX)
        {
            pts->_pFancyFormatCache->ReleaseData(lIndex);
            lIndex = pts->_iffDefault; 
            pts->_pFancyFormatCache->AddRefData(lIndex);
        }

        Assert(lIndex < MAX_FORMAT_INDEX && lIndex >= 0);
        SetIFF(lIndex FCCOMMA FCPARAM);
 
        if (iExpando >= 0)
        {
            pts->_pStyleExpandoCache->ReleaseData(iExpando);
        }

        if (iCustomCursor >= 0)
        {
            pts->_pCustomCursorCache->ReleaseData(iCustomCursor);
        }
        
        if (iPEI >= 0)
        {
            pts->_pPseudoElementInfoCache->ReleaseData(iPEI);
        }
    }

    TraceTag((
        tagFormatCaches,
        "Caching fancy format for "
        "node (tag: %ls, SN: E%d N%d) in %d",
        Element()->TagName(), Element()->SN(), SN(), _iFF ));

    Assert(  GetICF(FCPARAM) >= 0           
          && GetIPF(FCPARAM) >= 0 
          && GetIFF(FCPARAM) >= 0);
 
    pCFI->UnprepareForDebug();

    Assert(!pCFI->_pAAExpando);
    Assert(!pCFI->_cstrBgImgUrl);
    Assert(!pCFI->_cstrLiImgUrl);
    Assert(!pCFI->_cstrPseudoBgImgUrl);
    Assert(!pCFI->_pCustomCursor );
    
    return S_OK;

Error:
    if (_iCF >= 0) pts->_pCharFormatCache->ReleaseData(_iCF);
    if (_iPF >= 0) pts->_pParaFormatCache->ReleaseData(_iPF);
    if (_iFF >= 0) pts->_pFancyFormatCache->ReleaseData(_iFF);
    if (iExpando >= 0) pts->_pStyleExpandoCache->ReleaseData(iExpando);
    if (iCustomCursor >= 0) pts->_pCustomCursorCache->ReleaseData(iCustomCursor);
    
    if (iPEI >= 0) pts->_pPseudoElementInfoCache->ReleaseData(iPEI);

    pCFI->Cleanup();

    _iCF = _iPF = _iFF = -1;

    RRETURN(hr);
}

#ifdef MULTI_FORMAT

// These functions need to be updated as the FC/LC conversion process changes.
// They're helpers to ComputeFormats to ease use of different algorithms in finding
// the parent of a node for formatting purposes.
// Right now they do a redundant check, so they need to be kept in sync. Later they will likely be
// combined into one function.

CTreeNode *
CElement::GetParentFormatNode(CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if ( IS_FC(FCPARAM) )
    {
        if (this == FC_TO_LC(FCPARAM)->GetLayoutOwner()->ElementContent())
        {
            return FC_TO_LC(FCPARAM)->GetLayoutOwner()->ElementOwner()->GetFirstBranch();
        }
    }
    return pNodeTarget->Parent();
}

FORMAT_CONTEXT 
CElement::GetParentFormatContext(CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if ( IS_FC(FCPARAM))
    {
        if (this == FC_TO_LC(FCPARAM)->GetLayoutOwner()->ElementContent())
        {
            return LC_TO_FC((FC_TO_LC(FCPARAM)->GetLayoutOwner()->LayoutContext()));
        }

        return FCPARAM;
    }
    return 0;
}

#endif

// ComputeFormats -------------------------------------------------------------

void
CElement::FixupEditable(CFormatInfo *pCFI)
{
    Assert(ETAG_INPUT == _etag || ETAG_TEXTAREA == _etag);
    
    // for input and textarea if contentEditable is not explicity set, then set default as TRUE
    // if not readOnly OR its parent is editable.
    if (!pCFI->_fEditableExplicitlySet)
    {
        BOOL fReadOnly;

        if (ETAG_INPUT == _etag)
        {
            CInput *pInput = DYNCAST(CInput, this);
            htmlInput type = pInput->GetType();
            fReadOnly = (type == htmlInputText || type == htmlInputPassword || type == htmlInputFile) ? pInput->_fReadOnly : TRUE;
        }
        else
            fReadOnly = DYNCAST(CTextArea, this)->_fReadOnly;

        if (!fReadOnly || pCFI->_fParentEditable)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fEditable = TRUE;
            pCFI->UnprepareForDebug();

            _fEditable = TRUE;
        }
        else
            _fEditable = FALSE;
    }
}

MtDefine(IterativeComputeFormats_aryAncestors_pv, Locals, "IterativeComputeFormats::_aryAncestors::CTreeNode*")

#define MAX_CF_DEPTH 100
#define STRIDE_SIZE  (MAX_CF_DEPTH - 5)

HRESULT
CElement::IterativeComputeFormats(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    CTreeNode *pNode;
    CPtrAry<CTreeNode *> aryAncestors(Mt(IterativeComputeFormats_aryAncestors_pv));
    LONG lCount = STRIDE_SIZE;
    COMPUTEFORMATSTYPE      eExtraValues = pCFI->_eExtraValues;
    LONG i;
    
    for(pNode = pNodeTarget; pNode != NULL; pNode = pNode->Parent())
    {
#ifdef MULTI_FORMAT
        if (   (   !pNode->HasFormatAry() 
                && IS_FC(pFCParent)
                )
             || pNode->GetICF(pFCParent) == -1
             || pNode->GetIFF(pFCParent) == -1
             || eExtraValues == ComputeFormatsType_GetInheritedValue 
            )
#else
        if (    pNode->GetICF() == -1
            ||  pNode->GetIFF() == -1
            ||  eExtraValues == ComputeFormatsType_GetInheritedValue 
           )
#endif //MULTI_FORMAT
        {
            lCount--;
            if (lCount == 0)
            {
                aryAncestors.Append(pNode);
                lCount = STRIDE_SIZE;
            }
        }
        else
        {
            // Found a parent which has computed formats. Break and compute the
            // formats for all the ones we have collected in the array
            break;
        }
    }
    
    LONG lDepth = pCFI->_lRecursionDepth;
    pCFI->_lRecursionDepth = 0;
    for (i = aryAncestors.Size() - 1; i >= 0; i--)
    {
        Assert(aryAncestors[i]->Element() != this);
        aryAncestors[i]->Element()->ComputeFormats(pCFI, aryAncestors[i] FCCOMMA FCPARAM);
        Assert(pCFI->_lRecursionDepth == 0);
    }
    pCFI->_lRecursionDepth = lDepth;
    
    return S_OK;
}

#ifdef GENERALISED_STEALING
BYTE g_EtagCache[ETAG_LAST];
void InitETagsTable()
{
#define X(Y) g_EtagCache[ETAG_##Y] = TRUE;
    X(A) X(B) X(FONT) X(I) X(P) X(UL) X(LI) X(CENTER) X(H1) X(H2) X(H3) X(H4)
    X(H5) X(H6) X(HR) X(BR) X(INPUT)
#undef X
}
#endif

HRESULT
CElement::ComputeFormats(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{

    HRESULT hr = S_OK;

    pCFI->_lRecursionDepth++;
    if (pCFI->_lRecursionDepth > MAX_CF_DEPTH)
    {
        CTreeNode *pNodeParent = pNodeTarget->Parent();
        if (pNodeParent)
        {
            hr = THR(IterativeComputeFormats(pCFI, pNodeTarget FCCOMMA FCPARAM));
        }
    }
    hr = THR(ComputeFormatsVirtual(pCFI, pNodeTarget FCCOMMA FCPARAM));
    if (   SUCCEEDED(hr)
        && pNodeTarget->IsInMarkup()
        && pCFI->CanWeSteal()
        && pNodeTarget->IsFirstBranch()
       )
    {
        _fStealingAllowed = TRUE;
        
#ifdef GENERALISED_STEALING
        if (g_EtagCache[pNodeTarget->Tag()])
            TLS(_pNodeLast[pNodeTarget->Tag()]) = pNodeTarget;
#else
        if (pNodeTarget->Tag() == ETAG_A)
            TLS(_pNodeLast) = pNodeTarget;
#endif
    }
    else
    {
        _fStealingAllowed = FALSE;
#ifdef GENERALISED_STEALING
        if (    g_EtagCache[pNodeTarget->Tag()]
            &&  SameScope(TLS(_pNodeLast[pNodeTarget->Tag()]), pNodeTarget)
           )
        {
            TLS(_pNodeLast[pNodeTarget->Tag()]) = NULL;
        }
#else
        if (   pNodeTarget->Tag() == ETAG_A
            && SameScope(TLS(_pNodeLast), pNodeTarget)
           )
        {
            TLS(_pNodeLast) = NULL;
        }
#endif
    }

    // See if we need to register a whitespace change

    if (SUCCEEDED(hr)
        && (!!pNodeTarget->GetParaFormat()->_fPreInner != pNodeTarget->IsPre()))
    {
        CMarkup *pMarkup = pNodeTarget->GetMarkup();

        Assert( pMarkup );
        if (pMarkup->SupportsCollapsedWhitespace())
        {
            hr = THR(Doc()->GetWhitespaceManager()->RegisterWhitespaceChange(pNodeTarget));
        }
    }
    
    pCFI->_lRecursionDepth--;    
    
    RRETURN(hr);
}

BOOL CElement::CanStealFormats(CTreeNode *pNodeVictim)
{
#ifdef GENERALISED_STEALING
    CAttrArray **ppAA1 = GetAttrArray();
    CAttrArray **ppAA2 = pNodeVictim->Element()->GetAttrArray();
    
    return (   (*ppAA1 == NULL && *ppAA2 == NULL)
            || (*ppAA1 != NULL && *ppAA2 != NULL && (*ppAA1)->Compare(*ppAA2))
           );
#else
    Assert("Should never be called for non-A elements without generalised stealing.");
    return FALSE;
#endif
}

#if DBG==1
int g_CFTotalCalls = 0;
int g_CFAttemptedSteals = 0;
int g_CFSuccessfulSteals = 0;
#endif

HRESULT
CElement::AttemptToStealFormats(CFormatInfo * pCFI)
{
    HRESULT hr = S_FALSE;
    CTreeNode * pNodeTarget = pCFI->_pNodeContext;
    THREADSTATE * pts = GetThreadState();
#ifdef GENERALISED_STEALING
    CTreeNode *pNodeOther = pts->_pNodeLast[pNodeTarget->Tag()];
#else
    CTreeNode *pNodeOther = pts->_pNodeLast;
#endif
    
    WHEN_DBG(g_CFTotalCalls++);
    if (pNodeOther && pNodeTarget != pNodeOther)
    {
        CTreeNode *pNodeOtherParent = pNodeOther->Parent();
        CTreeNode *pNodeTargetParent = pNodeTarget->Parent();
        CMarkup *pMarkup = GetMarkup();
        CMarkup *pMarkupOther = pNodeOther->GetMarkup();
        CStyleSheetArray *pssa = pMarkup->GetStyleSheetArray();

        WHEN_DBG(g_CFAttemptedSteals++;)

        if (   pNodeOther->_iCF != -1
            && pNodeOther->_iPF != -1
            && pNodeOther->_iFF != -1
            && pNodeOtherParent
            && pNodeTargetParent
            && (   pNodeOtherParent == pNodeTargetParent
                || (   (pNodeOtherParent->_iCF == pNodeTargetParent->_iCF)
                    && (pNodeOtherParent->_iPF == pNodeTargetParent->_iPF)
                    && (pNodeOtherParent->_iFF == pNodeTargetParent->_iFF)
                    && (  !pssa
                        || pssa->OnlySimpleRulesApplied(pCFI)
                       )
                    && !pts->pUserStyleSheets
                    && !Doc()->_pHostStyleSheets
                   )
               )
            && !pMarkup->HasCFState()
            && !(HasPeerHolder() && GetPeerHolder()->TestFlagMulti(CPeerHolder::NEEDAPPLYSTYLE))
            && pCFI->_eExtraValues == ComputeFormatsType_Normal
            && pMarkup == pMarkupOther
           )
        {
            BOOL fSteal = CanStealFormats(pNodeOther);

            if (fSteal)
            {
                WHEN_DBG(g_CFSuccessfulSteals++;)

                Assert(pNodeOther->Element()->_fStealingAllowed);

                pNodeTarget->SetICF(pNodeOther->_iCF FCCOMMA FCPARAM);
                pts->_pCharFormatCache->AddRefData(pNodeOther->_iCF);

                pNodeTarget->SetIPF(pNodeOther->_iPF FCCOMMA FCPARAM);
                pts->_pParaFormatCache->AddRefData(pNodeOther->_iPF);

                pNodeTarget->SetIFF(pNodeOther->_iFF FCCOMMA FCPARAM);
                pts->_pFancyFormatCache->AddRefData(pNodeOther->_iFF);

                pNodeTarget->_fBlockNess = pNodeOther->_fBlockNess;
                pNodeTarget->_fShouldHaveLayout = pNodeOther->_fShouldHaveLayout;
                _fEditable = pNodeOther->Element()->_fEditable;

                DoLayoutRelatedWork(pNodeTarget->_fShouldHaveLayout);
                
                pCFI->_ProbRules.Invalidate(pssa);

                hr = S_OK;
            }
        }
    }
    
    RRETURN1(hr, S_FALSE);
}


HRESULT
CElement::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    CDoc *                  pDoc = Doc();
    THREADSTATE *           pts  = GetThreadState();
    CTreeNode *             pNodeParent;
    CElement *              pElemParent;
    CDefaults *             pDefaults;   
    BOOL                    fResetPosition = FALSE;
    BOOL                    fComputeFFOnly; // = pNodeTarget->_iCF != -1;
    BOOL                    fInheritEditableFalse;
    BOOL                    fEditable;
    HRESULT                 hr = S_OK;
    COMPUTEFORMATSTYPE      eExtraValues = pCFI->_eExtraValues;

    BOOL                    fRootVisibilityHidden = FALSE;
    CMarkup *               pMarkup = GetMarkup();
    
#ifdef MULTI_FORMAT
    FORMAT_CONTEXT pFCParent = NULL;
#endif //MULTI_FORMAT
    
    fComputeFFOnly = pNodeTarget->GetICF(FCPARAM) != -1;

    Assert(pCFI);
    Assert(SameScope(this, pNodeTarget));
#ifdef MULTI_FORMAT
    Assert(   eExtraValues != ComputeFormatsType_Normal 
           || (    !pNodeTarget->HasFormatAry()
                && IS_FC(FCPARAM) 
              )
           || (    (    pNodeTarget->GetICF(FCPARAM) == -1 
                     && pNodeTarget->GetIPF(FCPARAM) == -1
                   ) 
                ||  pNodeTarget->GetIFF(FCPARAM) == -1 
              )
          );
#else
    Assert(   eExtraValues != ComputeFormatsType_Normal 
           || (    (    pNodeTarget->GetICF(FCPARAM) == -1 
                     && pNodeTarget->GetIPF(FCPARAM) == -1
                   ) 
                ||  pNodeTarget->GetIFF(FCPARAM) == -1 
              )
          );
#endif //MULTI_FORMAT
              
    AssertSz(!TLS(fInInitAttrBag), "Trying to compute formats during InitAttrBag! This is bogus and must be corrected!");

    TraceTag((tagRecalcStyle, "ComputeFormats"));

    //
    // Get the format of our parent before applying our own format.
    //

    pNodeParent = pNodeTarget->Parent();

    // If this is the root and has a master, inherit from master
    if (!pNodeParent && HasMasterPtr())
    {
        CElement *pElemMaster = GetMasterPtr();

        CDefaults *pDefaults = pElemMaster->GetDefaults();                
    
        ELEMENT_TAG etag = pElemMaster->TagType();
        fInheritEditableFalse = (etag==ETAG_GENERIC) || (etag==ETAG_FRAME) || (etag==ETAG_IFRAME);

        if (    (!pDefaults && etag == ETAG_GENERIC)
            ||  (pDefaults && pDefaults->GetAAviewInheritStyle())
            ||  pElemMaster->Tag() == ETAG_INPUT)
        {
            pNodeParent = pElemMaster->GetFirstBranch();
        }
    }
    else
    {
        fInheritEditableFalse = FALSE;
    }
    
#ifdef MULTI_FORMAT

    if ( IS_FC(FCPARAM) )
    {
        // TODO (t-michda) These functions don't work with tables, and the value
        // of pNodeParent gets overwritten below. This is not a problem UNLESS you can
        // flow any of the below elements through a container, in which case these 
        // functions need to be updated to do the right thing.
        pNodeParent = pNodeTarget->Element()->GetParentFormatNode(pNodeTarget, FCPARAM );
        pFCParent = pNodeTarget->Element()->GetParentFormatContext(pNodeTarget, FCPARAM );
                
    }
    
#endif

    switch (_etag)
    {
        case ETAG_TR:
            {
                CTableSection *pSection = DYNCAST(CTableRow, this)->Section();
                if (pSection)
                    pNodeParent = pSection->GetFirstBranch();
            }
            break;
        case ETAG_TBODY:
        case ETAG_THEAD:
        case ETAG_TFOOT:
            {
                CTable *pTable = DYNCAST(CTableSection, this)->Table();
                if (pTable)
                    pNodeParent = pTable->GetFirstBranch();
                fResetPosition = TRUE;
            }
            break;
    }

    if (pNodeParent == NULL)
    {
        //(dmitryt) this can happen if we just processed OnClick event in which we removed the
        //element from the tree and, as a second step, we are trying to bubble the event up.
        //So we are looking at formats to detect if element has a layout and element is still alive but no parent!
        //I've removed assert from here because it's a valid situation. And I've checked that we process 
        //error code correctly in a caller.
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // If the parent node has not computed formats yet, recursively compute them
    //

    pElemParent = pNodeParent->Element();

#ifdef MULTI_FORMAT
    if (       (    !pNodeParent->HasFormatAry() 
                 && IS_FC(pFCParent)
               )
            || pNodeParent->GetICF(pFCParent) == -1
            || pNodeParent->GetIFF(pFCParent) == -1
            || eExtraValues == ComputeFormatsType_GetInheritedValue 
            || eExtraValues == ComputeFormatsType_GetInheritedIntoTableValue
       )
#else
    if (    pNodeParent->GetICF() == -1
        ||  pNodeParent->GetIFF() == -1
        ||  eExtraValues == ComputeFormatsType_GetInheritedValue 
        ||  eExtraValues == ComputeFormatsType_GetInheritedIntoTableValue
       )
#endif //MULTI_FORMAT
    {
        SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

#ifdef MULTI_FORMAT
        hr = THR(pElemParent->ComputeFormats(pCFI, pNodeParent, pFCParent));
#else
        hr = THR(pElemParent->ComputeFormats(pCFI, pNodeParent));
#endif //MULTI_FORMAT

        SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

        if (hr)
            goto Cleanup;
    }

#ifdef MULTI_FORMAT
    Assert(pNodeParent->GetICF(pFCParent) >= 0);
    Assert(pNodeParent->GetIPF(pFCParent) >= 0);
    Assert(pNodeParent->GetIFF(pFCParent) >= 0);
#else
    Assert(pNodeParent->GetICF() >= 0);
    Assert(pNodeParent->GetIPF() >= 0);
    Assert(pNodeParent->GetIFF() >= 0);
#endif
    //
    // NOTE: From this point forward any errors must goto Error instead of Cleanup!
    //

    // At this point, even if the parent ComputeFormat did build a list of probable rules
    // it should have freed it up, else we will leak memory.
    pCFI->Reset();
    pCFI->_pNodeContext = pNodeTarget;

#ifndef GENERALISED_STEALING
    if (pNodeTarget->Tag() == ETAG_A)
#endif
    {
        hr = THR(AttemptToStealFormats(pCFI));
        if (hr == S_OK)
            goto Cleanup; // successful stealing!
    }
    
    if (   eExtraValues != ComputeFormatsType_Normal
        || HasPeerHolder()
        || pMarkup->HasCFState()
       )
    {
        pCFI->NoStealing();
    }
    
    //
    // Setup Fancy Format
    //
    if (_fInheritFF) 
    {
#ifdef MULTI_FORMAT    
        if (IS_FC(pFCParent))  
        {                                 
            pCFI->_iffSrc = pNodeParent->GetIFF(pFCParent);
        } 
        else 
#endif //MULTI_FORMAT        
        {
            pCFI->_iffSrc = pNodeParent->_iFF;
        }
        
        pCFI->_pffSrc = pCFI->_pff = &(*pts->_pFancyFormatCache)[pCFI->_iffSrc];
        pCFI->_fHasExpandos = FALSE;

        if (    pCFI->_pff->_bPositionType != stylePositionNotSet
            ||  pCFI->_pff->_bDisplay != styleDisplayNotSet
            ||  pCFI->_pff->_bVisibility != styleVisibilityNotSet
            ||  pCFI->_pff->GetOverflowX() != styleOverflowNotSet
            ||  pCFI->_pff->GetOverflowY() != styleOverflowNotSet
            ||  pCFI->_pff->_bPageBreaks != 0
            ||  pCFI->_pff->_fPositioned
            ||  pCFI->_pff->_fAutoPositioned
            ||  pCFI->_pff->_fScrollingParent
            ||  pCFI->_pff->_fZParent
            ||  pCFI->_pff->_ccvBackColor.IsDefined()
            ||  pCFI->_pff->_lImgCtxCookie != 0
            ||  pCFI->_pff->_iExpandos != -1
            ||  pCFI->_pff->_iCustomCursor != -1 
            ||  pCFI->_pff->_iPEI != -1
            ||  pCFI->_pff->_fHasExpressions != 0
            ||  pCFI->_pff->_pszFilters
            ||  pCFI->_pff->_fHasNoWrap
            ||  pCFI->_pff->_fLayoutFlowChanged
            ||  pCFI->_pff->_lRotationAngle
            ||  pCFI->_pff->_flZoomFactor)
        {
            CUnitValue uvNull(0, CUnitValue::UNIT_NULLVALUE);

            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bPositionType = stylePositionNotSet;
            pCFI->_ff().SetPosition(SIDE_TOP, uvNull);
            pCFI->_ff().SetPosition(SIDE_LEFT, uvNull);
            pCFI->_ff()._bDisplay = styleDisplayNotSet;
            pCFI->_ff()._bVisibility = styleVisibilityNotSet;
            pCFI->_ff().SetOverflowX(styleOverflowNotSet);
            pCFI->_ff().SetOverflowY(styleOverflowNotSet);
            pCFI->_ff()._bPageBreaks = 0;
            pCFI->_ff()._pszFilters = NULL;
            pCFI->_ff()._fPositioned = FALSE;
            pCFI->_ff()._fAutoPositioned = FALSE;
            pCFI->_ff()._fScrollingParent = FALSE;
            pCFI->_ff()._fZParent = FALSE;
            pCFI->_ff()._fHasNoWrap = FALSE;
            pCFI->_ff()._fLayoutFlowChanged = FALSE;
            
            // We never ever inherit expandos or expressions
            pCFI->_ff()._iExpandos = -1;
            pCFI->_ff()._iCustomCursor = -1;
            pCFI->_ff()._fHasExpressions = FALSE;
            pCFI->_ff()._iPEI = -1;
            
            if(Tag() != ETAG_TR)
            {
                //
                // do not inherit background from the table.
                //
                pCFI->_ff()._ccvBackColor.Undefine();
                pCFI->_ff()._lImgCtxCookie = 0;

                // TRs inherit transformations from TBODY because TBODY can't have a layout.
                // Everyone else must not inherit transformations.
                pCFI->_ff()._lRotationAngle = 0;
                pCFI->_ff()._flZoomFactor = 0.0;
            }
            pCFI->UnprepareForDebug();
        }

        // 'text-overflow' is not inherited down
        if (pCFI->_pff->GetTextOverflow() != styleTextOverflowClip)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetTextOverflow(styleTextOverflowClip);
            pCFI->UnprepareForDebug();
        }
    }
    else
    {
        pCFI->_iffSrc = pts->_iffDefault;
        pCFI->_pffSrc = pCFI->_pff = pts->_pffDefault;

        Assert(pCFI->_pffSrc->_pszFilters == NULL);
    }

    if (!fComputeFFOnly)
    {
        //
        // Setup Char and Para formats
        //

        if (TestClassFlag(ELEMENTDESC_DONTINHERITSTYLE))
        {
            // The CharFormat inherits a couple of attributes from the parent, the rest from defaults.

            const CCharFormat * pcfParent;
            const CParaFormat * ppfParent;

#ifdef MULTI_FORMAT
            if (IS_FC(pFCParent))
            {
                pcfParent = &(*pts->_pCharFormatCache)[pNodeParent->GetICF(pFCParent)];
                ppfParent = &(*pts->_pParaFormatCache)[pNodeParent->GetIPF(pFCParent)];
            } 
            else
#endif //MULTI_FORMAT            
            {            
                pcfParent = &(*pts->_pCharFormatCache)[pNodeParent->_iCF];
                ppfParent = &(*pts->_pParaFormatCache)[pNodeParent->_iPF];
            }

            pCFI->_fDisplayNone      = pcfParent->_fDisplayNone ;
            pCFI->_fVisibilityHidden = pcfParent->_fVisibilityHidden ;

            {                
                if (!pMarkup->_fDefaultCharFormatCached)
                {
                    hr = THR(pMarkup->CacheDefaultCharFormat());
                    if (hr)
                        goto Error;
                }

                Assert(pMarkup->_fDefaultCharFormatCached);

                if (pMarkup->_fHasDefaultCharFormat)
                {
                    pCFI->_icfSrc = pMarkup->GetDefaultCharFormatIndex();
                    pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
                }
                else
                {
                    pCFI->_icfSrc = pDoc->_icfDefault;
                    pCFI->_pcfSrc = pCFI->_pcf = pDoc->_pcfDefault;
                }
            }

            pCFI->_fParentEditable = pcfParent->_fEditable;                       

            // Some properties are ALWAYS inherited, regardless of ELEMENTDESC_DONTINHERITSTYLE.
            // Do that here:
            if (    pCFI->_fDisplayNone
                ||  pCFI->_fVisibilityHidden
                ||  pcfParent->_fHasBgColor
                ||  pcfParent->_fHasBgImage
                ||  pcfParent->_fRelative
                ||  pcfParent->_fNoBreakInner
                ||  pcfParent->_fRTL
                ||  pCFI->_pcf->_bCursorIdx != pcfParent->_bCursorIdx
                ||  pCFI->_pcf->_wLayoutFlow != pcfParent->_wLayoutFlow
                ||  pcfParent->_fDisabled
                ||  pcfParent->_fWritingModeUsed
               )
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fDisplayNone       = pCFI->_fDisplayNone;
                pCFI->_cf()._fVisibilityHidden  = pCFI->_fVisibilityHidden;
                pCFI->_cf()._fHasBgColor        = pcfParent->_fHasBgColor;
                pCFI->_cf()._fHasBgImage        = pcfParent->_fHasBgImage;
                pCFI->_cf()._fRelative          = pNodeParent->ShouldHaveLayout()
                                                    ? FALSE
                                                    : pcfParent->_fRelative;
                pCFI->_cf()._fNoBreak           = pcfParent->_fNoBreakInner;
                pCFI->_cf()._fRTL               = pcfParent->_fRTL;
                pCFI->_cf()._bCursorIdx         = pcfParent->_bCursorIdx;
                pCFI->_cf()._fDisabled          = pcfParent->_fDisabled;
                pCFI->_cf()._wLayoutFlow        = pcfParent->_wLayoutFlow;
                pCFI->_cf()._fWritingModeUsed   = pcfParent->_fWritingModeUsed;
                pCFI->UnprepareForDebug();
            }

#ifdef MULTI_FORMAT
            if (IS_FC(pFCParent) )
            {
                pCFI->_ipfSrc = pNodeParent->GetIPF(pFCParent);
            }
            else
#endif //MULTI_FORMAT            
            {
                pCFI->_ipfSrc = pNodeParent->_iPF;                
            }

            pCFI->_ppfSrc = pCFI->_ppf = ppfParent;

            if (    pCFI->_ppf->_fPreInner
                ||  pCFI->_ppf->_fInclEOLWhiteInner
                ||  pCFI->_ppf->_bBlockAlignInner != htmlBlockAlignNotSet)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fPreInner              = FALSE;
                // TODO: (KTam) shouldn't this be _fInclEOLWhiteInner? fix in IE6
                pCFI->_pf()._fInclEOLWhite          = FALSE;
                pCFI->_pf()._bBlockAlignInner       = htmlBlockAlignNotSet;
                pCFI->UnprepareForDebug();
            }

            // outer block alignment should still be inherited from
            // parent, but reset the inner block alignment
            pCFI->_bCtrlBlockAlign  = ppfParent->_bBlockAlignInner;
            pCFI->_bBlockAlign      = htmlBlockAlignNotSet;


            // outer direction should still be inherited from parent
            if(pCFI->_ppf->_fRTL != pCFI->_ppf->_fRTLInner)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTL = pCFI->_ppf->_fRTLInner;
                pCFI->UnprepareForDebug();
            }

            // layout-grid should still be inherited from parent
            if (pcfParent->HasLayoutGrid(TRUE))
            {
                pCFI->PrepareCharFormat();
                pCFI->PrepareParaFormat();

                pCFI->_cf()._uLayoutGridMode = pcfParent->_uLayoutGridModeInner;
                pCFI->_pf()._uLayoutGridType = ppfParent->_uLayoutGridTypeInner;
                pCFI->_pf()._cuvCharGridSize = ppfParent->_cuvCharGridSizeInner;
                pCFI->_pf()._cuvLineGridSize = ppfParent->_cuvLineGridSizeInner;

                // TODO (srinib) - if inner values need to be inherited too for elements like
                // input, select,textarea then copy the inner values from parent here
                // pCFI->_cf()._uLayoutGridModeInner = pcfParent->_uLayoutGridModeInner;
                // pCFI->_pf()._uLayoutGridTypeInner = ppfParent->_uLayoutGridTypeInner;
                // pCFI->_pf()._cuvCharGridSizeInner = ppfParent->_cuvCharGridSizeInner;
                // pCFI->_pf()._cuvLineGridSizeInner = ppfParent->_cuvLineGridSizeInner;

                pCFI->UnprepareForDebug();
            }
        }
        else
        {
            // Inherit the Char and Para formats from the parent node
#ifdef MULTI_FORMAT
            if (IS_FC(pFCParent) ) 
            {
                pCFI->_icfSrc = pNodeParent->GetICF(pFCParent);
                pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
                pCFI->_ipfSrc = pNodeParent->GetIPF(pFCParent);
                pCFI->_ppfSrc = pCFI->_ppf = &(*pts->_pParaFormatCache)[pCFI->_ipfSrc];
            }
            else 
#endif //MULTI_FORMAT            
            {
                pCFI->_icfSrc = pNodeParent->_iCF;
                pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
                pCFI->_ipfSrc = pNodeParent->_iPF;
                pCFI->_ppfSrc = pCFI->_ppf = &(*pts->_pParaFormatCache)[pCFI->_ipfSrc];
            }

            pCFI->_fDisplayNone      = pCFI->_pcf->_fDisplayNone ;
            pCFI->_fVisibilityHidden = pCFI->_pcf->_fVisibilityHidden ;

            // If the parent had layoutness, clear the inner formats
            // NOTE figure out how multilayouts should work with this (t-michda)
#ifdef MULTI_FORMAT            
            if (pNodeParent->ShouldHaveLayout(pFCParent))
#else
            if (pNodeParent->ShouldHaveLayout())
#endif            
            {
                if (pCFI->_pcf->_fHasDirtyInnerFormats)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf().ClearInnerFormats();
                    pCFI->UnprepareForDebug();
                }

                if (pCFI->_ppf->_fHasDirtyInnerFormats)
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf().ClearInnerFormats();
                    pCFI->UnprepareForDebug();
                }

                // copy parent's inner formats to current elements outer
                if (    pCFI->_ppf->_fPre != pCFI->_ppf->_fPreInner
                    ||  pCFI->_ppf->_fInclEOLWhite != pCFI->_ppf->_fInclEOLWhiteInner
                    ||  pCFI->_ppf->_bBlockAlign != pCFI->_ppf->_bBlockAlignInner)
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._fPre = pCFI->_pf()._fPreInner;
                    pCFI->_pf()._fInclEOLWhite = pCFI->_pf()._fInclEOLWhiteInner;
                    pCFI->_pf()._bBlockAlign = pCFI->_pf()._bBlockAlignInner;
                    pCFI->UnprepareForDebug();
                }

                if (pCFI->_pcf->_fNoBreak != pCFI->_pcf->_fNoBreakInner)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fNoBreak = pCFI->_pcf->_fNoBreakInner;
                    pCFI->UnprepareForDebug();
                }

                if (pCFI->_pcf->_uLayoutGridMode != pCFI->_pcf->_uLayoutGridModeInner)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._uLayoutGridMode = pCFI->_pcf->_uLayoutGridModeInner;
                    pCFI->UnprepareForDebug();
                }
                if (    pCFI->_ppf->_uLayoutGridType != pCFI->_ppf->_uLayoutGridTypeInner
                    ||  pCFI->_ppf->_cuvCharGridSize.GetRawValue() != pCFI->_ppf->_cuvCharGridSizeInner.GetRawValue()
                    ||  pCFI->_ppf->_cuvLineGridSize.GetRawValue() != pCFI->_ppf->_cuvLineGridSizeInner.GetRawValue())
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._uLayoutGridType = pCFI->_ppf->_uLayoutGridTypeInner;
                    pCFI->_pf()._cuvCharGridSize = pCFI->_ppf->_cuvCharGridSizeInner;
                    pCFI->_pf()._cuvLineGridSize = pCFI->_ppf->_cuvLineGridSizeInner;
                    pCFI->UnprepareForDebug();
                }
            }

            // outer block alignment should still be inherited from
            // parent
            pCFI->_bCtrlBlockAlign  = pCFI->_ppf->_bBlockAlign;
            pCFI->_bBlockAlign      = pCFI->_ppf->_bBlockAlign;

            // outer direction should still be inherited from parent
            if(pCFI->_ppf->_fRTL != pCFI->_ppf->_fRTLInner)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTL = pCFI->_ppf->_fRTLInner;
                pCFI->UnprepareForDebug();
            }
        }

        pCFI->_bControlAlign = htmlControlAlignNotSet;
    }
    else
    {
        if (pMarkup->_fHasDefaultCharFormat)
        {
            pCFI->_icfSrc = pMarkup->GetDefaultCharFormatIndex();
            pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
        }
        else
        {
            pCFI->_icfSrc = pDoc->_icfDefault;
            pCFI->_pcfSrc = pCFI->_pcf = pDoc->_pcfDefault;
        }

        pCFI->_ipfSrc = pts->_ipfDefault;
        pCFI->_ppfSrc = pCFI->_ppf = pts->_ppfDefault;
    }

    Assert(pCFI->_fEditableExplicitlySet == FALSE);

    fEditable = fInheritEditableFalse ? FALSE : pCFI->_pcf->_fEditable;    

    // see if behaviour set default contentEditable    
    pDefaults = GetDefaults();    
    if (pDefaults || fInheritEditableFalse)
    {
        if (pDefaults)
        {
            htmlEditable enumEditable = pDefaults->GetAAcontentEditable();
            if (htmlEditableInherit != enumEditable)
            {
                fEditable = (htmlEditableTrue == enumEditable);            
            }
            pCFI->NoStealing();
        }         
    
        // change only if different.
        if (pCFI->_pcf->_fEditable != fEditable)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fEditable = fEditable;
            pCFI->UnprepareForDebug();
        }
        _fEditable = fEditable;
    }
                
    Assert(pElemParent);
    pCFI->_fParentFrozen = pElemParent->IsFrozen() 
            // Can not do this here. It is incorrectly accessing FirstBranch..
            // || pElemParent->IsParentFrozen(); 
            || pNodeParent->GetCharFormat()->_fParentFrozen;

    // change only if different
    if (pCFI->_pcf->_fParentFrozen != pCFI->_fParentFrozen)
    {        
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fParentFrozen = pCFI->_fParentFrozen;
        pCFI->UnprepareForDebug();     
    }

    hr = THR(ApplyDefaultFormat(pCFI));
    if (hr)
        goto Error;

    if (IsGenericListItem(pCFI->_pNodeContext, pCFI->_pff))
    {
        ApplyListItemFormats(pCFI);
    }

    // Fix 96067
    // The root is hidden only if it inherited it from the master element, implying we
    // are inside a hidden frame/iframe/viewlink. Hence, we want the root's hiddenness
    // to take precedence.     
    if (!IsRoot())
    {
        CRootElement *pRootElem = pMarkup->Root();
        if (pRootElem)
        {
            fRootVisibilityHidden = pRootElem->IsVisibilityHidden();
            if (    fRootVisibilityHidden               
                &&  fRootVisibilityHidden != !!pCFI->_fVisibilityHidden)
            {
                pCFI->PrepareCharFormat();
                pCFI->_fVisibilityHidden = TRUE;
                pCFI->UnprepareForDebug();                   
            }
        }
    }


    //
    // TODO:   ApplyFormatInfoProperty overwrite pCFI->_fVisibilityHidden without looking at if
    //         the current element has the parent format
    //
    if (    !fRootVisibilityHidden
        &&  pCFI->_pff->_bVisibility == styleVisibilityInherit
        &&  TestClassFlag(ELEMENTDESC_DONTINHERITSTYLE))
    {
        pCFI->PrepareCharFormat();
        pCFI->_fVisibilityHidden = pCFI->_cf()._fVisibilityHidden;
        pCFI->UnprepareForDebug();     
    }   

    hr = THR(ApplyInnerOuterFormats(pCFI FCCOMMA FCPARAM) );
    if (hr)
        goto Error;

    if (eExtraValues == ComputeFormatsType_Normal || 
        eExtraValues == ComputeFormatsType_ForceDefaultValue)
    {
        if (fResetPosition)
        {
            if (pCFI->_pff->_bPositionType != stylePositionstatic)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._bPositionType = stylePositionstatic;
                pCFI->UnprepareForDebug();
            }
        }

        if (   _fHasFilterSitePtr 
            || pCFI->_fHasFilters)
        {

#if DBG == 1

            // If only used in debug.  If they have set debug not to print
            // filters don't computer the filter format if we're printing.

            if (!IsTagEnabled(tagNoPrintFilters) || !pMarkup->IsPrintMedia())
            {
                ComputeFilterFormat(pCFI);
            }

#else  // DBG != 1

            ComputeFilterFormat(pCFI);

#endif // DBG != 1

        }
        
        hr = THR(pNodeTarget->CacheNewFormats(pCFI FCCOMMA FCPARAM ));
        pCFI->_cstrFilters.Free();  // Arrggh!!! TODO (michaelw)  This should really happen 
                                                                        // somewhere else (when you know where, put it there)
                                                                        // Fix CTableCell::ComputeFormats also
        if (hr)
            goto Error;

        // Cache whether an element is a block element or not for fast retrieval.
#ifdef MULTI_FORMAT        
        if (! (FCPARAM) )
        {
            pNodeTarget->_fBlockNess = pCFI->_pff->_fBlockNess;
            pNodeTarget->_fShouldHaveLayout = pCFI->_pff->_fShouldHaveLayout;           
        }
#else
        pNodeTarget->_fBlockNess = pCFI->_pff->_fBlockNess;
        pNodeTarget->_fShouldHaveLayout = pCFI->_pff->_fShouldHaveLayout;
#endif        

        DoLayoutRelatedWork(pCFI->_pff->_fShouldHaveLayout);

        // Update expressions in the recalc engine
        //
        // If we had expressions or have expressions then we need to tell the recalc engine
        // 
        if (pCFI->_pff->_fHasExpressions)
        {
            Doc()->AddExpressionTask(this);
            pCFI->NoStealing();
        }
    }

Cleanup:

    // Do not leak memory due to pre caching of rules which could probably apply.
    Assert(!pCFI->_ProbRules.IsItValid(NULL));

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);

Error:
    pCFI->Cleanup();
    goto Cleanup;
}

void
CElement::DoLayoutRelatedWork(BOOL fShouldHaveLayout)
{
    if ( HasLayoutPtr() || HasLayoutAry() )
    {
        // Irrespective of the newly computed value of _fShouldHaveLayout, we may currently really have a layout.
        // If this is the case, mark its _fEditableDirtyFlag.

        // PERF: MULTI_LAYOUT case is going to be slower.  work on this?
        LayoutSetEditableDirty( TRUE );
    
        // If the current element has a layout attached to but does not
        // need one, post a layout request to lazily destroy it.
        // TODO (KTam): MULTI_LAYOUT make sure we do lazy deletion in multilayout world
        if (!fShouldHaveLayout)
        {
            if ( HasLayoutPtr() )
            {
                TraceTagEx((tagLayoutTasks, TAG_NONAME,
                            "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CElement::ComputeFormats() [lazy layout del]",
                            GetLayoutPtr(),
                            GetLayoutPtr()->_pElementOwner,
                            GetLayoutPtr()->_pElementOwner->TagName(),
                            GetLayoutPtr()->_pElementOwner->_nSerialNumber));
                GetLayoutPtr()->PostLayoutRequest(LAYOUT_MEASURE|LAYOUT_POSITION);
            }           
        }
    }
}

//---------------------------------------------------------------------------
//
// Member:              CElement::ComputeFilterFormat
//
// Description: A helper function to do whatever work is needed
//                              for filters.  This can be scheduling a filter
//                              task (when the filters will be actually instantiated)
//                              or filtering the visibility
//
//---------------------------------------------------------------------------
void
CElement::ComputeFilterFormat(CFormatInfo *pCFI)
{
    //
    // Filters can be tricky.  We used to instantiate them
    // right here while in ComputeFormats.  As ComputeFormats
    // can now be deferred to paint time, this is no longer practical
    //
    // Filters can also mess with visibility.  Fortunately, they never
    // do so when they are instantiated.  Typically they defer changes
    // the visibility property and then make them happen later on.
    //
    // In the (rare) event that the filter chain's opinion of visibility
    // changes and the filter string itself is changed before ComputeFormats
    // is called, we really don't care about the old filter chain's opinion
    // and will start everything afresh.  For this reason we are either
    // filtering the visibility bit (when the filter string is unchanged)
    // or scheduling a filter task to create or destroy the filter chain.
    // We never do both.
    //

    // Filters don't print, even if we bypass them for painting
    // because due to their abilities to manipulate the object model
    // they are able to move objects to unprintable positions
    // so in that case bail out for printing
    // We are aware that this may cause scripterrors against the filter
    // which we would ignore anyway in printing (Frankman)
    //
    // Although Frank's concerns about OM changes during print are
    // no longer a real issue, now is not the time to change this (michaelw)
    //
    // TODO: Look at issues above and remove this whole code block.  Commenting
    //       out assert to support filter printing.
    //
    // Assert(!GetMarkupPtr()->IsPrintMedia() && (_fHasFilterSitePtr || pCFI->_fHasFilters));

    LPOLESTR pszFilterNew = pCFI->_pff->_pszFilters;
    CFilterBehaviorSite *pFS = GetFilterSitePtr();

    LPCTSTR pszFilterOld = pFS ? pFS->GetFullText() : NULL;

    pCFI->NoStealing();
    
    if ((!pszFilterOld && !pszFilterNew)
    ||  (pszFilterOld && pszFilterNew && !StrCmpC(pszFilterOld, pszFilterNew)))
    {
        // Nothing has changed, just update the visibility bit as appropriate
                // It is possible for us to get here having successfully called AddFilterTask
                // and still have no filters (the filter couldn't be found or failed to hookup)

        CPeerHolder *pPeerHolder = GetFilterPeerHolder();
        if (pPeerHolder)
        {
            BOOL fHiddenNew;
            int iCF = pCFI->_pNodeContext->GetICF(FCPARAM);
            if (iCF != -1)
            {   // computing fancy format only:

                // get visibility from previously
                // calculated char format
                fHiddenNew = GetCharFormatEx(iCF)->_fVisibilityHidden;
            }
            else
            {   // computing all formats

                BOOL fHiddenOld = pCFI->_pcf->_fVisibilityHidden;
                fHiddenNew = !pPeerHolder->SetFilteredElementVisibility(!fHiddenOld);

                if (fHiddenOld != fHiddenNew)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._fVisibilityHidden = fHiddenNew ;
                    pCFI->UnprepareForDebug();
                }
            }

            if (pPeerHolder->GetFilteredElementVisibilityForced())
            {
                unsigned sv = fHiddenNew ? styleVisibilityHidden : styleVisibilityVisible;
                if (pCFI->_pff->_bVisibility != sv)
                {
                    pCFI->PrepareFancyFormat();
                    pCFI->_ff()._bVisibility = sv;
                    pCFI->UnprepareForDebug();
                }
            }
        }
    }
    else
    {
        // The filter string has changed, schedule a task to destroy/create filters

        Verify(Doc()->AddFilterTask(this));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CElement::ShouldHaveLayout, public
//
//  Synopsis:   Determines, based on attributes, whether this element needs
//              layout and if so what type.
//
//  Arguments:  [pCFI]  -- Pointer to FormatInfo with applied properties
//              [pNode] -- Context Node for this element
//              [plt]   -- Returns the type of layout we need.
//
//  Returns:    TRUE if this element needs a layout, FALSE if not.
//
//----------------------------------------------------------------------------

BOOL
CElement::ElementShouldHaveLayout(CFormatInfo *pCFI)
{
    Assert(!pCFI->_fEditableExplicitlySet || pCFI->_pcf->_fEditable == _fEditable);

    if (    (   !TestClassFlag(ELEMENTDESC_NOLAYOUT)
            && (   _fLayoutAlwaysValid
                ||  ElementNeedsFlowLayout(pCFI)
                ||  HasSlavePtr()
                ||  _fEditable 
                ||  pCFI->_fEditableExplicitlySet
                ||  IsFrozen() )))
    {
            return TRUE;
    }
    
    return FALSE;
}

BOOL
CElement::ElementNeedsFlowLayout(CFormatInfo *pCFI)
{
    const CFancyFormat *pff = pCFI->_pff;
    BOOL fNeedsFL =      pff->_fRectangular
                    ||   pff->_bPositionType == stylePositionabsolute
                    ||   pff->_bStyleFloat == styleStyleFloatLeft
                    ||   pff->_bStyleFloat == styleStyleFloatRight
                    ||   pff->_flZoomFactor
                    ||   pff->_lRotationAngle
                    ||   pff->_fLayoutFlowChanged;

    if (   !fNeedsFL
        && (   !pff->GetWidth().IsNullOrEnum()
            || !pff->GetHeight().IsNullOrEnum()
           )
       )
    {
        // In strict mode, only block elements can have layout for height and width
        // property. Inline elements do not honor height and width properties.
        fNeedsFL =    !GetMarkup()->IsStrictCSS1Document()
                   ||  DetermineBlockness(pCFI->_pff);
    }
    return fNeedsFL;
}

static BOOL ElementHIV(ELEMENT_TAG eTag)
{
    BOOL fRet;

#define X(Y) case ETAG_##Y:
    switch(eTag)
    {
        X(APPLET)   X(AREA)     X(BASE)     X(BASEFONT) X(BGSOUND)  X(BODY)     X(BUTTON)
        X(CAPTION)  X(COL)      X(COLGROUP) X(FRAME)    X(FRAMESET) X(HEAD)     X(HTML) 
        X(IFRAME)   X(IMG)      X(INPUT)    X(ISINDEX)  X(LINK)     X(MAP)      X(META) 
        X(NOFRAMES) X(NOSCRIPT) X(OBJECT)   X(OPTION)   X(PARAM)    X(SCRIPT)   X(SELECT) 
        X(STYLE)    X(TABLE)    X(TBODY)    X(TD)       X(TEXTAREA) X(TFOOT)    X(TH) 
        X(THEAD)    X(TR)       X(GENERIC)  X(OPTGROUP)
            fRet = TRUE;
            break;
        default:
            fRet = FALSE;
            break;
    }
#undef X
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::DetermineBlockness, public
//
//  Synopsis:   Determines if this element is a block element based on
//              inherent characteristics of the tag or current properties.
//
//  Arguments:  [pFF] -- Pointer to current FancyFormat with applied properties
//
//  Returns:    TRUE if this element has blockness.
//
//----------------------------------------------------------------------------
BOOL
CElement::DetermineBlockness(const CFancyFormat *pFF)
{
    BOOL            fIsBlock    = HasFlag(TAGDESC_BLOCKELEMENT); 
    styleDisplay    disp        = (styleDisplay)(pFF->_bDisplay);

    /// Ignore block flag for BODY inside viewLink
    if (fIsBlock && Tag() == ETAG_BODY && IsInViewLinkBehavior( FALSE ))
    {
        fIsBlock = FALSE;
    }
    //
    // TODO -- Are there any elements for which we don't want to override
    // blockness? (lylec)
    //
    if (disp == styleDisplayBlock || disp == styleDisplayListItem)
    {
        fIsBlock = TRUE;
    }
    else if (disp == styleDisplayInline)
    {
        fIsBlock = FALSE;
    }

    return fIsBlock;
}

void
CElement::ApplyListFormats(CFormatInfo * pCFI, int defPoints FCCOMMA FORMAT_CONTEXT FCPARAM FCDEFAULT)
{
    //
    // Apply default before/after space.
    // NOTE: Before/after space are outside our box (== margins), 
    //       so they are relative to the parent's text flow.
    //
    BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

    pCFI->PrepareFancyFormat();
    ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff(), defPoints);
    pCFI->UnprepareForDebug();
}

void
CElement::ApplyListItemFormats(CFormatInfo * pCFI FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    pCFI->PrepareParaFormat();

    styleListStyleType listType = pCFI->_ppf->GetListStyleType();

    // If list type is not explicitly set, retrieve it from the
    // nearest ancestor list element.
    if (listType == styleListStyleTypeNotSet)
    {
        CTreeNode * pNodeList = NULL;

        // Find the list element
        if (GetMarkup())
        {
            pNodeList = GetMarkup()->SearchBranchForCriteria(
                pCFI->_pNodeContext->Parent(), IsBlockListElement, NULL);
        }

        if (pNodeList)
        {
            listType = pCFI->_ppf->_cListing.GetStyle();
        }
    }

    // Set listing properties for the list item
    pCFI->_pf()._cListing.SetStyle(listType);
    pCFI->_pf()._cListing.SetStyleValid();
    pCFI->_pf()._cListing.SetType(NumberOrBulletFromStyle(listType));

    if (!pCFI->_ppf->_lNumberingStart)
    {
        pCFI->_pf()._lNumberingStart = 1;
    }

    // For lists inside of blockquotes, start the bullets AFTER
    // indenting for the blockquote.
    pCFI->_pf()._cuvNonBulletIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);

    // set up for potential EMs, Ens, and ES Conversions
    pCFI->_pf()._lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(Doc());
    if (pCFI->_pf()._lFontHeightTwips <= 0)
        pCFI->_pf()._lFontHeightTwips = 1;

    pCFI->UnprepareForDebug();

    // Apply the pre-space to the first item, after space to last item
    ApplyListFormats(pCFI, 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CElement::ApplyInnerOuterFormats, public
//
//  Synopsis:   Takes the current FormatInfo and creates the correct
//              inner and (if appropriate) outer formats.
//
//  Arguments:  [pCFI]     -- FormatInfo with applied properties
//              [pCFOuter] -- Place to store Outer format properties
//              [pPFOuter] -- Place to store Outer format properties
//
//  Returns:    HRESULT
//
//  Notes:      Inner/Outer sensitive formats are put in the _fXXXXInner
//              for inner and outer are held in _fXXXXXX
//
//----------------------------------------------------------------------------

HRESULT
CElement::ApplyInnerOuterFormats(CFormatInfo * pCFI FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    HRESULT     hr = S_OK;
    CDoc * pDoc          = Doc();
    CMarkup *pMarkup     = GetMarkup(); 
    Assert(pDoc && pMarkup);

    BOOL fHTMLLayout     = pMarkup->IsHtmlLayout();

    BOOL fShouldHaveLayout    = 
        ( Tag() == ETAG_HTML ? fHTMLLayout : ElementShouldHaveLayout(pCFI) );
    
    BOOL fNeedsOuter     =      fShouldHaveLayout
                            &&  (   !_fLayoutAlwaysValid
                                || (    TestClassFlag(ELEMENTDESC_TEXTSITE)
                                    &&  !TestClassFlag(ELEMENTDESC_TABLECELL) ));
    BOOL fHasLeftIndent  = FALSE;
    BOOL fHasRightIndent = FALSE;
    BOOL fIsBlockElement = DetermineBlockness(pCFI->_pff);
    LONG lFontHeight     = 1;
    BOOL fComputeFFOnly;   
    BOOL fMainBody       =      (fHTMLLayout ? (Tag() == ETAG_HTML) : (Tag() == ETAG_BODY))
                            &&  (!IsInViewLinkBehavior( FALSE ));
    BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();
    BOOL fWritingMode    = pCFI->_pcf->_fWritingModeUsed;
    
    fComputeFFOnly = pCFI->_pNodeContext->GetICF(FCPARAM) != -1;
   
    Assert(pCFI->_pNodeContext->Element() == this);

    if (    !!pCFI->_pff->_fShouldHaveLayout != !!fShouldHaveLayout
        ||  !!pCFI->_pff->_fBlockNess != !!fIsBlockElement)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fShouldHaveLayout = fShouldHaveLayout;
        pCFI->_ff()._fBlockNess = fIsBlockElement;
        pCFI->UnprepareForDebug();
    }

    if (   !fIsBlockElement
        && HasFlag(TAGDESC_LIST)
       )
    {
        //
        // If the current list is not a block element, and it is not parented by
        // any block-list elements, then we want the LI's inside to be treated
        // like naked LI's. To do this we have to set cuvOffsetPoints to 0.
        //
        CTreeNode *pNodeList = pMarkup->SearchBranchForCriteria(
            pCFI->_pNodeContext->Parent(), IsBlockListElement, NULL );
        if (!pNodeList)
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvOffsetPoints.SetValue( 0, CUnitValue::UNIT_POINT );
            pCFI->_pf()._cListing.SetNotInList();
            pCFI->_pf()._cListing.SetStyle(styleListStyleTypeDisc);
            pCFI->UnprepareForDebug();
        }
        else
        {
            styleListStyleType listType = pNodeList->GetParaFormat()->GetListStyleType();
            WORD               wLevel   = (WORD)pNodeList->GetParaFormat()->_cListing.GetLevel();

            pCFI->PrepareParaFormat();
            pCFI->_pf()._cListing.SetStyle(DYNCAST(CListElement, pNodeList->Element())->
                                           FilterHtmlListType(listType, wLevel));
            pCFI->UnprepareForDebug();
        }
    }
    
    if (!fComputeFFOnly)
    {
        if (pCFI->_fDisplayNone && !pCFI->_pcf->_fDisplayNone)
        {
            BOOL fIgnoreVisibilityInDesign = (IsDesignMode() || pCFI->_pNodeContext->IsParentEditable()) && 
                                              ! pMarkup->IsRespectVisibilityInDesign() ;

            if (!fIgnoreVisibilityInDesign)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fDisplayNone = TRUE ;
                pCFI->UnprepareForDebug();
            }
        }

        if (pCFI->_fVisibilityHidden != unsigned(pCFI->_pcf->_fVisibilityHidden))
        {
            BOOL fIgnoreVisibilityInDesign = (IsDesignMode() || pCFI->_pNodeContext->IsParentEditable()) && 
                                              !pMarkup->IsRespectVisibilityInDesign() ;

            if (!fIgnoreVisibilityInDesign)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fVisibilityHidden = pCFI->_fVisibilityHidden ; 
                pCFI->UnprepareForDebug();
            }
        }

        if (fNeedsOuter)
        {
            if (pCFI->_fPre != pCFI->_ppf->_fPreInner)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fPreInner = pCFI->_fPre;
                pCFI->UnprepareForDebug();
            }

            if (!!pCFI->_ppf->_fInclEOLWhiteInner != (pCFI->_fInclEOLWhite || TestClassFlag(ELEMENTDESC_SHOWTWS)))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fInclEOLWhiteInner = !pCFI->_pf()._fInclEOLWhiteInner;
                pCFI->UnprepareForDebug();
            }

            // NO WRAP
            if (pCFI->_fNoBreak)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fNoBreakInner = TRUE; //pCFI->_fNoBreak;
                pCFI->UnprepareForDebug();
            }

        }
        else
        {
            if (pCFI->_fPre && (!pCFI->_ppf->_fPre || !pCFI->_ppf->_fPreInner))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fPre = pCFI->_pf()._fPreInner = TRUE;
                pCFI->UnprepareForDebug();
            }

            if (pCFI->_fInclEOLWhite && (!pCFI->_ppf->_fInclEOLWhite || !pCFI->_ppf->_fInclEOLWhiteInner))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fInclEOLWhite = pCFI->_pf()._fInclEOLWhiteInner = TRUE;
                pCFI->UnprepareForDebug();
            }

            if (pCFI->_fNoBreak && (!pCFI->_pcf->_fNoBreak || !pCFI->_pcf->_fNoBreakInner))
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fNoBreak = pCFI->_cf()._fNoBreakInner = TRUE;
                pCFI->UnprepareForDebug();
            }
        }

        if (pCFI->_fRelative)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fRelative = TRUE;
            pCFI->UnprepareForDebug();
        }
        
        if (!fShouldHaveLayout)
        {
            // PADDING / BORDERS
            //
            // For padding, set _fPadBord flag if CFI _fPadBord is set. Values have
            // already been copied. It always goes on inner.
            //
            if (pCFI->_fPadBord && !pCFI->_pcf->_fPadBord)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fPadBord = TRUE;
                pCFI->UnprepareForDebug();
            }

            // BACKGROUND
            //
            // Sites draw their own background, so we don't have to inherit their
            // background info. Always goes on inner.
            //
            if (pCFI->_fHasBgColor && !pCFI->_pcf->_fHasBgColor)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fHasBgColor = TRUE;
                pCFI->UnprepareForDebug();
            }

            if (pCFI->_fHasBgImage)
            {
                pCFI->PrepareCharFormat();
                pCFI->_cf()._fHasBgImage = TRUE;
                pCFI->UnprepareForDebug();
            }

        }

        // INLINE BACKGROUNDS
        if (pCFI->_fMayHaveInlineBg)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fHasInlineBg = TRUE;
            pCFI->UnprepareForDebug();
        }

        // TEXT TRANSFORMS
        BOOL fHasTextTransform =    pCFI->_pcf->_fSmallCaps 
                                 || (   pCFI->_pcf->_bTextTransform != styleTextTransformNotSet
                                     && pCFI->_pcf->_bTextTransform != styleTextTransformNone);
        if (fHasTextTransform != pCFI->_pcf->_fHasTextTransform)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fHasTextTransform = fHasTextTransform;
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Note: (srinib) Currently table cell's do not support margins,
    // based on the implementation, this may change.
    //
    if (pCFI->_pff->_fHasMargins && Tag() != ETAG_BODY)
    {
        if (fIsBlockElement)
        {
            pCFI->PrepareFancyFormat();
            
            // MARGIN-TOP - on block elements margin top is treated as before space
            const CUnitValue & cuvMarginTop = pCFI->_pff->GetLogicalMargin(SIDE_TOP, fParentVertical, fWritingMode);
            if (!cuvMarginTop.IsNullOrEnum())
            {
                pCFI->_ff()._cuvSpaceBefore = cuvMarginTop;
            }

            // MARGIN-BOTTOM - on block elements margin top is treated as after space
            const CUnitValue & cuvMarginBottom = pCFI->_pff->GetLogicalMargin(SIDE_BOTTOM, fParentVertical, fWritingMode);
            if (!cuvMarginBottom.IsNullOrEnum())
            {
                pCFI->_ff()._cuvSpaceAfter = cuvMarginBottom;
            }

            // MARGIN-LEFT - on block elements margin left is treated as left indent
            if (!pCFI->_pff->GetLogicalMargin(SIDE_LEFT, fParentVertical, fWritingMode).IsNullOrEnum())
            {
                // We handle the various data types below when we accumulate values.
                fHasLeftIndent = TRUE;
            }

            // MARGIN-RIGHT - on block elements margin right is treated as right indent
            if (!pCFI->_pff->GetLogicalMargin(SIDE_RIGHT, fParentVertical, fWritingMode).IsNullOrEnum())
            {
                // We handle the various data types below when we accumulate values.
                fHasRightIndent = TRUE;
            }

            pCFI->UnprepareForDebug();
        }
        else
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fHasInlineMargins = TRUE;
            pCFI->UnprepareForDebug();
        }
    }

    //
    // FLOAT
    //
    // TODO -- This code needs to move back to ApplyFormatInfoProperty to ensure
    // that the alignment follows the correct ordering. (lylec)
    //

    if (fShouldHaveLayout && pCFI->_pff->_bStyleFloat != styleStyleFloatNotSet)
    {
        htmlControlAlign hca   = htmlControlAlignNotSet;
        BOOL             fDoIt = TRUE;

        switch (pCFI->_pff->_bStyleFloat)
        {
        case styleStyleFloatLeft:
            hca = htmlControlAlignLeft;
            if (fIsBlockElement)
            {
                pCFI->_bCtrlBlockAlign = htmlBlockAlignLeft;
            }
            break;

        case styleStyleFloatRight:
            hca = htmlControlAlignRight;
            if (fIsBlockElement)
            {
                pCFI->_bCtrlBlockAlign = htmlBlockAlignRight;
            }
            break;

        case styleStyleFloatNone:
            hca = htmlControlAlignNotSet;
            break;

        default:
            fDoIt = FALSE;
        }

        if (fDoIt)
        {
            ApplySiteAlignment(pCFI, hca, this);
            pCFI->_fCtrlAlignLast = TRUE;

            // Autoclear works for float from CSS.  Navigator doesn't
            // autoclear for HTML floating.  Another annoying Nav compat hack.

            if (!pCFI->_pff->_fCtrlAlignFromCSS)
            {
                pCFI->PrepareFancyFormat();
                pCFI->_ff()._fCtrlAlignFromCSS = TRUE;
                pCFI->UnprepareForDebug();
            }
        }
    }

    //
    // ALIGNMENT
    //
    // Alignment is tricky because DISPID_CONTROLALIGN should only set the
    // control align if it has layout, but sets the block alignment if it's
    // not.  Also, if the element has TAGDESC_OWNLINE then DISPID_CONTROLALIGN
    // sets _both_ the control alignment and block alignment.  However, you
    // can still have inline sites (that are not block elements) that have the
    // OWNLINE flag set.  Also, if both CONTROLALIGN and BLOCKALIGN are set,
    // we must remember the order they were applied.  The last kink is that
    // HR's break the pattern because they're not block elements but
    // DISPID_BLOCKALIGN does set the block align for them.
    //

    if (fShouldHaveLayout)
    {
        if (pCFI->_pff->_bControlAlign != pCFI->_bControlAlign)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bControlAlign = pCFI->_bControlAlign;
            pCFI->UnprepareForDebug();
        }

        // If a site is positioned explicitly (absolute) it
        // overrides control alignment. We do that by simply turning off
        // control alignment.
        //
        if (    pCFI->_pff->_bControlAlign != htmlControlAlignNotSet
            &&  (   pCFI->_pff->_bControlAlign == htmlControlAlignRight
                ||  pCFI->_pff->_bControlAlign == htmlControlAlignLeft))
        {
            pCFI->PrepareFancyFormat();

            if (    pCFI->_pff->_bPositionType == stylePositionabsolute
                &&  (   fHTMLLayout
                     || Tag() != ETAG_BODY ))
            {
                pCFI->_ff()._bControlAlign = htmlControlAlignNotSet;
                pCFI->_ff()._fAlignedLayout = FALSE;
            }
            else
            {
                pCFI->_ff()._fAlignedLayout = Tag() != ETAG_HR && Tag() != ETAG_LEGEND;
            }

            pCFI->UnprepareForDebug();

        }
    }

    if (!fComputeFFOnly)
    {   
        BOOL fOwnLine = fShouldHaveLayout && HasFlag(TAGDESC_OWNLINE);

        if (    fShouldHaveLayout
            && (    fNeedsOuter
                ||  IsRunOwner() ))
        {
            if (    pCFI->_ppf->_bBlockAlign != pCFI->_bCtrlBlockAlign
                ||  pCFI->_ppf->_bBlockAlignInner != pCFI->_bBlockAlign)
            {
                pCFI->PrepareParaFormat();
                if (!pCFI->_pff->_fAlignedLayout)
                    pCFI->_pf()._bBlockAlign = pCFI->_bCtrlBlockAlign;
                pCFI->_pf()._bBlockAlignInner = pCFI->_bBlockAlign;
                pCFI->UnprepareForDebug();
            }
        }
        else if (fIsBlockElement || fOwnLine)
        {
            BYTE bAlign = pCFI->_bBlockAlign;

            if ((  (   !fIsBlockElement
                    && Tag() != ETAG_HR)
                 || pCFI->_fCtrlAlignLast)
                && (fOwnLine || !fShouldHaveLayout))
            {
                bAlign = pCFI->_bCtrlBlockAlign;
            }

            if (    pCFI->_ppf->_bBlockAlign != bAlign
                ||  pCFI->_ppf->_bBlockAlignInner != bAlign)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bBlockAlign = bAlign;
                pCFI->_pf()._bBlockAlignInner = bAlign;
                pCFI->UnprepareForDebug();
            }
        }

        //
        // DIRECTION
        //
        if (    fShouldHaveLayout
            && (    fNeedsOuter
                ||  IsRunOwner()
                ||  (   Tag() == ETAG_HTML
                    &&  fHTMLLayout     )))
        {
            if(     (fIsBlockElement && pCFI->_ppf->_fRTL != pCFI->_pcf->_fRTL)
                ||  (pCFI->_ppf->_fRTLInner != pCFI->_pcf->_fRTL))
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTLInner = pCFI->_pcf->_fRTL;
                // paulnel - we only set the inner for these guys because the
                //           positioning of the layout is determined by the
                //           parent and not by the outter _fRTL
                pCFI->UnprepareForDebug();
            }
        }
        else if (fIsBlockElement || fOwnLine)
        {
            if (pCFI->_ppf->_fRTLInner != pCFI->_pcf->_fRTL ||
                pCFI->_ppf->_fRTL != pCFI->_pcf->_fRTL)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._fRTLInner = pCFI->_pcf->_fRTL;
                pCFI->_pf()._fRTL = pCFI->_pcf->_fRTL;
                pCFI->UnprepareForDebug();
            }
        }
        if (pCFI->_fBidiEmbed != pCFI->_pcf->_fBidiEmbed ||
            pCFI->_fBidiOverride != pCFI->_pcf->_fBidiOverride)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fBidiEmbed = pCFI->_fBidiEmbed;
            pCFI->_cf()._fBidiOverride = pCFI->_fBidiOverride;
            pCFI->UnprepareForDebug();
        }

        //
        // TEXTINDENT
        //

        // We used to apply text-indent only to block elems; now we apply regardless because text-indent
        // is always inherited, meaning inline elems can end up having text-indent in their PF 
        // (via format inheritance and not Apply).  If we don't allow Apply() to set it on inlines,
        // there's no way to change what's inherited.  This provides a workaround for bug #67276.

        if (!pCFI->_cuvTextIndent.IsNull())
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvTextIndent = pCFI->_cuvTextIndent;
            pCFI->UnprepareForDebug();
        }

        if (fIsBlockElement)
        {

            //
            // TEXTJUSTIFY
            //

            if (pCFI->_uTextJustify)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._uTextJustify = pCFI->_uTextJustify;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTALIGNLAST
            //

            if (pCFI->_uTextAlignLast)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._uTextAlignLast = pCFI->_uTextAlignLast;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTJUSTIFYTRIM
            //

            if (pCFI->_uTextJustifyTrim)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._uTextJustifyTrim = pCFI->_uTextJustifyTrim;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTKASHIDA
            //

            if (!pCFI->_cuvTextKashida.IsNull())
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._cuvTextKashida = pCFI->_cuvTextKashida;
                pCFI->UnprepareForDebug();
            }

            //
            // TEXTKASHIDASPACE
            //

            if (!pCFI->_cuvTextKashidaSpace.IsNull())
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._cuvTextKashidaSpace = pCFI->_cuvTextKashidaSpace;
                pCFI->UnprepareForDebug();
            }
        }

        //
        // LAYOUT-GRID
        //

        if (pCFI->_pcf->HasLayoutGrid(TRUE))
        {
            if (!fIsBlockElement)
            {
                //
                // ApplyDefaultFormat() can set 'layout-grid-type', 'layout-grid-line' and 
                // 'layout-grid-char' to non-block elements. In this case we need to keep old
                // values (stored in outer format).
                //
                if (    pCFI->_ppf != pCFI->_ppfSrc
                    &&  (   pCFI->_ppf->_cuvCharGridSizeInner.GetRawValue() != pCFI->_ppf->_cuvCharGridSize.GetRawValue()
                        ||  pCFI->_ppf->_cuvLineGridSizeInner.GetRawValue() != pCFI->_ppf->_cuvLineGridSize.GetRawValue()
                        ||  pCFI->_ppf->_uLayoutGridTypeInner != pCFI->_ppf->_uLayoutGridType))
                {
                    pCFI->PrepareParaFormat();

                    pCFI->_pf()._cuvCharGridSizeInner = pCFI->_ppf->_cuvCharGridSize;
                    pCFI->_pf()._cuvLineGridSizeInner = pCFI->_ppf->_cuvLineGridSize;
                    pCFI->_pf()._uLayoutGridTypeInner = pCFI->_ppf->_uLayoutGridType;

                    // In case of change of layout-grid-char or layout-grid-line, 
                    // layout-grid-mode must be updated if its value is not set.
                    if (    pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNotSet
                        ||  (   pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeNone
                            &&  pCFI->_pcf->_uLayoutGridModeInner & styleLayoutGridModeBoth))
                    {
                        pCFI->PrepareCharFormat();

                        // Now _uLayoutGridModeInner can be one of { 000, 101, 110, 111 }
                        // it means that layout-grid-mode is not set

                        if (pCFI->_ppf->_cuvCharGridSizeInner.IsNull())
                        {   // clear deduced char mode
                            pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeLine);
                            if (pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNone)
                                pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
                        }
                        else
                        {   // set deduced char mode
                            pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeChar);
                        }

                        if (pCFI->_ppf->_cuvLineGridSizeInner.IsNull())
                        {   // clear deduced line mode
                            pCFI->_cf()._uLayoutGridModeInner &= (styleLayoutGridModeNone | styleLayoutGridModeChar);
                            if (pCFI->_pcf->_uLayoutGridModeInner == styleLayoutGridModeNone)
                                pCFI->_cf()._uLayoutGridModeInner = styleLayoutGridModeNotSet;
                        }
                        else
                        {   // set deduced line mode
                            pCFI->_cf()._uLayoutGridModeInner |= (styleLayoutGridModeNone | styleLayoutGridModeLine);
                        }
                    }
                    pCFI->UnprepareForDebug();
                }
            }
            if (!fShouldHaveLayout)
            {
                // Set outer format to inner
                if (pCFI->_pcf->_uLayoutGridMode != pCFI->_pcf->_uLayoutGridModeInner)
                {
                    pCFI->PrepareCharFormat();
                    pCFI->_cf()._uLayoutGridMode = pCFI->_pcf->_uLayoutGridModeInner;
                    pCFI->UnprepareForDebug();
                }
                if (    pCFI->_ppf->_uLayoutGridType != pCFI->_ppf->_uLayoutGridTypeInner
                    ||  pCFI->_ppf->_cuvCharGridSize.GetRawValue() != pCFI->_ppf->_cuvCharGridSizeInner.GetRawValue()
                    ||  pCFI->_ppf->_cuvLineGridSize.GetRawValue() != pCFI->_ppf->_cuvLineGridSizeInner.GetRawValue())
                {
                    pCFI->PrepareParaFormat();
                    pCFI->_pf()._uLayoutGridType = pCFI->_ppf->_uLayoutGridTypeInner;
                    pCFI->_pf()._cuvCharGridSize = pCFI->_ppf->_cuvCharGridSizeInner;
                    pCFI->_pf()._cuvLineGridSize = pCFI->_ppf->_cuvLineGridSizeInner;
                    pCFI->UnprepareForDebug();
                }
            }
        }

        if (   pCFI->_pff->_fHasAlignedFL
            && (   pCFI->_pff->GetVerticalAlign() != styleVerticalAlignNotSet
                || pCFI->_pff->HasCSSVerticalAlign()
               )
           )
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetVerticalAlign(styleVerticalAlignNotSet);
            pCFI->_ff().SetCSSVerticalAlign(FALSE);
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Process any image urls (for background images, li's, etc).
    //
    if (pCFI->_fHasSomeBgImage)
    {
        if (!pCFI->_cstrBgImgUrl.IsNull())
        {
            pCFI->PrepareFancyFormat();
            pCFI->ProcessImgUrl(this, pCFI->_cstrBgImgUrl,
                DISPID_A_BGURLIMGCTXCACHEINDEX, &pCFI->_ff()._lImgCtxCookie, fShouldHaveLayout);
            pCFI->UnprepareForDebug();
            pCFI->_cstrBgImgUrl.Free();
        }

        if (    pCFI->_fBgColorInFLetter
            && !pCFI->_fBgImageInFLetter
            &&  pCFI->_fBgImageInFLine
           )
        {
            pCFI->_cstrPseudoBgImgUrl.Free();
        }

        if (!pCFI->_cstrPseudoBgImgUrl.IsNull())
        {
            pCFI->PreparePEI();
            pCFI->ProcessImgUrl(this, pCFI->_cstrPseudoBgImgUrl,
                (pCFI->_pff->_fHasFirstLetter
                                ? DISPID_A_BGURLIMGCTXCACHEINDEX_FLETTER
                                : DISPID_A_BGURLIMGCTXCACHEINDEX_FLINE
                ),
                &pCFI->_pei()._lImgCtxCookie, fShouldHaveLayout);
            pCFI->UnprepareForDebug();
            pCFI->_cstrPseudoBgImgUrl.Free();
        }

        if (!pCFI->_cstrLiImgUrl.IsNull())
        {
            pCFI->PrepareParaFormat();
            pCFI->ProcessImgUrl(this, pCFI->_cstrLiImgUrl,
                DISPID_A_LIURLIMGCTXCACHEINDEX, &pCFI->_pf()._lImgCookie, fShouldHaveLayout);
            pCFI->UnprepareForDebug();
            pCFI->_cstrLiImgUrl.Free();
        }
    }
    
    //
    // ******** ACCUMULATE VALUES **********
    //

    if (!fComputeFFOnly)
    {
        //
        // LEFT/RIGHT indents
        //

        if (fHasLeftIndent)
        {
            const CUnitValue & cuvMarginLeft = pCFI->_pff->GetLogicalMargin(SIDE_LEFT, fParentVertical, fWritingMode);

            pCFI->PrepareParaFormat();

            Assert (!cuvMarginLeft.IsNullOrEnum());

            //
            // LEFT INDENT
            //
            switch (cuvMarginLeft.GetUnitType())
            {
            case CUnitValue::UNIT_PERCENT:
                pCFI->_pf()._cuvLeftIndentPercent.SetValue(
                    pCFI->_pf()._cuvLeftIndentPercent.GetUnitValue() +
                    cuvMarginLeft.GetUnitValue(),
                    CUnitValue::UNIT_PERCENT);
                break;

            case CUnitValue::UNIT_EM:
            case CUnitValue::UNIT_EX:
                if ( lFontHeight == 1 )
                    lFontHeight = pCFI->_pcf->GetHeightInTwips(pDoc);
                // Intentional fall-through...
            default:
                {
                    CUnitValue uvMarginLeft = cuvMarginLeft;
                    hr = uvMarginLeft.ConvertToUnitType(CUnitValue::UNIT_POINT, 0,
                                               CUnitValue::DIRECTION_CX, lFontHeight);
                    if (hr)
                        goto Cleanup;

                    pCFI->_pf()._cuvLeftIndentPoints.SetValue(
                        pCFI->_pf()._cuvLeftIndentPoints.GetUnitValue() +
                        uvMarginLeft.GetUnitValue(),
                        CUnitValue::UNIT_POINT);
                }
            }
            pCFI->UnprepareForDebug();
        }

            //
            // RIGHT INDENT
            //
        if (fHasRightIndent)
        {
            const CUnitValue & cuvMarginRight = pCFI->_pff->GetLogicalMargin(SIDE_RIGHT, fParentVertical, fWritingMode);

            pCFI->PrepareParaFormat();

            Assert (!cuvMarginRight.IsNullOrEnum());

            switch(cuvMarginRight.GetUnitType() )
            {
            case CUnitValue::UNIT_PERCENT:
                pCFI->_pf()._cuvRightIndentPercent.SetValue(
                    pCFI->_pf()._cuvRightIndentPercent.GetUnitValue() +
                    cuvMarginRight.GetUnitValue(),
                    CUnitValue::UNIT_PERCENT);
                break;

            case CUnitValue::UNIT_EM:
            case CUnitValue::UNIT_EX:
                if ( lFontHeight == 1 )
                    lFontHeight = pCFI->_pcf->GetHeightInTwips(pDoc);
                // Intentional fall-through...
            default:
                {
                    CUnitValue uvMarginRight = cuvMarginRight;
                    hr = uvMarginRight.ConvertToUnitType(CUnitValue::UNIT_POINT, 0,
                                               CUnitValue::DIRECTION_CX, lFontHeight);
                    if (hr)
                        goto Cleanup;

                    pCFI->_pf()._cuvRightIndentPoints.SetValue(
                        pCFI->_pf()._cuvRightIndentPoints.GetUnitValue()  +
                        uvMarginRight.GetUnitValue(),
                        CUnitValue::UNIT_POINT);
                }
            }

            pCFI->UnprepareForDebug();
        }

        if (IsListItem(pCFI->_pNodeContext, pCFI->_pff))
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvNonBulletIndentPoints.SetValue(0, CUnitValue::UNIT_POINT);
            pCFI->UnprepareForDebug();
        }

        //
        // LINE HEIGHT
        //
        switch ( pCFI->_pcf->_cuvLineHeight.GetUnitType() )
        {
        case CUnitValue::UNIT_EM:
        case CUnitValue::UNIT_EX:
            pCFI->PrepareCharFormat();
            if ( lFontHeight == 1 )
                lFontHeight = pCFI->_cf().GetHeightInTwips(pDoc);
            hr = pCFI->_cf()._cuvLineHeight.ConvertToUnitType( CUnitValue::UNIT_POINT, 1,
                CUnitValue::DIRECTION_CX, lFontHeight );
            pCFI->UnprepareForDebug();
            break;

        case CUnitValue::UNIT_PERCENT:
        {
            pCFI->PrepareCharFormat();
            if ( lFontHeight == 1 )
                lFontHeight = pCFI->_cf().GetHeightInTwips(pDoc);

            //
            // The following line of code does multiple things:
            //
            // 1) Takes the height in twips and applies the percentage scaling to it
            // 2) However, the percentages are scaled so we divide by the unit_percent
            //    scale multiplier
            // 3) Remember that its percent, so we need to divide by 100. Doing this
            //    gives us the desired value in twips.
            // 4) Dividing that by 20 and we get points.
            // 5) This value is passed down to SetPoints which will then scale it by the
            //    multiplier for points.
            //
            // (whew!)
            //
            pCFI->_cf()._cuvLineHeight.SetPoints(MulDivQuick(lFontHeight,
                        pCFI->_cf()._cuvLineHeight.GetUnitValue(),
                        20 * 100 * LONG(CUnitValue::TypeNames[CUnitValue::UNIT_PERCENT].wScaleMult)));

            pCFI->UnprepareForDebug();
        }
        break;
        }
    }

    if (    pCFI->_pff->_bPositionType == stylePositionrelative
        ||  pCFI->_pff->_bPositionType == stylePositionabsolute
        ||  fMainBody
        ||  Tag() == ETAG_ROOT)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fPositioned = TRUE;
        pCFI->UnprepareForDebug();
    }
    // cache important values
    if (pCFI->_pff->_fShouldHaveLayout)
    {
        if (    !TestClassFlag(ELEMENTDESC_NEVERSCROLL)
            &&  (   pCFI->_pff->GetOverflowX() == styleOverflowAuto
                ||  pCFI->_pff->GetOverflowX() == styleOverflowScroll
                ||  pCFI->_pff->GetOverflowY() == styleOverflowAuto
                ||  pCFI->_pff->GetOverflowY() == styleOverflowScroll
                ||  (pCFI->_pff->GetOverflowX() == styleOverflowHidden && !pDoc->_fInHomePublisherDoc && !g_fInHomePublisher98)
                ||  (pCFI->_pff->GetOverflowY() == styleOverflowHidden && !pDoc->_fInHomePublisherDoc && !g_fInHomePublisher98)
                ||  TestClassFlag(ELEMENTDESC_CANSCROLL)
                ||  (   !fHTMLLayout
                     && Tag() == ETAG_BODY )
                ||  (   fHTMLLayout
                     && Tag() == ETAG_HTML )))
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fScrollingParent = TRUE;
            pCFI->UnprepareForDebug();
        }
    }

    if (    (fHTMLLayout ? 
                Tag() == ETAG_HTML 
              : pCFI->_pff->_fScrollingParent)
        ||  pCFI->_pff->_fPositioned

            // IE:DEVICERECT is a z-parent too
        ||  pCFI->_pff->GetMediaReference() != mediaTypeNotSet
        
            // Make the master ZParent for content in viewLink
            // Do this only for ident. behaviors for now - play safe for (I)FRAME, INPUT, etc.
        ||  HasSlavePtr() && TagType() == ETAG_GENERIC )
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fZParent = TRUE;
        pCFI->UnprepareForDebug();
    }

    if (    pCFI->_pff->_fPositioned
        &&  (   pCFI->_pff->_bPositionType != stylePositionabsolute
            ||  (  pCFI->_pff->GetLogicalPosition(SIDE_TOP, fParentVertical, fWritingMode).IsNullOrEnum() 
                && pCFI->_pff->GetLogicalPosition(SIDE_BOTTOM, fParentVertical, fWritingMode).IsNullOrEnum())
            ||  (  pCFI->_pff->GetLogicalPosition(SIDE_LEFT, fParentVertical, fWritingMode).IsNullOrEnum() 
                && pCFI->_pff->GetLogicalPosition(SIDE_RIGHT, fParentVertical, fWritingMode).IsNullOrEnum())))
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fAutoPositioned = TRUE;
        pCFI->UnprepareForDebug();
    }

    // 
    // USER HEIGHT 
    // 
    if (    pMarkup->IsStrictCSS1Document() 
        &&  fShouldHaveLayout   )
    {
        BOOL fHasHeight     = FALSE;
        BOOL fPercentHeight = FALSE;
        BOOL fUseUserHeightParent = pCFI->_pcfSrc->_fUseUserHeight; 
        BOOL fUseUserHeightThis;

        if (fMainBody)
        {
            // If this is a main body (e.g. (ETAG_BODY && !HTMLLayout) || (ETAG_HTML && HTMLLayout))
            // its parent (which is viewport) always has a height.
            fUseUserHeightParent = TRUE;
            fHasHeight = TRUE;
        }
        else if (Tag() == ETAG_TD || Tag() == ETAG_TH)
        {
            // For table cells we need to go up to table element and pick up its flag 
            CElement *pElementTable = GetParentAncestorSafe(ETAG_TABLE); 
            if (pElementTable) 
                fUseUserHeightParent = pElementTable->GetFirstBranch()->GetCharFormat()->_fUseUserHeight;
        }

        if (!pCFI->_pff->GetHeight().IsNullOrEnum())
        {
            // 
            // NOTE (table specific) : For NS/IE compatibility, treat negative values as not present
            // 
            if (    Tag() != ETAG_TABLE
                ||  pCFI->_pff->GetHeight().GetUnitValue() > 0  )
            {
                fHasHeight     = TRUE;
                fPercentHeight = pCFI->_pff->GetHeight().IsPercent();
            }
        }

        Check(!fPercentHeight || fHasHeight);
        fUseUserHeightThis = fPercentHeight ? fUseUserHeightParent : fHasHeight;

        if (fUseUserHeightThis != pCFI->_pcf->_fUseUserHeight)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fUseUserHeight = fUseUserHeightThis;
            pCFI->UnprepareForDebug();
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CElement::ApplyDefaultFormat(CFormatInfo * pCFI)
{
    HRESULT             hr = S_OK;
    CMarkup *           pMarkup = GetMarkup();
    CDoc *              pDoc;
    OPTIONSETTINGS *    pos;
    BOOL                fUseStyleSheets;

    // tree-stress crash
    if (!pMarkup)
        goto Cleanup;

    pDoc = pMarkup->Doc();
    if (!pDoc)
        goto Cleanup;
    
    pos = pDoc->_pOptionSettings;
    fUseStyleSheets = !pos || pos->fUseStylesheets;
    
    if (    _pAA
        ||  ( fUseStyleSheets && (pDoc->HasHostStyleSheets() || pMarkup->HasStyleSheets()) )
        ||  ( pos && pos->fUseMyStylesheet)
        ||  (HasSlavePtr() && TagType() == ETAG_GENERIC)
        ||  (HasPeerHolder()) )
    {
        CAttrArray *        pInLineStyleAA;
        CAttrArray *        pDefaultStyleAA;
        CAttrArray *        pRuntimeStyleAA;
        CStyle *            pRuntimeStyle;
        CDefaults *         pDefaults;
        BOOL                fUserImportant = FALSE;
        BOOL                fDocumentImportant = FALSE;
        BOOL                fDefaultImportant = FALSE;
        BOOL                fInlineImportant = FALSE;
        BOOL                fRuntimeImportant = FALSE;
        BOOL                fPeerImportant;

        // TODO (ktam) elements created via CreateElement will be in a markup that doesn't have a window;
        // we have no way of getting media information at that point, so we'll just default to screen media.
        // Hopefully formats get recomputed when the element gets attached elsewhere.
        EMediaType          eMediaType = pMarkup->IsPrintMedia() ? MEDIA_Print : MEDIA_Screen;

        Assert(pCFI && pCFI->_pNodeContext && SameScope(this, pCFI->_pNodeContext));

        if (HasSlavePtr() && TagType() == ETAG_GENERIC)
        {
            pCFI->PrepareFancyFormat();
            
            pCFI->_ff().SetOverflowX(styleOverflowAuto);
            pCFI->_ff().SetOverflowY(styleOverflowAuto);

            // set default size for viewlinked frameset to be the same as IFRAME
            if (GetSlavePtr()->GetMarkup()->_fFrameSet)
            {
                pCFI->_ff().SetWidth(CUnitValue(300, CUnitValue::UNIT_PIXELS));
                pCFI->_ff().SetHeight(CUnitValue(150, CUnitValue::UNIT_PIXELS));
            }

            pCFI->UnprepareForDebug();                      
        }

        // Ignore user's stylesheet and accessability settings if we're in a trusted dialog
        // ...unless we're in a content document for printing.
        if (    !pDoc->_fInTrustedHTMLDlg
            ||  IsPrintMedia() )
        {
            pDoc->EnsureUserStyleSheets();

            if (TLS(pUserStyleSheets))
            {
                hr = THR(TLS(pUserStyleSheets)->Apply(pCFI, APPLY_NoImportant, eMediaType, &fUserImportant));
                if (hr)
                    goto Cleanup;
            }

            pCFI->_fAlwaysUseMyColors   = g_fHighContrastMode ? TRUE : pos->fAlwaysUseMyColors;
            pCFI->_fAlwaysUseMyFontFace = pos->fAlwaysUseMyFontFace;
            pCFI->_fAlwaysUseMyFontSize = pos->fAlwaysUseMyFontSize;
        }

        // Apply any HTML formatting properties
        if (_pAA)
        {
            // Note: ApplyAttrArrayValues checks to see if _pAA is NULL, but we do not want
            // to even call it if _pAA is NULL.
            hr = THR(ApplyAttrArrayValues(pCFI, &_pAA, NULL, APPLY_All, NULL, FALSE));
            if (hr)
                goto Cleanup;
        }

        // Apply defaults
        pDefaults = GetDefaults();
        if (pDefaults)
        {
            pDefaultStyleAA = pDefaults->GetStyleAttrArray();
            if (pDefaultStyleAA)
            {
                hr = THR(ApplyAttrArrayValues(pCFI, &pDefaultStyleAA, NULL, 
                        APPLY_NoImportant, &fDefaultImportant, TRUE, 
                        Doc()->_recalcHost.GetSetValueDispid(this)));
                if (hr)
                    goto Cleanup;
            }
        }

        // Skip author stylesheet properties if they're turned off.
        if (fUseStyleSheets)
        {
            TraceTag((tagRecalcStyle, "Applying author style sheets"));

            hr = THR(pMarkup->ApplyStyleSheets(pCFI, APPLY_NoImportant, eMediaType, &fDocumentImportant));
            if (hr)
                goto Cleanup;

            if (_pAA)
            {
                // Apply any inline STYLE rules

                pInLineStyleAA = GetInLineStyleAttrArray();

                if (pInLineStyleAA)
                {
                    TraceTag((tagRecalcStyle, "Applying inline style attr array"));

                    //
                    // The last parameter to ApplyAttrArrayValues is used to prevent the expression of that dispid from being
                    // overwritten.
                    //
                    // TODO (michaelw) this hackyness should go away when we store both the expression and the value in a single CAttrValue
                    //

                    hr = THR(ApplyAttrArrayValues(pCFI, &pInLineStyleAA, NULL, APPLY_NoImportant, &fInlineImportant, TRUE, Doc()->_recalcHost.GetSetValueDispid(this)));
                    if (hr)
                        goto Cleanup;
                }

                pRuntimeStyle = GetRuntimeStylePtr();
                if (pRuntimeStyle)
                {
                    CAttrArray **ppRuntimeStyleAA = pRuntimeStyle->GetAttrArray();
                    pRuntimeStyleAA = ppRuntimeStyleAA ? *ppRuntimeStyleAA : NULL;
                    if (pRuntimeStyleAA)
                    {
                        TraceTag((tagRecalcStyle, "Applying runtime style attr array"));

                        //
                        // The last parameter to ApplyAttrArrayValues is used to 
                        // prevent the expression of that dispid from being
                        // overwritten.
                        //
                        // TODO (michaelw) this hackyness should go away when 
                        // we store both the expression and the value in a single CAttrValue
                        //

                        hr = THR(ApplyAttrArrayValues(pCFI, &pRuntimeStyleAA, NULL, 
                                APPLY_NoImportant, &fRuntimeImportant, TRUE, 
                                Doc()->_recalcHost.GetSetValueDispid(this)));
                        if (hr)
                            goto Cleanup;
                    }
                }
            }

            if (pMarkup->HasCFState())
            {
                CTreeNode *pNode = pCFI->_pNodeContext;
                CComputeFormatState* pcfState = pMarkup->GetCFState();

                //
                // When we have both tag level rules and wildcard rules, we need
                // to reapply all the first-letter rules. Consider the case where we have
                // p:first-line and .classp both specifying the color. We will first
                // apply the color from p:first-line which will be overidden by the
                // .classp rule. To overcome this problem we reapply *only* the first
                // line rules here. We do this only for the block element which has
                // the pseudo element specified, since the other ones will inherit the
                // correct color.
                //
                if (pcfState->GetComputingFirstLine(pNode))
                {
                    CTreeNode *pNodeBlock = pcfState->GetBlockNodeLine();

                    // Apply only for the element intiating the pseudo element
                    if (SameScope(pNodeBlock, pNode))
                    {
                        // Apply on first line properties...
                        pCFI->_fFirstLineOnly = TRUE;
                        hr = THR(pMarkup->ApplyStyleSheets(pCFI, APPLY_NoImportant, eMediaType, &fDocumentImportant));

                        // Resotre state before checking if Apply* succeeded.
                        pCFI->_fFirstLineOnly = FALSE;

                        if (hr)
                            goto Cleanup;
                    }
                }

                //
                // If we are computing the first letter then we need to apply all the
                // first-letter pseudo element rules for the containing block element
                // after we have applied all the inline formats because first-letter
                // overrides the inline attrs/styles.
                //
                // So if there were a B inside a P which had first-letter, then when
                // applying the properties for B we would call to apply the properties
                // for P -- but only the first-letter properties.
                //
                // Remember that this is the only time, where we look *up* in the tree
                // when we are computing formats for a node.
                //
                if (pcfState->GetComputingFirstLetter(pNode))
                {
                    CTreeNode *pNodeBlock = pcfState->GetBlockNodeLetter();

                    // Apply only the first letter properties...
                    pCFI->_fFirstLetterOnly = TRUE;

                    // To calculate relative font-size always use the parent size
                    // to avoid applying relative value more than once.
                    pCFI->_fUseParentSizeForPseudo = !SameScope(pNode, pNodeBlock);

                    // for the parent block element only
                    pCFI->_pNodeContext = pNodeBlock;
                    hr = THR(pMarkup->ApplyStyleSheets(pCFI, APPLY_NoImportant, eMediaType, &fDocumentImportant));

                    // restore before checking if Apply* succeeded.
                    pCFI->_pNodeContext = pNode;
                    pCFI->_fFirstLetterOnly = FALSE;

                    if (hr)
                        goto Cleanup;
                }
            }
        }

        fPeerImportant = HasPeerHolder() && (pCFI->_eExtraValues == ComputeFormatsType_Normal);
        
        if (fDefaultImportant | fDocumentImportant | fInlineImportant | fRuntimeImportant | fPeerImportant | fUserImportant)
        {
            // Now handle any "!important" properties.
            // Order: default, document !important, inline, runtime, user !important.

            // Apply any default STYLE !important rules
            if (fDefaultImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important default styles"));

                hr = THR(ApplyAttrArrayValues(pCFI, &pDefaultStyleAA, NULL, APPLY_ImportantOnly));
                if (hr)
                    goto Cleanup;
            }

            // Apply any document !important rules
            if (fDocumentImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important doc styles"));

                hr = THR(pMarkup->GetStyleSheetArray()->Apply(pCFI, APPLY_ImportantOnly, eMediaType));
                if (hr)
                    goto Cleanup;
            }

            // Apply any inline STYLE rules
            if (fInlineImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important inline styles"));

                hr = THR(ApplyAttrArrayValues(pCFI, &pInLineStyleAA, NULL, APPLY_ImportantOnly));
                if (hr)
                    goto Cleanup;
            }

            // Apply any runtime important STYLE rules
            if (fRuntimeImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important runtimestyles"));

                hr = THR(ApplyAttrArrayValues(pCFI, &pRuntimeStyleAA, NULL, APPLY_ImportantOnly));
                if (hr)
                    goto Cleanup;
            }
        
            if (fPeerImportant)
            {
                CPeerHolder *   pPeerHolder = GetPeerHolder();

                if (pPeerHolder->TestFlagMulti(CPeerHolder::NEEDAPPLYSTYLE) &&
                    !pPeerHolder->TestFlagMulti(CPeerHolder::LOCKAPPLYSTYLE))
                {
                    //
                    // This needs to be deferred so that arbitrary script code
                    // does not run inside of the Compute pass.
                    //

                    AssertSz( FALSE, "This has been disabled and shouldn't happen - talk to JHarding" );
                    hr = THR(ProcessPeerTask(PEERTASK_APPLYSTYLE_UNSTABLE));
                    if (hr)
                        goto Cleanup;
                }
            }

            // Apply user !important rules last for accessibility
            if (fUserImportant)
            {
                TraceTag((tagRecalcStyle, "Applying important user styles"));

                hr = THR(TLS(pUserStyleSheets)->Apply(pCFI, APPLY_ImportantOnly, eMediaType));
                if (hr)
                    goto Cleanup;
            }
        }
    }
    
    if (ComputeFormatsType_ForceDefaultValue == pCFI->_eExtraValues)
    {
        Assert(pCFI->_pStyleForce);
        CAttrArray **ppAA = pCFI->_pStyleForce->GetAttrArray();
        if (ppAA)
        {
            hr = THR(ApplyAttrArrayValues(pCFI, ppAA, NULL, APPLY_All));
        }
        goto Cleanup;
    }

    //
    // Setup layoutflow of nested layouts. We may have a differing default layout flow 
    // than our parent only if:
    //
    //  1) There are vertical layouts in this document
    //  1.1) We are computing CF and PF and not just FF
    //  2) The layout flow has not been set explicitly on this element
    //  3) This element is in a vertical flow layout
    //  4) and finally, this element if in a vertical layout, will still be horizontal
    //
    if (   GetMarkup()->_fHaveDifferingLayoutFlows
        && (pCFI->_pNodeContext->GetICF(FCPARAM) == -1) // !fComputeFFOnly
       )
    {
        if (   !pCFI->_pff->_fLayoutFlowSet
            && pCFI->_pcf->HasVerticalLayoutFlow()
            && ElementHIV(Tag())
           )
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._wLayoutFlow = styleLayoutFlowHorizontal;
            if (!pCFI->_cf()._fExplicitAtFont)
            {
                if (pCFI->_cf().NeedAtFont())
                {
                    ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
                }
                else
                {
                    RemoveAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
                }
            }

            pCFI->PrepareFancyFormat();
            pCFI->_ff()._fLayoutFlowChanged = TRUE;

            pCFI->UnprepareForDebug();
        }

        if (pCFI->_pcf->HasVerticalLayoutFlow())
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
            pCFI->UnprepareForDebug();
        }
    }

Cleanup:
    RRETURN(hr);
}

//--------------------------------------------------------------
//
// Method:      CElement::AddFilters
//
// Description: Called async from EnsureView, this method looks at
//              the filter string and destroys and/or creates the
//              filter collection (and each filter).  If this method
//              is called we assume that we are replacing the 
//              old filter collection with a new one.
//
//--------------------------------------------------------------

HRESULT
CElement::AddFilters()
{
    CFilterBehaviorSite  *pFS;;

    HRESULT hr;

    hr = THR(EnsureFilterBehavior(TRUE, &pFS));
    if(hr)
        goto Cleanup;
       
    // Build the add the fiters
    hr = THR(pFS->ParseAndAddFilters());

Cleanup:

    RRETURN(hr);
}


//+-----------------------------------------------------------------------------
//
//  Method: CElement::EnsureFilterBehavior
//
//  Overview: 
//      Creates the CFilterBehaviorSite and the behavior itself.  If 
//      fForceRemoveAll is FALSE and a filter behavior is already attatched to
//      the element the funtion just retuns S_FALSE.
//
//------------------------------------------------------------------------------
HRESULT
CElement::EnsureFilterBehavior(BOOL fForceReplaceOld, CFilterBehaviorSite **ppSite /* =  NULL */)
{
    HRESULT                hr;
    CFilterBehaviorSite  * pFS      = NULL;
    CTreeNode            * pNode    = GetFirstBranch();

    if (!pNode)
    {
        hr = E_PENDING;

        goto Cleanup;
    }

    hr = THR(Doc()->EnsureFilterBehaviorFactory());

    if (hr)
    {
        goto Cleanup;
    }

    pFS = GetFilterSitePtr();

    // If it was requested that this function NOT replace the old filter 
    // behavior entirely, but we already have one then return S_FALSE.
    //
    // ##ISSUE: (mcalkins) We now never replace the filter behavior entirely so
    //          we may want to rethink this.  Maybe they have a good case for 
    //          really forcing the behavior replacement, but if there are
    //          private filters on the behavior, this will be very bad since
    //          external code will have pointers to filters that they need to
    //          remain valid.

    if (   !fForceReplaceOld 
        && pFS 
        && pFS->HasBehaviorPtr())
    {
        if (ppSite)
        {
            *ppSite = pFS;
        }

        hr = S_FALSE;

        goto Cleanup;
    }

    // if we're in the middle of attaching a peer to the element already,
    // we'll have to try again later (bug 105894)

    if (TestLock(ELEMENTLOCK_ATTACHPEER))
    {
        hr = E_PENDING; 

        goto Cleanup;
    }

    if (!pFS)
    {
        // Create a filter site and filter behavior for this element.

        pFS = new CFilterBehaviorSite(this);

        if (!pFS)
        {
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }

        SetFilterSitePtr(pFS);
    }

    // Even if we don't successfully create the filter behavior, I think we
    // can return a pointer to the filter site we've successfully created and
    // set the CSS filter string.

    if (ppSite)
    {
        *ppSite = pFS;
    }

    pFS->SetFullText(pNode->GetFancyFormat()->_pszFilters);

    // Do whatever is needed to have a filter behavior with no CSS filters
    // attached to the element.  

    if (pFS->HasBehaviorPtr())
    {
       // Remove all of the current CSS filters from the filter behavior.

       hr = THR(pFS->RemoveAllCSSFilters());

       if (hr)
       {
           goto Cleanup;
       }
    }
    else
    {
        // Create the actual filter behavior.  Obviously, it will start off with
        // no CSS filters attatched.

        hr = THR(pFS->CreateFilterBehavior(this));

        if (hr)
        {
            goto Cleanup;
        }
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}
//  Method: CElement::EnsureFilterBehavior


// VoidCachedInfo -------------------------------------------------------------

void
CTreeNode::VoidCachedNodeInfo ()
{
    THREADSTATE * pts = GetThreadState();

    // Only CharFormat and ParaFormat are in sync.
    Assert( (_iCF == -1 && _iPF == -1) || (_iCF >= 0  && _iPF >= 0) );

    if(_iCF != -1)
    {
        TraceTag((tagFormatCaches, "Releasing format cache entries "
                                "(iFF: %d, iPF: %d, iCF:%d )  for "
                                "node (SN: N%d)",
                                _iFF, _iPF, _iCF,  SN()));

        MtAdd( Mt(CharParaFormatVoided), +1, 0 );

        (pts->_pCharFormatCache)->ReleaseData( _iCF );
        _iCF = -1;

        (pts->_pParaFormatCache)->ReleaseData( _iPF );
        _iPF = -1;
           
    }

    if(_iFF != -1)
    {
        MtAdd( Mt(FancyFormatVoided), +1, 0 );

        (pts->_pFancyFormatCache)->ReleaseData( _iFF );
        _iFF = -1;
    }

#ifdef MULTI_FORMAT
    if (_pFormatTable)
    {
        //right now, we invalidate everything
        _pFormatTable->VoidCachedInfo(pts);
        delete _pFormatTable;
        _pFormatTable = NULL;
        
    }
#endif//MULTI_FORMAT

    // NOTE this assert is meaningless with context (t-michda)
    Assert(_iCF == -1 && _iPF == -1 && _iFF == -1);

#ifndef GENERALISED_STEALING
    if (SameScope(TLS(_pNodeLast), this))
    {
        TLS(_pNodeLast) = NULL;
    }
#else
    if (   g_EtagCache[Tag()]
        && SameScope(TLS(_pNodeLast[Tag()]), this)
       )
    {
        TLS(_pNodeLast[Tag()]) = NULL;
    }
#endif
    
}

#ifdef MULTI_FORMAT

void
CFormatTable::VoidCachedInfo( THREADSTATE * pts)
{
    int nEntries = _aryFC.Size();
    
    for (int i = 0 ; i < nEntries; i++)
    {
        if(_aryFC[i]._iCF != -1)
        {
            TraceTag((tagFormatCaches, "Releasing format cache entries "
                                    "(iFF: %d, iPF: %d, iCF:%d )  for "
                                    "a format table for above node",
                                    _aryFC[i]._iFF, _aryFC[i]._iPF, _aryFC[i]._iCF));

            (pts->_pCharFormatCache)->ReleaseData( _aryFC[i]._iCF );
            _aryFC[i]._iCF = -1;

            (pts->_pParaFormatCache)->ReleaseData( _aryFC[i]._iPF );
            _aryFC[i]._iPF = -1;
           
        }

        if(_aryFC[i]._iFF != -1)
        {
            (pts->_pFancyFormatCache)->ReleaseData( _aryFC[i]._iFF );
            _aryFC[i]._iFF = -1;
        }
    }
}

#endif //MULTI_FORMAT

void
CTreeNode::VoidCachedInfo ()
{
    Assert( Element() );
    Element()->_fDefinitelyNoBorders = FALSE;

    if(Element()->GetLayoutPtr())
        Element()->GetLayoutPtr()->InvalidateFilterPeer(NULL, NULL, FALSE);

    VoidCachedNodeInfo();
}

void
CTreeNode::VoidFancyFormat()
{
    THREADSTATE * pts = GetThreadState();

    if(_iFF != -1)
    {
        MtAdd( Mt(FancyFormatVoided), +1, 0 );

        TraceTag((tagFormatCaches, "Releasing fancy format cache entry "
                                "(iFF: %d)  for "
                                "node (SN: N%d)",
                                _iFF,  SN()));

        (pts->_pFancyFormatCache)->ReleaseData( _iFF );
        _iFF = -1;

    }

#ifdef MULTI_FORMAT
    if (_pFormatTable)
    {
        _pFormatTable->VoidFancyFormat(pts);
    }
#endif //MULTI_FORMAT    

}

#ifdef MULTI_FORMAT

void
CFormatTable::VoidFancyFormat(THREADSTATE * pts)
{

    int nEntries = _aryFC.Size();
    
    for (int i = 0; i < nEntries; i++)
    {
        TraceTag((tagFormatCaches, "Releasing fancy format cache entry "
                                "(iFF: %d)  for "
                                "a format table for above node",
                                _aryFC[i]._iFF));
         (pts->_pFancyFormatCache)->ReleaseData(_aryFC[i]._iFF);
         _aryFC[i]._iFF = -1;
    }

}

#endif

void
CFormatInfo::SetMatchedBy(EPseudoElement pelemType)
{
    _ePseudoElement = pelemType;
}

EPseudoElement
CFormatInfo::GetMatchedBy()
{
    Assert(_ePseudoElement != pelemUnknown);
    return _ePseudoElement;
}

#ifdef MULTI_FORMAT

const CFormatTableEntry *
CFormatTable::FindEntry(void * pContextId)
{
    static const CFormatTableEntry defaultTableEntry = {NULL, -1, -1, -1};

    int nEntries = _aryFC.Size();
    for (int i=0; i<nEntries; i++)
    {
        if (_aryFC[i]._pContextId == pContextId)
        {
            return &_aryFC[i];
        }
    }

    return &defaultTableEntry;
}

CFormatTableEntry * 
CFormatTable::FindAndAddEntry(void * pContextId)
{
    CFormatTableEntry * pEntry = const_cast<CFormatTableEntry*>(FindEntry(pContextId));

    if (pEntry->_pContextId != NULL) // if FindEntry didn't return the default
    {
        return pEntry;
    }

    pEntry = _aryFC.Append();
    
    pEntry->_pContextId = pContextId;
    pEntry->_iCF = -1;
    pEntry->_iPF = -1;
    pEntry->_iFF = -1;

    return pEntry;
}

#endif //MULTI_FORMAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\formcoll.cxx ===
//+------------------------------------------------------------------------
//
//  File:       FORMCOLL.CXX
//
//  Contents:   Implementation of collection for CDoc
//
//  Classes:    (part of) CDoc
//              (part of) CMarkup for the Collection Cache (tomfakes)
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HEADELEMS_HXX_
#define X_HEADELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

DeclareTag(tagCollectionsAddToCollections, "Collections", "trace CMarkup::AddToCollections")

#define USE_TREE_FOR_ALL_COLLECTION 1

MtDefine(CDocRecomputeTreeCache_arySitesOriginal_pv, Locals, "CDoc::RecomputeTreeCache arySitesOriginal::_pv")
MtDefine(CDocRecomputeTreeCache_arySitesDetach_pv, Locals, "CDoc::RecomputeTreeCache arySitesDetach::_pv")
MtDefine(CDocRecomputeTreeCache_arySitesDormancy_pv, Locals, "CDoc::RecomputeTreeCAche arySitesDormancy::_pv")
MtDefine(CDocOnElementEnter_pTabs, Locals, "CDoc::OnElementEnter::_pTabs")
MtDefine(BldElementCol, PerfPigs, "Build CDoc::ELEMENT_COLLECTION")
MtDefine(BldFormsCol, PerfPigs, "Build CDoc::FORMS_COLLECTION")
MtDefine(BldAnchorsCol, PerfPigs, "Build CDoc::ANCHORS_COLLECTION")
MtDefine(BldLinksCol, PerfPigs, "Build CDoc::LINKS_COLLECTION")
MtDefine(BldImagesCol, PerfPigs, "Build CDoc::IMAGES_COLLECTION")
MtDefine(BldAppletsCol, PerfPigs, "Build CDoc::APPLETS_COLLECTION")
MtDefine(BldScriptsCol, PerfPigs, "Build CDoc::SCRIPTS_COLLECTION")
MtDefine(BldMapsCol, PerfPigs, "Build CDoc::MAPS_COLLECTION")
MtDefine(BldWindowCol, PerfPigs, "Build CDoc::WINDOW_COLLECTION")
MtDefine(BldEmbedsCol, PerfPigs, "Build CDoc::EMBEDS_COLLECTION")
MtDefine(BldRegionCol, PerfPigs, "Build CDoc::REGION_COLLECTION")
MtDefine(BldLabelCol, PerfPigs, "Build CDoc::LABEL_COLLECTION")
MtDefine(BldNavDocCol, PerfPigs, "Build CDoc::NAVDOCUMENT_COLLECTION")
MtDefine(BldFramesCol, PerfPigs, "Build CDoc::FRAMES_COLLECTION")
MtDefine(BldOtherCol, PerfPigs, "Build CDoc::OTHER_COLLECTION (Unknown)")
MtDefine(CAllCollectionCacheItem, CDoc, "CDoc::CAllCollectionCacheItem")

//+----------------------------------------------------------------------------
//
// Member:      RecomputeTreeCache
//
// Synopsis:    This member invalidates any cached information in the Doc and
//              causes a monster walk to take place to recalculate the cached
//              information.
//
//+----------------------------------------------------------------------------

class CTable;
class CTableRow;


class CCollectionBuildContext
{
public:
    CDoc *_pDoc;
    // Collection State
    long _lCollection;
    BOOL _fNeedNameID;
    BOOL _fNeedForm;

    CCollectionBuildContext (CDoc *pDoc)
    {
        _pDoc = pDoc;
        _lCollection = 0;
        _fNeedNameID = FALSE;
        _fNeedForm = FALSE;
    };
};

//+----------------------------------------------------------------------------
//
// Member:      EnsureCollectionCache
//
// Synopsis:    Ensures that the collection cache is built
//              NOTE: Ensures the _cache_, not the _collections_.
//
//+----------------------------------------------------------------------------

HRESULT
CMarkup::EnsureCollectionCache ( long lCollectionIndex )
{
    HRESULT hr;

    hr = THR(InitCollections());
    if (hr)
        goto Cleanup;

    hr = THR( CollectionCache()->EnsureAry( lCollectionIndex ) );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   rebuild the collections based on the current state of the tree
//
//-----------------------------------------------------------------------------



HRESULT
CMarkup::EnsureCollections( long lIndex, long * plCollectionVersion )
{
    HRESULT hr = S_OK;
    CCollectionBuildContext collectionWalker ( _pDoc );
    long l,lSize;
    CElement *pElemCurrent;
    CCollectionCache *pCollectionCache;

#ifdef PERFMETER
    static PERFMETERTAG s_mpColMtr[] = { Mt(BldElementCol), Mt(BldFormsCol), Mt(BldAnchorsCol), Mt(BldLinksCol), Mt(BldImagesCol),
        Mt(BldAppletsCol), Mt(BldScriptsCol), Mt(BldMapsCol), Mt(BldWindowCol), Mt(BldEmbedsCol), Mt(BldRegionCol),
        Mt(BldLabelCol), Mt(BldNavDocCol), Mt(BldFramesCol) };
#endif

    pCollectionCache = CollectionCache();
    if ( !pCollectionCache )
        goto Cleanup;

    // Optimize the use of the region collection. The doc flag is set by
    // the CSS code whenever theres a position: attribute on an element in the doc
    // This is a temporary Beta1 Hack to avoid building the regions collection
    if(lIndex == REGION_COLLECTION && !_pDoc->_fRegionCollection)  //$$tomfakes - move this flag to CMarkup?
    {
        pCollectionCache->ResetAry( REGION_COLLECTION ); // To be safe
        goto Cleanup;
    }


    if(lIndex == ELEMENT_COLLECTION)
    {
        goto Update; // All collection is always up to date, update the version no & bail out
    }
	else if ( lIndex == REGION_COLLECTION )
    {
        // We ignore the collection _fIsValid flag for the REGION_COLLECTION
		// because it is unaffected by element name changes
        if (*plCollectionVersion == GetMarkupTreeVersion())
            goto Cleanup;
    }
    else
    {
        // Collections that are specificaly invalidated
        if (pCollectionCache->IsValidItem(lIndex))
		{
			// Doesn't change collection version, collections based on this one don't get rebuilt
            goto Cleanup; 
		}
    }

    MtAdd(lIndex < ARRAY_SIZE(s_mpColMtr) ? s_mpColMtr[lIndex] : Mt(BldOtherCol), +1, 0);

    collectionWalker._lCollection = lIndex;

    // Set flag to indicate whether or not we need to go get the name/ID of
    // elements during the walk
    if ( lIndex == NAVDOCUMENT_COLLECTION ||
        lIndex == ANCHORS_COLLECTION ||
		lIndex == WINDOW_COLLECTION )
    {
        collectionWalker._fNeedNameID = TRUE;
    }
    // Set flag to indicate whether or not we need to go get the containing form of
    // elements during the walk
    if ( lIndex == WINDOW_COLLECTION || lIndex == NAVDOCUMENT_COLLECTION ||
        lIndex == FORMS_COLLECTION || lIndex == FRAMES_COLLECTION )
    {
        collectionWalker._fNeedForm = TRUE;
    }

    //
    // Here we blow away any cached information which is stored in the doc.
    // Usually elements, themselves, will blow away their own cached info
    // when they are first visited, but because the doc is not an element,
    // it will not be visited, and must blow away the cached info before we
    // start the walk.
    //


    // every fixed collection is based on the all collection
    if ( lIndex != ELEMENT_COLLECTION )
    {
        pCollectionCache->ResetAry( lIndex );
    }

    // Otherwise all collection is up to date, so use it because its faster
    lSize = pCollectionCache->SizeAry ( ELEMENT_COLLECTION );
    for ( l = 0 ; l < lSize ; l++ )
    {
       hr = THR(pCollectionCache->GetIntoAry(
                ELEMENT_COLLECTION,
                l,
                &pElemCurrent));
        if ( hr )
            goto Cleanup;
        hr = THR (AddToCollections ( pElemCurrent, &collectionWalker ));
        if ( hr )
            goto Cleanup;
    }

Update:
    // Update the version on the collection
    if ( lIndex == REGION_COLLECTION || lIndex == ELEMENT_COLLECTION)
    {
        // Collection derived from tree
        *plCollectionVersion = GetMarkupTreeVersion();
    }
	else
	{
		(*plCollectionVersion)++;
	}

	pCollectionCache->ValidateItem ( lIndex );

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  member : InFormCollection
//
//  Synopsis : helper function for determining if an element will appear in a
//     form element's collecion of if it should be scoped to the document's all
//     collection. this is also used by buildTypeInfo for hooking up VBSCRIPT
//
//----------------------------------------------------------------------------

CTreeNode *
CMarkup::InFormCollection(CTreeNode * pNode)
{
    CTreeNode * pNodeParentForm = NULL;

    if (!pNode)
        goto Cleanup;

    // NOTE: Forms are now promoted to the window, this is because the AddNamedItem
    //       no longer adds the form and we need to have access to the form for
    //       <SCRIPT FOR EVENT>
    switch (pNode->TagType())
    {
    case ETAG_INPUT:
    case ETAG_FIELDSET:
    case ETAG_SELECT:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_TEXTAREA:
    case ETAG_IMG:
    case ETAG_BUTTON:
    case ETAG_OBJECT:
    case ETAG_EMBED:
        // COMMENT rgardner - A good optimization here would be to have the tree walker
        // retain the last scoping form element & pass in the pointer
        pNodeParentForm = pNode->SearchBranchToRootForTag( ETAG_FORM );
        break;
    }

Cleanup:
    return pNodeParentForm;
}

//+------------------------------------------------------------------------
//
//  Member:     AddToCollections
//
//  Synopsis:   add this element to the collection cache
//
//  lNumNestedTables The number of TABLE tags we're nested underneath - speeds
//                  up IMG tag handling
//-------------------------------------------------------------------------

//
// DEVNOTE rgardner
// This code is tighly couples with CElement::OnEnterExitInvalidateCollections and needs
// to be kept in sync with any changes in that function
//

HRESULT
CMarkup::AddToCollections ( CElement *pElement, CCollectionBuildContext *pMonsterWalk )
{
    int         i;
    HRESULT     hr = S_OK;
    CTreeNode * pNodeForm = NULL;
    LPCTSTR pszName = NULL;
    LPCTSTR pszID = NULL;
    CCollectionCache *pCollectionCache;

#if DBG == 1
    TraceTag((
        tagCollectionsAddToCollections,
        "CMarkup::AddToCollections, tag: %ls, tag id: %ls, collection: %X",
        pElement->TagName(), STRVAL(pElement->GetAAid()),
        pMonsterWalk->_lCollection));
#endif


    // Note here that the outer code has mapped the FRAMES_COLLECTION onto the same Index as
    // the WINDOW_COLLECTION, so both collections get built
    if (!pElement)
        goto Cleanup;

    // Names & ID's are needed by :
    // NAVDOCUMENT_COLLECTION | ANCHORS_COLLECTION
    // This flag is initialized in EnsureCollections()

    // _fIsNamed is always up to date
    if ( pMonsterWalk->_fNeedNameID && pElement->IsNamed() )
    {
        pElement->FindString ( STDPROPID_XOBJ_NAME, &pszName );
        pElement->FindString ( DISPID_CElement_id, &pszID );
    }

    //
    // Retrieve the Collection Cache
    //
    pCollectionCache = CollectionCache();

    //
    // Next check to see if element belongs in the window collection
    // Only elements which don't lie inside of forms (and are not forms) belong in here.
    // Things which are not inserted into the form's element collection
    // are also put into the window collection.  E.g. anchors.
    //
    if ( pMonsterWalk->_fNeedForm )
    {
        pNodeForm = InFormCollection(pElement->GetFirstBranch());
    }

    if (pMonsterWalk->_lCollection == WINDOW_COLLECTION  && !pNodeForm && pElement->IsNamed())
    {
        LPCTSTR pszUniqueName = NULL;

        if ( !pszName && !pszID )
            pElement->FindString ( DISPID_CElement_uniqueName, &pszUniqueName );

        if ( pszName || pszID || pszUniqueName )
        {
            if (!pElement->IsOverflowFrame())
            {
                hr = THR(pCollectionCache->SetIntoAry(WINDOW_COLLECTION, pElement));
                if (hr)
                    goto Cleanup;
            }
        }
    }

    // See if its a FORM within a FORM, Nav doesn't promote names of nested forms to the doc
    if ( pMonsterWalk->_fNeedForm && ETAG_FORM == pElement->Tag()  )
    {
        pNodeForm = pElement->GetFirstBranch()->SearchBranchToRootForTag( ETAG_FORM );
        if ( SameScope(pNodeForm, pElement->GetFirstBranch()) )
            pNodeForm = NULL;
    }

    // We use the NAVDOCUMENT_COLLECTION to resolve names on the document object
    // If you have a name you get promoted ala Netscape
    // If you have an ID you get promoted, regardless
    // If you have both, you get netscapes rules
    switch (pElement->TagType())
    {
    case ETAG_FORM:
        if (pNodeForm) // only count images, forms not in a form
            break;
        // fallthrough


    case ETAG_IMG:
    case ETAG_EMBED:
    case ETAG_IFRAME:
    case ETAG_APPLET:
    case ETAG_OBJECT:
        if ( pMonsterWalk->_lCollection == NAVDOCUMENT_COLLECTION )
        {
            if ( pszName )
            {
                hr = THR(pCollectionCache->SetIntoAry(NAVDOCUMENT_COLLECTION, pElement));
                if (hr)
                    goto Cleanup;
            }
            // IE30 compatability OBJECTs/APPLETs with IDs are prmoted to the document
            else if ( ( pElement->Tag() == ETAG_APPLET ||
                pElement->Tag() == ETAG_OBJECT ) && pszID )
            {
                hr = THR(pCollectionCache->SetIntoAry(NAVDOCUMENT_COLLECTION, pElement));
                if (hr)
                    goto Cleanup;
            }
        }
        break;
    }

    //
    // See if this element is a region, which means its "container" attribute
    // is "moveable", "in-flow", or "positioned". If so then put it in the
    // region collection, which is used to ensure proper rendering. The BODY
    // should not be added to the region collection.
    //
    if (pMonsterWalk->_lCollection == REGION_COLLECTION &&
        pElement->Tag() != ETAG_BODY &&
        !pElement->IsPositionStatic())
    {
        hr = THR(pCollectionCache->SetIntoAry(REGION_COLLECTION, pElement));
        if (hr)
            goto Cleanup;
    }

    switch(pElement->TagType())
    {
    case ETAG_LABEL:
        i = LABEL_COLLECTION;
        break;

    case ETAG_FRAME:
    case ETAG_IFRAME:
        if (pElement->_fSynthesized)
            goto Cleanup;

        if ( pMonsterWalk->_lCollection == FRAMES_COLLECTION &&
             !pElement->IsOverflowFrame())
        {
            hr = THR(pCollectionCache->SetIntoAry(FRAMES_COLLECTION, pElement));
        }
        goto Cleanup;

    case ETAG_FORM:
        if ( pNodeForm )
        {
            // nested forms don't go into the forms collection
            goto Cleanup;
        }
        i = FORMS_COLLECTION;
        break;

    case ETAG_AREA:
        if ( pMonsterWalk->_lCollection == LINKS_COLLECTION )
        {
            LPCTSTR lpHRef = DYNCAST(CAreaElement, pElement)->GetAAhref();

            // If the AREA element has an href attribute even HREF="", add it to the
            // links' collection
            if( !lpHRef )
            {
                goto Cleanup;
            }
        }
        i = LINKS_COLLECTION;
        break;

    case ETAG_A:
        // If the A element has an non empty name/id attribute, add it to
        // the anchors' collection
        if ( pMonsterWalk->_lCollection == ANCHORS_COLLECTION )
        {
            LPCTSTR lpAnchorName = pszName;
            if (!lpAnchorName)
            {
                lpAnchorName = pszID;
            }
            if ( lpAnchorName && lpAnchorName[0] )
            {
                hr = THR(pCollectionCache->SetIntoAry(ANCHORS_COLLECTION, pElement));
                if ( hr )
                    goto Cleanup;
            }
        }

        if ( pMonsterWalk->_lCollection == LINKS_COLLECTION )
        {
            LPCTSTR lpHRef = DYNCAST(CAnchorElement, pElement)->GetAAhref();

            // If the A element has an href attribute even HREF="", add it to the
            // links' collection
            if( lpHRef )
            {
                hr = THR(pCollectionCache->SetIntoAry(LINKS_COLLECTION, pElement));
            }
        }
        goto Cleanup;

    case ETAG_IMG:
        // The document.images collection in Nav has a quirky bug, for every TABLE
        // above one Nav adds 2^n IMG elements.
        i = IMAGES_COLLECTION;
        break;

    case ETAG_EMBED:
        i = EMBEDS_COLLECTION;
        break;

    case ETAG_OBJECT:
    case ETAG_APPLET:
        i = APPLETS_COLLECTION;
        break;

    case ETAG_SCRIPT:
        i = SCRIPTS_COLLECTION;
        break;

    case ETAG_MAP:
        i = MAPS_COLLECTION;
        break;

    default:
        goto Cleanup;
    }

    if ( i == pMonsterWalk->_lCollection )
    {
        hr = THR(pCollectionCache->SetIntoAry(i, pElement));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     GetCollection
//
//  Synopsis:   return collection based on index in the collection cache
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetCollection(int iIndex, IHTMLElementCollection ** ppdisp)
{
    Assert((iIndex >= 0) && (iIndex < NUM_DOCUMENT_COLLECTIONS));

    HRESULT hr;

    if (!ppdisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppdisp = NULL;

    hr = EnsureCollectionCache(iIndex);
    if ( hr )
        goto Cleanup;

    hr = THR(CollectionCache()->GetDisp(iIndex, (IDispatch **)ppdisp));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     GetElementByNameOrID
//
//  Synopsis:   look up an Element by its Name or ID
//
//  Returns:    S_OK, if it found the element.  *ppElement is set
//              S_FALSE, if multiple elements w/ name were found.
//                  *ppElement is set to the first element in list.
//              Other errors.
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetElementByNameOrID(LPCTSTR szName, CElement **ppElement)
{
    HRESULT hr;
    CElement * pElemTemp;

    hr = THR(EnsureCollectionCache(ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(CollectionCache()->GetIntoAry(
        ELEMENT_COLLECTION,
        szName,
        FALSE,
        &pElemTemp));
    *ppElement = pElemTemp;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     GetDispByNameOrID
//
//  Synopsis:   Retrieve an IDispatch by its Name or ID
//
//  Returns:    An IDispatch* to an element or a collection of elements.
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetDispByNameOrID(LPTSTR szName, IDispatch **ppDisp, BOOL fAlwaysCollection)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache(ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(CollectionCache()->GetDisp(
        ELEMENT_COLLECTION,
        szName,
        CacheType_Named,
        ppDisp,
        FALSE,  // Case Insensitive
        NULL,
        fAlwaysCollection)); // Always return a collection (even if empty, or has 1 elem)

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::OnElementExit
//
//  Synopsis:   Remove all references the doc may have to an element
//              that is exiting the tree
//
//-------------------------------------------------------------------------

HRESULT
CDoc::OnElementExit(CElement *pElement, DWORD dwExitFlags )
{  
    CAryFocusItem   * paryFocusItem;      
    CElement        * pMasterFocusElem = _pElemCurrent;
    long              i;

    if (_fVID && !_fOnControlInfoChangedPosted)
    {
        _fOnControlInfoChangedPosted = TRUE;
        IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CDoc, OnControlInfoChanged, oncontrolinfochanged), 0, FALSE, "CDoc::OnControlInfoChanged"));
    }

    if (_pMenuObject == pElement)
    {
        _pMenuObject = NULL;
    }

    //
    // marka - find the Element that will be current next - via adjusting the edit context
    // fire on Before Active Elemnet Change. If it's ok - do a SetEditContext on that elemnet,
    // and set _pElemCurrent to it. 
    //
    // Otherwise if FireOnBeforeActiveElement fails - 
    // we make the Body the current element, and call SetEditCOntext on that.
    //

    // mihaii - If pElement is the master for a slave markup that contains _pElemCurrent 
    // we also need to adjust the currency - pMasterFocusNode is the master parent for _pElemCurrent

    if (_pElemCurrent)
    {
        CMarkup   * pMarkup          =  pElement->GetMarkup();
        CTreeNode * pMasterFocusNode = _pElemCurrent->GetFirstBranch();  

        pMasterFocusNode = pMasterFocusNode->GetNodeInMarkup(pMarkup);
        if (pMasterFocusNode)    
            pMasterFocusElem = pMasterFocusNode->Element();
    }

    if (pElement == pMasterFocusElem)
    {
        if( dwExitFlags & EXITTREE_DESTROY )
        {
            // TODO: (jbeda) is this right?  What else do we have to do on markup destroy?
            _pElemCurrent = _pElementDefault;

            if (_pWindowPrimary)
                _pElemCurrent = PrimaryRoot();
        }
        else
        {        
            CTreeNode * pNodeSiteParent = pElement->GetFirstBranch()->GetUpdatedParentLayoutNode();
            if ( pNodeSiteParent )
            {
                _pElemCurrent = pNodeSiteParent->Element();
            }
            else
            {
                _pElemCurrent = pElement->GetMarkup()->Root();
                   
                // if it's the top element, don't defer to itself
            
                if (_pElemCurrent == pElement)
                {
                    if (_pWindowPrimary)
                        _pElemCurrent = PrimaryRoot();
                    else                    
                        _pElemCurrent = _pElementDefault;
                }
            }            

            if ( _pElemCurrent->IsEditable( FALSE ) && _pElemCurrent->_etag != ETAG_ROOT )
            {
                //
                // An editable element has just become current.
                // We tell the mshtmled.dll about this change in editing "context"
                //

                if (_pCaret)
                {
                    _pCaret->Show( FALSE );
                }
            }
            
            GWKillMethodCall(pElement->GetMarkup()->Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);
        }
    }
    else
    {
        Assert(pElement != _pElemCurrent);
    }

    // Make sure pElement site pointer is not cached by the document, which
    // can happen if we are in the middle of a drag-drop operation
    if (_pDragDropTargetInfo)
    {
        if (pElement == _pDragDropTargetInfo->_pElementTarget)
        {
            _pDragDropTargetInfo->_pElementTarget = NULL;
            _pDragDropTargetInfo->_pElementHit = NULL;
            _pDragDropTargetInfo->_pDispScroller = NULL;
        }
    }

    // Release capture if it owns it
    pElement->TakeCapture(FALSE);

    if (_pNodeLastMouseOver)
    {
        ClearCachedNodeOnElementExit(&_pNodeLastMouseOver, pElement);
    }
    if (_pNodeGotButtonDown)
    {
        ClearCachedNodeOnElementExit(&_pNodeGotButtonDown, pElement);
    }

    // Reset _pElemUIActive if necessary
    if (_pElemUIActive == pElement)
    {
        // TODO (MohanB) Need to call _pElemUIActive->YieldUI() here ?

        _pElemUIActive = NULL;
        if (_pInPlace && !_pInPlace->_fDeactivating && _pElemUIActive != pElement->GetMarkup()->Root())
        {
            IGNORE_HR(pElement->GetMarkup()->Root()->BecomeUIActive());
        }
    }

    //
    // Remove all traces of pElement from the focus item array
    // and accessKey array.    
    //
    
    // NOTE: this could be N^2 on shutdown
    paryFocusItem = pElement->GetMarkup()->GetFocusItems(FALSE);
    if (paryFocusItem) 
    {
        for (i = 0; i < paryFocusItem->Size(); )
        {
            if ((*paryFocusItem)[i].pElement == pElement)
            {
                paryFocusItem->Delete(i);
            }
            else
            {
                i++;
            }
        }
    }
    
    return S_OK;
}

BOOL IsAncestorMaster(CElement * pElem1, CTreeNode * pNode2);

void
CDoc::ClearCachedNodeOnElementExit(CTreeNode ** ppNodeToTest, CElement * pElement)
{
    Assert(pElement && ppNodeToTest && *ppNodeToTest);

    CTreeNode * pNode = *ppNodeToTest;

    if (SameScope(pNode, pElement) || IsAncestorMaster(pElement, pNode))
    {
        *ppNodeToTest = NULL;
        pNode->NodeRelease();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CMarkup::InsertFocusArrayItem
//
//  Synopsis:   Insert CElement with tabindex defined into the focusItems array
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::InsertFocusArrayItem(CElement * pElement)
{
    HRESULT             hr = S_OK;
    long                lTabIndex  = pElement->GetAAtabIndex();
    long                c;
    long *              pTabs = NULL;
    long *              pTabsSet;
    FOCUS_ITEM          focusitem;
    long                i;
    long                j;
    CAryFocusItem     * paryFocusItem = GetFocusItems(TRUE);
    
    Assert (paryFocusItem);

    //
    // The tabIndex attribute can have three values:
    //
    //      < 0     Does not participate in focus
    //     == 0     Tabindex as per source order
    //      > 0     Tabindex is the set tabindex
    //
    // Precedence is that given tab indices go first, then the elements
    // which don't have one assigned.  If not given a tab index, treat the
    // element same as tabIndex < 0 for those elements which don't have a
    // layout associated with them (e.g. <P>, <SPAN>).  Those that do
    // have a layout (e.g. <INPUT>, <BUTTON>) will be treated as tabindex == 0
    //

    //
    // Figure out if this element has subdivisions.  If so, then we need
    // multiple entries for this guy.
    //

    //
    // Areas and maps don't belong in here.
    //

    if (pElement->Tag() == ETAG_AREA || pElement->Tag() == ETAG_MAP)
        goto Cleanup;

    hr = THR(pElement->GetSubDivisionCount(&c));
    if (hr)
        goto Cleanup;

    // Subdivisions can have their own tabIndices. Therefore, if an element
    // has any subdivisions, the element's own tabIndex is ignored.
    if ( !c && lTabIndex <= 0 )
        goto Cleanup;

    //
    // Find the location in the focus item array to insert this element.
    //

    focusitem.pElement = pElement;
    if (c)
    {
        pTabs = new long[c];
        if (!pTabs)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pElement->GetSubDivisionTabs(pTabs, c));
        if (hr)
            goto Cleanup;

        pTabsSet = pTabs;
    }
    else
    {
        Assert(lTabIndex > 0);
        pTabsSet = &lTabIndex;
        c = 1;
    }

    hr = THR(paryFocusItem->EnsureSize(paryFocusItem->Size() + c));
    if (hr)
        goto Cleanup;

    for (i = 0; i < c; i++)
    {
        //
        // This is here because subdivisions can also be set to have
        // either a negative tabindex or zero, which means they're in source
        // order.
        //

        if (pTabsSet[i] <= 0)
            continue;

        focusitem.lSubDivision = i;
        focusitem.lTabIndex = pTabsSet[i];

        //
        // Find correct location in focusItems array to insert.
        //

        for (j = 0; j < paryFocusItem->Size(); j++)
        {
            if ((*paryFocusItem)[j].lTabIndex > focusitem.lTabIndex ||
                (*paryFocusItem)[j].pElement->GetSourceIndex() >
                    focusitem.pElement->GetSourceIndex())
                break;
        }

        Verify(!paryFocusItem->InsertIndirect(j, &focusitem));
    }

Cleanup:
    delete [] pTabs;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SearchFocusArray
//
//  Synopsis:   Search the focus array for the next focussable item
//
//  Returns:    FALSE if pElemFirst was not found in the focus arrya
//              TRUE and ppElemNext/plSubNext set to NULL if pElemFirst
//                  was found, but the next item was not present.
//              TRUE and ppElemNext/plSubNext set to valid values if
//                  pElemFirst was found and the next item is also present.
//
//-------------------------------------------------------------------------

BOOL
CMarkup::SearchFocusArray(
    FOCUS_DIRECTION dir,
    CElement *pElemFirst,
    long lSubFirst,
    CElement **ppElemNext,
    long *plSubNext)
{
    int               i;
    BOOL              fFound = FALSE;
    CAryFocusItem   * paryFocusItem = GetFocusItems(TRUE);

    Assert (paryFocusItem);    
    *ppElemNext = NULL;
    *plSubNext = 0;

    if (!pElemFirst)
    {
        if (DIRECTION_FORWARD == dir && paryFocusItem->Size() > 0)
        {
            i = 0;
        }
        else if (DIRECTION_BACKWARD == dir && paryFocusItem->Size() > 0)
        {
            i = paryFocusItem->Size() - 1;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        //
        // Search for pElemFirst and lSubFirst in the array.
        //

        for (i = 0; i < paryFocusItem->Size(); i++)
        {
            if (pElemFirst == (*paryFocusItem)[i].pElement &&
                lSubFirst == (*paryFocusItem)[i].lSubDivision)
            {
                fFound = TRUE;
                break;
            }
        }

        //
        // If pElemFirst is not in the array, just return FALSE.  This
        // will cause SearchFocusTree to get called.
        //

        if (!fFound)
            return FALSE;

        //
        // If pElemFirst is the first/last element in the array
        // return TRUE.  Otherwise return the next tabbable element.
        //

        if (DIRECTION_FORWARD == dir)
        {
            if (i == paryFocusItem->Size() - 1)
                return TRUE;

            i++;    // Make i point to the item to return
        }
        else
        {
            if (i == 0)
                return TRUE;

            i--;
        }
    }

    *ppElemNext = (*paryFocusItem)[i].pElement;
    *plSubNext = (*paryFocusItem)[i].lSubDivision;
    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SearchFocusTree
//
//  Synopsis:   Update the focus collection upon an element exiting the tree
//
//  Returns:    See SearchFocusArray
//
//-------------------------------------------------------------------------

BOOL
CMarkup::SearchFocusTree(
    FOCUS_DIRECTION dir,
    BOOL            fAccessKey,
    CMessage *      pmsg,
    CElement *pElemFirst,
    long lSubFirst,
    CElement **ppElemNext,
    long *plSubNext)
{
    //
    // Use the all collection for now.  TODO: (anandra) Fix ASAP.
    //

    HRESULT             hr = S_OK;
    long                i;
    long                cElems;
    CElement *          pElement;
    BOOL                fStopOnNextTab = FALSE;
    long                lSubNext;
    int                 iStep;
    BOOL                fFound = FALSE;
    CCollectionCache *  pCollectionCache;
    WCHAR               chKey;
    BOOL                fKeyConverted = FALSE;
    
    *ppElemNext = NULL;
    *plSubNext = 0;       

    hr = THR(EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = CollectionCache();

    cElems = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);
    if (!cElems)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Search for pElemFirst
    //

    iStep = (DIRECTION_FORWARD == dir) ? 1 : -1;

    for (i = (DIRECTION_FORWARD == dir) ? 0 : cElems - 1;
         (DIRECTION_FORWARD == dir) ? (i < cElems) : (i >= 0);
         i += iStep)
    {
        hr = THR(pCollectionCache->GetIntoAry(
                CMarkup::ELEMENT_COLLECTION,
                i,
                &pElement));
        if (hr)
            goto Cleanup;

        Assert(pElement);

        //
        // If HasTabIndex() is true, this element has already
        // been looked at in SearchFocusArray.
        //

        if (!fAccessKey && pElement->HasTabIndex())
            continue;

        if (pElemFirst)
        {
            if (pElemFirst == pElement)
            {
                //
                // Found the element.  Now check if there are any further
                // subdivisions.  If so, then we need to return the next
                // subdivision.  If we're on the last subdivision already
                // or if there are no subdivisions, then we need to return
                // the next tabbable object.
                //

                fFound = TRUE;
                lSubNext = lSubFirst;

                for(;;)
                {
                    hr = THR(pElement->GetNextSubdivision(dir, lSubNext, &lSubNext));
                    if (hr)
                        goto Cleanup;

                    if (lSubNext == -1)
                        break;

                    if (!fAccessKey)
                    {
                        if (pElement->IsTabbable(lSubNext))
                        {
                            *ppElemNext = pElement;
                            *plSubNext = lSubNext;
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        if (! fKeyConverted )
                        {
                            fKeyConverted = TRUE;
                            ConvertMessageToUnicode( pmsg, & chKey );                            
                        }

                        if (pElement->MatchAccessKey(pmsg, lSubNext, & chKey ))
                        {
                            FOCUS_ITEM fi = pElement->GetMnemonicTarget(lSubNext);

                            if (fi.pElement && fi.pElement->IsFocussable(fi.lSubDivision)) 
                            {
                                *ppElemNext = pElement;
                                *plSubNext = lSubNext;
                                goto Cleanup;
                            }
                        }

                        // Drill in if there is slave
                        if (pElement->HasSlavePtr() && pElement->Tag() != ETAG_INPUT)
                        {
                            *ppElemNext = pElement;
                            *plSubNext = -2; // THis will cause the caller to drill in
                            goto Cleanup;
                        }
                    }
                }

                fStopOnNextTab = TRUE;
                continue;
            }
        }
        else
        {
            fStopOnNextTab = TRUE;
        }

        if (fStopOnNextTab)
        {
            hr = THR(pElement->GetNextSubdivision(dir, -1, &lSubNext));
            if (hr)
                goto Cleanup;
            while (lSubNext != -1)
            {
                if (!fAccessKey)
                {
                    if (pElement->IsTabbable(lSubNext))
                    {
                        fFound = TRUE;
                        *ppElemNext = pElement;
                        *plSubNext = lSubNext;
                        goto Cleanup;
                    }
                }
                else
                {
                    if (! fKeyConverted )
                    {
                        fKeyConverted = TRUE;
                        ConvertMessageToUnicode( pmsg, & chKey );                            
                    }

                    if (pElement->MatchAccessKey(pmsg, lSubNext, & chKey ))
                    {
                        FOCUS_ITEM fi = pElement->GetMnemonicTarget(lSubNext);

                        if (fi.pElement && fi.pElement->IsFocussable(fi.lSubDivision)) 
                        {
                            fFound = TRUE;
                            *ppElemNext = pElement;
                            *plSubNext = lSubNext;
                            goto Cleanup;
                        }
                    }
                    // Drill in if there is slave
                    if (    pElement->HasSlavePtr()
                        &&  pElement->Tag() != ETAG_INPUT
                        &&  !pElement->GetSlavePtr()->GetMarkup()->IsPrintMedia())
                    {
                        fFound = TRUE;
                        *ppElemNext = pElement;
                        *plSubNext = -2; // THis will cause the caller to drill in
                        goto Cleanup;
                    }
                }
                hr = THR(pElement->GetNextSubdivision(dir, lSubNext, &lSubNext));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
#if DBG == 1
    if (*ppElemNext)
    {
        Assert(fFound);
    }

    if (hr)
    {
        Assert(!fFound && !*ppElemNext);
    }
#endif
    return fFound;
}

HRESULT CMarkup::InitCollections ( void )
{
    HRESULT hr = S_OK;
    CAllCollectionCacheItem *pAllCollection = NULL;
    CCollectionCache *pCollectionCache;

    // InitCollections should not be called more than once successfully.
    if (HasCollectionCache())
        goto Cleanup;

    pCollectionCache =
        new CCollectionCache(
            this,
            GetWindowedMarkupContext(),
            ENSURE_METHOD(CMarkup, EnsureCollections, ensurecollections ) );

    if (!pCollectionCache)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Initialize from the FORM_COLLECTION onwards,. leaving out the ELEMENT_COLLECTION
    hr = THR(pCollectionCache->InitReservedCacheItems( NUM_DOCUMENT_COLLECTIONS, FORMS_COLLECTION ));
    if (hr)
        goto Cleanup;

    pAllCollection = new CAllCollectionCacheItem();
    if ( !pAllCollection )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pAllCollection->SetMarkup(this);

    pAllCollection->Init();

    hr = THR(pCollectionCache->InitCacheItem ( ELEMENT_COLLECTION, pAllCollection ));
    if (hr)
        goto Cleanup;

    //
    // Collection cache now owns this item & is responsible for freeing it
    //

    // Turn off the default name promotion behaviour on collections
    // that don't support it in Nav.
    pCollectionCache->DontPromoteNames(ANCHORS_COLLECTION);
    pCollectionCache->DontPromoteNames(LINKS_COLLECTION);

    // The frames collection resolves ordinal access on the window object
    // so turn off the WINDOW_COLLECTIOn resultion of ordinals
    pCollectionCache->DontPromoteOrdinals(WINDOW_COLLECTION);


    // Because of VBScript compatability issues we create a dynamic type library
    // (See CDoc::BuildObjectTypeInfo()). The dynamic typeinfo contains
    // DISPIDs starting from DISPID_COLLECTION_MIN, & occupying half the DISPID space.


    // We either get Invokes from these DISPIDs or from the WINDOW_COLLECTION GIN/GINEX name resolution
    // OR from the FRAMES_COLLECTION. So we divide the avaliable DISPID range up among these
    // Three 'collections' - 2 real collections & one hand-cooked collection.

    // Divide up the WINDOW_COLLECTION DISPID's so we can tell where the Invoke came from

    // Give the lowest third to the dynamic type library
    // DISPID_COLLECTION_MIN .. (DISPID_COLLECTION_MIN+DISPID_COLLECTION_MAX)/3

    // Give the next third to names resolved on the WINDOW_COLLECTION
    pCollectionCache->SetDISPIDRange ( WINDOW_COLLECTION,
            (DISPID_COLLECTION_MIN+DISPID_COLLECTION_MAX)/3+1,
            ((DISPID_COLLECTION_MIN+DISPID_COLLECTION_MAX)*2)/3 );

    // In COmWindowProxy::Invoke the security code allows DISPIDs from the frames collection
    // through with no security check. Check that the DISPIDs reserved for this range match up
    Assert ( FRAME_COLLECTION_MIN_DISPID == pCollectionCache->GetMaxDISPID(WINDOW_COLLECTION)+1 );
    Assert ( FRAME_COLLECTION_MAX_DISPID == DISPID_COLLECTION_MAX );

    // Give the final third to the FRAMES_COLLECTION
    pCollectionCache->SetDISPIDRange ( FRAMES_COLLECTION,
            pCollectionCache->GetMaxDISPID(WINDOW_COLLECTION)+1,
            DISPID_COLLECTION_MAX );

    // Like NAV, we want to return the last frame that matches the name asked for,
    // rather than returning a collection.
    pCollectionCache->AlwaysGetLastMatchingCollectionItem ( FRAMES_COLLECTION );

    // Like NAV, the images doesn't return sub-collections. Note that we might put multiple
    // entries in the IMG collection for the same IMG if the IMG is nested in a table - so
    // this also prevents us from retunring a sub-collection in this situation.
    pCollectionCache->AlwaysGetLastMatchingCollectionItem ( IMAGES_COLLECTION );

    // Setup the lookaside variable
    hr = THR(SetLookasidePtr(LOOKASIDE_COLLECTIONCACHE, pCollectionCache));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


void CAllCollectionCacheItem::Init()
{
    CMarkup *pMarkup = GetMarkup();

    Assert(pMarkup);

    _pTreePos = pMarkup->FirstTreePos();

    Assert(     _pTreePos 
            &&  _pTreePos->IsNode() 
            &&  _pTreePos->Branch()->Tag() == ETAG_ROOT);

    // Skip past the root
    _pTreePos = _pTreePos->NextTreePos();

    // Find the first begin edge
    while(      _pTreePos != NULL
            &&  !_pTreePos->IsBeginElementScope())
    {
        _pTreePos = _pTreePos->NextTreePos();
    }
}

CElement *CAllCollectionCacheItem::GetNext ( void )
{
    CElement *pElement = NULL;

    if(_pTreePos && GetMarkup())
    {
        Assert( _pTreePos->IsBeginElementScope() );
        pElement = _pTreePos->Branch()->Element();

        // Skip over any nonelement nodes
        do
        {
            _pTreePos = _pTreePos->NextTreePos();
        } while(_pTreePos && !_pTreePos->IsBeginElementScope());
    }

    return pElement;
}

CElement *CAllCollectionCacheItem::MoveTo ( long lIndex )
{
    if (!GetMarkup())
        return NULL;

    if(lIndex == 0)
        Init();
    else
        return GetAt(lIndex, &_pTreePos);

    return NULL;
}

CElement *CAllCollectionCacheItem::GetAt ( long lIndex, CTreePos **ppTreePos )
{
    CMarkup * pMarkup = GetMarkup();
    CTreePos *ptpBegin;

    if (!pMarkup)
        return NULL;

    Assert ( lIndex >= 0 );

    // Skip ETAG_ROOT which is always the zero'th element
    lIndex++;

    if ( lIndex >= pMarkup->NumElems() )
        return NULL;

    ptpBegin = pMarkup->TreePosAtSourceIndex ( lIndex );

    Assert (ptpBegin && ptpBegin->IsBeginElementScope() );

    // Update the GetNext Walker
    if(ppTreePos)
        *ppTreePos = ptpBegin;

    return ptpBegin->Branch()->Element();
}

long CAllCollectionCacheItem::Length ( void )
{
    CMarkup *pMarkup = GetMarkup();

    if ( pMarkup && pMarkup->NumElems() >= 1 )
        return pMarkup->NumElems()-1;
    else
        return 0;
}

extern CDummySecurityDispatchEx g_DummySecurityDispatchEx;

CMarkup *CAllCollectionCacheItem::GetMarkup(void)
{
    if (!_pMarkup && _pDispDocument)
    {
        CDocument *pDocument = NULL;

        if (((TEAROFF_THUNK *)_pDispDocument)->pvObject1 != (IDispatchEx*)&g_DummySecurityDispatchEx)
        {
            pDocument = (CDocument *)(((TEAROFF_THUNK *)_pDispDocument)->pvObject1);
            Assert(pDocument->Markup());
            return pDocument->Markup();
        }

        ClearInterface(&_pDispDocument);
    }

    return _pMarkup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\formkrnl.cxx ===
//+------------------------------------------------------------------------
//
//  File:       FORMKRNL.CXX
//
//  Contents:   Root object of the standard forms kernel
//
//  Classes:    (part of) CDoc
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_SITECNST_HXX_
#define X_SITECNST_HXX_
#include "sitecnst.hxx"
#endif

#ifndef X_TIMER_HXX_
#define X_TIMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_RENDSTYL_HXX_
#define X_RENDSTYL_HXX_
#include "rendstyl.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_IDISPIDS_H_
#define X_IDISPIDS_H_
#include "idispids.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DWNNOT_H_
#define X_DWNNOT_H_
#include <dwnnot.h>
#endif

#ifndef X_SAFEOCX_H_
#define X_SAFEOCX_H_
#include <safeocx.h>
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include <htiface.h>
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include <perhist.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_MSHTMCID_H_
#define X_MSHTMCID_H_
#include <mshtmcid.h>
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include <urlhist.h>
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include <hlink.h>
#endif

#ifndef X_MARQINFO_H_
#define X_MARQINFO_H_
#include <marqinfo.h>
#endif

#ifndef X_HTMVER_HXX_
#define X_HTMVER_HXX_
#include "htmver.hxx"
#endif

#ifndef X_VERVEC_H_
#define X_VERVEC_H_
#include "vervec.h"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_EXTDL_HXX_
#define X_EXTDL_HXX_
#include "extdl.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X_LSCACHE_HXX_
#define X_LSCACHE_HXX_
#include "lscache.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_TPOINTER_H_
#define X_TPOINTER_H_
#include "tpointer.hxx"
#endif

#ifndef X_DXTRANSP_H_
#define X_DXTRANSP_H_
#include "dxtransp.h"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef _X_DISPSERV_H_
#define _X_DISPSERV_H_
#include "dispserv.hxx"
#endif

#ifndef _X_GENERIC_H_
#define _X_GENERIC_H_
#include "generic.hxx"
#endif

#ifndef _X_WEBOCUTIL_H_
#define _X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_TEMPFILE_HXX_
#define X_TEMPFILE_HXX_
#include "tempfile.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

extern BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

#ifdef V4FRAMEWORK

#include "complus.h"

#define _hxx_
#include "complus.hdl"

#undef _hxx_
#define _cxx_
#include "complus.hdl"


EXTERN_C const GUID CLSID_ExternalFrameworkSite;

const CBase::CLASSDESC CExternalFrameworkSite::s_classdesc =
{
    &CLSID_ExternalFrameworkSite,    // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IExternalDocumentSite,    // _piidDispinterface
    &s_apHdlDescs,                           // _apHdlDesc
};

#endif V4FRAMEWORK

#ifndef NO_SCRIPT_DEBUGGER
extern void    DeinitScriptDebugging();
#endif // NO_SCRIPT_DEBUGGER

#ifndef NODD
extern void         ClearSurfaceCache();        // out of offscreen.cxx to clear allocated DD surfaces
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

extern "C" const IID IID_IObjectSafety;
extern "C" const IID IID_IThumbnailView;
extern "C" const IID IID_IRenMailEditor;
extern "C" const IID IID_IRenVersionCheck;
extern "C" const IID IID_IHTMLEditorViewManager;
extern "C" const IID SID_SHTMLEditorViewManager;
extern "C" const CLSID  CLSID_HTMLEditor;
extern "C" const CLSID CLSID_HTMLPluginDocument;
extern "C" const IID IID_IHTMLDialog;
extern "C" const IID IID_IHTMLViewServices;
#define SID_SElementBehaviorFactory IID_IElementBehaviorFactory
extern "C" const CLSID CLSID_HTMLPluginDocument;
extern "C" const CLSID CLSID_HTMLDialog;
extern "C" const IID IID_IHTMLDialog;
#define SID_SElementBehaviorFactory IID_IElementBehaviorFactory
extern "C" const GUID SID_SSelectionManager;
extern "C" const IID SID_DefView;
extern "C" const IID SID_SHTMEDDesignerHost;
extern "C" const IID SID_SMarsPanel;

#define ABOUT_HOME  _T("about:home")

extern "C" const IID IID_IXMLGenericParse;

DeclareTag(tagCDoc, "Form", "Form base class methods")
DeclareTag(tagUpdateUI, "Form", "Form UpdateUI calls")
DeclareTag(tagUrlImgCtx, "UrlImgCtx", "Trace UrlImgCtx methods")
DeclareTag(tagAssertParentDocChangeToDebugIsPrintDocCache, "Print", "Assert parent doc change")
DeclareTag(tagCompatMsMoney, "Compat", "Microsoft Money")
DeclareTag(tagEdSelMan, "Edit", "Handle Selection Message - Routing")
DeclareTag(tagDocHitTest, "Doc", "Hit testing")
DeclareTag(tagFilter, "Filter", "Trace filter behaviour")
ExternTag(tagDisableLockAR);
ExternTag(tagPrivacySwitchList);
ExternTag(tagPrivacyAddToList);


PerfTag(tagGasGauge, "GasGauge", "MSHTML Info")
PerfDbgExtern(tagPerfWatch)

MtDefine(CDefaultElement, Elements, "CDefaultElement")
MtDefine(OptionSettings, CDoc, "CDoc::_pOptionSettings")
MtDefine(OSCodePageAry_pv, OptionSettings, "CDoc::_pOptionSettings::aryCodePageSettings::_pv")
MtDefine(OSContextMenuAry_pv, OptionSettings, "CDoc::_pOptionSettings::aryContextMenuExts::_pv")
MtDefine(CPendingEvents, CDoc, "CDoc::_pPendingEvents")
MtDefine(CPendingEvents_aryPendingEvents_pv, CPendingEvents, "CDoc::_pPendingEvents::_aryPendingEvents::_pv")
MtDefine(CPendingEvents_aryEventType_pv, CPendingEvents, "CDoc::_pPendingEvents::_aryEventType::_pv")
MtDefine(CDoc, Mem, "CDoc")
MtDefine(CDoc_arySitesUnDetached_pv, CDoc, "CDoc::_arySitesUnDetached::_pv")
MtDefine(CDoc_aryElementDeferredScripts_pv, CDoc, "CDoc::_aryElementDeferredScripts::_pv")
MtDefine(CMarkup_aryElementReleaseNotify, CMarkup, "CMarkup::_aryElementReleaseNotify::_pv")
MtDefine(CMarkup_aryElementReleaseNotify_pv, CMarkup_aryElementReleaseNotify, "CMarkup::_aryElementReleaseNotify::_pv")
MtDefine(CDoc_aryDefunctObjects_pv, CDoc, "CDoc::_aryDefunctObjects::_pv")
MtDefine(CDoc_aryChildDownloads_pv, CDoc, "CDoc::_aryChildDownloads::_pv")
MtDefine(CDoc_aryUndoData_pv, CDoc, "CDoc::_aryUndoData::_pv")
MtDefine(CDoc_aryUrlImgCtx_aryElems_pv, CDoc, "CDoc::_aryUrlImgCtx_aryElems::_pv")
MtDefine(CDoc_aryUrlImgCtx_pv, CDoc, "CDoc::_aryUrlImgCtx::_pv")
MtDefine(CDocEnumObjects_paryUnk, Locals, "CDoc::EnumObjects paryUnk")
MtDefine(CDocEnumObjects_paryUnk_pv, CDocEnumObjects_paryUnk, "CDoc::EnumObjects paryUnk::_pv")
MtDefine(CDragDropSrcInfo, ObjectModel, "CDragDropSrcInfo")
MtDefine(CDragDropTargetInfo, ObjectModel, "CDragDropTargetInfo")
MtDefine(CDocUpdateIntSink, CDoc, "CDoc::_pUpdateIntSink")
MtDefine(CDragStartInfo, ObjectModel, "CDragStartInfo")
MtDefine(LoadMSHTMLEd, PerfPigs, "Loading MSHTMLEd")
MtDefine(CDoc_aryDelayReleaseItems_pv, CDoc, "CDoc::_aryDelayReleaseItems::_pv")
MtDefine(CDoc_CLock, CDoc, "CDoc::CLock")
MtDefine(CDoc_aryMarkupNotifyInPlace, CDoc, "CDoc::_aryMarkupNotifyInPlace")
MtDefine(CDoc_aryMarkupNotifyEnableModeless_pv, CDoc, "CDoc::_aryMarkupNotifyEnableModeless::_pv")

MtDefine(CDoc_aryPendingExpressionElements_pv, CDoc, "CDoc::_aryPendingExpressionElements::_pv")
MtDefine(CDoc_aryStackCapture_pv, CDoc, "CDoc::_aryStackCapture::_pv")
MtDefine(CDoc_aryAccEvtRefs_pv, CDoc, "CDoc::_aryAccEvents::_pv")
MtDefine(Filters, CDoc, "Filters")

MtExtern(CPrivacyList)

//
//  Globals
//

// When we have more time I need to change pdlparser to generate externs
EXTERN_C const PROPERTYDESC_METHOD s_methdescCBasesetMember;
EXTERN_C const PROPERTYDESC_METHOD s_methdescCBasegetMember;
EXTERN_C const PROPERTYDESC_METHOD s_methdescCBaseremoveMember;

extern HRESULT  InitFormatCache(THREADSTATE *);

BOOL        g_IEHardened   = FALSE;
BOOL        g_fInIexplorer = FALSE;
BOOL        g_fInExplorer  = FALSE;
BOOL        g_fInKnownBrowserApp = FALSE;
BOOL        g_fDisableUnTrustedProtocol = FALSE;
BOOL        g_fDocClassInitialized = FALSE;
BOOL        g_fHiResAware;
BOOL        g_fInMoney98;
BOOL        g_fInMoney99;
BOOL        g_fInHomePublisher98;
BOOL        g_fInWin98Discover;
BOOL        g_fInVizAct2000;
BOOL        g_fInMSWorksCalender;
BOOL        g_fInPhotoSuiteIII;
BOOL        g_fInAccess9;
BOOL        g_fInAccess;
BOOL        g_fInExcelXP;
BOOL        g_fInHtmlHelp = FALSE;
BOOL        g_fPrintToGenericTextOnly;
BOOL        g_fInPip;
BOOL        g_fInIBMSoftwareSelection = FALSE;
BOOL        g_fInMoney2001 = FALSE;
BOOL        g_fInInstallShield = FALSE;
BOOL        g_fInAutoCad = FALSE;
BOOL        g_fInLotusNotes = FALSE;
BOOL        g_fInMshtmpad = FALSE;
BOOL        g_fInVisualStudio = FALSE;
int         g_iDragScrollDelay;
SIZE        g_sizeDragScrollInset;
int         g_iDragDelay;
int         g_iDragScrollInterval;
static char s_achWindows[] = "windows"; //  Localization: Do not localize
CGlobalCriticalSection g_csJitting;
BYTE g_bUSPJitState = JIT_OK;    //  For UniScribe JIT (USP10.DLL)
BYTE g_bJGJitState = JIT_OK;     //  JG ART library for AOL (JG*.DLL)
BOOL        g_fNoFileMenu = FALSE;      //  IEAK Restrictions
TCHAR       *g_tszModuleFileName = NULL;

const OLEMENUGROUPWIDTHS CDoc::s_amgw[] =
{
    { 0, 1, 0, 3, 0, 0 },   //  Design mode info
    { 0, 1, 0, 1, 0, 0 },   //  Run mode info
};


BEGIN_TEAROFF_TABLE(CDoc, IMarqueeInfo)
    TEAROFF_METHOD(CDoc, GetDocCoords, getdoccoords, (LPRECT pViewRect, BOOL bGetOnlyIfFullyLoaded, BOOL *pfFullyLoaded, int WidthToFormatPageTo))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IServiceProvider)
    TEAROFF_METHOD(CDoc, QueryService, queryservice, (REFGUID rsid, REFIID iid, void ** ppvObj))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPersistFile)
    // IPersist methods
    TEAROFF_METHOD(CDoc, GetClassID, getclassid, (CLSID *))
    // IPersistFile methods
    TEAROFF_METHOD(CDoc, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDoc, Load, load, (LPCOLESTR pszFileName, DWORD dwMode))
    TEAROFF_METHOD(CDoc, Save, save, (LPCOLESTR pszFileName, BOOL fRemember))
    TEAROFF_METHOD(CDoc, SaveCompleted, savecompleted, (LPCOLESTR pszFileName))
    TEAROFF_METHOD(CDoc, GetCurFile, getcurfile, (LPOLESTR *ppszFileName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPersistMoniker)
    // IPersist methods
    TEAROFF_METHOD(CDoc, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistMoniker methods
    TEAROFF_METHOD(CDoc, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDoc, Load, load, (BOOL fFullyAvailable, IMoniker *pmkName, LPBC pbc, DWORD grfMode))
    TEAROFF_METHOD(CDoc, Save, save, (IMoniker *pmkName, LPBC pbc, BOOL fRemember))
    TEAROFF_METHOD(CDoc, SaveCompleted, savecompleted, (IMoniker *pmkName, LPBC pibc))
    TEAROFF_METHOD(CDoc, GetCurMoniker, getcurmoniker, (IMoniker  **ppimkName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IMonikerProp)
    // IMonikerProp methods
    TEAROFF_METHOD(CDoc, PutProperty, putproperty, (MONIKERPROPERTY mkp, LPCWSTR wzValue))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CDoc, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CDoc, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CDoc, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CDoc, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CDoc, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IHlinkTarget)
    TEAROFF_METHOD(CDoc, SetBrowseContext, setbrowsecontext, (IHlinkBrowseContext *pihlbc))
    TEAROFF_METHOD(CDoc, GetBrowseContext, getbrowsecontext, (IHlinkBrowseContext **ppihlbc))
    TEAROFF_METHOD(CDoc, Navigate, navigate, (DWORD grfHLNF, LPCWSTR wzJumpLocation))
    // NOTE: the following is renamed in tearoff to avoid multiple inheritance problem with IOleObject::GetMoniker
    TEAROFF_METHOD(CDoc, GetMonikerHlink, getmonikerhlink, (LPCWSTR wzLocation, DWORD dwAssign, IMoniker **ppimkLocation))
    TEAROFF_METHOD(CDoc, GetFriendlyName, getfriendlyname, (LPCWSTR wzLocation, LPWSTR *pwzFriendlyName))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CDoc, ITargetContainer)
    TEAROFF_METHOD(CDoc, GetFrameUrl, getframeurl, (LPWSTR *ppszFrameSrc))
    TEAROFF_METHOD(CDoc, GetFramesContainer, getframescontainer, (IOleContainer **ppContainer))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IShellPropSheetExt)
    TEAROFF_METHOD(CDoc, AddPages, addpages, (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam))
    TEAROFF_METHOD(CDoc, ReplacePage, replacepage, (UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IObjectSafety)
    TEAROFF_METHOD(CDoc, GetInterfaceSafetyOptions, getinterfacesafetyoptions, (REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions))
    TEAROFF_METHOD(CDoc, SetInterfaceSafetyOptions, setinterfacesafetyoptions, (REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, ICustomDoc)
    TEAROFF_METHOD(CDoc, SetUIHandler, setuihandler, (IDocHostUIHandler * pUIHandler))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IAuthenticate)
    TEAROFF_METHOD(CDoc, Authenticate, authenticate, (HWND * phwnd, LPWSTR * pszUsername, LPWSTR * pszPassword))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IWindowForBindingUI)
    TEAROFF_METHOD(CDoc, GetWindowBindingUI, getwindowbindingui, (REFGUID rguidReason, HWND * phwnd))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IMarkupServices2)
    TEAROFF_METHOD(CDoc, CreateMarkupPointer, createmakruppointer, (IMarkupPointer **ppPointer))
    TEAROFF_METHOD(CDoc, CreateMarkupContainer, createmarkupcontainer, (IMarkupContainer **ppMarkupContainer))
    TEAROFF_METHOD(CDoc, CreateElement, createelement, (ELEMENT_TAG_ID, OLECHAR *, IHTMLElement **))
    TEAROFF_METHOD(CDoc, CloneElement, cloneelement, (IHTMLElement *, IHTMLElement * *))
    TEAROFF_METHOD(CDoc, InsertElement, insertelement, (IHTMLElement *pElementInsert, IMarkupPointer *pPointerStart, IMarkupPointer *pPointerFinish))
    TEAROFF_METHOD(CDoc, RemoveElement, removeelement, (IHTMLElement *pElementRemove))
    TEAROFF_METHOD(CDoc, Remove, remove, (IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, Copy, copy, (IMarkupPointer *, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, Move, move, (IMarkupPointer *, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, InsertText, inserttext, (OLECHAR *, long, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, ParseString, parsestring, (OLECHAR *, DWORD, IMarkupContainer **, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, ParseGlobal, parseglobal, (HGLOBAL, DWORD, IMarkupContainer **, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, IsScopedElement, isscopedelement, (IHTMLElement *, BOOL *))
    TEAROFF_METHOD(CDoc, GetElementTagId, getelementtagid, (IHTMLElement *, ELEMENT_TAG_ID *))
    TEAROFF_METHOD(CDoc, GetTagIDForName, gettagidforname, (BSTR, ELEMENT_TAG_ID *))
    TEAROFF_METHOD(CDoc, GetNameForTagID, getnamefortagid, (ELEMENT_TAG_ID, BSTR *))
    TEAROFF_METHOD(CDoc, MovePointersToRange, movepointerstorange, (IHTMLTxtRange *, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, MoveRangeToPointers, moverangetopointers, (IMarkupPointer *, IMarkupPointer *, IHTMLTxtRange *))
    TEAROFF_METHOD(CDoc, BeginUndoUnit, beginundounit, (OLECHAR *))
    TEAROFF_METHOD(CDoc, EndUndoUnit, beginundounit, ())
    TEAROFF_METHOD(CDoc, ParseGlobalEx, parseglobalex, (HGLOBAL hGlobal, DWORD dwFlags, IMarkupContainer *pContext,IMarkupContainer **pContainerResult, IMarkupPointer *, IMarkupPointer *))
    TEAROFF_METHOD(CDoc, ValidateElements, validateelements, (IMarkupPointer *pPointerStart, IMarkupPointer *pPointerFinish, IMarkupPointer *pPointerTarget, IMarkupPointer *pPointerStatus, IHTMLElement **ppElemFailBottom, IHTMLElement **ppElemFailTop))
#ifndef UNIX
    TEAROFF_METHOD(CDoc, SaveSegmentsToClipboard , savesegmentstoclipboard , ( ISegmentList * pSegmentList, DWORD dwFlags ))
#else
    TEAROFF_METHOD(CDoc, SaveSegmentsToClipboard , savesegmentstoclipboard , ( ISegmentList * pSegmentList, DWORD dwFlags, VARIANTARG * pvarargOut ))
#endif
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IHighlightRenderingServices)
    TEAROFF_METHOD(CDoc, AddSegment, addsegment, (  IDisplayPointer     *pIDispStart,
                                                    IDisplayPointer     *pIDispEnd,
                                                    IHTMLRenderStyle    *pIRenderStyle,
                                                    IHighlightSegment   **ppISegment ) )
    TEAROFF_METHOD(CDoc, MoveSegmentToPointers, movesegmenttopointers, (IHighlightSegment   *pISegment,
                                                                        IDisplayPointer     *pIDispStart,
                                                                        IDisplayPointer     *pIDispEnd) )
    TEAROFF_METHOD(CDoc, RemoveSegment, removesegment, (IHighlightSegment *pISegment) )
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IDisplayServices)
    TEAROFF_METHOD(CDoc, CreateDisplayPointer, createdisplaypointer, (IDisplayPointer **ppDispPointer))
    TEAROFF_METHOD(CDoc, TransformRect, transformrect, ( RECT           * pRect, 
                                                           COORD_SYSTEM eSource, 
                                                           COORD_SYSTEM eDestination, 
                                                           IHTMLElement * pIElement ))

    TEAROFF_METHOD(CDoc, TransformPoint, transformpoint, ( POINT        * pPoint, 
                                                           COORD_SYSTEM eSource, 
                                                           COORD_SYSTEM eDestination, 
                                                           IHTMLElement * pIElement ))
    TEAROFF_METHOD(CDoc, GetCaret, getcaret, (IHTMLCaret ** ppCaret))
    TEAROFF_METHOD(CDoc, GetComputedStyle, getcomputedstyle, (IMarkupPointer* pPointer, IHTMLComputedStyle** ppComputedStyle))
    TEAROFF_METHOD(CDoc, ScrollRectIntoView, scrollrectintoview, ( IHTMLElement* pIElement , RECT rect ))
    TEAROFF_METHOD(CDoc, HasFlowLayout, hasflowlayout, (IHTMLElement *pIElement, BOOL *pfHasFlowLayout))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CDoc, IXMLGenericParse)
    TEAROFF_METHOD(CDoc, SetGenericParse, setgenericparse, (VARIANT_BOOL fDoGeneric))
END_TEAROFF_TABLE()

#if DBG == 1
    //
    // IEditDebugServices Methods
    //
BEGIN_TEAROFF_TABLE( CDoc, IEditDebugServices)
    TEAROFF_METHOD( CDoc, GetCp, getcp , ( IMarkupPointer* pIPointer, long* pcp))                                                
    TEAROFF_METHOD( CDoc, SetDebugName, setdebugname, ( IMarkupPointer* pIPointer, LPCTSTR strDebugName ))
    TEAROFF_METHOD( CDoc, SetDisplayPointerDebugName, setdebugname, ( IDisplayPointer* pDispPointer, LPCTSTR strDebugName ))
    TEAROFF_METHOD( CDoc, DumpTree , dumptree, ( IMarkupPointer* pIPointer))
    TEAROFF_METHOD( CDoc, LinesInElement, linesinelement, (IHTMLElement *pIHTMLElement, long *piLines))
    TEAROFF_METHOD( CDoc, FontsOnLine, fontsonline, (IHTMLElement *pIHTMLElement, long iLine, BSTR *pbstrFonts))
    TEAROFF_METHOD( CDoc, GetPixel, getpixel, (long X, long Y, long *piColor))
    TEAROFF_METHOD( CDoc, IsUsingBckgrnRecalc, isusingbckgrnrecalc, (BOOL *pfUsingBckgrnRecalc))
    TEAROFF_METHOD( CDoc, IsEncodingAutoSelect, isencodingautoselect, (BOOL *pfEncodingAutoSelect))
    TEAROFF_METHOD( CDoc, EnableEncodingAutoSelect, enableencodingautoselect, (BOOL fEnable))
    TEAROFF_METHOD( CDoc, IsUsingTableIncRecalc, isusingtableincrecalc, (BOOL *pfUsingTableIncRecalc))
END_TEAROFF_TABLE()   
#endif // IEditDebugServices

BEGIN_TEAROFF_TABLE(CDoc, IIMEServices)
    TEAROFF_METHOD(CDoc, GetActiveIMM, getactiveimm, ( IActiveIMMApp **ppActiveIMM ))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDoc, IPrivacyServices)
    TEAROFF_METHOD(CDoc, AddPrivacyInfoToList, addprivacyinfotolist, ( 
                                    LPOLESTR    pstrUrl,
                                    LPOLESTR    pstrPolicyRef,
                                    LPOLESTR    pstrP3PHeader,
                                    LONG        dwReserved,
                                    DWORD       privacyFlags))
END_TEAROFF_TABLE()

// GetData format information
// note: the LINKSRCDESCRIPTOR and OBJECTDESCRIPTOR are identical structures
//       so we use the OBJECTDESCRIPTOR get/set fns for both.

// Note: can't be const because SetCommonClipFormats() converts private CF_COMMON(...)
//       into registered format handles (from RegisterClipFormats())
FORMATETC CDoc::s_GetFormatEtc[] =
{
    STANDARD_FMTETCGET
//  { cfFormat,                         ptd,  dwAspect,   lindex,  tymed },
    { CF_COMMON(ICF_LINKSRCDESCRIPTOR), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_COMMON(ICF_LINKSRCDESCRIPTOR), NULL, DVASPECT_ICON, -1L, TYMED_HGLOBAL },
    { CF_COMMON(ICF_LINKSOURCE),        NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { CF_COMMON(ICF_LINKSOURCE),        NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
    { CF_TEXT,                          NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { CF_TEXT,                          NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
    { CF_UNICODETEXT,                   NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { CF_UNICODETEXT,                   NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
#ifndef NO_RTF
    { (WORD)RegisterClipboardFormat(_T("CF_RTF")),    NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM },
    { (WORD)RegisterClipboardFormat(_T("CF_RTF")),    NULL, DVASPECT_ICON, -1L, TYMED_ISTREAM },
#endif // ndef NO_RTF
};

const CServer::LPFNGETDATA CDoc::s_GetFormatFuncs[] =
{
    STANDARD_PFNGETDATA
    &CServer::GetOBJECTDESCRIPTOR,  //  Actually LINKSRCDESCRIPTOR
    &CServer::GetOBJECTDESCRIPTOR,  //  Actually LINKSRCDESCRIPTOR
    &CServer::GetLINKSOURCE,
    &CServer::GetLINKSOURCE,
    &CDoc::GetTEXT,
    &CDoc::GetTEXT,
#ifdef UNICODE
    &CDoc::GetUNICODETEXT,
    &CDoc::GetUNICODETEXT,
#endif // UNICODE
#ifndef NO_RTF
    &CDoc::GetRTF,
    &CDoc::GetRTF,
#endif // !NO_RTF
};

#ifndef NO_PROPERTY_PAGE
const CLSID * const CDoc::s_apClsidPages[] =
{
    // Browse-time Pages
    &CLSID_CDocBrowsePropertyPage,
    NULL,
    // Edit-time Pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CServer::CLASSDESC CDoc::s_classdesc =
{
    {                                            // _classdescBase
        &CLSID_HTMLDocument,                     // _pclsid
        IDR_BASE_HTMLFORM,                       // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apClsidPages,                          // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                    // _pcpi
        SERVERDESC_CREATE_UNDOMGR |              // _dwFlags
        SERVERDESC_ACTIVATEONDRAG |
        SERVERDESC_SUPPORT_DRAG_DROP |
        SERVERDESC_HAS_MENU |
        SERVERDESC_HAS_TOOLBAR,
        NULL,                                    // _piidDispinterface
        &s_apHdlDescs,                           // _apHdlDesc
    },
    MISC_STATUS_FORM,                            // _dwMiscStatus
    0,                                           // _dwViewStatus
    ARRAY_SIZE(g_aOleVerbStandard),              // _cOleVerbTable
    g_aOleVerbStandard,                          // _pOleVerbTable
    g_apfnDoVerbStandard,                        // _pfnDoVerb
    ARRAY_SIZE(s_GetFormatFuncs),                // _cGetFmtTable
    s_GetFormatEtc,                              // _pGetFmtTable
    s_GetFormatFuncs,                            // _pGetFuncs
    0,                                           // _cSetFmtTable
    NULL,                                        // _pSetFmtTable
    NULL,                                        // _pSetFuncs
    0,                                           // _ibItfPrimary
    DISPID_UNKNOWN,                              // _dispidRowset
    0,                                           // _wVFFlags  (match Value property typelib)
    DISPID_UNKNOWN,                              // _dispIDBind
    ~0UL,                                        // _uGetBindIndex
    ~0UL,                                        // _uPutBindIndex
    VT_EMPTY,                                    // _vtBindType
    ~0UL,                                        // _uGetValueIndex
    ~0UL,                                        // _uPutValueIndex
    VT_EMPTY,                                    // _vtValueType
    ~0UL,                                        // _uSetRowset
    0,                                           // _sef
};


#if DBG == 1
void TestStringTable();

void DebugDocStartupCheck()
{
    TestStringTable();

    // verify CLIENTLAYERS and BEHAVIORRENDERINFO constants are in sync
    Assert(CLIENTLAYERS_BEFOREBACKGROUND    == BEHAVIORRENDERINFO_BEFOREBACKGROUND);
    Assert(CLIENTLAYERS_AFTERBACKGROUND     == BEHAVIORRENDERINFO_AFTERBACKGROUND);
    Assert(CLIENTLAYERS_BEFORECONTENT       == BEHAVIORRENDERINFO_BEFORECONTENT);
    Assert(CLIENTLAYERS_AFTERCONTENT        == BEHAVIORRENDERINFO_AFTERCONTENT);
    Assert(CLIENTLAYERS_AFTERFOREGROUND     == BEHAVIORRENDERINFO_AFTERFOREGROUND);

    Assert(CLIENTLAYERS_DISABLEBACKGROUND   == BEHAVIORRENDERINFO_DISABLEBACKGROUND);
    Assert(CLIENTLAYERS_DISABLENEGATIVEZ    == BEHAVIORRENDERINFO_DISABLENEGATIVEZ);
    Assert(CLIENTLAYERS_DISABLECONTENT      == BEHAVIORRENDERINFO_DISABLECONTENT);
    Assert(CLIENTLAYERS_DISABLEPOSITIVEZ    == BEHAVIORRENDERINFO_DISABLEPOSITIVEZ);
}

#endif

BOOL
CompareProductVersion(LPTSTR lpModule, LPTSTR lpVersionStr)
{
    BOOL        fIsEqual = FALSE;
    DWORD       cchVersionStrSize;
    DWORD       cbVersionInfoSize;
    DWORD       dwHandle = 0;
    VOID        *pData = NULL;

    Assert(lpModule != NULL);
    Assert(lpVersionStr != NULL);

    cchVersionStrSize = wcslen(lpVersionStr);

    if (cchVersionStrSize > 0)
    {
        //  Find the version info size.
        cbVersionInfoSize = GetFileVersionInfoSize(lpModule, &dwHandle);

        if (cbVersionInfoSize > 0)
        {
            pData = new BYTE[cbVersionInfoSize];

            if (pData)
            {
                //  Get the version info.
                if (GetFileVersionInfo(lpModule, dwHandle, cbVersionInfoSize, pData))
                {
                    struct LANGANDCODEPAGE {
                      WORD wLanguage;
                      WORD wCodePage;
                    } *lpTranslate;

                    LPTSTR              lpBuffer = NULL;
                    TCHAR               strSubBlock[40];
                    UINT                cbTranslate;
                    UINT                cchQueryValue = 0;
                    UINT                i;
                    BOOL                fFound = FALSE;

                    //  We'll find the supported language and code page.  We'll use these
                    //  to query for the product version.

                    if (VerQueryValue(pData, TEXT("\\VarFileInfo\\Translation"), (LPVOID*)&lpTranslate, &cbTranslate))
                    {
                        for( i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++ )
                        {
                            wsprintf( strSubBlock, 
                                    TEXT("\\StringFileInfo\\%04x%04x\\ProductVersion"),
                                    lpTranslate[i].wLanguage,
                                    lpTranslate[i].wCodePage);

                            //  Query for the product version.
                            fFound = VerQueryValue(pData, strSubBlock, (LPVOID*)&lpBuffer, &cchQueryValue);

                            //  Compare the version strings.
                            if ( fFound && lpBuffer && cchQueryValue >= cchVersionStrSize &&
                                _tcsnicmp(lpBuffer, cchVersionStrSize, lpVersionStr, cchVersionStrSize) == 0)
                            {
                                fIsEqual = TRUE;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (pData)
        delete pData;

    return fIsEqual;
}


//+---------------------------------------------------------------
//
//  Member:     InitDocClass
//
//  Synopsis:   Initializes the CDoc class
//
//  Returns:    TRUE iff the class could be initialized successfully
//
//  Notes:      This method initializes the verb tables in the
//              class descriptor.  Called by the LibMain
//              of the DLL.
//
//---------------------------------------------------------------

HRESULT
InitDocClass()
{
    if (!g_fDocClassInitialized)
    {
        LOCK_GLOBALS;

        // If another thread completed initialization while this thread waited
        // for the global lock, immediately return
        //
        if (g_fDocClassInitialized)
            return(S_OK);

        int     i;

        // Fetch parameters from the registry.  Use GetProfileIntA because
        // its faster on Win95 and the strings are smaller.
        //
        // CONSIDER: centralize this stuff and update on profile change.
        //
        // TODO: Confirm that GetProfileInt calls are actually fetching
        // profile data. (Are these the APIs to use? Are the key names correct?)
        //
        //  Localization: Do not localize the profile strings below.
        //

        i = GetProfileIntA(s_achWindows, "DragScrollInset", DD_DEFSCROLLINSET);
        g_sizeDragScrollInset.cx = i;
        g_sizeDragScrollInset.cy = i;
        g_iDragScrollDelay = GetProfileIntA(
                s_achWindows,
                "DragScrollDelay",
                DD_DEFSCROLLDELAY);

#ifndef _MAC
        g_iDragDelay = GetProfileIntA(
                s_achWindows,
                "DragDelay",
                DD_DEFDRAGDELAY),
#else
        g_iDragDelay = GetProfileIntA(s_achWindows, "DragDelay", 20),
#endif

        g_iDragScrollInterval = GetProfileIntA(
                s_achWindows,
                "DragScrollInterval",
                DD_DEFSCROLLINTERVAL);

        SetCommonClipFormats(
                CDoc::s_GetFormatEtc,
                ARRAY_SIZE(CDoc::s_GetFormatEtc));

        char szModule[MAX_PATH];

        if (!GetModuleFileNameA(NULL, szModule, MAX_PATH))
        {
            Assert(FALSE);
            return (E_FAIL);
        }

        // This code is somewhat redundant.  This is part of bug fix for 21939.
        // Mixing chars and tchars in CompareProductVersion is causing it to
        // fail on Windows98.  This is the easiest way to fix it.
        TCHAR tszModule[MAX_PATH];
        if (!GetModuleFileName(NULL, tszModule, MAX_PATH))
        {
            Assert(FALSE);
            return (E_FAIL);
        }

        g_IEHardened = IEHardened();

        if ( NULL != StrStrIA(szModule, "explorer.exe"))
        {
            g_fInExplorer = TRUE;
            g_fInKnownBrowserApp = TRUE;
            goto QuickDone;
        }

        //
        // If we're the browser bypass all other app string compares...
        //
        if ( NULL != StrStrIA(szModule, "iexplore.exe"))
        {
            g_fHiResAware  = TRUE;
            g_fInIexplorer = TRUE;
            g_fInKnownBrowserApp = TRUE;
            goto QuickDone;
        }

        if (NULL != StrStrIA(szModule, "msn6.exe") || 
            NULL != StrStrIA(szModule, "aol.exe")  || 
            NULL != StrStrIA(szModule, "neo.exe"))
        {
            g_fInKnownBrowserApp = TRUE;
        }

        //Get and store the ModuleName. This is primarily used for ProcessUrlAction 
        //in non-Browser, non-Explorer cases
        TCHAR *pFileName = PathFindFileName(tszModule);
        DWORD len = _tcslen(pFileName);
        g_tszModuleFileName = new TCHAR[len+1];
        if (!g_tszModuleFileName)
        {
            return E_OUTOFMEMORY;
        }
        _tcsncpy(g_tszModuleFileName, pFileName, len+1);

        g_fHiResAware  = ( NULL != ::FindAtom(DOCHOSTUIATOM_ENABLE_HIRES) );
        

        g_fInMoney98         =  NULL != StrStrIA(szModule, "msmoney.exe")
                            ||  IsTagEnabled(tagCompatMsMoney);

        g_fInMoney99         =  (NULL != StrStrIA(szModule, "msmoney.exe")) &&
                                CompareProductVersion(tszModule, TEXT("7."));

        g_fInMoney2001       =  (NULL != StrStrIA(szModule, "msmoney.exe")) && 
                                CompareProductVersion(tszModule, TEXT("9."));
                            
        g_fInVizAct2000      =  NULL != StrStrIA(szModule, "vizact.exe");
                            
        g_fInPhotoSuiteIII   =  NULL != StrStrIA(szModule, "PhotoSuite.exe");

        g_fInHomePublisher98 =  NULL != StrStrIA(szModule, "homepub.exe")
#if DBG==1
                            ||  NULL != StrStrIA(szModule, "homepubd.exe")
#endif
        ;

        g_fInPip           = NULL != StrStrIA(szModule,"pip.exe");

        g_fInLotusNotes    = NULL != StrStrIA(szModule,"nlnotes.exe");

        g_fInMshtmpad      = NULL != StrStrIA(szModule, "mshtmpad.exe");

        
        g_fInMSWorksCalender = (   NULL !=  StrStrIA(szModule, "wkscal.exe")     // works2000, works 2001
                                || NULL !=  StrStrIA(szModule, "mswkscal.exe")); // works 98
        //  If we are hosted by Access, we need to determine what version of Access is
        //  hosting us.  We only really care if we are hosted by Access 9.  We'll try
        //  to pull the version out of the version info for the file and see if it
        //  starts with "9.".
        g_fInAccess9 = (NULL != StrStrIA(szModule, "msaccess.exe")) &&
                       CompareProductVersion(tszModule, TEXT("9."));

        g_fInAccess   = NULL != StrStrIA(szModule, "msaccess.exe") ;

        g_fInExcelXP = (NULL != StrStrIA(szModule, "excel.exe")) &&
                       CompareProductVersion(tszModule, TEXT("10."));

        g_fInVisualStudio = NULL != StrStrIA(szModule, "devenv.exe") ;
        // IBM Recovery CDs containt a program ssstart.exe which hosts us to show some html pages.
        // The content is not standard compliant, but contains a standard compliant doctype switch.
        // So, the documents are totally screwed up. g_fInIBMSoftwareSelection forces trident to be
        // in legacy mode.
        g_fInIBMSoftwareSelection = NULL != StrStrIA(szModule, "ssstart.exe");        

        // discover.exe is too common. We wanted to use the version resource to
        // figure out that this was from win98, but it turns out that not only
        // does every different language have a different version number,
        // every one stores the resource in a different character set.
        // We hack and just look for "tour\discover.exe".
        if (NULL != StrStrIA(szModule, "discover.exe"))
        {
            HINSTANCE hInst;
            hInst = GetModuleHandle(NULL);
            if (hInst)
            {
                char achPath[MAX_PATH];
                char *sz;

                if (GetModuleFileNameA( hInst, achPath, sizeof(achPath) ))
                {
                    // Compare the last part of the full path.
                    sz = achPath + strlen(achPath) - strlen("\\tour\\discover.exe");
                    g_fInWin98Discover = NULL != StrStrIA(achPath, "\\tour\\discover.exe");
                }
            }
        }

        g_fInInstallShield = NULL != StrStrIA(szModule,"iside.exe");

        g_fInAutoCad       = NULL != (StrStrIA(szModule,"acad.exe") || StrStrIA(szModule,"aclt.exe"));

QuickDone: 
        // Read restrictions from registry
        DWORD dwSize, dwType, dw;
        dwSize = sizeof(dw);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, EXPLORER_REG_KEY, NO_FILE_MENU_RESTR,
                                        &dwType, &dw, &dwSize))
        {
            g_fNoFileMenu = dw;
        }

        g_fDocClassInitialized = TRUE;
    }

    return(S_OK);
}

//+---------------------------------------------------------------
//
//  Member:     CDefaultElement
//
//---------------------------------------------------------------

const CElement::CLASSDESC CDefaultElement::s_classdesc =
{
    {
        NULL,                   // _pclsid
        0,                      // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                   // _pcpi
        0,                      // _dwFlags
        NULL,                   // _piidDispinterface
        NULL
    },
    NULL,
    NULL                        // _paccelsRun
};

CDefaultElement::CDefaultElement ( CDoc * pDoc )
  : CElement ( ETAG_DEFAULT, pDoc )
{
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::CDoc, protected
//
//  Synopsis:   Constructor for the CDoc class
//
//  Arguments:  [pUnkOuter] -- the controlling unknown or NULL if we are
//                             not being created as part of an aggregate
//
//  Notes:      This is the first part of a two-stage construction process.
//              The second part is in the Init method.  Use the static
//              Create method to properly instantiate an CDoc object
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // 'this' argument to base-member init list

CDoc::CDoc(LPUNKNOWN pUnkOuter, DOCTYPE doctype)
  : CServer(pUnkOuter)
{
    Assert( g_fDocClassInitialized );
    Assert( _pUrlHistoryStg == NULL );
    Assert( ! _hwndCached );
    Assert( ! _fDeferredScripts );
    Assert( !_fUIHandlerSet );
    
    _dwTID = GetCurrentThreadId();
    _pts = GetThreadState();

    TraceTag((tagCDoc, "%lx constructing CDoc SSN=0x%x TID=0x%x", this, _ulSSN, _dwTID));

    //
    // Initialize the document to a default size
    //

    {
        SIZE sizeDefault;
        g_uiDisplay.HimetricFromDevice(sizeDefault, 100, 100);

        _dciRender.SetUnitInfo(&g_uiDisplay);
        _dciRender._pDoc = this;

        _view.Initialize(this, sizeDefault);        //  The view contains a measuring device.
    }

    Assert( ! _pElemCurrent );
    Assert( ! _pElemUIActive );

    _fShownSpin = TRUE;
    _fIsUpToDate = TRUE;
    _fUseSrcURL  = FALSE;
    _iStatusTop = STL_LAYERS;
    _fShouldEnableAutoImageResize = FALSE;
   
    _sizelGrid.cx = GRIDX_DEFAULTVALUE;
    _sizelGrid.cy = GRIDY_DEFAULTVALUE;

    // Support for document-level object safety settings.

    _fFullWindowEmbed = doctype == DOCTYPE_FULLWINDOWEMBED;
    _fHostedInHTA = doctype == DOCTYPE_HTA;
    _fHostNavigates    = TRUE;  
    _fStartup          = TRUE;
    _fPopupDoc = doctype == DOCTYPE_POPUP;
    _fMhtmlDoc = doctype == DOCTYPE_MHTML;
    
    Assert(!_fMhtmlDocOriginal);  // Initially false. This line does not do anything since _fMhtmlDocOriginal
                                  // is automatically initialized to FALSE. However, it is a reminder that on the 
                                  // navigation to a MIME file _fMhtmlDoc is FALSE, then TRUE _fMhtmlDoc on the handling, 
                                  // but is flipped to FALSE immediately. _fMhtmlDocOriginal will be come TRUE on that load.

    _fEnableInteraction = TRUE;
    
    _sBaselineFont = BASELINEFONTDEFAULT;

    _triOMOffscreenOK = -1; // set offscreen to auto

    SetPrimaryUrl(_T("about:blank"));

    // Append to thread doc array
    TLS(_paryDoc).Append(this);

    MemSetName((this, "CDoc SSN=%d", _ulSSN));

    // Register the window message (if not registered)
    if(_g_msgHtmlGetobject == 0)
    {
        _g_msgHtmlGetobject = RegisterWindowMessage(MSGNAME_WM_HTML_GETOBJECT);
        Assert(_g_msgHtmlGetobject != 0);
    }

#if !defined(NO_IME)
    if (   g_dwPlatformVersion < 0x4000a
        && _g_msgImeReconvert == 0)
    {
        _g_msgImeReconvert  = RegisterWindowMessage(RWM_RECONVERT);
        Assert(_g_msgImeReconvert != 0);
    }
#endif // !NO_IME

    _fNeedTabOut = FALSE;

    _fRegionCollection = FALSE; // default no need to build region collection
    _fDisableReaderMode = FALSE;

    _fPlaintextSave = FALSE;

    _pCaret = NULL;
    _pSharedStyleSheets = NULL;
    
    // reset the accessibility object, we don't need it until we're asked
    _pAccTypeInfo = NULL;

#ifdef TEST_LAYOUT
    _hExternalLayoutDLL = (HMODULE) INVALID_HANDLE_VALUE;
#endif

#if DBG == 1
    DebugDocStartupCheck();
#endif

    _aryAccEvents.SetCDoc(this);

    _pdomImplementation = NULL;

    _hDevNames =
    _hDevMode  = NULL;

    _pDT = NULL;
}

#pragma warning(default:4355)

//+---------------------------------------------------------------
//
//  Member:     CDoc::~CDoc
//
//  Synopsis:   Destructor for the CDoc class
//
//---------------------------------------------------------------

CDoc::~CDoc ( )
{

    TraceTag((tagCDoc, "%lx CDoc::~CDoc", this));

    Assert(!_pNodeGotButtonDown);

    ClearInterface(&_pUrlHistoryStg);

    //
    // Destroy host stylesheets collection subobject (if anyone held refs on it, we
    // should never have gotten here since the doc should then have subrefs
    // keeping it alive).  This is the only place where we directly access the
    // CBase impl. of IUnk. for the CStyleSheetArray -- we do this instead of
    // just calling delete in order to assure that the CBase part of the CSSA
    // is properly destroyed (CBase::Passivate gets called etc.)
    //
    // StyleSheets moved to CMarkup

    if (_pHostStyleSheets)  // TODO (alexz) investigate why is refcounting so complicated
    {
        _pHostStyleSheets->Free ( );
        _pHostStyleSheets->CBase::PrivateRelease();
        _pHostStyleSheets = NULL;
    }

    // Remove Doc from Thread state array
    TLS(_paryDoc).DeleteByValue(this);

    TraceTag((tagCDoc, "%lx destructed CDoc", this));

    // CVersions object
    if (_pVersions)
    {
        _pVersions->Release();
        _pVersions = NULL;
    }


    delete _pSharedStyleSheets;
    _pSharedStyleSheets = NULL;
    

    // In case any extra expandos were added after CDoc::Passivate (see bug 55425)
    _AtomTable.Free();

#if DBG == 1
    // Make sure there is nothing in the image context cache

    {
        URLIMGCTX * purlimgctx = _aryUrlImgCtx;
        LONG        curlimgctx = _aryUrlImgCtx.Size();
        LONG        iurlimgctx;

        for (iurlimgctx = 0; iurlimgctx < curlimgctx;
             ++iurlimgctx, ++purlimgctx)
        {
            if (purlimgctx->ulRefs > 0)
                break;
        }

        AssertSz(iurlimgctx == curlimgctx, "Image context cache leak");
    }
#endif

    // If we had to get type information for IAccessible, release type info
    if ( _pAccTypeInfo )
        _pAccTypeInfo->Release();

    Assert(!_aryANotification.Size());    
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Init
//
//  Synopsis:    Second phase of construction
//
//--------------------------------------------------------------------------

HRESULT
CDoc::Init()
{
    HRESULT hr;
    THREADSTATE * pts = GetThreadState();
    CMarkup * pMarkup = NULL;

    hr = THR( super::Init() );

    if (hr)
        goto Cleanup;

    //
    // Create the default site (not to be confused with a root site)
    //

    Assert(!_pElementDefault);
    _pElementDefault = new CDefaultElement ( this );
    if (!_pElementDefault)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( CSharedStyleSheetsManager::Create(&_pSharedStyleSheets, this) );
    if (hr)
        goto Cleanup;

    _icfDefault = -1;

    //
    // Create the primary window with an empty markup
    //

    hr = THR(CreateMarkup(&pMarkup, NULL, FALSE, TRUE));
    if (hr)
        goto Cleanup;

    _pElemCurrent = pMarkup->Root();

    _aryAccEvents.Init();

    //
    // Initialize format caches
    //

    if (!TLS(_pCharFormatCache))
    {
        hr = THR(InitFormatCache( pts ));
        if (hr)
            goto Cleanup;
    }
    
    _dwStylesheetDownloadingCookie = 1;

    _pWhitespaceManager = new CWhitespaceManager();
    if (!_pWhitespaceManager)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the default block tag to P.
    SetDefaultBlockTag(ETAG_P);

    // Create the cookie privacy list
    _pPrivacyList = new(Mt(CPrivacyList)) CPrivacyList(_pts);
    if (!_pPrivacyList)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pPrivacyList->Init();

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    // Needed for cookie privacy information to check whether we are in a script context or not
    _cScriptNestingTotal = 0;

Cleanup:
    if (pMarkup)
    {
        pMarkup->Release();
    }
    RRETURN( hr );
}



void
CDoc::SetLoadfFromPrefs()
{
    // Read in the preferences, if we don't already have them
    if( _pOptionSettings == NULL )
    {
        HRESULT hr;
        if (IsPrintDialogNoUI()) 
            hr = THR(UpdateFromRegistry(REGUPDATE_REFRESH));
        else
            hr = THR(UpdateFromRegistry());
        Assert(hr || _pOptionSettings);
    }

    if (_pOptionSettings)
    {
        _dwLoadf =
            ((_pOptionSettings->fShowImages || _fInTrustedHTMLDlg)
                ? DLCTL_DLIMAGES     : 0) |
#ifndef NO_AVI
            (_pOptionSettings->fShowVideos  ? DLCTL_VIDEOS       : 0) |
#endif
            ((_pOptionSettings->fPlaySounds
                         && !IsPrintDialogNoUI())  ? DLCTL_BGSOUNDS     : 0);
    }

    if (DesignMode() || (PrimaryMarkup() && PrimaryMarkup()->DontRunScripts()) )
    {
        _dwLoadf |= DLCTL_NO_SCRIPTS;
    }

    if (_pHostPeerFactory)
    {
        SetCssPeersPossible(); // TODO (alexz) reconsider this
    }

    GetLoadFlag(DISPID_AMBIENT_SILENT);
    GetLoadFlag(DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);

    if (_dwFlagsHostInfo & DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8)
        _dwLoadf |= DLCTL_URL_ENCODING_DISABLE_UTF8;
    else if (_dwFlagsHostInfo & DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8)
        _dwLoadf |= DLCTL_URL_ENCODING_ENABLE_UTF8;
}

void
CDoc::ReleaseEditor()
{
    //
    // Tear down the editor
    //
    ReleaseInterface( _pIHTMLEditor );
    _pIHTMLEditor = NULL;

    //
    // Release caret
    //   
    ReleaseInterface( _pCaret );
    _pCaret = NULL;

    //
    // Release editing resource DLL
    //
    if (_hEditResDLL)
    {
        FreeLibrary(_hEditResDLL);
        _hEditResDLL = NULL;
    }
    
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------

void
CDoc::Passivate ( )
{
    //
    // behaviors support
    //

    ClearInterface(&_pIepeersFactory);
    ClearInterface (&_pHostPeerFactory);
    ClearInterface (&_pFilterBehaviorFactory);

    if (_pExtendedTagTableHost)
    {
        _pExtendedTagTableHost->Release();
        _pExtendedTagTableHost = NULL;
    }

    //
    // When my last reference is released, don't accept any excuses
    // while shutting down

    _fForceCurrentElem = TRUE;

    //  Containers are not required to call IOleObject::Close on
    //    objects; containers are allowed to just release all pointers
    //    to an embedded object.  This means that the last reference
    //    to an object can disappear while the object is still in
    //    the OS_RUNNING state.  So, we demote it if necessary.
    //
    //  This duplicates logic in CServer::Passivate, which we don't
    //    call since it also calls CBase::Passivate, which we call
    //    separately.  We transition to the loaded state before
    //    we completely shut down since we can be called back by
    //    controls as they are being unloaded.

    if (_hwndCached)
    {
        Assert(IsWindow(_hwndCached));

        // I would like to assert that there better not be any child windows
        // (of windowed controls on the page) still hanging around at this point.
        // However, this fails in some cases, e.g. a control doesn't destroy its
        // window when going from inplace to running. It is useful to turn this
        // assert on when debugging shutdown problems related to windowed controls.
        //
        // Assert(::GetWindow(_hwndCached, GW_CHILD) == NULL);

        Verify(DestroyWindow(_hwndCached));
        _hwndCached = NULL;
    }

    _aryAccEvents.Passivate();

    Assert(_state <= OS_RUNNING);
    if (_state > OS_LOADED)
    {
        Verify(!TransitionTo(OS_LOADED));
    }

    ClearInterface(&_pTimerDraw);

    NotifySelection(EDITOR_NOTIFY_DOC_ENDED, NULL);
    ReleaseEditor();

    // Unload the contents of the document

    UnloadContents( FALSE, FALSE );

    Assert( _pElementDefault );

    CElement::ClearPtr( (CElement**)&_pElementDefault );

    if (_pActiveXSafetyProvider &&
        _pActiveXSafetyProvider != (IActiveXSafetyProvider *)-1) {
        _pActiveXSafetyProvider->Release();
    }

    ClearInterface(&_pDownloadNotify);

    FormsFreeString(_bstrUserAgent);
    _bstrUserAgent = NULL;

    if ( _pHostStyleSheets )
    {
        _pHostStyleSheets->Release();
        // we will delete in destructor
    }

    ClearInterface(&_phlbc);

    //  Now, we can safely shut down the form.
    if (_pWindowPrimary)
    {
        _pWindowPrimary->Release();
        _pWindowPrimary = NULL;
    }

    ClearInterface(&_pTravelLog);
    ClearInterface(&_pBrowserSvc);
    ClearInterface(&_pShellBrowser);
    ClearInterface(&_pTridentSvc);
    ClearInterface(&_pTopWebOC);

    GWKillMethodCall(this, ONCALL_METHOD(CServer, SendOnDataChange, sendondatachange), 0);
    GWKillMethodCall(this, NULL, 0);

    ClearInterface(&_pHostUIHandler);
    ClearInterface(&_pBackupHostUIHandler);
    ClearInterface(&_pHostUICommandHandler);
    ClearInterface(&_pSecurityMgr);
    ClearInterface(&_pPrintSecurityMgr);

    if (_hpalDocument)
    {
        DeleteObject(_hpalDocument);
        _hpalDocument = 0;
    }

    if (_pColors)
    {
        CoTaskMemFree(_pColors);
        _pColors = 0;
    }
    // release caches if needed...
    {
#ifndef NODD
        ClearSurfaceCache();
#endif
    }
    ClearInterface(&_pDSL);

    ClearDefaultCharFormat();

    if (_pPrivacyList)
    {
        _pPrivacyList->SetShutDown();
        _pPrivacyList->Release();
        _pPrivacyList = NULL;
    }
    
    NotifySelection( EDITOR_NOTIFY_DOC_ENDED, NULL );

#ifdef TEST_LAYOUT
    // Unload the external layout DLL if it's been loaded
    if ( _hExternalLayoutDLL != INVALID_HANDLE_VALUE )
    {
        FreeLibrary( _hExternalLayoutDLL );
        _hExternalLayoutDLL = (HMODULE) INVALID_HANDLE_VALUE;
    }
#endif

    ClearInterface(&_pCachedDocTearoff);

    CServer::Passivate();

    if(_pdomImplementation)
        _pdomImplementation->Release();

    delete _pWhitespaceManager;


    if (_hDevNames)
    {
        ::GlobalFree(_hDevNames);
        _hDevNames = NULL;
    }
    if (_hDevMode)
    {
        ::GlobalFree(_hDevMode);
        _hDevMode = NULL;
    }
}

//----------------------------------------------------------
//
//  Member   : CDoc::UnloadContents
//
//  Synopsis : Frees resources
//
//----------------------------------------------------------

void
CDoc::UnloadContents(BOOL fPrecreated, BOOL fRestartLoad )
{
    // Don't allow WM_PAINT or WM_ERASEBKGND to get processed while
    // the tree is being deleted.  Some controls when deleting their
    // HWNDs will cause WM_ERASEBKGND to get sent to our window.  That
    // starts the paint cycle which is bad news when the site tree is
    // being destroyed.

    CLock   Lock(this, SERVERLOCK_BLOCKPAINT | FORMLOCK_UNLOADING);
    
    // Indicate to anybody who checks that the document has been unloaded
    _cDie++;

    _cStylesheetDownloading         = 0;
    _dwStylesheetDownloadingCookie += 1;

    _aryMarkupNotifyInPlace.DeleteAll();

    UnregisterUrlImgCtxCallbacks();

    delete _pScriptCookieTable;
    _pScriptCookieTable = NULL;

    UpdateInterval(0);

    _recalcHost.Detach();
   
    GWKillMethodCall(this, ONCALL_METHOD(CDoc, FaultInUSP, faultinusp), 0);
    GWKillMethodCall(this, ONCALL_METHOD(CDoc, FaultInJG, faultinjg), 0);

    Assert(_aryChildDownloads.Size() == 0); // ExecStop should have emptied.

    // Delete stored focus rect info
    if (_pRectFocus)
    {
        delete _pRectFocus;
        _pRectFocus = NULL;
    }

    ClearInterface(&_pShortcutUserData);

    if (_pvPics != (void *)(LONG_PTR)(-1))
        MemFree(_pvPics);
    _pvPics = NULL;

    ClearInterface(&_pSecurityMgr);

    FormsKillTimer(this, TIMER_ID_MOUSE_EXIT);
    _fMouseOverTimer = FALSE;

    CTreeNode::ClearPtr( & _pNodeLastMouseOver );
    CTreeNode::ClearPtr( & _pNodeGotButtonDown );

    ReleaseOMCapture();

    // nothing depends on the tree now; release the tree
    //
    // Detach all sites still not detached
    //

    if (PrimaryMarkup())
    {
        if (_pInPlace)
        {
            _pInPlace->_fDeactivating = TRUE;
        }

        _view.Unload();

        // TODO (lmollico): revisit
        {
            CMarkup * pMarkup = PrimaryMarkup();

            delete pMarkup->_pHighlightRenSvcProvider;
            pMarkup->_pHighlightRenSvcProvider = NULL;

            pMarkup->_TxtArray.RemoveAll();
        }
    }

    if (PrimaryMarkup())
        _pElemCurrent = PrimaryMarkup()->Root();

    // reset _fPeersPossible, unless it was set because host supplies peer factory. In that case after refresh
    // we won't be requerying again for any css, namespace, and other information provided by host so the bit
    // can't be turned back on
    if (!_pHostPeerFactory)
        _fCssPeersPossible = FALSE;

    _fContentSavePeersPossible = FALSE;
    _fPageTransitionLockPaint = FALSE;

    // There might be some filter element tasks pending but we don't care

    // If a filter instantiate caused a navigate and unloaded the doc
    // we will be in a bit of trouble.  This doesn't happen today but just in case.
    Assert(!TestLock(FORMLOCK_FILTER));
    
    _fPendingFilterCallback = FALSE;
    GWKillMethodCall(this, ONCALL_METHOD(CDoc, FilterCallback, filtercallback), 0);

    // Delete all entries in our array of pending filter elements.  Each of
    // these elements also has to have its _fHasPendingFilterTask set to false
    // also.

    if (_aryPendingFilterElements.Size() > 0)
    {
        int i = _aryPendingFilterElements.Size();

        while (i > 0)
        {
            i--;

            CElement * pElement = _aryPendingFilterElements[i];

            Assert(pElement != NULL);
            if (pElement == NULL)
                continue;

            pElement->_fHasPendingFilterTask = false;
        }
            
        _aryPendingFilterElements.DeleteAll();
    }

    // Flush the queue of pending expression recalcs
    CleanupExpressionTasks();


    //
    // misc
    //

    delete _pXmlUrnAtomTable;
    _pXmlUrnAtomTable = NULL;

    if (_pInPlace)
    {
        _pInPlace->_fDeactivating = FALSE;
    }

    if (PrimaryMarkup())
    {
        PrimaryMarkup()->UpdateMarkupTreeVersion();
    }   
    
    _fNeedInPlaceActivation = FALSE;
    _fTagsInFrameset = FALSE;
    _fFramesetInBody = FALSE;
    _fRegionCollection = FALSE;
    _fFrameBorderCacheValid = FALSE;
    _fIsUpToDate = TRUE;
    _fHasOleSite = FALSE;
    _fHasBaseTag = FALSE;
    _fInHomePublisherDoc = FALSE;

    GWKillMethodCall(this, ONCALL_METHOD(CDoc, SendSetCursor, sendsetcursor), 0);

    {
        LONG c;
        CStr *pcstr;

        for (pcstr = _acstrStatus, c = STL_LAYERS; c; pcstr += 1, c -= 1)
            pcstr->Free();

        _iStatusTop = STL_LAYERS;
        _fSeenDefaultStatus = FALSE;
    }

    ClearInterface(&_pTypInfo);
    ClearInterface(&_pTypInfoCoClass);

    ClearInterface(&_punkMimeOle);
    ClearInterface(&_pOriginalMoniferForMHTML);

    SetPrimaryUrl(_T("about:blank"));

    FlushUndoData();

    if (_pWindowPrimary)
    {
        _pWindowPrimary->Markup()->TearDownMarkup();
        _pWindowPrimary->Release();
        _pWindowPrimary = NULL;
    }

    //
    // Don't delete our attr array outright since we've stored lotsa things
    // in there like prop notify sinks.  We're going to call FreeSpecial to
    // free everything else except these things.
    //

    if (*GetAttrArray())
    {
        (*GetAttrArray())->FreeSpecial();
    }

    _bufferDepth = 0;       // reset the buffer depth
    _triOMOffscreenOK = -1; // reset offscreen to auto

    // NOTE: (jbeda) I'm not sure this is necessary
    // reset SSL security/prompting state
    _sslPrompt = SSL_PROMPT_ALLOW;
    _sslSecurity = SSL_SECURITY_UNSECURE;

    _aryDefunctObjects.DeleteAll();

    if (_fHasOleSite)
    {
        CoFreeUnusedLibraries();
    }
    
    //
    // NOTE(SujalP): Our current usage pattern dictates that at this point there
    // should be no used entries in the cache. However, when we start caching a
    // plsline inside the cache at that point we will have used entries here and
    // then VerifyNonUsed() cannot be called.
    //
    WHEN_DBG( TLS(_pLSCache)->VerifyNoneUsed(); )
    TLS(_pLSCache)->Dispose(TRUE);
    
    NotifySelection( EDITOR_NOTIFY_DOC_ENDED, NULL );

    Assert(_lRecursionLevel == 0);
    Assert(!_aryANotification.Size());
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RequestReleaseNotify
//
//---------------------------------------------------------------

HRESULT
CMarkup::RequestReleaseNotify(CElement * pElement)
{
    HRESULT     hr = S_OK;
    CAryElementReleaseNotify * pAryElementReleaseNotify = EnsureAryElementReleaseNotify();

    pAryElementReleaseNotify->Append(pElement);
    pElement->SubAddRef();

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RevokeRequestReleaseNotify
//
//---------------------------------------------------------------

HRESULT
CMarkup::RevokeRequestReleaseNotify(CElement * pElement)
{
    HRESULT     hr = S_OK;
    CAryElementReleaseNotify * pAryElementReleaseNotify = GetAryElementReleaseNotify();

    if (pAryElementReleaseNotify)
    {
        LONG idx = pAryElementReleaseNotify->Find(pElement);

        if (0 <= idx)
        {
            pAryElementReleaseNotify->Delete(idx);
            pElement->SubRelease();
        }
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ReleaseNotify
//
//  Synopsis:   Notifies registered elements to release contained objects.
//
//  Notes:      elements must register to get this notification using RequestReleaseNotify
//
//---------------------------------------------------------------

HRESULT
CMarkup::ReleaseNotify()
{
    CElement *      pElement;
    CNotification   nf;
    int             c;
    CAryElementReleaseNotify * pAryElementReleaseNotify = GetAryElementReleaseNotify();

    if (pAryElementReleaseNotify)
    {
        while (0 < (c = pAryElementReleaseNotify->Size()))
        {
            pElement = (*pAryElementReleaseNotify)[c - 1];

            pAryElementReleaseNotify->Delete(c - 1);

            if (0 < pElement->GetObjectRefs())
            {
                nf.ReleaseExternalObjects(pElement);
                pElement->Notify(&nf);
            }

            pElement->SubRelease();
        }

        Assert (0 == pAryElementReleaseNotify->Size());
    }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:         CDoc::OnCssChange
//
//---------------------------------------------------------------

HRESULT
CDoc::OnCssChange()
{
    HRESULT     hr;

    hr = THR(ForceRelayout());

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:         CDoc::EnsureXmlUrnAtomTable
//
//
//---------------------------------------------------------------

HRESULT
CDoc::EnsureXmlUrnAtomTable(CXmlUrnAtomTable ** ppXmlUrnAtomTable)
{
    HRESULT     hr = S_OK;

    if (!_pXmlUrnAtomTable)
    {
        _pXmlUrnAtomTable = new CXmlUrnAtomTable();
        if (!_pXmlUrnAtomTable)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if (ppXmlUrnAtomTable)
    {
        *ppXmlUrnAtomTable = _pXmlUrnAtomTable;
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:         CDoc::EnsureScriptCookieTable
//
//
//---------------------------------------------------------------

HRESULT
CDoc::EnsureScriptCookieTable(CScriptCookieTable ** ppScriptCookieTable)
{
    HRESULT     hr = S_OK;

    if (!_pScriptCookieTable)
    {
        _pScriptCookieTable = new CScriptCookieTable();
        if (!_pScriptCookieTable)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if (ppScriptCookieTable)
    {
        *ppScriptCookieTable = _pScriptCookieTable;
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::PrivateQueryInterface
//
//  Synopsis:   QueryInterface on our private unknown
//
//---------------------------------------------------------------

HRESULT
CDoc::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    void * appropdescsInVtblOrder = NULL;
    const IID * const * apIID = NULL;

    // Obsolete (replaced by ITargetContainer)
    Assert(!IsEqualIID(iid, IID_ITargetFrame));

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF(this, IServiceProvider, _pUnkOuter)
        QI_TEAROFF(this, IMarqueeInfo, _pUnkOuter)
        QI_TEAROFF(this, IPersistFile, _pUnkOuter)
        QI_TEAROFF2(this, IPersist, IPersistFile, _pUnkOuter)
        QI_TEAROFF(this, IPersistMoniker, _pUnkOuter)
        QI_TEAROFF(this, IMonikerProp, _pUnkOuter)
        QI_TEAROFF(this, IHlinkTarget, _pUnkOuter)
        QI_TEAROFF(this, IPersistStreamInit, _pUnkOuter)
        QI_TEAROFF(this, DataSource, _pUnkOuter)
        QI_TEAROFF(this, ITargetContainer, _pUnkOuter)
        QI_TEAROFF(this, IObjectSafety, _pUnkOuter)
        QI_TEAROFF(this, IShellPropSheetExt, _pUnkOuter)
        QI_TEAROFF(this, IPersistHistory, _pUnkOuter)
        QI_TEAROFF(this, ICustomDoc, _pUnkOuter)
        QI_TEAROFF(this, IObjectIdentity, _pUnkOuter)
        QI_TEAROFF2(this, IMarkupServices, IMarkupServices2, _pUnkOuter)
        QI_TEAROFF(this, IMarkupServices2, _pUnkOuter)
        QI_TEAROFF(this, IHighlightRenderingServices, _pUnkOuter)

       QI_TEAROFF(this, IXMLGenericParse, _pUnkOuter)
#if DBG == 1
        QI_TEAROFF( this, IEditDebugServices, _pUnkOuter )
#endif
       QI_TEAROFF( this, IDisplayServices, _pUnkOuter )
       QI_TEAROFF( this, IIMEServices, _pUnkOuter )
       QI_TEAROFF( this, IPrivacyServices, _pUnkOuter )

     default:
        {
            void *          pvTearoff       = NULL;
            const void *    apfnTearoff     = NULL;
            BOOL            fCacheTearoff  = FALSE;

            if (IsEqualIID(iid, CLSID_HTMLDocument))
            {
                *ppv = this;
                return S_OK;
            }
            else if (DispNonDualDIID(iid) ||
                     IsEqualIID(iid, IID_IHTMLDocument) ||
                     IsEqualIID(iid, IID_IHTMLDocument2))
            {
                if (_pCachedDocTearoff)
                {
                    *ppv = _pCachedDocTearoff;
                    goto Cleanup;
                }
                fCacheTearoff = TRUE;
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument2;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument2;
            }
            else if (IsEqualIID(iid, IID_IHTMLDocument3))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument3;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument3;
            }
            else if (IsEqualIID(iid, IID_IHTMLDocument4))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument4;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument4;
            }
            else if (IsEqualIID(iid, IID_IHTMLDocument5))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnpdIHTMLDocument5;
                appropdescsInVtblOrder = (void *) CDocument::s_ppropdescsInVtblOrderIHTMLDocument5;
            }
            else if (IsEqualIID(iid, IID_IDispatchEx) ||
                     IsEqualIID(iid, IID_IDispatch))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnIDispatchEx;
                apIID = g_apIID_IDispatchEx;
            }
            else if (   IsEqualIID(iid, IID_IOleItemContainer)
                     || IsEqualIID(iid, IID_IOleContainer)
                     || IsEqualIID(iid, IID_IParseDisplayName))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnIOleItemContainer;
            }
            else if (IsEqualIID(iid, IID_IInternetHostSecurityManager))
            {
                pvTearoff = _pWindowPrimary->Document();
                apfnTearoff = (const void *) CDocument::s_apfnIInternetHostSecurityManager;
            }
            else if (iid == IID_IConnectionPointContainer)
            {
                *((IConnectionPointContainer **)ppv) = 
                    new CConnectionPointContainer(_pWindowPrimary->Document(), this);
                if (!*ppv)
                    RRETURN(E_OUTOFMEMORY);
                break;
            }
            else if (IsEqualIID(iid, CLSID_CMarkup) && PrimaryMarkup())
            {
                *ppv = PrimaryMarkup();
                return S_OK;
            }
            else if ((IsEqualIID(iid, IID_IMarkupContainer) || 
                      IsEqualIID(iid, IID_IMarkupContainer2)) && PrimaryMarkup())
            {
                pvTearoff = PrimaryMarkup();
                apfnTearoff = (const void *)CMarkup::s_apfnIMarkupContainer2;
            }
            else if (IsEqualIID(iid, IID_IHTMLChangePlayback) && PrimaryMarkup())
            {
                pvTearoff = PrimaryMarkup();
                apfnTearoff = (const void *)CMarkup::s_apfnIHTMLChangePlayback;
            }
            else if (IsEqualIID(iid, IID_IMarkupTextFrags) && PrimaryMarkup())
            {
                pvTearoff = PrimaryMarkup();
                apfnTearoff = (const void *)CMarkup::s_apfnIMarkupTextFrags;
            }

            // Create the tearoff if we need to
            if (pvTearoff)
            {
                HRESULT hr;

                Assert(apfnTearoff);

                hr = THR(CreateTearOffThunk(
                        pvTearoff,
                        apfnTearoff, 
                        NULL, 
                        ppv, 
                        (IUnknown *) PunkOuter(), 
                        *(void **)(IUnknown *) PunkOuter(),
                        QI_MASK | (fCacheTearoff ? CACHEDTEAROFF_MASK : 0),
                        apIID,
                        appropdescsInVtblOrder));
                if (hr)
                    RRETURN(hr);

                if (fCacheTearoff)
                {
                    Assert(!_pCachedDocTearoff);
                    _pCachedDocTearoff = (IHTMLDocument2*) *ppv;
                }
            }
            else
            {
                RRETURN(CServer::PrivateQueryInterface(iid, ppv));
            }
        }
    }

Cleanup:
    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    DbgTrackItf(iid, "CDoc", FALSE, ppv);

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::RunningToLoaded
//
//  Synopsis:   Effects the running to loaded state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//  Notes:      This method stops all embeddings
//              in addition to normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::RunningToLoaded ( )
{
    TraceTag((tagCDoc, "%lx CDoc::RunningToLoaded", this));

    HRESULT         hr;
    CNotification   nf;

    hr = THR(CServer::RunningToLoaded());
    if (_fHasOleSite)
    {
        nf.DocStateChange1(PrimaryRoot(), (void *)OS_RUNNING);
        BroadcastNotify(&nf);
    }
    
    _view.Deactivate();

    // If we are the last CDoc left alive clean up the clipboard
    // We can't do this in DllThreadPassivate because COM is shut
    // down at that point
    {
        THREADSTATE * pts = GetThreadState();

        CTlsDocAry * paryDoc = &(pts->_paryDoc);
        int iDoc, nDoc, nRunning = 0;
        CDoc * pDoc;

        for (iDoc = 0, nDoc = paryDoc->Size(); iDoc < nDoc; iDoc++)
        {
            pDoc = paryDoc->Item(iDoc);
            Assert(pDoc);
            if (pDoc->State() > OS_LOADED)
            {
                nRunning++;
                break;
            }
        }

        if (nRunning==0)
        {
            FormClearClipboard(pts);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::HitTestPoint
//
//  Synopsis:   Find site at given position
//
//  Arguments   pt              The position.
//              ppSite          The site, can be null on return.
//              dwFlags         HT_xxx flags
//
//  Returns:    HTC
//
//----------------------------------------------------------------------------

HTC
CDoc::HitTestPoint(CMessage *pMessage,
                   CTreeNode ** ppNodeElement,
                   DWORD dwFlags)
{
    HTC         htc;
    CTreeNode * pNodeElement;

    Assert(pMessage);

    // Ensure that pointers are set for simple code down the line.

    if (ppNodeElement == NULL)
    {
        ppNodeElement = &pNodeElement;
    }


    htc = _view.HitTestPoint(
                        pMessage,
                        ppNodeElement,
                        dwFlags);

    TraceTag((tagDocHitTest, "HitTest (%d,%d) -> HTC: %d  pt: (%d,%d)%d  dn: %x  tn: %ls %x",
                pMessage->pt.x, pMessage->pt.y, htc,
                pMessage->ptContent.x, pMessage->ptContent.y, pMessage->coordinateSystem,
                pMessage->pDispNode,
                (*ppNodeElement ? (*ppNodeElement)->_pElement->TagName() : _T("") ),
                *ppNodeElement));

    return htc;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::Update, IOleObject
//
//  Synopsis:   Update object's view cache
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::Update()
{
    HRESULT         hr;

    hr = THR(super::Update());
    if (hr)
        goto Cleanup;

    if (_fHasOleSite)
    {
        CNotification   nf;

        nf.UpdateViewCache(PrimaryRoot());
        BroadcastNotify(&nf);
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::IsUpToDate, IOleObject
//
//  Synopsis:   Is view cache up to date?
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::IsUpToDate ( )
{
    HRESULT         hr;

    hr = THR(super::IsUpToDate());
    if (hr)
        goto Cleanup;

    if (_fHasOleSite)
    {
        CNotification   nf;
        
        nf.UpdateDocUptodate(PrimaryRoot());
        BroadcastNotify(&nf);
        hr = _fIsUpToDate ? S_OK : S_FALSE;
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::GetUserClassID
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the class id from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::GetUserClassID(CLSID FAR* pClsid)
{
    if (pClsid == NULL)
    {
        RRETURN(E_INVALIDARG);
    }

    if (!_fFullWindowEmbed)
        *pClsid = *BaseDesc()->_pclsid;
    else
        *pClsid = CLSID_HTMLPluginDocument;

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CDoc::Close, IOleObject
//
//  Synopsis:   Close this object
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::Close(DWORD dwSaveOption)
{
    HRESULT hr;

    Assert( !_fIsClosingOrClosed );
    _fIsClosingOrClosed = TRUE;

    if (dwSaveOption == OLECLOSE_NOSAVE)
        _fForceCurrentElem = TRUE;

    // Remove all the posted refresh messages (bug 59289)
    GWKillMethodCall(_pWindowPrimary, ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback), 0);

    hr = THR(super::Close(dwSaveOption));
    if (hr)
        goto Cleanup;

    if (_pWindowPrimary)
        _pWindowPrimary->Markup()->TearDownMarkup(FALSE);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::BroadcastNotify
//
//  Synopsis:   Broadcast this notification through the tree
//
//----------------------------------------------------------------------------

void
CDoc::BroadcastNotify(CNotification *pNF)
{
    Assert (pNF);
    Assert( pNF->Element() ); 
    
    CMarkup *   pMarkup = pNF->Element()->GetMarkup();

    if (pMarkup)
    {
        pMarkup->Notify(pNF);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetClientSite, IOleObject
//
//  Synopsis:   Overridden method so we can initialize our state from
//              ambient properties.
//
//  Arguments:  pClientSite    New client site.
//
//  Returns:    HRESULT obtained from CServer::SetClientSite
//
//  Notes:      Delegates to CServer::SetClientSite for the real work.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDoc::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    HRESULT hr;
    HRESULT hr2;
    IUnknown *          pIThumbNailView;
    IUnknown *          pIRenMailEditor = NULL;
    IUnknown *          pIHTMLEditorViewManager;
    IUnknown *          pUnkVid7Hack;
    IUnknown *          pUnkDefView;
    IUnknown *          pUnkActiveDesktop;
    IUnknown *          pUnkMarsPanel;
    IOleCommandTarget * pCommandTarget;

    // Do not set the client site to the same place more than once

    if (IsSameObject(pClientSite, _pClientSite))
        return S_OK;

    TraceTag((tagCDoc, "%lx CDoc::SetClientSite", this));

    //
    // We delay loading the resource dll until client site is set.
    //

    hr = THR(CServer::SetClientSite(pClientSite));
    if (!OK(hr))
        goto Cleanup;

    // If the client site implements IInternetSecurityManager (e.g. HTML dialogs)
    // we want calls to _pSecurityMgr to delegate to the client site.  Do this by
    // "re"setting the security site now that we've made the client site available
    // by hooking it up via CServer::SetClientSite() above.  NOTE: we deliberately
    // do NOT do this for _pPrintSecurityMgr -- that's the reason it's separate! (KTam)
    if (_pSecurityMgr)
    {
        hr = THR(_pSecurityMgr->SetSecuritySite(&_SecuritySite));
        if (hr)
            goto Cleanup;
    }
  
    // hook up design mode (bug 35089)
    PrimaryMarkup()->_fDesignMode = !_fUserMode;

    if (!_fUIHandlerSet)
    {
        SetHostUIHandler(pClientSite);

        // Cache DocHost flags.
        _dwFlagsHostInfo = 0;
    }

    if (pClientSite)
    {
        OnAmbientPropertyChange(DISPID_UNKNOWN);
    }

    // Get an option settings pointer from the registry, now that we have the
    //  client site
    hr = THR(UpdateFromRegistry());
    if(!OK(hr))
        goto Cleanup;

    if (_fInHTMLDlg)
    {
        // HTML dialogs are assumed to be encoded in cpDefault, and must use
        // a META tag to override this if desired.
        PrimaryMarkup()->SwitchCodePage(g_cpDefault);
    }

    if (pClientSite)
    {
        // AppHack (greglett) (108234)
        // HtmlHelp does something in the onafterprint event which results in a ProgressChange.
        // They then use this ProgressChange to do something that may result in a print.
        // Thus, multiple print dialogs appear until they crash.
        // This hack delays the onafterprint event for HtmlHelp until the template is closing.
        // If we rearchitect to remove this plumbing problem (events fired always, immediately),
        // then we should remove this hack.
        //
        // AppHack (gschneid) (21796)
        // Windows 2000 help is broken because they use the strict doctype switch but there document
        // is not a valid css document. More precisely they use measure specifications without unit 
        // specifier. The hack allows in chm (and only in chm[compressed html]) measure specs without
        // unit specifier.

        {
            IOleWindow *pOleWindow;                
            TCHAR acClass[10];
            HWND hwnd;
            hr2 = pClientSite->QueryInterface(IID_IOleWindow, (void**)&pOleWindow);
            if (SUCCEEDED(hr2))
            {
                hr2 = pOleWindow->GetWindow(&hwnd);
                if (SUCCEEDED(hr2)) {
                    for (;
                         hwnd && !g_fInHtmlHelp;
                         hwnd = GetParent(hwnd))
                    {
                        if (GetClassName(hwnd, acClass, 10) > 0)
                        {
                            g_fInHtmlHelp = (_tcsncmp(acClass, 9, _T("HH Parent"), 9) == 0);
                        }
                    }
                }
                ReleaseInterface(pOleWindow);
            }
        }

        void * pv;
        COleSite * pOleSite;

        // If we are hosted in an object tag, don't fire
        // the WebOC events.
        //
        hr2 = pClientSite->QueryInterface(CLSID_HTMLWindow2, &pv);
        if (S_OK == hr2)
        {
            _fDontFireWebOCEvents = TRUE;
            _fInObjectTag = TRUE;
        }

        IServiceProvider *  pSvcPrvdr;

        hr2 = pClientSite->QueryInterface(IID_IServiceProvider, (void**)&pSvcPrvdr);
        if (SUCCEEDED(hr2)) 
        {
            // If hosted in the object tag, inherit DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK
            // setting from the container.
            if (_fInObjectTag)
            {
                CObjectElement *pObjectElement = NULL;
                // This doesn't AddRef, see comment in COleSite::CClient::QueryService
                if (SUCCEEDED(pSvcPrvdr->QueryService(CLSID_HTMLObjectElement, 
                                CLSID_HTMLObjectElement, (void**)&pObjectElement)))
                {
                    if (pObjectElement->HasMarkupPtr())
                    {
                        CDoc *pDoc = NULL;
                        pDoc = pObjectElement->GetMarkupPtr()->Doc();
                        if (pDoc && (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK))
                            _dwFlagsHostInfo |= DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK;
                    }
                }
            }

            IUnknown *          pUnkTmp;

            hr2 = pSvcPrvdr->QueryService(SID_QIClientSite, IID_IAxWinHostWindow, (void**)&pUnkTmp);
            if (S_OK == hr2)
            {
                // we are being hosted by the WebOC which is hosted in an ATL app.
                _fATLHostingWebOC = TRUE;
                ReleaseInterface(pUnkTmp);
            }

            // Find out if we are a being viewlinked in the WebOC
            //
            hr2 = pSvcPrvdr->QueryService(CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, (void **) &pOleSite);
            if (S_OK == hr2)
            {
                _fViewLinkedInWebOC = TRUE;

                if (pOleSite->IsInMarkup())
                {
                    CMarkup * pMarkup = pOleSite->GetMarkup();

                    if (pMarkup->_fIsActiveDesktopComponent)
                        _fIsActiveDesktopComponent = TRUE;

                    if (pMarkup->HasWindowedMarkupContextPtr())
                        pMarkup = pMarkup->GetWindowedMarkupContextPtr();

                    //
                    // Calling GetWindowPending guarantees that we will get a proxy.
                    // If the frame that contains us is restricted, then this CDoc's primary
                    // window also has to be restricted.

                    Assert(pMarkup->GetWindowPending());
                    Assert(pMarkup->GetWindowPending()->Window());

                    _pWindowPrimary->Window()->_fRestricted = pMarkup->GetWindowPending()->Window()->_fRestricted;
                }
            }

            ReleaseInterface(pSvcPrvdr);
        }

        // Get the travel log - retrieve it once. (It shouldn't change.)
        //
        if (!_fScriptletDoc)
        {
            // Note, we need to call InitDocHost after _fViewLinkedInWebOC is set.
            InitDocHost();
        }
        
        // Determine if host is ThumbNailView
        if (OK(pClientSite->QueryInterface(IID_IThumbnailView,
                                            (void **)&pIThumbNailView)))
        {
            _fThumbNailView = TRUE;
            ReleaseInterface(pIThumbNailView);
        }

        // Determine if host is Outlook98
        if (OK( pClientSite->QueryInterface( IID_IRenMailEditor,
                                             (void **) & pIRenMailEditor)))
        {
            ClearInterface( & pIRenMailEditor );
            //
            // Host is Outlook, now see if it's Outlook2000 and greater, or Outlook98
            // NOTE (JHarding): This could be a problem in the future since we don't
            // actually use the interface to see what version we're in.
            //
            if (OK( pClientSite->QueryInterface( IID_IRenVersionCheck,
                                                 (void **) & pIRenMailEditor)))
            {
                pIRenMailEditor->Release();
                _fOutlook2000 = TRUE;
            }
            else
            {
                _fOutlook98 = TRUE;
            }
        }

        // Determine if host is VID
        if (OK(THR_NOTRACE(QueryService(
                SID_SHTMLEditorViewManager,
                IID_IHTMLEditorViewManager,
                (void**) &pIHTMLEditorViewManager))))
        {
            _fVID = TRUE;
            pIHTMLEditorViewManager->Release();
        }

        // Determine if host is VID7
        if (OK(THR_NOTRACE(QueryService(
                SID_SHTMEDDesignerHost,
                IID_IUnknown,
                (void**) &pUnkVid7Hack))))
        {
            _fVID7 = TRUE;
            pUnkVid7Hack->Release();
        }

        // Determine if hosted inside webview/defview.  
        if (OK(THR_NOTRACE(QueryService(
                SID_DefView,
                IID_IUnknown,
                (void**) &pUnkDefView))))
        {
            _fDefView = TRUE;
            pUnkDefView->Release();

            if (OK(THR_NOTRACE(QueryService(
                    SID_SShellDesktop,
                    IID_IUnknown,
                    (void**) &pUnkActiveDesktop))))
            {
                _fActiveDesktop = TRUE;
                pUnkActiveDesktop->Release();
            }
        }

        if (OK(THR_NOTRACE(QueryService(
                SID_SMarsPanel, 
                IID_IUnknown,
                (void **) &pUnkMarsPanel))))
        {
            _fInWindowsXP_HSS = TRUE;
            pUnkMarsPanel->Release();
        }

        // Determine if host listens to progress status text by QSing OLECMDID_SETPROGRESSTEXT

        _fProgressStatus = FALSE;
        
        // IE5 bug 59311: outlook 98 doesn't want progress status

        if (!_fOutlook98 && OK(THR_NOTRACE(_pClientSite->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget))))
        {
            OLECMD cmd;
            
            cmd.cmdID = OLECMDID_SETPROGRESSTEXT;
            cmd.cmdf = 0;
            
            if (OK(THR_NOTRACE(pCommandTarget->QueryStatus(NULL, 1, &cmd, NULL))))
            {
                if ((cmd.cmdf & (OLECMDF_ENABLED)) && !(cmd.cmdf & (OLECMDF_INVISIBLE)))
                    _fProgressStatus = TRUE;
            }
                
            ReleaseInterface(pCommandTarget);
        }

        // QS host for behavior factory

        ClearInterface(&_pHostPeerFactory);

        hr2 = THR_NOTRACE(QueryService(
            SID_SElementBehaviorFactory, IID_IElementBehaviorFactory, (void**)&_pHostPeerFactory));
        if (S_OK == hr2 && _pHostPeerFactory)
        {
            SetCssPeersPossible();
        }

        IHostBehaviorInit *pHostBehaviorInit;
        hr2 = THR(QueryService(IID_IHostBehaviorInit, IID_IHostBehaviorInit, (void**)&pHostBehaviorInit));
        if (S_OK == hr2)
        {
            Assert(pHostBehaviorInit);
            IGNORE_HR(pHostBehaviorInit->PopulateNamespaceTable());
            pHostBehaviorInit->Release();
        }

        RefreshStatusUI();
    }

    // TODO: Determine why clearing _pVersions is necessary 
    // with open in new Window with Netdocs
    if (_pVersions)
    {
        _pVersions->Release();
        _pVersions = NULL;
    }

    IGNORE_HR(QueryVersionHost());

Cleanup:
   
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::InitDocHost
//
//  Synopsis:   Sets flags and other info in the host.
//
//---------------------------------------------------------------

void
CDoc::InitDocHost()
{
    HRESULT  hr;

    Assert(!_pBrowserSvc);  // This method should be called only once.

    SetHostNavigation(FALSE);
    
    // Shdcovw-specific data
    //
    hr = THR(QueryService(SID_SShellBrowser, IID_IBrowserService, (void**)&_pBrowserSvc));
    if (hr)
        return;

    IGNORE_HR(_pBrowserSvc->QueryInterface(IID_IShellBrowser, (void**)&_pShellBrowser));

    IGNORE_HR(_pBrowserSvc->QueryInterface(IID_ITridentService, (void**)&_pTridentSvc));
        
    if (!_pTravelLog)
    {
        IGNORE_HR(_pBrowserSvc->GetTravelLog(&_pTravelLog));
    }

    Assert(NULL == _pTopWebOC);
    
    hr = QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**)&_pTopWebOC);

    // try to get to an outer object tag 
    
    if (SUCCEEDED(hr))
    {
        IOleObject *pOleObject = NULL;

        hr = _pTopWebOC->QueryInterface(IID_IOleObject, (void**)&pOleObject);

        if (SUCCEEDED(hr))
        {
            IOleClientSite *pOuterClientSite = NULL;
            hr = pOleObject->GetClientSite(&pOuterClientSite);
            if (SUCCEEDED(hr))
            {
                IServiceProvider *pSP = NULL;
                hr = pOuterClientSite->QueryInterface(IID_IServiceProvider, (void**)&pSP);
                if (SUCCEEDED(hr))
                {
                    CObjectElement * pObjectElement = NULL;

                    // This doesn't AddRef, see comment in COleSite::CClient::QueryService
                    pSP->QueryService(CLSID_HTMLObjectElement, CLSID_HTMLObjectElement, (void**)&pObjectElement);

                    if (pObjectElement != NULL)
                    {
                        _fInWebOCObjectTag = TRUE;
                    }
                    ReleaseInterface(pSP);
                }
                ReleaseInterface(pOuterClientSite);
            }
            ReleaseInterface(pOleObject);
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetHostNavigation
//
//  Synopsis:   Tells the host who should do the navigation. If 
//              fHostNavigates is TRUE, the host should do the 
//              navigation. Otherwise, we will.
//
//---------------------------------------------------------------

void 
CDoc::SetHostNavigation(BOOL fHostNavigates)
{
    HRESULT  hr;
    CVariant cvarWindow(VT_UNKNOWN);

    // Delegate navigation to host, if aggregated (#102173)
    if (!fHostNavigates && 
        (IsAggregated() || (_fMhtmlDoc && _fViewLinkedInWebOC) || _fIsActiveDesktopComponent))
    {
        fHostNavigates = TRUE;
    }

    if (fHostNavigates == (BOOL)_fHostNavigates)  // Optimization
    {
        goto Cleanup;
    }

    _fHostNavigates = fHostNavigates;
    
    if (!fHostNavigates)  // Trident does the navigation.
    {
        Assert(_pWindowPrimary);

        hr = _pWindowPrimary->QueryInterface(IID_IUnknown,
                                             (void**)&V_UNKNOWN(&cvarWindow));
        if (hr)
            goto Cleanup;
    }
    
    Assert(_pClientSite);
    IGNORE_HR(CTExec(_pClientSite,
                     &CGID_DocHostCmdPriv,
                     DOCHOST_DOCCANNAVIGATE,
                     NULL,
                     fHostNavigates ? NULL : &cvarWindow,
                     NULL));

Cleanup:
    return;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetHostUIHandler
//
//  Synopsis:   Set _pHostUIHandler by using a passed in client
//              site.
//
//  Returns:    HRESULT, always S_OK
//
//---------------------------------------------------------------
HRESULT
CDoc::SetHostUIHandler(IOleClientSite * pClientSite)
{
    HRESULT             hr = S_OK;

    // First off, get rid of the old interface
    ClearInterface(&_pHostUIHandler);

    if(!pClientSite)
        goto Cleanup;


    if(!OK(pClientSite->QueryInterface(IID_IDocHostUIHandler,
                                       (void **)&_pHostUIHandler)))
    {
        _pHostUIHandler = NULL;
    }
    else
    {
        if (!OK(_pHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                                (void**)&_pHostUICommandHandler)))
        _pHostUICommandHandler = NULL;
    }


Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EnsureBackupUIHandler
//
//  Synopsis:   Ensure our backup UI handler, or CoCreate one if needed.
//
//  Returns:    HRESULT, always S_OK
//
//---------------------------------------------------------------
HRESULT
CDoc::EnsureBackupUIHandler()
{
    HRESULT            hr = S_OK;

    if (_pBackupHostUIHandler)
        goto Cleanup;

    hr = THR(CoCreateInstance(CLSID_DocHostUIHandler,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDocHostUIHandler,
                              (void**)&_pBackupHostUIHandler));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetHostNames
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::SetHostNames(LPCTSTR lpstrCntrApp, LPCTSTR lpstrCntrObj)
{
    //  make copies of the new strings and hold on

    _cstrCntrApp.Set(lpstrCntrApp);

    // It's legal for the container object name to be NULL.

    _cstrCntrObj.Set(lpstrCntrObj);

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      returns cached moniker on the most recent
//              text file representation of the document;
//              fails if there is no such
//              The text file may be out of sync with actual
//              document
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppmk)
{
    HRESULT     hr = S_OK;

    if (!ppmk)
        RRETURN(E_POINTER);

    if (OLEGETMONIKER_UNASSIGN == dwAssign)
        RRETURN(E_INVALIDARG);

    *ppmk = NULL;

    switch (dwWhichMoniker)
    {
    case OLEWHICHMK_OBJFULL:

        if (PrimaryMarkup()->GetNonRefdMonikerPtr())
        {
            *ppmk = PrimaryMarkup()->GetNonRefdMonikerPtr();
            (*ppmk)->AddRef();
        }
        else
        {
            const TCHAR * pchUrl = GetPrimaryUrl();

            if (pchUrl)
            {
                hr = THR(CreateURLMoniker(NULL, pchUrl, ppmk));
            }
            else
            {
                Assert(0);
//              hr = THR(super::GetMoniker(dwAssign, dwWhichMoniker, ppmk));
            }
        }

        break;

    case OLEWHICHMK_CONTAINER:
    case OLEWHICHMK_OBJREL:

        hr = THR(super::GetMoniker(dwAssign, dwWhichMoniker, ppmk));

        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ParseDisplayName
//
//  Synopsis:   Method of IParseDisplayName interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::ParseDisplayName(LPBC pbc,
        LPTSTR lpszDisplayName,
        ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut)
{
    *ppmkOut = 0;
    *pchEaten = 0;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EnumObjects
//
//  Synopsis:   Method of IOleContainer interface
//
//---------------------------------------------------------------

DECLARE_CPtrAry(CDocEnumObjectsAry, IUnknown *, Mt(CDocEnumObjects_paryUnk), Mt(CDocEnumObjects_paryUnk_pv))

STDMETHODIMP
CDocument::EnumObjects(DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown)
{
    HRESULT             hr;
    CDocEnumObjectsAry *paryUnk = NULL;
    int                 i;
    int                 c;
    CElement          * pElement;
    CCollectionCache  * pCollectionCache;
    CMarkup *           pMarkup = Markup();

    // The defined flags are EMBEDDINGS, LINKS, OTHERS, ONLY_USER, and
    // RUNNING.  We only care about EMBEDDINGS and RUNNING.  Return an
    // enumerator for the site array with the appripriate filters.

    Assert(pMarkup);
    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if ( hr )
        goto Cleanup;

    pCollectionCache = pMarkup->CollectionCache();
    Assert(pCollectionCache);

    c = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    paryUnk = new CDocEnumObjectsAry;
    if (!paryUnk)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(paryUnk->EnsureSize(c));
    if (hr)
        goto Cleanup;

    // Copy the elements into an array.

    for (i = 0; i < c; i++)
    {
        Verify(!pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, i, &pElement));

        if (grfFlags & OLECONTF_EMBEDDINGS)
        {
            // Skip elements that are not OLE Sites

            // Add the element to the array if it
            // is a framesite or olesite element.
            //
            if (pElement->TestClassFlag(CElement::ELEMENTDESC_FRAMESITE) ||
                (pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE) &&
                   DYNCAST(COleSite, pElement)->PunkCtrl()))
            {
                pElement->AddRef();
                Verify(!paryUnk->Append((IUnknown*)pElement));
            }
        }

#if 0
        //
        // This code doesn't make too much sense anymore.  All olesites
        // pretty much always go into at least the running state.
        // (anandra) 04/07/98
        //

        if (grfFlags & OLECONTF_ONLYIFRUNNING)
        {
            // Skip elements that are not running.

            if (pElement->ShouldHaveLayout() && (S_OK != pElement->Notify(SN_ISATLEASTRUNNING, 0)))
                continue;
        }
#endif
    }

    // create an enumerator that:
    // - makes and maintains addrefs on its contained (IUnknown*)s
    // - allocates its own copy of the array of (IUnknown*)s
    // - deletes its array when it goes away

    hr = THR(paryUnk->EnumElements(IID_IEnumUnknown,
                (void **)ppenumUnknown, TRUE, FALSE, TRUE));
    if (hr)
        goto Cleanup;

    paryUnk = NULL;

Cleanup:

    if (paryUnk)
    {
        paryUnk->ReleaseAll();
        delete paryUnk;
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::LockContainer
//
//  Synopsis:   Method of IOleContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::LockContainer(BOOL fLock)
{
    TraceTag((tagCDoc, "%lx CDoc::LockContainer", this));

    //
    // When we support linking to embedded objects then we need to
    // implement this method.
    //
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::GetObject
//
//  Synopsis:   Method of IOleItemContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::GetObject(
        LPTSTR lpszItem,
        DWORD dwSpeedNeeded,
        LPBINDCTX pbc,
        REFIID iid,
        void ** ppv)
{
    *ppv = 0;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetObjectStorage
//
//  Synopsis:   Method of IOleItemContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::GetObjectStorage(
        LPTSTR lpszItem,
        LPBINDCTX pbc,
        REFIID iid,
        void ** ppvStorage)
{
    *ppvStorage = NULL;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsRunning
//
//  Synopsis:   Method of IOleItemContainer interface
//
//---------------------------------------------------------------

STDMETHODIMP
CDocument::IsRunning(LPTSTR lpszItem)
{
    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetCurrentElem
//
//  Synopsis:   Sets the current element - the element that is or will shortly
//              become UI Active. All keyboard messages and commands will
//              be routed to this element.
//
//  Notes:      Note that this function could be called AFTER _pElemCurrent
//              has been removed from the tree.
//
//  Callee:     If SetCurrentElem succeeds, then the callee should do anything
//              appropriate with gaining currency.  The callee must remember
//              that any action performed here must be cleaned up in
//              YieldCurrency.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetCurrentElem(CElement * pElemNext,
                     long       lSubNext,
                     BOOL *     pfYieldFailed,
                     LONG       lButton,
                     BOOL *     pfDisallowedByEd,
                     BOOL       fFireFocusBlurEvents,
                     BOOL       fMnemonic)
{
    HRESULT             hr              = S_OK;
    CElement *          pElemPrev       = _pElemCurrent;
    BOOL                fFireEvent;
    BOOL                fPrevDetached   = !(pElemPrev && pElemPrev->GetFirstBranch());
    CElement::CLock *   pLockPrev       = NULL;
    CTreeNode::CLock *  pNodeLockPrev   = NULL;
    CElement *          pElemNewDefault = NULL;
    CElement *          pElemOldDefault = NULL;
    long                lSubPrev        = _lSubCurrent;
    BOOL                fSameElem       = (pElemPrev == pElemNext);
    BOOL                fDirty          = FALSE;
    BOOL                fDisallowedByEd = FALSE;
    BOOL                fHasFocus       = HasFocus();
    EVENTINFO evtInfo;
    IHTMLEventObj* pEventObj = NULL ;  
    BOOL                fReleasepNode       = FALSE;
    BOOL                fReleasepNodeFrom   = FALSE;
    BOOL                fReleasepNodeTo     = FALSE;
    
    Assert(pElemNext);

    if (pfYieldFailed)
        *pfYieldFailed = FALSE;

    if( pfDisallowedByEd )
        *pfDisallowedByEd = FALSE;
        
    if (fSameElem && lSubNext == _lSubCurrent )
    {
        // Explicitly destroy the prev site-selection and set the caret
        // (#106326). This would have been done implicitly if the currency
        // really got changed and the editor got notified.

        if (fMnemonic && GetSelectionType() == SELECTION_TYPE_Control)
        {
            CMarkupPointer      ptrStart(this);
            IHTMLElement *      pIElement;

            Verify(S_OK == pElemNext->PrivateQueryInterface(IID_IHTMLElement, (void **)&pIElement));
            if (S_OK == ptrStart.MoveToContent(pIElement, TRUE))
            {
                IMarkupPointer *    pIStart = NULL;

                Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
                Verify(S_OK == Select(pIStart, pIStart, SELECTION_TYPE_Caret));
                pIStart->Release();
            }
            ReleaseInterface(pIElement);
        }

        return S_OK;
    }

    if (!pElemNext || !pElemNext->IsInMarkup())
        return S_FALSE;

    // Someone is trying to set currency to pElemNext from its own onfocus handler (#43161)!
    // Break this loop. Note that it is possible to be in pElemNext's onfocus handler
    // even though pElemNext is the current element.
    if (pElemNext->TestLock(CElement::ELEMENTLOCK_FOCUS))
        return S_OK;

    Assert(this == pElemNext->Doc());

    // We would simply assert here and leave it for the caller to ensure that
    // the element is enabled. Most often, the processing needs to stops way
    // before getting here if the element is disabled. Returning quietly here
    // instead of asserting would hide those bugs.
    Assert(pElemNext->IsEnabled());

    // Prevent attempts to delete the sites.

    Assert( pElemNext->GetFirstBranch() );

    CLock LockForm(this, FORMLOCK_CURRENT);


    if (!fPrevDetached)
    {
        pLockPrev = new CElement::CLock(pElemPrev, CElement::ELEMENTLOCK_DELETE);
        pNodeLockPrev = new CTreeNode::CLock;

        hr = THR( pNodeLockPrev->Init(pElemPrev->GetFirstBranch()) );
        if( hr )
            goto Cleanup;
    }

    {
        CElement::CLock     LockNext(pElemNext, CElement::ELEMENTLOCK_DELETE);
        CTreeNode::CLock    NodeLockNext;

        hr = THR( NodeLockNext.Init( pElemNext->GetFirstBranch() ) );
        if( hr )
            goto Cleanup;
    
        _pElemNext = pElemNext;

        // Fire onbeforedeactivate
        if (!fPrevDetached)
        {
    
            if (    !pElemPrev->Fire_ActivationHelper(lSubPrev, pElemNext, lSubNext, TRUE, TRUE, FALSE,
                                 ( _pIHTMLEditor || ShouldCreateHTMLEditor( EDITOR_NOTIFY_BEFORE_FOCUS, pElemNext )) 
                                 ?& evtInfo : NULL ) && !_fForceCurrentElem
                ||  !pElemNext->IsInMarkup()
                ||  _pElemNext != pElemNext)
            {
                if (pfYieldFailed)
                    *pfYieldFailed = TRUE;

                hr = S_FALSE;
                goto CanNotYield;
            }
        }

        {
            fFireEvent = !pElemPrev->TestLock(CElement::ELEMENTLOCK_UPDATE);
            CElement::CLock LockUpdate(pElemPrev, CElement::ELEMENTLOCK_UPDATE);

            if (fFireEvent && !fPrevDetached && !fSameElem)
            {
                hr = THR_NOTRACE(pElemPrev->RequestYieldCurrency(_fForceCurrentElem));
                // yield if currency changed to a different or the same element that is
                // going to become current.
                if (FAILED(hr) || _pElemNext != pElemNext || _pElemCurrent == pElemNext)
                    goto CanNotYield;
            }

            if (fMnemonic)
            {
                if (!fPrevDetached)
                {
                    pElemPrev->LostMnemonic(); // tell the element that it's losing focus due to a mnemonic
                }

                // Clear any site-selection (#95823)
                if (GetSelectionType() == SELECTION_TYPE_Control)
                {
                    DestroyAllSelection();
                }
            }

            // Give a chance to the editor to cancel/change currency
            if ( pElemNext->_etag != ETAG_ROOT &&
                 pElemNext->IsInMarkup()        )
            {                
                if ( evtInfo._pParam ) // true once we have an editor/ or should create one. 
                {
                    CEventObj::Create(&pEventObj, this, pElemPrev, NULL, FALSE, NULL, evtInfo._pParam);

                    if(evtInfo._pParam->_pNode)
                    {
                        hr = THR( evtInfo._pParam->_pNode->NodeAddRef() );
                        if( hr )
                            goto Cleanup;
                        fReleasepNode = TRUE;
                    }
                    if (evtInfo._pParam->_pNodeFrom)
                    {
                        hr = THR( evtInfo._pParam->_pNodeFrom->NodeAddRef() );
                        if( hr )
                            goto Cleanup;
                        fReleasepNodeFrom = TRUE;
                    }
                    if(evtInfo._pParam->_pNodeTo)
                    {
                        hr = THR( evtInfo._pParam->_pNodeTo->NodeAddRef() );
                        if( hr )
                            goto Cleanup;
                        fReleasepNodeTo = TRUE;
                    }

                    IUnknown* pUnknown = NULL;
                    IGNORE_HR( pEventObj->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
                        
                    fDisallowedByEd = (S_FALSE == NotifySelection( EDITOR_NOTIFY_BEFORE_FOCUS , pUnknown, lButton , pElemNext ));
                    ReleaseInterface( pUnknown );
                    if (pfDisallowedByEd)
                        *pfDisallowedByEd = fDisallowedByEd;            
                }            
            }

            if (fDisallowedByEd && !_fForceCurrentElem)
            {
                hr = S_FALSE;
                goto Done;
            }

            if (    !pElemNext->IsInMarkup()
                ||  _pElemNext != pElemNext)
            {
                hr = S_FALSE;
                goto CanNotYield;
            }

            // Fire onbeforeactivate
            if (    !pElemNext->Fire_ActivationHelper(lSubNext, pElemPrev, lSubPrev, TRUE, FALSE, FALSE, NULL) && !_fForceCurrentElem
                ||  !pElemNext->IsInMarkup()
                ||  _pElemNext != pElemNext)
            {
                hr = S_FALSE;
                goto Done;
            }

            // window onblur will be fired only if body was the current site
            // and we are not refreshing
            if (    !_fForceCurrentElem
                &&  fFireFocusBlurEvents
                &&  _pElemCurrent->IsInMarkup()
                &&  _pElemCurrent == _pElemCurrent->GetMarkup()->GetElementClient()
                &&  _pElemCurrent->GetMarkup()->HasWindow()
               )
            {
                _pElemCurrent->GetMarkup()->Window()->Post_onblur();
            }

            if (!fPrevDetached && !fSameElem)
            {
                fFireEvent = !pElemPrev->TestLock(CElement::ELEMENTLOCK_CHANGE);
                CElement::CLock LockChange(pElemPrev, CElement::ELEMENTLOCK_CHANGE);

                if (fFireEvent) // TODO: Why check for fFireEvent here?
                {
                    hr = THR_NOTRACE(pElemPrev->YieldCurrency(pElemNext));
                    if (hr)
                    {
                        if (pfYieldFailed)
                            *pfYieldFailed = TRUE;

                        goto Error;
                    }

                    // bail out if currency changed
                    if (_pElemNext != pElemNext)
                        goto Error;
               }
            }
        }

        // bail out if the elem to become current is no longer in the tree, due to some event code
        if (!pElemNext->IsInMarkup())
            goto Error;

        _pElemCurrent = pElemNext;
        _lSubCurrent = lSubNext;

        // Set focus to the current element
        if (State() >= OS_UIACTIVE && !_fPopupDoc)
        {
            _view.SetFocus(_pElemCurrent, _lSubCurrent);
        }

        _cCurrentElemChanges++;
        
        // Has currency been set in a non-trivial sense?
        if (!_fCurrencySet && _pElemCurrent->Tag() != ETAG_ROOT && _pElemCurrent->Tag() != ETAG_DEFAULT)
        {
            _fCurrencySet = TRUE;
            GWKillMethodCall(this, ONCALL_METHOD(CDoc, DeferSetCurrency, defersetcurrency), 0);
        }

        //
        // marka TODO. OnPropertyChange is dirtying the documnet
        // which is bad for editing clients (bugs 10161)
        // this will go away for beta2.
        //
        fDirty = !!_lDirtyVersion;
        {
            CMarkup * pMarkupNext = pElemNext->GetMarkup();

            if (pMarkupNext->HasDocument())
                IGNORE_HR(pMarkupNext->Document()->OnPropertyChange(DISPID_CDocument_activeElement, 
                                                                    FORMCHNG_NOINVAL, 
                                                                    (PROPERTYDESC *)&s_propdescCDocumentactiveElement));
        }
        if (    !fDirty
            &&  _lDirtyVersion)
        {
            _lDirtyVersion = 0;
        }

        // We fire the blur event AFTER we change the current site. This is
        // because if the onBlur event handler throws up a dialog box then
        // focus will go to the current site (which, if we donot change the
        // current site to be the new one, will still be the previous
        // site which has just yielded currency!).

        if (!fPrevDetached)
        {
            Assert(pElemPrev);
            Assert(pElemPrev != _pElemCurrent || lSubPrev != _lSubCurrent);
            pElemPrev->Fire_ActivationHelper(lSubPrev, _pElemCurrent, _lSubCurrent, FALSE, TRUE, fFireFocusBlurEvents && fHasFocus);
        }

        if (_pElemCurrent && 
            ( pElemPrev != _pElemCurrent || lSubPrev != _lSubCurrent ))
        {            
            _pElemCurrent->Fire_ActivationHelper(_lSubCurrent,
                                                   pElemPrev,
                                                   lSubPrev,
                                                   FALSE,
                                                   FALSE,
                                                   !_fDontFireOnFocusForOutlook98 && fFireFocusBlurEvents);
        }
    }

Cleanup:
    // if forcing, always change the current site as asked
    if (_fForceCurrentElem &&
        _pElemCurrent != pElemNext)
    {
        _pElemCurrent = pElemNext;
        IGNORE_HR(pElemNext->GetMarkup()->Document()->OnPropertyChange(DISPID_CDocument_activeElement, 
                                                                       0,
                                                                       (PROPERTYDESC *)&s_propdescCDocumentactiveElement));
        hr = S_OK;
    }

    if (pElemNext == _pElemCurrent)
    {
        if (!fSameElem)
        {
            // if the button is already the default or a button
            pElemNewDefault = _pElemCurrent->_fActsLikeButton
                                    ? _pElemCurrent
                                    : _pElemCurrent->FindDefaultElem(TRUE);

            if (    pElemNewDefault
                &&  !pElemNewDefault->_fDefault)
            {
                pElemNewDefault->SendNotification(NTYPE_AMBIENT_PROP_CHANGE, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                pElemNewDefault->_fDefault = TRUE;
                pElemNewDefault->Invalidate();
            }
        }
    }

    if (!fPrevDetached && (pElemPrev != _pElemCurrent))
    {
        // if the button is already the default or a button
        pElemOldDefault = pElemPrev->_fActsLikeButton
                                ? pElemPrev
                                : pElemPrev->FindDefaultElem(TRUE);

        if (    pElemOldDefault
            &&  pElemOldDefault != pElemNewDefault)
        {
            pElemOldDefault->SendNotification(NTYPE_AMBIENT_PROP_CHANGE, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
            pElemOldDefault->_fDefault = FALSE;
            pElemOldDefault->Invalidate();
       }
    }

Done:
    if (pLockPrev)
        delete pLockPrev;
    if (pNodeLockPrev)
        delete pNodeLockPrev;


    ReleaseInterface( pEventObj );  
    if ( pEventObj )
    {
        Assert( evtInfo._pParam);
        if ( evtInfo._pParam->_pNode && fReleasepNode )
        {
            evtInfo._pParam->_pNode->NodeRelease();
        }
        if ( evtInfo._pParam->_pNodeFrom && fReleasepNodeFrom )
        {
            evtInfo._pParam->_pNodeFrom->NodeRelease();
        }
        if ( evtInfo._pParam->_pNodeTo && fReleasepNodeTo )
        {
            evtInfo._pParam->_pNodeTo->NodeRelease();
        }        
    }

    RRETURN1(hr, S_FALSE);

CanNotYield:
    if (pfYieldFailed)
        *pfYieldFailed = TRUE;
    goto Done;

Error:
    hr = E_FAIL;
    goto Cleanup;
}

void BUGCALL
CDoc::DeferSetCurrency(DWORD_PTR dwContext)
{
    BOOL    fWaitParseDone = FALSE;

    // If the currency is already set, or we are not yet inplace active 
    // there is nothing to do... 
    if (_fCurrencySet || (State() < OS_INPLACE))
        return;

    // If we are in a dialog, or webview hosting scenario,
    // If parsing is done, then we can activate the first tabbable object.
    if (_fInHTMLDlg || !_fMsoDocMode
                    || (_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG))
    {
        if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
        {
            // Parsing is complete, we know which element is the current element, 
            // we can set that element to be the active element
            CElement *      pElement    = NULL;
            long            lSubNext    = 0;

            FindNextTabOrder(DIRECTION_FORWARD, FALSE, NULL, NULL, 0, &pElement, &lSubNext);
            if (pElement)
            {
                Assert(pElement->IsTabbable(lSubNext));

                // If we are not UI active yet, only set the current element,
                // do not try to activate and scroll in the element.
                // If we are UI active, then we can activate the current element
                // and scroll it into the view.
                if (State() < OS_UIACTIVE)
                {
                    // if the document is not UI Active, then we should not UI activate
                    // the olesite either. If the Olesite becomes UI active, it will force
                    // the containing document to go UI active too.
                    _fDontUIActivateOleSite = TRUE;

                    IGNORE_HR(pElement->BecomeCurrent(lSubNext, NULL, NULL));

                    // reset flag
                    _fDontUIActivateOleSite = FALSE;
                }
                else
                {
                    if (S_OK == pElement->BecomeCurrentAndActive(lSubNext))
                    {
                        IGNORE_HR(THR(pElement->ScrollIntoView()));
                        _fFirstTimeTab = FALSE;
                    }
                }
            }
        }
        else
        {
            // Parsing is not done yet. 
            fWaitParseDone = TRUE;
        }
    }

    // if the currency is not yet set, then make the element client the 
    // current element.
    if (!_fCurrencySet)
    {
        CMarkup  *  pMarkup     = _pElemCurrent ? _pElemCurrent->GetMarkup() : PrimaryMarkup();
        CElement *  pel         = CMarkup::GetElementTopHelper(pMarkup);
        BOOL        fTakeFocus  = (State() >= OS_UIACTIVE) && 
                                    _pInPlace->_fFrameActive;
    
        // 49336 - work around Outlook98 bug which interprets Element_onFocus
        // event that would get fired in the BecomeCurrent below as indication
        // that Trident window gains focus and turns on an internal flag to that
        // effect. The fix is to not fire this onFocus, when the window does
        // not have focus
        _fDontFireOnFocusForOutlook98 = (   _fOutlook98
                                         && !fTakeFocus
                                         && ::GetFocus() != _pInPlace->_hwnd);

        pel->BecomeCurrent(0, NULL, NULL, fTakeFocus);

        _fDontFireOnFocusForOutlook98 = FALSE;

        // If we are waiting for the parsing to be completed, we have to make sure 
        // that we think the currency is not set when we receive the parse done notification.
        // We will activate the first available object when we receive the parse done
        // notification.
        if (fWaitParseDone)
            _fCurrencySet = FALSE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetUIActiveElement
//
//  Synopsis:   UIActivate a given site, often as part of
//              IOleInPlaceSite::OnUIActivate
//
//---------------------------------------------------------------

HRESULT
CDoc::SetUIActiveElement(CElement *pElemNext)
{
    HRESULT     hr = S_OK;
    CElement *  pElemPrev = _pElemUIActive;
    BOOL        fPrevInDesignMode, fNextInDesignMode;

    // Bail out if we are deactivating from Inplace or UI Active.
    if (_pInPlace->_fDeactivating)
        goto Cleanup;

    Assert(!pElemNext || pElemNext->ShouldHaveLayout() || pElemNext->Tag() == ETAG_ROOT || pElemNext->Tag() == ETAG_DEFAULT);
    Assert(!pElemPrev || pElemPrev->ShouldHaveLayout() || pElemPrev->Tag() == ETAG_ROOT || pElemPrev->Tag() == ETAG_DEFAULT);

    if (pElemNext != pElemPrev)
    {
        _pElemUIActive = pElemNext;

        // Tell the old ui-active guy to remove it's ui.

        if (pElemPrev)
        {
            pElemPrev->YieldUI(pElemNext);

            if (pElemPrev->_fActsLikeButton)
            {
                CNotification   nf;

                nf.AmbientPropChange(pElemPrev, (void *)DISPID_AMBIENT_DISPLAYASDEFAULT);
                pElemPrev->_fDefault = FALSE;
                pElemPrev->Notify(&nf);
            }
        }
    }

    if (_state < OS_UIACTIVE)
    {
        // A site is trying to activate.  Tell CServer not to do any
        // menu or border stuff.

        Assert(!_pInPlace->_fChildActivating);
        _pInPlace->_fChildActivating = TRUE;

        // If an embedding is UI active, then the document must be UI active.

        if (TestLock(SERVERLOCK_TRANSITION))
        {
            // We arrived here because CDoc::InPlaceToUIActive is attempting
            // to UI activate one of its sites.  Since we are already in the
            // middle of CDoc::InPlaceToUIActive, all we need to is is call
            // CServer::InPlaceToUIActive to finish the work.
            hr = THR(CServer::InPlaceToUIActive(NULL));
        }
        else
        {
            // Do the normal transition to the UI active state.
            hr = THR(TransitionTo(OS_UIACTIVE, NULL));
        }

        _pInPlace->_fChildActivating = FALSE;

        if (hr)
            goto Cleanup;
    }
       
    fPrevInDesignMode = pElemPrev && pElemPrev->IsEditable(/*fCheckContainerOnly*/TRUE);
    if (fPrevInDesignMode)
    {
        // Erase the grab handles.

        if (    pElemPrev != PrimaryRoot()
            &&  pElemNext != pElemPrev && pElemPrev->ShouldHaveLayout())
        {
            pElemPrev->GetUpdatedLayout()->Invalidate();
        }
    }        
      
    fNextInDesignMode = pElemNext && pElemNext->IsEditable(/*fCheckContainerOnly*/TRUE);
    if (fNextInDesignMode)
    {
        // Erase the grab handles.

        if (pElemNext != PrimaryRoot() && pElemNext->ShouldHaveLayout())
        {
            pElemNext->GetUpdatedLayout()->Invalidate();        
        }
    }    

    if (fPrevInDesignMode || fNextInDesignMode)
    {
        // Notify selection change.
        if (!_pInPlace->_fDeactivating)
        {
            //
            //  Since we report the UI Active control as the contents of
            //  the selected collection, we need to update the property
            //  frame
            //

            IGNORE_HR(OnSelectChange());
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::DeferUpdateUI, DeferUpdateTitle, SetUpdateTimer
//
//  Synopsis:   Post a request to ourselves to update the UI.
//
//-------------------------------------------------------------------------

void
CDoc::DeferUpdateUI()
{
    TraceTag((tagUpdateUI, "CDoc::DeferUpdateUI"));

    _fNeedUpdateUI = TRUE;

    SetUpdateTimer();
}

void
CDoc::DeferUpdateTitle(CMarkup* pMarkup /*=NULL*/)
{
    if ( ! pMarkup )
    {
        pMarkup = PrimaryMarkup();
    }    
    if ( ! _fInObjectTag && ! _fViewLinkedInWebOC &&
         ! _fInWebOCObjectTag &&
         ( pMarkup->IsPrimaryMarkup() ||
           pMarkup->IsPendingPrimaryMarkup() ) )
    {
        TraceTag((tagUpdateUI, "CDoc::DeferUpdateTitle"));

        _fNeedUpdateTitle = TRUE;
        
        SetUpdateTimer();
    }
}

void
CDoc::SetUpdateTimer()
{
    // If called before we're inplace or have a window, just return.
    if (!_pInPlace || !_pInPlace->_hwnd)
        return;

    if (!_fUpdateUIPending)
    {
        _fUpdateUIPending = TRUE;
        SetTimer(_pInPlace->_hwnd, TIMER_DEFERUPDATEUI, 100, NULL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::OnUpdateUI
//
//  Synopsis:   Process UpdateUI message.
//
//-------------------------------------------------------------------------

void
CDoc::OnUpdateUI()
{
    IOleCommandTarget * pCommandTarget = NULL;

    TraceTag((tagUpdateUI, "CDoc::OnUpdateUI"));

    Assert(InPlace());

    KillTimer(_pInPlace->_hwnd, TIMER_DEFERUPDATEUI);
    _fUpdateUIPending = FALSE;

    if (_fNeedUpdateUI)
    {
        if (_pHostUIHandler)
        {
           _pHostUIHandler->UpdateUI();
        }

        Assert(_pClientSite);
        if (_pClientSite)
        {
            IGNORE_HR(_pClientSite->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget));
        }

        // update container UI.

        if (pCommandTarget)
        {
#ifndef NO_OLEUI
            // update menu/toolbar
            pCommandTarget->Exec(NULL, OLECMDID_UPDATECOMMANDS, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            pCommandTarget->Release();
#endif // NO_OLEUI
        }

        _fNeedUpdateUI = FALSE;
    }

    if (_fNeedUpdateTitle)
    {
        UpdateTitle();
    }
}

void
CDoc::UpdateTitle(CMarkup * pMarkup /* = NULL */)
{
    VARIANTARG var;
    IOleCommandTarget * pCommandTarget = NULL;
    TCHAR szBuf[1024];
    TCHAR achUrl[pdlUrlLen + sizeof(DWORD)/sizeof(TCHAR)];
    DWORD cchUrl;
    HRESULT hr;
    CStr cstrFile;

    TraceTag((tagUpdateUI, "CDoc::UpdateTitle"));

    if (!_pClientSite || (_fDefView && !_fActiveDesktop))
    {
        return;
    }

    hr = _pClientSite->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);
    if (hr)
        goto Cleanup;

    // update title
    var.vt      = VT_BSTR;
    if (PrimaryMarkup()->GetTitleElement() && 
        PrimaryMarkup()->GetTitleElement()->Length())
    {
        var.bstrVal = PrimaryMarkup()->GetTitleElement()->GetTitle();
    }
    else
    {
        const TCHAR * pchUrl = GetPrimaryUrl();

        if (pchUrl && GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
        {
            TCHAR achFile[MAX_PATH];
            ULONG cchFile = ARRAY_SIZE(achFile);

            hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
            if (hr)
                goto Cleanup;

            hr = THR(cstrFile.Set(achFile)); // need memory format of a BSTR
            if (hr)
                goto Cleanup;

            var.bstrVal = cstrFile;
        }
        else if (pchUrl && !DesignMode())
        {
            // need to unescape the url when setting title

            if (S_OK == CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0,
                                           achUrl + sizeof(DWORD) / sizeof(TCHAR),
                                           ARRAY_SIZE(achUrl) - sizeof(DWORD) / sizeof(TCHAR),
                                           &cchUrl, 0))
            {
                var.bstrVal = achUrl + sizeof(DWORD) / sizeof(TCHAR);
            }
            else
            {
                var.bstrVal = (TCHAR*) pchUrl;
            }

            *(DWORD *)achUrl = _tcslen(V_BSTR(&var)); 

        }
        else
        {
            *((DWORD *)szBuf)=LoadString(GetResourceHInst(),
                                         IDS_NULL_TITLE,
                                         szBuf+sizeof(DWORD)/sizeof(TCHAR),
                                         ARRAY_SIZE(szBuf) -
                                             sizeof(DWORD) / sizeof(TCHAR));
            Assert(*((DWORD *)szBuf) != 0);
            var.bstrVal = szBuf + sizeof(DWORD) / sizeof(TCHAR);
        }
    }

    pCommandTarget->Exec(
            NULL,
            OLECMDID_SETTITLE,
            MSOCMDEXECOPT_DONTPROMPTUSER,
            &var,
            NULL);

    TraceTag((tagUpdateUI, "CDoc::UpdateTitle to \"%ls\"", var.bstrVal));

    // Fire the WebOC TitleChange event.
    //
    if (pMarkup)
    {
        _webOCEvents.FrameTitleChange(pMarkup->Window());
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    _fNeedUpdateTitle = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetDocCoords, IMarqueeInfo
//
//  Synopsis:   Returns the size information anbout the current doc. This method is
//              called only when the mshtml is hosted inside the marquee control.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::GetDocCoords(LPRECT pViewRect, BOOL bGetOnlyIfFullyLoaded, BOOL *pfFullyLoaded, int WidthToFormatPageTo)
{
    HRESULT     hr     = S_OK;
    SIZE        lsize;
    CSize       size;
    CMarkup *   pMarkup = PrimaryMarkup();
    BOOL        fReady = (pMarkup->GetReadyState() == READYSTATE_COMPLETE);
    CElement *  pElement = CMarkup::GetCanvasElementHelper(pMarkup);

    // Marquee control should support doc host interface, but it does not.
    // Fix things up for it.
    _dwFlagsHostInfo  |= DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_SCROLL_NO;

    *pfFullyLoaded = fReady;

    pViewRect->left   =
    pViewRect->top    =
    pViewRect->right  =
    pViewRect->bottom = 0;

    if (bGetOnlyIfFullyLoaded && !fReady)
        return S_FALSE;

    if (!pMarkup ||
        !pMarkup->GetElementClient() || 
        pMarkup->GetElementClient() == PrimaryRoot())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(pElement);
    //
    // Make sure that document is at least running, otherwise CalcSize will assert.
    //

    if (State() < OS_RUNNING)
    {
        hr = THR(TransitionTo(OS_RUNNING, NULL));
        if (hr)
            goto Cleanup;
    }

    if (_view.IsActive())
    {
        _view.Activate();
        _view.SetFlag(CView::VF_FULLSIZE);
    }

    size.cx = WidthToFormatPageTo;
    size.cy = 0;

    // No scrollbars wanted inside the marquee ocx.
    if (!(pMarkup->GetFrameOptions() & FRAMEOPTIONS_SCROLL_NO))
    {
        CElement * pBody = CMarkup::GetElementClientHelper(pMarkup);

        pMarkup->SetFrameOptions(FRAMEOPTIONS_SCROLL_NO);

        // Suppress scrollbar only if doc has a body (no frameset).
        if (pBody && pBody->Tag() == ETAG_BODY)
        {
            IGNORE_HR(pElement->OnPropertyChange(DISPID_A_SCROLL, 
                                                 ELEMCHNG_SIZECHANGED, 
                                                 (PROPERTYDESC *)&s_propdescCBodyElementscroll) );
        }
    }

    _view.SetViewSize(size);
    _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_FORCE);

    if (pElement)
    {
        pElement->GetUpdatedLayout()->GetContentSize(&size, FALSE);
    }

    //
    // Ensure size is a safe minimum and convert to HIMETRIC
    //
    size.Max(CSize(WidthToFormatPageTo,1));
    lsize.cx = HimetricFromHPix(size.cx);       //  Screen device Xform.
    lsize.cy = HimetricFromVPix(size.cy);
    
    //  TODO (greglett) Do we need to update the measuring device on the view here?
    CServer::SetExtent(DVASPECT_CONTENT, &lsize);

    pViewRect->right  = size.cx;
    pViewRect->bottom = size.cy;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetGenericParse, IXMLGenericParse
//
//  Synopsis:   If true, throws tokenizer and stylesheet selector parser into a mode
//              where all unqualified tags are treated as generic tags and real
//              html tags must be prefaced by html: namespace
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetGenericParse(VARIANT_BOOL fDoGeneric)
{
    if (!PrimaryMarkup())
        return E_FAIL;
    PrimaryMarkup()->SetXML(fDoGeneric == VARIANT_TRUE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureHostStyleSheets
//
//  Synopsis:   Ensure the document's stylesheets collection exists, and create it if not
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureHostStyleSheets()
{
    CStyleSheet *   pSS = NULL;
    HRESULT         hr = S_OK;
    
    if (_pHostStyleSheets || !_cstrHostCss)
        return S_OK;

    _pHostStyleSheets = new CStyleSheetArray(this, NULL, 0);
    if (!_pHostStyleSheets || _pHostStyleSheets->_fInvalid)
        return E_OUTOFMEMORY;

    hr = THR(_pHostStyleSheets->CreateNewStyleSheet(NULL, &pSS));
    if (!SUCCEEDED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE);  // cannot be using predownloaded version...
    hr = S_OK;

    {
        CCSSParser  cssparser(pSS, NULL, PrimaryMarkup()->IsXML(), PrimaryMarkup()->IsStrictCSS1Document());

        cssparser.Write(_cstrHostCss, lstrlen(_cstrHostCss));

        cssparser.Close();
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PreSetErrorInfo
//
//  Synopsis:   Update the UI whenever the form is returned from.
//
//----------------------------------------------------------------------------

void
CDoc::PreSetErrorInfo()
{
    super::PreSetErrorInfo();

    DeferUpdateUI();
}

//+------------------------------------------------------------------------
//
//  Member:     CreateDoc
//
//  Synopsis:   Creates a new doc instance.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase * STDMETHODCALLTYPE
CreateDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateDoc");
    pBase = new CDoc(pUnkOuter);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateDoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateMhtmlDoc
//
//  Synopsis:   Creates a new MHTML doc instance.  This is identical to
//              a regular doc instance, except that IPersistMoniker::Load
//              first needs to convert the moniker to one that points
//              to actual HTML.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreateMhtmlDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateMhtmlDoc");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_MHTML);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateMhtmlDoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateHTADoc
//
//  Synopsis:   Creates a new doc instance.  This version creates a doc
//              set up to understand HTA behavior
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreateHTADoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateHTADoc");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_HTA);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateHTADoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreatePopupDoc
//
//  Synopsis:   Creates a new doc instance.  This version creates a doc
//              set up to understand Popup window behavior
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreatePopupDoc(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreatePopupDoc");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_POPUP);
    PerfDbgLog(tagPerfWatch, NULL, "-CreatePopupDoc");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateDocFullWindowEmbed
//
//  Synopsis:   Creates a new doc instance.  This version creates a doc
//              set up to perform the implicit full-window-embed support
//              for a URL referencing a plugin handled object.
//
//  Arguments:  pUnkOuter   Outer unknown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

CBase *
CreateDocFullWindowEmbed(IUnknown * pUnkOuter)
{
    CBase * pBase;
    PerfDbgLog(tagPerfWatch, NULL, "+CreateDocFullWindowEmbed");
    pBase = new CDoc(pUnkOuter, CDoc::DOCTYPE_FULLWINDOWEMBED);
    PerfDbgLog(tagPerfWatch, NULL, "-CreateDocFullWindowEmbed");
    return(pBase);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetClassDesc, CBase
//
//  Synopsis:   Return the class descriptor.
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC *
CDoc::GetClassDesc() const
{
    return (CBase::CLASSDESC *)&s_classdesc;
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::SetReadyState
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::SetReadyState(long readyState)
{
    HRESULT hr = S_OK;
    
    if (GetReadyState() != readyState)
    {
        if (readyState < GetReadyState())
            goto Cleanup;

        PerfLog2(tagGasGauge, this, "%d 0 0 %ls", 100 + readyState, Url() ? Url() : _T(""));
        PerfDbgLog1(tagPerfWatch, this, "+CDoc::SetReadyState %s",
            readyState == READYSTATE_LOADING ? "LOADING" :
            readyState == READYSTATE_LOADED ? "LOADED" :
            readyState == READYSTATE_INTERACTIVE ? "INTERACTIVE" :
            readyState == READYSTATE_COMPLETE ? "COMPLETE" : "(Unknown)");

        hr = SetAAreadystate(readyState);
        if (hr)
            goto Cleanup;

        if (readyState == READYSTATE_COMPLETE)
        {
            if (Doc()->_fNeedUpdateTitle)
            {
                PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (UpdateTitle)");
                Doc()->UpdateTitle(this);
            }

            if (Doc()->_pDSL)
            {
                PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (_pDSL->dataMemberChanged())");
                Doc()->_pDSL->dataMemberChanged(_T(""));
            }

            if (   g_fInMSWorksCalender
                && GetUrlScheme(Url()) == URL_SCHEME_FILE )
            {
                if (!IsPrimaryMarkup() && !_fLoadingHistory)
                {
                    _pDoc->_webOCEvents.FireDownloadEvents(Window(),
                                                           CWebOCEvents::eFireDownloadComplete);
                }

                _pDoc->_webOCEvents.NavigateComplete2(Window());
            }
        }

        if (HasWindowPending())
        {
            COmWindowProxy *pOmWindow = GetWindowPending();

            if (!(    g_fInMSWorksCalender
                  &&  NULL == _tcsicmp(_T("about:Microsoft%20Works%20HTML%20Print%20Services"), Url())))
            {
                if (pOmWindow->Window()->_pMarkupPending &&
                    readyState == READYSTATE_LOADING &&
                    pOmWindow->Window()->_pMarkup->_LoadStatus == LOADSTATUS_DONE)
                {
                    Assert(pOmWindow->Window()->_pMarkupPending == this);
                    _fDelayFiringOnRSCLoading = TRUE;
                }
                else
                {
                    PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (FirePropertyNotify)");
                    pOmWindow->Document()->FirePropertyNotify(DISPID_READYSTATE, TRUE);

                    PerfDbgLog(tagPerfWatch, this, "CDoc::SetReadyState (Fire_onreadystatechange)");
                    pOmWindow->Document()->Fire_onreadystatechange();
                }
            }
        }

        PerfDbgLog(tagPerfWatch, this, "-CDoc::SetReadyState");
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetSpin
//
//  Synopsis:   Sets the animation state (the spinny globe)
//
//  Arguments:  fSpin: TRUE to spin the globe, FALSE to stop it
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
void
CDoc::SetSpin(BOOL fSpin)
{
    if (!!_fSpin != !!fSpin)
    {
        _fSpin = ENSURE_BOOL(fSpin);
        _fShownSpin = FALSE;

        UpdateLoadStatusUI();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetProgress
//
//  Synopsis:   Sets the position of the progress text+thermometer.
//
//  Arguments:  pchStatusText:  progress string, can be NULL
//              ulProgress:     less than or equal to ulProgressMax
//              ulProgressMax:  if zero, hides the thermometer
//              fFlash:         if TRUE, progress is cleared next time
//                              a SetStatusText string is shown
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetProgress(DWORD dwFlags, TCHAR *pchText, ULONG ulPos, ULONG ulMax, BOOL fFlash)
{
    HRESULT hr;

    if (dwFlags & PROGSINK_SET_TEXT)
    {
        hr = THR(_acstrStatus[STL_PROGSTATUS].Set(pchText));
        if (hr)
            goto Cleanup;

        if (_iStatusTop >= STL_PROGSTATUS)
        {
            _iStatusTop = (pchText && *pchText) ? STL_PROGSTATUS : STL_LAYERS;
            _fShownProgText = FALSE;
        }
    }

    if (    (dwFlags & PROGSINK_SET_MAX)
        &&  _ulProgressMax != ulMax)
    {
        _ulProgressMax = ulMax;
        _fShownProgMax = FALSE;
    }

    if (    (dwFlags & PROGSINK_SET_POS)
        &&  _ulProgressPos != ulPos)
    {
        _ulProgressPos = ulPos;
        _fShownProgPos = FALSE;
    }

    _fProgressFlash = fFlash;

    hr = THR(UpdateLoadStatusUI());

Cleanup:
    RRETURN(hr);
}

COmWindowProxy*
CDoc::GetCurrentWindow()
{
    COmWindowProxy * pWindow = NULL;

    if (_pElemCurrent && _pElemCurrent->IsInMarkup())
    {
        CMarkup * pMarkup = _pElemCurrent->GetMarkup()->GetFrameOrPrimaryMarkup();

        if (pMarkup)
        {
            pWindow = pMarkup->Window();
        }
    }
    if (!pWindow)
    {
        pWindow = _pWindowPrimary;
        Assert(pWindow);
    }
    return pWindow;
}

void
CDoc::SetFocusWithoutFiringOnfocus()
{
    if (_fPopupDoc || _fIsPrintWithNoUI)
        return;

    COmWindowProxy *    pWindow                 = GetCurrentWindow();
    BOOL                fOldFiredWindowFocus    = pWindow->_fFiredWindowFocus;
    BOOL                fInhibitFocusFiring     = _fInhibitFocusFiring;

    // Do not fire window onfocus if the inplace window didn't
    // previously have the focus (NS compat)
    if (fInhibitFocusFiring)
        pWindow->_fFiredWindowFocus = TRUE;

    if (RequestFocusFromServer())
        ::SetFocus(_pInPlace->_hwnd);

    // restore the old FiredFocus state
    if (fInhibitFocusFiring)
        pWindow->_fFiredWindowFocus = fOldFiredWindowFocus;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetStatusText
//
//  Synopsis:   Sets status text, remembering it if not in-place active.
//              Passing NULL clears status text.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetStatusText(TCHAR * pchStatusText, LONG statusLayer, CMarkup * pMarkup /* = NULL */)
{
    HRESULT hr = S_OK;
    
    // _fProgressFlash means that next time we have real status to show,
    // the progress text should be cleared (used for "Done"). So if we have
    // real status, clear progress.

    if (_fProgressFlash && pchStatusText && *pchStatusText)
    {
        SetProgress(PROGSINK_SET_TEXT | PROGSINK_SET_POS | PROGSINK_SET_MAX, NULL, 0, 0);
        _fProgressFlash = FALSE;
    }

    // NS compat: after window.defaultStatus has been set, the behavior changes
    if (statusLayer == STL_DEFSTATUS)
        _fSeenDefaultStatus = TRUE;
        
    LONG c;
    CStr *pcstr;

    hr = THR(_acstrStatus[statusLayer].Set(pchStatusText));
    if (hr)
        goto Cleanup;
        
    // Figure out what should be showing on the status bar (_iStatusTop):
    if (pchStatusText && *pchStatusText)
    {
        // NS compat: when nonempty, rollstatus, status, or defaultStatus go directly to the status bar
        // (For NS compat examples, see IE5 bug 65272, 65880)
        
        if (_iStatusTop >= statusLayer || statusLayer <= STL_DEFSTATUS)
        {
            _iStatusTop = statusLayer;
            UpdateStatusText();
        }
    }
    else
    {
        // NS compat: when clearing rollstatus, status, or default status, status bar will show:
        // window.status or lower layers if .defaultStatus has never been set or
        // window.defaultStatus or lower layers if .defaultStatus has been set.
        
        if (_iStatusTop <= statusLayer || statusLayer <= STL_DEFSTATUS)
        {
            LONG startLayer;

            startLayer = (_fSeenDefaultStatus ? STL_DEFSTATUS : STL_TOPSTATUS);
            for (pcstr = _acstrStatus + startLayer, c = STL_LAYERS - startLayer; c; pcstr += 1, c -= 1)
            {
                if (*pcstr && **pcstr)
                    break;
            }

            _iStatusTop = pcstr - _acstrStatus;
            UpdateStatusText();
        }
    }

    if (pMarkup)
    {
        _webOCEvents.FrameStatusTextChange(pMarkup->Window(), pchStatusText);
    }


Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateStatusText
//
//  Synopsis:   Sets status text, remembering it if not in-place active.
//              Passing NULL clears status text.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::UpdateStatusText()
{
    HRESULT hr = S_OK;
    
    if (_pInPlace && _pInPlace->_pFrame)
    {
        TCHAR *pchStatusText;

        // IE5 59311: don't report progress text to Outlook 98

        if (_iStatusTop < STL_LAYERS && (_fProgressStatus || _iStatusTop < STL_PROGSTATUS))
            pchStatusText = _acstrStatus[_iStatusTop];
        else
            pchStatusText = NULL;
        
        hr = THR(_pInPlace->_pFrame->SetStatusText(pchStatusText));
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::RefreshStatusUI
//
//  Synopsis:   Causes all status UI to be refreshed; used when becoming
//              in-place active.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
void
CDoc::RefreshStatusUI()
{
    _fShownProgPos  = FALSE;
    _fShownProgMax  = FALSE;
    _fShownProgText = FALSE;

    _fShownSpin     = !_fSpin;
    UpdateLoadStatusUI();
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::UpdateStatusUI
//
//  Synopsis:   Updates status text, progress text, progress thermometer,
//              and spinning globe of client.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::UpdateLoadStatusUI()
{
    IOleCommandTarget * pCommandTarget;
    HRESULT hr = S_OK;

    if (_pClientSite)
    {
        VARIANTARG var;

        hr = THR_NOTRACE(_pClientSite->QueryInterface(
                IID_IOleCommandTarget,
                (void **)&pCommandTarget));
        if (hr)
            goto Cleanup;

        if (!_fShownProgText)
        {
            THR_NOTRACE(UpdateStatusText());
            _fShownProgText = TRUE;
        }

        if (!_fShownProgMax)
        {
            var.vt = VT_I4;
            var.lVal = _ulProgressMax;
            pCommandTarget->Exec(NULL, OLECMDID_SETPROGRESSMAX,
                MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            _fShownProgMax = TRUE;
        }

        if (!_fShownProgPos)
        {
            var.vt = VT_I4;
            var.lVal = _ulProgressPos;
            pCommandTarget->Exec(NULL, OLECMDID_SETPROGRESSPOS,
                MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            _fShownProgPos = TRUE;
        }

        if (!_fShownSpin)
        {
            var.vt = VT_I4;
            var.lVal = _fSpin;
            pCommandTarget->Exec(NULL, OLECMDID_SETDOWNLOADSTATE,
                    MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL);
            _fShownSpin = TRUE;
        }

        pCommandTarget->Release();
    }

Cleanup:
    RRETURN(hr);
}


//+--------------------------------------------------------------
//
//  Member:     CDoc::HandleKeyNavigate
//
//  Synopsis:   Navigate to the next CSite/CElement that can take focus
//              based on the message.
//
//---------------------------------------------------------------

HRESULT
CDoc::HandleKeyNavigate(CMessage * pmsg, BOOL fAccessKeyNeedCycle)
{
    HRESULT         hr       = S_FALSE;
    FOCUS_DIRECTION dir = (pmsg->dwKeyState & FSHIFT) ?
                            DIRECTION_BACKWARD: DIRECTION_FORWARD;
    CElement *      pCurrent = NULL;
    CElement *      pNext = NULL;
    CElement *      pStart = NULL;
    long            lSubNew = _lSubCurrent;
    BOOL            fFindNext = FALSE;
    BOOL            fAccessKey = !(IsTabKey(pmsg) || IsFrameTabKey(pmsg));
    CElement *      pElementClient = CMarkup::GetElementClientHelper(PrimaryMarkup());
    unsigned        cCurrentElemChangesOld;

    // It is possible to have site selection even at browse time, if the user
    // is tabbing in an editable container such as HTMLAREA.
    BOOL            fSiteSelected   = (GetSelectionType() == SELECTION_TYPE_Control);
    BOOL            fSiteSelectMode = ((_pElemCurrent && _pElemCurrent->IsEditable(/*fCheckContainerOnly*/TRUE)) || fSiteSelected);
    BOOL            fYieldFailed    = FALSE;

    if (!pElementClient)
    {
        hr = S_FALSE;
        goto Cleanup;
    }   

    // FrameTab key is used to tab among frames. If this is not a frameset,
    // the usual thing to do is to pass up the message so that it goes to the
    // parent frameset document. However, if pmsg->lParam == 0, then it means
    // that pmsg is passed down from the parent document's CFrameSite, so
    // _pElemClient is activated.
    if (pElementClient->Tag() != ETAG_FRAMESET && IsFrameTabKey(pmsg))
    {
        if (pmsg->lParam)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = THR(pElementClient->BecomeCurrentAndActive(pmsg->lSubDivision, NULL, pmsg, TRUE));
        }
        goto Cleanup;
    }

    //
    // Detect time when this is the first time tabbing into the doc
    // and bail out in that case.  Let the shell take focus.
    //

    if (_fFirstTimeTab)
    {
        // This bit should only be set under certain circumstances.
        hr = S_FALSE;
        _fFirstTimeTab = FALSE;
        goto Cleanup;
    }

    //
    // First find the element from which to start
    //

    if ((!fSiteSelectMode && _pElemCurrent == PrimaryRoot()) ||
        (fAccessKeyNeedCycle && pmsg->message == WM_SYSKEYDOWN) ||
        (IsTabKey(pmsg) && !pmsg->lParam))
    {
        if ((IsTabKey(pmsg)) && (!pmsg->lParam) && (DIRECTION_FORWARD == dir))
        {
            // Raid 61972
            // we just tab down to a frame CBodyElement, need to set the flag
            // so we know we need to tab out when SHIFT+_TAB
            //
            _fNeedTabOut = TRUE;
        }
        pStart = NULL;
        fFindNext = TRUE;
    }
    else if (!fSiteSelectMode && _pElemCurrent->IsTabbable(_lSubCurrent))
    {
        pStart = _pElemCurrent;
        fFindNext = TRUE;
    }
    else if (_pElemCurrent->Tag() != ETAG_ROOT)
    {
        // Tab to the element next to the caret/selection (unless the root element is
        // current - bug #65023)
        //
        // marka - don't force create the editor. Only do the below if we have an editor already.
        //
        IHTMLEditor*    pEditor     = GetHTMLEditor(FALSE);
        CElement *      pElemStart  = NULL;

        if ( pEditor && ((_pCaret && _pCaret->IsVisible() ) || // if caret visible 
                         (GetSelectionType() == SELECTION_TYPE_Text)   || 
                         (GetSelectionType() == SELECTION_TYPE_Control) )  // there is selection, then follow this route
           )
        {
            IHTMLElement *  pIElement   = NULL;
            BOOL            fNext       = TRUE;

            Assert(pEditor);
            if ( pEditor && S_OK == pEditor->GetElementToTabFrom( dir == DIRECTION_FORWARD, &pIElement, &fNext)
                &&  pIElement)
            {
                Verify(S_OK == pIElement->QueryInterface(CLSID_CElement, ( void**) & pElemStart));
                Assert(pElemStart);

                if (pElemStart->HasMasterPtr())
                {
                    pElemStart = pElemStart->GetMasterPtr();
                }
                if (pElemStart)
                {
                    pStart = pElemStart;
                    fFindNext = (   fNext 
                                 || !fAccessKey && !pStart->IsTabbable(_lSubCurrent)
                                 || fAccessKey && !pStart->MatchAccessKey(pmsg, 0)
                                );

                    if (!fFindNext)
                    {
                        pCurrent = pStart;
                    }
                }
                pIElement->Release();
            }
        }
        
        if (!pElemStart)
        {
            pStart = _pElemCurrent;
            fFindNext = TRUE;
        }
    }
    else
    {
        pStart = NULL;
        fFindNext = TRUE;
    }

    if (pStart && pStart == pElementClient && !pStart->IsTabbable(_lSubCurrent))
    {
        pStart = NULL;
    }

    if (fFindNext)
    {
        Assert(!pCurrent);
        FindNextTabOrder(dir, fAccessKey, pmsg, pStart, _lSubCurrent, &pCurrent, &lSubNew);
    }

    hr = S_FALSE;
    if (!pCurrent)
        goto Cleanup;

    // This better not be FrameTab unless the doc is a frameset doc.
    Assert (pElementClient->Tag() == ETAG_FRAMESET || !IsFrameTabKey(pmsg));

    cCurrentElemChangesOld = _cCurrentElemChanges;
    if (!fAccessKey)
    {
        do
        {
            if (pNext)
            {
                pCurrent = pNext;
            }

            pmsg->lSubDivision = lSubNew;

            // Raid 61972
            // Set _fNeedTabOut if pCurrent is a CBodyElement so that we will
            // not try to SHIFT+TAB to CBodyElement again.
            //
            _fNeedTabOut = (!pCurrent->IsEditable(/*fCheckContainerOnly*/FALSE) && (pCurrent->Tag() == ETAG_BODY))
                         ? TRUE : FALSE;

            hr = THR_NOTRACE(pCurrent->HandleMnemonic(pmsg, FALSE, &fYieldFailed));
            Assert(!(hr == S_OK && fYieldFailed));
            if (hr && fYieldFailed)
            {
                hr = S_OK;
            }
            // We do not want to retry if currency was changed, even if to some other element
            if (hr == S_FALSE && cCurrentElemChangesOld != _cCurrentElemChanges)
            {
                hr = S_OK;
            }
        }
        while (hr == S_FALSE &&
               FindNextTabOrder(dir, FALSE, pmsg, pCurrent, pmsg->lSubDivision, &pNext, &lSubNew) &&
               pNext);
    }
    else
    {
        // accessKey case here
        //
        _fNeedTabOut = FALSE;
        do
        {
            if (pNext)
            {
                pCurrent = pNext;
            }


            FOCUS_ITEM fi = pCurrent->GetMnemonicTarget(lSubNew);

            if (fi.pElement)
            {
                if (fi.pElement == pCurrent)
                {
                    pmsg->lSubDivision = fi.lSubDivision;
                    hr = THR_NOTRACE(fi.pElement->HandleMnemonic(pmsg, TRUE, &fYieldFailed));
                }
                else
                {
                    CMessage msg;

                    msg.message = WM_KEYDOWN;
                    msg.wParam = VK_TAB;
                    msg.lSubDivision = fi.lSubDivision;
                    hr = THR_NOTRACE(fi.pElement->HandleMnemonic(&msg, TRUE, &fYieldFailed));
                }
                Assert(!(hr == S_OK && fYieldFailed));
                if (FAILED(hr) && fYieldFailed)
                {
                    hr = S_OK;
                }
                // We do not want to retry if currency was changed, even if to some other element
                if (hr == S_FALSE && cCurrentElemChangesOld != _cCurrentElemChanges)
                {
                    hr = S_OK;
                }
            }

            if (hr == S_FALSE)
            {
               FindNextTabOrder(dir, TRUE, pmsg, pCurrent, pmsg->lSubDivision, &pNext, &lSubNew);
            }
        }
        while (hr == S_FALSE && pNext);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FindNextTabOrder
//
//  Synopsis:   Given an element and a subdivision within it, find the
//              next tabbable item.
//
//----------------------------------------------------------------------------

BOOL
CDoc::FindNextTabOrder(
    FOCUS_DIRECTION     dir,
    BOOL                fAccessKey,
    CMessage *          pmsg,
    CElement *          pCurrent,
    long                lSubCurrent,
    CElement **         ppNext,
    long *              plSubNext)
{
    BOOL fFound = FALSE;
    CMarkup * pMarkup;

    *ppNext = NULL;

    if (    DIRECTION_FORWARD == dir
        &&  pCurrent

        // Don't go into INPUT's slave markup. We know that
        // the INPUT does not have any tabbale elements inside.
        &&  pCurrent->Tag() != ETAG_INPUT
        &&  pCurrent->HasSlavePtr()       
        //
        // marka - dont drill into a master, if it's inside something editable
        //
        
        &&  pCurrent->GetFirstBranch() 
        &&  ! pCurrent->GetFirstBranch()->Parent()->Element()->IsEditable(/*fCheckContainerOnly*/FALSE)  )
    {
        pMarkup = pCurrent->GetSlavePtr()->GetMarkup();
        pCurrent = NULL;
    }
    else if (pCurrent)
        pMarkup = pCurrent->GetMarkup();
    else
    {
        pMarkup = PrimaryMarkup();
    }
    
    while (!*ppNext && pMarkup)
    {
        fFound = pMarkup->FindNextTabOrderInMarkup(dir, fAccessKey, pmsg, pCurrent, lSubCurrent, ppNext, plSubNext);

        if (*ppNext)
        {
            // *plSubNext == -2 means we need to drill in to find the access key target
            if (    (!fAccessKey || -2 == *plSubNext)
                &&  (*ppNext)->HasSlavePtr()
                &&  (*ppNext)->Tag() != ETAG_INPUT
                &&  !((*ppNext)->GetSlavePtr()->GetMarkup()->IsPrintMedia())
               )
            {
                // drill in  if tabbing backwards or if master is not a tabstop

                BOOL fDrillIn = FALSE;

                if (fAccessKey || DIRECTION_BACKWARD == dir)
                {
                    fDrillIn = TRUE;
                }
                else
                {
                    fDrillIn = !(*ppNext)->IsMasterTabStop();
                }
                if (fDrillIn)
                {
                    pMarkup = (*ppNext)->GetSlavePtr()->GetMarkup();
                    pCurrent = NULL;
                    *ppNext = NULL;
                    lSubCurrent = 0;
                    continue;
                }
            }
            break;
        }

        //
        // marka - don't step out of a viewlink at design time.
        //
        if (pMarkup->Root()->HasMasterPtr() && 
            ( pMarkup->Root()->GetMasterPtr()->GetFirstBranch() &&
              ! pMarkup->Root()->GetMasterPtr()->GetFirstBranch()->Parent()->Element()->IsEditable(/*fCheckContainerOnly*/FALSE) ))
        {
            pCurrent = pMarkup->Root()->GetMasterPtr();
            if (DIRECTION_BACKWARD == dir)
            {
                if (fAccessKey)
                {
                    if (pCurrent->MatchAccessKey(pmsg, 0))
                    {
                        FOCUS_ITEM fi = pCurrent->GetMnemonicTarget(0);

                        if (fi.pElement && fi.pElement->IsFocussable(fi.lSubDivision)) 
                        {
                            *ppNext = pCurrent;
                            *plSubNext = 0;
                            fFound = TRUE;
                        }
                    }
                }
                else
                {
                    if (pCurrent->IsTabbable(0) && pCurrent->IsMasterTabStop())
                    {
                        *ppNext = pCurrent;
                        *plSubNext = 0;
                        fFound = TRUE;
                    }
                }
            }
            pMarkup = pCurrent->GetMarkup();
        }        
        else
            break;
    }

    return fFound;
}

BOOL
CMarkup::FindNextTabOrderInMarkup(
    FOCUS_DIRECTION     dir,
    BOOL                fAccessKey,
    CMessage *          pmsg,
    CElement *          pCurrent,
    long                lSubCurrent,
    CElement **         ppNext,
    long *              plSubNext)
{
    BOOL        fFound = FALSE;
    CElement *  pElemTemp   = pCurrent;
    long        lSubTemp    = lSubCurrent;     

    // make sure focus cache is up to date    
    if (_fFocusCacheDirty && !fAccessKey)
    {
        CCollectionCache *  pCollCache;
        CElement *          pElement;
        CAryFocusItem     * paryFocusItem;          
        int                 i;
        
        _fFocusCacheDirty = FALSE;
        
        paryFocusItem = GetFocusItems(TRUE);    
        Assert (paryFocusItem);    
        paryFocusItem->DeleteAll();

        EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION);
        pCollCache = CollectionCache();
        if (!pCollCache)
            return FALSE;
            
        for (i = 0; i < pCollCache->SizeAry(CMarkup::ELEMENT_COLLECTION); i++)
        {
            pCollCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, i, &pElement);
            if (pElement)
            {
                InsertFocusArrayItem(pElement);
            }
        }
    }

    for(;;)
    {
        *ppNext    = NULL;
        *plSubNext = 0;

        // When Shift+Tabbing, start the search with those not in the Focus array (because
        // they are at the bottom of the tab order)
        if (fAccessKey || (!pCurrent && DIRECTION_BACKWARD == dir))
            break;

        fFound = SearchFocusArray(dir, pElemTemp, lSubTemp, ppNext, plSubNext);
    
        if (!fFound || !*ppNext || (*ppNext)->IsTabbable(*plSubNext) )
             break;

        Assert(pElemTemp != *ppNext || lSubTemp != *plSubNext);

        pElemTemp   = *ppNext;
        lSubTemp    = *plSubNext;
    }

    if (!*ppNext)
    {
        if (fFound)
        {
            if (DIRECTION_BACKWARD == dir)
            {
                return TRUE;
            }
            else
            {
                //
                // Means pCurrent was in focus array, but next tabbable item is not
                // Just retrieve the first tabbable item from the tree.
                //

                pCurrent = NULL;
                lSubCurrent = 0;
            }
        }

        fFound = SearchFocusTree(dir, fAccessKey, pmsg, pCurrent, lSubCurrent, ppNext, plSubNext);

        //
        // If element was found, but next item is not in
        // the tree and we're going backwards, return the last element in
        // the focus array.
        //

        CAryFocusItem * paryFocusItem = GetFocusItems(TRUE);
        Assert (paryFocusItem);
        if (!*ppNext &&
            !fAccessKey &&
            (fFound || !pCurrent) &&
            dir == DIRECTION_BACKWARD &&
            paryFocusItem->Size() > 0)
        {
            long    lLast = paryFocusItem->Size() - 1;

            while (lLast >= 0)
            {
                pElemTemp = (*paryFocusItem)[lLast].pElement;
                lSubTemp = (*paryFocusItem)[lLast].lSubDivision;
                if (pElemTemp->IsTabbable(lSubTemp))
                {
                    *ppNext = pElemTemp;
                    *plSubNext = lSubTemp;
                    fFound = TRUE;
                    break;
                }
                lLast--;
            }
        }
    }

    return fFound;
}


//+--------------------------------------------------------------
//
//  Member:     CMarkup::DocTraverseGroup
//
//  Synopsis:   Called by (e.g.)a radioButton, this function
//      takes the groupname and queries the markup's collection for the
//      rest of the group and calls the provided CLEARGROUP function on that
//      element. The traversal stops if the visit function returns S_OK or
//      and an error.
//
//---------------------------------------------------------------

HRESULT
CMarkup::MarkupTraverseGroup(
        LPCTSTR                 strGroupName,
        PFN_VISIT               pfn,
        DWORD_PTR               dw,
        BOOL                    fForward)
{
    HRESULT             hr = S_OK;
    long                i, c;
    CElement          * pElement;
    CCollectionCache  * pCollectionCache;
    LPCTSTR             lpName;

    _fInTraverseGroup = TRUE;

    // The control is at the document level. Clear all other controls,
    // also at document level, which are in the same group as this control.

    hr = THR(EnsureCollectionCache(ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = CollectionCache();
    Assert(pCollectionCache);

    // get size of collection
    c = pCollectionCache->SizeAry(ELEMENT_COLLECTION);

    if (fForward)
        i = 0;
    else
        i = c - 1;

    // if nothing is in the collection, default answer is S_FALSE.
    hr = S_FALSE;

    while (c--)
    {
        hr = THR(pCollectionCache->GetIntoAry(ELEMENT_COLLECTION, i, &pElement));
        if (fForward)
            i++;
        else
            i--;
        if (hr)
            goto Cleanup;

        hr = S_FALSE;                   // default answer again.

        // ignore the element if it is not a site
        if (!pElement->ShouldHaveLayout())
            continue;

        // ignore the element if it is in a form
        if (pElement->GetParentForm())
            continue;

        lpName = pElement->GetAAname();

        // is this item in the target group?
        if ( lpName && FormsStringICmp(strGroupName, lpName) == 0 )
        {
            // Call the function and break out of the
            // loop if it doesn't return S_FALSE.
#ifdef WIN16
            hr = THR( (*pfn)(pElement, dw) );
#else
            hr = THR( CALL_METHOD(pElement, pfn, (dw)) );
#endif
            if (hr != S_FALSE)
                break;
        }
    }

Cleanup:
    _fInTraverseGroup = FALSE;
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------
//
//  Member:     CDoc::FindDefaultElem
//
//  Synopsis:   find the default/Cancel button in the Doc
//
//              fCurrent means looking for the current default layout
//
//---------------------------------------------------------------
CElement *
CMarkup::FindDefaultElem(BOOL fDefault, BOOL fCurrent /* FALSE */)
{
    HRESULT             hr      = S_FALSE;
    long                c       = 0;
    long                i       = 0;
    CElement          * pElem   = NULL;
    CCollectionCache  * pCollectionCache;

    hr = THR(EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = CollectionCache();
    Assert(pCollectionCache);

    // Collection walker cached the value on the doc, go get it

    // get size of collection
    c = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    while (c--)
    {
        hr = THR(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION,
                        i++,
                        &pElem));

        if (hr)
        {
            pElem = NULL;
            goto Cleanup;
        }

        if (!pElem || pElem->_fExittreePending)
            continue;

        if (fCurrent)
        {
            if (pElem->_fDefault)
                goto Cleanup;
            continue;
        }

        if (pElem->TestClassFlag(fDefault?
                    CElement::ELEMENTDESC_DEFAULT
                    : CElement::ELEMENTDESC_CANCEL)
            && !pElem->GetParentForm()
            && pElem->IsVisible(TRUE)
            && pElem->IsEnabled())
        {
            goto Cleanup;
        }
    }
    pElem = NULL;

Cleanup:
    return pElem;
}

//+----------------------------------------------------------------------
//
//  Member:     CDoc::GetOmWindow
//
//  Synopsis:   returns IDispatch of frame # nFrame;
//              the IDispatch is script window of doc inside the frame
//
//-----------------------------------------------------------------------

HRESULT
CMarkup::GetCWindow(LONG nFrame, IHTMLWindow2 ** ppCWindow)
{
    CElement *  pElem;
    HRESULT     hr;

    hr = THR(EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, nFrame, &pElem));
    if (hr)
        goto Cleanup;

    hr = THR((DYNCAST(CFrameSite, pElem))->GetCWindow(ppCWindow));

Cleanup:
    RRETURN (hr);
}

#ifndef NO_DATABINDING
//+-------------------------------------------------------------------------
//
// Member:              Get Data Bind Task (public)
//
// Synopsis:    return my databind task, creating one if necessary.
//              Used only by databinding code, where the real work is done.
//
//-------------------------------------------------------------------------

CDataBindTask *
CMarkup::GetDataBindTask()
{
    CDataBindTask * pDBTask = GetDBTask();

    if (!pDBTask)
    {
        pDBTask = new CDataBindTask(Doc(), this);

        if (pDBTask)
            pDBTask->SetEnabled(_fDataBindingEnabled);
    }

    IGNORE_HR(SetDBTask(pDBTask));

    return pDBTask;
}

//+-------------------------------------------------------------------------
//
// Member:              Get Simple Data Converter (public)
//
// Synopsis:    return my data converter, creating one if necessary.
//              Used only by databinding code, to handle elements bound with
//              dataFormatAs = localized-text.
//
//-------------------------------------------------------------------------

ISimpleDataConverter *
CMarkup::GetSimpleDataConverter()
{
    AssertSz(GetDBTask(), "SimpleDataConverter used when no databinding present");
    return GetDBTask()->GetSimpleDataConverter();
}

//+-------------------------------------------------------------------------
//
// Member:      SetDataBindingEnabled (public)
//
// Synopsis:    Set the enabled flag on my databind task (if any).
//              If this enables the task, then tell it to run.
//
// Returns:     previous value of enabled flag
//-------------------------------------------------------------------------

BOOL
CMarkup::SetDataBindingEnabled(BOOL fEnabled)
{
    CDataBindTask * pDBTask = GetDBTask();
    BOOL fOldValue = _fDataBindingEnabled;

    _fDataBindingEnabled = fEnabled;
    if (pDBTask)
    {
        pDBTask->SetEnabled(fEnabled);
        if (!fOldValue && fEnabled)
            TickleDataBinding();
    }
    return fOldValue;
}


//+-------------------------------------------------------------------------
//
// Member:              TickleDataBinding (public)
//
// Synopsis:    Ask my databind task to try to bind all the deferred
//              bindings.  This can be called repeatedly, as more bindings
//              enter the world.
//-------------------------------------------------------------------------

void
CMarkup::TickleDataBinding()
{
    CDataBindTask * pDBTask = GetDBTask();

    if (pDBTask)
        pDBTask->DecideToRun();
}


//+-------------------------------------------------------------------------
//
// Member:              ReleaseDataBinding (public)
//
// Synopsis:    Release my databinding resources.
//
//-------------------------------------------------------------------------

void
CMarkup::ReleaseDataBinding()
{
    CDataBindTask * pDBTask = GetDBTask();

    if (pDBTask)
    {
        pDBTask->Terminate();
        pDBTask->Release();
        IGNORE_HR(SetDBTask(NULL));
    }
    SetDataBindingEnabled(FALSE);
}
#endif // ndef NO_DATABINDING

//+------------------------------------------------------------------------
//
// Utility function to force layout on all windows in the thread
//
//-------------------------------------------------------------------------

void
OnSettingsChangeAllDocs(BOOL fNeedLayout)
{
    int i;

    for (i = 0; i < TLS(_paryDoc).Size(); i++)
    {
        TLS(_paryDoc)[i]->OnSettingsChange(fNeedLayout);
    }
}

//+---------------------------------------------------------------------------
//
// OnOptionSettingsChange()
//
//----------------------------------------------------------------------------
HRESULT
CDoc::OnSettingsChange(BOOL fForce /* =FALSE */)
{
    BOOL fNeedLayout = FALSE;

    if (!IsPrintDialogNoUI())
    {
#ifndef NO_SCRIPT_DEBUGGER
        BYTE fDisableScriptDebuggerOld = _pOptionSettings ?
            _pOptionSettings->fDisableScriptDebugger : BYTE(-1);
#endif // NO_SCRIPT_DEBUGGER

        // Invalidate cached script based font info
        if (_pOptionSettings)
            _pOptionSettings->InvalidateScriptBasedFontInfo();

        IGNORE_HR(UpdateFromRegistry(REGUPDATE_REFRESH, &fNeedLayout));

        if (_pOptionSettings)
        {
            THREADSTATE * pts = GetThreadState();

#ifndef NO_SCRIPT_DEBUGGER
            Assert (fDisableScriptDebuggerOld != BYTE(-1));

            if (!_pOptionSettings->fDisableScriptDebugger &&
                 (fDisableScriptDebuggerOld == 1))
            {
                //
                // The user has chosen to enable the script debugger, which had
                // been disabled.  Now any scripts need to be re-parsed, which
                // means that the document needs to be reloaded.
                //
                _pWindowPrimary->ExecRefresh(OLECMDIDF_REFRESH_RELOAD);
            }
            else
            {
                if (_pOptionSettings->fDisableScriptDebugger &&
                    !fDisableScriptDebuggerOld &&
                    PrimaryMarkup()->GetScriptCollection())
                {
                    //
                    // The user has chosen to turn off the script debugger,
                    // which was previously enabled.
                    //

                    DeinitScriptDebugging();
                }
            }
#endif // NO_SCRIPT_DEBUGGER

            if (fNeedLayout || fForce)
            {
                if (_pWindowPrimary)
                {
                    PrimaryMarkup()->BubbleDownClearDefaultCharFormat();
                    PrimaryMarkup()->BubbleDownClearThemeDeterminedFlag();
                    ForceRelayout();
                }
            }

            pts->_iFontHistoryVersion++;

        }
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     SwitchCodePage
//
//  Synopsis:   Change the codepage of the document.  Should only be used
//              when we are already at a valid codepage setting.
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::SwitchCodePage(CODEPAGE codepage)
{
    HRESULT hr = S_OK;
    BOOL fReadCodePageSettings;
    UINT uiFamilyCodePage = CP_UNDEFINED;
    CODEPAGESETTINGS * pCodepageSettings = GetCodepageSettings();

    // Remember if we were autodetected
    _fCodePageWasAutoDetect = GetCodePage() == CP_AUTO_JP;

    // If codepage settings don't exist or the information is stale,
    // reset the information, as well as the charformat cache.

    if (pCodepageSettings)
    {
        if (pCodepageSettings->uiFamilyCodePage != codepage)
        {
            uiFamilyCodePage = WindowsCodePageFromCodePage(codepage);

            fReadCodePageSettings = pCodepageSettings->uiFamilyCodePage != uiFamilyCodePage;
        }
        else
        {
            fReadCodePageSettings = FALSE;
        }
    }
    else
    {
        uiFamilyCodePage = WindowsCodePageFromCodePage(codepage);
        fReadCodePageSettings = TRUE;
    }

    if (fReadCodePageSettings)
    {
        // Read the settings from the registry
        // Note that this call modifies CDoc::_codepage.

        hr = THR( ReadCodepageSettingsFromRegistry( codepage, uiFamilyCodePage, FALSE ) );

        // ReadCodepageSettingsFromRegistry will update the code page settings ptr on the
        // markup. Hence we need to refetch the codepage settings ptr from the markup.
        pCodepageSettings = GetCodepageSettings();

        if (pCodepageSettings && (IsPrimaryMarkup() || IsPendingPrimaryMarkup()))
        {
            Doc()->_sBaselineFont = GetCodepageSettings()->sBaselineFontDefault;
        }

        if (GetElementClient())
            GetElementClient()->Invalidate();
        ClearDefaultCharFormat();
        EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
    }
        
    // Set the codepage
    hr = SetCodePage(codepage);
    if (hr)
        goto Cleanup;

    hr = SetFamilyCodePage(GetCodepageSettings()->uiFamilyCodePage);
    if (hr)
        goto Cleanup;

    if (HtmCtx())
    {
        HtmCtx()->SetCodePage(codepage);
    }

Cleanup:
    RRETURN(hr);
}

CODEPAGE
CMarkup::GetCodePageCore()
{
    Assert( !_codepage );

    if (IsPrimaryMarkup())
        return g_cpDefault;

    CElement * pElemMaster = Root()->GetMasterPtr();

    if (!pElemMaster)
        return g_cpDefault;

    switch (pElemMaster->Tag())
    {
    case ETAG_FRAME:
    case ETAG_IFRAME:
        return g_cpDefault;
    default:
        if (!pElemMaster->IsInMarkup())
            return g_cpDefault;
        return pElemMaster->GetMarkup()->GetCodePage();
    }
}

CODEPAGE
CMarkup::GetFamilyCodePageCore()
{
    Assert( !_codepageFamily );

    if (IsPrimaryMarkup())
        return g_cpDefault;

    CElement * pElemMaster = Root()->GetMasterPtr();

    if (!pElemMaster)
        return g_cpDefault;

    switch (pElemMaster->Tag())
    {
    case ETAG_FRAME:
    case ETAG_IFRAME:
        return g_cpDefault;
    default:
        if (!pElemMaster->IsInMarkup())
            return g_cpDefault;
        return pElemMaster->GetMarkup()->GetFamilyCodePage();
    }
}

void
CMarkup::BubbleDownAction(BUBBLEACTION pfnBA, void *pvArgs)
{
    HRESULT hr;
    IHTMLFramesCollection2 * pFramesCollection = 0;

    CALL_METHOD(this, pfnBA, (pvArgs));

    // get frames collection
    hr = THR(Window()->get_frames(&pFramesCollection));
    if (hr)
        goto Cleanup;

    if (pFramesCollection)
    {
        // get frames count
        long cFrames;
        hr = THR(pFramesCollection->get_length(&cFrames));
        if (hr || (cFrames == 0))
            goto Cleanup;

        hr = THR(EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
        if (hr)
            goto Cleanup;

        for (long i = 0; i < cFrames; i++)
        {
            CElement * pElement;
            
            hr = THR(CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, i, &pElement));
            if (hr)
                goto Cleanup;

            CFrameSite *pFrameSite = DYNCAST(CFrameSite, pElement);
            if (pFrameSite)
            {
                // Get the markup associated with the frame.
                CMarkup * pNestedMarkup = pFrameSite->_pWindow ? pFrameSite->_pWindow->Markup() : NULL;
                if (pNestedMarkup)
                {
                    // Bubble down action
                    pNestedMarkup->BubbleDownAction(pfnBA, pvArgs);
                }
            }
        }
    }

Cleanup:
    if (pFramesCollection)
        pFramesCollection->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::IsAvailableOffline
//
//  Synopsis:   Determines if URL is availble when off line.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsAvailableOffline(LPCTSTR pchUrl, CElement *pElementContext)
{
    HRESULT hr;
    BOOL    fResult = FALSE;
    DWORD   f;
    DWORD   dwSize;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchExpUrl = cBuf;

    if (!pchUrl)
        goto Cleanup;

    // $$anandra Need markup
    hr = THR(CMarkup::ExpandUrl(
            NULL, pchUrl, ARRAY_SIZE(cBuf), pchExpUrl, pElementContext));
    if (hr)
        goto Cleanup;

    hr = THR(CoInternetQueryInfo(pchExpUrl,
            QUERY_USES_NETWORK,
            0,
            &f,
            sizeof(f),
            &dwSize,
            0));

    if (FAILED(hr) || !f)
    {
        fResult = TRUE;
        goto Cleanup;
    }

    hr = THR(CoInternetQueryInfo(pchExpUrl,
            QUERY_IS_CACHED_OR_MAPPED,
            0,
            &f,
            sizeof(f),
            &dwSize,
            0));

    if (FAILED(hr))
        goto Cleanup;

    fResult = f;

Cleanup:
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AddRefUrlImgCtx
//
//  Synopsis:   Returns a cookie to the background image specified by the
//              given Url and element context.
//
//  Arguments:  lpszUrl         Relative URL of the background image
//              pElemContext    Element to begin search for nearest <BASE> tag
//
//  Returns:    Cookie which refers to the background image
//
//----------------------------------------------------------------------------

HRESULT
CDoc::AddRefUrlImgCtx(LPCTSTR lpszUrl, CElement *pElemContext, LONG *plCookie, BOOL fForceReload)
{
    CDwnCtx *   pDwnCtx;
    CImgCtx *   pImgCtx;
    URLIMGCTX * purlimgctx;
    LONG        iurlimgctx;
    LONG        iurlimgctxFree = -1;
    LONG        curlimgctx;
    HRESULT     hr;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR *     pszExpUrl   = cBuf;
    SSL_SECURITY_STATE sslSecurity;
    SSL_PROMPT_STATE   sslPrompt;
    BOOL        fPendingRoot;
    CMarkup *   pMarkup = PrimaryMarkup();

    Assert( pElemContext );

    if (pElemContext->IsInMarkup())
        pMarkup = pElemContext->GetMarkup();

    *plCookie = 0;

    hr = THR(CMarkup::ExpandUrl(
            NULL, lpszUrl, ARRAY_SIZE(cBuf), pszExpUrl, pElemContext));
    if (hr)
        goto Cleanup;

    // See if we've already got a background image with this Url

    purlimgctx = _aryUrlImgCtx;
    curlimgctx = _aryUrlImgCtx.Size();

    // TODO (mohanb / lmollico): The IsOverlapped test is a hack for #64357
    if (    pElemContext->GetMarkup()
        &&  pElemContext->GetMarkup()->_LoadStatus == LOADSTATUS_DONE
        && !pElemContext->IsOverlapped()
        && fForceReload
        && !_fBackgroundImageCache)
    {
        iurlimgctx = curlimgctx;
    }
    else
    {
        for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx, ++purlimgctx)
        {
            if (purlimgctx->ulRefs == 0)
            {
                purlimgctx->fZombied = FALSE;
                iurlimgctxFree = iurlimgctx;
            }
            else
            {
                const TCHAR *pchSlotUrl;

                pchSlotUrl = purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl;
                Assert(pchSlotUrl);
            
                if (    pchSlotUrl 
                    &&  purlimgctx->pMarkup == pMarkup 
                    &&  StrCmpC(pchSlotUrl, pszExpUrl) == 0)
                {
                    // Found it.  Increment the reference count on this entry and
                    // hand out a cookie to it.

                    purlimgctx->ulRefs += 1;
                    *plCookie = iurlimgctx + 1;

                    TraceTag((tagUrlImgCtx, "AddRefUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%ld(%ls))",
                        *plCookie, purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl, purlimgctx->ulRefs,
                        pElemContext->_nSerialNumber, pElemContext->TagName()));

                    hr = THR(purlimgctx->aryElems.Append(pElemContext));

                    goto Cleanup;
                }
            }
        }
    }

    // No luck finding an existing image.  Get a new one and add it to array.

    if (iurlimgctxFree == -1)
    {
        hr = THR(_aryUrlImgCtx.EnsureSize(iurlimgctx + 1));
        if (hr)
            goto Cleanup;

        iurlimgctxFree = iurlimgctx;

        _aryUrlImgCtx.SetSize(iurlimgctx + 1);

        // N.B. (johnv) We need this so that the CPtrAry inside URLIMGCTX
        // gets initialized.
        memset(&_aryUrlImgCtx[iurlimgctxFree], 0, sizeof(URLIMGCTX));
    }

    purlimgctx = &_aryUrlImgCtx[iurlimgctxFree];

    // grab the current security state

    fPendingRoot = pMarkup->IsPendingRoot();

    GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);
    
    // If the URL is not secure....
    if (sslPrompt == SSL_PROMPT_QUERY && !IsUrlSecure(pszExpUrl))
    {
        // If a query is required, save the url and post a message to start download later
        
        GWPostMethodCallEx(GetThreadState(), (void *)this,
                           ONCALL_METHOD(CDoc, OnUrlImgCtxDeferredDownload, onurlimgctxdeferreddownload),
                           0, FALSE, "CDoc::OnUrlImgCtxDeferredDownload");

        if (!_dwCookieUrlImgCtxDef && CMarkup::GetProgSinkHelper(PrimaryMarkup()))
        {
            CMarkup::GetProgSinkHelper(PrimaryMarkup())->AddProgress(PROGSINK_CLASS_MULTIMEDIA, &_dwCookieUrlImgCtxDef);
            CMarkup::GetProgSinkHelper(PrimaryMarkup())->SetProgress(_dwCookieUrlImgCtxDef, PROGSINK_SET_STATE | PROGSINK_SET_POS | PROGSINK_SET_MAX, PROGSINK_STATE_LOADING, NULL, 0, 0, 1);
        }
        
        pImgCtx = NULL;
        hr = THR(purlimgctx->cstrUrl.Set(pszExpUrl));
        if (hr)
            goto Cleanup;
    }
    else if (sslPrompt == SSL_PROMPT_DENY && !IsUrlSecure(pszExpUrl))
    {
        pImgCtx = NULL;
        hr = THR(purlimgctx->cstrUrl.Set(pszExpUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // TODO Pass lpszUrl, not pszExpUrl, due to ExpandUrl bug.
        hr = THR(NewDwnCtx(DWNCTX_IMG, lpszUrl, pElemContext,
                    &pDwnCtx, fPendingRoot, TRUE));
        if (hr)
            goto Cleanup;
            
        pImgCtx = (CImgCtx *)pDwnCtx;

    }

    if (pImgCtx)
    {
        pImgCtx->SetProgSink(CMarkup::GetProgSinkHelper(PrimaryMarkup()));
        pImgCtx->SetCallback(OnUrlImgCtxCallback, this);
        // (greglett) Should be IsPrintMedia or is in print media context.
        pImgCtx->SelectChanges((!pElemContext->IsPrintMedia() && _pOptionSettings->fPlayAnimations) ? IMGCHG_COMPLETE|IMGCHG_ANIMATE
            : IMGCHG_COMPLETE, 0, TRUE); // TRUE: disallow prompting
    }

    // _aryUrlImgCtx array could be changed and we can't be sure that purlimgctx point 
    // to the same structure. Refer to bug 30282, we prevent crashing in next line.
    if (purlimgctx != &_aryUrlImgCtx[iurlimgctxFree])
        goto Cleanup;

    hr = THR(purlimgctx->aryElems.Append(pElemContext));
    if (hr)
        goto Cleanup;
        
    purlimgctx->ulRefs   = 1;
    purlimgctx->pImgCtx  = pImgCtx;
    purlimgctx->pMarkup  = pMarkup;
    *plCookie            = iurlimgctxFree + 1;

    TraceTag((tagUrlImgCtx, "AddRefUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%d(%ls))",
        *plCookie, purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl, purlimgctx->ulRefs,
        pElemContext->_nSerialNumber, pElemContext->TagName()));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnUrlImgCtxDeferredDownload
//
//  Synopsis:   Callback to validate security of backround images.
//
//----------------------------------------------------------------------------
void
CDoc::OnUrlImgCtxDeferredDownload(DWORD_PTR dwContext)
{
    // loop through array of urlimgctx's and kick off downloads for all
    // those that have urls without imgctx's.

    CDwnCtx *   pDwnCtx;
    CImgCtx *   pImgCtx;
    LONG        iurlimgctx;
    URLIMGCTX * purlimgctx;
    LONG        curlimgctx;
    HRESULT     hr;
    CStr        cstrUrl;
    
    if (InRootSslPrompt())
    {
        _fNeedUrlImgCtxDeferredDownload = TRUE;
        return;
    }
    
    curlimgctx = _aryUrlImgCtx.Size();

    // structured inefficiently to withstand array motion on reentrancy

    for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx)
    {
        purlimgctx = _aryUrlImgCtx + iurlimgctx;
        
        if (    purlimgctx->ulRefs > 0 
            &&  purlimgctx->pImgCtx == NULL 
            &&  purlimgctx->cstrUrl
            && !purlimgctx->fZombied)
        {
            CElement *  pElemTest = NULL;
            // make a copy (motivated by stress crash where AddRefUrlImgCtx is called inside pushed message loop of NewDwnCtx)
            
            cstrUrl.Set(purlimgctx->cstrUrl);

            // (jbeda) For fPending root, can we assume that all elemnts are in the same pending
            // root?  What if they have been moved around since we posted?  We can't use
            // pMarkup that we have cached because we aren't addrefing that pointer so
            // lets just grab the first element and use that to see if we are in the pending world
            // or not.
            BOOL fPendingRoot = FALSE;
            if (purlimgctx->aryElems.Size())
            {
                pElemTest = purlimgctx->aryElems[0];
                if (pElemTest->IsInMarkup())
                    fPendingRoot = pElemTest->GetMarkup()->IsPendingRoot();
            }

            hr = THR(NewDwnCtx(DWNCTX_IMG, cstrUrl, NULL, &pDwnCtx, fPendingRoot, FALSE)); // FALSE: allow prompting
            if (!hr)
            {
                // Check for sanity of aryUrlImgCtx after possible pushed message loop in NewDwnCtx (motivated by stress crash)

                if (    iurlimgctx < _aryUrlImgCtx.Size()
                    && !_aryUrlImgCtx[iurlimgctx].pImgCtx
                    && _aryUrlImgCtx[iurlimgctx].cstrUrl
                    && !StrCmpC(cstrUrl, _aryUrlImgCtx[iurlimgctx].cstrUrl))
                {
                    pImgCtx = (CImgCtx *)pDwnCtx;
                    
                    if (pImgCtx)
                    {
                        pImgCtx->SetProgSink(CMarkup::GetProgSinkHelper(PrimaryMarkup()));
                        pImgCtx->SetCallback(OnUrlImgCtxCallback, this);
                        // (greglett) Should be IsPrintMedia or is in print media context.
                        pImgCtx->SelectChanges((!(pElemTest && pElemTest->IsPrintMedia()) && _pOptionSettings->fPlayAnimations) ? IMGCHG_COMPLETE|IMGCHG_ANIMATE
                            : IMGCHG_COMPLETE, 0, TRUE);
                            
                        _aryUrlImgCtx[iurlimgctx].cstrUrl.Free();
                    }
                    _aryUrlImgCtx[iurlimgctx].pImgCtx  = pImgCtx;
                }
                else
                {
                    pDwnCtx->Release();
                }
            }
            cstrUrl.Free();
        }
    }

    if (_dwCookieUrlImgCtxDef)
    {
        CMarkup::GetProgSinkHelper(PrimaryMarkup())->DelProgress(_dwCookieUrlImgCtxDef);
        _dwCookieUrlImgCtxDef = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AddRefUrlImgCtx
//
//  Synopsis:   Adds a reference to the background image specified by the
//              given cookie.
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//
//----------------------------------------------------------------------------

HRESULT
CDoc::AddRefUrlImgCtx(LONG lCookie, CElement * pElem)
{
    HRESULT hr;

    if (!lCookie)
        return S_OK;

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    Assert(_aryUrlImgCtx[lCookie-1].ulRefs > 0);

    hr = THR(_aryUrlImgCtx[lCookie-1].aryElems.Append(pElem));
    if (hr)
        goto Cleanup;

    _aryUrlImgCtx[lCookie-1].ulRefs += 1;

    TraceTag((tagUrlImgCtx, "AddRefUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%ld)",
        lCookie, _aryUrlImgCtx[lCookie-1].pImgCtx ? _aryUrlImgCtx[lCookie-1].pImgCtx->GetUrl() : _aryUrlImgCtx[lCookie-1].cstrUrl,
        _aryUrlImgCtx[lCookie-1].ulRefs, pElem->_nSerialNumber));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetUrlImgCtx
//
//  Synopsis:   Returns the CImgCtx at the specified cookie
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//
//----------------------------------------------------------------------------

CImgCtx *
CDoc::GetUrlImgCtx(LONG lCookie)
{
    if (!lCookie)
        return(NULL);

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    Assert(_aryUrlImgCtx[lCookie-1].ulRefs > 0);

    return(_aryUrlImgCtx[lCookie-1].pImgCtx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetImgAnimState
//
//  Synopsis:   Returns an IMGANIMSTATE for the specified cookie, null if
//              there is none
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//
//----------------------------------------------------------------------------

IMGANIMSTATE *
CDoc::GetImgAnimState(LONG lCookie)
{
    CImgAnim * pImgAnim = GetImgAnim();
    LONG lAnimCookie;

    if (!lCookie || !pImgAnim)
        return(NULL);

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    Assert(_aryUrlImgCtx[lCookie-1].ulRefs > 0);

    lAnimCookie = _aryUrlImgCtx[lCookie-1].lAnimCookie;

    if (lAnimCookie)
        return(pImgAnim->GetImgAnimState(lAnimCookie));

    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReleaseUrlImgCtx
//
//  Synopsis:   Releases a reference to the background image specified by
//              the given cookie.
//
//  Arguments:  lCookie         Cookie given out by AddRefUrlImgCtx
//              pElem           An element associated with this cookie
//
//----------------------------------------------------------------------------

void
CDoc::ReleaseUrlImgCtx(LONG lCookie, CElement * pElem)
{
    if (!lCookie)
        return;

    Assert(lCookie > 0 && lCookie <= _aryUrlImgCtx.Size());
    URLIMGCTX * purlimgctx = &_aryUrlImgCtx[lCookie-1];
    Assert(purlimgctx->ulRefs > 0);


    TraceTag((tagUrlImgCtx, "ReleaseUrlImgCtx (#%ld,url=%ls,cRefs=%ld,elem=%d)",
        lCookie, _aryUrlImgCtx[lCookie-1].pImgCtx ? _aryUrlImgCtx[lCookie-1].pImgCtx->GetUrl() : NULL,
        _aryUrlImgCtx[lCookie-1].ulRefs - 1,
        pElem->_nSerialNumber));

    Verify(purlimgctx->aryElems.DeleteByValue(pElem));

    if (--purlimgctx->ulRefs == 0)
    {
        Assert(purlimgctx->aryElems.Size() == 0);

        // Release our animation cookie if we have one
        if (purlimgctx->lAnimCookie)
        {
            CImgAnim * pImgAnim = GetImgAnim();

            if (pImgAnim)
            {
                pImgAnim->UnregisterForAnim(this, purlimgctx->lAnimCookie);
            }
        }

        purlimgctx->aryElems.DeleteAll();
        if (purlimgctx->pImgCtx)
        {
            purlimgctx->pImgCtx->SetProgSink(NULL); // detach download from document's load progress
            purlimgctx->pImgCtx->Disconnect();
            purlimgctx->pImgCtx->Release();
        }
        purlimgctx->cstrUrl.Free();
        memset(purlimgctx, 0, sizeof(*purlimgctx));
    }
}

//----------------------------------------------------------
//
//  Member   : CDoc::StopUrlImgCtx
//
//  Synopsis : Stops downloading of all background images
//
//----------------------------------------------------------

void
CDoc::StopUrlImgCtx(CMarkup * pMarkup)
{
    URLIMGCTX * purlimgctx;
    LONG        curlimgctx;

    purlimgctx = _aryUrlImgCtx;
    curlimgctx = _aryUrlImgCtx.Size();

    for (; curlimgctx > 0; --curlimgctx, ++purlimgctx)
    {
        if (purlimgctx->pMarkup == pMarkup)
        {
            purlimgctx->fZombied = TRUE;
            if (purlimgctx->pImgCtx)
            {
                purlimgctx->pImgCtx->SetLoad(FALSE, NULL, FALSE);
            }
        }
    }

    if (_dwCookieUrlImgCtxDef && CMarkup::GetProgSinkHelper(PrimaryMarkup()))
    {
//        GWKillMethodCallEx(GetThreadState(), this, ONCALL_METHOD(CDoc, OnUrlImgCtxDeferredDownload, onurlimgctxdeferreddownload), 0);
//        _fNeedUrlImgCtxDeferredDownload = FALSE;
        CMarkup::GetProgSinkHelper(PrimaryMarkup())->DelProgress(_dwCookieUrlImgCtxDef);
        _dwCookieUrlImgCtxDef = NULL;
    }
}

//----------------------------------------------------------
//
//  Member   : CDoc::UnregisterUrlImageCtxCallbacks
//
//  Synopsis : Cancels any image callbacks for the doc.  Does
//             not release the image context itself.
//
//----------------------------------------------------------

void
CDoc::UnregisterUrlImgCtxCallbacks()
{
    CImgAnim  * pImgAnim = GetImgAnim();
    URLIMGCTX * purlimgctx;
    LONG        iurlimgctx;
    LONG        curlimgctx;

    purlimgctx = _aryUrlImgCtx;
    curlimgctx = _aryUrlImgCtx.Size();

    for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx, ++purlimgctx)
    {
        if (purlimgctx->ulRefs)
        {
            // Unregister callbacks from the animation object, if any
            if (pImgAnim && purlimgctx->lAnimCookie)
            {
                pImgAnim->UnregisterForAnim(this, purlimgctx->lAnimCookie);
                purlimgctx->lAnimCookie = 0;
            }

            if (purlimgctx->pImgCtx)
            {
                // Unregister callbacks from the image context
                purlimgctx->pImgCtx->SetProgSink(NULL); // detach download from document's load progress
                purlimgctx->pImgCtx->Disconnect();
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnUrlImgCtxCallback
//
//  Synopsis:   Callback from background image reporting that it is finished
//              loading.
//
//  Arguments:  pvObj         The pImgCtx that is calling back
//              pbArg         The CDoc pointer
//
//----------------------------------------------------------------------------

void CALLBACK
CDoc::OnUrlImgCtxCallback(void * pvObj, void * pvArg)
{
    CDoc *      pDoc       = (CDoc *)pvArg;
    CImgCtx *   pImgCtx    = (CImgCtx *)pvObj;
    LONG        iurlimgctx;
    LONG        curlimgctx = pDoc->_aryUrlImgCtx.Size();
    URLIMGCTX * purlimgctx = pDoc->_aryUrlImgCtx;
    SIZE        size;
    ULONG       ulState    = pImgCtx->GetState(TRUE, &size);

    pImgCtx->AddRef();

    for (iurlimgctx = 0; iurlimgctx < curlimgctx; ++iurlimgctx, ++purlimgctx)
    {
        if (pImgCtx && purlimgctx->pImgCtx == pImgCtx)
        {
            TraceTag((tagUrlImgCtx, "OnUrlImgCtxCallback (#%ld,url=%ls,cRefs=%ld)",
                iurlimgctx + 1, purlimgctx->pImgCtx ? purlimgctx->pImgCtx->GetUrl() : purlimgctx->cstrUrl, purlimgctx->ulRefs));

            if (ulState & IMGCHG_ANIMATE)
            {
                // Register for animation callbacks
                CImgAnim * pImgAnim = CreateImgAnim();

                if(pImgAnim)
                {
                    if (!purlimgctx->lAnimCookie)
                    {
                        pImgAnim->RegisterForAnim(pDoc, (DWORD_PTR) pDoc,   // TODO (lmollico): remove the second arg
                                                  pImgCtx->GetImgId(),
                                                  OnAnimSyncCallback,
                                                  (void *)(DWORD_PTR)iurlimgctx,
                                                  &purlimgctx->lAnimCookie);
                    }

                    if (purlimgctx->lAnimCookie)
                    {
                        pImgAnim->ProgAnim(purlimgctx->lAnimCookie);
                    }
                }
            }
            if (ulState & (IMGLOAD_COMPLETE | IMGLOAD_STOPPED | IMGLOAD_ERROR))
            {
                pImgCtx->SetProgSink(NULL); // detach download from document's load progress
            }
            if (ulState & IMGLOAD_COMPLETE)
            {
                pDoc->OnUrlImgCtxChange(purlimgctx, IMGCHG_COMPLETE);
            }

            break;
        }
    }
    pImgCtx->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnAnimSyncCallback
//
//  Synopsis:   Called back on an animation event
//
//----------------------------------------------------------------------------

void
CDoc::OnAnimSyncCallback(void * pvObj, DWORD dwReason, void * pvArg,
                         void ** ppvDataOut, IMGANIMSTATE * pImgAnimState)
{
    CDoc * pDoc  = (CDoc *) pvObj;
    URLIMGCTX * purlimgctx = &pDoc->_aryUrlImgCtx[(LONG)(LONG_PTR)pvArg];

    switch (dwReason)
    {
    case ANIMSYNC_GETIMGCTX:
        *(CImgCtx **) ppvDataOut = purlimgctx->pImgCtx;
        break;

    case ANIMSYNC_GETHWND:
        *(HWND *) ppvDataOut = pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : NULL;
        break;

    case ANIMSYNC_TIMER:
    case ANIMSYNC_INVALIDATE:
        if(purlimgctx->pImgCtx)
            *(BOOL *) ppvDataOut = pDoc->OnUrlImgCtxChange(purlimgctx, IMGCHG_ANIMATE);
        else
            *(BOOL *) ppvDataOut = FALSE;
        break;

    default:
        Assert(FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnUrlImgCtxChange
//
//  Synopsis:   Called when this image context has changed, does the necessary
//              invalidating.
//
//  Arguments:  purlimgctx    The url image ctx that changed
//              ulState       The reason for the callback
//
//----------------------------------------------------------------------------

MtDefine(CDoc_OnUrlImgCtxChange_aryElemsLocal_pv, CDoc, "CDoc::OnUrlImgCtxChange aryElemsLocal::_pv")

BOOL
CDoc::OnUrlImgCtxChange(URLIMGCTX * purlimgctx, ULONG ulState)
{
    if (!_pInPlace || !purlimgctx->pImgCtx)
        return FALSE;             // no window yet, nothing to do

    BOOL        fSynchronousPaint = TRUE;
    int         n;
    CElement ** ppElem;
    CLayout   * pLayout;
    BOOL        fUpdateSecPrimary = FALSE;
    BOOL        fUpdateSecPending = FALSE;

    TraceTag((tagUrlImgCtx, "OnChange for doc %ls, img %ls, %ld elements",
              GetPrimaryUrl(),
              purlimgctx->pImgCtx->GetUrl(),
              purlimgctx->aryElems.Size()));
    
    // First scan to see which world we are in for updating security icons
    if (ulState & IMGCHG_COMPLETE)
    {
        for (n = purlimgctx->aryElems.Size(), ppElem = purlimgctx->aryElems;
             n > 0;
             n--, ppElem++)
        {
            CElement * pElement = * ppElem;

            if (pElement->IsInMarkup())
            {
                // figure out if we are going to have to update security state
                if (!fUpdateSecPrimary || !fUpdateSecPending)
                {
                    if (pElement->GetMarkup()->IsPendingRoot())
                        fUpdateSecPending = TRUE;
                    else
                        fUpdateSecPrimary = TRUE;
                }
                else
                    break;
            }
        }

         // If the image turned out to be unsecure, blow away the lock icon
        if (fUpdateSecPending)
            OnSubDownloadSecFlags(TRUE, purlimgctx->pImgCtx->GetUrl(), purlimgctx->pImgCtx->GetSecFlags());
        if (fUpdateSecPrimary)
            OnSubDownloadSecFlags(FALSE, purlimgctx->pImgCtx->GetUrl(), purlimgctx->pImgCtx->GetSecFlags());
    }

    {
        // Note: (jbeda) We are now going to go through all of the elements that
        //       depend on this change and perhaps invaldate.  Some of the
        //       result of this is that we may reenter this code and change this
        //       array.  That could be bad.  To get around this, we'll copy the
        //       array and only notify on that.  There should be no need to
        //       addref here as the tree shouldn't be changed during this
        //       operation.
        CStackPtrAry < CElement *, 16 > aryElemsLocal( Mt( CDoc_OnUrlImgCtxChange_aryElemsLocal_pv ) );

        if (OK( aryElemsLocal.Copy(purlimgctx->aryElems, FALSE) ) )
        {
            for (n = aryElemsLocal.Size(), ppElem = aryElemsLocal;
                 n > 0;
                 n--, ppElem++)
            {
                CElement * pElement = * ppElem;
                //
                // marka - check that element still in tree - bug # 15481.
                //
                if (pElement->IsInMarkup())
                {
                    CMarkup * pMarkup = pElement->GetMarkup();

                    if (   pMarkup->IsHtmlLayout()
                        && pMarkup->GetElementClient() == pElement )
                    {
                        CElement * pHtml = pMarkup->GetHtmlElement();
                        if (    pHtml
                            &&  DYNCAST(CHtmlElement, pHtml)->ShouldStealBackground())
                        {
                            pElement = pHtml;                    
                        }
                    }

                    pLayout = pElement->GetFirstBranch()->GetUpdatedNearestLayout(GUL_USEFIRSTLAYOUT);

                    //
                    // if the background is on HTML element or any other ancestor of
                    // body/top element, the inval the top element.
                    //
                    if (!pLayout)
                    {
                        CElement * pElemClient = pMarkup->GetElementClient();

                        if(pElemClient)
                        {
                            pLayout  = pElemClient->GetUpdatedLayout();
                            pElement = pLayout->ElementOwner();
                        }
                    }

                    if(pLayout)
                    {
                        if (pLayout->ElementOwner() == pElement)
                        {
                            if (OpenView())
                            {
                                CDispNodeInfo   dni;

                                pLayout->GetDispNodeInfo(&dni);
                                pLayout->EnsureDispNodeBackground(dni);
                            }
                        }


                        // Some elements require a resize, others a simple invalidation
                        if (pElement->_fResizeOnImageChange && (ulState & IMGCHG_COMPLETE))
                        {
                            pElement->ResizeElement();
                            fSynchronousPaint = FALSE;
                        }
                        else
                        {
                            // We can get away with just an invalidate
                            pElement->Invalidate();
                        }
                    }
                }
            }
        }
    }

    return fSynchronousPaint;
}

//+----------------------------------------------------------------
//
//  Member   :  GetActiveFrame
//
//  Arguments:  ppFrame(out)    Pointer to the frame element that 
//                              contains the current element
//
//              pMarkup(in):   Pointer to interesting frameset.  If null/unspecified,
//                              a master frameset is assumed.
//                              The active frame is returned only if it is
//                              within this markup's scope.
//-----------------------------------------------------------------
HRESULT CDoc::GetActiveFrame(CFrameElement **ppFrame, CMarkup *pMarkup)
{   
    CMarkup     *pMarkupTarget;
    CTreeNode   *pNode;
    CElement    *pElement;

    Assert(ppFrame);
    (*ppFrame)    = NULL;

    pMarkupTarget = pMarkup ? pMarkup : PrimaryMarkup();

    Assert(pMarkupTarget);

    // if there is no active element
    if (_pElemCurrent)
    {
        pNode = _pElemCurrent->GetFirstBranch();
        if (!pNode)
            return E_FAIL;

        // Get the master node in the target markup, which enslaves
        // the markup our node is a member of.
        pNode = pNode->GetNodeInMarkup(pMarkupTarget);

        // If we actually found a node in target markup, then try to 
        // return a frame element from it. 
        // Otherwise return S_OK with a NULL pointer.
        if (pNode)
        {
            // This may be a frame element
            pElement = pNode->Element();
            if (pElement->Tag() == ETAG_FRAME || pElement->Tag() == ETAG_IFRAME)
            {
                // It is a FRAME/IFRAME.  Return the element.
                (*ppFrame) = DYNCAST(CFrameElement, pNode->Element());
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMarkup::RequestReadystateInteractive
//
//  Synopsis:   Request (default is a post) to make the markup interactive.
//              This can be a signal to the host to take us inplace.  It
//              also requests that the new markup to be switched in.
//
//----------------------------------------------------------------------------
void
CMarkup::RequestReadystateInteractive(BOOL fImmediate)
{
    if (!CanNavigate())
    {
        if (!_fInteractiveRequested)
        {
            _fInteractiveRequested = TRUE;
            Doc()->RegisterMarkupForModelessEnable(this);
        }
        return;
    }

    Assert( !_fInteractiveRequested );

    if (fImmediate)
    {
        SetInteractiveInternal(0);
    }
    else
    {
        IGNORE_HR(GWPostMethodCall(this,
            ONCALL_METHOD(CMarkup, SetInteractiveInternal, setinteractiveinternal),
            READYSTATE_INTERACTIVE, FALSE, "CMarkup::SetInteractive"));
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetInteractiveInternal
//
//  Synopsis:   Changes the readyState of the document to interactive if
//              the document is still being loaded.
//
//----------------------------------------------------------------------------

void BUGCALL
CMarkup::SetInteractiveInternal(DWORD_PTR dwContext)
{
    CMarkup::CLock markupLock(this);

    if (_fIsInSetInteractive || _pDoc->IsShuttingDown())
        goto Cleanup;

    // This is always a posted call, so if we can't do what we want
    // to do now (modeless enabled) than we just put ourselves
    // on the list to get tickled when this situation changes.
    if (!CanNavigate())
    {
        RequestReadystateInteractive();
        goto Cleanup;
    }

    {
        CDoc::CLock docLock( _pDoc );

        _fIsInSetInteractive = TRUE;

        // If any markups go interactive, we want to make sure that we
        // are OS_INPLACE.  We do that by taking the readystate markup
        // interactive.  This is the markup that is used in 
        // CDocument::get_readyState
        if (_pDoc->State() < OS_INPLACE)
        {
            CWindow * pWindowPrimary = _pDoc->_pWindowPrimary->Window();
            CMarkup * pMarkupReadystate = pWindowPrimary->_pMarkupPending 
                                          ? pWindowPrimary->_pMarkupPending 
                                          : pWindowPrimary->_pMarkup;

            if (this != pMarkupReadystate)
                RequestReadystateInteractive(TRUE);
        }

        // Take this interactive
        if (GetReadyState() < READYSTATE_INTERACTIVE)
        {
            COmWindowProxy * pPendingWindowPrxy = GetWindowPending();

            if (_fWindowPending)
            {
                Assert(pPendingWindowPrxy);

                THR(pPendingWindowPrxy->SwitchMarkup(this,
                                                     IsActiveDesktopComponent(),
                                                     COmWindowProxy::TLF_UPDATETRAVELLOG));

                // SwitchMarkup could actually cause our load to get aborted -
                // Ex: IFRAME being held onto by undo queue, but in the middle of 
                // navigating.  SwitchMarkup flushes the undo queue, passivates the
                // IFrame, and nukes us.
                if ( ! HasWindowPending())
                        return;
            }

            // We have to fire NavigateComplete2 even if 
            // _fWindowPending is FALSE. This will occur if the 
            // navigation has come from the address bar or if
            // we are creating a frame.
            //
            if (   pPendingWindowPrxy 
                && !(pPendingWindowPrxy->IsPassivating() || pPendingWindowPrxy->IsPassivated())
                && HtmCtx()
                && (S_OK == HtmCtx()->GetBindResult())
                    // let this event firing happen in SetReadyState when status == Done
                    // for print markups, just do the normal thing
                && !(   g_fInMSWorksCalender
                     && (   GetUrlScheme(Url()) == URL_SCHEME_ABOUT
                         || GetUrlScheme(Url()) == URL_SCHEME_FILE
                     )  )
               )
            {
                if (!_fInRefresh && !_fMarkupServicesParsing && !_pDoc->_fDefView)
                {
                    if (!IsPrimaryMarkup() && !_fLoadingHistory)
                    {
                        _pDoc->_webOCEvents.FireDownloadEvents(pPendingWindowPrxy,
                                                               CWebOCEvents::eFireDownloadComplete);
                    }

                    if (!_fNewWindowLoading)
                    {
                        _pDoc->_webOCEvents.NavigateComplete2(pPendingWindowPrxy);
                    }
                }
            }

            // Fire onRSC for LOADING, if we could not fire earlier, due to the old markup
            // not having completely gone through the shutdown sequence (i.e until onUnload
            // is fired in switchMarkup
            if (_fDelayFiringOnRSCLoading && pPendingWindowPrxy)
            {
                _fDelayFiringOnRSCLoading = FALSE;
                pPendingWindowPrxy->Document()->FirePropertyNotify(DISPID_READYSTATE, TRUE);
                pPendingWindowPrxy->Document()->Fire_onreadystatechange();
            }

            SetReadyState(READYSTATE_INTERACTIVE);        
            ProcessPeerTasks(0);
        }

        _fIsInSetInteractive = FALSE;
    }

Cleanup:    
    ShowWaitCursor(FALSE); // No waiting
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CLock::CLock
//
//  Synopsis:
//
//----------------------------------------------------------------------------

CDoc::CLock::CLock(CDoc * pDoc, WORD wLockFlags)
    : CServer::CLock(pDoc, wLockFlags)
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pScriptCollection = ( pDoc->_pWindowPrimary )
                            ? pDoc->_pWindowPrimary->Markup()->GetScriptCollection(FALSE)
                            : NULL;
#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        if (_pScriptCollection)
            _pScriptCollection->AddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif

}

CDoc::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        if (_pScriptCollection)
            _pScriptCollection->Release();
    }

#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PostAAEvent
//
//  Synopsis:   Translate our trident event into an Accessibility event and
//      post it to the window.
//
//----------------------------------------------------------------------------
typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG);
NOTIFYWINEVENTPROC g_pfnNotifyWinEvent=NULL;
#define DONOTHING_NOTIFYWINEVENT (NOTIFYWINEVENTPROC )1

#define ACCEVTARRAYSIZE_MIN  4
#define ACCEVTARRAYSIZE_MAX  32

//
//
//
HRESULT
CDoc::CAccEvtArray::Init()
{
    HRESULT hr;

    _lCurIndex = 0;
    _lCurSize = 0;

    hr = THR(_aryEvtRefs.EnsureSize(ACCEVTARRAYSIZE_MIN));

    if (!hr)
        _lCurSize = ACCEVTARRAYSIZE_MIN;

    RRETURN(hr);
}

//
//
//
void
CDoc::CAccEvtArray::Passivate()
{
    // walk through the array and cleanup existing entries
    
    for (int i=0; i < _aryEvtRefs.Size() ; i++)
    {
        // if the slot still contains information
        if (_aryEvtRefs[i])
        {
            CBase * pObj = _aryEvtRefs[i]->pObj;
            
            // free memory
            delete _aryEvtRefs[i];
            _aryEvtRefs[i] = 0;
            
            // dereference the object 
            pObj->PrivateRelease();                
        }
    }

    // if this ever fires, we will leak.  To fix: add a do-while(!IsEmpty) around the for loop.
    Assert(IsEmpty(_aryEvtRefs));
}

//
//  This method is called to clean up defunked enteries in _aryEvtRefs.
//  That is references to elements that do not have markup
//

void
CDoc::CAccEvtArray::Flush()
{
    CElement * pElement = NULL;
    CWindow  * pWindow  = NULL;

    // We are getting into problems when CDoc is passivated before the Markup
    // We need not worry about flushing in such a case, because we passivate 
    // When CDoc passivates.

    if (_pMyCDoc->IsPassivating() || _pMyCDoc->IsPassivated())
    {
        return;
    }

    // walk through the array and defunked entries
    for (int i=0; i < _aryEvtRefs.Size() ; i++)
    {
        // if the slot still contains information check 
        if (_aryEvtRefs[i])
        {
            // if window
            if (_aryEvtRefs[i]->fWindow)
            {
                pWindow = DYNCAST(CWindow,_aryEvtRefs[i]->pObj);
                
                // Check to make sure we are not the primary window
                // Cannot use IsPrimaryWindow() because it can be fooba at this point
                // if slot is defunked free it
                // removed pWindow->_pMarkup == NULL check.  That'll never happen in The New World.
                Assert( _pMyCDoc->_pWindowPrimary && _pMyCDoc->_pWindowPrimary->_pCWindow );
                
                if (pWindow->_pWindowParent == NULL && _pMyCDoc->_pWindowPrimary->_pCWindow != pWindow)
                {
                    delete _aryEvtRefs[i];
                    _aryEvtRefs[i]=0;
                    
                    // dereference the object 
                    pWindow->PrivateRelease();
                }
            }
            // it is a element
            else
            {
                pElement = DYNCAST(CElement,_aryEvtRefs[i]->pObj);
                
                // if slot is defunked free it
                if (pElement->GetFirstBranch() == NULL)
                {
                    // We have to null out the slot first because 
                    // there can be a slave markup that is passivated.
                    delete _aryEvtRefs[i];
                    _aryEvtRefs[i]=0;
                    
                    // dereference the object 
                    pElement->PrivateRelease();
                    
                }
            } 
        }
    }
}
//
//
//

#if DBG==1
#pragma warning(disable:4189) // local variable initialized but not used 
#endif
HRESULT 
CDoc::CAccEvtArray::AddAccEvtSource(ACCEVTRECORD * pAccEvtRec, long * pnCurIndex)
{
    HRESULT     hr = S_OK;
    CWindow  *  pWindow  = NULL;

    Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

    Assert(pAccEvtRec);

    //
    // Make sure the document isn't passivating otherwise all the pointer are foobaa
    //
    if (_pMyCDoc->IsPassivating() || _pMyCDoc->IsPassivated())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // If your a child window and passivating we don't want to add your event to the queue
    //
    if (pAccEvtRec->fWindow)
    {
        pWindow = DYNCAST(CWindow,pAccEvtRec->pObj);

        // Check to make sure we are not the primary window
        // Cannot use IsPrimaryWindow() because it can be fooba at this point
        //

        if (_pMyCDoc->_pWindowPrimary->_pCWindow != pWindow)
        {
            if ((pWindow->IsPassivating()) || (pWindow->IsPassivated()))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }

    Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

    // now the _lCurIndex is pointing to the next location we will write
    if (_lCurSize > _aryEvtRefs.Size())
    {
        Assert( _lCurIndex < ACCEVTARRAYSIZE_MAX);

        hr = _aryEvtRefs.Append(pAccEvtRec);
        if (hr)
            goto Cleanup;
    }
    else
    {
        // If the array is full and we have a full slot in hand, clean it up and 
        // reuse it.
        if ((_aryEvtRefs.Size() == ACCEVTARRAYSIZE_MAX) && _aryEvtRefs[_lCurIndex])
        {
            while(_aryEvtRefs[_lCurIndex])
            {
#if DBG
                ACCEVTRECORD *  pDbg1 = _aryEvtRefs[_lCurIndex];
#endif
                CBase * pObj = _aryEvtRefs[_lCurIndex]->pObj;
                // Clean up before releasing to prevent reentry
                delete _aryEvtRefs[_lCurIndex];
                _aryEvtRefs[_lCurIndex] = 0;
                
                // release the reference on the object
                // CAUTION: this is side effecting!  We can reenter this function!
                pObj->PrivateRelease();
            }
        }

        Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

        Assert(0 == _aryEvtRefs[_lCurIndex]);

        // set the pointer value in this slot
        _aryEvtRefs[_lCurIndex] = pAccEvtRec;
    }

    // add a reference to the object we are adding to the array
    pAccEvtRec->pObj->PrivateAddRef();

    // return the current index and increment the position.
    // the index we return is 1 based, so it is ok to increment before returning.
    *pnCurIndex = ++_lCurIndex;

    // this assert is different - _lCurIndex can be equal to _lCurSize
    Assert(_lCurIndex >= 0 && _lCurIndex <= _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);

    // if we have reached the end of the allocated size,
    if (_lCurIndex == _lCurSize)
    {
        // if we have room to grow, 
        if (_lCurSize < ACCEVTARRAYSIZE_MAX)
        {
            hr = _aryEvtRefs.EnsureSize(_lCurSize * 2);

            if (SUCCEEDED(hr))
            {
                _lCurSize = _lCurSize * 2;
            }
            else
            {
                _lCurIndex = 0; // could not grow, reset position
            }
        }
        else
        {
            _lCurIndex = 0; // reached max size, reset position
        }
    }


Cleanup:
    if (hr)
    {
        *pnCurIndex = 0;
    }

    Assert(_lCurIndex >= 0 && _lCurIndex < _lCurSize && _lCurSize <= ACCEVTARRAYSIZE_MAX);
    RRETURN(hr);
}
#if DBG==1
#pragma warning(default:4189) // local variable initialized but not used 
#endif

//
//
//
HRESULT
CDoc::CAccEvtArray::GetAccEvtSource(long lIndex, ACCEVTRECORD * pAccEvtRec)
{
    HRESULT hr = S_OK;

    if (!pAccEvtRec)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // index has to be larger than 0
    // index has to be less then or equal to the total number of elements 
    // currently in the array. (since the lIndex is 1 based)
    // There has to be a non-zero value in the slot the index will refer to
    if (!lIndex || 
        (lIndex > _aryEvtRefs.Size()) || 
        !_aryEvtRefs[lIndex-1])
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Copy the contents of the structure that is pointed by the array entry
    // to the structure which we received the address of.

    memcpy( pAccEvtRec, _aryEvtRefs[lIndex-1], sizeof(ACCEVTRECORD));

Cleanup:
    RRETURN(hr);
}

extern BOOL g_fIsWinEventHookInstalled;

HRESULT 
CDoc::FireAccessibilityEvents(DISPID dispidEvent, CBase * pBaseObj, BOOL fWindow)
{
    HRESULT hr  = S_OK;
    long    lElemId;
    
    // map of trident events to the accesiblity events.

//
//FerhanE:
//  This is list is searched using a linear search algo. However, to make the 
//  search faster, events that are fired more often are at the top of the list.
//  Be careful when adding things in here.
    static const struct { DISPID a;
                          DWORD  b; } aEventTable[] = {
                              { NULL,                          EVENT_OBJECT_STATECHANGE},
                              { DISPID_EVMETH_ONFOCUS,         EVENT_OBJECT_FOCUS},
                              { DISPID_EVMETH_ONBLUR,          EVENT_OBJECT_STATECHANGE},
                              { DISPID_EVMETH_ONLOAD,          EVENT_OBJECT_CREATE},
                              { DISPID_EVMETH_ONUNLOAD,        EVENT_OBJECT_DESTROY},
                              { DISPID_IHTMLELEMENT_INNERHTML, EVENT_OBJECT_REORDER},
                              { DISPID_IHTMLELEMENT_OUTERHTML, EVENT_OBJECT_REORDER},
                              { DISPID_ONCONTROLSELECT,        EVENT_OBJECT_FOCUS},
                        };
    
    // do we have enabled accessiblity?
    if (g_pfnNotifyWinEvent != DONOTHING_NOTIFYWINEVENT &&
        _pInPlace && g_fIsWinEventHookInstalled)
    {
        if (!g_pfnNotifyWinEvent )
        {
            HMODULE hmod = GetModuleHandle(TEXT("USER32"));

            if (hmod)
                g_pfnNotifyWinEvent = (NOTIFYWINEVENTPROC)GetProcAddress(
                                                            hmod,
                                                            "NotifyWinEvent");

            if (!g_pfnNotifyWinEvent)
            {
                g_pfnNotifyWinEvent = DONOTHING_NOTIFYWINEVENT;
                goto Cleanup;
            }
        }        
        
        // if the object that was passed in was not the primary window
        // then we have to get a cookie to send out.
        if (pBaseObj != OBJID_WINDOW)
        {
            ACCEVTRECORD * pAccEvtRec = new ACCEVTRECORD( pBaseObj, fWindow);
            
            if (!pAccEvtRec)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            
            // Add the object into the array and get a cookie back.
            hr = _aryAccEvents.AddAccEvtSource(pAccEvtRec,&lElemId);
            
            if (hr != S_OK)
            {
                hr = S_OK;
                goto Cleanup;
            }
            Assert(lElemId);
        }
        else
        {
            lElemId = OBJID_WINDOW;
        }

        // we have a fx Ptr
        for (int iPos=0; iPos < ARRAY_SIZE(aEventTable); iPos++)
        {            
            // If we can map this event, send the message and leave
           if (aEventTable[iPos].a == dispidEvent)
           {
                // make the event notification call.       
                (* g_pfnNotifyWinEvent)( aEventTable[iPos].b,   // the Accesibility event id
                                         _pInPlace->_hwnd,      // the inplace hwnd
                                         lElemId,               // parent?
                                         CHILDID_SELF);         // child id

                break;
           }
        }

    }

Cleanup:
    RRETURN(hr);
}

//TODO: remove pDoc first param later, after NATIVE_FRAME is enabled, don't do it now to avoid pdlparser dependency
HRESULT
CDocument::FireEvent(CDoc *pDoc,
        DISPID      dispidEvent,
        DISPID      dispidProp,
        LPCTSTR     pchEventType,
        BOOL *      pfRet)
{
    RRETURN(CBase::FireEvent(pDoc, NULL, Markup(), dispidEvent, dispidProp, pchEventType, pfRet));
}

HRESULT
CDocument::fireEvent(BSTR bstrEventName, VARIANT *pvarEventObject, VARIANT_BOOL *pfCancelled)
{
    CDoc *pDoc = Doc();
    HRESULT hr = S_OK;
    const PROPERTYDESC *ppropdesc;
    EVENTPARAM *pParam = NULL;
    BOOL fCreateLocal = FALSE;
    CEventObj *pSrcEventObj = NULL;
    IHTMLEventObj *pIEventObject = NULL;
    DISPID dispidEvent;
    DISPID dispidProp;
    BOOL fRet;
    
    if (!bstrEventName || !*bstrEventName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //TODO(sramani): what about Case sensitivity?
    ppropdesc = FindPropDescForName(bstrEventName);
    if (!ppropdesc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    dispidEvent = (DISPID)(((const PROPERTYDESC_BASIC *)ppropdesc)->c);
    dispidProp = ((const PROPERTYDESC_BASIC *)ppropdesc)->b.dispid;

    if (pvarEventObject && V_VT(pvarEventObject) == VT_DISPATCH && V_DISPATCH(pvarEventObject))
    {
        pIEventObject = (IHTMLEventObj *)V_DISPATCH(pvarEventObject);

        hr = THR(pIEventObject->QueryInterface(CLSID_CEventObj, (void **)&pSrcEventObj));
        if (hr)
            goto Cleanup;

        pSrcEventObj->GetParam(&pParam);
        if (!pParam)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        // event object passed in already pushed on stack --- we are inside an event handler, copy it locally and use.
        if (pParam->_fOnStack)
            fCreateLocal = TRUE;
    }
    else // no event obj passed in, create one implicitly on the stack and init it.
    {
        fCreateLocal = TRUE;
    }

    if (fCreateLocal)
    {
        EVENTPARAM param(pDoc, NULL, Markup(), !pParam, TRUE, pParam);

        param.SetType(ppropdesc->pstrName + 2); // all events start with on...
        param.fCancelBubble = FALSE;
        V_VT(&param.varReturnValue) = VT_EMPTY;

        hr = THR(CBase::FireEvent(pDoc, NULL, Markup(), dispidEvent, dispidProp, NULL, &fRet));
    }
    else // explicitly created event object passed in, re-use it by locking it on stack
    {
        Assert(pIEventObject);
        Assert(pParam);

        pParam->SetType(ppropdesc->pstrName + 2); // all events start with on...
        pParam->fCancelBubble = FALSE;
        V_VT(&pParam->varReturnValue) = VT_EMPTY;

        CEventObj::COnStackLock onStackLock(pIEventObject);

        hr = THR(CBase::FireEvent(pDoc, NULL, Markup(), dispidEvent, dispidProp, NULL, &fRet));
    }

    if (pfCancelled && !FAILED(hr))
    {
        if (ppropdesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_CANCELABLE)
            *pfCancelled = (fRet) ? VB_TRUE : VB_FALSE;
        else
            *pfCancelled = VB_TRUE;
    
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::FireEvent
//
//  Synopsis:   Lock the document while firing an event. Central event firing routine
//              that supports non-bubbling, cancelable\non-cancelable events for any
//              object derived from CBase.
//
//  Arguments:  [pDoc]          -- The current document
//              [dispidEvent]   -- DISPID of event to fire
//              [dispidProp]    -- Dispid of prop storing event function
//              [pchEventType]  -- String of type of event; if NULL, caller needs to
//                                 push EVENTPARAM on stack, else this function does
//              [pfRet]         -- if specified event is Cancelable, result returned as bool
//                                 (false(0)==canceled, true(1)==default, vice-versa for onmouseover)
//              [fBubble]       -- does the event bubble? i.e is it called from BubbleEventHelper?
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CBase::FireEvent(
    CDoc *      pDoc,
    CElement *  pElement,
    CMarkup *   pMarkup,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    LPCTSTR     pchEventType,
    BOOL *      pfRet,
    BOOL        fBubble,
    IDispatch * pdispThis,
    EVENTINFO* pEvtInfo /*=NULL*/ )
{
    HRESULT         hr = S_OK;
    CVariant        varRet;
    IHTMLEventObj  *pEventObj = NULL;
    CScriptCollection * pScriptCollection;

    CDoc::CLock     Lock(pDoc);

    if (!pMarkup && pElement)
        pMarkup = pElement->GetMarkup();

    pScriptCollection = pMarkup ? pMarkup->GetScriptCollection() : NULL;

    if (pScriptCollection)
        pScriptCollection->AddRef();

    // EVENTPARAM not pushed if pchEventType==NULL, caller will push.
    EVENTPARAM param(pchEventType ? pDoc : NULL, pElement, pMarkup, TRUE);

    // Don't fire Doc events before init is complete.
    if (pDoc->_state < OS_LOADED) 
        goto Cleanup;


    if (pchEventType)
    {
        Assert(pDoc->_pparam == &param);
        param.SetType(pchEventType);
    }

    // Get the eventObject.
    Assert(pDoc->_pparam);
    CEventObj::Create(&pEventObj, pDoc, pElement, pMarkup);

    if ( pEvtInfo )
    {
        pEvtInfo->_dispId = dispidEvent;
        pEvtInfo->_pParam = new EVENTPARAM( pDoc->_pparam );

        if ( pEvtInfo->_fDontFireEvent )
            goto Cleanup;
    }

    hr = InvokeEvent(dispidEvent, dispidProp, pEventObj, &varRet, NULL, NULL, NULL, NULL, pdispThis);

    if (pfRet)
    {
        // if no event type passed in, caller should have pushed EVENTPARAM
        Assert(!pchEventType && pDoc->_pparam || pDoc->_pparam == &param);
        VARIANT_BOOL vb;
        if (fBubble && V_VT(&varRet) == VT_EMPTY)
            goto Cleanup;

        vb = (V_VT(&varRet) == VT_BOOL) ? V_BOOL(&varRet) : VB_TRUE;
        *pfRet = (VB_TRUE == vb) && (fBubble ? TRUE : !pDoc->_pparam->IsCancelled());
    }

Cleanup:
    if (pScriptCollection)
        pScriptCollection->Release();
    ReleaseInterface(pEventObj);
    RRETURN(hr);
}

void
CDoc::FlushUndoData()
{
    // Nuke undo/redo stacks.  Release references.

    UndoManager()->DiscardFrom(NULL);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryCreateUndo
//
//  Synopsis:   Query whether to create undo or not.  Also dirties 
//              the doc if fFlushOnError.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
BOOL 
CDoc::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = FALSE */, BOOL * pfTreeSync /* = NULL */)
{
    if( fDirtyChange )
    {
        switch( TLS(nUndoState) )
        {
        case UNDO_BASESTATE:
            if( _lDirtyVersion < 0 )
                // If someone has reset the dirty version and then called undo
                // multiple times, a regular action will make us permenantly dirty.
                _lDirtyVersion = MAXLONG;
            else
                _lDirtyVersion++;
            break;
        case UNDO_UNDOSTATE:
            _lDirtyVersion--;
            break;
        case UNDO_REDOSTATE:
            _lDirtyVersion++;
            break;
        }
    }

    return super::QueryCreateUndo( fRequiresParent, fDirtyChange, pfTreeSync );
}
#endif // NO_EDIT


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnFrameOptionScrollChange
//
//  Synopsis:   Called after scrolling of Frame option  has changed
//
//----------------------------------------------------------------------------
HRESULT
CDoc::OnFrameOptionScrollChange(void)
{
    ITargetFrame *  pTargetFrame = NULL;

    // Update Cached Frame flags.
    if (OK(THR_NOTRACE(QueryService(
            IID_ITargetFrame,
            IID_ITargetFrame,
            (void**)&pTargetFrame))))
    {
        CMarkup * pMarkup = PrimaryMarkup();
        DWORD dwFrameOptionsOld = pMarkup->GetFrameOptions();
        DWORD dwFrameOptionsNew;

        THR(pTargetFrame->GetFrameOptions(&dwFrameOptionsNew));
        pTargetFrame->Release();

        if (dwFrameOptionsNew != dwFrameOptionsOld)
        {
            CBodyElement * pBody;

            IGNORE_HR(pMarkup->GetBodyElement(&pBody));
    
            pMarkup->SetFrameOptions(dwFrameOptionsNew);

            //  For a BODY (not FRAMESET) document, resize the canvas.
            if (pBody)
            {
                CElement * pCanvas = pMarkup->GetCanvasElement();

                Assert(pCanvas);
                pCanvas->ResizeElement(NFLAGS_FORCE);
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallBackEnumChild
//
//  Synopsis:   Called from EnumChildWindows, used to determine if
//              we have child windows
//
//----------------------------------------------------------------------------

static BOOL CALLBACK
CallBackEnumChild(HWND hwnd, LPARAM lparam)
{
    *(BOOL *)lparam = (::GetFocus() == hwnd);

    return !(*(BOOL *)lparam);
}

BOOL
CDoc::HasFocus()
{
    BOOL    fHasFocus = FALSE;

    if (_pInPlace && _pInPlace->_hwnd)
    {
        Assert(IsWindow(_pInPlace->_hwnd));
        //
        // TODO: think about nested Popup
        //
        if (_fPopupDoc)
        {
            fHasFocus = TRUE;
        }
        else
        {
            fHasFocus = (::GetFocus() == _pInPlace->_hwnd);
        }
        if (!fHasFocus)
        {
            EnumChildWindows(_pInPlace->_hwnd, CallBackEnumChild, (LPARAM)&fHasFocus);
        }
    }

    return fHasFocus;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnterStylesheetDownload
//
//  Synopsis:   Note that a stylesheet is being downloaded
//
//--------------------------------------------------------------------

void
CDoc::EnterStylesheetDownload(DWORD * pdwCookie)
{
    if (*pdwCookie != _dwStylesheetDownloadingCookie)
    {
        *pdwCookie = _dwStylesheetDownloadingCookie;
        _cStylesheetDownloading++;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::LeaveStylesheetDownload
//
//  Synopsis:   Note that stylesheet is finished downloading
//
//--------------------------------------------------------------------

void
CDoc::LeaveStylesheetDownload(DWORD * pdwCookie)
{
    if (*pdwCookie == _dwStylesheetDownloadingCookie)
    {
        *pdwCookie = 0;
        _cStylesheetDownloading--;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetActiveXSafetyProvider
//
//  Synopsis:   Get an IActiveXSafetyProvider pointer, or return NULL if
//              there isn't one installed.
//
//-------------------------------------------------------------------------

HRESULT
   CDoc::GetActiveXSafetyProvider(IActiveXSafetyProvider **ppProvider)
{
    HRESULT hr;
    LONG l;
    HKEY hKey;

    if (_pActiveXSafetyProvider) {
        if (_pActiveXSafetyProvider == (IActiveXSafetyProvider *)-1) {
            //
            // A previous call has determined that there is no safety
            // provider installed.  Return S_OK, but set *ppProvider to NULL.
            //
            *ppProvider = NULL;
        } else {
            //
            // Use the cached ActiveXSafetyProvider.
            //
            *ppProvider = _pActiveXSafetyProvider;
        }
        TraceTag((tagCDoc, "CDoc::GetActiveXSafetyProvider returning cached value 0x%x", *ppProvider));
        return S_OK;
    }

    //
    // See if an IActiveXSafetyProvider is present by peeking into the
    // registry.
    //
    l = RegOpenKeyA(HKEY_CLASSES_ROOT,
                    "CLSID\\{aaf8c6ce-f972-11d0-97eb-00aa00615333}",
                    &hKey
                   );
    if (l != ERROR_SUCCESS) {
        //
        // No ActiveXSafetyProvider installed.  Cache this information.
        //
        _pActiveXSafetyProvider = (IActiveXSafetyProvider *)-1;
        *ppProvider = NULL;
        TraceTag((tagCDoc, "CDoc::GetActiveXSafetyProvider - provider not installed"));
        return S_OK;
    }
    else
        RegCloseKey(hKey);

    //
    // Call OLE to instantiate the ActiveXSafetyProvider.  If this fails,
    // _pActiveXSafetyProvider will remain NULL, so the operation will
    // be retried next time someone calls this routine.
    //
    hr = CoCreateInstance(CLSID_IActiveXSafetyProvider,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IActiveXSafetyProvider,
                          (void **)&_pActiveXSafetyProvider
                         );

    *ppProvider = _pActiveXSafetyProvider;
    TraceTag((tagCDoc, "CDoc::GetActiveXSafetyProvider - caching provider 0x%x", *ppProvider));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::GetWindowForBinding
//
//  Synopsis:   Gets a window for binding UI
//
//--------------------------------------------------------------------

void
CDoc::GetWindowForBinding(HWND * phwnd)
{
    IOleWindow *        pOleWindow = NULL;

    // try in-place window
    *phwnd = GetHWND();

    // try client site window
    if (!*phwnd && _pClientSite)
        if (!_pClientSite->QueryInterface(IID_IOleWindow, (void **)&pOleWindow))
            IGNORE_HR(pOleWindow->GetWindow(phwnd));

    // resort to desktop window
    if (!*phwnd)
        *phwnd = GetDesktopWindow();

    ReleaseInterface(pOleWindow);
}



//+-------------------------------------------------------------------
//
//  Member:     CDoc::GetWindow, IWindowForBindingUI
//
//  Synopsis:   Default implementation of the IWindowForBindingUI
//              service
//
//--------------------------------------------------------------------

HRESULT
CDoc::GetWindowBindingUI(REFGUID rguidReason, HWND * phwnd)
{
    if (IsPrintDialogNoUI())
    {
        *phwnd = HWND_DESKTOP;
        return S_OK;
    }

    if (_dwLoadf & DLCTL_SILENT)
    {
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
        return(S_FALSE);
    }

    GetWindowForBinding(phwnd);

    return S_OK;
}



//+-------------------------------------------------------------------
//
//  Member:     CDoc::Authenticate, IAuthenticate
//
//  Synopsis:   Default implementation of the IAuthenticate service
//
//--------------------------------------------------------------------

HRESULT
CDoc::Authenticate(HWND * phwnd, LPWSTR * ppszUsername, LPWSTR * ppszPassword)
{
    if (_dwLoadf & DLCTL_SILENT)
        *phwnd = (HWND)-1;
    else
    {
        GetWindowForBinding(phwnd);
    }

    *ppszUsername = NULL;
    *ppszPassword = NULL;

    return(S_OK);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::ShowLoadError
//
//  Synopsis:   Shows a message box stating that the document could
//              not be loaded, the URL, and the reason.
//
//--------------------------------------------------------------------

HRESULT
CDoc::ShowLoadError(CHtmCtx *pHtmCtx)
{
    TCHAR *pchMessage = NULL;
    TCHAR achReason[256];
    TCHAR *pchReason;
    HRESULT hr;

    // If there was an explicit error-reason message, show it
    pchReason = pHtmCtx->GetErrorString();

    // Otherwise, format up a generic error message based on GetBindResult
    if (!pchReason)
    {
        hr = THR(GetErrorText(pHtmCtx->GetBindResult(), achReason, ARRAY_SIZE(achReason)));
        if (hr)
            goto Cleanup;

        pchReason = achReason;
    }

    // Internet Explorer cannot open the internet site <url>.\n<reason>

    hr = THR(Format(FMT_OUT_ALLOC,
           &pchMessage,
           64,
           MAKEINTRESOURCE(IDS_CANNOTLOAD),
           GetPrimaryUrl(),
           pchReason));
    if (hr)
        goto Cleanup;

    hr = THR(ShowMessageEx(NULL,
                  MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                  NULL,
                  0,
                  pchMessage));
    if (hr)
        goto Cleanup;

Cleanup:
    MemFree(pchMessage);

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::MoveSystemCaret
//
//  Synopsis:   Decides if the system caret should be moved to track
//              user moves ---  for accessibility purposes.
//
//--------------------------------------------------------------------
extern BOOL g_fScreenReader;

BOOL
CDoc::MoveSystemCaret()
{
    BOOL fMove = g_fScreenReader;

    //
    // If the screen reader is installed, then ignore what the registry says,
    // and always move the system caret.
    //
    if (!fMove)
    {
        //
        // If screen reader is not installed, then we need to look at what
        // registry has to say about moving the system caret.
        //
        HRESULT hr = THR(UpdateFromRegistry());
        if (hr)
            goto Cleanup;

        fMove = _pOptionSettings->fMoveSystemCaret;
    }

Cleanup:
    return fMove;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::suspendRecalc
//
//--------------------------------------------------------------------
STDMETHODIMP
CDoc::suspendRecalc(BOOL fSuspend)
{
    RRETURN(_recalcHost.SuspendRecalc(!!fSuspend));
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::SetCpAutoDetect 
//
//  Synopsis:   Set the flag that indicates cp is to be auto-detected
//              [review] this also refresh the 'autodetect' reg entry
//                       could we find better place to do this?
//
//  Returns:    S_OK - if auto detect is flipped
//
//--------------------------------------------------------------------
static const TCHAR s_szAutoDetect[] = TEXT("AutoDetect");
static const TCHAR s_szDefaultCodepage[] = TEXT("Default_CodePage");
HRESULT
CDoc::SetCpAutoDetect(BOOL fSet)
{
    HRESULT hr = S_OK;

    if (_pOptionSettings)
    {
        if (_pOptionSettings->fCpAutoDetect != fSet)
        {
            DWORD dwWrite;
            CStr  cstrPath;

            hr = THR(cstrPath.Set(NULL, _tcslen(_pOptionSettings->achKeyPath)+_tcslen(s_szPathInternational)+1));
            if (hr)
                goto Cleanup;

            _tcscpy(cstrPath, _pOptionSettings->achKeyPath);
            _tcscat(cstrPath, s_szPathInternational);

            dwWrite = fSet ? 1 : 0;

            hr =  SHSetValue(HKEY_CURRENT_USER, cstrPath,  s_szAutoDetect, REG_DWORD, 
                             (void*)&dwWrite,  sizeof(dwWrite));

            if (hr == NO_ERROR)
            {
                _pOptionSettings->fCpAutoDetect = !!fSet;
            }
        }
    }
    else
        hr = E_FAIL;
Cleanup:
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsCpAutoDetect 
//
//  Synopsis:   Get the flag that indicates cp is to be auto-detected
//
//  Returns:    BOOL true if auto mode is set
//
//--------------------------------------------------------------------

BOOL
CDoc::IsCpAutoDetect(void)
{
    BOOL bret;

    if (_pOptionSettings)
        bret = (BOOL)_pOptionSettings->fCpAutoDetect;
    else
        bret = FALSE;

    return bret;
}

HRESULT
CDoc::SaveDefaultCodepage(CODEPAGE cp)
{
    HRESULT hr = S_OK;
    if (_pOptionSettings)
    {
        if ( _pOptionSettings->codepageDefault != cp)
        {
            CStr cstrPath;
            hr = THR(cstrPath.Set(NULL, _tcslen(_pOptionSettings->achKeyPath)+_tcslen(s_szPathInternational)+1));
            if (hr)
                goto Cleanup;

            _tcscpy(cstrPath, _pOptionSettings->achKeyPath);
            _tcscat(cstrPath, s_szPathInternational);

            hr =  SHSetValue(HKEY_CURRENT_USER, cstrPath, s_szDefaultCodepage, 
                                               REG_BINARY, (void *)&cp, sizeof(cp));
            if (hr == NO_ERROR)
                _pOptionSettings->codepageDefault = cp;
        }
    }
Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::QueryVersionHost
//
//  Synopsis:   Sets up the local or global CVersions object
//
//----------------------------------------------------------------------------

HRESULT
CDoc::QueryVersionHost()
{
    HRESULT hr = S_OK;
    IVersionHost *pVersionHost = NULL;
    IVersionVector *pVersionVector = NULL;
    BOOL fUseLocal = FALSE;
    CVersions *pVersions = NULL;

    HKEY hkey = NULL;

    // This code use to return S_OK if there is a _pVersion, however, there 
    // should no longer be path that calls QueryVersionHost in such a case
    Assert(!_pVersions);

    if (!OK(THR_NOTRACE(QueryService(
            SID_SVersionHost,
            IID_IVersionHost,
            (void**)&pVersionHost))))
    {
        pVersionHost = NULL;

        pVersions = GetGlobalVersions();
        if (!pVersions)
            fUseLocal = TRUE;
    }
    else
    {
        hr = THR(pVersionHost->QueryUseLocalVersionVector(&fUseLocal));
        if (hr)
            goto Cleanup;

        if (!fUseLocal)
        {
            pVersions = GetGlobalVersions();
        }
    }

    if (!pVersions)
    {
        pVersions = new CVersions();
        if (pVersions == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pVersions->Init());
        if (hr)
            goto Cleanup;

        hr = THR(pVersions->GetVersionVector(&pVersionVector));
        if (hr)
            goto Cleanup;

        // Enumerate through the HKLM\Software\Microsoft\Internet Explorer\Version Vector key
        // setting versions.
        // We should always find at least "IE", "x.x.xxxx", which is registered in selfreg.inx.
        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Internet Explorer\\Version Vector"),
                &hkey) == ERROR_SUCCESS)
        {
            for (int iValue = 0; ;iValue++)
            {
                OLECHAR    wszValue[256];
                OLECHAR    wszVersion[256];
                DWORD      dwType;
                DWORD      cchValue = ARRAY_SIZE(wszValue);
                DWORD      cchVersion = ARRAY_SIZE(wszVersion);

                if (SHEnumValueW(hkey, iValue, wszValue, &cchValue, 
                                 &dwType, wszVersion, &cchVersion)==ERROR_SUCCESS)
                {
                    // TODO (alexz) in IE5, we disable VML for OE4 and Outlook98, per IE5 bug 69437
                    if ((_fOE4 || _fOutlook98) && wszValue && 0 == StrCmpIC(_T("VML"), wszValue))
                        continue;

                    hr = pVersionVector->SetVersion(wszValue, wszVersion);
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    break;
                }
            }
        }

        // Now give the host a chance to set some version vector info.
        if (pVersionHost)
        {
            hr = THR(pVersionHost->QueryVersionVector(pVersionVector));
            if (hr)
                goto Cleanup;
        }

        if (!fUseLocal)
        {
            if (!SuggestGlobalVersions(pVersions))
            {
                // Another thread has won the race to supply a global version; get it
                pVersions->Release();
                pVersions = GetGlobalVersions();
                Assert(pVersions);
            }
        }
    }
    Assert(pVersions);

    _pVersions = pVersions;
    pVersions = NULL;

Cleanup:
    if (pVersions)
        pVersions->Release();
    ReleaseInterface(pVersionHost);
    ReleaseInterface(pVersionVector);

    if (hkey != NULL)
        RegCloseKey(hkey);
        
    RRETURN(hr);
}

//-----------------------------------------------------------------------------
//
//  Function:   CDoc::FaultInUSP
//
//  Synopsis:   Async callback to JIT install UniScribe (USP10.DLL)
//
//  Arguments:  DWORD (CDoc *)  The current doc from which the hWnd can be gotten
//
//  Returns:    none
//
//-----------------------------------------------------------------------------

void CDoc::FaultInUSP(DWORD_PTR dwContext)
{
    HRESULT hr;
    uCLSSPEC classpec;
    CStr cstrGUID;
    ULONG cDie = _cDie;
    BOOL  fRefresh = FALSE;

    PrivateAddRef();

    g_csJitting.Enter();

    Assert(g_bUSPJitState == JIT_PENDING);

    // Close the door. We only want one of these running.
    g_bUSPJitState = JIT_IN_PROGRESS;

    // Set the GUID for USP10 so JIT can lookup the feature
    cstrGUID.Set(TEXT("{b1ad7c1e-c217-11d1-b367-00c04fb9fbed}"));

    // setup the classpec
    classpec.tyspec = TYSPEC_CLSID;
    hr = CLSIDFromString((BSTR)cstrGUID, &classpec.tagged_union.clsid);

    if(hr == S_OK)
    {
        hr = THR(FaultInIEFeatureHelper(GetHWND(), &classpec, NULL, 0));
    }

    // if we succeeded or the document navigated away (process was killed in
    // CDoc::UnloadContents) set state to JIT_OK so IOD can be attempted
    // again without having to restart the host.
    if(hr == S_OK)
    {
        g_bUSPJitState = JIT_OK;
        if(cDie == _cDie)
            fRefresh = TRUE;
    }
    else
    {
        // The user cancelled or aborted. Don't ask for this again
        // during this session.
        g_bUSPJitState = JIT_DONT_ASK;
    }

    g_csJitting.Leave();
    
    // refresh the view if we have just installed.
    if(fRefresh)
    {
        _view.EnsureView(LAYOUT_SYNCHRONOUS | LAYOUT_FORCE);
    }

    PrivateRelease();
}

//-----------------------------------------------------------------------------
//
//  Function:   CDoc::FaultInJG
//
//  Synopsis:   Async callback to JIT install JG ART library for AOL (JG*.DLL)
//
//-----------------------------------------------------------------------------

void CDoc::FaultInJG(DWORD_PTR dwContext)
{
    HRESULT hr;
    uCLSSPEC classpec;
    CStr cstrGUID;

    if (g_bJGJitState != JIT_PENDING)
        return;

    // Close the door. We only want one of these running.
    g_bJGJitState = JIT_IN_PROGRESS;

    HWND hWnd = GetHWND();
    // Set the GUID for JG*.dll so JIT can lookup the feature
    cstrGUID.Set(_T("{47f67d00-9e55-11d1-baef-00c04fc2d130}"));

    // setup the classpec
    classpec.tyspec = TYSPEC_CLSID;
    hr = CLSIDFromString((BSTR) cstrGUID, &classpec.tagged_union.clsid);

    if (hr == S_OK)
    {
        hr = THR(FaultInIEFeatureHelper(hWnd, &classpec, NULL, 0));
    }

    // if we succeeded or the document navigated away (process was killed in
    // CDoc::UnloadContents) set state to JIT_OK so IOD can be attempted
    // again without having to restart the host.
    if (hr == S_OK)
    {
        g_bJGJitState = JIT_OK;
    }
    else
    {
        // The user cancelled or aborted. Don't ask for this again
        // during this session.
        g_bJGJitState = JIT_DONT_ASK;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::ExpandedRelativeUrlInVariant
//
//  Synopsis:   Used by CBase::getAttribute to expand an URL if the property
//              retrieved is an URL and the GETMEMBER_ABSOLUTE is specified.
//
//----------------------------------------------------------------------------

HRESULT
CBase::ExpandedRelativeUrlInVariant(VARIANT *pVariantURL)
{
    HRESULT         hr = S_OK;
    TCHAR           cBuf[pdlUrlLen];
    TCHAR          *pchUrl = cBuf;

    if (pVariantURL && V_VT(pVariantURL) == VT_BSTR)
    {
        BSTR            bstrURL;
        IHTMLElement   *pElement;
        CElement       *pCElement;

        // Are we really an element?
        if (!PrivateQueryInterface(IID_IHTMLElement, (void **)&pElement))
        {
            ReleaseInterface(pElement);

            pCElement = DYNCAST(CElement, this);

            hr = CMarkup::ExpandUrl(
                pCElement->GetMarkup(), V_BSTR(pVariantURL), 
                ARRAY_SIZE(cBuf), pchUrl, pCElement);
            if (hr)
                goto Cleanup;

            hr = FormsAllocString(pchUrl, &bstrURL);
            if (hr)
                goto Cleanup;

            VariantClear(pVariantURL);

            V_BSTR(pVariantURL) = bstrURL;
            V_VT(pVariantURL) = VT_BSTR;
        }
    }
    else
        hr = S_OK;

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DeferSetCursor
//
//  Synopsis:   After scrolling we want to post a setcursor message to our
//              window so that the cursor shape will get updated. However,
//              because of nested scrolls, we might end up with multiple
//              setcursor calls. To avoid this, we will post a method call
//              to the function which actually does the postmessage. During
//              the setup of the method call we will delete any existing
//              callbacks, and hence this will delete any existing callbaks.
//
//----------------------------------------------------------------------------
void
CDoc::DeferSetCursor()
{
    if ( _fDisableReaderMode )
        return;
        
    GWKillMethodCall (this, ONCALL_METHOD(CDoc, SendSetCursor, sendsetcursor), 0);
    IGNORE_HR(GWPostMethodCall (this,
                                ONCALL_METHOD(CDoc, SendSetCursor, sendsetcursor),
                                0, FALSE, "CDoc::SendSetCursor"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SendMouseMessage
//
//  Synopsis:   This function actually posts the message to our window.
//
//----------------------------------------------------------------------------
void
CDoc::SendSetCursor(DWORD_PTR dwContext)
{
    // First be sure that we are all OK
    // Do this only if we have focus. We don't want to generate mouse events
    // when we do not have focus (bug 9144)
    
    if (    _pInPlace
        &&  _pInPlace->_hwnd
        &&  HasFocus() )
    {
        CPoint  pt;
        CRect   rc;

        ::GetCursorPos(&pt);
        ::ScreenToClient(_pInPlace->_hwnd, &pt);
        ::GetClientRect(_pInPlace->_hwnd, &rc);

        // Next be sure that the mouse is in our client rect and only then
        // post ourselves the message.
        if (rc.Contains(pt))
        {
            ::PostMessage(_pInPlace->_hwnd, WM_SETCURSOR, (WORD)_pInPlace->_hwnd, HTCLIENT);
        }
    }
}


//+====================================================================================
//
// Method: SetClick
//
// Synopsis: Enable the Setting and passing of click messages
//
//------------------------------------------------------------------------------------

VOID
CDoc::SetClick(CMessage* pMessage)
{
    pMessage->SetNodeClk(pMessage->pNodeHit);
}


//+==========================================================
//
// Method: UpdateCaret
//
// Synopsis: Informs the caret that it's position has been
//           changed externally.
//
//-----------------------------------------------------------

HRESULT
CDoc::UpdateCaret(
    BOOL        fScrollIntoView,    //@parm If TRUE, scroll caret into view if we have
                                    // focus or if not and selection isn't hidden
    BOOL        fForceScroll,       //@parm If TRUE, scroll caret into view regardless
    CDocInfo *  pdci )
{
    HRESULT hr = S_OK;

    if( _pCaret )
        hr = _pCaret->UpdateCaret( fScrollIntoView, fForceScroll, pdci );

    RRETURN( hr );
}

//+==========================================================
//
// Method: UpdateCaretPosition
//
// Synopsis: Repositions the caret at the given point.
//
//-----------------------------------------------------------

HRESULT
CDoc::UpdateCaretPosition(CLayout *pLayout, POINTL ptlScreen)
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pElement = NULL;
    IDisplayPointer     *pDispCaret = NULL;

    if (_pCaret)
    {
        CPoint          pt;

        Assert(pLayout && pLayout->ElementContent());
        Assert(_pInPlace && _pInPlace->_hwnd);

        //  Convert from screen coordinates.
        pt.x = ptlScreen.x;
        pt.y = ptlScreen.y;

        ScreenToClient( _pInPlace->_hwnd, (POINT*) & pt );

        pLayout->TransformPoint( &pt, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT, NULL );
        IFC( pLayout->ElementContent()->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElement) );

        //  Create a display pointer at the new caret position
        IFC( CreateDisplayPointer( & pDispCaret ));
        
        g_uiDisplay.DocPixelsFromDevice(&pt);
        IFC( pDispCaret->MoveToPoint(pt, COORD_SYSTEM_CONTENT, pElement, 0, NULL) );

        //  Move the caret to the display pointer
        _pCaret->MoveCaretToPointerEx( pDispCaret, _pCaret->IsVisible(), FALSE, CARET_DIRECTION_INDETERMINATE );
    }

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pDispCaret);
    RRETURN( hr );
}

//+==========================================================
//
// Method: HandleSelectionMessage
//
// Synopsis: Dispatch a message to the Selection Manager if it exists.
//
//
//-----------------------------------------------------------
HRESULT
CDoc::HandleSelectionMessage(
            CMessage   *pMessage,
            BOOL        fForceCreate ,
            EVENTINFO  *pEvtInfo ,
            HM_TYPE     eHMType )
{
    BOOL            fNeedToSetEditContext   = FALSE;
    BOOL            fAllowSelection         = TRUE;
    IHTMLEventObj * pEventObj               = NULL;
    HRESULT         hr                      = S_FALSE;
    HRESULT         hr2;
    BOOL            fReleasepNode           = FALSE;
    BOOL            fReleasepNodeHit        = FALSE;
    IHTMLEditor   * ped                     = NULL;
    CElement      * pEditElement            = NULL;

    if (pMessage->fSelectionHMCalled)
        goto Cleanup;

    if ( (pMessage->pNodeHit) &&
         (pMessage->pNodeHit->Element() == PrimaryRoot() ) )
        goto Cleanup;

    if ( pMessage->pNodeHit )
        pEditElement = pMessage->pNodeHit->Element();
    else
        pEditElement = NULL;

    AssertSz( !_pDragStartInfo || ( _pDragStartInfo && pMessage->message != WM_MOUSEMOVE ),
              "Sending a Mouse Message to the tracker during a drag !");

    //
    // We just got a mouse down. If the element is not editable,
    // we need to set the Edit Context ( as SetEditContext may not have already happened)
    // If we don't do this the manager may not have a tracker for the event !
    //
    // 

    //
    // Don't set edit context on mouse down in scrollbars - as TranslateAccelerator in the editor
    // will ignore these messages anyway.
    //
    //
    // marka - this is ok - as we will move the SetEditContext code into the editor anyway.
    //
    
    fNeedToSetEditContext = (pEditElement  && 
                             _pElemCurrent && _pElemCurrent->_etag != ETAG_ROOT &&
                            (ShouldSetEditContext( pMessage ) && 
                             pMessage->htc != HTC_VSCROLLBAR && 
                             pMessage->htc != HTC_HSCROLLBAR  )) ; 
               
    if ( fNeedToSetEditContext )             // we only check if we think we need to set the ed. context
        fAllowSelection = pEditElement && ! pEditElement->DisallowSelection() ;

   ped = GetHTMLEditor( fForceCreate || ( fNeedToSetEditContext && fAllowSelection ) );


    // Block selection handling for layout rects;  we don't want
    // the editor drilling into our contained content.
    if ( pEditElement && pEditElement->IsLinkedContentElement() )
        goto Cleanup;

    if ( ped && (pMessage->pNodeHit == NULL || !pMessage->pNodeHit->IsDead()) &&
                (pEvtInfo->_pParam->_pNode == NULL || !pEvtInfo->_pParam->_pNode->IsDead()) )
    {   
        //
        // NOTE. We set the _lButton based on the message type
        // Some automation harnesses (VID) - cookup messages without setting the mouse button
        //
        
        switch( pMessage->message )
        {
            case WM_LBUTTONDOWN:
                pEvtInfo->_pParam->_lButton |= 1;
            break;

            case WM_RBUTTONDOWN:
                pEvtInfo->_pParam->_lButton |= 2;
            break;

            case WM_MBUTTONDOWN:
                pEvtInfo->_pParam->_lButton |= 4;
            break;
        }

        //
        // NOTE - hide the root - to show the Master if we're viewlinked.
        // 
        if ( pEditElement &&
             pEditElement->_etag == ETAG_ROOT &&
             pEditElement->HasMasterPtr() )
        {
            Assert( pEditElement->GetFirstBranch() == pEvtInfo->_pParam->_pNode ||
                    pEditElement->GetMasterPtr()->GetFirstBranch() == pEvtInfo->_pParam->_pNode);
            
            pEditElement = pEditElement->GetMasterPtr();
            pEvtInfo->_pParam->SetNodeAndCalcCoordinates(pEditElement->GetFirstBranch(), TRUE);
            // pEvtInfo->_pParam->SetNodeAndCalcCoordinates(pEditElement->GetFirstBranch(), TRUE);
        }
        
        CEventObj::Create(&pEventObj, this, pEditElement, NULL, FALSE, NULL, pEvtInfo->_pParam);

        ped->AddRef();

        if(pMessage->pNodeHit)
        {
            hr2 = THR( pMessage->pNodeHit->NodeAddRef() );
            if( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }
            fReleasepNodeHit = TRUE;
        }
        if(pEvtInfo->_pParam->_pNode)
        {
            hr2 = THR( pEvtInfo->_pParam->_pNode->NodeAddRef() );
            if( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }
            fReleasepNode = TRUE;
        }

        switch( eHMType )
        {
            case HM_Pre:
            hr = THR( ped->PreHandleEvent( pEvtInfo->_dispId, pEventObj ));
            if ( hr != S_FALSE )
            {
                pMessage->fSelectionHMCalled = TRUE;                
            }
            break;

            case HM_Post:
            hr = THR( ped->PostHandleEvent( pEvtInfo->_dispId, pEventObj ));
            pMessage->fSelectionHMCalled = TRUE;                
            break;

            case HM_Translate:
            hr = THR( ped->TranslateAccelerator( pEvtInfo->_dispId, pEventObj ));
            if ( hr != S_FALSE )
            {
                pMessage->fSelectionHMCalled = TRUE;                
            }                
            break;
            
        }

        //
        // Check the return value and pass it back
        // to WndProc
        // 
        // TODO: 
        // I will only do it for IME RECONVERSION 
        // messages currently. However We should 
        // always check for return value and set it
        // This can be reconsidered and modified in
        // the future. 
        // (zhenbinx)
        //
#if !defined(NO_IME)            
        #ifndef WM_IME_REQUEST
        #define WM_IME_REQUEST 0x0288
        #endif
        if (S_OK == hr)
        {
            switch (pMessage->message)
            {
            case WM_IME_REQUEST:
                {
                    TraceTag((tagEdSelMan, "Pass lresult back to WndProc"));
                    VARIANT  v;
                    VariantInit(&v);    
                    THR( pEventObj->get_returnValue(&v) );
                    switch (V_VT(&v))
                    {
                        case    VT_I2:
                                pMessage->lresult = V_I2(&v);
                                break;
                                
                        case    VT_I4:
                                pMessage->lresult = V_I4(&v);
                                break;
                                
                        case    VT_BOOL:
                                pMessage->lresult = (LRESULT)(
                                        V_BOOL(&v) == VARIANT_TRUE ? TRUE : FALSE 
                                            );
                                break;
                    }
                    TraceTag((tagEdSelMan, "pMessage->lresult = %d - %x", pMessage->lresult, pMessage->lresult));
                    VariantClear(&v);
                }
                
            }
        }
#endif
        ped->Release();
    }

Cleanup:
    if( pMessage->pNodeHit && fReleasepNodeHit )
    {
        pMessage->pNodeHit->NodeRelease();
    }
    
    if( pEvtInfo->_pParam->_pNode && fReleasepNode )
    {
        // Windows security push bug 536319 
        // pNode is pointing to a garbage now since HandleSelection Message
        // is the only one AddRef pNode so we know it has to be a garbage now
        // if it is dead. 
        // 
        BOOL fDeadNode = pEvtInfo->_pParam->_pNode->IsDead();
        pEvtInfo->_pParam->_pNode->NodeRelease();
        if (fDeadNode)
        {
            pEvtInfo->_pParam->_pNode = NULL;
            // STOP routing message to editor as well since the event node will be a garbage
            pMessage->fSelectionHMCalled = TRUE;
        }
    }

    ReleaseInterface( pEventObj );
    RRETURN1( hr, S_FALSE );
}

#if !defined(NO_IME)
#ifndef WM_IME_REQUEST
#define WM_IME_REQUEST 0x0288
#endif
#endif

HRESULT
CDoc::CreateIMEEventInfo(CMessage * pMessage, EVENTINFO * pEvtInfo, CElement * pElement) 
{
    HRESULT hr = S_OK ;
    EVENTPARAM *pparam = NULL;
    LPTSTR pchType = NULL;    

    Assert(  pMessage &&
             ( pMessage->message == WM_IME_STARTCOMPOSITION ||
               pMessage->message == WM_IME_ENDCOMPOSITION || 
               pMessage->message == WM_IME_COMPOSITIONFULL ||
               pMessage->message == WM_IME_CHAR ||
               pMessage->message == WM_IME_COMPOSITION ||
               pMessage->message == WM_IME_NOTIFY ||
               pMessage->message == WM_INPUTLANGCHANGE ||
               pMessage->message == WM_IME_REQUEST ) );
               
    switch(pMessage->message)
    {
    case WM_IME_STARTCOMPOSITION:
        pchType = _T("startComposition");
        break;

    case WM_IME_ENDCOMPOSITION:
        pchType = _T("endComposition");
        break;

    case WM_IME_COMPOSITIONFULL:
        pchType = _T("compositionFull");
        break;

    case WM_IME_CHAR:
        pchType = _T("char");
        break;

    case WM_IME_COMPOSITION:
        pchType = _T("composition");
        break;

    case WM_IME_NOTIFY:
        pchType = _T("notify");
        break;

    case WM_INPUTLANGCHANGE:
        pchType = _T("inputLangChange");
        break;
        
    case WM_IME_REQUEST:
        pchType = _T("imeRequest");
        break;
    }

    if (pchType)
    {
        pparam = new EVENTPARAM(this, pElement, NULL, FALSE, FALSE);
        if (!pparam)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        switch(pMessage->message)
        {
        case WM_IME_COMPOSITION:
            pparam->_lParam = pMessage->lParam;
            break;

        case WM_IME_NOTIFY:
            pparam->_wParam = pMessage->wParam;
            pparam->_lParam = pMessage->lParam;
            break;

        case WM_INPUTLANGCHANGE:
            pparam->_lParam = pMessage->lParam;
            break;

        case WM_IME_REQUEST:
            pparam->_wParam = pMessage->wParam;
            pparam->_lParam = pMessage->lParam;
            break;
            
        }

        pparam->SetType(pchType);
        
        Assert(!pEvtInfo->_pParam);
        pEvtInfo->_pParam = pparam;
        pEvtInfo->_dispId = 0;
    }

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::CreateDblClickInfo
//
//  Synopsis:   Creates an "internal" double-click message so the editor is
//              able to synchronize with the real windows LBUTTONDBLCLK message
//              instead of Trident's delayed DBLCLICK event.  See CDoc::PumpMessage
//              or bug 86923 for more details.
//
//  Arguments:  pMessage = CMessage corresponding to LBUTTONDBLCLK
//              pEvtInfo = Event info struct to fill out
//              pElement = Element where event was fired
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CDoc::CreateDblClickInfo(   CMessage    *pMessage, 
                            EVENTINFO   *pEvtInfo, 
                            CTreeNode   *pNodeContext,
                            CTreeNode   *pNodeEvent /* = NULL */ )
{
    HRESULT     hr = S_OK ;
    EVENTPARAM  *pparam = NULL;         // Event parameters
    POINT       ptScreen;               // Screen coords
    
    CTreeNode   *pNodeSrcElement = pNodeEvent ? pNodeEvent : pNodeContext;
    
    Assert( pMessage && pMessage->message == WM_LBUTTONDBLCLK && pNodeSrcElement && pNodeContext );
               
    //
    // Create new event param
    //
    pparam = new EVENTPARAM(this, pNodeContext->Element(), NULL, FALSE, FALSE);
    if (!pparam)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ptScreen.x = pMessage->pt.x;
    ptScreen.y = pMessage->pt.y;

    //
    // Setup the parameters that this event will use.  These may or 
    // may not be used by the editor, but just in case, we should have
    // them.  Modeled after CElement::FireStdEvent_MouseHelper()
    // 
    pparam->_htc = pMessage->htc;
    pparam->_lBehaviorCookie = pMessage->lBehaviorCookie;
    pparam->_lBehaviorPartID = pMessage->lBehaviorPartID;

    pparam->_pLayoutContext = pMessage->pLayoutContext;
    
    pparam->SetNodeAndCalcCoordinates(pNodeSrcElement);

    //
    // Setup the coordinates of this event
    //
    pparam->SetClientOrigin(pNodeContext->Element(), &pMessage->pt);

    if( _pInPlace )
        ClientToScreen( _pInPlace->_hwnd, &ptScreen );
        
    pparam->_screenX = ptScreen.x;
    pparam->_screenY = ptScreen.y;

    //
    // Misc information about keyboard states
    //
    pparam->_sKeyState = VBShiftState();

    pparam->_fShiftLeft = !!(GetKeyState(VK_LSHIFT) & 0x8000);
    pparam->_fCtrlLeft = !!(GetKeyState(VK_LCONTROL) & 0x8000);
    pparam->_fAltLeft = !!(GetKeyState(VK_LMENU) & 0x8000);

    pparam->_lButton = VBButtonState( (short)pMessage->wParam );

    // Name of our internal hacky event
    pparam->SetType(_T("intrnlDblClick"));
    
    Assert(!pEvtInfo->_pParam);
    pEvtInfo->_pParam = pparam;
    pEvtInfo->_dispId = 0;

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Select
//
// Synopsis: 'Select from here to here' a wrapper to the selection manager.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::Select( ISegmentList* pSegmentList )
{
    HRESULT             hr = S_OK; 
    ISelectionObject2   *pISelObject = NULL;       
            
    hr = THR( GetSelectionObject2( &pISelObject ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( pISelObject->Select( pSegmentList ));  
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: Select
//
// Synopsis: 'Select from here to here' a wrapper to the selection manager.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::Select( 
                IMarkupPointer* pStart, 
                IMarkupPointer* pEnd, 
                SELECTION_TYPE eType )
{
    HRESULT             hr = S_OK;
    IHTMLEditServices   *pIServices = NULL;

    hr = THR( GetEditServices( &pIServices ) );
    if ( hr )
        goto Cleanup;
       
    hr = THR( pIServices->SelectRange( pStart, pEnd, eType ));  
        
Cleanup:
    ReleaseInterface( pIServices );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: EmptySelection
//
// Synopsis: Empties the current selection and hides the caret
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::EmptySelection()
{
    HRESULT             hr = S_OK;
    ISelectionObject2   *pISelObject = NULL;       

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionObject2( &pISelObject ) );
        if ( hr )
            goto Cleanup;
      
        hr = THR( pISelObject->EmptySelection() );  
    }
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );  
}

//+====================================================================================
//
// Method:      DestroyAllSelection
//
// Synopsis:    Removes the current selection
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::DestroyAllSelection()
{
    HRESULT             hr = S_OK;
    ISelectionObject2   *pISelObject = NULL;       

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionObject2( &pISelObject ) );
        if ( hr )
            goto Cleanup;
      
        hr = THR( pISelObject->DestroyAllSelection() );  
    }
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );

}

//+====================================================================================
//
// Method:      DestroySelection
//
// Synopsis:    Removes the current selection, and clears adorners
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::DestroySelection()
{
    HRESULT             hr = S_OK;
    ISelectionObject2   *pISelObject = NULL;       

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionObject2( &pISelObject ) );
        if ( hr )
            goto Cleanup;
      
        hr = THR( pISelObject->DestroySelection() );  
    }
        
Cleanup:
    ReleaseInterface( pISelObject );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsElementSiteselectable
//
// Synopsis: Determine if a given elemnet is site selectable by asking mshtmled.dll.
//
//------------------------------------------------------------------------------------



BOOL
CDoc::IsElementSiteSelectable( CElement* pCurElement, CElement** ppSelectThis /* = NULL*/ )
{
    HRESULT hr = S_OK;
    HRESULT hrSiteSelectable = S_FALSE;
    IHTMLEditor* ped = NULL;
    IHTMLEditingServices * pIEditingServices = NULL;
    IHTMLElement * pICurElement = NULL;    
    IHTMLElement* pISelectThis = NULL;
    
    ped = GetHTMLEditor( TRUE );        
    Assert( ped );

    if ( ppSelectThis )
        *ppSelectThis = NULL;
        
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void** ) & pIEditingServices));
        if ( hr )
            goto Cleanup;
        hr = THR( pCurElement->QueryInterface( IID_IHTMLElement, (void**) & pICurElement));
        if ( hr)
            goto Cleanup;
            
        hrSiteSelectable = pIEditingServices->IsElementSiteSelectable( pICurElement, 
                                                                       ppSelectThis ? & pISelectThis : NULL  );

        if ( hrSiteSelectable == S_OK  && ppSelectThis )
        {
            Assert( pISelectThis );

            hr = THR( pISelectThis->QueryInterface( CLSID_CElement, (void**) ppSelectThis ));
            if ( hr)
                goto Cleanup;            
        }
    }
    
Cleanup:
    ReleaseInterface( pICurElement);
    ReleaseInterface( pISelectThis );
    ReleaseInterface( pIEditingServices);
    
    return ( hrSiteSelectable == S_OK );
}

//+====================================================================================
//
// Method: IsElementUIActivatable
//
// Synopsis: Determine if a given elemnet is site selectable by asking mshtmled.dll.
//
//------------------------------------------------------------------------------------



BOOL
CDoc::IsElementUIActivatable( CElement* pCurElement)
{
    HRESULT hr = S_OK;
    HRESULT hrActivatable = S_FALSE;
    IHTMLEditor* ped = NULL;
    IHTMLEditingServices * pIEditingServices = NULL;
    IHTMLElement * pICurElement = NULL;    
    
    ped = GetHTMLEditor( TRUE );        
    Assert( ped );

    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void** ) & pIEditingServices));
        if ( hr )
            goto Cleanup;
        hr = THR( pCurElement->QueryInterface( IID_IHTMLElement, (void**) & pICurElement));
        if ( hr)
            goto Cleanup;
            
        hrActivatable = pIEditingServices->IsElementUIActivatable( pICurElement );
    }
    
Cleanup:
    ReleaseInterface( pICurElement);
    ReleaseInterface( pIEditingServices);
    
    return ( hrActivatable  == S_OK );
}

//+====================================================================================
//
// Method: IsElementSiteselected
//
// Synopsis: Determine if a given elemnet is currently site selected 
//
//------------------------------------------------------------------------------------
BOOL
CDoc::IsElementSiteSelected( CElement* pCurElement)
{
    HRESULT                 hr = S_OK;
    SELECTION_TYPE          eType;
    ISegmentList            *pISegmentList = NULL;
    ISegment                *pISegment = NULL;
    IElementSegment         *pIElementSegment = NULL;   
    IHTMLElement            *pIElement = NULL;
    ISegmentListIterator    *pIIter = NULL;
    IObjectIdentity         *pIIdent = NULL;
    BOOL                    fSelected = FALSE;
    BOOL                    fEmpty;
    
    hr = THR( GetCurrentSelectionSegmentList(&pISegmentList) );
    if( FAILED(hr) )
        goto Cleanup;

    hr = THR( pCurElement->QueryInterface( IID_IObjectIdentity, (void **)&pIIdent));
    if( FAILED(hr) )
        goto Cleanup;

    // Make sure something is selected, and that the type of 
    // selection is control (otherwise, nothing can be site
    // selected)
    hr = THR( pISegmentList->IsEmpty(&fEmpty) );
    if( FAILED(hr) || fEmpty )
        goto Cleanup;

    hr = THR( pISegmentList->GetType(&eType) );
    if( FAILED(hr) || (eType != SELECTION_TYPE_Control) )
        goto Cleanup;
    
    hr = THR( pISegmentList->CreateIterator( &pIIter ) );
    if( FAILED(hr) )
        goto Cleanup;

    while( (pIIter->IsDone() == S_FALSE) && (fSelected == FALSE) )
    {
        // Retrieve the current segment
        hr = THR( pIIter->Current( &pISegment ) );
        if( FAILED(hr) )
            goto Cleanup;

        // QI for the IHTMLElement (should not fail if we have
        // a control tracker )
        hr = THR( pISegment->QueryInterface( IID_IElementSegment, (void **)&pIElementSegment ) );
        if( FAILED(hr) )
            goto Cleanup;

        hr = THR( pIElementSegment->GetElement( &pIElement ) );
        if( FAILED(hr) )
            goto Cleanup;

        // Check to see if our object is equal
        if( pIIdent->IsEqualObject( pIElement ) == S_OK )
        {
            fSelected = TRUE;
        }
        
        ClearInterface( &pISegment );
        ClearInterface( &pIElementSegment );
        ClearInterface( &pIElement );

        hr = pIIter->Advance();
        if( FAILED(hr) )
            goto Cleanup;
    }
   
Cleanup:
    ReleaseInterface( pISegmentList );
    ReleaseInterface( pISegment );
    ReleaseInterface( pIElement );
    ReleaseInterface( pIIter );
    ReleaseInterface( pIIdent );
    ReleaseInterface( pIElementSegment );
    
    return(fSelected);
}



//+====================================================================================
//
// Method: IsElementAtomic
//
// Synopsis: Determine if a given elemnet is atomic by asking mshtmled.dll.
//
//------------------------------------------------------------------------------------



BOOL
CDoc::IsElementAtomic( CElement* pCurElement)
{
    HRESULT hr = S_OK;
    HRESULT hrAtomic = S_FALSE;
    IHTMLEditor* ped = NULL;
    IHTMLEditingServices * pIEditingServices = NULL;
    IHTMLElement * pICurElement = NULL;    
    
    ped = GetHTMLEditor( TRUE );        
    Assert( ped );

    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void** ) & pIEditingServices));
        if ( hr )
            goto Cleanup;
        hr = THR( pCurElement->QueryInterface( IID_IHTMLElement, (void**) & pICurElement));
        if ( hr)
            goto Cleanup;
            
        hrAtomic = pIEditingServices->IsElementAtomic( pICurElement );
    }
    
Cleanup:
    ReleaseInterface( pICurElement);
    ReleaseInterface( pIEditingServices);
    
    return ( hrAtomic == S_OK );
}

HRESULT
CDoc::NotifySelectionHelper( EDITOR_NOTIFICATION eSelectionNotification,
                        CElement* pElementNotify,
                        DWORD dword /* = 0*/,
                        CElement* pElement /*=NULL*/)
{
    IUnknown* pUnk = NULL;
    HRESULT hr;
    
    hr = THR( pElementNotify->QueryInterface(IID_IUnknown, (void**) & pUnk ));
    if ( hr )
        goto Cleanup;

    hr = THR( NotifySelection( eSelectionNotification, pUnk, dword, pElement ));
    
Cleanup:
    ReleaseInterface( pUnk );
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method:NotifySelection
//
// Synopsis: Notify the HTMLEditor that "something" happened.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::NotifySelection(
                        EDITOR_NOTIFICATION eSelectionNotification,
                        IUnknown* pUnknown,
                        DWORD dword /* = 0*/,
                        CElement* pElement /*=NULL*/)
{
    HRESULT hr = S_OK;

    IHTMLEditor * ped = NULL;

    //
    // If we get a timer tick - when the doc is shut down this is very bad
    //
    Assert( ! ( (  eSelectionNotification == EDITOR_NOTIFY_TIMER_TICK )
            && (_ulRefs == ULREF_IN_DESTRUCTOR)) );

    if( _pIHTMLEditor == NULL && ! ShouldCreateHTMLEditor( eSelectionNotification , pElement ))
        goto Cleanup;    // Nothing to do

    if (eSelectionNotification == EDITOR_NOTIFY_LOSE_FOCUS)
    {
        if (_pCaret)
            _pCaret->LoseFocus();         
    }

    ped = GetHTMLEditor( (eSelectionNotification != EDITOR_NOTIFY_DOC_ENDED 
                         && eSelectionNotification != EDITOR_NOTIFY_CONTAINER_ENDED)
                       );

    if ( ped )
    {
        hr = ped->Notify( eSelectionNotification, pUnknown, dword );
    }

Cleanup:

    RRETURN1 ( hr, S_FALSE );
}


//+====================================================================================
//
// Method:  GetSelectionType
//
// Synopsis:Check the current selection type of the selection manager
//
//------------------------------------------------------------------------------------


SELECTION_TYPE
CDoc::GetSelectionType()
{
    ISegmentList    *pISegList = NULL;  
    SELECTION_TYPE  theType = SELECTION_TYPE_None;

    if( GetHTMLEditor(FALSE) )
    {
        GetCurrentSelectionSegmentList(&pISegList);
        Assert( pISegList );
        
        pISegList->GetType(&theType);

        ReleaseInterface( pISegList );
    }
    
    return theType;
}

//+====================================================================================
//
// Method: HasTextSelection
//
// Synopsis: Is there a "Text Selection"
//
//------------------------------------------------------------------------------------


BOOL
CDoc::HasTextSelection()
{
    return ( GetHTMLEditor(FALSE) && GetSelectionType() == SELECTION_TYPE_Text );
}


//+====================================================================================
//
// Method: HasSelection
//
// Synopsis: Is there any form of Selection ?
//
//------------------------------------------------------------------------------------

BOOL
CDoc::HasSelection()
{
    return ( GetHTMLEditor(FALSE) && GetSelectionType() != SELECTION_TYPE_None );
}


BOOL
CDoc::IsEmptySelection()
{
    ISegmentList    *pISegList = NULL; 
    ISegmentListIterator *pIIter = NULL;
    ISegment*       pISegment = NULL;
    IMarkupPointer* pIStart = NULL;
    IMarkupPointer* pIEnd = NULL;
    
    HRESULT hr;
    BOOL fEmpty = FALSE;
    
    if ( GetHTMLEditor(FALSE ) && GetSelectionType() == SELECTION_TYPE_Text )
    {
        IFC( GetCurrentSelectionSegmentList(&pISegList));
        IFC( pISegList->CreateIterator( & pIIter ));   
            
        IFC( CreateMarkupPointer( & pIStart ));
        IFC( CreateMarkupPointer( & pIEnd ));

        fEmpty = TRUE;
        
        while( pIIter->IsDone() == S_FALSE && fEmpty )
        {
            // Retrieve the current segment
            IFC( pIIter->Current( &pISegment ) );
            IFC( pISegment->GetPointers( pIStart, pIEnd ));

            IFC( pIStart->IsEqualTo( pIEnd, & fEmpty ));
            
            IFC( pIIter->Advance());

            ClearInterface( & pISegment );
        }        
    }
    
Cleanup:
    ReleaseInterface( pISegList );
    ReleaseInterface( pISegment );
    ReleaseInterface( pIStart );
    ReleaseInterface( pIEnd );
    ReleaseInterface( pIIter );

    return fEmpty;
}


//+====================================================================================
//
// Method: PointInSelection
//
// Synopsis: Is the given point in a Selection ? Returns false if there is no selection
//
//------------------------------------------------------------------------------------

BOOL
CDoc::IsPointInSelection(POINT pt, CTreeNode* pNode, BOOL fPtIsContent )
{
    // TODO (MohanB) This function does not check for clipping, because
    // MovePointerToPoint always does virtual hit-testing. We should pass
    // in an argument fDoVirtualHitTest to MovePointerToPoint() and set that
    // argument to FALSE when calling from this function.

    HRESULT hr = S_OK;
    
    IDisplayPointer* pDispPointer = NULL;
    BOOL fPointInSelection = FALSE;
    IHTMLElement* pIElementOver = NULL;
    CElement* pElement = NULL;
    SELECTION_TYPE eType = GetSelectionType() ;
    ISelectionObject2 *pISelObject = NULL;
    
    //
    // Illegal to call for content coordinates without a tree node
    //
    Assert( pNode || !fPtIsContent );
    
    if ( eType == SELECTION_TYPE_Control || eType == SELECTION_TYPE_Text )
    {
        //
        // marka TODO - consider making this take the node - and work out the pointer more directly
        //
        hr = THR( CreateDisplayPointer( & pDispPointer ));
        if ( hr )
            goto Cleanup;

        if ( pNode )
        {
            pElement = pNode->Element();

            if ( pElement )
            {
                hr = THR( pElement->QueryInterface( IID_IHTMLElement, ( void**) & pIElementOver));
                if ( hr )
                    goto Cleanup;
            }
        }
        
        //
        // One of two cases.  pNode is NOT null, in which case we retrieved
        // our element above.  Otherwise, if pNode Is NULL, pIElementOver will
        // not have been set, but we should be in the global coord system (via the
        // assert) so the display pointer should be able to handle it.
        //

        g_uiDisplay.DocPixelsFromDevice(&pt);
        
        IFC( pDispPointer->MoveToPoint(pt, 
                                       fPtIsContent ? COORD_SYSTEM_CONTENT : COORD_SYSTEM_GLOBAL,
                                       pIElementOver,
                                       0,
                                       NULL) );

        IGNORE_HR( GetSelectionObject2( &pISelObject ) );
        Assert( pISelObject );

        hr = THR( pISelObject->IsPointerInSelection( pDispPointer, &fPointInSelection , &pt, pIElementOver));       
    }

Cleanup :
    ReleaseInterface( pISelObject );
    ReleaseInterface( pDispPointer );
    ReleaseInterface( pIElementOver );
    return fPointInSelection;
    
}

//+========================================================================
//
// Method: ShouldCreateHTMLEditor
//
// Synopsis: Certain messages require the creation of a selection ( like Mousedown)
//           For these messages return TRUE.
//
//          Or if the Host will host selection Manager - return TRUE.
//-------------------------------------------------------------------------

BOOL
CDoc::ShouldCreateHTMLEditor( CMessage* pMessage )
{
    // If this is a MouseDown message, we should force a TSR to be created
    // Per Bug 18568 we should also force a TSR for down/up/right/left arrows
    switch(pMessage->message)
    {
        case WM_LBUTTONDOWN:
        /*case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:*/
            return TRUE;

        //
        // marka TODO - this may not be required anymore.
        //
        case WM_KEYDOWN:
            switch(pMessage->wParam)
            {
            case VK_LEFT:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
                return TRUE;

            }
        default:
            return FALSE;
    }
}


//+====================================================================================
//
// Method:ShouldCreateHTMLEditor
//
// Synopsis: Should we force the creation of a selection manager for this type of notify ?
//
//------------------------------------------------------------------------------------


BOOL
CDoc::ShouldCreateHTMLEditor( EDITOR_NOTIFICATION eSelectionNotification, CElement* pElement /*=NULL*/ )
{
    BOOL   fCreate = FALSE;
   
    if( eSelectionNotification == EDITOR_NOTIFY_BEFORE_FOCUS)
    {
        CMarkup* pMarkup = pElement->GetMarkup();
        Assert( pMarkup );
        CElement* pRootElement = pMarkup->Root();
        
        // check the element is editable or its parent (container) is editable
        if ( ( pElement && ( pElement->IsEditable(FALSE) || pElement->IsEditable(TRUE) ) ) 

             ||
        
             ( pRootElement && 
               pRootElement->HasMasterPtr() && 
               pRootElement->GetMasterPtr()->IsParentEditable() ) )
        {
            fCreate = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    return fCreate;        
}

//+========================================================================
//
// Method: ShouldSetEditContext.
//
// Synopsis: On Mouse Down we should always set a new EditContext
//
//-------------------------------------------------------------------------

inline BOOL
CDoc::ShouldSetEditContext( CMessage* pMessage )
{
     switch(pMessage->message)
    {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            return TRUE;

        default:
            return FALSE;
    }
}

//+====================================================================================
//
// Method: GetEditingServices
//
// Synopsis: Get a ref-counted IHTMLEditingServices, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::GetEditingServices( IHTMLEditingServices **ppIServices )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditingServices, (void**) ppIServices));
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: GetEditServices
//
// Synopsis: Get a ref-counted IHTMLEditServices, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::GetEditServices( IHTMLEditServices **ppIServices )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditServices, (void**) ppIServices));
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN ( hr );
}


//+====================================================================================
//
// Method: GetSelectionObject2
//
// Synopsis: Get a ref-counted ISelectionObject2, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::GetSelectionObject2( ISelectionObject2 **ppISelObject )
{
    HRESULT hr = S_OK;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_ISelectionObject2, (void**)ppISelObject ));
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: GetSelectionServices
//
// Synopsis: Get a ref-counted ISelectionServices, 
//           forcing creation of the editor if there isn't one
//
//------------------------------------------------------------------------------------


HRESULT 
CDoc::GetSelectionServices( ISelectionServices **ppIServices )
{
    HRESULT hr = S_OK;
    IHTMLEditServices* pEdSvc = NULL;
    
    IHTMLEditor* ped = GetHTMLEditor(TRUE);
    if ( ped )
    {
        hr = THR( ped->QueryInterface( IID_IHTMLEditServices, ( void**) & pEdSvc ));
        if ( hr )
        {
            goto Cleanup;
        }
        
        hr = THR( pEdSvc->GetSelectionServices( NULL, ppIServices ));
    }
    else
    {
        hr = E_FAIL;
    }
Cleanup:
    ReleaseInterface( pEdSvc );
    
    RRETURN ( hr );
}

HRESULT
CDoc::GetSelectionMarkup( CMarkup **ppMarkup )
{
    HRESULT             hr = S_OK;
    ISelectionServices  *pISelServ = NULL;
    IMarkupContainer    *pIContainer = NULL;
    
    Assert( ppMarkup != NULL );

    *ppMarkup = NULL;

    if( GetHTMLEditor(FALSE) )
    {
        hr = THR( GetSelectionServices(&pISelServ) );
        if( hr )
            goto Cleanup;

        hr = THR( pISelServ->GetMarkupContainer( &pIContainer ) );
        if( hr )
            goto Cleanup;

        hr = THR( pIContainer->QueryInterface(CLSID_CMarkup, (void **)ppMarkup) );
        Assert( hr == S_OK && *ppMarkup );
    }


Cleanup:
    ReleaseInterface( pISelServ );
    ReleaseInterface( pIContainer );
    
    RRETURN( hr );
}

    
//+-------------------------------------------------------------------------
//  Method:     CDoc::GetEditResourceLibrary
//
//  Synopsis:   Loads and cache's the HINSTANCE for the editing resource DLL.
//
//  Arguments:  hResourceLibrary = OUTPUT - HINSTANCE for DLL
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT 
CDoc::GetEditResourceLibrary(HINSTANCE *hResourceLibrary)
{    
    //
    // Load the editing resource DLL if it hasn't already been loaded
    //
    if(!_hEditResDLL)
    {
        _hEditResDLL = MLLoadLibrary(_T("mshtmler.dll"), g_hInstCore, ML_CROSSCODEPAGE);
    }

    *hResourceLibrary = _hEditResDLL;

    if (!_hEditResDLL)
        return E_FAIL; // TODO: can we convert GetLastError() to an HRESULT?

    return S_OK;
}

//+-------------------------------------------------------------------------
//  Method:     CDoc::GetEditingString
//
//  Synopsis:   Loads a string from the editing DLL.
//
//  Arguments:  uiStringId = String ID to load
//              pchBuffer = I/O - Buffer to receive string
//              cchBuffer = Length of buffer
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CDoc::GetEditingString(UINT uiStringId , TCHAR* pchBuffer, long cchBuffer /*=NULL*/)
{
    HRESULT     hr = S_OK;
    HINSTANCE   hinstEditResDLL;
    INT         iResult;
    long        cch = cchBuffer ? cchBuffer : ARRAY_SIZE(pchBuffer);
           
    hr = GetEditResourceLibrary(&hinstEditResDLL) ;        
    if (hr)
        goto Cleanup;
      
    iResult = LoadString( hinstEditResDLL, uiStringId, pchBuffer, cch );
   
    if (!iResult)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    return hr; 
}


//+==========================================================
//
// Method: GetHTMLEditor
//
// Synopsis: This is the real GetHTMLEditor
//                QueryService on the Host for the HTMLEditor Service
//              if it's there - we QI the host for it.
//              if it's not there - we cocreate the HTMLEditor in Mshtmled
//
//-----------------------------------------------------------


IHTMLEditor* 

CDoc::GetHTMLEditor( BOOL fForceCreate /* = TRUE */ )
{
    HRESULT hr = S_OK;

    // If we have an editor already, just return it

    if( _pIHTMLEditor )
        goto Cleanup;


        
    if( fForceCreate )
    {

        // IE Bug 32346 (mharper) check that the _pWindowPrimary is valid
        if (!_pWindowPrimary)
            goto Error;

        // If the host doesn't want to be the editor, mshtmled sure does!
        MtAdd( Mt( LoadMSHTMLEd ), +1 , 0 );
        hr = ::CoCreateInstance(CLSID_HTMLEditor,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IHTMLEditor ,
                                (void**) &_pIHTMLEditor );
        
        if( FAILED( hr ) || _pIHTMLEditor == NULL )
            goto Error;
    
        //
        // Use a weak-ref to all doc interfaces. Use _OmDocument for CView while it
        // doesn't exist...
        //
        hr = THR(_pIHTMLEditor->Initialize(
                (IUnknown *)_pWindowPrimary->Document(),
                (IUnknown *)_pWindowPrimary->Document()->Markup()));
        if ( FAILED(hr) )
            goto Error;
            
    }   // fForceCreate
    
                                            
    goto Cleanup;
    
Error:
    AssertSz(0,"Unable to create Editor");
    ClearInterface( & _pIHTMLEditor );


Cleanup:
    AssertSz( ! ( fForceCreate && _pIHTMLEditor == NULL ) , "IHTMLEditor Not Found or Allocated on Get!" );

    return( _pIHTMLEditor );    
}


HRESULT 
CDoc::BeginSelectionUndo()
{
    HRESULT hr= S_OK ;
    ISelectionServices* pSelServ = NULL;
    ISelectionServicesListener* pISelServListener = NULL;

    if ( GetHTMLEditor( FALSE ))
    {
        IGNORE_HR( NotifySelection( EDITOR_NOTIFY_BEGIN_SELECTION_UNDO, NULL ));
        
        //
        // Only bother with notifying sel serv - if there's already an editor.
        //
        hr = THR( GetSelectionServices( & pSelServ ));
        if ( hr )
            goto Cleanup;

        if ( SUCCEEDED( pSelServ->GetSelectionServicesListener( & pISelServListener )))
        {
            Assert( pISelServListener );
            hr = THR( pISelServListener->BeginSelectionUndo() );
        }            
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pISelServListener );
    
    RRETURN( hr );
}

HRESULT 
CDoc::EndSelectionUndo()
{
    HRESULT hr = S_OK ;
    ISelectionServices* pSelServ = NULL;
    ISelectionServicesListener* pISelServListener = NULL;

    if ( GetHTMLEditor( FALSE ))
    {
        hr = THR( GetSelectionServices( & pSelServ ));
        if ( hr )
            goto Cleanup;

        if( SUCCEEDED( pSelServ->GetSelectionServicesListener( & pISelServListener )) )
        {
            Assert( pISelServListener );
            hr = THR( pISelServListener->EndSelectionUndo() );
        }            
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pISelServListener );
    
    RRETURN( hr );
}
    
HRESULT
CDoc::GetMarkupFromHighlightSeg(IHighlightSegment *pISegment, CMarkup **ppMarkup)
{
    HRESULT             hr;
    CHighlightSegment   *pSegment = NULL;

    Assert( pISegment && ppMarkup );

    *ppMarkup = NULL;

    //
    // Retrieve the markup from the highlight segment
    //
    hr = THR( pISegment->QueryInterface( CLSID_CHighlightSegment, (void **)&pSegment) );
    if( FAILED(hr) || !pSegment )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppMarkup = pSegment->GetMarkup();
    Assert( *ppMarkup );

Cleanup:
    RRETURN(hr);
}

HRESULT 
CDoc::AddSegment(   IDisplayPointer     *pIDispStart, 
                    IDisplayPointer     *pIDispEnd,
                    IHTMLRenderStyle    *pIRenderStyle,
                    IHighlightSegment   **ppISegment )  
{
    HRESULT             hr;
    CMarkup             *pMarkup;
    CDisplayPointer     *pDisplayPointer = NULL;

    Assert( pIDispStart && pIDispEnd && pIRenderStyle && ppISegment );

    //
    // Retrieve the CDisplayPointer
    hr = THR( pIDispStart->QueryInterface( CLSID_CDisplayPointer, (void **)&pDisplayPointer ) );
    if( FAILED(hr) || !pDisplayPointer )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Retrieve the markup
    //
    pMarkup = pDisplayPointer->Markup();
    Assert( pMarkup );
    if( !pMarkup )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
      
    hr = THR( pMarkup->AddSegment( pIDispStart, pIDispEnd, pIRenderStyle, ppISegment ) );

Cleanup:
    RRETURN ( hr );            
}

HRESULT 
CDoc::MoveSegmentToPointers(IHighlightSegment   *pISegment,
                            IDisplayPointer     *pIDispStart, 
                            IDisplayPointer     *pIDispEnd )
{
    HRESULT hr = E_INVALIDARG;
    CMarkup *pMarkup;

    Assert( pISegment && pIDispStart && pIDispEnd  );

    if( pISegment && pIDispStart && pIDispEnd )
    {
        hr = THR( GetMarkupFromHighlightSeg( pISegment, &pMarkup ) );
        if( FAILED(hr) )
            goto Cleanup;

        hr = THR( pMarkup->MoveSegmentToPointers(   pISegment, 
                                                    pIDispStart, 
                                                    pIDispEnd ) );
    }
    
Cleanup:

    RRETURN ( hr );        
}    
    
HRESULT 
CDoc::RemoveSegment( IHighlightSegment *pISegment )
{
    HRESULT hr = E_INVALIDARG;
    CMarkup *pMarkup;

    Assert( pISegment );

    if( pISegment )
    {
        hr = THR( GetMarkupFromHighlightSeg( pISegment, &pMarkup ) );
        if( FAILED(hr) )
            goto Cleanup;

        hr = THR( pMarkup->RemoveSegment(pISegment) );
    }
    
Cleanup:

    RRETURN ( hr );        
}


//+====================================================================================
//
// Method: GetSelectionDragDropSource
//
// Synopsis: If this doc is the source of a drag/drop, and we are drag/dropping a selection
//           return the CSelDragDropSrcInfo. Otherwise return NULL.
//
//------------------------------------------------------------------------------------


CSelDragDropSrcInfo* 
CDoc::GetSelectionDragDropSource()
{
    if ( _fIsDragDropSrc   &&
         _pDragDropSrcInfo &&
         _pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION )
    {
        return DYNCAST( CSelDragDropSrcInfo, _pDragDropSrcInfo );
    }
    else
        return NULL;
}


//+---------------------------------------------------------------------------
//
// Helper Function: IsNumPadKey
//
//      lParam      bit 16-23  ScanCode
//----------------------------------------------------------------------------
#ifndef SCANCODE_NUMPAD_FIRST
#define SCANCODE_NUMPAD_FIRST 0x47
#endif
#ifndef SCANCODE_NUMPAD_LAST
#define SCANCODE_NUMPAD_LAST  0x52
#endif
BOOL 
IsNumpadKey(CMessage *pmsg)
{
    UINT uScanCode = LOBYTE(HIWORD(pmsg->lParam));
    return (uScanCode >= SCANCODE_NUMPAD_FIRST &&
            uScanCode <= SCANCODE_NUMPAD_LAST
           );
}


//+---------------------------------------------------------------------------
//
// Helper Function: IsValidAccessKey
//
//----------------------------------------------------------------------------
BOOL
IsValidAccessKey(CDoc * pDoc, CMessage * pmsg)
{
    //
    // Bug 105346/104194
    // Alt+Numpad input has to be treated as CHAR
    // [zhenbinx]
    //
    return (    (   (pmsg->message == WM_SYSKEYDOWN && !IsNumpadKey(pmsg))
                 || (pDoc->_fInHTMLDlg && pmsg->message == WM_CHAR)
                )
            &&
                (pmsg->wParam != VK_MENU)
            );
}

BOOL IsFrameTabKey(CMessage * pMessage);
BOOL IsTabKey(CMessage * pMessage);

//+---------------------------------------------------------------------------
//
//  Member:     PerformTA
//
//  Synopsis:   Handle any accelerators
//
//  Arguments:  [pMessage]  -- message
//
//  Returns:    Returns S_OK if keystroke processed, S_FALSE if not.
//----------------------------------------------------------------------------
HRESULT
CDoc::PerformTA(CMessage * pMessage, EVENTINFO *pEvtInfo)
{
    HRESULT     hr    = S_FALSE;

    Assert(State() >= OS_INPLACE);

    // WinUser.h better not change! We are going to assume the order of the
    // navigation keys (Left/Right/Up/Down/Home/End/PageUp/PageDn), so let's
    // assert about it.
    Assert(VK_PRIOR + 1 == VK_NEXT);
    Assert(VK_NEXT  + 1 == VK_END);
    Assert(VK_END   + 1 == VK_HOME);
    Assert(VK_HOME  + 1 == VK_LEFT);
    Assert(VK_LEFT  + 1 == VK_UP);
    Assert(VK_UP    + 1 == VK_RIGHT);
    Assert(VK_RIGHT + 1 == VK_DOWN);

    if (WM_KEYDOWN == pMessage->message || WM_SYSKEYDOWN == pMessage->message ||
        WM_KEYUP == pMessage->message   || WM_SYSKEYUP == pMessage->message
        )
    {
        // Handle accelerator here.
        //  1. Pass any accelerators that the editor requires
        //  2. Bubble up the element chain starting from _pElemCurrent (or capture elem)
        //     and call PerformTA on them
        //  3. Perform key navigation for TAB and accesskey

        //
        // marka - pump all messages to the editor. It makes the determination on 
        // what it wants to handle in TA.
        //
        if ( pEvtInfo->_pParam != NULL )
        {
            hr = THR(HandleSelectionMessage(pMessage, FALSE, pEvtInfo , HM_Translate));
        }                
        if (hr != S_FALSE)
            goto Cleanup;


        CElement *  pElemTarget         = _pElemCurrent;

        CTreeNode * pNodeTarget         = pElemTarget->GetFirstBranch();
        BOOL        fGotEnterKey        = (pMessage->message == WM_KEYDOWN && pMessage->wParam == VK_RETURN);
        BOOL        fTranslateEnterKey  = FALSE;

        while (pNodeTarget && pElemTarget && pElemTarget->Tag() != ETAG_ROOT)
        {
            // Hack for tabbing between the button and text regions of InputFile
            if (WM_KEYDOWN == pMessage->message && VK_TAB == pMessage->wParam && pElemTarget->Tag() == ETAG_INPUT)
            {
                CInput * pInput = DYNCAST(CInput, pElemTarget);

                if (pInput->GetType() == htmlInputFile)
                {
                    hr = pInput->HandleFileMessage(pMessage);
                    if (hr != S_FALSE)
                        goto Cleanup;
                }
            }

            hr = pElemTarget->PerformTA(pMessage);
            if (hr != S_FALSE)
                goto Cleanup;

            // Navigation keys are dealt with in HandleMessage, but we need to
            // treat them as accelerators (because many hosts such as HomePublisher
            // and KatieSoft Scroll expect us to - IE5 66735, 63774).

            if (    WM_KEYDOWN  == pMessage->message
                &&  VK_PRIOR    <= pMessage->wParam
                &&  VK_DOWN     >= pMessage->wParam
               )
            {
                // On the other hand, VID6.0 wants the fist shot at some of them if
                // there is a site-selection (they should fix this in VID6.1)
                if (    _fVID
                    &&  pMessage->wParam >= VK_LEFT
                    &&  GetSelectionType() == SELECTION_TYPE_Control)
                {
                    // let go to the host
                }
                else
                {
                    hr = pElemTarget->HandleMessage(pMessage);
                    if (hr != S_FALSE)
                        goto Cleanup;
                }
            }

            // Raid 44891
            // Some hosts like AOL, CompuServe and MSN eat up the Enter Key in their
            // TranslateAccelerator, so we never get it in our WindowProc. We work around
            // by explicitly translating WM_KEYDOWN+VK_RETURN to WM_CHAR+VK_RETURN
            //
            if (fGotEnterKey && !pElemTarget->IsEditable(TRUE))
            {
                if (pElemTarget->_fActsLikeButton)
                {
                    fTranslateEnterKey = TRUE;
                }
                else
                {
                    switch (pElemTarget->Tag())
                    {
                    case ETAG_A:
                    case ETAG_IMG:
                    case ETAG_TEXTAREA:
                        fTranslateEnterKey = TRUE;
                        break;
                    }
                }
                if (fTranslateEnterKey)
                    break;
            }

            // Find the next target
            pNodeTarget = pNodeTarget->Parent();
            if (pNodeTarget)
            {
                pElemTarget = pNodeTarget->Element();
            }
            else
            {
                pElemTarget = pElemTarget->GetMasterPtr();
                pNodeTarget = (pElemTarget) ? pElemTarget->GetFirstBranch() : NULL;
            }
        }
        // Pressing 'Enter' should activate the default button
        // (unless the focus is on a SELECT - IE5 #64133)
        if (fGotEnterKey && !fTranslateEnterKey && !pElemTarget->IsEditable(/*fCheckContainerOnly*/FALSE) && _pElemCurrent->Tag() != ETAG_SELECT)
        {
             fTranslateEnterKey = !!_pElemCurrent->FindDefaultElem(TRUE);
        }
        if (fTranslateEnterKey)
        {
            ::TranslateMessage(pMessage);
            hr = S_OK;
            goto Cleanup;
        }

        Assert(hr == S_FALSE);

        if (IsFrameTabKey(pMessage)
            || IsTabKey(pMessage)
            || IsValidAccessKey(this, pMessage))
        {
            hr = HandleKeyNavigate(pMessage, FALSE);

            if (hr != S_FALSE)
                goto Cleanup;

            // Comment (jenlc). Say that the document has two frames, the
            // first frame has two controls with access keys ALT+A and ALT+B
            // respectively while the second frame has a control with access
            // key ALT+A. Suppose currently the focus is on the control with
            // access key ALT+B (the second control of the first frame) and
            // ALT+A is pressed, which control should get the focus? Currently
            // Trident let the control in the second frame get the focus.
            //
            if (IsTabKey(pMessage) || IsFrameTabKey(pMessage))
            {
                BOOL fYieldFailed = FALSE;

                IGNORE_HR(PrimaryRoot()->BecomeCurrentAndActive(0, &fYieldFailed, NULL, TRUE, 0, TRUE));
                if (fYieldFailed)
                {
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }
    }
    // Raid 63207
    // If we call IOleControSite::TranslateAccelerator() here for WM_CHAR
    // in HTML Dialog, this would cause WM_CHAR message to be re-dispatched
    // back to us, which is an infinite loop.
    //
    if (hr == S_FALSE &&
            (!_fInHTMLDlg || pMessage->message != WM_CHAR))
    {
        hr = CallParentTA(pMessage);
    }

    if (IsFrameTabKey(pMessage)
        || IsTabKey(pMessage)
        || IsValidAccessKey(this, pMessage))
    {
        if (hr == S_OK)
        {
            _pElemUIActive = NULL;
        }
        else if (hr == S_FALSE)
        {
            hr = HandleKeyNavigate(pMessage, TRUE);

            if (hr == S_FALSE && pMessage->message != WM_SYSKEYDOWN)
            {
                CElement *pElement = CMarkup::GetElementClientHelper(PrimaryMarkup());

                if (pElement)
                {
                    pElement->BecomeCurrentAndActive(pMessage->lSubDivision, NULL, NULL, TRUE);
                    hr = S_OK;  
                }
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


BOOL
CDoc::FCaretInPre()
{
    if (_pCaret)
    {
        CTreeNode * pNode = _pCaret->GetNodeContainer(MPTR_SHOWSLAVE);

        if (pNode)
        {
            const CParaFormat * pPF = pNode->GetParaFormat();
            if (pPF)
            {
                return pPF->_fPre;
            }
        }
    }

    return FALSE;
}

#if DBG==1
BOOL    
CDocExtra::AreLookasidesClear( void *pvKey, int nLookasides)
{
    DWORD * pdwKey = (DWORD*)pvKey;

    for ( ; nLookasides > 0; nLookasides--, pdwKey++ )
    {
        if (_HtPvPv.IsPresent( pdwKey ))
            return FALSE;
    }

    return TRUE;
}
BOOL    
CDocExtra::AreLookasides2Clear( void *pvKey, int nLookasides)
{
    DWORD * pdwKey = (DWORD*)pvKey;

    for ( ; nLookasides > 0; nLookasides--, pdwKey++ )
    {
        if (_HtPvPv2.IsPresent( pdwKey ))
            return FALSE;
    }

    return TRUE;
}
#endif


// Aggregration helper for XML MimeViewer
// RETURN true if we're being aggregated by the XML MimeViewer
extern "C" const IID IID_IXMLViewerIdentity;
BOOL CDoc::IsAggregatedByXMLMime()
{
    if (IsAggregated())
    {
        IUnknown *pXMLViewer = NULL;
        HRESULT hr = PunkOuter()->QueryInterface(IID_IXMLViewerIdentity, (void **)&pXMLViewer);
        if (hr == S_OK)
        {
            pXMLViewer->Release();
            return TRUE;
        }
    }
    return FALSE;
}

void 
CDoc::AddExpressionTask(CElement *pElement)
{
    // Don't create expression tasks for elements in print media
    if ( pElement->IsPrintMedia() )
        return;

    if ( !pElement->_fHasPendingRecalcTask )
    {
        if (!_aryPendingExpressionElements.Append ( pElement ))
        {
            pElement->_fHasPendingRecalcTask = TRUE;
            PostExpressionCallback();
        }
    }
}

void
CDoc::RemoveExpressionTask(CElement *pElement)
{
    if ( pElement->_fHasPendingRecalcTask )
    {
        INT i;
        i = _aryPendingExpressionElements.Find ( pElement );
        if ( i >= 0 )
        {
            _aryPendingExpressionElements [ i ] = NULL;
        }
        // Next recalc pass will delete the entry
        pElement->_fHasPendingRecalcTask = FALSE;
    }
}

void
CDoc::ExpressionCallback(DWORD_PTR)
{
    ExecuteExpressionTasks();
}

void
CDoc::ExecuteExpressionTasks()
{
    //
    // This function is re-entrant. Code may run in setStyleExpression, which may cause us to re-enter 
    // (e.g. a call to setExpression)
    //
    // A key architectural point is that expressions never get removed from the queue, if in
    // setStyleExpressions, code runs that calls removeExpression(), note that this merely sets
    // the array entry to null
    //

    if (_recalcHost._fInRecalc)
    {
        // This is a very bad time to be making changes to the dependency graph
        // Just return.  EngineRecalcAll will pick up any pending work when it finishes.
        return;
    }

    if (!TestLock(FORMLOCK_EXPRESSION))
    {
        INT i,size;
        CElement *pElem;
        CLock lock(this, FORMLOCK_EXPRESSION);

        
        if ( !_fPendingExpressionCallback )
        {
            // Nothing to do
            Assert ( _aryPendingExpressionElements.Size() == 0 ); // to get here there must be elements in the queue
            return;
        }

        _fPendingExpressionCallback = FALSE;

        size = _aryPendingExpressionElements.Size();

        Assert ( size > 0 ); // to get here there must be elements in the queue

        for ( i = 0 ; i < size ; i++ )
        {
            pElem = _aryPendingExpressionElements [i];
            //
            // A call to removeExpression, e.g. in CElement::Passive & CElement::ExitTree(),
            // sets the array entry to null
            //
            if ( pElem && pElem->GetFirstBranch() )
            {
                Assert ( pElem->_fHasPendingRecalcTask );

                pElem->_fHasPendingRecalcTask = FALSE;
                _aryPendingExpressionElements [i] = NULL;

                // If  a new recalc task is added for this element during this callback, 
                // it will be added to the end of the list, beyond size

                _recalcHost.setStyleExpressions(pElem); // *** This call may cause re-entrancy to this function ***

                pElem->_fHasExpressions = TRUE;

                // And if tasks where added during the upper loop, a call to _fPendingExpressionCallback has
                // been made and will kick off another ExecuteExpressionTasks() when its serviced     
            }        
        }

        // Clear up completed tasks
        if ( size > 0 )
            _aryPendingExpressionElements.DeleteMultiple(0, size - 1);

        if ( !_fPendingExpressionCallback )
        {
            // If the flag is still false, no more tasks were added in the loop above
            // So as an optimization, kill the posted method call if it was outstanding 

            Assert ( _aryPendingExpressionElements.Size() == 0 ); // if flag is off, queue must be empty

            GWKillMethodCall(this, ONCALL_METHOD(CDoc, ExpressionCallback, expressioncallback), 0);
        }
    }
}

void
CDoc::PostExpressionCallback()
{
    if (!_fPendingExpressionCallback)
    {
        _fPendingExpressionCallback = 
            SUCCEEDED(GWPostMethodCall(this,ONCALL_METHOD(CDoc, ExpressionCallback, expressioncallback), 0, FALSE, "CDoc::FilterCallback"));
        Assert(_fPendingExpressionCallback);
    }
}

void
CDoc::CleanupExpressionTasks()
{
    _aryPendingExpressionElements.DeleteAll();
    if ( _fPendingExpressionCallback )
    {
        GWKillMethodCall(this, ONCALL_METHOD(CDoc, ExpressionCallback, expressioncallback), 0);
        _fPendingExpressionCallback = FALSE;
    }
}

BOOL
CDoc::AddFilterTask(CElement *pElement)
{
    if (!pElement->_fHasPendingFilterTask)
    {
        TraceTag((tagFilter, "Adding filter task for element %08x", pElement));

        Assert(_aryPendingFilterElements.Find(pElement) == -1);

        pElement->_fHasPendingFilterTask = SUCCEEDED(_aryPendingFilterElements.Append(pElement));

        PostFilterCallback();
    }

    return pElement->_fHasPendingFilterTask;
}

void
CDoc::RemoveFilterTask(CElement *pElement)
{
    if (pElement->_fHasPendingFilterTask)
    {
        int i = _aryPendingFilterElements.Find(pElement);

        Assert(i >= 0);
        if (i >= 0)
        {
            _aryPendingFilterElements[i] = NULL;
            pElement->_fHasPendingFilterTask = FALSE;

            TraceTag((tagFilter, "%08x Removing filter task", pElement));

            // We don't delete anything from the array, that will happen when the
            // ExecuteFilterTasks is called.

            Assert(_fPendingFilterCallback);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     ExecuteSingleFilterTask
//
//  Synopsis:   Execute pending filter hookup for a single element
//
//              Can be called at anytime without worrying about trashing
//              the queue array
//
//----------------------------------------------------------------------------

BOOL
CDoc::ExecuteSingleFilterTask(CElement *pElement)
{
    if (!pElement->_fHasPendingFilterTask)
        return FALSE;

    int i = _aryPendingFilterElements.Find(pElement);

    Assert(i >= 0);

    if (i < 0)
        return FALSE;

    Assert(_aryPendingFilterElements[i] == pElement);

    // This function doesn't actually delete the entry, it simply nulls it out
    // The array is cleaned up when ExecuteFilterTasks is complete
    _aryPendingFilterElements[i] = NULL;

    pElement->_fHasPendingFilterTask = FALSE;

    TraceTag((tagFilter, "%08x demand executing filter task", pElement));
    pElement->AddFilters();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     ExecuteFilterTasks
//
//  Synopsis:   Execute pending filter hookup
//
//  Notes;      This code is 100% re-entrant safe.  Call it whenever, however
//              you want and it must do the right thing.  Re-entrancy into
//              other functions (like ComputeFormats) is the responsibility
//              of the caller :-)
//
//  Arguments:  grfLayout - Collections of LAYOUT_xxxx flags
//
//  Returns:    TRUE if all tasks were processed, FALSE otherwise
//
//----------------------------------------------------------------------------

BOOL
CDoc::ExecuteFilterTasks(BOOL * pfHaveAddedFilters/* = NULL */)
{
    TraceTag((tagFilter, "+ExecuteFilterTasks"));

    if(pfHaveAddedFilters)
        *pfHaveAddedFilters = FALSE;

    // We don't want to do this while we're painting
    if (   TestLock(SERVERLOCK_BLOCKPAINT))
    {
        if (_aryPendingFilterElements.Size())
        {
            TraceTag((tagFilter, "In the middle of Painting, will do the filters later"));
            PostFilterCallback();
            return FALSE;
        }

        return TRUE;    // No tasks means that they all got done, right?
    }


    // If we're in the middle of doing this (for whatever reason), don't start again
    // The primary reason for not starting again has to do with trying to cleanup the
    // array, otherwise this code is re-entrant safe
    if (!TestLock(FORMLOCK_FILTER))
    {
        CLock lock(this, FORMLOCK_FILTER);

        // Sometimes this gets called on demand.  We may have a posted callback, get rid of it now.
        if (_fPendingFilterCallback)
        {
            _fPendingFilterCallback = FALSE;
            GWKillMethodCall(this, ONCALL_METHOD(CDoc, FilterCallback, filtercallback), 0);
        }


        // We're only going to do as many elements as are there when we start
        int c = _aryPendingFilterElements.Size();

        if (c > 0)
        {
            for (int i = 0 ; i < c ; i++)
            {
                CElement *pElement = _aryPendingFilterElements[i];

                if (pElement)
                {
                   if(pElement->IsConnectedToPrimaryMarkup())
                    {
                        // This calls out to external code, anything could happen?
                        HRESULT hr = pElement->AddFilters();

                        if (hr == E_PENDING)
                        {
                            Assert(pElement->TestLock(CElement::ELEMENTLOCK_ATTACHPEER));
                            TraceTag((tagFilter, "%08x Skipping the task, because attaching a Peer", pElement));
                            continue;
                        }

                        if (pfHaveAddedFilters)
                            *pfHaveAddedFilters = TRUE;

                        _aryPendingFilterElements[i] = NULL;

                        Assert(pElement->_fHasPendingFilterTask);
                        pElement->_fHasPendingFilterTask = FALSE;

                        TraceTag((tagFilter, "%08x Executing filter task from filter task list (also removes)", pElement));
                    }
                    else
                    {
                        // Not connected to the primary markup, we will create the filters later, after the merkup is switched
                        TraceTag((tagFilter, "%08x element is not connected to the primary markup, try again later", pElement));
                    }
                }
            }

            // Adding filters occasionally causes more filter
            // work.  Rather than doing it immediately, we'll
            // just wait until next time.
            Assert(_aryPendingFilterElements.Size() >= c);

            if (_aryPendingFilterElements.Size() > c)
            {
                PostFilterCallback();
            }

            // Now delete all the processed elements from the array
            for (int i = _aryPendingFilterElements.Size() - 1; i >= 0; i--)
            {
                if(!_aryPendingFilterElements[i])
                    _aryPendingFilterElements.Delete(i);
            }

#if DBG == 1
            if(_aryPendingFilterElements.Size() > 0)
            {
                TraceTag(( tagFilter, "Still have %d filters to add when exiting ExecuteFilterTasks", _aryPendingFilterElements.Size()));
            }
#endif
        }
    }

    TraceTag((tagFilter, "-ExecuteFilterTasks"));
    return (_aryPendingFilterElements.Size() == 0);
}

void
CDoc::PostFilterCallback()
{
    if (!_fPendingFilterCallback)
    {
        TraceTag((tagFilter, "PostFilterCallback"));
        _fPendingFilterCallback = SUCCEEDED(GWPostMethodCall(this,ONCALL_METHOD(CDoc, FilterCallback, filtercallback), 0, FALSE, "CDoc::FilterCallback"));
        Assert(_fPendingFilterCallback);
    }
}

void
CDoc::FilterCallback(DWORD_PTR)
{
    Assert(_fPendingFilterCallback);
    if (_fPendingFilterCallback)
    {
        TraceTag((tagFilter, "FilterCallback"));
        _fPendingFilterCallback = FALSE;
        ExecuteFilterTasks();
    }
}


//+---------------------------------------------------------------
//
// Helper Function: DocIsDeskTopItem
//
// Test if Trident is a desktop iframe. There is a agreement during
// IE4 stage that desktop iframe will have CDoc::_pDocParent to be
// NULL, this prevents Trident from making CBodyElement in desktop
// iframe a tab stop. Need to way to separate this situation.
//
//----------------------------------------------------------------
BOOL
DocIsDeskTopItem(CDoc * pDoc)
{
    BOOL    fResult = FALSE;
    HRESULT hr;

    IServiceProvider * pSP1 = NULL;
    IServiceProvider * pSP2 = NULL;

    if (!pDoc->_pClientSite)
        goto Cleanup;

    hr = pDoc->_pClientSite->QueryInterface(
            IID_IServiceProvider,
            (void **) &pSP1);

    if (!hr && pSP1)
    {
        hr = pSP1->QueryService(
                SID_STopLevelBrowser,
                IID_IServiceProvider,
                (void **) &pSP2);
        if (!hr && pSP2)
        {
            ITargetFrame2 * pTF2 = NULL;

            hr = pSP2->QueryService(
                    IID_ITargetFrame2,
                    IID_ITargetFrame2,
                    (void **) &pTF2);
            if (!hr && pTF2)
            {
                DWORD dwOptions;

                hr = pTF2->GetFrameOptions(&dwOptions);
                if (!hr && (dwOptions & FRAMEOPTIONS_DESKTOP))
                {
                    fResult = TRUE;
                }
                pTF2->Release();
            }
            pSP2->Release();
        }
        pSP1->Release();
    }

Cleanup:
    return fResult;
}

HRESULT 
CDocument::createRenderStyle(BSTR v, IHTMLRenderStyle** ppIHTMLRenderStyle)
{
    HRESULT hr;
    CRenderStyle *pRenderStyle;
    
    pRenderStyle = new CRenderStyle( Doc() );
    if (!pRenderStyle)
    {
        hr = E_OUTOFMEMORY;
        *ppIHTMLRenderStyle = NULL;
        goto Error;
    }
    
    hr = THR(pRenderStyle->QueryInterface(IID_IHTMLRenderStyle, (void **)ppIHTMLRenderStyle));

Error:
   
    if(pRenderStyle)
        pRenderStyle->PrivateRelease();

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::IsAboutHomeOrNonAboutURL
//
//  Synopsis : Returns TRUE if the URL is about:home or a non about: URL.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsAboutHomeOrNonAboutUrl(LPCTSTR lpszUrl)
{
    BOOL fIsAboutHomeOrNonAboutURL = TRUE;

    Assert(lpszUrl);
    
    // Is it "about:home"?
    //
    if (0 != StrCmpNIC(ABOUT_HOME, lpszUrl, ARRAY_SIZE(ABOUT_HOME) - 1))
    {
        // We also want to return TRUE if the
        // scheme was NOT an about: URL.
        //
        fIsAboutHomeOrNonAboutURL = (URL_SCHEME_ABOUT != GetUrlScheme(lpszUrl));
    }

    return fIsAboutHomeOrNonAboutURL;            
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::IsSameUrl
//
//  Synopsis : Determines if the url of the old markup is the same as the 
//             url of the new markup.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsSameUrl(CMarkup * pMarkupOld, CMarkup * pMarkupNew)
{
    Assert(pMarkupOld);
    Assert(pMarkupNew);
    
    return IsSameUrl(CMarkup::GetUrl(pMarkupOld),
                     CMarkup::GetUrlLocation(pMarkupOld),
                     CMarkup::GetUrl(pMarkupNew),
                     CMarkup::GetUrlLocation(pMarkupNew),
                     (pMarkupNew->GetDwnPost() != NULL));
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::IsSameUrl
//
//  Synopsis : Determines if the url of the old markup is the same as the 
//             url of the new markup.
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsSameUrl(LPCTSTR lpszOldUrl,
                LPCTSTR lpszOldLocation,
                LPCTSTR lpszNewUrl,
                LPCTSTR lpszNewLocation,
                BOOL    fIsPost)
{
    HRESULT hr;
    BOOL    fIsSameUrl = FALSE;
    TCHAR   szOldUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR   szNewUrl[INTERNET_MAX_URL_LENGTH];

    if (fIsPost)
    {
        goto Cleanup;
    }

    hr = FormatUrl(lpszOldUrl,
                   lpszOldLocation,
                   szOldUrl,
                   ARRAY_SIZE(szOldUrl));
    if (hr)
        goto Cleanup;

    hr = FormatUrl(lpszNewUrl,
                   lpszNewLocation,
                   szNewUrl,
                   ARRAY_SIZE(szNewUrl));
    if (hr)
        goto Cleanup;

    Assert(szNewUrl);
    Assert(szOldUrl);

    fIsSameUrl = !StrCmpI(szNewUrl, szOldUrl);

Cleanup:
    return fIsSameUrl;
}       

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::UpdateTravelLog
//
//  Synopsis : Updates the travel log, adds a new entry, and updates
//             the state of the back and forward buttons.
//
//----------------------------------------------------------------------------

void
CDoc::UpdateTravelLog(CWindow * pWindow,
                      BOOL      fIsLocalAnchor,
                      BOOL      fAddEntry,            /* = TRUE */
                      BOOL      fDontUpdateIfSameUrl, /* = TRUE */
                      CMarkup * pMarkupNew,           /* = NULL */
                      BOOL      fForceUpdate          /* = FALSE */)
{
    Assert(pWindow);

    //
    // don't add to tlog - if we were called from location.replace.
    //

    if (!_pTravelLog || ( pMarkupNew && pMarkupNew->_fReplaceUrl ) )
    {
        goto Cleanup;
    }
    
    //
    // don't update travel log for error pages we said not to update for.
    //
    if ( pWindow->_fHttpErrorPage && _fDontUpdateTravelLog )
    {
        goto Cleanup;
    }
    
    if ( !pWindow->_fHttpErrorPage
         && (  _fDontUpdateTravelLog
             || ((_fShdocvwNavigate || (_fDefView && !_fActiveDesktop)) && pWindow->IsPrimaryWindow())))
    {
        goto Cleanup;
    }

    if (   fDontUpdateIfSameUrl
        && pMarkupNew
        && !pMarkupNew->_fLoadingHistory
        && ( IsSameUrl(pWindow->_pMarkup, pMarkupNew) || pMarkupNew->_fInRefresh ) )
    {
        goto Cleanup;
    }

    LPCTSTR pchUrl = CMarkup::GetUrl(pWindow->_pMarkup);
    if (IsAboutHomeOrNonAboutUrl(pchUrl))
    {
        // Security QFE, don't want script urls running in history context
        if (IsSpecialUrl(pchUrl)) 
            goto Cleanup;

        // If the window's markup is the primary markup, we 
        // delegate the updating of the travel log to the
        // client site. Otherwise, if the window is a frame,
        // we update the travel log ourselves.
        //
        if (pWindow->Markup()->IsPrimaryMarkup())
        {
            TraceTag((tagCDoc, "TRAVELLOG: delegating to shdocvw for %ls", CMarkup::GetUrl(pWindow->_pMarkup)));

            CVariant cvar(VT_I4);
            long lVal = 0;

            if (fIsLocalAnchor)
                lVal |= TRAVELLOG_LOCALANCHOR;

            if (fForceUpdate)
                lVal |= TRAVELLOG_FORCEUPDATE;

            V_I4(&cvar) = lVal;

            Assert(_pClientSite);
            CTExec(_pClientSite, &CGID_Explorer, SBCMDID_UPDATETRAVELLOG, 0, &cvar, NULL);
        }
        else
        {
            TraceTag((tagCDoc, "TRAVELLOG: updating for frame (%ls). fAddEntry: %ls", 
                      CMarkup::GetUrl(pWindow->_pMarkup), fAddEntry ? _T("True") : _T("False")));

            IUnknown * pUnk = DYNCAST(IHTMLWindow2, pWindow);

            UpdateTravelEntry(pUnk, fIsLocalAnchor);

            if (fAddEntry)
                AddTravelEntry(pUnk, fIsLocalAnchor);

        }

        UpdateBackForwardState();
    }

Cleanup:
    _fDontUpdateTravelLog = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::UpdateTravelEntry
//
//  Synopsis : Updates the current entry in the travel log.
//
//----------------------------------------------------------------------------

void
CDoc::UpdateTravelEntry(IUnknown * punk, BOOL fIsLocalAnchor)
{
    Assert(punk);

    if (_pTravelLog && LoadStatus() != LOADSTATUS_UNINITIALIZED)
    {
        _pTravelLog->UpdateEntry(punk, fIsLocalAnchor);
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::AddTravelEntry
//
//  Synopsis : Adds an entry to the travel log.
//
//----------------------------------------------------------------------------

void
CDoc::AddTravelEntry(IUnknown * punk, BOOL fIsLocalAnchor) const
{
    Assert(punk);

    if (_pTravelLog)
    {
        _pTravelLog->AddEntry(punk, fIsLocalAnchor);
    }
}        

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::Travel
//
//  Synopsis : Navigates to an offset within the travel log
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::Travel(int iOffset) const
{
    HRESULT hr = S_OK;
    IBrowserService * pBrowserSvc = NULL;

    // If we are viewlinked in a WebOC, we must pass
    // the IBrowserService of the top frame browser 
    // to ITravelLog::Travel. Otherwise, in the case
    // of choosing back/forward from the context menu,
    // we won't go anywhere.
    //
    if (_pTravelLog && _pBrowserSvc)
    {
        if (_fViewLinkedInWebOC)
        {
            hr = IUnknown_QueryService(_pBrowserSvc, SID_STopFrameBrowser,
                                       IID_IBrowserService, (void**)&pBrowserSvc);
            if (hr)
                goto Cleanup;
        }
        else 
        {
            pBrowserSvc = _pBrowserSvc;
            pBrowserSvc->AddRef();
        }

        Assert(pBrowserSvc);

        hr = THR(_pTravelLog->Travel(pBrowserSvc, iOffset));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pBrowserSvc);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::Travel
//
//  Synopsis : Navigates to the specified URL in the travel log.
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::Travel(CODEPAGE uiCP, LPOLESTR pszUrl) const
{
    ITravelLogEx * pTravelLogEx;
    HRESULT        hr = S_OK;

    if (_pTravelLog && _pBrowserSvc)
    {
        hr = _pTravelLog->QueryInterface(IID_ITravelLogEx, (void**)&pTravelLogEx);

        if (!hr)
        {
            hr = pTravelLogEx->TravelToUrl(_pBrowserSvc, uiCP, pszUrl);
            pTravelLogEx->Release();
        }
    }

    return hr;
}        

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::NumTravelEntries
//
//  Synopsis : Returns the number of entries in the travel log.
//
//----------------------------------------------------------------------------

DWORD 
CDoc::NumTravelEntries() const
{
    DWORD dwNumEntries = 0;

    if (_pTravelLog && _pBrowserSvc)
    {
        dwNumEntries = _pTravelLog->CountEntries(_pBrowserSvc);
    }

    return dwNumEntries;
}


//+---------------------------------------------------------------------------
//
//  Method   : CDoc::UpdateBackForwardState
//
//  Synopsis : Updates the state of the back/forward buttons, ctx menu, etc.
//
//----------------------------------------------------------------------------

void 
CDoc::UpdateBackForwardState() const
{
    if (_pBrowserSvc)
    {
        _pBrowserSvc->UpdateBackForwardState();
    }
}

//+---------------------------------------------------------------------------
//
//  Method   : CDoc::EnsureFilterBehaviorFactory()
//
//  Synopsis : Creates the FilterBehaviorFactory if needed
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::EnsureFilterBehaviorFactory()
{
    HRESULT     hr = S_OK;
    
    if(!_pFilterBehaviorFactory)
    {
        // Create the factory
        hr = THR(CoCreateInstance( CLSID_DXTFilterFactory, NULL, CLSCTX_INPROC_SERVER,
                     IID_IElementBehaviorFactory, (void **)&_pFilterBehaviorFactory));
    }

    RRETURN(hr);
}


VOID
CDoc::InitEventParamForKeyEvent(
                                EVENTPARAM* pParam , 
                                CTreeNode * pNodeContext, 
                                CMessage *pMessage, 
                                int *piKeyCode, 
                                const PROPERTYDESC_BASIC **ppDesc )
{
    // $$ktam: is it meaningful to have a layout context in the message 
    // at this point?  it's often null.
    pParam->_pLayoutContext = pMessage->pLayoutContext;
    pParam->SetNodeAndCalcCoordinates(pNodeContext);
    pParam->_lKeyCode = (long)*piKeyCode;

    if (g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
    {
        pParam->_fShiftLeft = (LOBYTE(HIWORD(pMessage->lParam)) == OEM_SCAN_SHIFTLEFT);
    }

    switch (pMessage->message)
    {
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        // the 30th bit of the lparam indicates whether this is a repeated WM_
        pParam->fRepeatCode = !!(HIWORD(pMessage->lParam) & KF_REPEAT);
        *ppDesc = &s_propdescCElementonkeydown;
        break;
    
    case WM_SYSKEYUP:
    case WM_KEYUP:
        *ppDesc = &s_propdescCElementonkeyup;
        break;

    case WM_CHAR:
        *ppDesc = &s_propdescCElementonkeypress;
        break;

    default:
        AssertSz(0, "Unknown Key stroke");
        return;
    }

    pParam->SetType((*ppDesc)->a.pstrName + 2);
    
}

#ifdef V4FRAMEWORK

MtDefine(CExternalFrameworkSite, Mem, "CExternalFrameworkSite")

void
CDoc::ReleaseFrameworkDoc()
{    
    if ( _pFrameworkDoc )
    {
        _pFrameworkDoc->SetSite(NULL);
        _pFrameworkDoc->Release();
        _pFrameworkDoc = NULL;
    }
}

HRESULT CExternalFrameworkSite::SetLongRenderProperty ( long lRef, long propertyType, long lValue )
{
    HRESULT hr=S_OK;
    CElement *pElement = (CElement *)lRef;
    CAttrArray **ppAry;
    DISPID dispID;
    VARIANT varNew;
    PROPERTYDESC *pDesc = NULL;


    varNew.vt = VT_I4;
    varNew.lVal = (long)lValue;

    // For now - going to get much smarter than this
    
    ppAry = pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
    if ( !ppAry )
        goto Cleanup;

    switch ( propertyType )
    {
    case 0: // BackColor
        dispID = DISPID_BACKCOLOR;
        pDesc = (PROPERTYDESC *)&s_propdescCStylebackgroundColor;
        break;

    case 1: // TextColor
        dispID = DISPID_A_COLOR;
        pDesc = (PROPERTYDESC *)&s_propdescCStylecolor;
        break;

    case 2: // Display (used to be 'rectangular' prop, now 'display:inline-block')
        dispID = DISPID_A_DISPLAY;
        pDesc = (PROPERTYDESC *)&s_enumdescstyleDisplay;
        break;

    case 3: // LayoutType 
        {
        CPeerHolder *pPH = pElement->GetPeerHolder();
        if ( pPH )
        {
            pPH->_pLayoutBag->_lLayoutInfo = lValue;
        }
        goto Cleanup;
        }
        break;

    case 4: // Positioning
        dispID = DISPID_A_POSITION;
        pDesc = (PROPERTYDESC *)&s_propdescCStyleposition;
        break;

    default:
        goto Cleanup;
    } 

    hr = THR(CAttrArray::Set ( ppAry, dispID, &varNew, NULL, CAttrValue::AA_StyleAttribute, 0 ) );
    if (hr)
        goto Cleanup;

    if (pDesc)
        hr = THR(pElement->OnPropertyChange(dispID, pDesc->GetdwFlags()));

Cleanup:
    return hr;
}

HRESULT CExternalFrameworkSite::SetStringRenderProperty ( long lRef, long propertyType, BSTR bstrValue )
{
    HRESULT hr=S_OK;
 
    CElement *pElement = (CElement *)lRef;

    return hr;
}

HRESULT CExternalFrameworkSite::ReleaseElement ( long lRef )
{
    CElement *pElement = (CElement *)lRef;
    CDoc *pDoc = pElement->Doc();

    // Remove our own artificial AddRef() - element should now go away
    pElement->Release();

    Assert(lExternalElems>0);

    if (--lExternalElems == 0 )
    {
        pDoc->ReleaseFrameworkDoc();
    }
    return S_OK;
}

HRESULT CExternalFrameworkSite::AddTagsHelper(long lNamespaceCookie, LPTSTR pchTags, BOOL fLiteral)
{
    IElementNamespace *pNamespace = (IElementNamespace *)lNamespaceCookie;
    TCHAR *pchTag;
    TCHAR chOld;
    HRESULT hr = S_OK;

    while(pchTags && *pchTags)
    {
        pchTag = pchTags;
        while(*pchTags && *pchTags != _T(','))
            pchTags++;
        chOld = *pchTags;
        *pchTags = _T('\0');
        hr = THR(pNamespace->AddTag(pchTag, fLiteral ? ELEMENTDESCRIPTORFLAGS_LITERAL : 0));
        *pchTags = chOld;
        if (chOld)
            pchTags++;
    }

    RRETURN(hr);
}

HRESULT CExternalFrameworkSite::AddLiteralTags(long lNamespaceCookie, BSTR bstrLiteralTags)
{
    RRETURN(AddTagsHelper(lNamespaceCookie, bstrLiteralTags, TRUE));
}

IExternalDocument *CDoc::EnsureExternalFrameWork()
{
    HRESULT hr = S_OK;
    CLSID clsid;
    IExternalDocumentSite *pSite = NULL;

    if (_pFrameworkDoc || GetObjectRefs() == 0)
    {
        goto Cleanup;
    }
    
    // For now it's called CElement - need to change the COM+ Code <g>
    hr = THR(CLSIDFromProgID( TEXT("System.UI.Html.Impl.DocThunk"), &clsid));
    if ( hr )
        goto Cleanup;

    hr = CoCreateInstance(clsid, NULL,
                          CLSCTX_INPROC_SERVER, IID_IExternalDocument,
                          (void **)&_pFrameworkDoc);
    if (hr)
        goto Cleanup;

    hr = _extfrmwrkSite.QueryInterface (IID_IExternalDocumentSite, (void**)&pSite);
    if (hr)
        goto Cleanup;

    hr = _pFrameworkDoc->SetSite ( pSite );
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pSite);
    return _pFrameworkDoc;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmDocument::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
CExternalFrameworkSite::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT      hr = S_OK;
    const void * apfn = NULL;
    void *       pv = NULL;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IUnknown *)this, IUnknown)
        QI_INHERITS2(this, IDispatch, IExternalDocumentSite)
    default:
        if ( iid == IID_IExternalDocumentSite )
        {
            *ppv = (IExternalDocumentSite *)this;  
        }
        break;
    }

    if (*ppv)
        ((IUnknown *)*ppv)->AddRef();
    else if (!hr)
        hr = E_NOINTERFACE;

    DbgTrackItf(iid, "CExternalFrameworkSite", FALSE, ppv);

    return hr;
}
#endif V4FRAMEWORK



#ifdef V4FRAMEWORK
// Expanded the SUBOBJECT Macro so I can debug the calls properly
CDoc * CExternalFrameworkSite::Doc()                           
{                                                               
    return CONTAINING_RECORD(this, CDoc, _extfrmwrkSite);         
}                                                               
inline BOOL CExternalFrameworkSite::IsMyParentAlive(void)                          
    { return Doc()->GetObjectRefs() != 0; }              
STDMETHODIMP_(ULONG) CExternalFrameworkSite::AddRef( )                             
    { return Doc()->SubAddRef(); }                       
STDMETHODIMP_(ULONG) CExternalFrameworkSite::Release( )                            
    { return Doc()->SubRelease(); }
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT
CExternalFrameworkSite::SetElementPosition (DISPID dispID,
                 long lValue, CAttrArray **ppAttrArray,
                 BOOL * pfChanged)
{
    CUnitValue          uvValue;
    HRESULT             hr = S_OK;
    long                lRawValue;

    Assert(pfChanged);
    uvValue.SetNull();

    Assert(ppAttrArray);
    
    if (*ppAttrArray)
    {
        (*ppAttrArray)->GetSimpleAt(
            (*ppAttrArray)->FindAAIndex(dispID, CAttrValue::AA_Attribute),
            (DWORD*)&uvValue );
    }

    lRawValue = uvValue.GetRawValue(); // To see if we've changed

    uvValue.SetValue(lValue, CUnitValue::UNIT_PIXELS );
    
    if ( uvValue.GetRawValue() == lRawValue ) // Has anything changed ??
        goto Cleanup;

    hr = THR(CAttrArray::AddSimple ( ppAttrArray, dispID, uvValue.GetRawValue(),
                                     CAttrValue::AA_StyleAttribute ));

    if (hr)
        goto Cleanup;

    *pfChanged = TRUE;

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::PositionElement(long lRefElement, long nTop, long nLeft, long nWidth, long nHeight)
{
    /* Call this code if I want to keey the legacy OM in sync ???
    CAttrArray **ppAry;
    BOOL fChanged = FALSE;
    CElement *pElement = (CElement *)lRefElement;
    HRESULT hr = S_OK;

    Assert(pElement->Tag()==ETAG_GENERIC);

    ppAry = pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
    if ( !ppAry )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(SetElementPosition(STDPROPID_XOBJ_TOP, nTop, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_LEFT, nLeft, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_WIDTH, nWidth, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_HEIGHT, nHeight, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;
    */
    CElement *pElement = (CElement *)lRefElement;
    HRESULT hr = S_OK;
    CLayout   * pLayout;

    pLayout = pElement->GetUpdatedLayout();
    if ( !pLayout )
        goto Cleanup;

    {

        CFlowLayout *pFlowLayout = DYNCAST(CFlowLayout, pElement->GetUpdatedParentLayout());
        Assert( pFlowLayout );

        CCalcInfo CI(pLayout);

        pLayout->EnsureDispNode(&CI, TRUE /*??*/);

        pFlowLayout->AddLayoutDispNode( &CI, pLayout->ElementOwner()->GetFirstBranch(), nTop, nLeft, NULL );

        //pLayout->SetPosition(nTop, nLeft);
        pLayout->SizeDispNode(&CI, nWidth, nHeight, TRUE /*??*/ );
    }

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::ParentElement(long lRefElement, long *lParentRef)
{
    HRESULT hr = S_OK;
    CGenericElement::COMPLUSREF cpRef;

    CElement *pElem = (CElement *)lRefElement;
    CTreeNode *pNode;

    Assert(pElem);
    Assert(pElem->Tag()==ETAG_GENERIC);

    if (!lParentRef)
    {
        hr=E_POINTER;
        goto Cleanup;
    }
    *lParentRef=0;

    pNode = pElem->GetFirstBranch(); // Ignore overlapping for now

    Assert( !pNode || !pNode->IsDead() );

    // if still no node, we are not in the tree, return NULL
    if (!pNode)
        goto Cleanup;

    pNode = pNode->Parent();

    // TODO need to sort out the last condition here - what to do with HTML tags!!
    if (!pNode || pNode->Tag() == ETAG_ROOT || pNode->Tag() != ETAG_GENERIC)
        goto Cleanup;

    pElem = pNode->Element();

    hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
    if ( hr )
        goto Cleanup;

    *lParentRef = (long)cpRef; // again ignore overlapping

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::MoveElement(long lRefElement, long nTop, long nLeft)
{
    CAttrArray **ppAry;
    BOOL fChanged = FALSE;
    HRESULT hr = S_OK;

    CElement *pElement = (CElement *)lRefElement;

    Assert(pElement->Tag()==ETAG_GENERIC);

    ppAry = pElement->CreateStyleAttrArray(DISPID_INTERNAL_INLINESTYLEAA);
    if ( !ppAry )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(SetElementPosition(STDPROPID_XOBJ_TOP, nTop, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    hr = THR(SetElementPosition(STDPROPID_XOBJ_LEFT, nLeft, ppAry, &fChanged));
    if ( hr )
        goto Cleanup;

    if ( fChanged )
    {
        pElement->RemeasureElement( NFLAGS_FORCE );
    }

Cleanup:
    RRETURN(hr);
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::SizeElement(long lRefElement, long Width, long Height)
{
    return S_OK;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CExternalFrameworkSite::ZOrderElement(long lRefElement, long ZOrder)
{
    return S_OK;
}
#endif V4FRAMEWORK


HRESULT
CDocument::get_media(BSTR * pbstr)
{
    HRESULT hr = S_OK;
    if (!pbstr)
        RRETURN (E_POINTER);

    Assert(Markup());
    hr = STRINGFROMENUM( mediaType, Markup()->GetMedia(), pbstr );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

HRESULT
CDocument::put_media(BSTR bstr)
{
    HRESULT hr = S_OK;

    Assert(Markup());
    if (!Markup()->IsPrintTemplate())
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }
    
    hr = putMediaHelper(bstr);

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

HRESULT
CDocument::putMediaHelper(BSTR bstr)
{
    HRESULT hr = S_OK;
    mediaType type;

    hr = ENUMFROMSTRING( mediaType, bstr, (long *) & type);
    if (hr)
        goto Cleanup;

    Assert(Markup());
    Markup()->SetMedia(type);

    // TODO (KTam): It doesn't look like format cache clearing works via
    // CDocument::OnPropertyChange (only formats on the root element get cleared;

    // we don't go through ClearRunCaches or anything like it).  That's OK since
    // CMarkup::SetMedia now does an EnsureFormatsCacheChange (like CElement::OnPropertyChange),
    IGNORE_HR(OnPropertyChange(DISPID_CDocument_media, 
                               ELEMCHNG_CLEARCACHES|FORMCHNG_LAYOUT, 
                               (PROPERTYDESC *)&s_propdescCDocumentmedia));
    
Cleanup:
    return hr;
}

#if DBG
void
CDocExtra::DumpLayoutRects( BOOL fDumpLines /*=TRUE*/ )
{
    CTreeNode *pNodeIter = NULL;
    CTreeNode *pInnerNodeIter = NULL;
    CElement *pElementIter = NULL;
    CElement *pInnerElementIter = NULL;
    CLayoutInfo *pLayoutIter = NULL;
    CLayoutInfo *pInnerLayoutIter = NULL;
    CElement *pElementSlave = NULL;
    CMarkup *pPrimaryMarkup = ((CDoc*)(this))->PrimaryMarkup();
    CChildIterator outerIter( pPrimaryMarkup->Root(), NULL, CHILDITERATOR_DEEP );

    // TODO: Reorganize output.  One idea: dump all layout rects first
    // so we have defining context information for them all.  Then dump
    // layouts of slave markups.  Do this by pushing slave markups onto
    // a stack as we walk.  Also handle device rects (and whatever else
    // defines context).

    if (!InitDumpFile())
        return;

    WriteString( g_f,
        _T("\r\n------------- LAYOUT RECTS -------------------------------\r\n" ));

    while ( (pNodeIter = outerIter.NextChild()) != NULL )
    {
        pElementIter = pNodeIter->Element();
        if ( pElementIter->IsLinkedContentElement() )
        {
            Assert( pElementIter->CurrentlyHasAnyLayout() );
            pLayoutIter = pElementIter->GetLayoutInfo();
            Assert( pLayoutIter );

            WriteHelp(g_f, _T("<0s>: 0x<1x> ID=<2s>\r\n"), pElementIter->TagName(), pElementIter, pElementIter->GetAAid());

            pLayoutIter->DumpLayoutInfo( fDumpLines );

            pElementSlave = pElementIter->GetSlaveIfMaster();

            // GetSlaveIfMaster() returns "this" if no slave
            if ( pElementSlave != pElementIter )
            {
                // ..we have a slave
                Assert( pElementIter->HasSlavePtr() );
                CChildIterator innerIter( pElementSlave, NULL, CHILDITERATOR_DEEP );
                while ( (pInnerNodeIter = innerIter.NextChild()) != NULL )
                {
                    pInnerElementIter = pInnerNodeIter->Element();
                    if ( pInnerElementIter->CurrentlyHasAnyLayout() )
                    {
                        WriteHelp(g_f, _T("<0s>: 0x<1x>\r\n"), pInnerElementIter->TagName(), pInnerElementIter);
                        pInnerLayoutIter = pInnerElementIter->GetLayoutInfo();
                        Assert( pInnerLayoutIter );
                        pInnerLayoutIter->DumpLayoutInfo( fDumpLines );
                    }
                }
            }
            else
            {
                WriteString(g_f, _T(" -- no slave on this layout rect --\r\n"));
            }
        }
    }

    WriteString( g_f,
        _T("\r\n--- END LAYOUT RECTS -------------------------------\r\n" ));

    CloseDumpFile();
}
#endif


BOOL
CDoc::DesignMode()
{ 
    CMarkup * pMarkup = PrimaryMarkup();
    return pMarkup ? pMarkup->_fDesignMode : FALSE; 
}


//+====================================================================================
//
// Method: SetEditBitsForMarkup
//
// Synopsis: Set the default values of editing bits - based on what was in the registry
//
//------------------------------------------------------------------------------------


VOID
CDoc::SetEditBitsForMarkup( CMarkup* pMarkup )
{
    if ( _fShowAlignedSiteTags ||
         _fShowCommentTags ||
         _fShowStyleTags ||
         _fShowAreaTags ||
         _fShowUnknownTags ||
         _fShowMiscTags ||
         _fShowWbrTags )
    {
        pMarkup->GetGlyphTable()->_fShowAlignedSiteTags = _fShowAlignedSiteTags;
        pMarkup->GetGlyphTable()->_fShowCommentTags = _fShowCommentTags;
        pMarkup->GetGlyphTable()->_fShowStyleTags = _fShowStyleTags;
        pMarkup->GetGlyphTable()->_fShowAreaTags = _fShowAreaTags;
        pMarkup->GetGlyphTable()->_fShowUnknownTags = _fShowUnknownTags;
        pMarkup->GetGlyphTable()->_fShowMiscTags = _fShowMiscTags;
        pMarkup->GetGlyphTable()->_fShowWbrTags = _fShowWbrTags;
    }

    if ( _fShowZeroBorderAtDesignTime )
    {
        SET_EDIT_BIT( pMarkup,_fShowZeroBorderAtDesignTime , _fShowZeroBorderAtDesignTime);
    }
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ResetProgressData
//
//  Synopsis:   Resets the progress bar data.
//
//---------------------------------------------------------------

void
CDoc::ResetProgressData()
{
    _ulProgressPos  = 0;
    _ulProgressMax  = 0;
    _fShownProgPos  = FALSE;
    _fShownProgMax  = FALSE;
    _fShownProgText = FALSE;
    _fProgressFlash = FALSE;
}

COmWindowProxy *
CDoc::GetOuterWindow()
{
    COleSite * pOleSite;
    
    Assert(_fViewLinkedInWebOC);

    if (S_OK == IUnknown_QueryService(_pClientSite, CLSID_HTMLFrameBase, CLSID_HTMLFrameBase, (void **) &pOleSite))
        return pOleSite->GetWindowedMarkupContext()->GetWindowPending();

    return NULL;
}

//
//  Called by shdocvw to transfer it's privacy info to Trident's list
//
HRESULT
CDoc::AddPrivacyInfoToList( LPOLESTR  pUrl, 
                            LPOLESTR  pPolicyRefURL, 
                            LPOLESTR  pP3PHeader,
                            LONG      dwReserved,
                            DWORD     privacyFlags)
{
    HRESULT           hr              = S_OK;
    TCHAR           * pLocalP3PHeader = NULL;
    unsigned long     ulLen           = 0;
    CMarkup         * pMarkup         = NULL;

    hr = AddToPrivacyList(pUrl, pPolicyRefURL, privacyFlags);

    if (pUrl && *pUrl)
    {
        if (pP3PHeader)
        {
            ulLen = _tcslen(pP3PHeader);
            pLocalP3PHeader = new TCHAR[ulLen + 1];
            if (FAILED(hr))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            _tcscpy(pLocalP3PHeader, pP3PHeader);
        }
        
        pMarkup = PendingPrimaryMarkup();
        if (!pMarkup)
            pMarkup = PrimaryMarkup();
        if (pMarkup && pLocalP3PHeader)
            hr = pMarkup->SetPrivacyInfo(&pLocalP3PHeader);
    }
    
Cleanup:
    if (FAILED(hr))
        delete [] pLocalP3PHeader;

    RRETURN(hr);
}

HRESULT
CDoc::AddToPrivacyList(const TCHAR * pchUrl, const TCHAR * pchPolicyRef /* =NULL */, DWORD dwFlags /* =0 */, BOOL fPending /* =TRUE*/)
{

    TraceTag((tagPrivacyAddToList, "url %ls being added to privacy list with policyRef %ls, privacyFlags %x", pchUrl, pchPolicyRef, dwFlags));

    HRESULT       hr       = S_OK;

    if (!_pPrivacyList)
    {
        TraceTag((tagPrivacyAddToList, "No privacy list on the doc, cannot add"));
        goto Cleanup;
    }

    if (_fBlockNonPending && !fPending)
    {
        TraceTag((tagPrivacyAddToList, "Blocked %ls from being added to privacy list", pchUrl));
        goto Cleanup;
    }

    BOOL oldState = _pPrivacyList->GetPrivacyImpacted();

    hr = THR(_pPrivacyList->AddNode(pchUrl, pchPolicyRef, dwFlags));
        
    if (SUCCEEDED(hr) && !oldState)
    {
        BOOL newState = _pPrivacyList->GetPrivacyImpacted();

        // Fire a change so we can show the impacted icon, clearing this icon is done in ResetPrivacyList
        if (newState  &&  _pTridentSvc)
        {
            GWPostMethodCallEx(_pts, (void*)this, ONCALL_METHOD(CDoc, OnPrivacyImpactedStateChange, onprivacyimpactedstatechange),
                               NULL, TRUE, "CDoc::OnPrivacyImpactedStateChange");
            TraceTag((tagPrivacyAddToList, "POSTED PrivacyImpactedStateChange call for state - %x", newState));
        }
    }

Cleanup:
    RRETURN(hr);
}

void
CDoc::OnPrivacyImpactedStateChange(DWORD_PTR pdwImpacted)
{
    // don't do anything if we are shutting down
    if (IsShut())
        return;

    ITridentService2 * pTridentSvc2 = NULL;
    HRESULT            hr = THR(_pTridentSvc->QueryInterface(IID_ITridentService2, (void**)&pTridentSvc2));

    if (hr == S_OK)
    {
        pTridentSvc2->FirePrivacyImpactedStateChange(_pPrivacyList->GetPrivacyImpacted());
    }
    else
    {
        TraceTag((tagPrivacyAddToList,"Failed to fire PrivacyStateChange event."));
    }

    ReleaseInterface(pTridentSvc2);
}

HRESULT
CDoc::ResetPrivacyList()
{
    TraceTag((tagPrivacyAddToList,"Privacy list was reset"));

    if (!_pPrivacyList)
    {
        RRETURN(S_OK);
    }
    
    BOOL oldState = _pPrivacyList->GetPrivacyImpacted();
    HRESULT hr = THR(_pPrivacyList->ClearNodes());

    //This is guaranteed to be called on the UI thread, so fire the change here directly
    if (SUCCEEDED(hr) && oldState && _pTridentSvc)
        OnPrivacyImpactedStateChange(0);

    _fBlockNonPending = TRUE;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\fpersist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       persist.cxx
//
//  Contents:   Contains the saving and loading code for the form
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"   // for databinding
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"  // for _pimganim
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include "urlcomp.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_WINCRYPT_H_
#define X_WINCRYPT_H_
#include "wincrypt.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_DWNNOT_H_
#define X_DWNNOT_H_
#include <dwnnot.h>
#endif

#ifndef X_EVENTOBJ_H_
#define X_EVENT_OBJ_H_
#include "eventobj.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_SHFOLDER_HXX_
#define X_SHFOLDER_HXX_
#define _SHFOLDER_
#include "shfolder.h"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#define _hxx_
#include "hedelems.hdl"

#include <platform.h>

// N.B. taken from shlguidp.h of shell enlistment fame
// Consider: include this file instead (but note that this is a private guid)
#define WSZGUID_OPID_DocObjClientSite _T("{d4db6850-5385-11d0-89e9-00a0c90a90ac}")

extern "C" const CLSID CLSID_HTMLPluginDocument;

HRESULT CreateStreamOnFile(LPCTSTR    lpstrFile,
                           DWORD      dwSTGM,
                           LPSTREAM * ppstrm);

BOOL IsInIEBrowser(CDoc * pDoc);

extern CGlobalCriticalSection   g_csFile;
extern TCHAR                    g_achSavePath[];

//+---------------------------------------------------------------
//  Debugging support
//---------------------------------------------------------------

DeclareTag(tagFormP,            "FormPersist", "Form Persistence");
DeclareTag(tagDocRefresh,       "Doc",          "Trace ExecRefresh");
ExternTag(tagMsoCommandTarget);
ExternTag(tagPageTransitionTrace);
PerfDbgExtern(tagPushData)
PerfDbgExtern(tagPerfWatch)
DeclareTag(tagDontOverrideCharset, "Markup",   "Don't override Meta Charset tag");
DeclareTag(tagDontRewriteDocType, "Markup", "Don't rewrite DocType tag");

MtDefine(CDocSaveToStream_aryElements_pv, Locals, "CDoc::SaveToStream aryElements::_pv")
MtDefine(CDocSaveSnapShotDocument_aryElements_pv, Locals, "CDoc::SaveSnapShotDocument aryElements::_pv")
MtDefine(LoadInfo_pchSearch, Locals, "CDoc::LOADINFO::pchSearch")
MtDefine(NewDwnCtx, Dwn, "CDoc::NewDwnCtx")
WHEN_DBG( void DebugSetTerminalServer(); )

//+---------------------------------------------------------------
//  Sturcture used in creating a desktop item.
//---------------------------------------------------------------

typedef struct {
    LPCTSTR pszUrl;
    HWND hwnd;
    DWORD dwItemType;
    int x;
    int y;
} CREATEDESKITEM;

static HRESULT CreateDesktopItem(LPCTSTR pszUrl, HWND hwnd, DWORD dwItemType, int x, int y);
MtDefine(SetAsDesktopItem, Utilities, "Set As Desktop Item...")

//+---------------------------------------------------------------
//
//   IsGlobalOffline
//
// Long term - This should call UrlQueryInfo so that wininet is
// not loaded unless needed
//
//---------------------------------------------------------------
extern BOOL IsGlobalOffline(void);

// IEUNIX: Needs to know filter type and save file with filter type.
#ifdef UNIX
//
// I'm taking this out temporarily during my merge.
// To coordinate with steveshi about putting it back - v-olegsl.
//
#if 0 // Move it back temporary. #if 1
#define MwFilterType(pIn, bSet) ""
#else
extern "C" char* MwFilterType(char*, BOOL);
#endif
#endif /** UNIX **/

BOOL
IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
    HMODULE hModuleHandle = GetModuleHandleA("wininet.dll");

    if(!hModuleHandle)
        return FALSE;

    // Call InternetQueryOption when INTERNET_OPTION_LINE_STATE
    // implemented in WININET.
    if(InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

static BOOL
IsNotConnected()
{
#ifdef WIN16
    //BUGWIN16: Ned to implement the new wininet APIs
    return FALSE;
#else
    DWORD dwConnectedStateFlags;

    return(     !InternetGetConnectedState(&dwConnectedStateFlags, 0)       // Not connected
            &&  !(dwConnectedStateFlags & INTERNET_CONNECTION_MODEM_BUSY)); // Not dialed out to another connection
#endif
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsFrameOffline
//
//---------------------------------------------------------------

BOOL
CDoc::IsFrameOffline(DWORD *pdwBindf)
{
    BOOL fIsFrameOffline = FALSE;
    DWORD dwBindf = 0;

    if (_dwLoadf & DLCTL_FORCEOFFLINE)
    {
        fIsFrameOffline = TRUE;
        dwBindf = BINDF_OFFLINEOPERATION;
    }
    else if (_dwLoadf & DLCTL_OFFLINEIFNOTCONNECTED)
    {
        if (IsNotConnected())
        {
            fIsFrameOffline = TRUE;
            dwBindf = BINDF_OFFLINEOPERATION;
        }
        else
            dwBindf = BINDF_GETFROMCACHE_IF_NET_FAIL;
    }

    if (pdwBindf)
        *pdwBindf = dwBindf;

    return fIsFrameOffline;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsOffline
//
//---------------------------------------------------------------

BOOL
CDoc::IsOffline()
{
    // Call InternetQueryOption when INTERNET_OPTION_LINE_STATE
    // implemented in WININET.
    return ((IsFrameOffline()) || (IsGlobalOffline()) );
}

HRESULT
CDoc::SetDirtyFlag(BOOL fDirty)
{
    if( fDirty )
        _lDirtyVersion = MAXLONG;
    else
        _lDirtyVersion = 0;
    
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::IsDirty
//
//  Synopsis:   Method of IPersist interface
//
//  Notes:      We must override this method because we are a container.
//              In addition to normal base processing we must pass this
//              call recursively to our embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CDoc::IsDirty(void)
{
    HRESULT  hr = S_OK;

    // NOTE: (rodc) Never dirty in browse mode.
    if (!DesignMode())
        return S_FALSE;

    if (_lDirtyVersion != 0)
        return S_OK;

    if (PrimaryMarkup() && 
        (PrimaryMarkup()->_fHasFrames || _fHasOleSite))
    {
        hr = PrimaryMarkup()->Document()->IsDirty();
    }

    if (_lDirtyVersion == 0)
        return S_FALSE;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetCurFile, IPersistFile
//
//----------------------------------------------------------------------------

HRESULT
CDoc::GetCurFile(LPOLESTR *ppszFileName)
{
    //delegate to the top level document
    RRETURN(THR(PrimaryMarkup()->Document()->GetCurFile(ppszFileName)));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetClassID, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::GetClassID(CLSID *pclsid)
{
    // This method can be deleted if we can make IPersistFile a tearoff interface.
    if (pclsid == NULL)
    {
        RRETURN(E_INVALIDARG);
    }

    if (!_fFullWindowEmbed)
        *pclsid = *BaseDesc()->_pclsid;
    else
        *pclsid = CLSID_HTMLPluginDocument;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetCurMoniker, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::GetCurMoniker(IMoniker **ppmkName)
{
    RRETURN(THR(PrimaryMarkup()->Document()->GetCurMoniker(ppmkName)));
}

//+---------------------------------------------------------------------------
//
//  Helper:     ReloadAndSaveDocInCodePage
//
//  Synopsis:   Helper to encapsulate reloading a document and saving it.
//              Save the URL pszUrl in the file pszPath, in character set
//              codepage.
//----------------------------------------------------------------------------
static HRESULT
ReloadAndSaveDocInCodePage(LPTSTR pszUrl, LPTSTR pszPath, CODEPAGE codepage,
    CODEPAGE codepageLoad, CODEPAGE codepageLoadURL)
{
    CDoc::LOADINFO LoadInfo = { 0 };
    MSG         msg;
    HRESULT     hr  = S_OK;
    CMarkup   * pMarkup;

    // No container, not window enabled, not MHTML.
    CDoc *pTempDoc = new CDoc(NULL);

    if (!pTempDoc)
        goto Cleanup;

    pTempDoc->Init();

    // Don't execute scripts, we want the original.
    pTempDoc->_dwLoadf |= DLCTL_NO_SCRIPTS | DLCTL_NO_FRAMEDOWNLOAD |
                          DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_CLIENTPULL |
                          DLCTL_SILENT | DLCTL_NO_JAVA | DLCTL_DOWNLOADONLY;

    hr = CreateURLMoniker(NULL, LPTSTR(pszUrl), &LoadInfo.pmk);
    if (hr || !LoadInfo.pmk)
        goto Cleanup;

    LoadInfo.pchDisplayName = pszUrl;
    LoadInfo.codepageURL = codepageLoadURL;
    LoadInfo.codepage = codepageLoad;

    hr = pTempDoc->LoadFromInfo(&LoadInfo);
    if (hr)
        goto Cleanup;

    // TODO Arye: I don't like having a message loop here,
    // Neither does Dinarte, nor Gary. But no one has a better
    // idea that can be implemented in a reasonable length of
    // time, so we'll do this for now so that Save As ... is a
    // synchronous operation.
    //
    // Process messages until we've finished loading.

    for (;;)
    {
        GetMessage(&msg, NULL, 0, 0);
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        if (pTempDoc->LoadStatus() >= LOADSTATUS_PARSE_DONE)
            break;
    }

    pMarkup = pTempDoc->PrimaryMarkup();

    hr = pMarkup->SetCodePage(codepage);                            // codepage of the doc
    if (hr)
        goto Cleanup;
    hr = pMarkup->SetFamilyCodePage(WindowsCodePageFromCodePage(codepage));  // family codepage of the doc
    if (hr)
        goto Cleanup;

    pMarkup->_fDesignMode = TRUE;          // force to save from the tree.

    IGNORE_HR(pTempDoc->Save(pszPath, FALSE));

Cleanup:
    ReleaseInterface(LoadInfo.pmk);

    if (pTempDoc)
    {
        pTempDoc->Close(OLECLOSE_NOSAVE);
        pTempDoc->Release();
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PromptSave
//
//  Synopsis:   This function saves the document to a file name selected by
//              displaying a dialog. It changes current document name to given
//              name.
//
//              NOTE: for this version, Save As will not change the
//              current filename.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::PromptSave(CMarkup *pMarkup, BOOL fSaveAs, BOOL fShowUI /* = TRUE */, TCHAR * pchPathName /* = NULL */)
{
    HRESULT                 hr = S_OK;
    TCHAR                   achPath[MAX_PATH];
    TCHAR *                 pchPath;
    CElement *              pElem;
    PARSEDURL               puw = {0};
    int                     cchUrl;
    TCHAR *                 pchQuery;
    CCollectionCache *      pCollectionCache;

    Assert(fShowUI || (!fShowUI && pchPathName));
    Assert (pMarkup);

    // Save image files as native file type
    if (pMarkup->IsImageFile())
    {
        Assert(fSaveAs); // image files are not editable       

        // Locate the image element
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::IMAGES_COLLECTION));
        if (hr)
            goto Cleanup;

        pCollectionCache = pMarkup->CollectionCache();
        Assert(pCollectionCache);

        // We must have exactly one image in this document
        if (1 != pCollectionCache->SizeAry(CMarkup::IMAGES_COLLECTION))
        {
            Assert(FALSE);
            goto Cleanup;
        }

        hr = THR(pCollectionCache->GetIntoAry(CMarkup::IMAGES_COLLECTION, 0, &pElem));
        if (hr)
            goto Cleanup;
        Assert(pElem->Tag() != ETAG_INPUT);
        hr = THR(DYNCAST(CImgElement, pElem)->_pImage->PromptSaveAs(achPath, MAX_PATH));
        if (hr)
            goto Cleanup;
        pchPath = achPath;
    }
    else
    {
        CODEPAGE codepage = pMarkup->GetCodePage();

        if (fSaveAs)
        {
            if (!fShowUI)
            {
                pchPath = pchPathName;
            }
            else
            {
                achPath[0] = 0;

                if (pchPathName)
                {
                    _tcsncpy(achPath, pchPathName, MAX_PATH);
                    achPath[MAX_PATH - 1] = 0;
                }
                else
                {
                    // Get file name from _cstrUrl
                    // Note that location is already stripped out from the URL
                    // before it is copied into _cstrUrl. If _cstrUrl ends in '/',
                    // we assume that it does not have a file name at the end
                    const TCHAR * pchUrl = CMarkup::GetUrl(pMarkup);
                    if (pchUrl)
                    {
                        cchUrl = _tcslen(pchUrl);
                        if (cchUrl && pchUrl[cchUrl - 1] != _T('/'))
                        {
                            puw.cbSize = sizeof(PARSEDURL);
                            if (SUCCEEDED(ParseURL(pchUrl, &puw)))
                            {
                                // Temporarily, null out the '?' in the url
                                pchQuery = _tcsrchr(puw.pszSuffix, _T('?'));
                                if (pchQuery)
                                    *pchQuery = 0;
                                _tcsncpy(achPath, PathFindFileName(puw.pszSuffix), MAX_PATH);
                                if (pchQuery)
                                    *pchQuery = _T('?');

                                achPath[MAX_PATH - 1] = 0;
                            }
                        }
                    }
                }
                if (!achPath[0])
                {
                    LoadString(GetResourceHInst(), IDS_UNTITLED_MSHTML,
                               achPath, ARRAY_SIZE(achPath));
                }

                {
                    CDoEnableModeless   dem(this, pMarkup->GetWindowedMarkupContextWindow());

                    if (dem._hwnd)
                    {
                        hr = RequestSaveFileName(achPath, ARRAY_SIZE(achPath), &codepage);
                    }

                    if ( hr || !dem._hwnd)
                        goto Cleanup;
                }
                
                pchPath = achPath;
            }
        }
        else
        {
            pchPath = NULL;
        }

        if (pMarkup->GetCodePage() != codepage && fSaveAs)
        {
            if (pMarkup->_fDesignMode)
            {
                // TODO (johnv) This is a bit messy.  CDoc::Save should
                // take a codepage parameter.
                // Save from the tree, but in a different codepage.
                CODEPAGE codepageInitial = pMarkup->GetCodePage();
                CODEPAGE codepageFamilyInitial = pMarkup->GetFamilyCodePage();

                IGNORE_HR(pMarkup->SetCodePage(codepage));
                IGNORE_HR(pMarkup->SetFamilyCodePage(WindowsCodePageFromCodePage(codepage)));
                hr = THR(SaveHelper(pMarkup, pchPath, pMarkup->_fDesignMode));
                IGNORE_HR(pMarkup->SetCodePage(codepageInitial));
                IGNORE_HR(pMarkup->SetFamilyCodePage(codepageFamilyInitial));
                IGNORE_HR(pMarkup->UpdateCodePageMetaTag(codepageInitial));

                if (hr)
                    goto Cleanup;
            }
            else
            {
                // Create a separate document, loading it in without
                // actually running any scripts.
                hr = THR(ReloadAndSaveDocInCodePage ((TCHAR *) CMarkup::GetUrl(pMarkup),
                            pchPath, codepage, pMarkup->GetCodePage(), NavigatableCodePage(pMarkup->GetURLCodePage())));

                if (hr)
                    goto Cleanup;
            }

        }
        else
        {
            hr = THR(SaveHelper(pMarkup, pchPath, pMarkup->_fDesignMode));
            if (hr)
                goto Cleanup;
        }
    }
    hr = THR(SaveCompletedHelper(pMarkup, pchPath));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PromptSaveImgCtx
//
//----------------------------------------------------------------------------

HRESULT
CDoc::PromptSaveImgCtx(const TCHAR * pchCachedFile, const MIMEINFO * pmi,
                       TCHAR * pchFileName, int cchFileName)
{
    HRESULT hr;
    TCHAR * pchFile;
    TCHAR * pchFileExt;
    int     idFilterRes = IDS_SAVEPICTUREAS_ORIGINAL;

    Assert(pchCachedFile);

    // If there is no save directory then save
    // to the "My Pictures" Dir.
    {
        // NB: to keep from eating up too much stack, I'm going
        // to temporarily use the pchFileName buffer that is passed
        // in to construct the "My Pictures" dir string.

        // Also if the directory doesn't exist, then just leave g_achSavePath
        // NULL and we will default to the desktop

        LOCK_SECTION(g_csFile);

        if (!*g_achSavePath)
        {
            hr = SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, 0, pchFileName);
            if (hr == S_OK && PathFileExists(pchFileName))
            {
                _tcscpy(g_achSavePath, pchFileName);
            }
        }
    }

    pchFile = _tcsrchr(pchCachedFile, _T(FILENAME_SEPARATOR));
    if (pchFile && *pchFile)
        _tcsncpy(pchFileName, ++pchFile, cchFileName - 1);
    else
        _tcsncpy(pchFileName, pchCachedFile, cchFileName - 1);
    pchFileName[cchFileName - 1] = _T('\0');

#ifndef UNIX // UNIX needs extension name if available.
    pchFileExt = _tcsrchr(pchFileName, _T('.'));
//    if (pchFileExt)
//        *pchFileExt = _T('\0');
#endif

    if (pmi && pmi->ids)
        idFilterRes = pmi->ids;

    {
        // TODO: We need to pass window context down here
        CDoEnableModeless   dem(this, NULL);
        
        if (dem._hwnd)
        {
            hr = FormsGetFileName(TRUE,  // indicates SaveFileName
                                  dem._hwnd,
                                  idFilterRes,
                                  pchFileName,
                                  cchFileName, (LPARAM)0);
        }
        else
            hr = E_FAIL;
    }
    
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveImgCtxAs
//
//----------------------------------------------------------------------------

void
CDoc::SaveImgCtxAs(CImgCtx *    pImgCtx,
                   CBitsCtx *   pBitsCtx,
                   int          iAction,
                   TCHAR *      pchFileName /*=NULL*/,
                   int          cchFileName /*=0*/)
{
#ifndef WINCE
    HRESULT hr = S_OK;
    TCHAR achPath1[MAX_PATH];
    TCHAR achPath2[MAX_PATH];
    TCHAR * pchPathSrc = NULL;
    TCHAR * pchPathDst = NULL;
    TCHAR * pchAlloc = NULL;
    int idsDefault;
    BOOL fSaveAsBmp;

    if (pBitsCtx)
    {
        idsDefault = IDS_ERR_SAVEPICTUREAS;

        hr = pBitsCtx->GetFile(&pchAlloc);
        if (hr)
            goto Cleanup;

        hr = PromptSaveImgCtx(pchAlloc, pBitsCtx->GetMimeInfo(), achPath1, ARRAY_SIZE(achPath1));
        if (hr)
            goto Cleanup;

        pchPathSrc = pchAlloc;
        pchPathDst = achPath1;
        fSaveAsBmp = FALSE;
    }
    else if (pImgCtx)
    {
        switch(iAction)
        {
            case IDM_SETWALLPAPER:
                idsDefault = IDS_ERR_SETWALLPAPER;

                hr = SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, achPath2);
                if (hr)
                    goto Cleanup;

                _tcscat(achPath2, _T("\\Microsoft"));
                if (!PathFileExists(achPath2) && !CreateDirectory(achPath2, NULL))
                {
                    hr = GetLastWin32Error();
                    goto Cleanup;
                }
                _tcscat(achPath2, _T("\\Internet Explorer"));
                if (!PathFileExists(achPath2) && !CreateDirectory(achPath2, NULL))
                {
                    hr = GetLastWin32Error();
                    goto Cleanup;
                }

                hr = Format(0, achPath1, ARRAY_SIZE(achPath1), MAKEINTRESOURCE(IDS_WALLPAPER_BMP), achPath2);
                if (hr)
                    goto Cleanup;

                pchPathDst = achPath1;
                fSaveAsBmp = TRUE;
                break;

            case IDM_SETDESKTOPITEM:
            {
                LPCTSTR lpszURL = pImgCtx->GetUrl();

                idsDefault = IDS_ERR_SETDESKTOPITEM;
                fSaveAsBmp = FALSE;
                if(lpszURL)
                    hr = CreateDesktopItem( lpszURL,
                                            //(_pInPlace ? _pInPlace->_hwnd : GetDesktopWindow()), //Parent window for the UI dialog boxes
                                            GetDesktopWindow(), // If you set _pInPlace->hwnd as the parent, it gets disabled.
                                            COMP_TYPE_PICTURE,          // Desktop item type is IMG.
                                            COMPONENT_DEFAULT_LEFT,     // Default position of top left corner
                                            COMPONENT_DEFAULT_TOP );    // Default position of top
                else
                    hr = E_FAIL;

                if(hr)
                    goto Cleanup;
                break;
            }

            case IDM_SAVEPICTURE:
            default:
                const MIMEINFO * pmi = pImgCtx->GetMimeInfo();

                idsDefault = IDS_ERR_SAVEPICTUREAS;

                hr = pImgCtx->GetFile(&pchAlloc);
                if (hr)
                {
                    if (!LoadString(GetResourceHInst(), IDS_UNTITLED_BITMAP, achPath2, ARRAY_SIZE(achPath2)))
                    {
                        hr = GetLastWin32Error();
                        goto Cleanup;
                    }

                    pmi = GetMimeInfoFromMimeType(CFSTR_MIME_BMP);
                    fSaveAsBmp = TRUE;
                    pchPathSrc = achPath2;
                }
                else
                {
                    fSaveAsBmp = FALSE;
                    pchPathSrc = pchAlloc;
                    _tcsncpy(achPath2, pchAlloc, ARRAY_SIZE(achPath2)-1);
                    achPath2[ARRAY_SIZE(achPath2)-1] = NULL;
                    PathUndecorate(achPath2);
                }

                hr = PromptSaveImgCtx(achPath2, pmi, achPath1, ARRAY_SIZE(achPath1));
                if (hr)
                    goto Cleanup;

                pchPathDst = achPath1;

                if (!fSaveAsBmp)
                {
#ifdef UNIX // IEUNIX uses filter to know save-type
                    fSaveAsBmp = !_strnicmp(".bmp", MwFilterType(NULL, FALSE), 4);
#else
                    TCHAR * pchFileExt = _tcsrchr(pchPathDst, _T('.'));
                    fSaveAsBmp = pchFileExt && _tcsnipre(_T(".bmp"), 4, pchFileExt, -1);
#endif
                }
                break;
        }
    }
    else
    {
        Assert(FALSE);
        return;
    }

    if(iAction != IDM_SETDESKTOPITEM)
    {
        Assert(pchPathDst);
        Assert(fSaveAsBmp || pchPathSrc);

        if (fSaveAsBmp)
        {
            IStream *pStm = NULL;

            hr = THR(CreateStreamOnFile(pchPathDst,
                                    STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
                                    &pStm));
            if (hr)
                goto Cleanup;

            hr = pImgCtx->SaveAsBmp(pStm, TRUE);
            ReleaseInterface(pStm);

            if (hr)
            {
                DeleteFile(pchPathDst);
                goto Cleanup;
            }
        }
        else if (!CopyFile(pchPathSrc, pchPathDst, FALSE))
        {
            hr = GetLastWin32Error();
            goto Cleanup;
        }

        if (pchFileName && cchFileName > 0)
        {
            _tcsncpy(pchFileName, pchPathDst, cchFileName - 1);
            pchFileName[cchFileName - 1] = 0; // _tcsncpy doesn't seem to do this
        }

        if (iAction == IDM_SETWALLPAPER)
        {
            if (!SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, pchPathDst,
                                  SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE))
            {
                hr = GetLastWin32Error();
                goto Cleanup;
            }
        }
    }

Cleanup:
    MemFreeString(pchAlloc);
    if (FAILED(hr))
    {
        SetErrorInfo(hr);
        THR(ShowLastErrorInfo(hr, idsDefault));
    }
    return;
#endif // WINCE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::RequestSaveFileName
//
//  Synopsis:   Provides the UI for the Save As.. command.
//
//  Arguments:  pszFileName    points to the buffer accepting the file name
//              cchFileName    the size of the buffer
//
//----------------------------------------------------------------------------

HRESULT
CDoc::RequestSaveFileName(LPTSTR pszFileName, int cchFileName, CODEPAGE *pCodePage)
{
    HRESULT  hr;

    Assert(pszFileName && cchFileName);

    hr = FormsGetFileName(TRUE,  // indicates SaveFileName
                          _pInPlace ? _pInPlace->_hwnd : 0,
                          IDS_HTMLFORM_SAVE,
                          pszFileName,
                          cchFileName, (LPARAM)pCodePage);
    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     SetFilename
//
//  Synopsis:   Sets the current filename of the document.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetFilename(CMarkup *pMarkup, const TCHAR *pchFile)
{
    TCHAR achUrl[pdlUrlLen];
    ULONG cchUrl = ARRAY_SIZE(achUrl);
    HRESULT hr;

#ifdef WIN16
    Assert(0);
#else
    hr = THR(UrlCreateFromPath(pchFile, achUrl, &cchUrl, 0));
    if (hr)
#endif
        goto Cleanup;

    hr = THR(SetUrl(pMarkup, achUrl));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     SetUrl
//
//  Synopsis:   Sets the current url of the document and updates the moniker
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SetUrl(CMarkup *pMarkup, const TCHAR *pchUrl, BOOL fKeepDwnPost)
{
    IMoniker *pmk = NULL;
    HRESULT hr;

    hr = THR(CreateURLMoniker(NULL, pchUrl, &pmk));
    if (hr)
        goto Cleanup;

    hr = THR(CMarkup::SetUrl(pMarkup, pchUrl));
    if (hr)
        goto Cleanup;

    DeferUpdateTitle(pMarkup);

    hr = THR( pMarkup->ReplaceMonikerPtr( pmk ) );
    if( hr )
        goto Cleanup;

    if (!fKeepDwnPost)
        pMarkup->ClearDwnPost();

    MemSetName((this, "CMarkup SSN=%d URL=%ls", _ulSSN, CMarkup::GetUrl(pMarkup)));

Cleanup:
    ClearInterface(&pmk);

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//   Static : CreateSnapShotDocument
//
//   Synopsis : as the name says...
//
//+-------------------------------------------------------------------------

static HRESULT
CreateSnapShotDocument(CDoc * pSrcDoc, CDoc ** ppSnapDoc)
{
    HRESULT         hr = S_OK;
    IStream       * pstmFile = NULL;
    MSG             msg;
    TCHAR         * pstrFile = NULL;
    CDoc          * pSnapDoc = NULL;

    if (!ppSnapDoc)
        return E_POINTER;
    if (!pSrcDoc)
        return E_INVALIDARG;

    *ppSnapDoc = NULL;

    // No container, not window enabled, not MHTML.
    pSnapDoc = new CDoc(NULL);
    if (!pSnapDoc)
        goto Cleanup;

    pSnapDoc->Init();

    // Don't execute scripts, we want the original.
    pSnapDoc->_dwLoadf |= DLCTL_NO_SCRIPTS | DLCTL_NO_FRAMEDOWNLOAD |
                          DLCTL_NO_CLIENTPULL |
                          DLCTL_SILENT | DLCTL_NO_JAVA | DLCTL_DOWNLOADONLY;

    pSnapDoc->PrimaryMarkup()->_fDesignMode = TRUE;          // force to save from the tree.

    pSrcDoc->PrimaryMarkup()->GetFile(&pstrFile);

    hr = THR(CreateStreamOnFile(pstrFile,
                STGM_READ | STGM_SHARE_DENY_NONE, &pstmFile));
    if (hr)
        goto Cleanup;

    hr = THR(pSnapDoc->Load(pstmFile));
    if (hr)
        goto Cleanup;
    //
    // Process messages until we've finished loading.
    do
    {
        if (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    } while ( pSnapDoc->LoadStatus() < LOADSTATUS_PARSE_DONE );

    // transfer doc to out parameter
    *ppSnapDoc = pSnapDoc;
    pSnapDoc = NULL;

Cleanup:
    ReleaseInterface(pstmFile);
    if (pSnapDoc)
    {
        // we are here due to an error
        pSnapDoc->Close(OLECLOSE_NOSAVE);
        pSnapDoc->Release();
    }
    if (pstrFile)
    {
        MemFreeString(pstrFile);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//   Member :SaveSnapShotDocument
//
//   Synopsis : entry point for the snapshot save logic.  called from
//          IPersistfile::save
//
//+---------------------------------------------------------------------------
HRESULT
CDoc::SaveSnapShotDocument(IStream * pstmSnapFile)
{
    HRESULT              hr = S_OK;
    CDoc               * pSnapDoc = NULL;
    IPersistStreamInit * pIPSI = NULL;
    IUnknown           * pDocUnk = NULL;

    if (!pstmSnapFile)
        return E_INVALIDARG;

    // create our design time document,
    hr = CreateSnapShotDocument(this, &pSnapDoc);
    if (hr)
        goto Cleanup;

    hr = THR(pSnapDoc->QueryInterface(IID_IUnknown, (void**)&pDocUnk));
    if (hr)
        goto Cleanup;

    // fire the save notification and let the peers transfer their
    // element's state into the design doc
    hr = THR(SaveSnapshotHelper( pDocUnk ));
    if (hr)
        goto Cleanup;

    // and now save the design doc.
    hr = THR(pSnapDoc->QueryInterface(IID_IPersistStreamInit, (void**)&pIPSI));
    if (hr)
        goto Cleanup;

    hr = THR(pIPSI->Save(pstmSnapFile, TRUE));

Cleanup:
    ReleaseInterface(pDocUnk);
    ReleaseInterface(pIPSI);
    if (pSnapDoc)
        pSnapDoc->Release();

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member : CDoc::SaveSnapshotHelper( IUnknown * pDocUnk)
//
//  Synopsis : this helper function does the task of firing the save 
//      notification and letting the peers put their element's state into
//      the design time document.  It is called by SaveSnapshotDocument 
//      (a save to stream operation) and by Exec::switch(IDM_SAVEASTHICKET)
//      the save-as call, will return this document to the browser where it
//      will be thicketized.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::SaveSnapshotHelper( IUnknown * pDocUnk, BOOL fVerifyParameters /* ==False */)
{
    HRESULT          hr = S_OK;
    IHTMLDocument2 * pIHTMLDoc = NULL;
    IPersistFile   * pIPFDoc   = NULL;
    TCHAR          * pstrFile = NULL;

    // SaveSnapshotDocument() is internal and has already done the work, 
    // Exec() has not.
    if (fVerifyParameters)
    {
        BSTR bstrMode = NULL;

        if (!pDocUnk)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        // dont do the snapshot (runtime) save while we are in design mode
        //  there may be no work to do at all.
        if (!PrimaryMarkup()->MetaPersistEnabled((long)htmlPersistStateSnapshot) ||
            PrimaryMarkup()->_fDesignMode)
        {
            goto Cleanup;
        }

        // now we need to verify that this is indeed a 1> document, 2> loaded with 
        // current base file, and 3> in design mode.
        hr = THR(pDocUnk->QueryInterface(IID_IHTMLDocument2, (void**)&pIHTMLDoc));
        if (hr)
            goto Cleanup;

        hr = THR(pIHTMLDoc->get_designMode(&bstrMode));
        if (hr)
            goto Cleanup;

        if (! _tcsicmp(bstrMode, L"Off"))
            hr = E_INVALIDARG;

        SysFreeString(bstrMode);
        if ( hr )
            goto Cleanup;
    }

    // and finally do the work of the call to transfer the state 
    // from the current document into the (design) output doc
    {
        CNotification   nf;
        long            i;
        CStackPtrAry<CElement *, 64>  aryElements(Mt(CDocSaveSnapShotDocument_aryElements_pv));

        nf.SnapShotSave(PrimaryRoot(), &aryElements);
        BroadcastNotify(&nf);

        for (i = 0; i < aryElements.Size(); i++)
        {
            aryElements[i]->TryPeerSnapshotSave(pDocUnk);
        }
    }

Cleanup:
    ReleaseInterface( pIHTMLDoc );
    ReleaseInterface( pIPFDoc );
    if (pstrFile)
    {
        MemFreeString(pstrFile);
    }
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Load, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    LOADINFO LoadInfo = { 0 };

    LoadInfo.pchFile = (TCHAR *)pszFileName;
    LoadInfo.codepageURL = g_cpDefault;

    RRETURN(LoadFromInfo(&LoadInfo));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Save, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    RRETURN(THR(PrimaryMarkup()->Document()->Save(pszFileName, fRemember)));
}

HRESULT
CDoc::SaveHelper(CMarkup *pMarkup, LPCOLESTR pszFileName, BOOL fRemember)
{
    HRESULT hr;
    
    Assert(pMarkup);
    hr = THR(pMarkup->Save(pszFileName, fRemember));
    if (fRemember)
        _lDirtyVersion = 0;
    RRETURN(hr);
}

HRESULT
CMarkup::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
#ifdef WINCE
    return S_OK;
#else
    HRESULT                 hr = S_OK;
    IStream *               pStm = NULL;
    LPCOLESTR               pszName;
    BOOL                    fBackedUp;
    BOOL                    fRestoreFailed = FALSE;
    TCHAR                   achBackupFileName[MAX_PATH];
    TCHAR                   achBackupPathName[MAX_PATH];
    TCHAR                   achFile[MAX_PATH];
    ULONG                   cchFile;
    const TCHAR *           pszExt;

    if (!pszFileName)
    {
        const TCHAR * pchUrl = CMarkup::GetUrl( this );

        if (!pchUrl || GetUrlScheme(pchUrl) != URL_SCHEME_FILE)
            return E_UNEXPECTED;

        cchFile = ARRAY_SIZE(achFile);

        hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
        if (hr)
            RRETURN(hr);

        pszName = achFile;
    }
    else
    {
        pszName = pszFileName;
    }

    //
    // Point to the extension of the file name
    //
    pszExt = pszName + _tcslen(pszName);

    while (pszExt > pszName && *(--pszExt) != _T('.'))
        ;

    fBackedUp =
        GetTempPath(ARRAY_SIZE(achBackupPathName), achBackupPathName) &&
        GetTempFileName(achBackupPathName, _T("trb"), 0, achBackupFileName) &&
        CopyFile(pszName, achBackupFileName, FALSE);

#if 0
    if (!StrCmpIC(_T(".rtf"), pszExt) && RtfConverterEnabled())
    {
        CRtfToHtmlConverter * pcnv = new CRtfToHtmlConverter(this);

        if (!pcnv)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        hr = THR(pcnv->InternalHtmlToExternalRtf(pszName));

        delete pcnv;

        if (hr)
            goto Error;
    }
    else
#endif
    {
        //
        // Create a stream on the file and save
        //
        hr = THR(CreateStreamOnFile(
                pszName,
                STGM_READWRITE | STGM_READWRITE | STGM_CREATE,
                &pStm));
        if (hr)
            goto Error;

#ifdef UNIX // Unix uses filter type as save-type
        if (!_strnicmp(".txt", MwFilterType(NULL, FALSE), 4))
#else
        if (!StrCmpIC(_T(".txt"), pszExt))
#endif
        {
            BOOL fWasPlainTextSave = Doc()->_fPlaintextSave;
            // Plaintext save should not touch the dirty bit
            Doc()->_fPlaintextSave = TRUE; // smuggle the text-ness to CDoc::SaveToStream(IStream *pStm)
            hr = THR(SaveToStream(pStm, WBF_SAVE_PLAINTEXT|WBF_FORMATTED,
                GetCodePage()));

            Doc()->_fPlaintextSave = fWasPlainTextSave;

            if (hr)
                goto Error;
        }
        else
        {
            // dont do the snapshot (runtime) save while we are in design mode
            if (    _fDesignMode
                ||  Doc()->_fSaveTempfileForPrinting
                ||  !MetaPersistEnabled((long)htmlPersistStateSnapshot) )
            {
                hr = THR(SaveToStream(pStm));
            }
            else
            {
                // for Snapshot saving, after we save, we need to
                // reload what we just saved.
                if (pszName)
                {
                    hr = THR(Doc()->SaveSnapShotDocument(pStm));
                }
            }
            if (hr)
                goto Error;
        }

        if (fRemember)
        {
            if (pszFileName)
            {
                hr = THR(Doc()->SetFilename(this, pszFileName));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:

    ReleaseInterface(pStm);

    if (!fRestoreFailed)
    {
        // Delete backup file only if copy succeeded.
        DeleteFile(achBackupFileName);
    }

    RRETURN(hr);

Error:

    ClearInterface(&pStm);     // necessary to close pszFileName

    if (fBackedUp)
    {
        //Setting fRestoreFailed to false if the copy fails ensures that 
        //the backup file does not get deleted above.
        fRestoreFailed = CopyFile(achBackupFileName, pszName, FALSE);
    }

    goto Cleanup;
#endif // WINCE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveCompleted, IPersistFile
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::SaveCompleted(LPCOLESTR pszFileName)
{
    RRETURN(THR(SaveCompletedHelper(PrimaryMarkup(), pszFileName)));
}

HRESULT
CDoc::SaveCompletedHelper(CMarkup *pMarkup, LPCOLESTR pszFileName)
{
    HRESULT     hr = S_OK;

    Assert(pMarkup);
    if (pszFileName && pMarkup->_fDesignMode)
    {
        hr = THR(SetFilename(pMarkup, pszFileName));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Load, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Load(BOOL fFullyAvailable, IMoniker *pmkName, IBindCtx *pbctx,
    DWORD grfMode)
{
    PerfDbgLog1(tagPerfWatch, this, "+CDoc::Load (IPersistMoniker pbctx=%08lX)", pbctx);

    HRESULT     hr = E_INVALIDARG;
    TCHAR *pchURL = NULL;

    LOADINFO LoadInfo = { 0 };
    LoadInfo.pmk    = pmkName;
    LoadInfo.pbctx  = pbctx;

    if( pmkName == NULL )
        goto Cleanup;

    // Get the URL from the display name of the moniker:
    hr = pmkName->GetDisplayName(pbctx, NULL, &pchURL);
    if (FAILED(hr))
        goto Cleanup;

    LoadInfo.pchDisplayName  = pchURL;

    hr = LoadFromInfo(&LoadInfo);

Cleanup:
    CoTaskMemFree(pchURL);

    PerfDbgLog(tagPerfWatch, this, "-CDoc::Load (IPersistMoniker)");

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Save, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDoc::Save(IMoniker *pmkName, LPBC pBCtx, BOOL fRemember)
{
    RRETURN(THR(PrimaryMarkup()->Document()->Save(pmkName, pBCtx, fRemember)));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveCompleted, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SaveCompleted(IMoniker *pmkName, LPBC pBCtx)
{
    RRETURN(THR(PrimaryMarkup()->Document()->SaveCompleted(pmkName, pBCtx)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PutProperty, IMonikerProp
//
//  Synopsis:   QI'ed by urlmon to store the content type, so
//              we don't need to issue a synchronous request
//              to rediscover the content type for full window
//              embeddings. 
//
//----------------------------------------------------------------------------
HRESULT CDoc::PutProperty(MONIKERPROPERTY mkp, LPCWSTR wzValue)
{
    if (_fFullWindowEmbed && mkp == MIMETYPEPROP)
    {
        _cstrPluginContentType.Set(wzValue);
    }

    if (_fFullWindowEmbed && mkp == USE_SRC_URL)
    {
        _fUseSrcURL = !_tcsicmp(wzValue, L"1");
    }

    // Currently, no reason to ever return anything other than S_OK
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::LoadFromStream, CServer
//
//  Synopsis:   Loads the object's persistent state from a stream. Called
//              from CServer implementation of IPersistStream::Load
//              and IPersistStorage::Load
//
//----------------------------------------------------------------------------

HRESULT
CDoc::LoadFromStream(IStream * pstm)
{
    BOOL fSync = _fPersistStreamSync;

    _fPersistStreamSync = FALSE;
    TraceTag((tagFormP, " LoadFromStream"));
#ifdef DEBUG
    CDataStream ds(pstm);
    ds.DumpStreamInfo();
#endif

    RRETURN(LoadFromStream(pstm, fSync));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::LoadFromStream
//
//  Synopsis:   Loads the object's persistent state from a stream. Called
//              from CServer implementation of IPersistStream::Load
//              and IPersistStorage::Load
//
//----------------------------------------------------------------------------

HRESULT
CDoc::LoadFromStream(IStream * pstm, BOOL fSync, CODEPAGE cp)
{
    LOADINFO LoadInfo = { 0 };

    LoadInfo.pstm = pstm;
    LoadInfo.fSync = fSync;
    LoadInfo.codepage = cp;

    RRETURN(LoadFromInfo(&LoadInfo));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveToStream, CServer
//
//  Synopsis:   Saves the object's persistent state to a stream.  Called
//              from CServer implementation of IPersistStream::Save
//              and IPersistStorage::Save.
//
//----------------------------------------------------------------------------

#define BUF_SIZE 8192 // copy in chunks of 8192

HRESULT
CDoc::SaveToStream( IStream * pstm )
{
    if( PrimaryMarkup() )
        RRETURN( PrimaryMarkup()->SaveToStream( pstm ) );
    else
        RRETURN( S_OK );
}

HRESULT
CMarkup::SaveToStream(IStream *pStm)
{
    HRESULT hr = E_FAIL;
    DWORD   dwFlags = WBF_FORMATTED;
    IStream * pStmDirty = GetStmDirty();

    // There are three interesting places to save from:
    //  1) The tree if we're in design-mode and we're dirty or when we are saving
    //          to a temporary file for printing purposes, or when we are saving
    //          to html when the original file was plaintext. In the printing case we use the
    //          base tag that we have inserted to the tree to print images.
    //  2) The dirty stream if we're in run-mode and the dirty stream exists.
    //  3) The original source otherwise.
    //  4) We are in design mode, and not dirty and do not have original source,
    //          then save from the tree.

    if (    (_fDesignMode && Doc()->IsDirty() != S_FALSE ) 
        ||  Doc()->_fSaveTempfileForPrinting
        ||  (HtmCtx() && HtmCtx()->GetMimeInfo() == g_pmiTextPlain && !Doc()->_fPlaintextSave))  // Case 1
    {
        TraceTag((tagFormP, " SaveToStream Case 1"));
        // don't save databinding attributes during printing, so that we
        // print the current content instead of re-binding
        if (Doc()->_fSaveTempfileForPrinting)
        {
            dwFlags |= WBF_SAVE_FOR_PRINTDOC | WBF_NO_DATABIND_ATTRS;
            if ( IsXML() )
                dwFlags |= WBF_SAVE_FOR_XML;
        }

        hr = THR(SaveToStream(pStm, dwFlags, GetCodePage()));
#if DBG==1
        CDataStream ds(pStm);
        ds.DumpStreamInfo();
#endif
    }
    else if (!_fDesignMode && pStmDirty)       // Case 2
    {
        ULARGE_INTEGER  cb;
        LARGE_INTEGER   liZero = {0, 0};

        cb.LowPart = ULONG_MAX;
        cb.HighPart = ULONG_MAX;

        TraceTag((tagFormP, " SaveToStream Case 2"));

        Verify(!pStmDirty->Seek(liZero, STREAM_SEEK_SET, NULL));
        hr = THR(pStmDirty->CopyTo(pStm, cb, NULL, NULL));

#if DBG==1
        CDataStream ds(pStm);
        ds.DumpStreamInfo();
#endif
    }
    else                                        // Case 3
    {
        if (HtmCtx() && !_fDesignMode)
        {
            if (!HtmCtx()->IsSourceAvailable())
            {
                TraceTag((tagFormP, " SaveToStream Case 3, no source available"));
                hr = THR(SaveToStream(pStm, dwFlags, GetCodePage()));
#if DBG==1
                CDataStream ds(pStm);
                ds.DumpStreamInfo();
#endif
            }
            else
            {
                TraceTag((tagFormP, " SaveToStream Case 3, source available"));
                hr = THR(HtmCtx()->CopyOriginalSource(pStm, 0));
#if DBG==1
                CDataStream ds(pStm);
                ds.DumpStreamInfo();
#endif
            }
        }
        else
        {
            // Case 4:
            TraceTag((tagFormP, " SaveToStream Case 4"));
            hr = THR(SaveToStream(pStm, dwFlags, GetCodePage()));
#if DBG==1
            CDataStream ds(pStm);
            ds.DumpStreamInfo();
#endif
        }
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CMarkup::WriteDocHeader(CStreamWriteBuff* pStm)
{
    // Write "<!DOCTYPE... >" stuff
    HRESULT hr = S_OK;
    DWORD dwFlagSave = pStm->ClearFlags(WBF_ENTITYREF);

    // Do not write out the header in plaintext mode.
    if(     Doc()->_fDontWhackGeneratorOrCharset
        WHEN_DBG( || IsTagEnabled( tagDontRewriteDocType ) )
       ||   pStm->TestFlag(WBF_SAVE_PLAINTEXT) )
        goto Cleanup;

    pStm->SetFlags(WBF_NO_WRAP);

    {
        CElement * pEC = GetElementClient();

        hr = pStm->Write((pEC && pEC->Tag() == ETAG_FRAMESET)

                            ? IsStrictCSS1Document()
                                ? _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3c.org/TR/1999/REC-html401-19991224/frameset.dtd\">")
                                : _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Frameset//EN\">")
                            : IsStrictCSS1Document()
                                ? _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd\">")
                                : _T("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">")
                            );                    
    }

    // If we are saving "pseudoXML" (<HTML:HTML><HTML:HEAD>) set the directive
    // so that the Trident that later reads the file knows to interpret it as such.
    if (    (dwFlagSave & WBF_SAVE_FOR_PRINTDOC)
        &&  (dwFlagSave & WBF_SAVE_FOR_XML) )
    {
        hr = pStm->Write(_T("<?PXML />"));
        if( hr )
            goto Cleanup;
    }

    hr = pStm->NewLine( );
    if( hr )
        goto Cleanup;

Cleanup:
    pStm->RestoreFlags(dwFlagSave);

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveToStream(pStm, dwFlags, codepage)
//
//  Synopsis:   Helper method to save to a stream passing flags to the
//              saver.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::SaveToStream(IStream *pStm, DWORD dwStmFlags, CODEPAGE codepage)
{
    if( PrimaryMarkup() )
        RRETURN( PrimaryMarkup()->SaveToStream( pStm, dwStmFlags, codepage ) );
    else
        RRETURN( S_OK );
}

HRESULT
CMarkup::SaveToStream(IStream *pStm, DWORD dwStmFlags, CODEPAGE codepage)
{
    HRESULT          hr = S_OK;
    CStreamWriteBuff StreamWriteBuff(pStm, codepage);

    hr = THR( StreamWriteBuff.Init() );
    if( hr )
        goto Cleanup;

    StreamWriteBuff.SetFlags(dwStmFlags);

    // Srinib, we have just created the stream buffer. But just to make sure
    // that we don't save DOCTYPE during plaintext save.
    if(!StreamWriteBuff.TestFlag(WBF_SAVE_PLAINTEXT))
    {
        // Write out the unicode signature if necessary
        if(     codepage == NATIVE_UNICODE_CODEPAGE 
            ||  codepage == NATIVE_UNICODE_CODEPAGE_BIGENDIAN
            ||  codepage == NONNATIVE_UNICODE_CODEPAGE
            ||  codepage == NONNATIVE_UNICODE_CODEPAGE_BIGENDIAN
            ||  codepage == CP_UTF_8
            ||  codepage == CP_UTF_7 )
        {
            // TODO: We have to write more or less data depending on whether
            //         non-native support is 2* sizeof(TCHAR) or sizeof(TCHAR) / 2
            TCHAR chUnicodeSignature = NATIVE_UNICODE_SIGNATURE;
            StreamWriteBuff.Write( (const TCHAR *) &chUnicodeSignature, 1 );
        }
        if (!StreamWriteBuff.TestFlag(WBF_SAVE_FOR_PRINTDOC) &&
            !Doc()->_fDontWhackGeneratorOrCharset
            WHEN_DBG( && !IsTagEnabled(tagDontOverrideCharset) ))
        {
            // Update or create a meta tag for the codepage on the doc
            IGNORE_HR( UpdateCodePageMetaTag( codepage ) );
        }

        WriteDocHeader(&StreamWriteBuff);
    }

    // TODO (paulpark) Should advance the code-page meta tag to the front of the head, or
    // at least make sure we save it first.

    {
        Assert( Root() );
        CTreeSaver ts( Root(), &StreamWriteBuff );

        ts.SetTextFragSave( TRUE );
        hr = ts.Save();
        if( hr ) 
            goto Cleanup;
    }

    if(!StreamWriteBuff.TestFlag(WBF_SAVE_PLAINTEXT))
        hr = StreamWriteBuff.NewLine();

Cleanup:
    RRETURN(hr);
}

HRESULT
CMarkup::SaveHtmlHead(CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT hr = S_OK;

    // If plaintext, don't write out the head.
    if (pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        goto Cleanup;

    // If we are saving for printing, we need to do a few things:
    // Save out codepage metatag.
    // We also need to have a BASE tag or we have little hope of printing
    // any images.  It may be of general use, though, to save the BASE
    // from whence the document orginally came.
    // TODO (KTam): Is it possible that we can use the BASE we're saving
    // as the URL for security checks?  I doubt it.
    if (pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        CODEPAGE codepage = pStreamWriteBuff->GetCodePage();
        TCHAR achCharset[MAX_MIMECSET_NAME];
        TCHAR * pchBaseUrl = NULL;

        CODEPAGESETTINGS * pCodepageSettings = GetCodepageSettings();
        hr = THR(CMarkup::GetBaseUrl(this, &pchBaseUrl));

        if (hr)
            goto Cleanup;

        hr = GetMlangStringFromCodePage(codepage, achCharset, ARRAY_SIZE(achCharset));
        if (hr)
            goto Cleanup;

        hr = WriteTagNameToStream(pStreamWriteBuff, _T("META"), FALSE, FALSE);
        if (hr)
            goto Cleanup;
       
        hr = WriteTagToStream(pStreamWriteBuff, _T(" content=\"text/html; charset="));
        if (hr)
            goto Cleanup;
        
        hr = WriteTagToStream(pStreamWriteBuff, achCharset);
        if (hr)
            goto Cleanup;
        
        hr = WriteTagToStream(pStreamWriteBuff, _T("\" http-equiv=Content-Type>"));
        if (hr)
            goto Cleanup;
        
        hr = pStreamWriteBuff->NewLine();
        if (hr)
            goto Cleanup;


        if (pchBaseUrl)
        {
            hr = WriteTagNameToStream(pStreamWriteBuff, _T("BASE"), FALSE, FALSE);
            if (hr)
                goto Cleanup;

            hr = THR(WriteTagToStream(pStreamWriteBuff, _T(" HREF=\"")));
            if(hr)
                goto Cleanup;

            hr = THR(WriteTagToStream(pStreamWriteBuff, pchBaseUrl));
            if (hr)
                goto Cleanup;

            hr = THR(WriteTagToStream(pStreamWriteBuff, _T("\">")));
            if (hr)
                goto Cleanup;

            // 43859: For Athena printing, save font information if available
            //        NOTE that this must be the first FONT style tag so that
            //        any others can override it.
            //        NOTE that we only do this for the root document, since
            //        this is the only one for which Athena has set the font
            //        correctly. any sub-frames have _Trident_'s default font.
            if (   pCodepageSettings
                && pCodepageSettings->latmPropFontFace)
            {
                hr = THR(pStreamWriteBuff->NewLine());
                if (hr)
                    goto Cleanup;

                pStreamWriteBuff->BeginPre();

                hr = WriteTagNameToStream(pStreamWriteBuff, _T("STYLE"), FALSE, TRUE);
                if (hr)
                    goto Cleanup;

                hr = THR(WriteTagToStream(pStreamWriteBuff, _T(" HTML { font-family : \"")));
                if(hr)
                    goto Cleanup;

                hr = THR(WriteTagToStream(pStreamWriteBuff, (TCHAR *)fc().GetFaceNameFromAtom(pCodepageSettings->latmPropFontFace)));
                if(hr)
                    goto Cleanup;

                hr = THR(WriteTagToStream(pStreamWriteBuff, _T("\" } ")));
                if(hr)
                    goto Cleanup;

                hr = WriteTagNameToStream(pStreamWriteBuff, _T("STYLE"), TRUE, TRUE);
                if (hr)
                    goto Cleanup;

                pStreamWriteBuff->EndPre();
            }
        }
    }

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::WriteTagToStream
//
//  Synopsis:   Writes given HTML tag to the stream turning off the entity
//               translation mode of the stream. If the WBF_SAVE_PLAINTEXT flag
//               is set in the stream nothing is done.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::WriteTagToStream(CStreamWriteBuff *pStreamWriteBuff, LPTSTR szTag)
{
    HRESULT hr = S_OK;
    DWORD dwOldFlags;

    Assert(szTag != NULL && *szTag != 0);

    if(!pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        // Save the state of the flag that controls the conversion of entities
        // and change the mode to "no entity translation"
        dwOldFlags = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);

        hr = THR(pStreamWriteBuff->Write(szTag));

        // Restore the entity translation mode
        pStreamWriteBuff->RestoreFlags(dwOldFlags);
    }

     RRETURN(hr);
}


HRESULT 
CMarkup::WriteTagNameToStream(CStreamWriteBuff *pStreamWriteBuff, LPTSTR szTagName, BOOL fEnd, BOOL fClose)
{
    HRESULT hr = THR(WriteTagToStream(pStreamWriteBuff, fEnd ? _T("</") : _T("<")));
    if (hr)
        goto Cleanup;

    if (pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_XML))
    {
        hr = THR(WriteTagToStream(pStreamWriteBuff, _T("HTML:")));
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(WriteTagToStream(pStreamWriteBuff, szTagName));
    if (hr)
        goto Cleanup;

    if (fClose)
        hr = THR(WriteTagToStream(pStreamWriteBuff, _T(">")));

Cleanup:
    RRETURN(hr);
}




//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryRefresh
//
//  Synopsis:   Called to discover if refresh is supported
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::QueryRefresh(DWORD * pdwFlags)
{
    CMarkup * pMarkup = Markup();
    TraceTag((tagMsoCommandTarget, "CMarkup::QueryRefresh"));

    *pdwFlags = (!pMarkup->_fDesignMode &&
        (CMarkup::GetUrl(pMarkup) || pMarkup->GetNonRefdMonikerPtr() || pMarkup->GetStmDirty() ||
        (pMarkup->HtmCtx() && pMarkup->HtmCtx()->WasOpened())))
            ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMarkup::ExecStop
//
//  Synopsis:   Stop form
//
//--------------------------------------------------------------------------

HRESULT
CMarkup::ExecStop(BOOL fFireOnStop /* = TRUE */, BOOL fSoftStop /* = TRUE */, BOOL fSendNot /* = TRUE */)
{
    int             i;
    CNotification   nf;
    CDoc * pDoc = Doc();
    CDataBindTask * pDBTask = GetDBTask();

    // If we are in the middle of a page transition, stop the transition first
    CDocument * pDocument = Document();
    if(pDocument && pDocument->HasPageTransitionInfo())
    {
        if(pDocument->GetPageTransitionInfo()->GetPageTransitionState() > CPageTransitionInfo::PAGETRANS_APPLIED)
        {
            TraceTag((tagPageTransitionTrace, "  PGTRANS: Executing a stop with fSoftStop set to %d", fSoftStop));
            pDocument->CleanupPageTransitions(0);

            // If the STOP button is pressed, kill the transistion but don't stop the download.
            // We will stop the download if the user presses the STOP button again.
            if (fSoftStop)
                return S_OK;
        }
    }

    if (HasWindowPending())
    {
        CWindow *pWindow = GetWindowPending()->Window();
        if (pWindow && pWindow->_pMarkup)
            pWindow->_pMarkup->ShowWaitCursor(FALSE);
    }
    
    _fHardStopDone = !fSoftStop;

    _fStopDone = TRUE;

    if (pDBTask)
    {
        pDBTask->Stop();
    }

    if (HtmCtx())
    {
        // fFireOnStop indicates that Stop button was pressed.
        if (fSoftStop)
        {
            // If the document was opened through script, don't let the stop
            // button interfere pressed.
            if (HtmCtx()->IsOpened())
            {
                return(S_OK);
            }
            HtmCtx()->DoStop(); // Do a "soft" stop instead of a "hard" SetLoad(FALSE)
        }
        else
        {
            HtmCtx()->SetLoad(FALSE, NULL, FALSE);

        }
    }

    if (    pDoc->_pWindowPrimary
        &&  !pDoc->_pWindowPrimary->IsPassivating()
        &&  IsPrimaryMarkup())
    {
        pDoc->StopUrlImgCtx(this);

        if (TLS(pImgAnim))  // TODO (lmollico): should stop animation for this markup only
        {
            TLS(pImgAnim)->SetAnimState((DWORD_PTR) pDoc, ANIMSTATE_STOP);   // Stop img animation
        }

        for (i = 0; i < pDoc->_aryChildDownloads.Size(); i++)
        {
            pDoc->_aryChildDownloads[i]->Terminate();
        }
        pDoc->_aryChildDownloads.DeleteAll();
    }

    StopPeerFactoriesDownloads();
    if (fSendNot && Root())
    {
        if (pDoc->_fBroadcastStop || 
            pDoc->_fHasViewSlave ||
            (GetProgSinkC() && GetProgSinkC()->GetClassCounter((DWORD)-1)))
        {
            nf.Stop1(Root());
            Notify(&nf);
        }
    }

    GWKillMethodCall(this, ONCALL_METHOD(CMarkup, SetInteractiveInternal, setinteractiveinternal), 0);
    if (_fInteractiveRequested)
    {
        Doc()->UnregisterMarkupForModelessEnable(this);
        _fInteractiveRequested = FALSE;
    }
    
    IGNORE_HR(pDoc->CommitDeferredScripts(0, this));    // TODO (lmollico): fix this

    if (fFireOnStop && pDocument)
        pDocument->Fire_onstop();
    
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ExecRefreshCallback
//
//  Synopsis:   ExecRefresh, but in a GWPostMethodCall compatible format
//
//--------------------------------------------------------------------------

void
COmWindowProxy::ExecRefreshCallback(DWORD_PTR dwOleCmdidf)
{
    IGNORE_HR(ExecRefresh((LONG) dwOleCmdidf));
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ExecRefresh
//
//  Synopsis:   Refresh form
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::ExecRefresh(LONG lOleCmdidf)
{
    IStream *   pStream     = NULL;
    DWORD       dwBindf;
    HRESULT     hr          = S_OK;
    CMarkup *   pMarkupNew  = NULL;
    CMarkup *   pMarkupOld  = Markup();
    CDoc *      pDoc        = pMarkupOld->_pDoc;
    LPCTSTR     pchCreatorUrl;
    CMarkup*    pSelectionMarkup;
    IMoniker *  pMoniker = NULL;

    #if DBG==1
    TraceTag((tagDocRefresh, "ExecRefresh(%lX) %ls", lOleCmdidf,
        CMarkup::GetUrl(pMarkupOld) ? CMarkup::GetUrl(pMarkupOld) : g_Zero.ach));
    TraceTag((tagDocRefresh, "    %s",
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_NORMAL) ?
            "OLECMDIDF_REFRESH_NORMAL (!! AOL Compat)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_NO_CACHE) ?
            "OLECMDIDF_REFRESH_NO_CACHE (F5)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_COMPLETELY) ?
            "OLECMDIDF_REFRESH_COMPLETELY (ctrl-F5)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_IFEXPIRED) ?
            "OLECMDIDF_REFRESH_IFEXPIRED (same as OLECMDIDF_REFRESH_RELOAD)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_CONTINUE) ?
            "OLECMDIDF_REFRESH_CONTINUE (same as OLECMDIDF_REFRESH_RELOAD)" :
        ((lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK) == OLECMDIDF_REFRESH_RELOAD) ?
            "OLECMDIDF_REFRESH_RELOAD (no forced cache validation)" :
            "?? Unknown OLECMDIDF_REFRESH_* level"));
    if (lOleCmdidf & OLECMDIDF_REFRESH_PROMPTIFOFFLINE)
        TraceTag((tagDocRefresh, "    OLECMDIDF_REFRESH_PROMPTIFOFFLINE"));
    if (lOleCmdidf & OLECMDIDF_REFRESH_CLEARUSERINPUT)
        TraceTag((tagDocRefresh, "    OLECMDIDF_REFRESH_CLEARUSERINPUT"));
    if (lOleCmdidf & OLECMDIDF_REFRESH_THROUGHSCRIPT)
        TraceTag((tagDocRefresh, "    OLECMDIDF_REFRESH_THROUGHSCRIPT"));    
    #endif

    pMarkupOld->AddRef();

    if (pDoc->_fInHTMLDlg || !Fire_onbeforeunload()) // No refresh in dialog
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if ((lOleCmdidf & OLECMDIDF_REFRESH_PROMPTIFOFFLINE) && pDoc->_pClientSite)
    {
        CTExec(pDoc->_pClientSite, NULL, OLECMDID_PREREFRESH, 0, NULL, NULL);
    }

    switch (lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK)
    {
        case OLECMDIDF_REFRESH_NORMAL:
            dwBindf = BINDF_RESYNCHRONIZE;
            break;
        case OLECMDIDF_REFRESH_NO_CACHE:
            dwBindf = BINDF_RESYNCHRONIZE|BINDF_PRAGMA_NO_CACHE;
            break;
        case OLECMDIDF_REFRESH_COMPLETELY:
            dwBindf = BINDF_GETNEWESTVERSION|BINDF_PRAGMA_NO_CACHE;
            break;
        default:
            dwBindf = 0;
            break;
    }

    pDoc->_fFirstTimeTab = IsInIEBrowser(pDoc);

    //
    // The Java VM needs to know when a refresh is
    // coming in order to clear its internal cache
    //

    if (pDoc->_fHasOleSite)
    {
        CNotification   nf;

        nf.BeforeRefresh(pMarkupOld->Root(), (void *)(DWORD_PTR)(lOleCmdidf & OLECMDIDF_REFRESH_LEVELMASK));
        pMarkupOld->Notify(&nf);
    }

    //
    // Save the current doc state into a history stream
    //

    hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStream));
    if (hr)
        goto Cleanup;

    // note that ECHOHEADERS only has an effect if the original response for this page was a 449 response

    hr = THR(pMarkupOld->SaveHistoryInternal(pStream,
                SAVEHIST_ECHOHEADERS |
                ((lOleCmdidf & OLECMDIDF_REFRESH_CLEARUSERINPUT) ? 0 : SAVEHIST_INPUT)));
    if (hr)
        goto Cleanup;

    // Stop the current bind
    hr = THR(pMarkupOld->ExecStop(FALSE, FALSE, FALSE));
    if( hr )
        goto Cleanup;

    // If this is a top level navigation, then 
    // 1. If it is user initiated, reset the list ELSE
    // 2. Add a blank record to demarcate the set of urls pertaining to this new top level url
    if (pMarkupOld->IsPrimaryMarkup() && !pDoc->_fViewLinkedInWebOC)
    {
        if (lOleCmdidf & OLECMDIDF_REFRESH_THROUGHSCRIPT)
            THR(pDoc->AddToPrivacyList(_T(""), NULL, PRIVACY_URLISTOPLEVEL));
        else
            THR(pDoc->ResetPrivacyList());
    }

    IGNORE_HR(pDoc->GetSelectionMarkup(&pSelectionMarkup));
    if (    pMarkupOld->IsPrimaryMarkup()
        ||  (pDoc->_pElemCurrent && pDoc->_pElemCurrent->IsConnectedToThisMarkup(pMarkupOld))
        ||  (pSelectionMarkup    && pSelectionMarkup->GetElementTop()->IsConnectedToThisMarkup(pMarkupOld)))
    {
        pDoc->_fForceCurrentElem = TRUE;         // make sure next call succeeds
        pMarkupOld->Root()->BecomeCurrent(0);
        pDoc->_fForceCurrentElem = FALSE;
    }

    if (_fFiredOnLoad)
    {
        _fFiredOnLoad = FALSE;

        {
            COmWindowProxy::CLock Lock(this);
            Fire_onunload();
    
            if (!pMarkupOld->Window())
            {
                // The old markup has been navigated. Just bail out!
                goto Cleanup;
            }
        }
    }

    hr = THR(pStream->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pMarkupOld->Window());
    if (hr)
        goto Cleanup;

    pMarkupNew->_fInRefresh = TRUE;

    pchCreatorUrl = pMarkupOld->GetAAcreatorUrl();
    if (pchCreatorUrl && *pchCreatorUrl)
        pMarkupNew->SetAAcreatorUrl(pchCreatorUrl);

    pMoniker = pMarkupOld->GetNonRefdMonikerPtr();
    if (pMoniker)
        pMoniker->AddRef();

    SwitchMarkup(pMarkupNew);

    hr = THR(pMarkupNew->LoadHistoryInternal(pStream, NULL, dwBindf, pMoniker, NULL, NULL, 0));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStream);
    ReleaseInterface(pMoniker);
    pMarkupOld->Release();
    if (pMarkupNew)
    {
        pMarkupNew->_fSafeToUseCalcSizeHistory = FALSE;
        pMarkupNew->Release();
    }
    RRETURN1(hr,S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::UpdateCodePageMetaTag
//
//  Synopsis:   Update or create a META tag for the document codepage.
//
//---------------------------------------------------------------

static BOOL LocateCodepageMeta ( CMetaElement * pMeta )
{
    return pMeta->IsCodePageMeta();
}

HRESULT
CMarkup::UpdateCodePageMetaTag(CODEPAGE codepage)
{
    HRESULT        hr = S_OK;
    TCHAR          achContentNew [ 256 ];
    TCHAR          achCharset[ MAX_MIMECSET_NAME ];
    CMetaElement * pMeta;
    AAINDEX        iCharsetIndex;

    hr = GetMlangStringFromCodePage(codepage, achCharset,
                                    ARRAY_SIZE(achCharset));
    if (hr)
        goto Cleanup;

    hr = THR(
        LocateOrCreateHeadMeta(LocateCodepageMeta, &pMeta, FALSE));

    if (hr || !pMeta)
        goto Cleanup;

    // If the meta tag is already for the same codepage, leave the original form
    //  intact.
    if( pMeta->GetCodePageFromMeta( ) == codepage )
        goto Cleanup;

    hr = THR(
        pMeta->AddString(
            DISPID_CMetaElement_httpEquiv, _T( "Content-Type" ),
            CAttrValue::AA_Attribute ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        Format(
            0, achContentNew, ARRAY_SIZE( achContentNew ),
            _T( "text/html; charset=<0s>" ), achCharset ) );

    if (hr)
        goto Cleanup;

    hr = THR( pMeta->SetAAcontent( achContentNew ) );

    if (hr)
        goto Cleanup;

    // If the meta was of the form <META CHARSET=xxx>, convert it to the new form.
    iCharsetIndex = pMeta->FindAAIndex( DISPID_CMetaElement_charset, CAttrValue::AA_Attribute );
    if( iCharsetIndex != AA_IDX_UNKNOWN )
    {
        pMeta->DeleteAt( iCharsetIndex );
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::HaveCodePageMetaTag
//
//  Synopsis:   Returns TRUE if the doc has a meta tag specifying
//              a codepage.
//
//---------------------------------------------------------------

BOOL
CMarkup::HaveCodePageMetaTag()
{
    CMetaElement *pMeta;

    return LocateHeadMeta(LocateCodepageMeta, &pMeta) == S_OK &&
           pMeta;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InitNew, IPersistStreamInit
//
//  Synopsis:   Initialize ole state of control. Overriden to allow this to
//              occur after already initialized or loaded (yuck!). From an
//              OLE point of view this is totally illegal. Required for
//              MSHTML classic compat.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::InitNew()
{
    LOADINFO LoadInfo = { 0 };
    CROStmOnBuffer stm;
    HRESULT hr;

    if (_fPopupDoc)
    {
        hr = THR(stm.Init((BYTE *)"<html><body></body></html>", 26));
    }
    else if (GetDefaultBlockTag() == ETAG_DIV)
    {
        hr = THR(stm.Init((BYTE *)"<div>&nbsp;</div>", 17));
    }
    else
    {
        hr = THR(stm.Init((BYTE *)"<p>&nbsp;</p>", 13));
    }

    if (hr)
        goto Cleanup;

    LoadInfo.pstm  = &stm;
    LoadInfo.fSync = TRUE;

    hr = THR(LoadFromInfo(&LoadInfo));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::EnsureDirtyStream
//
//  Synopsis:   Save to dirty stream if needed. Create the dirty stream
//              if it does not already exist.
//
//---------------------------------------------------------------

HRESULT
CMarkup::EnsureDirtyStream()
{
    CDoc * pDoc = Doc();
    HRESULT hr = S_OK;

    // if we're in design mode and we're dirty
    if (_fDesignMode)
    {
        IStream * pStmDirty = GetStmDirty();

        if (pDoc->IsDirty() != S_FALSE)
        {        
            // Since we are dirty in design mode we have to persist
            // ourselves out to a temporary file

            //
            // If the stream is read only, release it because we'll
            // want to create a read-write one in a moment.
            //

            if (pStmDirty)
            {
                STATSTG stats;

                hr = THR(pStmDirty->Stat(&stats, STATFLAG_DEFAULT));

                if (stats.grfMode == STGM_READ || FAILED(hr))
                {
                    ReleaseInterface(pStmDirty);
                    hr = SetStmDirty(NULL);
                    if (hr)
                        goto Cleanup;
                }
            }

            //
            // If we don't have a stream, create a read-write one.
            //

            if (!GetStmDirty())
            {
                TCHAR achFileName[MAX_PATH];
                TCHAR achPathName[MAX_PATH];
                DWORD dwRet;

                dwRet = GetTempPath(ARRAY_SIZE(achPathName), achPathName);
                if (!(dwRet && dwRet < ARRAY_SIZE(achPathName)))
                    goto Cleanup;

                if (!GetTempFileName(achPathName, _T("tri"), 0, achFileName))
                    goto Cleanup;

                hr = THR(CreateStreamOnFile(
                         achFileName,
                         STGM_READWRITE | STGM_SHARE_DENY_WRITE |
                                 STGM_CREATE | STGM_DELETEONRELEASE,
                         &pStmDirty));
                if (hr)
                    goto Cleanup;

                hr = SetStmDirty(pStmDirty);
                if (hr)
                    goto Cleanup;
            }

            ULARGE_INTEGER   luZero = {0, 0};

            hr = THR(pStmDirty->SetSize(luZero));
            if (hr)
                goto Cleanup;

            hr  = THR(SaveToStream(pStmDirty));
        }
        else
        {
            // Since we are in design mode, and are not dirty, our dirty
            // stream is probably stale.  Clear it here.
            ReleaseInterface(pStmDirty);
            hr = SetStmDirty(NULL);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::GetHtmSourceText
//
//  Synopsis:   Get the decoded html source text specified
//
//---------------------------------------------------------------
HRESULT
CDoc::GetHtmSourceText(ULONG ulStartOffset, ULONG ulCharCount, WCHAR *pOutText, ULONG *pulActualCharCount)
{
    HRESULT hr;

    Assert(CMarkup::HtmCtxHelper(PrimaryMarkup()));

    if (!CMarkup::HtmCtxHelper(PrimaryMarkup()))
    {
        RRETURN(E_FAIL);
    }

    hr = THR(CMarkup::HtmCtxHelper(PrimaryMarkup())->ReadUnicodeSource(pOutText, ulStartOffset, ulCharCount,
                pulActualCharCount));

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SetDownloadNotify
//
//  Synopsis:   Sets the Download Notify callback object
//              to be used next time the document is loaded
//
//---------------------------------------------------------------
HRESULT
CDoc::SetDownloadNotify(IUnknown *punk)
{
    IDownloadNotify *pDownloadNotify = NULL;
    HRESULT hr = S_OK;

    if (punk)
    {
        hr = THR(punk->QueryInterface(IID_IDownloadNotify, (void**) &pDownloadNotify));
        if (hr)
            goto Cleanup;
    }

    ReleaseInterface(_pDownloadNotify);
    _pDownloadNotify = pDownloadNotify;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::GetViewSourceFileName
//
//  Synopsis:   Get the fully qualified name of the file to display when the
//              user wants to view source.
//
//---------------------------------------------------------------

HRESULT
CDoc::GetViewSourceFileName(TCHAR * pszPath, CMarkup * pMarkup)
{
    Assert(pszPath);

    HRESULT hr;
    IStream *pstm = NULL;
    TCHAR achFileName[MAX_PATH];
    TCHAR * pchFile = NULL;
    CStr cstrVSUrl;
    IStream * pStmDirty = NULL;

    hr = THR(pMarkup->EnsureDirtyStream());
    if (hr)
        RRETURN(hr);

    pStmDirty = pMarkup->GetStmDirty();

    achFileName[0] = 0;

    if (pStmDirty)
    {
        STATSTG statstg;

        hr = THR(pStmDirty->Stat(&statstg, STATFLAG_DEFAULT));
        if (SUCCEEDED(hr) && statstg.pwcsName)
        {
            _tcscpy(pszPath, statstg.pwcsName);
            CoTaskMemFree( statstg.pwcsName );
        }
    }
    else if (pMarkup->HtmCtx())
    {
        // Use original filename, if it exists, Otherwise, use temporily file name
        if (IsAggregatedByXMLMime())
            hr = pMarkup->HtmCtx()->GetPretransformedFile(&pchFile);
        else
            hr = pMarkup->HtmCtx()->GetFile(&pchFile);
        if (!hr)
        {
            //
            //  If URL "file:" protocol and the document wasn't document.open()ed
            //  then use the original file name and path.Otherwise, use temp path
            //
            if (    !pMarkup->HtmCtx()->WasOpened()
                &&  GetUrlScheme(CMarkup::GetUrl(pMarkup)) == URL_SCHEME_FILE
                )
            {
                _tcsncpy(pszPath, pchFile, MAX_PATH);
                pszPath[MAX_PATH-1] = _T('\0');
                goto Cleanup;
            }
        }
        else
        {
            // Continue
            hr = S_OK;
        }
    }
    else
    {
        AssertSz(0, "EnsureDirtyStream failed to create a stream when no original was available.");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // We have either a pstmDirty or a pHtmCtx, but no file yet,
    // so create a temp file and write into it
    //
    cstrVSUrl.Set(_T("view-source:"));
    cstrVSUrl.Append(CMarkup::GetUrl(pMarkup));
    if (!CreateUrlCacheEntry(cstrVSUrl, 0, NULL, achFileName, 0))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(CreateStreamOnFile(
             achFileName,
             STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
             &pstm));
    if (hr)
        goto Cleanup;

    if (pStmDirty)
    {
        ULARGE_INTEGER uliSize;

        hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_END, &uliSize));
        if (hr)
            goto Cleanup;

        hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
        if (hr)
            goto Cleanup;

        hr = THR(pStmDirty->CopyTo(pstm, uliSize, NULL, NULL));
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert(pMarkup->HtmCtx());
        if (!pMarkup->HtmCtx()->IsSourceAvailable())
        {
            hr = THR(SaveToStream(pstm, 0, pMarkup->GetCodePage()));
        }
        else
        {
            DWORD dwFlags = HTMSRC_FIXCRLF | HTMSRC_MULTIBYTE;
            if (IsAggregatedByXMLMime())
                dwFlags |= HTMSRC_PRETRANSFORM;
            hr = THR(pMarkup->HtmCtx()->CopyOriginalSource(pstm, dwFlags));
        }
        if (hr)
            goto Cleanup;
    }

    _tcscpy(pszPath, achFileName);

    hr = CloseStreamOnFile(pstm);
    if (hr)
        goto Cleanup;

    FILETIME fileTime;
    fileTime.dwLowDateTime = 0;
    fileTime.dwHighDateTime = 0;
    if (!CommitUrlCacheEntry(cstrVSUrl,
                             achFileName,
                             fileTime,
                             fileTime,
                             NORMAL_CACHE_ENTRY,
                             NULL,
                             0,
                             NULL,
                             0))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    MemFreeString(pchFile);
    ReleaseInterface(pstm);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::SavePretransformedSource
//
//  Synopsis:   Save the pre-transformed, pre-html file if any. For mime filters.
//
//---------------------------------------------------------------
HRESULT
CDoc::SavePretransformedSource(CMarkup * pMarkup, BSTR bstrPath)
{
    HRESULT hr = E_FAIL;

    if (    CMarkup::HtmCtxHelper(pMarkup)
        &&  CMarkup::HtmCtxHelper(pMarkup)->IsSourceAvailable())
    {
        IStream *pIStream = NULL;
        LPTSTR pchPathTgt = bstrPath;
        LPTSTR pchPathSrc = NULL;

        // first see if it's the same file, we can't both create a read and write stream, so do nothing
        // both files should be canonicalized
        hr = CMarkup::HtmCtxHelper(pMarkup)->GetPretransformedFile(&pchPathSrc);
        if (hr)
            goto CleanUp;

        if (0 == StrCmpI(pchPathTgt, pchPathSrc))
        {
            hr = S_OK;
            goto CleanUp;
        }

        // create the output stream
        hr = THR(CreateStreamOnFile(pchPathTgt, STGM_READWRITE | STGM_CREATE, &pIStream));
        if (hr)
            goto CleanUp;
            
        // copy the pretransformed source into it
        hr = THR(CMarkup::HtmCtxHelper(pMarkup)->CopyOriginalSource(pIStream, HTMSRC_PRETRANSFORM));

CleanUp:
        ReleaseInterface(pIStream);
        MemFreeString(pchPathSrc);
    }
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     LoadFromInfo
//
//  Synopsis:   Workhorse method which loads (or reloads) the document.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::LoadFromInfo(LOADINFO * pLoadInfo, CMarkup** ppMarkup )
{
    LOADINFO            LoadInfo          = *pLoadInfo;
    DWORD               dwBindf           = 0;
    CDwnBindInfo *      pDwnBindInfo      = NULL;
    HRESULT             hr;
    CROStmOnBuffer *    prosOnBuffer      = NULL;
    TCHAR *             pchTask           = NULL;
    const TCHAR *       pchUrl;
    CMarkup *           pMarkup           = PrimaryMarkup();
    TCHAR *             pszCookedHTML     = NULL;
    BSTR                bstrUrlOrig       = NULL;
    int                 cbCookedHTML;

    Assert(_pWindowPrimary);

    LoadInfo.fCDocLoad = TRUE;

    // Don't allow re-entrant loading of the document

    if (TestLock(FORMLOCK_LOADING))
        return(E_PENDING);

    CLock Lock(this, FORMLOCK_LOADING);

    PerfDbgLog(tagPerfWatch, this, "+CDoc::LoadFromInfo");
    TraceTag((tagCDoc, "%lx CDoc::LoadFromInfo URL=%ls", this, pLoadInfo->pchDisplayName));

    //
    // Grab refs before any "goto Cleanup"s
    // Don't put any failure code above these addrefs
    //

    if (LoadInfo.pstm)
        LoadInfo.pstm->AddRef();
    if (LoadInfo.pmk)
        LoadInfo.pmk->AddRef();

    if (    pMarkup->_LoadStatus != LOADSTATUS_UNINITIALIZED
        ||  pMarkup->IsStreaming())
    {
        BOOL fDesignModeOld = pMarkup->_fDesignMode;

        // freeze the old markup and nuke any pending readystate changes
        pMarkup->ExecStop(FALSE, FALSE);

        hr = CreateMarkup(&pMarkup, NULL, NULL, FALSE, _pWindowPrimary);
        if (hr)
            goto Cleanup;

        // Check to see if this is a window.open case. If so,
        // switch the markup now so that we won't have any
        // issues with accessing the window object's OM
        // after calling window.open.
        //
        if (LoadInfo.pbctx)
        {
            IUnknown * punkBindCtxParam = NULL;

            hr = LoadInfo.pbctx->GetObjectParam(KEY_BINDCONTEXTPARAM, &punkBindCtxParam);
            if (SUCCEEDED(hr))
            {
                punkBindCtxParam->Release();

                LoadInfo.fShdocvwNavigate = TRUE;
                pMarkup->_fNewWindowLoading = TRUE;

                // HACKHACK (jbeda) IE5.5 110944
                // If PICS is turned on we want
                // to do this navigation async.  This
                // opens up places where the OM isn't
                // consistent, but we have no other option
                // this late in the game.
                if (_pClientSite && !(_dwFlagsHostInfo & DOCHOSTUIFLAG_NOPICS))
                {
                    VARIANT varPics = {0};
                    IGNORE_HR(CTExec(_pClientSite, &CGID_ShellDocView, SHDVID_ISPICSENABLED, 
                                     0, NULL, &varPics));
                    if (V_VT(&varPics) == VT_BOOL && V_BOOL(&varPics) == VARIANT_TRUE)
                    {
                        CMarkup * pPrimary = PrimaryMarkup();

                        LoadInfo.fStartPicsCheck = TRUE;

                        if (pPrimary)
                        {
                            // Set a flag on this special blank markup
                            pPrimary->_fPICSWindowOpenBlank = TRUE;
                        }
                            
                    }
                }
                
                if (!LoadInfo.fStartPicsCheck)
                    _pWindowPrimary->SwitchMarkup(pMarkup);
            }
        }

        // if this is an HTA document, the newly created markup should be trusted.
        pMarkup->SetMarkupTrusted(_fHostedInHTA);

        pMarkup->_fDesignMode = fDesignModeOld;

        pMarkup->Release();
    }
    else if (_fInTrustedHTMLDlg)
    {
        pMarkup->SetMarkupTrusted(TRUE);
    }

    //
    // Take ownership of any memory passed in before "goto Cleanup"s
    // Don't put any failure code above these assignments
    //
    pLoadInfo->pbRequestHeaders = NULL;
    pLoadInfo->cbRequestHeaders = 0;

    //
    //
    // Handle FullWindowEmbed special magic:
    //
    if (_fFullWindowEmbed && LoadInfo.pchDisplayName && !LoadInfo.pstmDirty)
    {
        // Synthesize the html which displays the plugin imbedded:
        // Starts with a Unicode BOM (byte order mark) to identify the buffer
        // as containing Unicode.
        static TCHAR altData[] =
         _T(" <<html><<body leftmargin=0 topmargin=0 scroll=no> <<embed width=100% height=100% fullscreen=yes src=\"<0s>\"><</body><</html>");
        static const TCHAR szUnsafeChars[]=TEXT("<>\"\' ");
        TCHAR *pszCanonicalizedUrl;
        DWORD cchCanonicalizedUrl;

        altData[0] = NATIVE_UNICODE_SIGNATURE;
        cchCanonicalizedUrl = INTERNET_MAX_URL_LENGTH;
        pszCanonicalizedUrl = new TCHAR[cchCanonicalizedUrl];
        if (!pszCanonicalizedUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        //Canonicalize the URL since it's going into html text.
        hr = UrlCanonicalize(LoadInfo.pchDisplayName, pszCanonicalizedUrl, &cchCanonicalizedUrl, URL_ESCAPE_UNSAFE);
        if (hr != S_OK)
        {
            delete[] pszCanonicalizedUrl;
            goto Cleanup;
        }

        //UrlCanonicalize() does not escape unsafe characters after # or ?
        //Check if we still have unsafe chars. Truncate the URL if there is one.
        //Error code returned from here is not properly handled by the caller.
        TCHAR *pChar;
        for (pChar=pszCanonicalizedUrl; *pChar != 0; pChar++)
        {
            if (NULL != StrChr(szUnsafeChars, *pChar))
            {
                *pChar = 0;
                break;
            }
        }

        // Create our cooked up HTML, which is an embed tag with src attr set to the current URL
        hr = Format( FMT_OUT_ALLOC, &pszCookedHTML, 0, altData,  pszCanonicalizedUrl);
        delete[] pszCanonicalizedUrl;
        if( FAILED( hr ) )
            goto Cleanup;
        cbCookedHTML = _tcslen( pszCookedHTML );

        // Create a stream onto that string.  Note that this CROStmOnBuffer::Init() routine
        // duplicates the string and owns the new version.  Thus it is safe to pass it this
        // local scope string buffer.
        prosOnBuffer = new CROStmOnBuffer;
        if (prosOnBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = prosOnBuffer->Init( (BYTE*)pszCookedHTML, cbCookedHTML*sizeof(TCHAR) );
        if (hr)
            goto Cleanup;

        // We may need some information stored in CDwnBindInfo when we
        // start loading up the plugin site.
        if (LoadInfo.pbctx)
        {
            IUnknown *pUnk = NULL;
            LoadInfo.pbctx->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);
            if (pUnk)
            {
                pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);
                ReleaseInterface(pUnk);
            }
            if (pDwnBindInfo)
            {
                // Get content type and cache filename of plugin data.
                _cstrPluginContentType.Set(pDwnBindInfo->GetContentType());
                _cstrPluginCacheFilename.Set(pDwnBindInfo->GetCacheFilename());
                pDwnBindInfo->Release();
                pDwnBindInfo = NULL;
            }
        }

        Assert( LoadInfo.pstmDirty == NULL );
        ReleaseInterface( LoadInfo.pstmDirty );  // just in case.
        LoadInfo.pstmDirty = prosOnBuffer;
    }

    dwBindf = LoadInfo.dwBindf;

    // Extract the client site from the bind context and set it (if available).
    // It is not an error not to be able to do this.

    if (LoadInfo.pbctx)
    {
        IUnknown* pUnkParam = NULL;
        LoadInfo.pbctx->GetObjectParam(WSZGUID_OPID_DocObjClientSite,
                                        &pUnkParam);
        if( pUnkParam )
        {
            IOleClientSite* pOleClientSite = NULL;

            pUnkParam->QueryInterface(IID_IOleClientSite,
                                       (void**)&pOleClientSite);
            ReleaseInterface(pUnkParam);

            if (pOleClientSite)
            {
                hr = THR(SetClientSite(pOleClientSite));
                pOleClientSite->Release();
                if (FAILED(hr))
                    goto Cleanup;
            }
        }

        //
        // Detect if shdocvw CoCreated trident if so then the bctx with have the
        // special string __PrecreatedObject.  If that is so then we don't want
        // to blow away the expando when the document is actually loaded (just
        // in case expandos were created on the window prior to loading).
        //
        hr = LoadInfo.pbctx->GetObjectParam(_T("__PrecreatedObject"), &pUnkParam);
        if (!hr)
        {
            ReleaseInterface(pUnkParam);

            // Signal we were precreated.
            pMarkup->_fPrecreated = TRUE;
        }
    }

    Assert(!LoadInfo.pchUrlOriginal);
    if (_pTridentSvc)
    {
        // Get the original url from shdocvw and store it in pchUrlOriginal
        if (S_OK == _pTridentSvc->GetPendingUrl(&bstrUrlOrig))
        {
            LoadInfo.pchUrlOriginal = bstrUrlOrig;
        }
    }

    // Load preferences from the registry if we haven't already
    if (!_fGotAmbientDlcontrol)
    {
        SetLoadfFromPrefs();
    }

    // Create CVersions object if we haven't already
    if (!_pVersions)
    {
        hr = THR(QueryVersionHost());
        if (hr)
            goto Cleanup;
    }

    if (_pWindowPrimary->_fFiredOnLoad)
    {
        _pWindowPrimary->_fFiredOnLoad = FALSE;
        {
            CDoc::CLock Lock(this);
            _pWindowPrimary->Fire_onunload();
        }
    }

    // Free the undo buffer before unload the contents

    FlushUndoData();

    // We are during loading and codepage might not be updated yet.
    // Clear this flag so we won't ignore META tag during reloading.
    if (    pMarkup->GetDwnDoc()
        &&  !(pMarkup->GetDwnDoc()->GetLoadf() & DLCTL_NO_METACHARSET))
    {
        LoadInfo.fNoMetaCharset = FALSE;
    }

    //
    // At this point, we should be defoliated.  Start up a new tree.
    //

    Assert(PrimaryRoot());

    // Right now the globe should not be spinning.
    //
    if (_fSpin)
    {
        SetSpin(FALSE);
    }

    // It's a go for loading, so say we're loaded

    if (_state < OS_LOADED)
        _state = OS_LOADED;

#if DBG==1
    DebugSetTerminalServer();
#endif

    // Set the document's URL and moniker

    if (!pMarkup->HasUrl())
    {
        if (!LoadInfo.pmk)
        {
            hr = THR(SetUrl(pMarkup, _T("about:blank")));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(LoadInfo.pmk->GetDisplayName(LoadInfo.pbctx, NULL, &pchTask));
            if (hr)
                goto Cleanup;

            // now chop of #location part, if any
            TCHAR *pchLoc = const_cast<TCHAR *>(UrlGetLocation(pchTask));
            if (pchLoc)
                *pchLoc = _T('\0');

            hr = THR(SetUrl(pMarkup, pchTask));
            if (hr)
                goto Cleanup;

            DeferUpdateTitle();

            hr = THR( pMarkup->ReplaceMonikerPtr( LoadInfo.pmk ) );
            if( hr )
                goto Cleanup;
        }
    }
    pchUrl = GetPrimaryUrl();

    Assert(!!pchUrl);
    MemSetName((this, "CDoc SSN=%d URL=%ls", _ulSSN, pchUrl));

    IGNORE_HR(CompatBitsFromUrl((TCHAR *) pchUrl, &_dwCompat));

    // The default document direction is LTR. Only set this if the document is RTL
    _pWindowPrimary->Document()->_eHTMLDocDirection = (unsigned) LoadInfo.eHTMLDocDirection;

    _fInIEBrowser = IsInIEBrowser(this);

    hr = THR(pMarkup->LoadFromInfo(&LoadInfo, NULL, LoadInfo.pchUrlOriginal));
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

Cleanup:
    if ( ppMarkup && hr == S_OK )
    {
        *ppMarkup = pMarkup;
    }
    
    SysFreeString(bstrUrlOrig);
    ReleaseInterface(LoadInfo.pstm);
    ReleaseInterface(LoadInfo.pmk);
    ReleaseInterface((IBindStatusCallback *)pDwnBindInfo);
    ReleaseInterface(prosOnBuffer);
    ReleaseInterface((IUnknown *)LoadInfo.pDwnPost);
    MemFree(LoadInfo.pbRequestHeaders);
    MemFree(LoadInfo.pchSearch);
    CoTaskMemFree(pchTask);
    delete pszCookedHTML;

    //
    // If everything went A-OK, transition to the running state in
    // case we haven't done so already. Set active object if the
    // doc is ui-activate (fix for #49313, #51062)

    if (OK(hr))
    {
        if (State() < OS_RUNNING)
        {
            IGNORE_HR(TransitionTo(OS_RUNNING));
        }
        else if (State() >= OS_UIACTIVE)
        {
            SetActiveObject();
        }
    }

    PerfDbgLog(tagPerfWatch, this, "-CDoc::LoadFromInfo");

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveSelection
//
//  Synopsis:   saves the current selection into
//              a file. The created file is an independent
//              .HTM file on it's own
//
//----------------------------------------------------------------------------
HRESULT
CDoc::SaveSelection(TCHAR *pszFileName)
{
    HRESULT     hr = E_FAIL;
    IStream     *pStm = NULL;

    if (pszFileName && HasTextSelection())
    {
        // so there is a current selection, go and create a stream
        // and call the stream helper

        hr = THR(CreateStreamOnFile(
                pszFileName,
                STGM_READWRITE | STGM_READWRITE | STGM_CREATE,
                &pStm));
        if (hr)
            goto Cleanup;

        hr = THR(SaveSelection(pStm));

        ReleaseInterface(pStm);
    }

Cleanup:

    RRETURN(hr);
}





//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SaveSelection
//
//  Synopsis:   saves the current selection into
//              a stream. The created stream is saved in HTML format//
//
//----------------------------------------------------------------------------
HRESULT
CDoc::SaveSelection(IStream *pstm)
{
    HRESULT                 hr = E_FAIL;
    ISelectionServices      *pSelSvc = NULL;
    ISegment                *pISegment = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegmentList            *pSegmentList = NULL;
    
    if (pstm  && HasTextSelection())
    {
        DWORD dwFlags = RSF_SELECTION | RSF_CONTEXT;
        CMarkup * pMarkup = GetCurrentMarkup();

        hr = GetSelectionServices( &pSelSvc );
        if( hr || pSelSvc == NULL )
            goto Cleanup;

        hr = pSelSvc->QueryInterface( &pSegmentList );
        if( hr || pSegmentList == NULL )
            goto Cleanup;
            
        // so there is a current selection, go and get the text...
        // if there is a selection, we can safely assume (because
        // it is already checked in IsThereATextSelection)
        // that _pElemCurrent exists and is a txtSite
        
#if DBG == 1
        {
            BOOL fEmpty = FALSE;
            SELECTION_TYPE eType = SELECTION_TYPE_None;
            IGNORE_HR( pSegmentList->GetType( &eType ));
            IGNORE_HR( pSegmentList->IsEmpty( &fEmpty ) );
            Assert( eType == SELECTION_TYPE_Text && !fEmpty );
        }
#endif // DBG == 1

        {
            CStreamWriteBuff StreamWriteBuff(pstm, pMarkup->GetCodePage());

            hr = THR( StreamWriteBuff.Init() );
            if( hr )
                goto Cleanup;

            StreamWriteBuff.SetFlags(WBF_SAVE_SELECTION);

            // don't save databinding attributes during printing, so that we
            // print the current content instead of re-binding
            if (_fSaveTempfileForPrinting)
            {
                StreamWriteBuff.SetFlags(WBF_SAVE_FOR_PRINTDOC | WBF_NO_DATABIND_ATTRS);
                if (PrimaryMarkup() && PrimaryMarkup()->IsXML())
                    StreamWriteBuff.SetFlags(WBF_SAVE_FOR_XML);
            }

            if (!StreamWriteBuff.TestFlag(WBF_SAVE_FOR_PRINTDOC))
            {
                // HACK (cthrash) Force META tag persistance.
                //
                // Save any html header information needed for the rtf converter.
                // For now this is <HTML> and a charset <META> tag.
                //
                TCHAR achCharset[MAX_MIMECSET_NAME];

                if (GetMlangStringFromCodePage(pMarkup->GetCodePage(), achCharset,
                                               ARRAY_SIZE(achCharset)) == S_OK)
                {
                    DWORD dwOldFlags = StreamWriteBuff.ClearFlags(WBF_ENTITYREF);

                    StreamWriteBuff.Write(_T("<META CHARSET=\""));
                    StreamWriteBuff.Write(achCharset);
                    StreamWriteBuff.Write(_T("\">"));
                    StreamWriteBuff.NewLine();

                    StreamWriteBuff.RestoreFlags(dwOldFlags);
                }
            }

            // Create an interator for the segments
            hr = THR( pSegmentList->CreateIterator(&pIter) );
            if( hr || (pIter == NULL) )
                goto Cleanup;
            //
            // Save the segments using the range saver
            //
            while( pIter->IsDone() == S_FALSE )
            {
                CMarkupPointer mpStart(this), mpEnd(this);

                hr = THR( pIter->Current( &pISegment ) );
                if( FAILED(hr) )
                    goto Error;

                // Get the next element, because of continues in the 
                // while loop
                hr = THR( pIter->Advance() );
                if( FAILED(hr) )
                    goto Error;
                    
                hr = THR( pISegment->GetPointers( &mpStart, &mpEnd ) );
                if (S_OK == hr)
                {
                    // Skip saving text of password inputs.
                    CTreeNode * pNode = mpStart.Branch();
                    CElement * pElementContainer = pNode ? pNode->Element()->GetMasterPtr() : NULL;
                    if (   pElementContainer
                        && pElementContainer->Tag() == ETAG_INPUT
                        && htmlInputPassword == DYNCAST(CInput, pElementContainer)->GetType())
                    {
                        continue;
                    }
                }

                //
                // TODO - need to make range saver here use ISegmentList based saver
                //

                CRangeSaver rs( &mpStart, &mpEnd, dwFlags, &StreamWriteBuff, mpStart.Markup() );

                hr = THR( rs.Save());
                if (hr)
                    goto Error;

                ClearInterface( &pISegment );                    
            }

Error:
            StreamWriteBuff.Terminate();
        }
    }

Cleanup:
    ReleaseInterface( pSelSvc );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pISegment );
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ClearDwnPost()
//
//  Synopsis:   Used to discard original post data that lead to the page.
//              Called after moniker has changed or after HTTP redirect.
//
//----------------------------------------------------------------------------

void
CMarkup::ClearDwnPost()
{
    CDwnPost * pDwnPost = GetDwnPost();

    if (pDwnPost)
    {
        pDwnPost->Release();
        IGNORE_HR(SetDwnPost(NULL));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::RestartLoad
//
//  Synopsis:   Reloads a doc from a DwnBindData in progress.
//
//-------------------------------------------------------------------------

HRESULT COmWindowProxy::RestartLoad(IStream *pstmLeader, CDwnBindData *pDwnBindData, CODEPAGE codepage)
{
    CStr cstrUrl;
    HRESULT hr;
    IStream * pStream = NULL;
    IStream * pstmRefresh;
    CMarkup * pMarkupNew = NULL;
    CMarkup * pMarkupOld = Markup();
    CDoc *    pDoc = pMarkupOld->Doc();
    CDwnDoc * pDwnDoc;

    hr = THR(cstrUrl.Set(CMarkup::GetUrl(pMarkupOld)));
    if (hr)
        goto Cleanup;

    //  are we going to a place already in the history?
    if (    pMarkupOld->HtmCtx()
        && ((pstmRefresh = pMarkupOld->HtmCtx()->GetRefreshStream()) != NULL))
    {
        hr = THR(pstmRefresh->Clone(&pStream));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        //
        // Save the current doc state into a history stream
        //

        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStream));
        if (hr)
            goto Cleanup;

        hr = THR(pMarkupOld->SaveHistoryInternal(pStream, 0));    //  Clear user input
        if (hr)
            goto Cleanup;

        hr = THR(pStream->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
        if (hr)
            goto Cleanup;
    }

    IGNORE_HR(pMarkupOld->ExecStop(FALSE, FALSE));

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pMarkupOld->Window());
    if (hr)
        goto Cleanup;

    // Move the pics target over to the new markup if we are doing the first load
    // pics check.  If we aren't doing the first load check, we should have been cleared
    // by now when the post parser saw that we were restarting.
    if (pMarkupOld->HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = pMarkupOld->GetTransNavContext();
        if (ptnc->_pctPics)
        {
            IGNORE_HR(pMarkupNew->SetPicsTarget(ptnc->_pctPics));

            pMarkupOld->SetPicsTarget(NULL);
        }
    }

    pDwnDoc = pMarkupOld->GetDwnDoc();
    hr = THR(pMarkupNew->LoadHistoryInternal(pStream, 
                                             NULL, 
                                             pDwnDoc ? (pDwnDoc->GetBindf() & BINDF_GETNEWESTVERSION) : 0, 
                                             pMarkupOld->GetNonRefdMonikerPtr(), 
                                             pstmLeader, 
                                             pDwnBindData, 
                                             codepage,
                                             NULL,
                                             CDoc::FHL_RESTARTLOAD));

    if (pMarkupOld->HasWindow())
        pMarkupOld->Window()->Window()->_fRestartLoad = TRUE;

    if (hr)
        goto Cleanup;

    if (pDoc->IsPrintDialog())
    {
        pMarkupNew->SetPrintTemplate(pMarkupOld->IsPrintTemplate());
        pMarkupNew->SetPrintTemplateExplicit(pMarkupOld->IsPrintTemplateExplicit());
    }

    SwitchMarkup(pMarkupNew, FALSE, 0, 0, TRUE);

Cleanup:
    if (pMarkupNew)
    {
        pMarkupNew->Release();
    }
    ReleaseInterface(pStream);
    RRETURN(hr);
}

BOOL
CDoc::IsLoading()
{
    return (    CMarkup::HtmCtxHelper(PrimaryMarkup())
            &&  CMarkup::HtmCtxHelper(PrimaryMarkup())->IsLoading());
}

HRESULT
CDoc::NewDwnCtx(UINT dt, LPCTSTR pchSrc, CElement * pel, CDwnCtx ** ppDwnCtx, BOOL fPendingRoot, BOOL fSilent, DWORD dwProgsinkClass)
{
    HRESULT     hr;
    DWNLOADINFO dli       = { 0 };
    BOOL        fLoad     = TRUE;
    TCHAR   *   pchExpUrl = new TCHAR[pdlUrlLen];
    CMarkup *   pMarkup   = pel ? pel->GetMarkupForBaseUrl() : NULL;

    if (!pMarkup)
        pMarkup = PrimaryMarkup();

    if (pchExpUrl == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppDwnCtx = NULL;

    if (pchSrc == NULL)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR( pMarkup->InitDownloadInfo(&dli) );
    if( hr )
        goto Cleanup;

    hr = THR(CMarkup::ExpandUrl(
                pMarkup, pchSrc, pdlUrlLen, pchExpUrl, pel));
    if (hr)
        goto Cleanup;
        
    dli.pchUrl = pchExpUrl;
    dli.dwProgClass = dwProgsinkClass;

    if (!pMarkup->ValidateSecureUrl(fPendingRoot, (LPTSTR)dli.pchUrl, FALSE, fSilent))
    {
        hr = E_ABORT;
        goto Cleanup;
    }

    if (pMarkup && pMarkup->HtmCtx())
    {
        *ppDwnCtx = pMarkup->HtmCtx()->GetDwnCtx(dt, dli.pchUrl);

        if (*ppDwnCtx)
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    if (dt == DWNCTX_IMG && !(_dwLoadf & DLCTL_DLIMAGES))
        fLoad = FALSE;

    if (pMarkup && pMarkup->LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        UINT uScheme = GetUrlScheme(dli.pchUrl);

        // (jbeda) 85899 
        // Don't do this for pluggable protocols since we have no way to verify modification times.
        if (uScheme == URL_SCHEME_FILE || uScheme == URL_SCHEME_HTTP || uScheme == URL_SCHEME_HTTPS)
        {
            // (dinartem) 39144
            // This flag tells the download mechanism not use the CDwnInfo cache until it has at
            // least verified that the modification time of the underlying bits is the same as the
            // cached version.  Normally we allow connection to existing images if they are on the
            // same page and have the same URL.  Once the page is finished loading and script makes
            // changes to SRC properties, we perform this extra check.

            dli.fResynchronize = TRUE;
        }
    }

    dli.fPendingRoot = fPendingRoot;

    hr = THR(::NewDwnCtx(dt, fLoad, &dli, ppDwnCtx));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pchExpUrl != NULL)
        delete pchExpUrl;
    RRETURN(hr);
}


HRESULT
CMarkup::InitDownloadInfo(DWNLOADINFO * pdli)
{
    HRESULT hr = S_OK;

    memset(pdli, 0, sizeof(DWNLOADINFO));
    pdli->pInetSess = TlsGetInternetSession();
    pdli->pDwnDoc = GetWindowedMarkupContext()->GetDwnDoc();

    if( !pdli->pDwnDoc )
        hr = E_UNEXPECTED;

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member: LocalAddDTI()
//
//  Synopsis:
//      Local helper function to call IActiveDesktop interface to add a
//      desktop item at the given location.
//
//-------------------------------------------------------------------------
#ifndef WINCE

static HRESULT LocalAddDTI(LPCTSTR pszUrl, HWND hwnd, int x, int y, int nType)
{
    HRESULT hr;
    IActiveDesktop * pad;
    COMPONENT comp = {
        sizeof(COMPONENT),  // Size of this structure
        0,                  // For Internal Use: Set it always to zero.
        nType,              // One of COMP_TYPE_*
        TRUE,               // Is this component enabled?
        FALSE,              // Had the component been modified and not yet saved to disk?
        FALSE,              // Is the component scrollable?
        {
            sizeof(COMPPOS),//Size of this structure
            x,              //Left of top-left corner in screen co-ordinates.
            y,              //Top of top-left corner in screen co-ordinates.
            (DWORD)-1,      // Width in pixels.
            (DWORD)-1,      // Height in pixels.
            10000,          // Indicates the Z-order of the component.
            TRUE,           // Is the component resizeable?
            TRUE,           // Resizeable in X-direction?
            TRUE,           // Resizeable in Y-direction?
            -1,             // Left of top-left corner as percent of screen width
            -1              // Top of top-left corner as percent of screen height
        },                  // Width, height etc.,
        _T("\0"),           // Friendly name of component.
        _T("\0"),           // URL of the component.
        _T("\0"),           // Subscrined URL.
        IS_NORMAL           // ItemState
    };

    StrCpyN(comp.wszSource, pszUrl, ARRAY_SIZE(comp.wszSource));
    StrCpyN(comp.wszFriendlyName, pszUrl, ARRAY_SIZE(comp.wszFriendlyName));
    StrCpyN(comp.wszSubscribedURL, pszUrl, ARRAY_SIZE(comp.wszSubscribedURL));

    if(SUCCEEDED(hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (LPVOID *) &pad)))
    {
        hr = pad->AddDesktopItemWithUI(hwnd, &comp, DTI_ADDUI_DISPSUBWIZARD);

        if (pad)
            pad->Release();
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member: _CreateDeskItem_ThreadProc
//
//  Synopsis:
//        Local function that serves as the threadProc to add desktop item.
//      We need to start a thread to do this because it may take a while and
//      we don't want to block the UI thread because dialogs may be displayed.
//
//-------------------------------------------------------------------------

static DWORD CALLBACK _CreateDeskItem_ThreadProc(LPVOID pvCreateDeskItem)
{
    CREATEDESKITEM * pcdi = (CREATEDESKITEM *) pvCreateDeskItem;

    HRESULT hres = OleInitialize(0);
    if (SUCCEEDED(hres))
    {
        hres = LocalAddDTI(pcdi->pszUrl, pcdi->hwnd, pcdi->x, pcdi->y, pcdi->dwItemType);
        OleUninitialize();
    }

    if(pcdi->pszUrl)
        MemFree((void *)(pcdi->pszUrl));
    MemFree((void *)pcdi);
    return 0;
}
#endif //WINCE
//+------------------------------------------------------------------------
//
//  Member:     CreateDesktopComponents
//
//  Synopsis:
//        Create Desktop Components for one item.  We need to start
//    a thread to do this because it may take a while and we don't want
//    to block the UI thread because dialogs may be displayed.
//
//-------------------------------------------------------------------------

static HRESULT CreateDesktopItem(LPCTSTR pszUrl, HWND hwnd, DWORD dwItemType, int x, int y)
{
    HRESULT hr = E_OUTOFMEMORY;
#ifndef WINCE
    //The following are allocated here; But, they will be freed at the end of _CreateDeskComp_ThreadProc.
    CREATEDESKITEM * pcdi = (CREATEDESKITEM *)MemAlloc(Mt(SetAsDesktopItem), sizeof(CREATEDESKITEM));
    LPTSTR  lpszURL = (LPTSTR)MemAlloc(Mt(SetAsDesktopItem), sizeof(TCHAR)*(_tcslen(pszUrl)+1));

    // Create Thread....
    if (pcdi && lpszURL)
    {
        _tcscpy(lpszURL, pszUrl); //Make a temporary copy of the URL
        pcdi->pszUrl = (LPCTSTR)lpszURL;
        pcdi->hwnd = hwnd;
        pcdi->dwItemType = dwItemType;
        pcdi->x = x;
        pcdi->y = y;

        SHCreateThread(_CreateDeskItem_ThreadProc, pcdi, CTF_INSIST, NULL);
        hr = S_OK;
    }
    else
    {   
        // This fixes Prefix bug 7799 in which we can leak one of these or the other
        MemFree((void *) pcdi);
        MemFree((void *) lpszURL);
    }

#endif //WINCE
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\fpropdlg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       fpropdlg.cxx
//
//  Contents:   Display property dialog.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifdef NEVER

        #ifndef X_ELEMENT_HXX_
        #define X_ELEMENT_HXX_
        #include "element.hxx"
        #endif

        #ifndef X_COMMCTRL_H_
        #define X_COMMCTRL_H_
        #include "commctrl.h"
        #endif

        #ifndef X_MSHTMLRC_H_
        #define X_MSHTMLRC_H_
        #include "mshtmlrc.h"
        #endif

        #ifndef X_SITEGUID_H_
        #define X_SITEGUID_H_
        #include "siteguid.h"
        #endif

        #ifndef X_CGUID_H_
        #define X_CGUID_H_
        #include <cguid.h>
        #endif

        #ifdef UNIX
        #include <mainwin.h>
        #endif

        #ifndef NO_HTML_DIALOG
        class CPropertyDialog;

        MtDefine(CPropertyPageSite, Dialogs, "CPropertyPageSite")
        MtDefine(ShowPropertyDialog, Dialogs, "ShowPropertyDialog (temp array)")
        MtDefine(CPropertyDialog, Dialogs, "CPropertyDialog")
        MtDefine(CPropertyDialog_arySite_pv, Dialogs, "CPropertyDialog::_arySite::_pv")

        //+---------------------------------------------------------------------------
        //
        //  Class:      CPropertyPageSite
        //
        //  Synopsis:   Manage single page in property dialog.
        //
        //----------------------------------------------------------------------------

        class CPropertyPageSite :
            public IPropertyPageSite,
            public IServiceProvider
        {
        public:

            DECLARE_MEMCLEAR_NEW_DELETE(Mt(CPropertyPageSite))

            CPropertyPageSite()
                { _ulRefs = 1; }

            ~CPropertyPageSite()
                { Close(); }

            DECLARE_FORMS_STANDARD_IUNKNOWN(CPropertyPageSite)

            void    Close();
            HRESULT Show();
            void    Hide();
            HRESULT Init(CPropertyDialog *pFrame, int iLevel, CLSID *pclsid);

            // IPropertyPageSite methods

            STDMETHOD(OnStatusChange)   (DWORD dw);
            STDMETHOD(GetLocaleID)      (LCID * pLocaleID);
            STDMETHOD(GetPageContainer) (LPUNKNOWN * ppUnk);
            STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

            // IServiceProvider methods

            STDMETHOD(QueryService)(REFGUID, REFIID, void **);

            // Data members

            CPropertyDialog *   _pDialog;
            CLSID               _clsid;
            IPropertyPage *     _pPage;
            PROPPAGEINFO        _ppi;
            BOOL                _fActive;
            int                 _iLevel;
        };


        //+---------------------------------------------------------------------------
        //
        //  Class:      CPropertyDialog
        //
        //  Synopsis:   Run the property dialog.
        //
        //----------------------------------------------------------------------------

        class CPropertyDialog
        {
        public:

            DECLARE_MEMALLOC_NEW_DELETE(Mt(CPropertyDialog))
            // Construct / destruct

            ~CPropertyDialog()
                { Close(); }

            // Helper functions

            HRESULT         GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca);
            void            SetPage(int i, BOOL fSetTab = TRUE);
            void            UpdateApplyButton();
            HRESULT         CreatePageSites(int iLevel, int cUnk, IUnknown **apUnk);
            void            UpdateTabs(int iLevel);
            BOOL            Apply();
            void            Close();
            HRESULT         PreTranslateMessage(LPMSG);
            HRESULT         TranslateTabCtrlAccelerators(LPMSG);

            // Dialog procedure

            static BOOL CALLBACK DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
            BOOL OnInitDialog(HWND);
            void OnNotify(int idiCtrl, LPNMHDR lpnmhdr);
            void OnCommand(WORD wNotifyCode, WORD idi, HWND hwnd);

            HWND                _hwndDialog;    // dialog window
            HWND                _hwndTabs;      // tab control window
            HWND                _hwndCombo;     // combo box window
            HWND                _hwndTopParent; // top level parent window to be reenabled before close
            RECT                _rcPage;
            int                 _iPage;
            LCID                _lcid;

            BOOL                _fApplyWasHit;

            IUnknown **         _apUnk;
            int                 _cUnk;
            IUnknown *          _apUnkLevel[32];
            int                 _cUnkLevel;

            IServiceProvider *  _pServiceProvider;
            int                 _aiPageLevel[32];
            HRESULT             _hr;
            BOOL                _fMessageTranslated;
            IUnknown *          _punkBrowseDefault; // Not NULL implies we're in browse
                                                    //  mode

            DECLARE_CPtrAry(CArySite, CPropertyPageSite *, Mt(Mem), Mt(CPropertyDialog_arySite_pv))
            CArySite            _arySite;

        };


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Init
        //
        //  Synopsis:   Initialize the page.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::Init(CPropertyDialog *pDialog, int iLevel, CLSID *pclsid)
        {
            HRESULT         hr;
            IClassFactory * pCF = NULL;

            _pDialog = pDialog;
            _iLevel = iLevel;

            //
            // First try getting a local class object.  If that fails, then
            // go out to OLE and the registry.
            //

            hr = THR_NOTRACE(LocalGetClassObject(
                    *pclsid,
                    IID_IClassFactory,
                    (void **)&pCF));
            if (!hr)
            {
                hr = THR(pCF->CreateInstance(
                        NULL,
                        IID_IPropertyPage,
                        (void **)&_pPage));
            }
            else
            {
                hr = THR(CoCreateInstance(
                        *pclsid,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IPropertyPage,
                        (void **) &_pPage));
            }
            if (hr)
                goto Cleanup;

            hr = THR(_pPage->SetPageSite(this));
            if (hr)
                goto Cleanup;

            _ppi.cb = sizeof(PROPPAGEINFO);

            hr = THR(_pPage->GetPageInfo(&_ppi));
            if (hr)
                goto Cleanup;

        Cleanup:
            ReleaseInterface(pCF);
            RRETURN(hr);
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Close
        //
        //  Synopsis:   Release everything.  Called at frame exit.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyPageSite::Close()
        {
            if (_pPage)
            {
                if (_fActive)
                {
                    IGNORE_HR(_pPage->Deactivate());
                }
                IGNORE_HR(_pPage->SetPageSite(NULL));
            }

            CoTaskMemFree(_ppi.pszTitle);
            _ppi.pszTitle = NULL;

            CoTaskMemFree(_ppi.pszDocString);
            _ppi.pszDocString = NULL;

            CoTaskMemFree(_ppi.pszHelpFile);
            _ppi.pszHelpFile = NULL;

            //  TODO (laszlog) : Shouldn't we call SetObjects(0,NULL) here to ensure
            //                   robust refcounting?
            //                   See Help for IPropertyPage::SetObjects


            ClearInterface(&_pPage);

            _pDialog = NULL;
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Show
        //
        //  Synopsis:   Activates a page, passing it the current set of objects
        //              and showing it.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::Show()
        {
            HRESULT hr = S_OK;

            if (!_fActive)
            {
                if (_iLevel == 0)
                {
                    hr = THR(_pPage->SetObjects(
                            _pDialog->_cUnk,
                            _pDialog->_apUnk));
                }
                else
                {
                    hr = THR(_pPage->SetObjects(
                            1,
                            &_pDialog->_apUnkLevel[_iLevel]));
                }

                if (hr)
                    goto Cleanup;
                hr = THR(_pPage->Activate(_pDialog->_hwndTabs, &_pDialog->_rcPage, FALSE));
                if (hr)
                    goto Cleanup;

                _fActive = TRUE;
            }

            hr = THR(_pPage->Show(SW_SHOWNA));
            if (hr)
                goto Cleanup;

        Cleanup:
            RRETURN(hr);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::Hide
        //
        //  Synopsis:   Hide the page
        //
        //-------------------------------------------------------------------------

        void
        CPropertyPageSite::Hide()
        {
            IGNORE_HR(_pPage->Show(SW_HIDE));
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::QueryInterface, IUnknown
        //
        //  Synopsis:   Per IUnknown.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::QueryInterface(REFIID iid, void ** ppv)
        {
            if (iid == IID_IUnknown || iid == IID_IPropertyPageSite)
            {
                *ppv = (IPropertyPageSite *) this;
            }
            else if (iid == IID_IServiceProvider)
            {
                *ppv = (IServiceProvider *) this;
            }
            else
            {
                *ppv = 0;
                RRETURN(E_NOINTERFACE);
            }

            (*(IUnknown **)ppv)->AddRef();
            return S_OK;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::OnStatusChange, IPropertyPageSite
        //
        //  Synopsis:   Note that status changed.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::OnStatusChange(DWORD dw)
        {
            if (!_pDialog || !_pPage)
                RRETURN(E_UNEXPECTED);

            if (dw & PROPPAGESTATUS_DIRTY)
            {
                _pDialog->UpdateApplyButton();
            }
            return S_OK;
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::GetLocaleID
        //
        //  Synopsis:   Returns the current locale ID.
        //
        //-------------------------------------------------------------------------

        STDMETHODIMP
        CPropertyPageSite::GetLocaleID(LCID * plcid)
        {
            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            *plcid = _pDialog->_lcid;
            return S_OK;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::GetPageContainer, IPropertyPageSite
        //
        //  Synopsis:   Per IPropertyPageSite, not supported.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::GetPageContainer(IUnknown ** ppUnk)
        {
            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            *ppUnk = NULL;
            return E_NOTIMPL;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::TranslateAccelerator, IPropertyPageSite
        //
        //  Synopsis:   Handle accelerator.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::TranslateAccelerator(LPMSG pmsg)
        {
            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            _pDialog->_fMessageTranslated = TRUE;
            return IsDialogMessage(_pDialog->_hwndDialog, pmsg) ? S_OK : S_FALSE;
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyPageSite::QueryService, IServiceProvider
        //
        //  Synopsis:   Per IServiceProvider.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyPageSite::QueryService(REFGUID guid, REFIID iid, void **ppv)
        {
            HRESULT hr;

            if (!_pDialog)
                RRETURN(E_UNEXPECTED);

            if (_pDialog->_pServiceProvider)
            {
                hr = THR(_pDialog->_pServiceProvider->QueryService(guid, iid, ppv));
            }
            else
            {
                hr = E_FAIL;
            }

            RRETURN(hr);
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::Close
        //
        //  Synopsis:   Cleanup for shutdown.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::Close()
        {
            int i;

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (_arySite[i])
                {
                    _arySite[i]->Close();
                    _arySite[i]->Release();
                    _arySite[i] = 0;
                }
            }
            _arySite.SetSize(0);

            while (_cUnkLevel--)
            {
                ClearInterface(&_apUnkLevel[_cUnkLevel]);
            }
            _cUnkLevel = 0;

            if ( _hwndTopParent )
            {
                ::EnableWindow(_hwndTopParent, TRUE);
            }

            if (_hwndDialog)
            {
                DestroyWindow(_hwndDialog);
                _hwndDialog = 0;
            }
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::UpdateAppyButton
        //
        //  Synopsis:   Enable apply button based on page dirty.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::UpdateApplyButton()
        {
            int     i;
            BOOL    fEnable = FALSE;

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (S_OK == _arySite[i]->_pPage->IsPageDirty())
                {
                    fEnable = TRUE;
                    break;
                }
            }

            EnableWindow(GetDlgItem(_hwndDialog, IDC_PROPFRM_APPLY), fEnable);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::UpdateTabs
        //
        //  Synopsis:   Set tabs to page titles.
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::UpdateTabs(int iLevel)
        {
            int     i;
            TC_ITEM item;

            TabCtrl_DeleteAllItems(_hwndTabs);

            memset(&item, 0, sizeof(item));
            item.mask = TCIF_TEXT;

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (_arySite[i]->_iLevel == iLevel)
                {
                    item.pszText = _arySite[i]->_ppi.pszTitle;
                    Verify(TabCtrl_InsertItem(_hwndTabs, i, &item) != -1);
                }
            }
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::Apply
        //
        //  Synopsis:   Applies changes to dirty pages.
        //
        //  Returns:    True if all ok.
        //
        //-------------------------------------------------------------------------

        BOOL
        CPropertyDialog::Apply()
        {
            int i;
            HRESULT hr = S_OK;
            IPropertyPage *pPage;

            for (i = 0; i < _arySite.Size(); i++)
            {
                pPage = _arySite[i]->_pPage;
                if (S_OK == pPage->IsPageDirty())
                {
                    hr = THR(pPage->Apply());
                    if (hr)
                    {
                        // TODO (garybu) Need to display error message.
                        SetPage(i);
                        break;
                    }
                }
            }

            UpdateApplyButton();

            return hr == S_OK;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::SetPage
        //
        //  Synopsis:   Changes the current page.
        //
        //  Arguments:  i Index of page to activate
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::SetPage(int iPage, BOOL fSetTab)
        {
            HRESULT hr = S_OK;
            int     iLevel;

            if (iPage == _iPage)
                return;

            if (_iPage >= 0)
            {
                _arySite[_iPage]->Hide();
                iLevel = _arySite[_iPage]->_iLevel;
            }
            else
            {
                iLevel = -1;
            }

            _iPage = iPage;

            if (_iPage >= 0)
            {
                if (_arySite[_iPage]->_iLevel != iLevel)
                {
                    iLevel = _arySite[_iPage]->_iLevel;
                    UpdateTabs(iLevel);
                    SendMessage(_hwndCombo, CB_SETCURSEL, iLevel, 0);
                }
                if (fSetTab)
                {
                    TabCtrl_SetCurSel(_hwndTabs, _iPage - _aiPageLevel[iLevel]);
                }
                IGNORE_HR(_arySite[_iPage]->Show());
            }
        }

        //+---------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::GetCommonPages
        //
        //  Synopsis:   Find common property pages for selected objects.
        //
        //----------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::GetCommonPages(int cUnk, IUnknown **apUnk, CAUUID *pca)
        {
            HRESULT                hr;
            int                    i;
            UINT                   iScan, iFill, iCompare;
            BOOL                   fFirst = TRUE;
            CAUUID                 caCurrent;
            IUnknown *             pUnk;
            ISpecifyPropertyPages *pSPP;

            pca->cElems = 0;
            pca->pElems = NULL;

            //
            // If _punkBrowseDefault is set, then we show the properties on that
            // object only if no other objects in the list have any pages.
            //
            // Loop one more time than the number of elements to get pages on
            // _punkBrowseDefault if necessary.
            for (i = 0; i <= cUnk; i++)
            {
                if (i == cUnk && _punkBrowseDefault && pca->cElems == 0)
                {
                    // Force the default object's page(s) to be loaded because the
                    // other object(s) did not provide any.
                    pUnk = _punkBrowseDefault;
                    fFirst = TRUE;
                }
                else if (i < cUnk)
                {
                    pUnk = apUnk[i];
                }
                else
                {
                    break;
                }

                if (OK(THR(pUnk->QueryInterface(
                        IID_ISpecifyPropertyPages,
                        (void **)&pSPP))))
                {
                    hr = THR(pSPP->GetPages(fFirst ? pca : &caCurrent));
                    pSPP->Release();
                    if (hr)
                        continue;

                    if (fFirst)
                    {
                        fFirst = FALSE;
                    }
                    else
                    {
                        for (iScan = 0, iFill = 0; iScan < pca->cElems; iScan++)
                        {
                            for (iCompare = 0; iCompare < caCurrent.cElems; iCompare++)
                            {
                                if (caCurrent.pElems[iCompare] == pca->pElems[iScan])
                                    break;
                            }
                            if (iCompare != caCurrent.cElems)
                            {
                                pca->pElems[iFill++] = pca->pElems[iScan];
                            }
                        }
                        pca->cElems = iFill;

                        CoTaskMemFree(caCurrent.pElems);
                    }
                }
            }

            return S_OK;
        }

        //+---------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::CreatePageSites
        //
        //  Synopsis:   Create page sites for the specified objects.
        //
        //----------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::CreatePageSites(int iLevel, int cUnk, IUnknown **apUnk)
        {
            HRESULT hr;
            ULONG   i;
            CAUUID  ca      = { 0, 0 };
            CPropertyPageSite *pSite;

            _aiPageLevel[iLevel] = _arySite.Size();

            // Compute pages to load.

            hr = THR(GetCommonPages(cUnk, apUnk, &ca));
        #if DBG==1    
            if (hr)
            {
                   // put in a blank page in arySites()
                ca.cElems = 1;
                ca.pElems = (GUID *)&CLSID_CCDGenericPropertyPage;
            }
        #endif // DBG==1    

            // Create the sites.

            hr = THR(_arySite.EnsureSize(_arySite.Size() + ca.cElems));
            if (hr)
                goto Cleanup;

            for (i = 0; i < ca.cElems; i++)
            {
                pSite = new CPropertyPageSite();
                if (!pSite)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(pSite->Init(this, iLevel, &ca.pElems[i]));
                if (hr)
                {
                    // If we can't initalize the page, then ignore it.
                    pSite->Close();
                    pSite->Release();
                }
                else
                {
                    _arySite.Append(pSite);
                }

            }

        Cleanup:
            CoTaskMemFree(ca.pElems);
            RRETURN(hr);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::TranslateWndAccelerator
        //
        //  Synopsis:   Handle accelerators for the tab control.
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::TranslateTabCtrlAccelerators(LPMSG pmsg)
        {
            HRESULT hr = S_FALSE;
            int iPage;
            int iLevel;
            int d;

            if ((pmsg->message == WM_KEYDOWN || pmsg->message == WM_SYSKEYDOWN) &&
                pmsg->wParam == VK_TAB &&
                (GetKeyState(VK_CONTROL) & 0x8000) &&
                (GetKeyState(VK_MENU) & 0x8000) == 0)
            {
                d = (GetKeyState(VK_SHIFT) & 0x8000) ? -1 : 1;

                iPage = _iPage + d;
                iLevel = _arySite[_iPage]->_iLevel;
                if (iPage >= _arySite.Size() ||
                    iPage < 0 ||
                    _arySite[iPage]->_iLevel != iLevel)
                {
                    if (d > 0)
                    {
                        for (iPage = 0;
                            _arySite[iPage]->_iLevel != iLevel;
                            iPage++)
                            ;
                    }
                    else
                    {
                        for (iPage = _arySite.Size() - 1;
                            _arySite[iPage]->_iLevel != iLevel;
                            iPage--)
                            ;
                    }
                }

                if (_iPage != iPage)
                {
                    SetPage(iPage);
                }

                hr = S_OK;
            }

            RRETURN1(hr, S_FALSE);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::PreTranslateMessage
        //
        //  Synopsis:   Handle accelerators
        //
        //-------------------------------------------------------------------------

        HRESULT
        CPropertyDialog::PreTranslateMessage(LPMSG pmsg)
        {
            HRESULT hr;
            HWND hwndFocus, hwndBeforePage, hwndAfterPage;

            if (pmsg->message < WM_KEYFIRST || pmsg->message > WM_KEYLAST)
            {
                hr = S_FALSE;
                goto Cleanup;
            }

            // CDK pages eat the keys we use for flipping pages.
            // Handle these keys first.

            hr = THR(TranslateTabCtrlAccelerators(pmsg));
            if (hr != S_FALSE)
                goto Cleanup;

            hwndFocus      = GetFocus();
            hwndBeforePage = _hwndTabs;
            hwndAfterPage  = _hwndCombo;

            if (GetParent(hwndFocus) != _hwndDialog ||
                    (hwndFocus == hwndBeforePage &&
                        pmsg->wParam == VK_TAB &&
                        pmsg->message == WM_KEYDOWN &&
                        (GetKeyState(VK_SHIFT) & 0x8000) == 0) ||
                    (hwndFocus == hwndAfterPage &&
                        pmsg->wParam == VK_TAB &&
                        pmsg->message == WM_KEYDOWN &&
                        (GetKeyState(VK_SHIFT) & 0x8000)))
            {
                // The focus is in the property page or we are about
                // to tab into the property page.  We let the property
                // page handle the accelerator first.

                _fMessageTranslated = FALSE;
            }
            else
            {
                // Focus is in our child. We get first crack at the message.

                hr = IsDialogMessage(_hwndDialog, pmsg) ? S_OK : S_FALSE;
                if (hr != S_FALSE)
                    goto Cleanup;

                _fMessageTranslated = TRUE;
            }

            // Give the property page a chance to handle the message.

            if (_iPage >= 0)
            {
                hr = THR(_arySite[_iPage]->_pPage->TranslateAccelerator(pmsg));
                if (hr != S_FALSE)
                    goto Cleanup;
            }

            // The CDK pages don't always bubble messages up to the
            // site.  Handle the message now if we have not seen it
            // before.

            if (!_fMessageTranslated)
            {
                hr = IsDialogMessage(_hwndDialog, pmsg) ? S_OK : S_FALSE;
            }

        Cleanup:
            RRETURN1(hr, S_FALSE);
        }

        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::OnCommand
        //
        //  Synopsis:   Handle WM_COMMAND message
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::OnCommand(WORD wNotifyCode, WORD idiCtrl, HWND hwndCtrl)
        {
            switch (idiCtrl)
            {
            case IDCANCEL:
                _hr = _fApplyWasHit ? S_OK : S_FALSE;
                Close();
                break;

            case IDI_PROPDLG_APPLY:
                if (Apply())
                {
                    _fApplyWasHit = TRUE;
                }
                break;

            case IDOK:
                if (Apply())
                {
                    Close();
                }
                break;

            case IDI_PROPDLG_COMBO:
                if (wNotifyCode == CBN_SELCHANGE)
                {
                    int i = SendMessage(_hwndCombo, CB_GETCURSEL, 0, 0);

                    if (i >= 0 && i <= _cUnkLevel)
                    {
                        SetPage(_aiPageLevel[i]);
                    }
                }
                break;
            }
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::OnNotify
        //
        //  Synopsis:   Handle WM_NOTIFY message
        //
        //-------------------------------------------------------------------------

        void
        CPropertyDialog::OnNotify(int idiCtrl, LPNMHDR lpnmhdr)
        {
            int i;

            if (idiCtrl == IDI_PROPDLG_TABS &&
                    lpnmhdr->code == TCN_SELCHANGE &&
                    _iPage >= 0)
            {
                i = TabCtrl_GetCurSel(_hwndTabs);
                SetPage(_aiPageLevel[_arySite[_iPage]->_iLevel] + i, FALSE);
            }
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::InitDialog
        //
        //  Synopsis:   Initialize the dialog
        //
        //-------------------------------------------------------------------------

        BOOL
        CPropertyDialog::OnInitDialog(HWND hwnd)
        {
            static int aidiButtons[] =
                { IDOK, IDCANCEL, IDI_PROPDLG_APPLY, IDI_PROPDLG_COMBO };

            HRESULT         hr = S_OK;
            GDIRECT         rcMax;
            GDIRECT         rc;
            int             i;
            int             dx, dy;
            IHTMLElement *  pElement;
            CElement *      pElem;

            _hwndDialog = hwnd;
            _hwndTabs = GetDlgItem( _hwndDialog, IDI_PROPDLG_TABS );
            _hwndCombo = GetDlgItem( _hwndDialog, IDI_PROPDLG_COMBO );

            _fApplyWasHit = FALSE;

            // Crawl up the parent chain.

            _apUnkLevel[0] = _apUnk[ 0 ];
            _apUnkLevel[0]->AddRef();       // Keeps the cleanup code simple.

            //
            // Don't walk the tree in browse mode
            //
            if (!_punkBrowseDefault)
            {
                for ( _cUnkLevel = 1 ; !hr && _cUnkLevel < ARRAY_SIZE(_apUnkLevel) ; )
                {
                    hr =
                        THR(
                            _apUnkLevel [ _cUnkLevel - 1 ]->QueryInterface(
                                IID_IHTMLElement, (void * *) & pElement ) );

                    if (OK(hr))
                    {
                        //
                        // Get parent of this element
                        //

                        hr =
                            THR(
                                pElement->get_parentElement(
                                    (IHTMLElement **) & _apUnkLevel [ _cUnkLevel ] ) );

                        if ( !hr )
                        {
                            hr =
                                _apUnkLevel [ _cUnkLevel ]->QueryInterface (
                                    CLSID_CElement, (void * *) & pElem );

                            if (!hr)
                            {
                                // Ignore the HTML tag
                                if ( pElem->Tag() == ETAG_HTML )
                                {
                                    _apUnkLevel[ _cUnkLevel ]->Release();
                                    _apUnkLevel[ _cUnkLevel ] = NULL;
                                    hr = E_FAIL;
                                }
                                else
                                {
                                    _cUnkLevel++;
                                }
                            }
                        }

                        pElement->Release();
                    }
                }
            }
            else
            {
                //
                // In browse mode we hide the combo-box and the apply button.
                //
                _cUnkLevel = 1;
                ::EnableWindow(_hwndCombo, FALSE);
                ::ShowWindow(_hwndCombo, SW_HIDE);
                hwnd = GetDlgItem(_hwndDialog, IDI_PROPDLG_APPLY);
                ::ShowWindow(hwnd, SW_HIDE);
            }

            // Load pages for base objects.

            hr = THR(CreatePageSites(0, _cUnk, (IUnknown **) _apUnk));
            if (hr)
                goto Cleanup;

            // Load pages for parent objects.

            for (i = 1; i < _cUnkLevel; ++i)
            {
                hr = THR(CreatePageSites(i, 1, (IUnknown **) &_apUnkLevel[i]));
            }

            // Combobox is hidden, no need to load.
            // Load combobox when _apUnkLevel[i] is (IHTMLDocument2 *) pDoc will set
            // hr to E_FAIL, and eventually fails IDM_PROPERTIES.
            //
            if (!(_punkBrowseDefault))
            {
                // Load the combo box

                for (i = 0; i < _cUnkLevel; ++i)
                {
                    BSTR           bstrTagName = 0;
                    IHTMLElement * pElement;

                    if (OK(_apUnkLevel[i]->QueryInterface(IID_IHTMLElement, (void **)&pElement)))
                    {
                        hr = THR(pElement->get_tagName(&bstrTagName));
                        pElement->Release();
                    }
                    else
                    {
                        hr = E_FAIL;
                    }

                    // TODO Pick default name here?
                    if (hr)
                        break;

                    SendMessage(_hwndCombo, CB_ADDSTRING, 0, (LPARAM) bstrTagName);
                    SysFreeString(bstrTagName);
                }
            }

            // Compute maximum page size.

            memset(&rcMax, 0, sizeof(rcMax));

            for (i = 0; i < _arySite.Size(); i++)
            {
                if (_arySite[i]->_ppi.size.cx > rcMax.right)
                    rcMax.right = _arySite[i]->_ppi.size.cx;

                if (_arySite[i]->_ppi.size.cy > rcMax.bottom)
                    rcMax.bottom = _arySite[i]->_ppi.size.cy;
            }

            // Load titles into tabs.

            UpdateTabs(0);

            // Move controls to where they belong based on max page rectangle.

            TabCtrl_AdjustRect(_hwndTabs, TRUE, &rcMax);
            GetWindowRect(_hwndTabs, &rc);
            dx = rcMax.right - rcMax.left - rc.right + rc.left;
            dy = rcMax.bottom - rcMax.top - rc.bottom + rc.top;

            // Allow Trident to shrink the properties dialog in browse mode to honor
            // the size given by PMs.
            //
            if (dx < 0 && !_punkBrowseDefault) dx = 0;
            if (dy < 0 && !_punkBrowseDefault) dy = 0;

            MapWindowPoints(NULL, _hwndDialog, (GDIPOINT *)&rc, 2);
            rc.right += dx;
            rc.bottom += dy;
            MoveWindow(_hwndTabs, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, FALSE);

            _rcPage.left = 0;
            _rcPage.right = rc.right - rc.left;
            _rcPage.top = 0;
            _rcPage.bottom = rc.bottom - rc.top;

            TabCtrl_AdjustRect(_hwndTabs, FALSE, (GDIRECT *) ENSUREOLERECT(&_rcPage));
	        
            GetWindowRect(_hwndDialog, &rc);

            GDIRECT rcDesktop;
            LONG lWidth, lHeight;

            GetWindowRect(GetDesktopWindow(), &rcDesktop);
            lWidth  = rc.right - rc.left + dx;
            lHeight = rc.bottom - rc.top + dy;
            MoveWindow(_hwndDialog,
                    rcDesktop.left + (rcDesktop.right - rcDesktop.left - lWidth) / 2,
                    rcDesktop.top + (rcDesktop.bottom - rcDesktop.top - lHeight) / 2,
                    lWidth,
                    lHeight,
                    FALSE);

            //
            // Move the OK and Cancel buttons over in browse mode since we hide
            // the Apply button.
            //
            if (_punkBrowseDefault)
            {
                GDIRECT rc2;
                hwnd = GetDlgItem(_hwndDialog, IDI_PROPDLG_APPLY);
                GetWindowRect(hwnd, &rc);
                hwnd = GetDlgItem(_hwndDialog, IDCANCEL);
                GetWindowRect(hwnd, &rc2);
                dx += (rc.right - rc.left) + (rc.left - rc2.right);
            }

            for (i = 0; i < ARRAY_SIZE(aidiButtons); i++)
            {
                hwnd = GetDlgItem(_hwndDialog, aidiButtons[i]);
                GetWindowRect(hwnd, &rc);
                MapWindowPoints(NULL, _hwndDialog, (GDIPOINT *)&rc, 2);
                OffsetRect(&rc, aidiButtons[i] != IDI_PROPDLG_COMBO ? dx : 0, dy);
                MoveWindow(hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, FALSE);
            }

            // Activate the first page.

            if (_arySite.Size() > 0)
            {
                SetPage(0);
            }

            //  Disable the top-level parent, makes the propdialog modal.

            ::EnableWindow(_hwndTopParent, FALSE);

        Cleanup:
            _hr = hr;
            return FALSE;
        }


        //+------------------------------------------------------------------------
        //
        //  Member:     CPropertyDialog::DlgProc
        //
        //  Synopsis:   Dialog procedure.
        //
        //-------------------------------------------------------------------------

        BOOL CALLBACK
        CPropertyDialog::DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
        {
            CPropertyDialog *pDialog = (CPropertyDialog *)GetWindowLong(hwnd, DWL_USER);

            switch (msg)
            {
            case WM_INITDIALOG:
                SetWindowLong(hwnd, DWL_USER, lParam);
                pDialog = (CPropertyDialog *)lParam;
                return pDialog->OnInitDialog(hwnd);
                break;

            case WM_CLOSE:
                pDialog->Close();
                break;

            case WM_NOTIFY:
                pDialog->OnNotify((int)wParam, (LPNMHDR)lParam);
                break;

            case WM_COMMAND:
                pDialog->OnCommand(GET_WM_COMMAND_CMD(wParam, lParam),
                                   GET_WM_COMMAND_ID(wParam, lParam), 
                                   GET_WM_COMMAND_HWND(wParam, lParam));
                break;

            default:
                return FALSE;
            }

            return TRUE;
        }

        //+---------------------------------------------------------------------------
        //
        //  Member:     ShowPropertyDialog
        //
        //  Synopsis:   Show the property dialog for the given objects.
        //
        //----------------------------------------------------------------------------

        HRESULT
        ShowPropertyDialog(
                int                 cUnk,
                IUnknown **         apUnk,
                HWND                hwndOwner,
                IServiceProvider *  pServiceProvider,
                LCID                lcid,
                IUnknown *          punkBrowseDefault)
        {
            if (!cUnk)
                return S_OK;

            IDispatch *         pDispBase = NULL;
            CPropertyDialog     Dialog;
            MSG                 msg;
            HWND                hwndTop;
            HWND                hwnd;
    
            memset(&Dialog, 0, sizeof(Dialog));

            Dialog._iPage               = -1;
            Dialog._cUnk                = cUnk;
            Dialog._apUnk               = apUnk;
            Dialog._pServiceProvider    = pServiceProvider;
            Dialog._lcid                = lcid;
            Dialog._punkBrowseDefault   = punkBrowseDefault;

            //  compute top-level parent

            for ( hwnd = hwndTop = hwndOwner;
                  hwnd;
                  hwnd = GetParent(hwnd) )
            {
                hwndTop = hwnd;
            }
            Dialog._hwndTopParent    = hwndTop;

            if (!CreateDialogParam(
                    GetResourceHInst(),
                    MAKEINTRESOURCE(IDR_PROPERTIES_DIALOG),
                    hwndOwner,
                    &CPropertyDialog::DlgProc,
                    (LPARAM)&Dialog))
            {
                Dialog._hr = E_FAIL;
                goto Cleanup;
            }

        #ifdef UNIX
            // IEUNIX: Need to tell window manager that I'm modal
            MwSetModalPopup(Dialog._hwndDialog, TRUE);
        #endif

            ShowWindow(Dialog._hwndDialog, SW_SHOWNA);

            while (Dialog._hwndDialog)
            {
                GetMessage(&msg, NULL, 0, 0);

                if (Dialog.PreTranslateMessage(&msg) != S_OK)
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }


        Cleanup:
            RRETURN1(Dialog._hr, S_FALSE);
        }
        #endif // NO_HTML_DIALOG

#endif NEVER


//----------------------------------------------------------------------------
//  WARNING - We don't want to "taint" the property dialog with with any
//  knowledge of our internals.  This so that our hosts can duplicate our
//  UI from clean interfaces.  So don't move this include any higher in this
//  file and don't put any new functions below this line.
//

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ShowPropertyDialog
//
//  Synopsis:   Show the property dialog for the given array of sites.
//
//----------------------------------------------------------------------------


HRESULT
CDoc::ShowPropertyDialog(CDocument * pDocument, int cElements, CElement ** apElement)
{
#ifdef NO_HTML_DIALOG
    return S_OK;
#else        
    HRESULT             hr = E_FAIL;   
    SAFEARRAY         * psafearray = NULL;
    IUnknown * HUGEP  * apUnk = NULL;
    IOleCommandTarget * pBackupHostUICommandHandler = NULL;  
    EVENTPARAM          param(this, NULL, NULL, TRUE);
    VARIANT             varIn;
    int                 i;           
    HWND                hwnd = NULL;
    HWND                hwndParent;

    Assert(cElements >= 0);
    Assert(apElement || cElements==0);
    VariantInit(&varIn);

    psafearray = SafeArrayCreateVector(VT_UNKNOWN, 0, cElements);
    if (!psafearray)        
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // fill the safe array with punks
    if (cElements)
    {
        hr = SafeArrayAccessData(psafearray, (void HUGEP* FAR*)&apUnk);
        if (hr)
            goto Cleanup;
        Assert(apUnk);
        
        for (i = 0; i < cElements; ++i)
        {
            Assert(apElement[i]);           
            apUnk[i] = apElement[i]->PunkInner();
            apUnk[i]->AddRef();
        }
    }

    {
        CDoEnableModeless   dem(this, pDocument->MyCWindow());
    
        if (!dem._hwnd)
        {
            hr = E_FAIL;
            goto Cleanup;
        }    
     
        hwnd = dem._hwnd;

        // set up expandos         
        param.SetType(_T("propertysheet"));             
        param.propertysheetParams.paPropertysheetPunks     = psafearray;
        
        V_VT(&varIn) = VT_UNKNOWN;    

        pDocument->QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&varIn));

        //V_UNKNOWN(&varIn) = (IUnknown*)(IPrivateUnknown *)this;
        //V_UNKNOWN(&varIn)->AddRef();
        
        // Query host to show dialog    
        if (_pHostUICommandHandler)               
        {                             
            hr = _pHostUICommandHandler->Exec(                
                &CGID_DocHostCommandHandler,                        
                OLECMDID_PROPERTIES,                        
                0,                                           
                &varIn,                                            
                NULL);              
            if (SUCCEEDED(hr))
                goto Cleanup;        
        }
            
        // Let backup show dialog                                            
        EnsureBackupUIHandler();                            
        if (_pBackupHostUIHandler)                                        
        {                                                                                                  
            hr = _pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,                                            
                (void **) &pBackupHostUICommandHandler);                                                            
            if (hr)                                                                         
                goto Cleanup;                                            
                        
            hr = pBackupHostUICommandHandler->Exec(                                
                &CGID_DocHostCommandHandler,                                            
                OLECMDID_PROPERTIES,                                            
                0,                                            
                &varIn,                                            
                NULL);                                                                                   
        }
    }
    
Cleanup:
    // need to re-focus parent frame, since OleCreatePropertyFrameIndirect
    // does not return focus to its window owner
    if (hwnd)
    {
        for(hwndParent = GetParent(hwnd); 
            hwndParent;
            hwndParent = GetParent(hwnd) )
            hwnd = hwndParent;
        SetActiveWindow(hwnd);
    }
    SetFocus(TRUE);
    
    if (psafearray)
    {
        if (apUnk)
            SafeArrayUnaccessData(psafearray);
        SafeArrayDestroy(psafearray);
    }

    ReleaseInterface(pBackupHostUICommandHandler);
    VariantClear(&varIn);   

    RRETURN1(hr, S_FALSE);
#endif // NO_HTML_DIALOG
}


STDAPI CreateHTMLPropertyPage(       
        IMoniker *          pmk,
        IPropertyPage **    ppPP)
{
    HRESULT             hr = E_FAIL;    
    HTMLDLGINFO         dlginfo;
    CEnsureThreadState  ets;
       
    Assert(pmk);
    Assert(ppPP);       
  
    if (ppPP)
        *ppPP = NULL;

    if (!pmk || !ppPP)
        goto Cleanup;    

    hr = ets._hr;
    if (FAILED(hr))
        goto Cleanup;    
        
    dlginfo.pmk             = pmk;
    dlginfo.fPropPage       = TRUE;

    hr = THR(CHTMLDlg::CreateHTMLDlgIndirect(NULL, &dlginfo, IID_IPropertyPage, (void**)ppPP));
    if (hr)
        goto Cleanup;   

Cleanup:    
    if (hr && ppPP)    
    {
        ReleaseInterface(*ppPP);   
        *ppPP = NULL;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\formmso.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       src\core\formkrnl\formmso.cxx
//
//  Contents:   Implementation of IOleCommandTarget
//
//  Classes:    CDoc
//
//  Functions:
//
//  History:    04-May-95   RodC    Created
//
//----------------------------------------------------------------------------
#ifdef UNIX
#include <inetreg.h>
#endif

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_SHELLAPI_H_
#define X_SHELLAPI_H_
#include <shellapi.h>  // for the definition of ShellExecute
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_NTVERP_H_
#define X_NTVERP_H_
#include "ntverp.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"   // for _pimganim
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_UPDSINK_HXX_
#define X_UPDSINK_HXX_
#include "updsink.hxx"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_FRAME_HXX
#define X_FRAME_HXX
#include "frame.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif

#ifndef X_CGLYPH_HXX_
#define X_CGLYPH_HXX_
#include "cglyph.hxx"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"
#endif

#ifndef _X_WEBOCUTIL_H_
#define _X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

PerfDbgExtern(tagPerfWatch);

#ifdef UNIX
// A hack to compile:
EXTERN_C const GUID CGID_DocHostCommandHandler = {0xf38bc242,0xb950,0x11d1, {0x89,0x18,0x00,0xc0,0x4f,0xc2,0xc8,0x36}};
#endif // UNIX
EXTERN_C const GUID CGID_DocHostCommandHandler;

extern TCHAR g_achDLLCore[];
ExternTag(tagMsoCommandTarget);
extern void DumpFormatCaches();

#ifdef UNIX
extern int g_SelectedFontSize;
#endif

#ifndef NO_SCRIPT_DEBUGGER
extern interface IDebugApplication *g_pDebugApp;
#endif

EXTERN_C const GUID IID_ITriEditDocument = {0x438DA5DF, 0xF171, 0x11D0, {0x98, 0x4E, 0x00, 0x00, 0xF8, 0x02, 0x70, 0xF8}};

extern BOOL g_fInHtmlHelp;

HRESULT CreateResourceMoniker(HINSTANCE hInst, TCHAR *pchRID, IMoniker **ppmk);

ULONG ConvertSBCMDID(ULONG localIDM)
{
    struct SBIDMConvert {
        ULONG localIDM;
        ULONG SBCMDID;
    };
    static const SBIDMConvert SBIDMConvertTable[] =
    {
        { IDM_TOOLBARS,       SBCMDID_SHOWCONTROL },
        { IDM_STATUSBAR,      SBCMDID_SHOWCONTROL },
        { IDM_OPTIONS,        SBCMDID_OPTIONS },
        { IDM_ADDFAVORITES,   SBCMDID_ADDTOFAVORITES },
        { IDM_CREATESHORTCUT, SBCMDID_CREATESHORTCUT },
        { 0, 0 }
    };

    ULONG SBCmdID = IDM_UNKNOWN;
    int   i;

    for (i = 0; SBIDMConvertTable[i].localIDM; i ++)
    {
        if (SBIDMConvertTable[i].localIDM == localIDM)
        {
            SBCmdID = SBIDMConvertTable[i].SBCMDID;
            break;
        }
    }

    return SBCmdID;
}

//////////////
//  Globals // moved from rootlyt.cxx
//////////////

BSTR                g_bstrFindText = NULL;

HRESULT
GetFindText(BSTR *pbstr)
{
    LOCK_GLOBALS;

    RRETURN(FormsAllocString(g_bstrFindText, pbstr));
}


BOOL
CDoc::HostedInTriEdit()
{
    HRESULT     hr = S_OK;
    IUnknown    *pITriEditDocument = NULL;
    BOOL        fHostedInTriEdit = FALSE;
    
    hr = THR( QueryInterface(IID_ITriEditDocument, (void **)&pITriEditDocument) );
    if (hr == S_OK && pITriEditDocument != NULL)
    {
        fHostedInTriEdit = TRUE;
    }
    
    ReleaseInterface(pITriEditDocument);
    return fHostedInTriEdit;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDoc::RouteCTElement
//
//  Synopsis:   Route a command target call, either QueryStatus or Exec
//              to an element
//
//--------------------------------------------------------------------------

HRESULT
CDoc::RouteCTElement(CElement *pElement, CTArg *parg, CDocument *pContextDoc)
{
    HRESULT     hr = OLECMDERR_E_NOTSUPPORTED;
    CTreeNode * pNodeParent;
    AAINDEX     aaindex;
    IUnknown *  pUnk = NULL;

    _cInRouteCT++;

    if (TestLock(FORMLOCK_QSEXECCMD) && pContextDoc)
    {
        aaindex = pContextDoc->FindAAIndex(
            DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        if (aaindex != AA_IDX_UNKNOWN)
        {
            // Note: Command routing can fail here if we return an error because
            // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
            if (FAILED(pContextDoc->GetUnknownObjectAt(aaindex, &pUnk)))
                goto Cleanup;
        }
    }

    while (pElement)
    {
        // TODO (lmollico): traverse the master if the element wants to
        Assert(pElement->Tag() != ETAG_ROOT ||
               !pElement->IsInMarkup() || pElement == pElement->GetMarkup()->Root());

        if (!pElement->IsInMarkup() || pElement == pElement->GetMarkup()->Root())
            break;

        if (pUnk)
        {
            pElement->AddUnknownObject(
                DISPID_INTERNAL_INVOKECONTEXT, pUnk, CAttrValue::AA_Internal);
        }

        if (pContextDoc)
        {
            pElement->AddPointer(
                DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, pContextDoc, CAttrValue::AA_Internal);
        }

        if (parg->fQueryStatus)
        {
            Assert(parg->pqsArg->cCmds == 1);

            // Note: Command routing can fail here if we return an error because
            // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
            hr = THR_NOTRACE(pElement->QueryStatus(
                    parg->pguidCmdGroup,
                    parg->pqsArg->cCmds,
                    parg->pqsArg->rgCmds,
                    parg->pqsArg->pcmdtext));
            if (parg->pqsArg->rgCmds[0].cmdf)
                break;  // Element handled it.
        }
        else
        {
            // Note: Command routing can fail here if we return an error because
            // command execution halts unless we return OLECMDERR_E_NOTSUPPORTED.
            hr = THR_NOTRACE(pElement->Exec(
                    parg->pguidCmdGroup,
                    parg->pexecArg->nCmdID,
                    parg->pexecArg->nCmdexecopt,
                    parg->pexecArg->pvarargIn,
                    parg->pexecArg->pvarargOut));
            if (hr != OLECMDERR_E_NOTSUPPORTED)
                break;
        }

        if (pUnk)
        {
            pElement->FindAAIndexAndDelete(
                DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        }
        
        if (pContextDoc)
        {
            pElement->FindAAIndexAndDelete(
                DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, CAttrValue::AA_Internal);
        }

        if (!pElement->IsInMarkup())
            break;

        if (pElement == pElement->GetMarkup()->GetElementClient())
            break;

        pNodeParent = pElement->GetFirstBranch()->Parent();
        pElement = pNodeParent ? pNodeParent->Element() : NULL;
    }

Cleanup:
    if (pUnk && pElement)
    {
        pElement->FindAAIndexAndDelete(
            DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
    }
    if (pContextDoc && pElement)
    {
        pElement->FindAAIndexAndDelete(
            DISPID_INTERNAL_INVOKECONTEXTDOCUMENT, CAttrValue::AA_Internal);
    }
    ReleaseInterface(pUnk);
    _cInRouteCT--;
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CDoc::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    HRESULT hr;

    hr = THR(QueryStatusHelper(NULL, pguidCmdGroup, cCmds, rgCmds, pcmdtext));

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     GetExecDocument
//
//  Synopsis:   Helper called to get a CDocument* based on two choices
//
//--------------------------------------------------------------------------
HRESULT
GetExecDocument(CDocument ** ppDocument, CElement * pMenuObject, CDocument * pContextDoc)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = NULL;

    Assert(ppDocument);

    // Determine the markup to execute the command on
    if (pMenuObject)
    {
        pMarkup = pMenuObject->GetMarkup();
    }
    else if (pContextDoc)
    {
        pMarkup = pContextDoc->Markup();
    }

    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);

    Assert(pMarkup);

    *ppDocument = pMarkup->Document();

    Assert(NULL != *ppDocument);

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::QueryStatusHelper
//
//  Synopsis:   Helper called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CDoc::QueryStatusHelper(
        CDocument *pContextDoc,
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagMsoCommandTarget, "CDoc::QueryStatus"));

    // Check to see if the command is in our command set.
    if (!IsCmdGroupSupported(pguidCmdGroup))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);

    MSOCMD *    pCmd;
    INT         c;
    UINT        idm;
    HRESULT     hr = S_OK;
    MSOCMD      msocmd;
    CTArg       ctarg;
    CTQueryStatusArg    qsarg;
    BOOL                fDesignMode;
    CMarkup     *pEditMarkup = NULL;

    if (!pContextDoc)
    {
        Assert(_pWindowPrimary);
        pContextDoc = _pWindowPrimary->Document();
    }
    else
    {
        pEditMarkup = pContextDoc->Markup();
    }

    Assert (pContextDoc);
    Assert (pContextDoc->Markup());
    fDesignMode = pContextDoc->Markup()->_fDesignMode;

    // Loop through each command in the ary, setting the status of each.
    for (pCmd = rgCmds, c = cCmds; --c >= 0; pCmd++)
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        idm = IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
        if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_STATUS)
        {
            pcmdtext[c].cwActual = LoadString(
                    GetResourceHInst(),
                    IDS_MENUHELP(idm),
                    pcmdtext[c].rgwz,
                    pcmdtext[c].cwBuf);
        }

        if (    !fDesignMode
            &&  idm >= IDM_MENUEXT_FIRST__
            &&  idm <= IDM_MENUEXT_LAST__
            &&  _pOptionSettings)
        {
            CONTEXTMENUEXT *    pCME;
            int                 nExts, nExtCur;

            // not supported unless the next test succeeds
            pCmd->cmdf = 0;

            nExts = _pOptionSettings->aryContextMenuExts.Size();
            nExtCur = idm - IDM_MENUEXT_FIRST__;

            if(nExtCur < nExts)
            {
                // if we have it, it is enabled
                pCmd->cmdf = MSOCMDSTATE_UP;

                // the menu name is the text returned
                pCME = _pOptionSettings->
                            aryContextMenuExts[idm - IDM_MENUEXT_FIRST__];
                pCmd->cmdf = MSOCMDSTATE_UP;

                Assert(pCME);

                if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_NAME)
                {
                    hr = Format(
                            0,
                            pcmdtext->rgwz,
                            pcmdtext->cwBuf,
                            pCME->cstrMenuValue);
                    if (!hr)
                        pcmdtext->cwActual = _tcslen(pcmdtext->rgwz);

                    // ignore the hr
                    hr = S_OK;
                }
            }
        }

        switch (idm)
        {
        case IDM_REPLACE:
        case IDM_FONT:
        case IDM_GOTO:
        case IDM_HYPERLINK:
        case IDM_BOOKMARK:
        case IDM_IMAGE:
            if(_fInHTMLDlg)
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

        case IDM_FIND:
            if (_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else
                pCmd->cmdf = _fInHTMLDlg ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_PROPERTIES:
            pCmd->cmdf = MSOCMDSTATE_UP;
            hr = S_OK;
            break;

        case IDM_MENUEXT_COUNT:
            pCmd->cmdf = _pOptionSettings ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
            break;

        case IDM_REDO:
        case IDM_UNDO:
            QueryStatusUndoRedo((IDM_UNDO == idm), pCmd, pcmdtext);
            break;

        case IDM_SAVE:
            if (!fDesignMode)
            {
                // Disable Save Command if in BROWSE mode.
                //
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
                break;
            }
            // fall through to QueryStatus the DocFrame if in EDIT mode.

        case IDM_NEW:
        case IDM_OPEN:
            //  Bubble it out to the DocFrame

            msocmd.cmdf  = 0;
            msocmd.cmdID = (idm == IDM_NEW) ? (OLECMDID_NEW) :
                   ((idm == IDM_OPEN) ? (OLECMDID_OPEN) : (OLECMDID_SAVE));
            hr = THR(CTQueryStatus(_pInPlace->_pInPlaceSite, NULL, 1, &msocmd, NULL));
            if (!hr)
                pCmd->cmdf = msocmd.cmdf;

            break;

        case IDM_SAVEAS:
            pCmd->cmdf = _fFullWindowEmbed ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_ISTRUSTEDDLG:
            if(_fInTrustedHTMLDlg)
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            else
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

#if !defined(WIN16) && !defined(WINCE)
#if !defined(NO_SCRIPT_DEBUGGER)
        case IDM_TOOLBARS:
        case IDM_STATUSBAR:
            ULONG        SBCmdId;
            VARIANTARG   varIn, varOut;

            pCmd->cmdf = MSOCMDSTATE_DISABLED;

            SBCmdId = ConvertSBCMDID(idm);
            varIn.vt   = VT_I4;
            varIn.lVal = MAKELONG(
                    (idm == IDM_TOOLBARS) ? (FCW_INTERNETBAR) : (FCW_STATUS),
                    SBSC_QUERY);

            hr = THR(CTExec(
                    _pInPlace->_pInPlaceSite,
                    &CGID_Explorer,
                    SBCmdId,
                    0,
                    &varIn,
                    &varOut));
            if (!hr && varOut.vt == VT_I4)
            {
                switch (varOut.lVal)
                {
                case SBSC_HIDE:
                    pCmd->cmdf = MSOCMDSTATE_UP;
                    break;

                case SBSC_SHOW:
                    pCmd->cmdf = MSOCMDSTATE_DOWN;
                    break;
                }
            }

            break;

#endif // NO_SCRIPT_DEBUGGER

        case IDM_OPTIONS:
        case IDM_ADDFAVORITES:
        case IDM_CREATESHORTCUT:
            msocmd.cmdf  = 0;
            msocmd.cmdID = ConvertSBCMDID(idm);
            hr = THR(CTQueryStatus(
                    _pInPlace->_pInPlaceSite,
                    &CGID_Explorer,
                    1,
                    &msocmd,
                    NULL));
            if (!hr)
            {
                pCmd->cmdf = (msocmd.cmdf & MSOCMDF_ENABLED) ?
                        (MSOCMDSTATE_UP) : (MSOCMDSTATE_DISABLED);
            }
            break;
#endif // !WIN16 && !WINCE

        case IDM_PAGESETUP:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_PRINT:
            pCmd->cmdf = (IsPrintDialog()) ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_PRINTPREVIEW:
            pCmd->cmdf =    (   IsPrintDialog()
                             || GetPlugInSiteForPrinting(pContextDoc) == S_OK )
                                ? MSOCMDSTATE_DISABLED
                                : MSOCMDSTATE_UP;
            break;

        case IDM_PRINTQUERYJOBSPENDING:
            pCmd->cmdf = (PrintJobsPending() ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED);
            break;

        case IDM_HELP_CONTENT:
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

        case IDM_HELP_README:
        case IDM_HELP_ABOUT:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_BROWSEMODE:
            if (fDesignMode)
                pCmd->cmdf = MSOCMDSTATE_UP;
            else
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            break;

        case IDM_EDITMODE:
            if (pContextDoc->Markup()->IsImageFile()) // Cannot edit image files
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else if (fDesignMode)
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_VIEWSOURCE:
            if (pContextDoc->Markup()->IsImageFile() || _fFullWindowEmbed) // No source for non-HTML files
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

#ifndef NO_SCRIPT_DEBUGGER
        case IDM_SCRIPTDEBUGGER:
            if (PrimaryMarkup()->HasScriptContext() &&
                PrimaryMarkup()->ScriptContext()->_pScriptDebugDocument)
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_BREAKATNEXT:
        case IDM_LAUNCHDEBUGGER:
            pCmd->cmdf = (PrimaryMarkup()->HasScriptContext() &&
                          PrimaryMarkup()->ScriptContext()->_pScriptDebugDocument) ?
                            MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
            break;
#endif // ndef NO_SCRIPT_DEBUGGER

        case IDM_STOP:
            pCmd->cmdf = fDesignMode ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
            break;

        case IDM_STOPDOWNLOAD:
            pCmd->cmdf = _fSpin ? MSOCMDF_ENABLED : 0;
            break;

        case IDM_REFRESH_TOP:
        case IDM_REFRESH_TOP_FULL:
            _pWindowPrimary->QueryRefresh(&pCmd->cmdf);
            break;

        case IDM_REFRESH:
        case IDM_REFRESH_THIS:
        case IDM_REFRESH_THIS_FULL:
            {
                COmWindowProxy * pOmWindowProxy = NULL;

                // Get the markup of the nearest frame, if any. Otherwise use the primary markup.

                Assert(pContextDoc);

                CMarkup * pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();

                if (pMarkup)
                {
                    pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);
                }
                if (pMarkup)
                {
                    pOmWindowProxy = pMarkup->Window();
                }
                if (!pOmWindowProxy)
                {
                    pOmWindowProxy = _pWindowPrimary;
                }
                Assert(pOmWindowProxy);
                pOmWindowProxy->QueryRefresh(&pCmd->cmdf);
            }
            break;

        case IDM_CONTEXTMENU:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_GOBACKWARD:
        case IDM_GOFORWARD:
            {
                // default this to disabled since we're not
                // hosted in shdocvw when we're on the desktop
                pCmd->cmdf = MSOCMDSTATE_DISABLED;

                MSOCMD            rgCmds1[1];
                LPOLECLIENTSITE   lpClientSite     = NULL;
                IBrowserService * pTopFrameBrowser = NULL;

                rgCmds1[0].cmdf  = 0;
                rgCmds1[0].cmdID = (idm == IDM_GOBACKWARD)
                                 ? SHDVID_CANGOBACK
                                 : SHDVID_CANGOFORWARD;

                if (_fViewLinkedInWebOC && _pBrowserSvc)
                {
                    hr = IUnknown_QueryService(_pBrowserSvc, SID_STopFrameBrowser,
                                               IID_IBrowserService, (void**)&pTopFrameBrowser);
                    if (hr)
                        goto Cleanup;

                    hr = IUnknown_QueryStatus(pTopFrameBrowser, &CGID_ShellDocView,
                                              1, rgCmds1, NULL);
                }
                else
                {
                    hr = GetClientSite(&lpClientSite);

                    if (hr || !lpClientSite)
                    {
                        goto Cleanup;
                    }

                    hr = IUnknown_QueryStatus(lpClientSite, &CGID_ShellDocView,
                                              1, rgCmds1, NULL);
                }

                if (hr)
                    goto Cleanup;

                pCmd->cmdf = rgCmds1[0].cmdf ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;

            Cleanup:
                ReleaseInterface(lpClientSite);
                ReleaseInterface(pTopFrameBrowser);
            }

           break;

        case IDM_BASELINEFONT1:
        case IDM_BASELINEFONT2:
        case IDM_BASELINEFONT3:
        case IDM_BASELINEFONT4:
        case IDM_BASELINEFONT5:
            //
            // depend on that IDM_BASELINEFONT1, IDM_BASELINEFONT2,
            // IDM_BASELINEFONT3, IDM_BASELINEFONT4, IDM_BASELINEFONT5 to be
            // consecutive integers.
            //
            {
                if (GetBaselineFont() ==
                    (short)(idm - IDM_BASELINEFONT1 + BASELINEFONTMIN))
                {
                    pCmd->cmdf = MSOCMDSTATE_DOWN;
                }
                else
                {
                    pCmd->cmdf = MSOCMDSTATE_UP;
                }
            }
            break;

        case IDM_SHDV_MIMECSETMENUOPEN:
        case IDM_SHDV_FONTMENUOPEN:
        case IDM_SHDV_GETMIMECSETMENU:
        case IDM_SHDV_GETFONTMENU:
        case IDM_LANGUAGE:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_DIRLTR:
        case IDM_DIRRTL:
            {
                BOOL fDocRTL = FALSE;   // keep compiler happy

                CDocument * pDocument;

                hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
                if (SUCCEEDED(hr))
                {
                    hr = THR(pDocument->GetDocDirection(&fDocRTL));
                }
                if (hr == S_OK && ((!fDocRTL) ^ (idm == IDM_DIRRTL)))
                {
                    pCmd->cmdf = MSOCMDSTATE_DOWN;
                }
                else
                {
                    pCmd->cmdf = MSOCMDSTATE_UP;
                }
            }
            break;

        case IDM_SHDV_DEACTIVATEMENOW:
        case IDM_SHDV_NODEACTIVATENOW:
            //  This is Exec only in the upward direction.
            //  we shouldn't get here.
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;

        case IDM_SHDV_CANDEACTIVATENOW:
            //  We return ENABLED unless we or one of our OCs [eg a frame]
            //  are in a script or otherwise not able to be deactivated.  if this is
            //  disabled, SHDOCVW will defer the activation until signaled by
            //  a SHDVID_DEACTIVATEMENOW on script exit [at which time, it
            //  will redo the SHDVID_CANDEACTIVATENOW querystatus]
            Assert(pContextDoc->GetWindowedMarkupContext()->GetWindowPending());
            if (pContextDoc->GetWindowedMarkupContext()->GetWindowPending()->Window()->IsInScript())
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

        case IDM_SHDV_PAGEFROMPOSTDATA:
            if (PrimaryMarkup()->GetDwnPost())
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            else
                pCmd->cmdf = MSOCMDSTATE_UP;
            break;

#ifdef IDM_SHDV_ONCOLORSCHANGE
                        // Let the shell know we support the new palette notification
                case IDM_SHDV_ONCOLORSCHANGE:
                        pCmd->cmdf = MSOCMDF_SUPPORTED;
                        break;
#endif
        case IDM_RESPECTVISIBILITY_INDESIGN:
            pCmd->cmdf = pContextDoc->Markup()->IsRespectVisibilityInDesign() ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
            break;

        case IDM_HTMLEDITMODE:
            pCmd->cmdf = _fInHTMLEditMode ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP;
            break;

        case IDM_SHOWALLTAGS:
        case IDM_SHOWALIGNEDSITETAGS:
        case IDM_SHOWSCRIPTTAGS:
        case IDM_SHOWSTYLETAGS:
        case IDM_SHOWCOMMENTTAGS:
        case IDM_SHOWAREATAGS:
        case IDM_SHOWUNKNOWNTAGS:
        case IDM_SHOWMISCTAGS:
        {
            Assert(pContextDoc->Markup());
            CGlyph *pTable = pContextDoc->Markup()->GetGlyphTable();

            if( pTable )
            {
                switch( idm )
                {
                    case IDM_SHOWALLTAGS:
                        pCmd->cmdf = pTable->_fShowAlignedSiteTags &&
                                     pTable->_fShowMiscTags &&
                                     pTable->_fShowScriptTags &&
                                     pTable->_fShowStyleTags &&
                                     pTable->_fShowCommentTags &&
                                     pTable->_fShowAreaTags &&
                                     pTable->_fShowUnknownTags &&
                                     pTable->_fShowMiscTags ?
                                     MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWALIGNEDSITETAGS:
                        pCmd->cmdf = pTable->_fShowAlignedSiteTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWSCRIPTTAGS:
                        pCmd->cmdf = pTable->_fShowScriptTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWSTYLETAGS:
                        pCmd->cmdf = pTable->_fShowStyleTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWCOMMENTTAGS:
                        pCmd->cmdf = pTable->_fShowCommentTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWAREATAGS:
                        pCmd->cmdf = pTable->_fShowAreaTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWUNKNOWNTAGS:
                        pCmd->cmdf = pTable->_fShowUnknownTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;

                    case IDM_SHOWMISCTAGS:
                        pCmd->cmdf = pTable->_fShowMiscTags ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
                        break;
                }
            }
            else
            {
                pCmd->cmdf = MSOCMDSTATE_UP;
            }

            break;
        }


        case IDM_SHOWZEROBORDERATDESIGNTIME:
            pCmd->cmdf = CHECK_EDIT_BIT( pContextDoc->Markup(),_fShowZeroBorderAtDesignTime ) ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

        case IDM_NOACTIVATENORMALOLECONTROLS:
            pCmd->cmdf = _fNoActivateNormalOleControls ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

        case IDM_NOACTIVATEDESIGNTIMECONTROLS:
            pCmd->cmdf = _fNoActivateDesignTimeControls ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

        case IDM_NOACTIVATEJAVAAPPLETS:
            pCmd->cmdf = _fNoActivateJavaApplets ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;
            break;

#if DBG==1
        case IDM_DEBUG_TRACETAGS:
        case IDM_DEBUG_DUMPOTRACK:
        case IDM_DEBUG_RESFAIL:
        case IDM_DEBUG_BREAK:
        case IDM_DEBUG_VIEW:
        case IDM_DEBUG_DUMPTREE:
        case IDM_DEBUG_DUMPFORMATCACHES:
        case IDM_DEBUG_DUMPLINES:
        case IDM_DEBUG_DUMPLAYOUTRECTS:
        case IDM_DEBUG_MEMMON:
        case IDM_DEBUG_METERS:
        case IDM_DEBUG_DUMPDISPLAYTREE:
        case IDM_DEBUG_DUMPRECALC:
        case IDM_DEBUG_SAVEHTML:
            pCmd->cmdf = MSOCMDSTATE_UP;
            break;
#endif // DBG == 1

        }

//#ifndef NO_IME
        // Enables the languages in the browse context menu
        if( !fDesignMode && idm >= IDM_MIMECSET__FIRST__ &&
                             idm <= IDM_MIMECSET__LAST__)
        {
            CODEPAGE cp = GetCodePageFromMenuID(idm);

            if (cp == PrimaryMarkup()->GetCodePage() || cp == CP_UNDEFINED)
            {
                pCmd->cmdf = MSOCMDSTATE_DOWN;
            }
            else
            {
                pCmd->cmdf = MSOCMDSTATE_UP;
            }
        }
//#endif // !NO_IME

        //
        // If still not handled then try menu object.
        //

        ctarg.pguidCmdGroup = pguidCmdGroup;
        ctarg.fQueryStatus = TRUE;
        ctarg.pqsArg = &qsarg;
        qsarg.cCmds = 1;
        qsarg.rgCmds = pCmd;
        qsarg.pcmdtext = pcmdtext;

        if (!pCmd->cmdf && _pMenuObject)
        {
            hr = THR_NOTRACE(RouteCTElement(_pMenuObject, &ctarg, pContextDoc));
        }

        //
        // Next try the current element;
        //
        if (!pCmd->cmdf && _pElemCurrent)
        {
            CElement *pelTarget;
            CTreeNode *pNode = _pElemCurrent->GetFirstBranch();
            Assert(pNode);
            Assert(pContextDoc);

            // Get the node in the markup of the context CDocument that contains the current element
            pNode = pNode->GetNodeInMarkup(pContextDoc->Markup());

            if (pNode)
            {
                pelTarget = pNode->Element();
            }
            else
            {
                pelTarget = pContextDoc->Markup()->GetElementClient();
            }
            if (pelTarget)
                hr = THR_NOTRACE(RouteCTElement(pelTarget, &ctarg, pContextDoc));
        }

        //
        // Finally try edit router
        //

        if( !pCmd->cmdf )
        {
            CEditRouter *pRouter;
            HRESULT     hrEdit = S_OK;

            // Retrieve the edit markup if no context has been passed into this helper function.
            // This occurs when pContextDoc is NULL on input.  pEditMarkup will be NULL in this
            // case, and we use the selection's current markup in order to determine where
            // the edit command should be routed to

            if( !pEditMarkup )
            {
                hrEdit = THR( GetSelectionMarkup( &pEditMarkup ) );

                if( pEditMarkup == NULL && _pElemCurrent )
                {
                    pEditMarkup = _pElemCurrent->GetMarkupPtr();
                }

            }

            if( !FAILED(hrEdit) && pEditMarkup )
            {
                hr = THR( pEditMarkup->EnsureEditRouter(&pRouter) );

                if( !FAILED(hr) )
                {
                    hr = THR_NOTRACE( pRouter->QueryStatusEditCommand(
                            pguidCmdGroup,
                            1,
                            pCmd,
                            pcmdtext,
                            (IUnknown *)(IPrivateUnknown *)pEditMarkup,
                            pEditMarkup,
                            this ));
                }
            }
        }

        // Prevent any command but the first from setting this.
        pcmdtext = NULL;
    }

    SRETURN(hr);
}

#if !defined(UNIX)

extern HRESULT DisplaySource(LPCTSTR tszSourceName);

HRESULT CDoc::InvokeEditor( LPCTSTR tszSourceName )
{
    return DisplaySource(tszSourceName);
}

#else // !UNIX

HRESULT CDoc::InvokeEditor( LPCTSTR lptszPath )
{
    HRESULT         hr = S_OK;

    TCHAR           tszCommand[pdlUrlLen];
    TCHAR           tszExpandedCommand[pdlUrlLen];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey;
    DWORD   dw;
    TCHAR *pchPos;
    BOOL bMailed;
    STARTUPINFO stInfo;

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS,
                        0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;

    dw = pdlUrlLen;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    dw = ExpandEnvironmentStrings(tszCommand, tszExpandedCommand, pdlUrlLen);
    if (!dw)
    {
        _tcscpy(tszExpandedCommand, tszCommand);
    }
    _tcscat(tszCommand, tszExpandedCommand);

    for (i = _tcslen(tszCommand); i > 0; i--)
    {
        if (tszCommand[i] == '/')
        {
            tszCommand[i] = '\0';
            break;
        }
    }

    _tcscat(tszCommand, TEXT(" "));
    _tcscat(tszCommand, lptszPath);

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    stInfo.wShowWindow= SW_SHOWNORMAL;
    bMailed = CreateProcess(tszExpandedCommand,
                            tszCommand,
                            NULL, NULL, TRUE,
                            CREATE_NEW_CONSOLE,
                            NULL, NULL, &stInfo, NULL);

Cleanup:

    return hr;
}

#endif

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Exec
//
//  Synopsis:   Called to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT hr;

    hr = THR(ExecHelper(NULL, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

    SRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ExecHelper
//
//  Synopsis:   helper to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------
#define IPRINT_DOCUMENT     0
#define IPRINT_ACTIVEFRAME  1
#define IPRINT_ALLFRAMES    2

HRESULT
CDoc::ExecHelper(
        CDocument *pContextDoc,
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CDoc::Exec"));

    if (!IsCmdGroupSupported(pguidCmdGroup))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);


#ifndef NO_HTML_DIALOG
    struct DialogInfo
    {
        UINT    idm;
        UINT    idsUndoText;
        TCHAR * szidr;
    };

    // TODO (cthrash) We should define and use better undo text.  Furthermore,
    // we should pick an appropriate one depending (for image, link, etc.)
    // on whether we're creating anew or editting an existing object.
    //
    // Fix for bug# 9136. (a-pauln)
    // Watch order of this array. Find dialogs need to be at the bottom,
    // and in the order listed (IDR_FINDDIALOG, IDR_BIDIFINDDIALOG).
    //
    // Find resources have been relocated to shdocvw (peterlee)
    static DialogInfo   dlgInfo[] =
    {
        {IDM_FIND,          0,                     NULL}, //IDR_FINDDIALOG,
        {IDM_FIND,          0,                     NULL}, //IDR_BIDIFINDDIALOG,
        {IDM_REPLACE,       IDS_UNDOGENERICTEXT,   IDR_REPLACEDIALOG},
        {IDM_PARAGRAPH,     IDS_UNDOGENERICTEXT,   IDR_FORPARDIALOG},
        {IDM_FONT,          IDS_UNDOGENERICTEXT,   IDR_FORCHARDIALOG},
        {IDM_GOTO,          0,                     IDR_GOBOOKDIALOG},
        {IDM_IMAGE,         IDS_UNDONEWCTRL,       IDR_INSIMAGEDIALOG},
        {IDM_HYPERLINK,     IDS_UNDOGENERICTEXT,   IDR_EDLINKDIALOG},
        {IDM_BOOKMARK,      IDS_UNDOGENERICTEXT,   IDR_EDBOOKDIALOG},
    };
#endif // NO_HTML_DIALOG

    CDoc::CLock         Lock(this);
    UINT                idm;
    HRESULT             hr = OLECMDERR_E_NOTSUPPORTED;
    DWORD               nCommandID;
    CTArg               ctarg;
    CTExecArg           execarg;
    BOOL                fRouteToEditor = FALSE;
    CMarkup             *pEditMarkup = NULL;
    CDocument           *pContextDocOrig = pContextDoc;

    //  artakka showhelp is not implemented (v2?)
    if(nCmdexecopt == MSOCMDEXECOPT_SHOWHELP)
    {
        return E_NOTIMPL;
    }


    if (!pContextDoc)
    {
        Assert(_pWindowPrimary);
        pContextDoc = _pWindowPrimary->Document();
    }
    else
    {
        pEditMarkup = pContextDoc->Markup();
    }

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    // Handle context menu extensions - always eat the command here
    if( idm >= IDM_MENUEXT_FIRST__ && idm <= IDM_MENUEXT_LAST__)
    {
        CMarkup * pMarkupExt = NULL;
        if (_pMenuObject)
            pMarkupExt = _pMenuObject->GetMarkup();
        if (!pMarkupExt)
            pMarkupExt = pContextDoc->Markup();

        if (pMarkupExt)
        {
            hr = OnContextMenuExt(pMarkupExt, idm, pvarargIn);
        }
        goto Cleanup;
    }

    switch (idm)
    {
        int             result;

#if DBG==1
    case IDM_DEBUG_MEMMON:
        DbgExOpenMemoryMonitor();
        hr = S_OK;
        break;

    case IDM_DEBUG_METERS:
        DbgExMtOpenMonitor();
        hr = S_OK;
        break;

    case IDM_DEBUG_TRACETAGS:
        DbgExDoTracePointsDialog(FALSE);
        hr = S_OK;
        break;

    case IDM_DEBUG_RESFAIL:
        DbgExShowSimFailDlg();
        hr = S_OK;
        break;

    case IDM_DEBUG_DUMPOTRACK:
        DbgExTraceMemoryLeaks();
        hr = S_OK;
        break;

    case IDM_DEBUG_BREAK:
        DebugBreak();
        hr = S_OK;
        break;

    case IDM_DEBUG_VIEW:
        DbgExOpenViewObjectMonitor(_pInPlace->_hwnd, (IUnknown *)(IViewObject *) this, TRUE);
        hr = S_OK;
        break;

    case IDM_DEBUG_DUMPTREE:
        {
            if(_pElemCurrent->GetMarkup())
                _pElemCurrent->GetMarkup()->DumpTree();
            break;
        }
    case IDM_DEBUG_DUMPLINES:
        {
            CFlowLayout * pFlowLayout = _pElemCurrent->GetFirstBranch()->GetFlowLayout();
            if(pFlowLayout)
                pFlowLayout->DumpLines();
            break;
        }
    case IDM_DEBUG_DUMPDISPLAYTREE:
        GetView()->DumpDisplayTree();
        break;

    case IDM_DEBUG_DUMPFORMATCACHES:
        DumpFormatCaches();
        break;
    case IDM_DEBUG_DUMPLAYOUTRECTS:
        DumpLayoutRects();
        break;
    case IDM_DEBUG_DUMPRECALC:
        _recalcHost.Dump(0);
        break;
#endif

    case IDM_ADDFAVORITES:
        {
            CMarkup * pMarkup = NULL;

            if(pContextDocOrig)
            {
                pMarkup = pContextDocOrig->Markup();
            }
            else if(_pMenuObject)
            {
                hr = THR_NOTRACE(_pMenuObject->Exec(
                    pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                if(hr == S_OK)
                    break;

                pMarkup = _pMenuObject->GetMarkup();
            }
            else if(_pElemCurrent) //context was not directly specified and have currency
            {
                hr = THR_NOTRACE(_pElemCurrent->Exec(
                    pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                if(hr == S_OK)
                    break;

                pMarkup = _pElemCurrent->GetMarkup();
            }

            {
                // Add the current document to the favorite folder ...
                //
                TCHAR * pszURL;
                TCHAR * pszTitle;

                if(!pMarkup) pMarkup = pContextDoc->Markup();
                pszURL   = (TCHAR *) CMarkup::GetUrl(pMarkup);

                pszTitle = (pMarkup->GetTitleElement() && pMarkup->GetTitleElement()->Length())
                         ? (pMarkup->GetTitleElement()->GetTitle())
                         : (NULL);
                hr = AddToFavorites(pszURL, pszTitle);
            }
        }
        break;

#ifndef NO_HTML_DIALOG
    // provide the options object to the dialog code
    case IDM_FIND:
    case IDM_REPLACE:
        // we should not invoke the dialogs out of the dialog...
        if (!_fInHTMLDlg && nCmdexecopt != MSOCMDEXECOPT_DONTPROMPTUSER)
        {
            CVariant            cVarNull(VT_NULL);
            IDispatch      *    pDispOptions = NULL;
            CParentUndoUnit*    pCPUU = NULL;
            BSTR                bstrText = NULL;
            COptionsHolder *    pcoh = NULL;
            CDoc *              pDoc = this;
            int                 i;
            CMarkup *           pWindowedMarkupContext;

            CMarkup *           pMarkup =
            (pContextDocOrig ?
                pContextDocOrig->Markup() :
                ( _pMenuObject ?
                    _pMenuObject->GetMarkup() :
                    ( _pElemCurrent ?
                        _pElemCurrent->GetMarkup() :
                        pContextDoc->Markup())));

            pWindowedMarkupContext = pMarkup->GetWindowedMarkupContext();

            if (!pWindowedMarkupContext->HasWindow())
            {
                hr = S_OK;
                goto Cleanup_FindReplace;
            }

            pcoh = new COptionsHolder(pWindowedMarkupContext->Window()->Window());

            if (pcoh == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup_FindReplace;
            }

            // find RID string
            for (i = 0; i < ARRAY_SIZE(dlgInfo); ++i)
            {
                if (idm == dlgInfo[i].idm)
                    break;
            }
            Assert(i < ARRAY_SIZE(dlgInfo));

            if (dlgInfo[i].idsUndoText)
            {
                pCPUU = OpenParentUnit(this, dlgInfo[i].idsUndoText);
            }

            // get dispatch from stack variable
            hr = THR_NOTRACE(pcoh->QueryInterface(IID_IHTMLOptionsHolder,
                                     (void**)&pDispOptions));
            if (hr)
                goto Cleanup_FindReplace;

            // Save the execCommand argument so that the dialog can have acces
            // to them
            //
#ifdef _MAC     // casting so bad I left in the #ifdef
            pcoh->put_execArg(pvarargIn ? (VARIANT) * pvarargIn
                                        : *((VARIANT *) ((void *)&cVarNull)));
#else
            pcoh->put_execArg(pvarargIn ? (VARIANT) * pvarargIn
                                        : (VARIANT)   cVarNull);

#endif

            hr = THR(GetFindText(&bstrText));
            if (hr)
                goto Cleanup_FindReplace;

            // Set the findText argument for the dialog
            THR_NOTRACE(pcoh->put_findText(bstrText));
            FormsFreeString(bstrText);
            bstrText = NULL;

            if (idm == IDM_REPLACE)
            {
// TODO (dmitryt) at the moment (5.5 RTM) we don't have replace.dlg template in shdocvw.
//      IE5.0 didn't have either. This seems no to work at all. But if it does or will be,
//      _pElemCurrent should probably be replaced with pContextDoc...
                hr = THR(ShowModalDialogHelper(
                        _pElemCurrent->GetMarkup(),
                        dlgInfo[i].szidr,
                        pDispOptions,
                        pcoh));
                goto UIHandled;
            }

            // Fix for bug# 9136. (a-pauln)
            // make an adjustment for the bidi find dialog
            // if we are on a machine that supports bidi
            BOOL fbidi;
            fbidi = (idm == IDM_FIND && g_fBidiSupport);

            // Let host show find dialog
            VARIANT varIn;
            VARIANT varOut;

            V_VT(&varIn) = VT_DISPATCH;
            V_DISPATCH(&varIn) = pDispOptions;

            // The HTMLView object in Outlook 98 returns S_OK for all exec
            // calls, even those for which it should return OLECMD_E_NOTSUPPORTED.
            if (pDoc->_pHostUICommandHandler && !pDoc->_fOutlook98)
            {
                hr = pDoc->_pHostUICommandHandler->Exec(
                    &CGID_DocHostCommandHandler,
                    OLECMDID_SHOWFIND,
                    fbidi,
                    &varIn,
                    &varOut);

                if (!hr)
                    goto UIHandled;
            }

            // Let backup show find dialog
            pDoc->EnsureBackupUIHandler();
            if (pDoc->_pBackupHostUIHandler)
            {
                IOleCommandTarget * pBackupHostUICommandHandler;
                hr = pDoc->_pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                    (void **) &pBackupHostUICommandHandler);
                if (hr)
                    goto Cleanup_FindReplace;

                hr = THR(pBackupHostUICommandHandler->Exec(
                    &CGID_DocHostCommandHandler,
                    OLECMDID_SHOWFIND,
                    fbidi,
                    &varIn,
                    &varOut));
                ReleaseInterface(pBackupHostUICommandHandler);
            }

UIHandled:
Cleanup_FindReplace:
            // release dispatch, et al.
            ReleaseInterface(pcoh);
            ReleaseInterface(pDispOptions);

            if ( pCPUU )
            {
                IGNORE_HR(CloseParentUnit( pCPUU, hr ) );
            }
        }

        break;


    case IDM_PROPERTIES:
        {

            CDocument * pDocument = _pMenuObject ? _pMenuObject->GetMarkup()->Document() : pContextDoc;

            if (_pMenuObject && _pMenuObject->HasPages())
            {
                THR(ShowPropertyDialog(pDocument, 1, &_pMenuObject));
            }
            else if (!_pMenuObject && _pElemCurrent && _pElemCurrent->HasPages())
            {
                THR(ShowPropertyDialog(pDocument, 1, &_pElemCurrent));
            }
            else
            {
                THR(ShowPropertyDialog(pDocument, 0, NULL));
            }
            hr = S_OK;

        }

        break;
#endif // NO_HTML_DIALOG

    case IDM_MENUEXT_COUNT:
        if(!pvarargOut)
        {
            hr = E_INVALIDARG;
        }
        else if(!_pOptionSettings)
        {
            hr = OLECMDERR_E_DISABLED;
        }
        else
        {
            hr = S_OK;
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = _pOptionSettings->aryContextMenuExts.Size();
        }
        break;

    case IDM_RESPECTVISIBILITY_INDESIGN:
        {
            CMarkup* pMarkup = pContextDoc->Markup() ;
            Assert (pMarkup);

            if ( pvarargIn && pvarargIn->vt == VT_BOOL )
            {
                pMarkup->SetRespectVisibilityInDesign( ENSURE_BOOL(pvarargIn->bVal));
            }
            else
            {
                pMarkup->SetRespectVisibilityInDesign( ! pMarkup->IsRespectVisibilityInDesign());
            }

            if (pMarkup != PrimaryMarkup())
            {
                pMarkup->ForceRelayout();
            }
            else
            {
                ForceRelayout();
            }
        }
        break;

    case IDM_UNDO:
        hr = THR(EditUndo());
        break;

    case IDM_REDO:
        hr = THR(EditRedo());
        break;

    case IDM_SHDV_CANDOCOLORSCHANGE:
        {
            hr = S_OK;
            break;
        }

    case IDM_SHDV_CANSUPPORTPICS:
        if (!pvarargIn || (pvarargIn->vt != VT_UNKNOWN))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            SetPicsCommandTarget((IOleCommandTarget *)pvarargIn->punkVal);
            hr = S_OK;
        }
        break;

    case IDM_SHDV_ISDRAGSOURCE:
        if (!pvarargOut)
        {
            Assert(pvarargOut);
            hr = E_INVALIDARG;
        }
        else
        {
            pvarargOut->vt = VT_I4;
            V_I4(pvarargOut) = _fIsDragDropSrc;
            hr = S_OK;
        }
        break;

    case IDM_SHDV_WINDOWOPEN:
        _fNewWindowInit = TRUE;
        break;

#if !defined(WIN16) && !defined(WINCE) && !defined(NO_SCRIPT_DEBUGGER)
    case IDM_TOOLBARS:
    case IDM_STATUSBAR:
    case IDM_OPTIONS:
    case IDM_CREATESHORTCUT:
        {
        DWORD        CmdOptions;
        VARIANTARG * pVarIn;
        VARIANTARG   var;

        VariantInit(&var);                  // keep compiler happy

        nCommandID = ConvertSBCMDID(idm);
        CmdOptions = 0;
        if (idm == IDM_OPTIONS)
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = SBO_NOBROWSERPAGES;
            pVarIn   = &var;
        }
        else if (idm == IDM_CREATESHORTCUT)
        {
            CDocument *pDocument;
            GetExecDocument(&pDocument, _pMenuObject, pContextDoc);
            if (pDocument->Markup()->IsPrimaryMarkup())
            {
                pVarIn = NULL;
            }
            else
            {
                V_VT(&var) = VT_UNKNOWN;
                hr = pDocument->QueryInterface(IID_IUnknown, (void**)&V_UNKNOWN(&var));
                if (hr)
                    goto Cleanup;
                pVarIn = &var;
            }
            CmdOptions = MSOCMDEXECOPT_PROMPTUSER;
        }
        else // IDM_TOOLBARS and IDM_STATUSBAR
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = MAKELONG(
                    (idm == IDM_TOOLBARS) ? (FCW_INTERNETBAR) : (FCW_STATUS),
                    SBSC_TOGGLE);
            pVarIn   = &var;
        }
        hr = THR(CTExec(
                _pInPlace->_pInPlaceSite,
                &CGID_Explorer,
                nCommandID,
                CmdOptions,
                pVarIn,
                0));
        if (V_VT(&var) == VT_UNKNOWN)
            ReleaseInterface(V_UNKNOWN(&var));
        }
        break;
#endif // !WIN16 && !WINCE

    case IDM_NEW:
    case IDM_OPEN:
    case IDM_SAVE:
        //  Bubble it out to the DocFrame

        switch(idm)
        {
        case IDM_NEW:
            nCommandID = OLECMDID_NEW;
            break;
        case IDM_OPEN:
            nCommandID = OLECMDID_OPEN;
            break;
        default:
            nCommandID = OLECMDID_SAVE;
            break;
        }
        hr = THR(CTExec(
            (IUnknown *)(_pInPlace ?
                (IUnknown *) _pInPlace->_pInPlaceSite : (IUnknown *) _pClientSite),
            NULL, nCommandID, 0, 0, 0));
        break;

#if DBG==1
    case IDM_DEBUG_SAVEHTML:
        idm = IDM_SAVEAS;
    // FALL THROUGH
#endif
    case IDM_SAVEAS:
        {
            // if _pElemCurrent is IFrame or Frame or Viewlinked weboc, Send saveas command it,
            if ( _pElemCurrent->Tag() == ETAG_IFRAME ||
                 _pElemCurrent->Tag() == ETAG_FRAME  ||
                 (   _pElemCurrent->Tag() == ETAG_OBJECT 
                  && (DYNCAST(CObjectElement,_pElemCurrent)->_fViewLinkedWebOC)) )
            {
                hr = THR_NOTRACE(_pElemCurrent->Exec(
                        pguidCmdGroup,
                        nCmdID,
                        nCmdexecopt,
                        pvarargIn,
                        pvarargOut));
            }

            // If frame does not handle the command or _pElemCurrent is not a frame
            // Save current document
            if (hr == OLECMDERR_E_NOTSUPPORTED)
            {
                // Pass it up to the host
                // If we don't have a _pHostUICommandHandler, then hr will remain OLECMDERR_E_NOTSUPPORTED
                if (    _pHostUICommandHandler
                && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
                )
                {
                    hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                }

                // Only do it ourselves if the host doesn't understand the CGID or the CMDid
                //
                if (FAILED(hr))
                {
                    TCHAR * pchPathName = NULL;
                    BOOL fShowUI = TRUE;

                    if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
                    {
                        pchPathName = V_BSTR(pvarargIn);
                    }

                    if (nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
                    {
                        MSOCMD msocmd;

                        msocmd.cmdf  = 0;
                        msocmd.cmdID = OLECMDID_ALLOWUILESSSAVEAS;
                        if (!THR(CTQueryStatus(_pInPlace->_pInPlaceSite, NULL, 1, &msocmd, NULL)))
                            fShowUI = !(msocmd.cmdf == MSOCMDSTATE_UP);
                    }

                    if (!fShowUI && !pchPathName)
                        hr = E_INVALIDARG;
                    else
                        hr = PromptSave(pContextDoc->Markup(), TRUE, fShowUI, pchPathName);
                }
            }

            if ( hr == S_FALSE )
            {
                hr = OLECMDERR_E_CANCELED;
            }
        }
        break;

    case IDM_SAVEASTHICKET:
        {
            if (!pvarargIn)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                CVariant cvarDocument;

                hr = THR(cvarDocument.CoerceVariantArg(pvarargIn, VT_UNKNOWN));
                if (SUCCEEDED(hr))
                {
                    hr = THR(SaveSnapshotHelper( V_UNKNOWN(&cvarDocument), true ));
                }
            }
        }
        break;

#ifndef NO_PRINT
    case IDM_PAGESETUP:

        // If we have a HostUICommandHandler, and the caller did NOT request no-UI, pass it up to the host
        // If we don't have a _pHostUICommandHandler, then hr will remain OLECMDERR_E_NOTSUPPORTED
        if (_pHostUICommandHandler
            && !(nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
            && !_fOutlook98
            )
        {
            hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
        }

        // Only do it ourselves if the host doesn't understand the CGID or the CMDid
        //
        if (FAILED(hr))
        {
            // if they didn't handle it, use our backup (default)
            EnsureBackupUIHandler();
            if (_pBackupHostUIHandler)
            {
                IOleCommandTarget * pBackupHostUICommandHandler;
                VARIANT             varArgIn;
                CVariant            cvarEmpty;

                hr = _pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                                           (void **) &pBackupHostUICommandHandler);
                if (hr)
                    goto Cleanup;

                V_VT(&varArgIn) = VT_UNKNOWN;
                V_UNKNOWN(&varArgIn) = SetPrintCommandParameters(
                                GetHWND(),              // parentHWND
                                NULL, NULL, NULL, 0, 0, NULL, NULL, NULL,
                                this,
                                &cvarEmpty, _hDevNames, _hDevMode,
                                NULL, NULL, NULL,
                                PRINTTYPE_PAGESETUP);

                hr = pBackupHostUICommandHandler->Exec(
                            &CGID_DocHostCommandHandler,
                            IDM_TEMPLATE_PAGESETUP,
                            nCmdexecopt,
                            &varArgIn,
                            pvarargOut);

                VariantClear(&varArgIn);
                ReleaseInterface(pBackupHostUICommandHandler);

            }
            if ( hr == S_FALSE )
            {
                hr = OLECMDERR_E_CANCELED;
            }
        }
        break;

    case IDM_PRINTPREVIEW:
        // don't allow a recursive mess...
        if (!IsPrintDialog())
        {
            // Now set all the data for the delegation call
            //      if the varargin is a bstr, interpret it as a template name
            //      if the varargin is an array, use back-compat logic
            //----------------------------------------------------------------
            hr = PrintHandler(pContextDoc,
                              ((pvarargIn && V_VT(pvarargIn)==VT_BSTR) ?
                                (LPCTSTR)V_BSTR(pvarargIn) : NULL),
                               NULL,
                               0,
                               NULL,
                               nCmdexecopt,
                               pvarargIn,
                               pvarargOut,
                               TRUE);   //preview
            if (hr)
                goto Cleanup;

        }
        break;

    case IDM_SHOWPAGESETUP:
        hr = DelegateShowPrintingDialog(pvarargIn, FALSE);
        goto Cleanup;   // Preserve the hr... may be E_NOTIMPL, S_FALSE, &c...
        break;

    case IDM_SHOWPRINT:
        hr = DelegateShowPrintingDialog(pvarargIn, TRUE);
        goto Cleanup;   // Preserve the hr... may be E_NOTIMPL, S_FALSE, &c...
        break;

    case IDM_GETPRINTTEMPLATE:
        hr = S_OK;

        if (pvarargOut)
        {
            Assert(pContextDoc->Markup());
            V_VT(pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = pContextDoc->Markup()->IsPrintTemplate() ? VB_TRUE : VB_FALSE;
        }
        else
        {
            hr = E_POINTER;
        }
        break;

    case IDM_SETPRINTTEMPLATE:
        if (!pvarargIn || pvarargIn->vt != VT_BOOL)
        {
            hr = E_INVALIDARG;
            break;
        }

        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);

            pMarkup->SetPrintTemplate(ENSURE_BOOL(pvarargIn->bVal));
            pMarkup->SetPrintTemplateExplicit(TRUE);
        }

        hr = S_OK;
        break;

    case IDM_FIRE_PRINTTEMPLATEDOWN:
        // AppHack (greglett) (108234)
        // NT5 HtmlHelp does something in the onafterprint event which results in a ProgressChange.
        // They then use this ProgressChange to do something that may result in a print.
        // Thus, multiple print dialogs appear until they crash.
        // This hack delays the onafterprint event for HtmlHelp until the template is closing.
        if (g_fInHtmlHelp)
        {
            // This really should do *all* nested markups, but this is a hack, right?
            _fPrintEvent = TRUE;
            PrimaryMarkup()->Window()->Fire_onafterprint();
            _fPrintEvent = FALSE;
        }

    case IDM_FIRE_PRINTTEMPLATEUP:
        if (_pTridentSvc && pvarargIn && V_VT(pvarargIn) == VT_UNKNOWN && V_UNKNOWN(pvarargIn))
        {
            IHTMLWindow2 * pHtmlWindow = NULL;
            hr = V_UNKNOWN(pvarargIn)->QueryInterface(IID_IHTMLWindow2, (void**)&pHtmlWindow);
            if (hr == S_OK)
            {
                ITridentService2 * pTridentSvc2 = NULL;

                hr = _pTridentSvc->QueryInterface(IID_ITridentService2, (void**)&pTridentSvc2);
                if (hr == S_OK)
                {

                    pTridentSvc2->FirePrintTemplateEvent(pHtmlWindow,
                                                         idm == IDM_FIRE_PRINTTEMPLATEUP
                                                            ?  DISPID_PRINTTEMPLATEINSTANTIATION
                                                            :  DISPID_PRINTTEMPLATETEARDOWN);
                    pTridentSvc2->Release();
                }
                pHtmlWindow->Release();
            }

            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;

    case IDM_SETPRINTHANDLES:
        // Safety check SAFEARRAY arguments...
        if (    pvarargIn
            &&  (V_VT(pvarargIn) == (VT_ARRAY | VT_HANDLE))
            &&  V_ARRAY(pvarargIn) )
        {
#if DBG==1
            Assert( SafeArrayGetDim(V_ARRAY(pvarargIn)) == 1
                &&  V_ARRAY(pvarargIn)->rgsabound[0].cElements == 2
                &&  V_ARRAY(pvarargIn)->rgsabound[0].lLbound == 0  );
#endif
            long lArg = 0;
            HGLOBAL hDN = NULL;
            HGLOBAL hDM = NULL;

            if (    SafeArrayGetElement(V_ARRAY(pvarargIn), &lArg, &hDN) == S_OK
                &&  SafeArrayGetElement(V_ARRAY(pvarargIn), &(++lArg), &hDM) == S_OK)
            {
                ReplacePrintHandles(hDN,hDM);
            }

            hr = S_OK;
        }
        else
            hr = E_INVALIDARG;
        break;

    case IDM_EXECPRINT :  // comes from script ExecCommand
    case IDM_PRINT:       // comes from IOleCommandTarget
        if (!IsPrintDialog())
        {
            DWORD dwPrintFlags = 0;
            BOOL  fOutlook98 = _fOutlook98;

            //
            // if no-UI is requested from execCommand, then we better be a trusted Dialog, or an
            // HTA (which also use this bit); default handling of print templates uses trusted dialogs
            // window.print doesn't make this request
            //
            if (nCmdID == IDM_EXECPRINT && !_fInTrustedHTMLDlg)
            {
                nCmdexecopt &= ~OLECMDEXECOPT_DONTPROMPTUSER;

                if (pvarargIn && (V_VT(pvarargIn) == VT_I2))
                    V_I2(pvarargIn) &= ~PRINT_DONTBOTHERUSER;
            }
           
            //
            // Set up the printing flags
            //
            if (pvarargIn && V_VT(pvarargIn) == VT_I2)
                dwPrintFlags |= V_I2(pvarargIn);            
            if (nCmdexecopt & OLECMDEXECOPT_DONTPROMPTUSER)
                dwPrintFlags |= PRINT_DONTBOTHERUSER;

            // NB: 68038 - _fOutlook98 is not set when we are printing the Outlook98 Today page.
            // So we use the "outday://" url to identify that we are in Outlook.  Even if somebody
            // else invents an "outday" protocol, they would still not run into this since no address
            // is specified after "outday://".
            if (!_fOutlook98)
            {
                const TCHAR * pchUrl = GetPrimaryUrl();

                if (pchUrl && *pchUrl && !_tcscmp(pchUrl, _T("outday://")))
                    _fOutlook98 = TRUE;
            }

            // Now set all the data for the delegation call
            //      if the varargin is a bstr, interpret it as a template name
            //      if the varargin is an I2, treat as flags (above)
            //      if the varargin is an array, use back-compat logic
            // Note that a BSTR and/or an array can contain a custom print template,
            // and should *NOT* be accessible from script.
            //----------------------------------------------------------------
            hr = PrintHandler( pContextDoc,
                               (idm == IDM_PRINT && pvarargIn && V_VT(pvarargIn)==VT_BSTR)                               
                                ? (LPCTSTR)V_BSTR(pvarargIn)
                                : NULL,
                               NULL,
                               dwPrintFlags,
                               (idm == IDM_PRINT && pvarargIn && V_ISARRAY(pvarargIn) && V_ISBYREF(pvarargIn))
                                     ? V_ARRAY(pvarargIn)
                                     : NULL,
                               nCmdexecopt, pvarargIn, pvarargOut,
                                FALSE
                               );
            if (hr)
                goto Cleanup;

            _fOutlook98 = fOutlook98;

            if ( hr == S_FALSE )
                hr = OLECMDERR_E_CANCELED;
        }

        break;

    case IDM_GETIPRINT:
        if (!pvarargOut || !pvarargIn)
            hr = E_POINTER;
        else if (V_VT(pvarargIn) != VT_I4)
            hr = E_INVALIDARG;
        else
        {
            CIPrintCollection * pipcData = NULL;
            long                nLen;

            hr = E_FAIL;
            V_VT(pvarargOut) = VT_NULL;
            Assert(pContextDoc);

            pipcData = new CIPrintCollection;
            if (!pipcData)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            switch (V_I4(pvarargIn))
            {
            case IPRINT_DOCUMENT:
                {
                    CWindow *pWindow = pContextDoc->Window();
                    if (    pWindow
                        &&  pWindow->_punkViewLinkedWebOC)
                    {
                        IDispatch   *pIDispDoc  = NULL;
                        IPrint      *pIPrint    = NULL;

                        if (GetWebOCDocument(pWindow->_punkViewLinkedWebOC, &pIDispDoc) == S_OK)
                        {
                            Assert(pIDispDoc);
                            pIDispDoc->QueryInterface(IID_IPrint, (void **) &pIPrint);
                        }

                        if (pIPrint)
                        {
                            pipcData->AddIPrint(pIPrint);
                        }

                        ReleaseInterface(pIDispDoc);
                        ReleaseInterface(pIPrint);
                    }
                }
                break;
            case IPRINT_ACTIVEFRAME:
                if (_pElemCurrent)
                {
                    CElement *pElemRoot = _pElemCurrent->GetMarkup()->Root();
                    if (pElemRoot->HasMasterPtr())
                    {
                        CElement *pFrame;

                        pFrame = pElemRoot->GetMasterPtr();
                        if (    pFrame->Tag() == ETAG_FRAME
                            ||  pFrame->Tag() == ETAG_IFRAME )
                        {
                            IPrint *pIPrint = NULL;
                            if (!DYNCAST(CFrameSite, pFrame)->GetIPrintObject(&pIPrint))
                            {
                                pipcData->AddIPrint(pIPrint);
                            }
                            ReleaseInterface(pIPrint);
                        }
                    }
                }
                break;
            case IPRINT_ALLFRAMES:
                {
                    CElement    *pElement   = NULL;
                    CMarkup     *pMarkup    = pContextDoc->Markup();

                    Assert(pMarkup);
                    if (pMarkup)
                    {
                        pElement = pMarkup->GetElementClient();
                        Assert(pElement);
                        if (pElement)
                        {
                            // NB: (greglett) Since this notification only collects CFrameElements and not IFrames, we only need
                            // to fire the notification if we have a frameset.
                            if (pElement->Tag() == ETAG_FRAMESET)
                            {
                                CNotification nf;
                                Assert(pElement->GetFirstBranch());

                                // Collect all IPrint objects from frames that consist of only IPrint objects.
                                nf.Initialize(NTYPE_COLLECT_IPRINT, pElement, pElement->GetFirstBranch(), pipcData, 0);

                                pMarkup->Notify(&nf);
                            }
                        }
                    }
                }
                break;
            }

            if (    !pipcData->get_length(&nLen)
                &&  nLen > 0)
            {
                pipcData->AddRef();
                V_VT(pvarargOut) = VT_UNKNOWN;
                V_UNKNOWN(pvarargOut) = pipcData;
            }

            pipcData->Release();

            hr = S_OK;
        }
        break;

    case IDM_UPDATEPAGESTATUS:
        if (    !pvarargIn
            ||  V_VT(pvarargIn) != VT_I4)
            hr = E_INVALIDARG;
        else
        {          
            if (_pClientSite)
            {
                IOleCommandTarget *pCommandTarget = NULL;

                hr = _pClientSite->QueryInterface(IID_IOleCommandTarget, (void**)&pCommandTarget);
                if  (!hr &&  pCommandTarget)
                {
                    // Pass it on to the host.
                    hr = pCommandTarget->Exec(&CGID_DocHostCommandHandler,
                                               OLECMDID_UPDATEPAGESTATUS,
                                               0,
                                               pvarargIn,
                                               0);
                }
                ReleaseInterface(pCommandTarget);
            }
            else
                hr = S_OK;

            // pagestatus indicates that we have finished and that the template is about to be closed
            if (V_I4(pvarargIn) == 0)
            {
                _cSpoolingPrintJobs--;

                if (   !_cSpoolingPrintJobs
                    && _fCloseOnPrintCompletion
                    && pContextDoc
                    && pContextDoc->Window())
                {
                    _fCloseOnPrintCompletion = FALSE;
                    pContextDoc->Window()->close();
                }
            }
        }
        break;

#endif // NO_PRINT


    case IDM_HELP_CONTENT:
        break;

#ifndef WIN16
    case IDM_HELP_ABOUT:

        ShowMessage(
                &result,
                MB_APPLMODAL | MB_OK,
                0,
                IDS_HELPABOUT_STRING,
                VER_PRODUCTVERSION,
#if DBG==1
                _T("\r\n"), g_achDLLCore
#else
                _T(""), _T("")
#endif
                );

        hr = S_OK;
        break;
#endif // !WIN16

#ifndef NO_EDIT
    case IDM_BROWSEMODE:
        hr = THR_NOTRACE(SetDesignMode(pContextDoc, htmlDesignModeOff));
        break;

    case IDM_EDITMODE:
        hr = THR_NOTRACE(SetDesignMode(pContextDoc, htmlDesignModeOn));
        break;
#endif // NO_EDIT

#ifndef NO_SCRIPT_DEBUGGER
    case IDM_BREAKATNEXT:
        if (g_pDebugApp)
            hr = THR(g_pDebugApp->CauseBreak());
        else
            hr = E_UNEXPECTED;
        break;

    case IDM_LAUNCHDEBUGGER:
        {
            CScriptCollection * pScriptCollection = PrimaryMarkup()->GetScriptCollection();

            if (pScriptCollection)
            {
                hr = THR(pScriptCollection->ViewSourceInDebugger());
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        break;
#endif // NO_SCRIPT_DEBUGGER

#ifndef WINCE

    case IDM_VIEWSOURCE:
    case IDM_VIEWPRETRANSFORMSOURCE:
        {
            CMarkup * pMarkup = NULL;

            // Determine the markup to execute the command on
            pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();
            if (pMarkup)
            {
                pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);
            }

            // Do nothing for non-HTML files
            if (!pMarkup || pMarkup->IsImageFile())
            {
                hr = S_OK;
                break;
            }

            // this is all because the @#$&*% shell team refuses to fix the fact that IDM_VIEWSOURCE
            // is not overridable by the aggregator via IOleCommandTarget. So the XML Mime viewer has to
            // go inside out and send VIEWPRETRANSFORMSOURCE.
            if (    idm == IDM_VIEWSOURCE
                &&  pMarkup->IsPrimaryMarkup()
                &&  IsAggregatedByXMLMime()
               )
            {
                IOleCommandTarget *pIOCT = NULL;
                HRESULT hr = THR(PunkOuter()->QueryInterface(IID_IOleCommandTarget, (void **)&pIOCT));
                if (hr)
                    break;
                if (!pIOCT) {
                    hr = E_POINTER;
                    break;
                }
                hr = THR(pIOCT->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
                ReleaseInterface(pIOCT);
                break;
            }


#ifndef UNIX
            // TODO (MohanB) Do we still need this. Noone sets _fFramesetInBody!

            // If there's a frameset in the body, launch the
            // analyzer dialog.
            if (pMarkup->IsPrimaryMarkup() && _fFramesetInBody)
            {
                COptionsHolder *    pcoh            = NULL;
                IDispatch      *    pDispOptions    = NULL;
                TCHAR               achAnalyzeDlg[] = _T("analyze.dlg");

                pcoh = new COptionsHolder(_pWindowPrimary->Window());
                if (!pcoh)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup_ViewSource;
                }

                // get dispatch from stack variable
                hr = THR_NOTRACE(pcoh->QueryInterface(IID_IHTMLOptionsHolder,
                                     (void**)&pDispOptions));
                if (hr)
                    goto Cleanup_ViewSource;

                hr = THR(ShowModalDialogHelper(
                    PrimaryMarkup(),
                    achAnalyzeDlg,
                    pDispOptions, pcoh));
                if (hr)
                    goto Cleanup_ViewSource;

Cleanup_ViewSource:
                // release dispatch, et al.
                ReleaseInterface(pcoh);
                ReleaseInterface(pDispOptions);

            }
#endif

            {
                TCHAR   tszPath[MAX_PATH] = _T("\"");

                hr = THR(GetViewSourceFileName(&tszPath[1], pMarkup));

                if (hr)
                    break;

                StrCat(tszPath, _T("\""));

                InvokeEditor(tszPath);
            }
        }
        break;
#endif // WINCE

#ifndef WIN16
    case IDM_HELP_README:
        HKEY  hkey;
        LONG  lr, lLength;

        lr = RegOpenKey(
                HKEY_CLASSES_ROOT,
                TEXT("CLSID\\{25336920-03F9-11CF-8FD0-00AA00686F13}"),
                &hkey);

        if (lr == ERROR_SUCCESS)
        {
            TCHAR   szPathW[MAX_PATH];

            lLength = sizeof(szPathW);
            lr = RegQueryValue(
                    hkey,
                    TEXT("InprocServer32"),
                    szPathW,
                    &lLength);
            RegCloseKey(hkey);
            if (lr == ERROR_SUCCESS)
            {
                // Right now szPath contains the full path of fm30pad.exe
                // need to replace fm30pad.exe with m3readme.htm
                //
                TCHAR *pch;

                pch = _tcsrchr(szPathW, _T('\\'));
                if (pch)
                    *pch = 0;
                // TODO hardcoded filename string?  -Tomsn
                _tcscat(szPathW, _T("\\readme.htm"));

                // test whether m3readme.htm exists.
                //
                HANDLE hFileReadme;

                hFileReadme = CreateFile(
                        szPathW,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                if (hFileReadme != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hFileReadme);
                    hr = THR(FollowHyperlink(szPathW));
                    if (!hr)
                        break;
                }
            }
        }
        break;
#endif // ndef WIN16

    case IDM_STOP:
        {
            CMarkup * pMarkup = pContextDoc->Markup();

            if (    pMarkup->HasWindow()
                &&  pMarkup->Window()->Window()->_pMarkupPending)
            {
                pMarkup->Window()->Window()->ReleaseMarkupPending(pMarkup->Window()->Window()->_pMarkupPending);
                hr = S_OK;
            }
            else if (   pvarargIn
                    &&  (VT_BOOL      == V_VT(pvarargIn))
                    &&  (VARIANT_TRUE == V_BOOL(pvarargIn)))
            {
                // Hard Stop
                //
                hr = THR(pMarkup->ExecStop(TRUE, FALSE));
            }
            else
            {
                // Soft Stop
                //
                hr = THR(pMarkup->ExecStop());
            }
        }
        break;

    case IDM_ENABLE_INTERACTION:
        if (!pvarargIn || (pvarargIn->vt != VT_I4))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            BOOL fEnableInteraction = pvarargIn->lVal;

            if (!!_fEnableInteraction != !!fEnableInteraction)
            {
                CNotification   nf;

                _fEnableInteraction = fEnableInteraction;
                if ( _pUpdateIntSink )
                    // don't bother drawing accumulated inval rgn if minimized
                    _pUpdateIntSink->_pTimer->Freeze( !fEnableInteraction );

                if (_fBroadcastInteraction)
                {
                    BOOL dirtyBefore = !!_lDirtyVersion;
                    nf.EnableInteraction1(PrimaryRoot());
                    BroadcastNotify(&nf);
                    //
                    // TODO ( marka ) - reset erroneous dirtying the document.
                    //
                    if ( ( ! dirtyBefore ) && ( _lDirtyVersion ) )
                        _lDirtyVersion = 0;
                }

                if (TLS(pImgAnim))
                    TLS(pImgAnim)->SetAnimState(
                        (DWORD_PTR) this,
                        fEnableInteraction ? ANIMSTATE_PLAY : ANIMSTATE_PAUSE);
            }
            hr = S_OK;
        }
        break;

    case IDM_ONPERSISTSHORTCUT:
        {
            INamedPropertyBag  *    pINPB = NULL;
            FAVORITES_NOTIFY_INFO   sni;
            CNotification           nf;

            // first put my information into the defualt structure
            // if this is the first call (top level document) then we want to
            // set the base url. for normal pages we are nearly done.  For
            // frameset pages, we need to compare domains for security purposes
            // and establish subdomains if necessary
            if (!pvarargIn ||
                (pvarargIn->vt != VT_UNKNOWN) ||
                !V_UNKNOWN(pvarargIn) )
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = THR_NOTRACE(V_UNKNOWN(pvarargIn)->QueryInterface(IID_INamedPropertyBag,
                                                                  (void **)&pINPB));
            if (hr)
                break;

            hr = THR(PersistFavoritesData(pContextDoc->Markup(), pINPB, (LPCWSTR)_T("DEFAULT")));
            if (hr)
            {
                ReleaseInterface((IUnknown*) pINPB);
                break;
            }

            // initialize the info strucuture
            sni.pINPB = pINPB;
            sni.bstrNameDomain = SysAllocString(_T("DOC"));
            if (sni.bstrNameDomain == NULL)
            {
                ReleaseInterface((IUnknown*) pINPB);
                hr = E_OUTOFMEMORY;
                break;
            }

            // then propogate the event to my children
            nf.FavoritesSave(pContextDoc->Markup()->Root(), &sni);
            BroadcastNotify(&nf);

            ClearInterface(&sni.pINPB);
            SysFreeString(sni.bstrNameDomain);
        }
        break;

    case IDM_REFRESH:
    case IDM_REFRESH_TOP:
    case IDM_REFRESH_TOP_FULL:
    case IDM_REFRESH_THIS:
    case IDM_REFRESH_THIS_FULL:
    {
        LONG lOleCmdidf;

        //
        // Give the container a chance to handle the refresh.
        //

        if (_pHostUICommandHandler)
        {
            hr = THR_NOTRACE(_pHostUICommandHandler->Exec(&CGID_DocHostCommandHandler, idm, nCmdexecopt, pvarargIn, pvarargOut));
        }

        if (FAILED(hr))
        {
            COmWindowProxy * pOmWindowProxy = NULL;

            if (idm != IDM_REFRESH_TOP && idm != IDM_REFRESH_TOP_FULL)
            {
                // Get the markup of the nearest frame, if any. Otherwise use the primary markup.

                Assert(pContextDoc);

                CMarkup * pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();

                if (pMarkup)
                {
                    pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);
                }
                if (pMarkup)
                {
                    pOmWindowProxy = pMarkup->Window();
                }
            }
            if (!pOmWindowProxy)
            {
                pOmWindowProxy = _pWindowPrimary;
            }

            if (idm == IDM_REFRESH)
            {
                if (pvarargIn && pvarargIn->vt == VT_I4)
                    lOleCmdidf = pvarargIn->lVal;
                else
                    lOleCmdidf = OLECMDIDF_REFRESH_NORMAL;
            }
            else if (idm == IDM_REFRESH_TOP_FULL || idm == IDM_REFRESH_THIS_FULL)
            {
                lOleCmdidf = OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
            }
            else
            {
                lOleCmdidf = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
            }

            hr = GWPostMethodCall(pOmWindowProxy,
                                  ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                  lOleCmdidf, FALSE, "COmWindowProxy::ExecRefreshCallback");
        }

        break;
    }

    case IDM_CONTEXTMENU:
        {
            CMessage Message(
                    InPlace()->_hwnd,
                    WM_CONTEXTMENU,
                    (WPARAM) InPlace()->_hwnd,
                    MAKELPARAM(0xFFFF, 0xFFFF));
            hr = THR( Message.SetNodeHit(_pElemCurrent->GetFirstBranch()) );
            if( hr )
                goto Cleanup;
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
        }
        break;

    case IDM_GOBACKWARD:
    case IDM_GOFORWARD:
        if (_fDefView)
        {
            // 92970 -- Let ShDocVw handle web view navigations
            hr = FollowHistory(idm==IDM_GOFORWARD);
        }
        else
        {
            hr = Travel((idm == IDM_GOBACKWARD) ? -1 : 1);
        }
        break;

    case IDM_SHDV_SETPENDINGURL:
        if (!pvarargIn || (pvarargIn->vt != VT_BSTR) || (pvarargIn->bstrVal == NULL))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            hr = SetUrl(pContextDoc->Markup(), pvarargIn->bstrVal);
        }
        break;

#ifdef DEADCODE // The command makes sense, but this is a wrong way to apply zoom to a document
                // We don't support body zoom in IE 5.5, so let's disable it until it is used.
    case IDM_ZOOMPERCENT:
        if (pvarargIn && (VT_I4 == V_VT(pvarargIn)))
        {
            int iZoomPercent = V_I4(pvarargIn);

            GetView()->SetZoomPercent(iZoomPercent);

            hr = S_OK;
        }
        break;
#endif

    // JuliaC -- This is hack for InfoViewer's "Font Size" toolbar button
    // For details, please see bug 45627
    case IDM_INFOVIEW_ZOOM:

        if (pvarargIn && (VT_I4 == V_VT(pvarargIn)))
        {
            int iZoom;

            iZoom = V_I4(pvarargIn);

            if (iZoom < (long) BASELINEFONTMIN || iZoom > (long) BASELINEFONTMAX)
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = ExecHelper(pContextDoc,
                    (GUID *)&CGID_MSHTML,
                    iZoom + IDM_BASELINEFONT1,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    NULL);
            if (hr)
                break;
        }

        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = (long) _sBaselineFont;
        }

        hr = S_OK;
        break;

    case IDM_INFOVIEW_GETZOOMRANGE:

        V_VT(pvarargOut) = VT_I4;
        V_I4(pvarargOut) = MAKELONG((SHORT)BASELINEFONTMIN, (SHORT)BASELINEFONTMAX);

        hr = S_OK;
        break;
    // End of hack for InfoViewer's "Font Size" toolbar button

    case IDM_BASELINEFONT1:
    case IDM_BASELINEFONT2:
    case IDM_BASELINEFONT3:
    case IDM_BASELINEFONT4:
    case IDM_BASELINEFONT5:
    {
        CODEPAGESETTINGS * pCodepageSettings = _pElemCurrent->GetWindowedMarkupContext()->GetCodepageSettings();
#if 0
        BOOL f12   = !!(GetKeyState(VK_F12)     & 0x8000);
        BOOL fCtrl = !!(GetKeyState(VK_CONTROL) & 0x8000);
        extern BOOL g_fUseHR;
        
        if (!(f12 && fCtrl && g_fUseHR && g_fInExplorer))
#endif
        {
            //
            // depend on that IDM_BASELINEFONT1, IDM_BASELINEFONT2,
            // IDM_BASELINEFONT3, IDM_BASELINEFONT4, IDM_BASELINEFONT5 to be
            // consecutive integers.
            //
            if (_sBaselineFont != (short)(idm - IDM_BASELINEFONT1 + BASELINEFONTMIN))
            {
                // {keyroot}\International\Scripts\{script-id}\IEFontSize

                static TCHAR * s_szScripts = TEXT("\\Scripts");
                const TCHAR * szSubKey = _pOptionSettings->fUseCodePageBasedFontLinking
                                         ? L""
                                         : s_szScripts;

                DWORD dwFontSize = (idm - IDM_BASELINEFONT1 + BASELINEFONTMIN);
                TCHAR *pchPath, *pch;
                int cch0 = _tcslen(_pOptionSettings->achKeyPath);
                int cch1 = _tcslen(s_szPathInternational);
                int cch2 = _tcslen(szSubKey);

                pchPath = pch = new TCHAR[cch0 + cch1 + cch2 + 1 + 10 + 1];

                if (pchPath)
                {
                    ULONG ulArg = _pOptionSettings->fUseCodePageBasedFontLinking
                                  ? ULONG(pCodepageSettings->uiFamilyCodePage)
                                  : ULONG(RegistryAppropriateSidFromSid(DefaultSidForCodePage(pCodepageSettings->uiFamilyCodePage)));

                    StrCpy( pch, _pOptionSettings->achKeyPath );
                    pch += cch0;
                    StrCpy( pch, s_szPathInternational );
                    pch += cch1;
                    StrCpy( pch, szSubKey );
                    pch += cch2;
                    *pch++ = _T('\\');
                    _ultot(ulArg, pch, 10);

                    IGNORE_HR( SHSetValue(HKEY_CURRENT_USER, pchPath, TEXT("IEFontSize"),
                                          REG_BINARY, (void *)&dwFontSize, sizeof(dwFontSize)) );

                    delete [] pchPath;
                }
            }

            _sBaselineFont = pCodepageSettings->sBaselineFontDefault =
                        (short)(idm - IDM_BASELINEFONT1 + BASELINEFONTMIN);

#ifdef UNIX
            g_SelectedFontSize = _sBaselineFont; // save the selected font size for new CDoc.
#endif
        }
#if 0
        {
            static LONG g_res[] = {65, 72, 96, 133, 150};
            g_uiDisplay.SetResolution(g_res[idm - IDM_BASELINEFONT1], g_res[idm - IDM_BASELINEFONT1]);
            
            _sBaselineFont = pCodepageSettings->sBaselineFontDefault =
                (short)(IDM_BASELINEFONT3 - IDM_BASELINEFONT1 + BASELINEFONTMIN);
        }
#endif        

        _pElemCurrent->GetMarkup()->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
        ForceRelayout();

        {   // update font history version number
            THREADSTATE * pts = GetThreadState();
            pts->_iFontHistoryVersion++;
        }

        // Send this command to our children
        {
            COnCommandExecParams cmdExecParams;
            cmdExecParams.pguidCmdGroup = pguidCmdGroup;
            cmdExecParams.nCmdID        = nCmdID;
            CNotification   nf;

            nf.Command(PrimaryRoot(), &cmdExecParams);
            BroadcastNotify(&nf);
        }

        //
        // tell shell to apply this exec to applicable explorer bars
        //
        IGNORE_HR(CTExec(
                _pInPlace ?
                (IUnknown *) _pInPlace->_pInPlaceSite : (IUnknown *) _pClientSite,
                &CGID_ExplorerBarDoc, nCmdID, 0, 0, 0));

        hr             = S_OK;
        break;
    }
    
    // Complex Text for setting default document reading order
    case IDM_DIRLTR:
    case IDM_DIRRTL:
    {
        //
        // TODO: In the future, we should move these two commands
        // into editor code. [zhenbinx]
        //
        CDocument * pDocument;
        CParentUndoUnit *pCPUU = NULL;

        pCPUU = OpenParentUnit(this, IDS_UNDOGENERICTEXT);
        hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
        if (SUCCEEDED(hr))
        {
            hr = pDocument->SetDocDirection((IDM_DIRLTR == idm) ? htmlDirLeftToRight : htmlDirRightToLeft);
        }
        IGNORE_HR( CloseParentUnit(pCPUU, hr) );
        break;
    }

    case IDM_SHDV_MIMECSETMENUOPEN:
    // this case is probably dead code -- jeffwall 04/05/00
        if (pvarargIn)
        {
            int nIdm;
            CODEPAGE cp = PrimaryMarkup()->GetCodePage();
            BOOL fDocRTL = FALSE;           // keep compiler happy
            Assert(pvarargIn->vt == VT_I4);

            CDocument * pDocument;

            hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
            if (SUCCEEDED(hr))
            {
                hr = THR(pDocument->GetDocDirection(&fDocRTL));
            }
            if (hr == S_OK)
            {
                hr = THR(ShowMimeCSetMenu(_pOptionSettings, &nIdm, cp,
                                           pvarargIn->lVal,
                                           fDocRTL, IsCpAutoDetect()));

                if (hr == S_OK)
                {
                    if (nIdm >= IDM_MIMECSET__FIRST__ && nIdm <= IDM_MIMECSET__LAST__)
                    {
                        idm = nIdm;     // handled below
                    }
                    else if (nIdm == IDM_DIRLTR || nIdm == IDM_DIRRTL)
                    {
                        ExecHelper(pContextDoc, (GUID *)&CGID_MSHTML, nIdm, 0, NULL, NULL);
                    }

                }
            }
        }
        break;

    case IDM_SHDV_FONTMENUOPEN:
        if (pvarargIn)
        {
            int nIdm;
            Assert(pvarargIn->vt == VT_I4);

            hr = THR(ShowFontSizeMenu(&nIdm, _sBaselineFont,
                                       pvarargIn->lVal));

            if (hr == S_OK)
            {
                if ( (nIdm >= IDM_BASELINEFONT1 && nIdm <= IDM_BASELINEFONT5) )
                {
                    ExecHelper(pContextDoc, (GUID *)&CGID_MSHTML, nIdm, 0, NULL, NULL);
                }
            }
        }
        break;

    case IDM_SHDV_GETMIMECSETMENU:
        if (pvarargOut)
        {
            BOOL fDocRTL = FALSE;           // keep compiler happy

            V_VT(pvarargOut) = VT_INT_PTR;

            CDocument * pDocument;

            hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
            if (SUCCEEDED(hr))
            {
                hr = THR(pDocument->GetDocDirection(&fDocRTL));
            }
            if (hr == S_OK)
            {
                CMarkup * pMarkup = pDocument->Markup();
                V_BYREF(pvarargOut) = GetEncodingMenu(_pOptionSettings, pMarkup->GetCodePage(), fDocRTL, IsCpAutoDetect());

                hr = V_BYREF(pvarargOut) ? S_OK: S_FALSE;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_SHDV_GETFONTMENU:
        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = HandleToLong(GetFontSizeMenu(_sBaselineFont));

            hr = V_I4(pvarargOut)? S_OK: S_FALSE;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_SHDV_GETDOCDIRMENU:
        if (pvarargOut)
        {
            BOOL fDocRTL = FALSE;               // keep compiler happy
            CDocument * pDocument;

            hr = THR(GetExecDocument(&pDocument, _pMenuObject, pContextDoc));
            if (SUCCEEDED(hr))
            {
                hr = THR(pDocument->GetDocDirection(&fDocRTL));
            }

            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = HandleToLong(GetOrAppendDocDirMenu(PrimaryMarkup()->GetCodePage(), fDocRTL));
            hr = V_I4(pvarargOut)? S_OK: OLECMDERR_E_DISABLED;
        }
        else
        {
            hr = E_INVALIDARG;
        }
         break;

    case IDM_SHDV_DOCCHARSET:
    case IDM_SHDV_DOCFAMILYCHARSET:
        // Return the family or actual charset for the doc
        if (pvarargOut)
        {
            UINT uiCodePage = idm == IDM_SHDV_DOCFAMILYCHARSET ?
                              WindowsCodePageFromCodePage(PrimaryMarkup()->GetCodePage()) :
                              PrimaryMarkup()->GetCodePage();

            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = uiCodePage;

            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
        break;

    case IDM_GETFRAMEZONE:
        if (!pvarargOut)
        {
            hr = E_POINTER;
        }
        else
        {
            if (_pWindowPrimary)
            {
                hr = THR(_pWindowPrimary->Markup()->GetFrameZone(pvarargOut));
            }

            if (hr || !_pWindowPrimary)
            {
                V_VT(pvarargOut) = VT_EMPTY;
            }
        }
        break;
        // Support for Context Menu Extensions
    case IDM_SHDV_ADDMENUEXTENSIONS:
        {
            if (   !pvarargIn  || (pvarargIn->vt  != VT_INT_PTR)
                || !pvarargOut || (pvarargOut->vt != VT_I4)
                )
            {
                Assert(pvarargIn);
                hr = E_INVALIDARG;
            }
            else
            {
                HMENU hmenu = (HMENU) V_BYREF(pvarargIn);
                int   id    = V_I4(pvarargOut);
                hr = THR(InsertMenuExt(hmenu, id));
            }
        }
        break;

    case IDM_RUNURLSCRIPT:
        // This enables us to run scripts inside urls on the
        // current document. The Variant In parameter is an URL.
        if (!pvarargIn || pvarargIn->vt != VT_BSTR)
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);

            // get dispatch for the markup's window
            //
            IDispatch * pDispWindow = (IHTMLWindow2*)(pMarkup->Window()->Window());
            Assert(pDispWindow);

            // bring up the dialog
            //
            hr = THR(ShowModalDialogHelper(
                    pMarkup,
                    pvarargIn->bstrVal,
                    pDispWindow,
                    NULL,
                    NULL,
                    HTMLDLG_NOUI | HTMLDLG_AUTOEXIT));
        }
        break;

    case IDM_HTMLEDITMODE:
        if (!pvarargIn || (pvarargIn->vt != VT_BOOL))
        {
            Assert(pvarargIn);
            hr = E_INVALIDARG;
        }
        else
        {
            GUID guidCmdGroup = CGID_MSHTML;
            _fInHTMLEditMode = !!V_BOOL(pvarargIn);

            IGNORE_HR(Exec(&guidCmdGroup, IDM_COMPOSESETTINGS, 0, pvarargIn, NULL));
            hr = S_OK;
        }
        break;

    case IDM_REGISTRYREFRESH:
        IGNORE_HR(OnSettingsChange());
        break;

    case IDM_DEFAULTBLOCK:
        if (pvarargIn)
        {
            hr = THR(SetupDefaultBlockTag(pvarargIn));
            if (S_OK == hr)
            {
                CNotification   nf;

                nf.EditModeChange(CMarkup::GetElementTopHelper(PrimaryMarkup()));
                BroadcastNotify(&nf);
            }
        }
        if (pvarargOut)
        {
            V_VT(pvarargOut) = VT_BSTR;
            if (GetDefaultBlockTag() == ETAG_DIV)
                V_BSTR(pvarargOut) = SysAllocString(_T("DIV"));
            else
                V_BSTR(pvarargOut) = SysAllocString(_T("P"));
            hr = S_OK;
        }

        break;

    case OLECMDID_ONUNLOAD:
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);
            Assert(pMarkup->Window());

            BOOL fRetval = pMarkup->Window()->Fire_onbeforeunload();

            hr = S_OK;
            if (pvarargOut)
            {
               V_VT  (pvarargOut) = VT_BOOL;
               V_BOOL(pvarargOut) = VARIANT_BOOL_FROM_BOOL(fRetval);
            }
        }
        break;

    case OLECMDID_DONTDOWNLOADCSS:
        {
            if (DesignMode())
                _fDontDownloadCSS = TRUE;
            hr = S_OK;
        }
        break;

    case IDM_GETBYTESDOWNLOADED:
        if (!pvarargOut)
        {
            hr = E_POINTER;
        }
        else
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert(pMarkup);

            CDwnDoc * pDwnDoc = pMarkup->GetDwnDoc();

            V_VT(pvarargOut) = VT_I4;
            V_I4(pvarargOut) = pDwnDoc ? pDwnDoc->GetBytesRead() : 0;
        }
        break;

    case IDM_PERSISTSTREAMSYNC:
        _fPersistStreamSync = TRUE;
        hr = S_OK;
        break;

    case IDM_OVERRIDE_CURSOR:
        {
            CMarkup* pMarkup = pContextDoc->Markup() ;
            Assert (pMarkup);
            BOOL fSet;
            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
            {
                fSet = !( CHECK_EDIT_BIT( pMarkup, _fOverrideCursor));      // If the argument value is not bool, just toggle the flag
            }
            else
            {
                fSet = ENSURE_BOOL(pvarargIn->bVal);
            }
            SET_EDIT_BIT( pMarkup,_fOverrideCursor , fSet );

            hr = S_OK;
        }
        break;

    case IDM_PEERHITTESTSAMEINEDIT:
        _fPeerHitTestSameInEdit = !_fPeerHitTestSameInEdit;
        hr = S_OK;
        break;

    case IDM_SHOWZEROBORDERATDESIGNTIME:
    case IDM_NOFIXUPURLSONPASTE:
        {
            BOOL fSet = FALSE;
            CMarkup* pMarkup = pContextDoc->Markup();
            Assert (pMarkup);

            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
            {
                fSet = !(pMarkup->IsShowZeroBorderAtDesignTime());      // If the argument value is not bool, just toggle the flag
            }
            else
            {
                fSet = ENSURE_BOOL(pvarargIn->bVal);
            }


            if (idm == IDM_SHOWZEROBORDERATDESIGNTIME)
            {
                pMarkup->SetShowZeroBorderAtDesignTime(fSet);
                CNotification nf;
                nf.ZeroGrayChange(CMarkup::GetElementTopHelper(pMarkup));
                BroadcastNotify( & nf );
                Invalidate();
            }
            else
            {
                _fNoFixupURLsOnPaste = fSet;
            }

            hr = S_OK;
            _pOptionSettings->dwMiscFlags = _dwMiscFlags();

            CElement *pElement = CMarkup::GetElementClientHelper(pMarkup);
            //
            // TODO marka - is this supposed to be doing an invalidate ?
            //
            if (pElement)
                pElement->ResizeElement(NFLAGS_FORCE);

            // Send this command to our children
            {
                COnCommandExecParams cmdExecParams;
                cmdExecParams.pguidCmdGroup = pguidCmdGroup;
                cmdExecParams.nCmdID        = nCmdID;
                CNotification   nf;

                if (idm == IDM_SHOWZEROBORDERATDESIGNTIME)
                    nf.Command(pMarkup->Root(), &cmdExecParams);
                else
                    nf.Command(PrimaryRoot(), &cmdExecParams);
                BroadcastNotify(&nf);
            }
            break;
        }

    case IDM_SHOWALLTAGS:
    case IDM_SHOWALIGNEDSITETAGS:
    case IDM_SHOWSCRIPTTAGS:
    case IDM_SHOWSTYLETAGS:
    case IDM_SHOWCOMMENTTAGS:
    case IDM_SHOWAREATAGS:
    case IDM_SHOWUNKNOWNTAGS:
    case IDM_SHOWMISCTAGS:
    case IDM_SHOWWBRTAGS:
       {
            //
            //  TODO: cleanup these flags [ashrafm]
            //
            CVariant    var;
            BOOL        fSet = FALSE;
            CGlyph      *pTable = pContextDoc->Markup()->GetGlyphTable();

            if (pvarargIn)
            {
                if(pvarargIn->vt != VT_BOOL)
                    break;
                fSet = ENSURE_BOOL(V_BOOL(pvarargIn));
            }
            else
            {
                if( pTable )
                {
                    switch(idm)
                    {
                        case IDM_SHOWALIGNEDSITETAGS:
                            fSet = !pTable->_fShowAlignedSiteTags; break;
                        case IDM_SHOWSCRIPTTAGS:
                            fSet = !pTable->_fShowScriptTags; break;
                        case IDM_SHOWSTYLETAGS:
                            fSet = !pTable->_fShowStyleTags; break;
                        case IDM_SHOWCOMMENTTAGS:
                            fSet = !pTable->_fShowCommentTags; break;
                        case IDM_SHOWAREATAGS:
                            fSet = !pTable->_fShowAreaTags; break;
                        case IDM_SHOWMISCTAGS:
                            fSet = !pTable->_fShowMiscTags; break;
                        case IDM_SHOWUNKNOWNTAGS:
                            fSet = !pTable->_fShowUnknownTags; break;
                        case IDM_SHOWWBRTAGS:
                            fSet = !pTable->_fShowWbrTags; break;
                        case IDM_SHOWALLTAGS:
                            fSet = !( pTable->_fShowWbrTags     && pTable->_fShowUnknownTags    &&
                                      pTable->_fShowMiscTags    && pTable->_fShowAreaTags       &&
                                      pTable->_fShowCommentTags && pTable->_fShowStyleTags      &&
                                      pTable->_fShowScriptTags  && pTable->_fShowAlignedSiteTags );
                            break;
                        default:Assert(0);
                    }
                }
                else
                {
                    // No glyph table yet... so turn on the option (this will create the
                    // glyph table )
                    fSet = TRUE;
                }
                V_VT(&var) = VT_BOOL;
                V_BOOL(&var) = VARIANT_BOOL_FROM_BOOL(fSet);

                pvarargIn = &var;
            }

            //
            // HACKHACK: EnsureGlyphTableExistsAndExecute should be able to delete from the table
            //
            if (!fSet && (idm == IDM_SHOWALLTAGS || idm == IDM_SHOWMISCTAGS))
            {
                // Empty the glyph table
                idm = IDM_EMPTYGLYPHTABLE;
            }

            hr = pContextDoc->Markup()->EnsureGlyphTableExistsAndExecute(
                                                    pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);
            if (hr)
                break;

            if( idm != IDM_EMPTYGLYPHTABLE )
            {
                //
                // If we empty'd the table, then of course won't need to reset
                // any of the flags.
                //
                pTable = pContextDoc->Markup()->GetGlyphTable();
                Assert( pTable );

                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWALIGNEDSITETAGS)
                    pTable->_fShowAlignedSiteTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWSCRIPTTAGS)
                    pTable->_fShowScriptTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWSTYLETAGS)
                    pTable->_fShowStyleTags =  fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWCOMMENTTAGS)
                    pTable->_fShowCommentTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWAREATAGS)
                    pTable->_fShowAreaTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWMISCTAGS)
                    pTable->_fShowMiscTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWUNKNOWNTAGS)
                    pTable->_fShowUnknownTags = fSet;
                if(idm == IDM_SHOWALLTAGS || idm == IDM_SHOWWBRTAGS)
                    pTable->_fShowWbrTags = fSet;
            }

            break;
        }

    case IDM_ADDTOGLYPHTABLE:
    case IDM_REMOVEFROMGLYPHTABLE:
    case IDM_REPLACEGLYPHCONTENTS:
        {
            if (!pvarargIn->bstrVal)
                break;

            hr = pContextDoc->Markup()->EnsureGlyphTableExistsAndExecute(
                                                    pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);
            break;
        }
    case IDM_EMPTYGLYPHTABLE:
        {
            hr = pContextDoc->Markup()->EnsureGlyphTableExistsAndExecute(
                                                    pguidCmdGroup, idm, nCmdexecopt,pvarargIn, pvarargOut);
            break;
        }
    case IDM_NOACTIVATENORMALOLECONTROLS:
    case IDM_NOACTIVATEDESIGNTIMECONTROLS:
    case IDM_NOACTIVATEJAVAAPPLETS:
        {
            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
                break;

            BOOL fSet = ENSURE_BOOL(pvarargIn->bVal);

            if (idm == IDM_NOACTIVATENORMALOLECONTROLS)
                _fNoActivateNormalOleControls = fSet;
            else if (idm == IDM_NOACTIVATEDESIGNTIMECONTROLS)
                _fNoActivateDesignTimeControls = fSet;
            else
                _fNoActivateJavaApplets = fSet;

            _pOptionSettings->dwMiscFlags = _dwMiscFlags();

            hr = S_OK;
            fRouteToEditor = TRUE;
            break;
        }

    case IDM_SETDIRTY:
        if (!pvarargIn || pvarargIn->vt != VT_BOOL)
        {
            hr = E_INVALIDARG;
            break;
        }

        hr = THR(SetDirtyFlag(ENSURE_BOOL(pvarargIn->bVal)));
        break;

    case IDM_PRESERVEUNDOALWAYS:
        if (pvarargIn && pvarargIn->vt == VT_BOOL)
        {
            TLS( fAllowParentLessPropChanges ) = pvarargIn->boolVal;

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_PERSISTDEFAULTVALUES:
        if(pvarargIn && pvarargIn->vt == VT_BOOL)
        {
            TLS( fPersistDefaultValues ) = pvarargIn->boolVal;

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_PROTECTMETATAGS:
        if(pvarargIn && pvarargIn->vt == VT_BOOL)
        {
            _fDontWhackGeneratorOrCharset = pvarargIn->boolVal;

            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_WAITFORRECALC:
    {
        // This private command is issued by MSHTMPAD to force background recalc to
        // finish so that accurate timings can be measured.

        WaitForRecalc(pContextDoc->Markup());
        hr = S_OK;
        break;
    }

    case IDM_GETSWITCHTIMERS:
    {
#ifdef SWITCHTIMERS_ENABLED
        // This private command is issued by MSHTMPAD to collect detailed timing information.
        void AnsiToWideTrivial(const CHAR * pchA, WCHAR * pchW, LONG cch);
        char ach[256];
        SwitchesGetTimers(ach);
        AnsiToWideTrivial(ach, pvarargOut->bstrVal, lstrlenA(ach));
#endif
        hr = S_OK;
        break;
    }

    case IDM_DWNH_SETDOWNLOAD:
        if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
        {
            hr = THR(SetDownloadNotify(pvarargIn->punkVal));
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;

    case IDM_SAVEPICTURE:
        if (!_pMenuObject)
        {
            //
            // only do work here if there is no menu object, and there an
            // image on this document.  This is here to handle saveAs on a
            // file://c:/temp/foo.gif type document url.  If for some reason
            // this IDM comes through on a non-image document, we will try to
            // save the first image in the images collection instead.  If there
            // isn't one, then we fail,
            //
            CElement          * pImg = NULL;
            CCollectionCache  * pCollectionCache = NULL;
            CMarkup           * pMarkup = _pElemCurrent->GetMarkup();

            hr = THR(pMarkup->EnsureCollectionCache(CMarkup::IMAGES_COLLECTION));
            if (!hr)
            {
                pCollectionCache = pMarkup->CollectionCache();

                hr = THR(pCollectionCache->GetIntoAry(CMarkup::IMAGES_COLLECTION, 0, &pImg));
                if (!hr)
                {
                    Assert(pImg);

                    hr = THR_NOTRACE(pImg->Exec(pguidCmdGroup,
                                        nCmdID,
                                        nCmdexecopt,
                                        pvarargIn,
                                        pvarargOut));
                }
            }
            if (hr)
                hr = OLECMDERR_E_NOTSUPPORTED;
        }
        break;

    case IDM_SAVEPRETRANSFORMSOURCE:
        Assert(pContextDoc->Markup());
        if (!pvarargIn || (pvarargIn->vt != VT_BSTR) || !V_BSTR(pvarargIn) )
            hr = E_INVALIDARG;
        else
        {
            hr = SavePretransformedSource(pContextDoc->Markup(), V_BSTR(pvarargIn));
        }
        break;
    case IDM_UNLOADDOCUMENT:
        {
            CMarkup * pMarkup = pContextDoc->Markup();
            Assert( pMarkup );
            if( pMarkup->IsConnectedToPrimaryMarkup() )
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                Assert( !pMarkup->IsConnectedToPrimaryWorld() );
                pMarkup->TearDownMarkup();
                hr = S_OK;
            }
        }
        break;

    case IDM_TRUSTAPPCACHE:
        {
            BOOL fSet;
            if (!pvarargIn || pvarargIn->vt != VT_BOOL)
            {
                fSet = !( _fTrustAPPCache );      // If the argument value is not bool, just toggle the flag
            }
            else
            {
                fSet = ENSURE_BOOL(pvarargIn->bVal);
            }

            _fTrustAPPCache = fSet;

            hr = S_OK;
        }
        break;

    case IDM_BACKGROUNDIMAGECACHE:
        if (!pvarargIn || pvarargIn->vt != VT_BOOL)
        {
            hr = E_INVALIDARG;
        } 
        else
        {
            _fBackgroundImageCache = ENSURE_BOOL(pvarargIn->bVal);
            hr = S_OK;
        }
        break;

	case IDM_CLEARAUTHENTICATIONCACHE:
        hr = InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0) ? 
            S_OK : E_FAIL;
        break;

#if DBG==1
    case IDM_DEBUG_GETTREETEXT:
        {
            IStream * pStream = NULL;

            if (!pvarargIn ||
                (pvarargIn->vt != VT_UNKNOWN) ||
                !V_UNKNOWN(pvarargIn) )
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = THR_NOTRACE(V_UNKNOWN(pvarargIn)->QueryInterface(IID_IStream,
                                                                  (void **)&pStream));
            if (hr)
                break;

            hr = THR_NOTRACE(SaveToStream( pStream, 0, CP_1252 ));

            ReleaseInterface((IUnknown*) pStream);
        }
        break;
#endif
    }

    if(FAILED(hr) && hr != OLECMDERR_E_NOTSUPPORTED)
        goto Cleanup;

#ifndef NO_MULTILANG
    if( idm >= IDM_MIMECSET__FIRST__ && idm <= IDM_MIMECSET__LAST__)
    {
        CODEPAGE cp = GetCodePageFromMenuID(idm);
        THREADSTATE * pts = GetThreadState();

        // assigning IDM_MIMECSET__LAST__ to CpAutoDetect mode
        if ( cp == CP_UNDEFINED && idm == IDM_MIMECSET__LAST__ )
        {
            SetCpAutoDetect(!IsCpAutoDetect());

            if (IsCpAutoDetect() && mlang().IsMLangAvailable())
            {
                // we need the same refreshing effect as the regular cp
                cp = CP_AUTO;
            }
        }

        // NB (cthrash) ValidateCodePage allows us to JIT download a language pack.
        // If we don't have IMultiLanguage2, JIT downloadable codepages will not
        // appear in the language menu (ie only codepages currently available on
        // the system will be provided as options) and thus ValidateCodePage
        // is not required.

        if (   CP_UNDEFINED != cp
#ifndef UNIX
            && S_OK == mlang().ValidateCodePage(g_cpDefault, cp, _pInPlace->_hwnd, TRUE, _dwLoadf & DLCTL_SILENT)
#endif
            )
        {
            CMarkup * pMarkup = _pMenuObject ? _pMenuObject->GetMarkup() : pContextDoc->Markup();

            pMarkup = pMarkup->GetFrameOrPrimaryMarkup(TRUE);

            if (pMarkup)
            {
                CRootElement * pRoot = pMarkup->Root();

                CNotification nf;
                nf.Initialize(NTYPE_SET_CODEPAGE, pRoot, pRoot->GetFirstBranch(), (void *)(UINT_PTR)cp, 0);

                // if AutoDetect mode is on, we don't make a change
                // to the default codepage for the document
                if (!IsCpAutoDetect() && !pMarkup->HaveCodePageMetaTag())
                {
                    // [review]
                    // here we save the current setting to the registry
                    // we should find better timing to do it
                    SaveDefaultCodepage(cp);
                }

                BroadcastNotify(&nf);

                // Bubble down code page to nested documents
                pMarkup->BubbleDownCodePage(cp);

                IGNORE_HR(pMarkup->Window()->ExecRefresh());
            }
        }
        pts->_iFontHistoryVersion++;
        hr = S_OK;
    }
#endif // !NO_MULTLANG

    if (hr == OLECMDERR_E_NOTSUPPORTED)
    {
        ctarg.pguidCmdGroup = pguidCmdGroup;
        ctarg.fQueryStatus = FALSE;
        ctarg.pexecArg = &execarg;
        execarg.nCmdID = nCmdID;
        execarg.nCmdexecopt = nCmdexecopt;
        execarg.pvarargIn = pvarargIn;
        execarg.pvarargOut = pvarargOut;

        if (_pMenuObject)
        {
            hr = THR_NOTRACE(RouteCTElement(_pMenuObject, &ctarg, pContextDoc));
        }

        if (hr == OLECMDERR_E_NOTSUPPORTED && _pElemCurrent)
        {
            CElement *pelTarget;
            CTreeNode *pNode = _pElemCurrent->GetFirstBranch();
            Assert(pNode);
            Assert(pContextDoc);
            // Get the node in the markup of the context CDocument that contains the current element
            pNode = pNode->GetNodeInMarkup(pContextDoc->Markup());

            if (pNode)
            {
                pelTarget = pNode->Element();
            }
            else
            {
                pelTarget = pContextDoc->Markup()->GetElementClient();
            }
            if (pelTarget)
                hr = THR_NOTRACE(RouteCTElement(pelTarget, &ctarg, pContextDoc));
        }
    }


    //
    // IEV6 #2555
    // We only route command to editor if we are at least
    // OS_INPLACE. This is to make sure that we have a
    // window -- otherwise caret code will crash.
    //
    if( (hr == OLECMDERR_E_NOTSUPPORTED || fRouteToEditor)
        && ((!_pOptionSettings || !(_pOptionSettings->fRouteEditorOnce)) || (_cInRouteCT == 0)) // only call editor once
        && (State() >= OS_INPLACE) 
        )
    {
        CEditRouter *pRouter;
        HRESULT     hrEdit = S_OK;

        // Retrieve the edit markup if no context has been passed into this helper function.
        // This occurs when pContextDoc is NULL on input.  pEditMarkup will be NULL in this
        // case, and we use the selection's current markup in order to determine where
        // the edit command should be routed to

        if( !pEditMarkup )
        {
            hrEdit = THR( GetSelectionMarkup( &pEditMarkup ) );

            if( pEditMarkup == NULL && _pElemCurrent )
            {
                pEditMarkup = _pElemCurrent->GetMarkupPtr();
            }
        }

        if( !FAILED(hrEdit ) && pEditMarkup )
        {
            hr = THR( pEditMarkup->EnsureEditRouter(&pRouter) );

            if( !FAILED(hr) )
            {
                hr = THR_NOTRACE( pRouter->ExecEditCommand( pguidCmdGroup,
                                                            nCmdID, nCmdexecopt,
                                                            pvarargIn, pvarargOut,
                                                            (IUnknown *)(IPrivateUnknown *)pEditMarkup,
                                                            this ) );
            }
        }
    }

    Assert(TestLock(SERVERLOCK_STABILIZED));

    if (!hr && (!pvarargOut || pvarargIn))
        DeferUpdateUI();

Cleanup:
    SRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CDoc::OnContextMenuExt
//
//  Synopsis:   Handle launching the dialog when a ContextMenuExt
//              command is received
//
//--------------------------------------------------------------------
HRESULT
CDoc::OnContextMenuExt(CMarkup * pMarkupContext, UINT idm, VARIANTARG * pvarargIn)
{
    HRESULT          hr = E_FAIL;
    IDispatch      * pDispWindow=NULL;
    CParentUndoUnit* pCPUU = NULL;
    unsigned int     nExts;
    CONTEXTMENUEXT * pCME;

    Assert(idm >= IDM_MENUEXT_FIRST__ && idm <= IDM_MENUEXT_LAST__);

    // find the html to run
    //
    nExts = _pOptionSettings->aryContextMenuExts.Size();
    Assert((idm - IDM_MENUEXT_FIRST__) < nExts);
    pCME = _pOptionSettings->
                aryContextMenuExts[idm - IDM_MENUEXT_FIRST__];
    Assert(pCME);

    // Undo stuff
    //
    pCPUU = OpenParentUnit(this, IDS_CANTUNDO);

    // get dispatch for the main window
    //

    pMarkupContext = pMarkupContext->GetFrameOrPrimaryMarkup();

    if (!pMarkupContext || !pMarkupContext->Window())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pDispWindow = (IHTMLWindow2*)(pMarkupContext->Window()->Window());

    // bring up the dialog
    //
    hr = THR(ShowModalDialogHelper(
            pMarkupContext,
            pCME->cstrActionUrl,
            pDispWindow,
            NULL,
            NULL,
            (pCME->dwFlags & MENUEXT_SHOWDIALOG)
                            ? 0 : (HTMLDLG_NOUI | HTMLDLG_AUTOEXIT)));

    if (pCPUU)
    {
        IGNORE_HR(CloseParentUnit(pCPUU, hr));
    }

Cleanup:
    RRETURN(hr);
}


void
CDoc::WaitForRecalc(CMarkup * pMarkup)
{
    PerfDbgLog(tagPerfWatch, this, "+CDoc::WaitForRecalc");

    //  Even for StrictCSS1 documents, this is currently enough.
    //  All that this function would do for an HTML layout is to delegate it to the
    //  element client... so we simply use the element client here.
    CElement *  pElement = CMarkup::GetElementClientHelper(pMarkup);

    if (_view.HasLayoutTask())
    {
        PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (EnsureView)");
        _view.EnsureView(LAYOUT_DEFERPAINT);
    }

    if (pElement)
    {
        PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (Body/Frame WaitForRecalc)");
        if (pElement->Tag() == ETAG_BODY)
            ((CBodyElement *)pElement)->WaitForRecalc();
        else if (pElement->Tag() == ETAG_FRAMESET)
            ((CFrameSetSite *)pElement)->WaitForRecalc();
    }

    if (_view.HasLayoutTask())
    {
        PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (EnsureView)");
        _view.EnsureView(LAYOUT_DEFERPAINT);
    }

    PerfDbgLog(tagPerfWatch, this, "CDoc::WaitForRecalc (UpdateForm)");
    UpdateForm();

    PerfDbgLog(tagPerfWatch, this, "-CDoc::WaitForRecalc");
}

//+---------------------------------------------------------------------------
//
// Member: AddToFavorites
//
//----------------------------------------------------------------------------
HRESULT
CDoc::AddToFavorites(TCHAR * pszURL, TCHAR * pszTitle)
{
#if defined(WIN16) || defined(WINCE)
    return S_FALSE;
#else
    VARIANTARG varURL;
    VARIANTARG varTitle;
    IUnknown * pUnk;
    HRESULT    hr;

    varURL.vt        = VT_BSTR;
    varURL.bstrVal   = pszURL;
    varTitle.vt      = VT_BSTR;
    varTitle.bstrVal = pszTitle;

    if (_pInPlace && _pInPlace->_pInPlaceSite)
    {
        pUnk = _pInPlace->_pInPlaceSite;
    }
    else
    {
        pUnk = _pClientSite;
    }

    hr = THR(CTExec(
            pUnk,
            &CGID_Explorer,
            SBCMDID_ADDTOFAVORITES,
            MSOCMDEXECOPT_PROMPTUSER,
            &varURL,
            &varTitle));

    RRETURN(hr);
#endif
}

//+----------------------------------------------------------------------------
//
// Member: AddPages (IShellPropSheetExt interface)
//
// Add Internet Property Sheets
//
//-----------------------------------------------------------------------------
typedef struct tagIEPROPPAGEINFO
{
    UINT  cbSize;
    DWORD dwFlags;
    LPSTR pszCurrentURL;
    DWORD dwRestrictMask;
    DWORD dwRestrictFlags;
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

DYNLIB  g_dynlibINETCPL = { NULL, NULL, "inetcpl.cpl" };

DYNPROC g_dynprocAddInternetPropertySheets =
        { NULL, & g_dynlibINETCPL, "AddInternetPropertySheetsEx" };

#ifndef WIN16
HRESULT
CDoc::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TCHAR  achFile[MAX_PATH];
    ULONG  cchFile = ARRAY_SIZE(achFile);
    LPTSTR pszURLW = (TCHAR *) GetPrimaryUrl();
    char   szURL[1024];
    LPSTR  pszURL = NULL;

    HRESULT hr;

    if (pszURLW && GetUrlScheme(pszURLW) == URL_SCHEME_FILE)
    {
        hr = THR(PathCreateFromUrl(pszURLW, achFile, &cchFile, 0));
        if (hr)
            goto Cleanup;

        pszURLW = achFile;
    }

    if (pszURLW)
    {
        pszURL = szURL;
        WideCharToMultiByte(CP_ACP, 0, pszURLW, -1, pszURL, sizeof(szURL), NULL, NULL);
    }

    hr = THR(LoadProcedure(& g_dynprocAddInternetPropertySheets));
    if (hr)
        goto Cleanup;

    IEPROPPAGEINFO iepi;

    iepi.cbSize = sizeof(iepi);
    iepi.dwFlags = (DWORD)-1;
    iepi.pszCurrentURL = pszURL;
    iepi.dwRestrictMask = 0;    // turn off all mask bits

    hr = THR((*(HRESULT (WINAPI *)
                    (LPFNADDPROPSHEETPAGE,
                     LPARAM,
                     PUINT,
                     LPFNPSPCALLBACK,
                     LPIEPROPPAGEINFO))
             g_dynprocAddInternetPropertySheets.pfn)
                     (lpfnAddPage, lParam, NULL, NULL, &iepi));

Cleanup:
    if (hr)
        hr = E_FAIL;
    RRETURN (hr);
}
#endif // !WIN16

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetupDefaultBlockTag(VARIANTARG pvarargIn)
//
//  Synopsis:   This function parses the string coming in and sets up the
//              default composition font.
//
//  Params:     [vargIn]: A BSTR, either "P" or "DIV"
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CDoc::SetupDefaultBlockTag(VARIANTARG *pvarargIn)
{
    HRESULT hr = E_INVALIDARG;
    BSTR pstr;

    //
    // If its not a BSTR, do nothing.
    //
    if (V_VT(pvarargIn) != VT_BSTR)
        goto Cleanup;

    // Get the string
    pstr = V_BSTR(pvarargIn);

    if (!StrCmpC (pstr, _T("DIV")))
    {
        SetDefaultBlockTag(ETAG_DIV);
    }
    else if (!StrCmpC (pstr, _T("P")))
    {
        SetDefaultBlockTag(ETAG_P);
    }
    else
    {
        SetDefaultBlockTag(ETAG_P);
        AssertSz(0, "Unexpected type");
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\grab.cxx ===
//+------------------------------------------------------------------------
//
//  File:       grab.cxx
//
//  Contents:   Grab handle utilities
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifdef UNIX
extern "C" COLORREF MwGetTrueRGBValue(COLORREF crColor);
#endif

template < class T > void swap ( T & a, T & b ) { T t = a; a = b; b = t; }

struct HTCDSI
{
    short   htc;
    short   dsi;
};

static const HTCDSI s_aHtcDsi[] =
{
    {HTC_TOPLEFTHANDLE,     DSI_NOTOPHANDLES    | DSI_NOLEFTHANDLES     },
    {HTC_TOPHANDLE,         DSI_NOTOPHANDLES                            },
    {HTC_TOPRIGHTHANDLE,    DSI_NOTOPHANDLES    | DSI_NORIGHTHANDLES    },
    {HTC_LEFTHANDLE,                              DSI_NOLEFTHANDLES     },
    {HTC_RIGHTHANDLE,                             DSI_NORIGHTHANDLES    },
    {HTC_BOTTOMLEFTHANDLE,  DSI_NOBOTTOMHANDLES | DSI_NOLEFTHANDLES     },
    {HTC_BOTTOMHANDLE,      DSI_NOBOTTOMHANDLES                         },
    {HTC_BOTTOMRIGHTHANDLE, DSI_NOBOTTOMHANDLES | DSI_NORIGHTHANDLES    },
};

//+------------------------------------------------------------------------
//
//  Function:   ColorDiff
//
//  Synopsis:   Computes the color difference amongst two colors
//
//-------------------------------------------------------------------------
DWORD ColorDiff (COLORREF c1, COLORREF c2)
{
#ifdef UNIX
    if ( CColorValue(c1).IsMotifColor() ) {
        c1 = MwGetTrueRGBValue( c1 );
    }

    if ( CColorValue(c2).IsMotifColor() ) {
        c2 = MwGetTrueRGBValue( c2 );
    }
#endif

#define __squareit(n) ((DWORD)((n)*(n)))
    return (__squareit ((INT)GetRValue (c1) - (INT)GetRValue (c2)) +
            __squareit ((INT)GetGValue (c1) - (INT)GetGValue (c2)) +
            __squareit ((INT)GetBValue (c1) - (INT)GetBValue (c2)));
#undef __squareit
}

//+------------------------------------------------------------------------
//
//  Function:   PatBltRectH & PatBltRectV
//
//  Synopsis:   PatBlts the top/bottom and left/right.
//
//-------------------------------------------------------------------------
static void
PatBltRectH(XHDC hDC, RECT * prc, int cThick, DWORD dwRop)
{
    PatBlt(
            hDC,
            prc->left,
            prc->top,
            prc->right - prc->left,
            cThick,
            dwRop);

    PatBlt(
            hDC,
            prc->left,
            prc->bottom - cThick,
            prc->right - prc->left,
            cThick,
            dwRop);
}

static void
PatBltRectV(XHDC hDC, RECT * prc, int cThick, DWORD dwRop)
{
    PatBlt(
            hDC,
            prc->left,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            dwRop);

    PatBlt(
            hDC,
            prc->right - cThick,
            prc->top + cThick,
            cThick,
            (prc->bottom - prc->top) - (2 * cThick),
            dwRop);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetGrabRect
//
//  Synopsis:   Compute grab rect for a given area.
//
//  Notes:      These diagrams show the output grab rect for handles and
//              borders.
//
//              -----   -----   -----               -------------
//              |   |   |   |   |   |               |           |
//              | TL|   | T |   |TR |               |     T     |
//              ----|-----------|----           ----|-----------|----
//                  |           |               |   |           |   |
//              ----| Input     |----           |   | Input     |   |
//              |   |           |   |           |   |           |   |
//              |  L|   RECT    |R  |           |  L|   RECT    |R  |
//              ----|           |----           |   |           |   |
//                  |           |               |   |           |   |
//              ----|-----------|----           ----|-----------|----
//              | BL|   | B |   |BR |               |     B     |
//              |   |   |   |   |   |               |           |
//              -----   -----   -----               -------------
//
//----------------------------------------------------------------------------

static void
GetGrabRect(HTC htc, RECT * prcOut, RECT * prcIn, LONG cGrabSize)
{
    switch (htc)
    {
    case HTC_TOPLEFTHANDLE:
    case HTC_LEFTHANDLE:
    case HTC_BOTTOMLEFTHANDLE:
    case HTC_GRPTOPLEFTHANDLE:
    case HTC_GRPLEFTHANDLE:
    case HTC_GRPBOTTOMLEFTHANDLE:
    case HTC_LEFTBORDER:
    case HTC_GRPLEFTBORDER:
        prcOut->left = prcIn->left - cGrabSize;
        prcOut->right = prcIn->left;
        break;

    case HTC_TOPHANDLE:
    case HTC_BOTTOMHANDLE:
    case HTC_GRPTOPHANDLE:
    case HTC_GRPBOTTOMHANDLE:
        prcOut->left = ((prcIn->left + prcIn->right) - cGrabSize) / 2;
        prcOut->right = prcOut->left + cGrabSize;
        break;

    case HTC_TOPRIGHTHANDLE:
    case HTC_RIGHTHANDLE:
    case HTC_BOTTOMRIGHTHANDLE:
    case HTC_GRPTOPRIGHTHANDLE:
    case HTC_GRPRIGHTHANDLE:
    case HTC_GRPBOTTOMRIGHTHANDLE:
    case HTC_RIGHTBORDER:
    case HTC_GRPRIGHTBORDER:
        prcOut->left = prcIn->right;
        prcOut->right = prcOut->left + cGrabSize;
        break;

    case HTC_TOPBORDER:
    case HTC_BOTTOMBORDER:
    case HTC_GRPTOPBORDER:
    case HTC_GRPBOTTOMBORDER:
        prcOut->left = prcIn->left;
        prcOut->right = prcIn->right;
        break;

    default:
        Assert(FALSE && "Unsupported HTC_ value in GetHandleRegion");
        return;
    }

    switch (htc)
    {
    case HTC_TOPLEFTHANDLE:
    case HTC_TOPHANDLE:
    case HTC_TOPRIGHTHANDLE:
    case HTC_GRPTOPLEFTHANDLE:
    case HTC_GRPTOPHANDLE:
    case HTC_GRPTOPRIGHTHANDLE:
    case HTC_TOPBORDER:
    case HTC_GRPTOPBORDER:
        prcOut->top = prcIn->top - cGrabSize;
        prcOut->bottom = prcIn->top;
        break;

    case HTC_LEFTHANDLE:
    case HTC_RIGHTHANDLE:
    case HTC_GRPLEFTHANDLE:
    case HTC_GRPRIGHTHANDLE:
        prcOut->top = ((prcIn->top + prcIn->bottom) - cGrabSize) / 2;
        prcOut->bottom = prcOut->top + cGrabSize;
        break;

    case HTC_BOTTOMLEFTHANDLE:
    case HTC_BOTTOMHANDLE:
    case HTC_BOTTOMRIGHTHANDLE:
    case HTC_GRPBOTTOMLEFTHANDLE:
    case HTC_GRPBOTTOMHANDLE:
    case HTC_GRPBOTTOMRIGHTHANDLE:
    case HTC_BOTTOMBORDER:
    case HTC_GRPBOTTOMBORDER:
        prcOut->top = prcIn->bottom;
        prcOut->bottom = prcOut->top + cGrabSize;
        break;

    case HTC_LEFTBORDER:
    case HTC_RIGHTBORDER:
    case HTC_GRPLEFTBORDER:
    case HTC_GRPRIGHTBORDER:
        prcOut->top = prcIn->top;
        prcOut->bottom = prcIn->bottom;
        break;

    default:
        Assert(FALSE && "Unsupported HTC_ value in GetHandleRegion");
        return;
    }

    if (prcOut->left > prcOut->right)
    {
        swap(prcOut->left, prcOut->right);
    }
    if (prcOut->top > prcOut->bottom)
    {
        swap(prcOut->top, prcOut->bottom);
    }
}


//+---------------------------------------------------------------------------
//
//  Global helpers.
//
//----------------------------------------------------------------------------

void
PatBltRect(XHDC hDC, RECT * prc, int cThick, DWORD dwRop)
{
    PatBltRectH(hDC, prc, cThick, dwRop);

    PatBltRectV(hDC, prc, cThick, dwRop);
}

void
DrawDefaultFeedbackRect(XHDC hDC, RECT * prc)
{
#ifdef NEVER
    HBRUSH  hbrOld = NULL;
    HBRUSH  hbr = GetCachedBmpBrush(IDR_FEEDBACKRECTBMP);

    hbrOld = (HBRUSH) SelectObject(hDC, hbr);
    if (!hbrOld)
        goto Cleanup;

    PatBltRect(hDC, prc, FEEDBACKRECTSIZE, PATINVERT);

Cleanup:
    if (hbrOld)
        SelectObject(hDC, hbrOld);
#endif        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\getid.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       getid.cxx
//
//  Contents:   GetUniqueID service and usage
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_TIMER_HXX_
#define X_TIMER_HXX_
#include "timer.hxx"
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

#ifndef X_ACTIVDBG_H_
#define X_ACTIVDBG_H_
#include <activdbg.h>
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef NO_DDRAW
#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include <ddraw.h>
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif
#endif // NO_DDRAW

#ifndef NO_SCRIPT_DEBUGGER
extern interface IDebugApplication *g_pDebugApp;
#endif // NO_SCRIPT_DEBUGGER

extern CGlobalCriticalSection    g_csOscCache;

extern HRESULT EnsureAccWindow( CWindow * pWindow );

extern "C" const GUID SID_SHTMLEditServices;

//
//  CDoc methods
//


DeclareTag(tagNoQS, "Form", "Obstruct all QueryService to container")
MtExtern(CEnumPrivacyRecords)


//+------------------------------------------------------------------------
//
//  Member:     CDoc::QueryService
//
//  Synopsis:   QueryService for the form.  Delegates to the form's
//              own site.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDoc::QueryService(
        REFGUID guidService,
        REFIID iid,
        void ** ppv)
{
    HRESULT             hr;

#if DBG == 1
    if (IsTagEnabled(tagNoQS))
        hr = E_NOINTERFACE;
    else
#endif
    //
    // Certain services should never be bubbled up through 
    // the client site
    // SID_SContainerDispatch   -   Always provide container's IDispatch
    // SID_SLocalRegistry       -   Never bubble due to security concerns.
    //                              License manager is per document.
    // SID_SBindHost            -   We provide the service but might also
    //                              forward some calls to an outer bindhost,
    //                              if any.
    //

    // TODO (alexz) these "ifs" are redundant to "ifs" inside CreateService
    if (SID_SContainerDispatch == guidService ||
        SID_SLocalRegistry == guidService ||
        SID_SBindHost == guidService ||
        CLSID_HTMLDocument == guidService ||
        IID_IDebugApplication == guidService ||
        IID_IInternetHostSecurityManager == guidService ||
        IID_IDocHostUIHandler == guidService ||
        SID_SHTMLProperyPageArg == guidService ||
        IID_IAccessible == guidService ||
        IID_ISelectionServices == guidService ||
        SID_SHTMLEditServices == guidService || 
        IID_IElementNamespaceTable== guidService ||
        IID_IEnumPrivacyRecords == guidService ||
        IID_IPrivacyServices == guidService)
    {
        hr = THR_NOTRACE(CreateService(guidService, iid, ppv));
    }
    else
    {
        hr = THR_NOTRACE(CServer::QueryService(guidService, iid, ppv));
        if (hr)
        {
            hr = THR_NOTRACE(CreateService(guidService, iid, ppv));
        }
    }
    
    RRETURN_NOTRACE(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CreateService, public
//
//  Synopsis:   Creates the requested service. Only called if our container
//              does not provide the service.
//
//  Arguments:  [guidService] -- Service being asked for.
//              [iid]         -- IID needed on that service.
//              [ppv]         -- Place to put pointer.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CreateService(REFGUID guidService, REFIID iid, LPVOID * ppv)
{
    HRESULT hr;

    *ppv = NULL;

#ifndef NO_EDIT
    if (guidService == SID_SOleUndoManager)
    {
        hr = CreateUndoManager();
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(_pUndoMgr->QueryInterface(iid, ppv));
    }
    else 
#endif // NO_EDIT
#ifndef NO_DDRAW
    if (guidService == SID_SDirectDraw3)
    {
        extern HRESULT InitSurface();
        extern IDirectDraw* g_pDirectDraw;
        LOCK_SECTION(g_csOscCache);
        hr = InitSurface();
        if (SUCCEEDED(hr))
            hr = THR_NOTRACE(g_pDirectDraw->QueryInterface(iid, ppv));
    } 
    else 
#endif //ndef NO_DDRAW
    if (guidService == SID_STimerService)
    {
        CTimerMan *pTimerMan;
        hr = THR(GetTimerManager(&pTimerMan));
        if (SUCCEEDED(hr))
        {
            hr = THR_NOTRACE(pTimerMan->QueryInterface(iid, ppv));

            if (SUCCEEDED(hr))
            {
                if (!_pTimerDraw)
                {
                    // Init NAMEDTIMER_DRAW which gets frozen for controls during paints.
                    // Not a problem if this fails as the results are not catastrophic.

                    IGNORE_HR(pTimerMan->GetNamedTimer(NAMEDTIMER_DRAW, &_pTimerDraw));
                }
                
                pTimerMan->Release();
            }
        }
    }
    else if (guidService == SID_SContainerDispatch)
    {
        hr = THR_NOTRACE(QueryInterface(iid, ppv));
    }
    else if (guidService == SID_SLocalRegistry)
    {
        //
        // Respond with license manager if one is available.
        //
        
        if (_pWindowPrimary->Window()->_pLicenseMgr)
        {
            hr = THR(_pWindowPrimary->Window()->_pLicenseMgr->QueryInterface(iid, ppv));
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else if (guidService == SID_SUrlHistory) 
    {
        // Our container is not shdocvw --- we need to handle geting the
        // history container ourself. It would be nice to be able to
        // assert that shdocvw is not the host though to make sure we 
        // are not in the situation where we have a problem and don't
        // detect it.

        hr = THR(CoCreateInstance(CLSID_CUrlHistory, NULL,  CLSCTX_INPROC_SERVER, iid, ppv));
    }
    else if (   guidService == CLSID_HTMLDocument )
    {
        hr = THR(PrivateQueryInterface(iid, ppv));
    }
    else if ( guidService == IID_IInternetHostSecurityManager )
    {
        // delegate to the top level document object.

        Assert(_pWindowPrimary->Document());

        hr = THR(_pWindowPrimary->Document()->QueryInterface(iid, ppv));

    }
#ifndef NO_SCRIPT_DEBUGGER
    else if ((IID_IDebugApplication == guidService) && g_pDebugApp)
    {
        hr = THR_NOTRACE(g_pDebugApp->QueryInterface (iid, ppv));
    }
#endif
#ifndef NO_PROPERTY_PAGE
    else if (guidService == SID_SHTMLProperyPageArg)
    {
        COptionsHolder *    pcoh = new COptionsHolder(GetCurrentWindow()->Window());

        hr = 
            THR(pcoh->put_anythingAfterFrameset( 
            (VARIANT_BOOL) _fTagsInFrameset));

        hr = THR_NOTRACE(pcoh->QueryInterface(iid,ppv));
        ReleaseInterface(pcoh);
    }
#endif
    else if (guidService == IID_IAuthenticate && iid == IID_IAuthenticate)
    {
        hr = THR(CreateTearOffThunk(this, s_apfnIAuthenticate, NULL, ppv));

        if (hr == S_OK)
        {
            ((IUnknown *)(*ppv))->AddRef();
        }
    }
    else if (guidService == IID_IWindowForBindingUI && iid == IID_IWindowForBindingUI)
    {
        hr = THR(CreateTearOffThunk(this, s_apfnIWindowForBindingUI, NULL, ppv));

        if (hr == S_OK)
        {
            ((IUnknown *)(*ppv))->AddRef();
        }
    }
    else if ( guidService == IID_IAccessible )
    {
        // delegate to the top level document's QueryService handling code.
        
        // Should we protect against a passivation situation ?? (FerhanE)
        Assert(_pWindowPrimary);

        hr = THR(_pWindowPrimary->Document()->QueryService(guidService, iid, ppv));
    }
    else if ( guidService == IID_IDocHostUIHandler )
    {
        if (!_pHostUIHandler)
        {
            hr = E_NOINTERFACE;
            goto Cleanup;
        }

        *ppv = _pHostUIHandler;
        _pHostUIHandler->AddRef();
        hr = S_OK;
    }    
    else if (guidService == IID_ISelectionServices && iid == IID_ISelectionServices )
    {
        AssertSz(FALSE, "QueryServices for IID_ISelectionServices no longer support");
        hr = E_INVALIDARG;
    }
    else if (guidService == SID_SHTMLEditServices && iid == IID_IHTMLEditServices )
    {
        IHTMLEditor *pEd = GetHTMLEditor(TRUE);

        if (pEd != NULL)
            hr = THR( pEd->QueryInterface( IID_IHTMLEditServices, (void**) ppv ));
        else
        {
            *ppv = NULL ;
            hr = E_FAIL;
            goto Cleanup;
        }    
    }    
    else if (IID_IElementNamespaceTable == guidService)
    {
        hr = THR(EnsureExtendedTagTableHost());
        if (hr)
            goto Cleanup;

        hr = THR(_pExtendedTagTableHost->QueryInterface(iid, ppv));
    }
    else if (IID_IEnumPrivacyRecords == guidService)
    {
        *ppv = (void*)new(Mt(CEnumPrivacyRecords)) CEnumPrivacyRecords(_pPrivacyList);
        if (!*ppv)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        hr = S_OK;
        goto Cleanup;
    }
    else if (   guidService == IID_IPrivacyServices )
    {
        hr = THR(PrivateQueryInterface(iid, ppv));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

#if DBG==1
    if (guidService != CLSID_HTMLDocument)
    {
        DbgTrackItf(iid, "CDoc::QS", FALSE, ppv);
    }
#endif

Cleanup:
    RRETURN_NOTRACE(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetUniqueIdentifier
//
//  Synopsis:   Gets a unique ID for the control.  If possible, the form
//              coordinates with its container through the IGetUniqueID
//              service to get an ID unique within the container.
//
//  Arguments:  [pstr]      The string to set into
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDoc::GetUniqueIdentifier(CStr *pstr)
{
    TCHAR   ach[64];
    HRESULT hr;

    memset(ach, 0, sizeof(ach));

    // Prefix with id_ because scriptlet code
    // doesn't currently like ID's that are all digits
    hr = THR(Format(0, ach, ARRAY_SIZE(ach), UNIQUE_NAME_PREFIX _T("<0d>"), (long)++_ID));
    if (hr)
        goto Cleanup;

    hr = THR(pstr->Set(ach));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\fscroll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       scroll.cxx
//
//  Contents:   Contains CDoc methods related to scrolling behavior.
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Scroll
//
//  Synopsis:   Scrolls the form.
//
//  Note:       A single scroll event is fired.
//
//--------------------------------------------------------------------------

#if 0
STDMETHODIMP
CDoc::Scroll(VARIANT varXAction, VARIANT varYAction)
{

    HRESULT             hr = S_OK;
    VARIANT *           pvar;
    VARIANT             var;
    UINT                uCode;
    long                lPos;
    int                 i;
    BOOL                fScroll;
    long                dxl = 0;
    long                dyl = 0;
    fmScrollAction      xAction = fmScrollActionNoChange;
    fmScrollAction      yAction = fmScrollActionNoChange;

    for (i = 0; i < 2; i++)
    {
        lPos = 0;
        fScroll = TRUE;

        pvar = (i == 0 ? &varXAction : &varYAction);
        if (pvar->vt == VT_ERROR)
            continue;

        VariantInit(&var);
        hr = THR(VariantChangeTypeSpecial(&var, pvar, VT_I4));
        if (hr)
            goto Cleanup;

        if (i == 0)
        {
            xAction = (fmScrollAction) V_I4(&var);
        }
        else
        {
            yAction = (fmScrollAction) V_I4(&var);
        }

        switch(V_I4(&var))
        {
        case fmScrollActionLineUp:
            uCode = SB_LINEUP;
            break;

        case fmScrollActionLineDown:
            uCode = SB_LINEDOWN;
            break;

        case fmScrollActionPageUp:
            uCode = SB_PAGEUP;
            break;

        case fmScrollActionPageDown:
            uCode = SB_PAGEDOWN;
            break;

        case fmScrollActionBegin:
            uCode = SB_THUMBPOSITION;
            break;

        case fmScrollActionEnd:
            uCode = SB_THUMBPOSITION;
            lPos = LONG_MAX;
            break;

        case fmScrollActionNoChange:
            fScroll = FALSE;
            break;

        case fmScrollActionAbsoluteChange:
            uCode = SB_THUMBPOSITION;
            break;

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (fScroll)
        {
            DYNCAST(C2DSite, _RootSite._pElemClient)->OnScrollHelper(
                    i,
                    uCode,
                    lPos,
                    (i == 0 ? &dxl : &dyl));
        }
    }

    hr = THR(_RootSite.ScrollBy(dxl, dyl, xAction, yAction));

Cleanup:
    RRETURN(SetErrorInfo(hr));
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\history.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       history.cxx
//
//  Contents:   Implementation of COmLocation, COmHistory and COmNavigator objects.
//
//  Synopsis:   CWindow uses instances of this class to provide expando properties
//              to the browser impelemented window.location, window.history, and
//              window.navigator objects.
//
//              The typelib for those objects are in mshtml.dll which we use via the
//              standard CBase mechanisms and the CLASSDESC specifiers.
//              The browser's implementation of those objects are the only interface
//              to those objects that is ever exposed externally.  The browser delegates
//              to us for the few calls that require our expando support.
//
//              Instances of these classes are also used to provide minimal implementation
//              for non-browser scenarios like Athena
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "history.hdl"

MtDefine(COmLocation, ObjectModel, "COmLocation")
MtDefine(COmLocationGetUrlComponent, Utilities, "COmLocation::GetUrlComponent")
MtDefine(COmHistory, ObjectModel, "COmHistory")
MtDefine(COmNavigator, ObjectModel, "COmNavigator")
MtDefine(COpsProfile, ObjectModel, "COpsProfile")
MtDefine(CPlugins, ObjectModel, "CPlugins")
MtDefine(CMimeTypes, ObjectModel, "CMimeTypes")

//+-------------------------------------------------------------------------
//
//  COmLocation - implementation for the window.location object
//
//--------------------------------------------------------------------------

COmLocation::COmLocation(CWindow *pWindow)
{
    Assert(pWindow);
    _pWindow = pWindow;
}

ULONG COmLocation::PrivateAddRef(void)
{
    return _pWindow->SubAddRef();
}

ULONG COmLocation::PrivateRelease(void)
{
    return _pWindow->SubRelease();
}

HRESULT
COmLocation::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLLocation, NULL)

        default:
            if (iid == CLSID_HTMLLocation)
            {
                *ppv = this;
                return S_OK;
            }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

const COmLocation::CLASSDESC COmLocation::s_classdesc =
{
    &CLSID_HTMLLocation,                 // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    0,                                   // _pcpi
    0,                                   // _dwFlags
    &IID_IHTMLLocation,                  // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};



HRESULT
COmLocation::GetUrlComponent(BSTR *pstrComp, URLCOMP_ID ucid, TCHAR **ppchUrl, DWORD dwFlags)
{
    HRESULT  hr = S_OK;
    TCHAR    cBuf[pdlUrlLen];
    TCHAR  * pchNewUrl = cBuf;
    CStr     cstrFullUrl;

    // make sure we have at least one place to return a value
    Assert(!(pstrComp && ppchUrl));
    if (!pstrComp && !ppchUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (ppchUrl)
        *ppchUrl = NULL;
    else
        *pstrComp = NULL;

    // Get the expanded string
    //
    hr = _pWindow->_pDocument->GetMarkupUrl(&cstrFullUrl, TRUE);
    if (hr)
        goto Cleanup;

    // Should we call this even if URLCOMP_WHOLE is requested.  I'm not
    // sure what shdocvw did...
    //
    hr = CMarkup::ExpandUrl(
            _pWindow->_pMarkup,
            cstrFullUrl,
            ARRAY_SIZE(cBuf), pchNewUrl, NULL);

    if (hr || !*pchNewUrl)
        goto Cleanup;

    // if asking for whole thing, just set return param
    if (ucid == URLCOMP_WHOLE)
    {
        if (ppchUrl)
        {
            hr = THR(MemAllocString(Mt(COmLocationGetUrlComponent),
                        pchNewUrl, ppchUrl));
            pchNewUrl = NULL;          // to avoid cleanup
        }
        else
        {
            hr = THR(FormsAllocString(pchNewUrl, pstrComp));
        }
    }
    else
    {
        // we want a piece, so split it up.
        CStr cstrComponent;
        BOOL fUseOmLocationFormat = ((_pWindow->Doc()->_pTopWebOC && _pWindow->_pMarkup->IsPrimaryMarkup()) || _pWindow->GetFrameSite());

        hr = THR(GetUrlComponentHelper(pchNewUrl, &cstrComponent, dwFlags, ucid, fUseOmLocationFormat));
        if (hr)
            goto Cleanup;

        if (ppchUrl)
        {
            if (cstrComponent)
                hr = THR(MemAllocString(Mt(COmLocationGetUrlComponent),
                        cstrComponent, ppchUrl));
            else
                *ppchUrl = NULL;
        }
        else
        {
            hr = THR(cstrComponent.AllocBSTR(pstrComp));
        }
    }

Cleanup:
    RRETURN (hr);
}

//+-----------------------------------------------------------
//
//  Member  : SetUrlComponenet
//
//  Synopsis    : field the various component setting requests
//
//-----------------------------------------------------------

HRESULT
COmLocation::SetUrlComponent(const BSTR bstrComp,
                             URLCOMP_ID ucid,
                             BOOL fDontUpdateTravelLog, /*=FALSE*/
                             BOOL fReplaceUrl /*=FALSE*/)
{
    HRESULT hr;

    // if set_href, just set it
    if (ucid == URLCOMP_WHOLE)
    {
        hr = THR(_pWindow->FollowHyperlinkHelper(bstrComp, 0, CDoc::FHL_SETURLCOMPONENT |
                                                              ( fDontUpdateTravelLog ?  CDoc::FHL_DONTUPDATETLOG : 0 ) |
                                                              ( fReplaceUrl ? CDoc::FHL_REPLACEURL : 0 ) ));
    }
    else
    {
        TCHAR * pchOldUrl = NULL;
        TCHAR   achUrl[pdlUrlLen];

        // get the old url
        hr = THR(GetUrlComponent(NULL, URLCOMP_WHOLE, &pchOldUrl, 0));

        if (hr || !pchOldUrl)
            goto Cleanup;

        // expand it if necessary
        if ((ucid != URLCOMP_HASH) && (ucid != URLCOMP_SEARCH))
        {
            // and set the appropriate component
            hr = THR(SetUrlComponentHelper(pchOldUrl,
                                           achUrl,
                                           ARRAY_SIZE(achUrl),
                                           &bstrComp,
                                           ucid));
        }
        else
        {
            hr = THR(ShortCutSetUrlHelper(pchOldUrl,
                                   achUrl,
                                   ARRAY_SIZE(achUrl),
                                   &bstrComp,
                                   ucid,
                                   TRUE));  // use OmLocation format that is
                                            // compatible with SHDOCVW 5.01 implementation
        }

        // free the old url.
        if (pchOldUrl)
            MemFreeString(pchOldUrl);

        if (hr)
            goto Cleanup;

        hr = THR(_pWindow->FollowHyperlinkHelper(achUrl, 0, CDoc::FHL_SETURLCOMPONENT |
                                                            ( fDontUpdateTravelLog ?  CDoc::FHL_DONTUPDATETLOG : 0 ) |
                                                            ( fReplaceUrl ? CDoc::FHL_REPLACEURL : 0 ) ));
        if (hr)
            goto Cleanup;

        IGNORE_HR(_pWindow->Document()->Fire_PropertyChangeHelper(DISPID_CDocument_location,
                                                                  0,
                                                                  (PROPERTYDESC *)&s_propdescCDocumentlocation));
    }

Cleanup:
    RRETURN(hr);
}

HRESULT COmLocation::put_href(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_WHOLE)));
}

HRESULT COmLocation::put_hrefInternal(BSTR v, BOOL fDontUpdateTravelLog, BOOL fReplaceUrl )
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_WHOLE, fDontUpdateTravelLog , fReplaceUrl )));
}


HRESULT COmLocation::get_href(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_WHOLE, NULL, 0)));
}

HRESULT COmLocation::put_protocol(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_PROTOCOL)));
}

HRESULT COmLocation::get_protocol(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_PROTOCOL, NULL, 0)));
}

HRESULT COmLocation::put_host(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_HOST)));
}

HRESULT COmLocation::get_host(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_HOST, NULL, 0)));
}

HRESULT COmLocation::put_hostname(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_HOSTNAME)));
}

HRESULT COmLocation::get_hostname(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_HOSTNAME, NULL, 0)));
}

HRESULT COmLocation::put_port(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_PORT)));
}

HRESULT COmLocation::get_port(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_PORT, NULL, 0)));
}

HRESULT COmLocation::put_pathname(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_PATHNAME)));
}

HRESULT COmLocation::get_pathname(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_PATHNAME, NULL, 0)));
}

HRESULT COmLocation::put_search(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_SEARCH)));
}

HRESULT COmLocation::get_search(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_SEARCH, NULL, 0)));
}

HRESULT COmLocation::put_hash(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_HASH)));
}

HRESULT COmLocation::get_hash(BSTR *p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_HASH, NULL, 0)));
}

HRESULT COmLocation::reload(VARIANT_BOOL flag)
{
    LONG lOleCmdidf;

    if (flag)
        lOleCmdidf = OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_CLEARUSERINPUT|OLECMDIDF_REFRESH_THROUGHSCRIPT;
    else
        lOleCmdidf = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT|OLECMDIDF_REFRESH_THROUGHSCRIPT;

        // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
        // released while running script
        RRETURN(SetErrorInfo(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                              ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                              lOleCmdidf, FALSE, "COmWindowProxy::ExecRefreshCallback")));
}

HRESULT COmLocation::replace(BSTR bstr)
{
    HRESULT hr = S_OK;

    // 5.0 compat, don't allow location.replace if we are in a dialog
    if (   _pWindow
        && _pWindow->_pMarkup
        && !_pWindow->_pMarkup->Doc()->_fInHTMLDlg)
    {
        hr = THR(put_hrefInternal(bstr, TRUE, TRUE  ));
    }

    RRETURN( hr );
}

HRESULT COmLocation::assign(BSTR bstr)
{
    RRETURN(put_href(bstr));
}

HRESULT COmLocation::toString(BSTR * pbstr)
{
    RRETURN(get_href(pbstr));
}

//+-------------------------------------------------------------------------
//
//  COmHistory - implementation for the window.history object
//
//--------------------------------------------------------------------------

COmHistory::COmHistory(CWindow *pWindow)
{
    Assert(pWindow);
    _pWindow = pWindow;
}

ULONG COmHistory::PrivateAddRef(void)
{
    return _pWindow->SubAddRef();
}

ULONG COmHistory::PrivateRelease(void)
{
    return _pWindow->SubRelease();
}

HRESULT COmHistory::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)

    default:
        if (iid == IID_IOmHistory)
            hr = THR(CreateTearOffThunk(this, COmHistory::s_apfnIOmHistory, NULL, ppv));
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

const COmHistory::CLASSDESC COmHistory::s_classdesc =
{
    &CLSID_HTMLHistory,                  // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    0,                                   // _pcpi
    0,                                   // _dwFlags
    &IID_IOmHistory,                     // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};

//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::get_length
//
//  Synopsis : Returns the number of entries in the history list
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::get_length(short * pLen)
{
    *pLen = (short)_pWindow->Doc()->NumTravelEntries();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::back
//
//  Synopsis : Navigates back in the history list
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::back(VARIANT * pvarDistance)
{
    //
    // Netscape ignores all errors from these navigation functions
    //
    IGNORE_HR(_pWindow->Doc()->Travel(TLOG_BACK));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::forward
//
//  Synopsis : Navigates forward in the history list
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::forward(VARIANT * pvarDistance)
{
    //
    // Netscape ignores all errors from these navigation functions
    //
    IGNORE_HR(_pWindow->Doc()->Travel(TLOG_FORE));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method   : COmHistory::go
//
//  Synopsis : Navigates to the offset or URL in the history as
//             specified by pvarDistance
//
//----------------------------------------------------------------------------

HRESULT
COmHistory::go(VARIANT * pvarDistance)
{
    //
    // Netscape ignores all errors from these navigation functions
    //
    // Parameter is optional.  If not present, just refresh.
    if (VT_ERROR == pvarDistance->vt || DISP_E_PARAMNOTFOUND == pvarDistance->scode)
    {
        // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
        // released while running script
        IGNORE_HR(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                              ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                              OLECMDIDF_REFRESH_NO_CACHE, FALSE, "COmWindowProxy::ExecRefreshCallback"));
        goto Cleanup;
    }

    // Change type to short if possible.
    //
    if (!VariantChangeType(pvarDistance, pvarDistance, NULL, VT_I2))
    {
        //
        // If 0, just call Refresh
        //
        if (0 == pvarDistance->iVal)
        {
            // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
            // released while running script
            IGNORE_HR(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                                  ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                  OLECMDIDF_REFRESH_NO_CACHE, FALSE, "COmWindowProxy::ExecRefreshCallback"));
            goto Cleanup;
        }

        IGNORE_HR(_pWindow->Doc()->Travel(pvarDistance->iVal));
    }
    else
    {
        // Now see if it's a string.
        //
        if (VT_BSTR == pvarDistance->vt)
        {
            // Refresh if the URL wasn't specified
            if (!pvarDistance->bstrVal)
            {
                // NOTE (lmollico): calling ExecRefresh synchronously could cause the scriptcollection to be
                // released while running script
                IGNORE_HR(GWPostMethodCall(_pWindow->_pMarkup->Window(),
                                      ONCALL_METHOD(COmWindowProxy, ExecRefreshCallback, execrefreshcallback),
                                      OLECMDIDF_REFRESH_NO_CACHE, FALSE, "COmWindowProxy::ExecRefreshCallback"));
                goto Cleanup;
            }

            IGNORE_HR(_pWindow->Doc()->Travel(_pWindow->_pMarkup->GetCodePage(), pvarDistance->bstrVal));
        }
    }

Cleanup:
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  COmNavigator - implementation for the window.navigator object
//
//--------------------------------------------------------------------------

COmNavigator::COmNavigator(CWindow *pWindow)
{
    Assert(pWindow);
    _pWindow = pWindow;

    _pPluginsCollection = NULL;
    _pMimeTypesCollection = NULL;
    _pOpsProfile = NULL;
}

COmNavigator::~COmNavigator()
{
    super::Passivate();
    delete _pPluginsCollection;
    delete _pMimeTypesCollection;
    delete _pOpsProfile;
}

ULONG COmNavigator::PrivateAddRef(void)
{
    return _pWindow->SubAddRef();
}

ULONG COmNavigator::PrivateRelease(void)
{
    return _pWindow->SubRelease();
}

HRESULT
COmNavigator::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr=S_OK;

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
    default:
        if (iid == IID_IOmNavigator)
            hr = THR(CreateTearOffThunk(this, COmNavigator::s_apfnIOmNavigator, NULL, ppv));
    }

    if (!hr)
    {
        if (*ppv)
            (*(IUnknown **)ppv)->AddRef();
        else
            hr = E_NOINTERFACE;
    }
    RRETURN(hr);
}

const COmNavigator::CLASSDESC COmNavigator::s_classdesc =
{
    &CLSID_HTMLNavigator,                // _pclsid
    0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
    0,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    0,                                   // _pcpi
    0,                                   // _dwFlags
    &IID_IOmNavigator,                   // _piidDispinterface
    &s_apHdlDescs,                       // _apHdlDesc
};

void DeinitUserAgentString(THREADSTATE *pts)
{
    pts->cstrUserAgent.Free();
}

HRESULT EnsureUserAgentString()
{
    HRESULT hr = S_OK;
    TCHAR   szUserAgent[MAX_PATH];  // URLMON says the max length of the UA string is MAX_PATH
    DWORD   dwSize = MAX_PATH;

    szUserAgent[0] = '\0';

    if (!TLS(cstrUserAgent))
    {
        hr = ObtainUserAgentStringW(0, szUserAgent, &dwSize);
        if (hr)
            goto Cleanup;

        hr = (TLS(cstrUserAgent)).Set(szUserAgent);
    }

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_appCodeName(BSTR *p)
{
    HRESULT hr;
    hr = THR(EnsureUserAgentString());
    if (hr)
        goto Cleanup;

    Assert(!!TLS(cstrUserAgent));
    hr = THR(FormsAllocStringLen(TLS(cstrUserAgent), 7, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_appName(BSTR *p)
{
    HRESULT hr;
    // TODO (sramani): Need to replace hard coded string with value from registry when available.
    hr = THR(FormsAllocString(_T("Microsoft Internet Explorer"), p));
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_appVersion(BSTR *p)
{
    HRESULT hr;
    hr = THR(EnsureUserAgentString());
    if (hr)
        goto Cleanup;

    Assert(!!TLS(cstrUserAgent));
    hr = THR(FormsAllocString(TLS(cstrUserAgent) + 8, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_userAgent(BSTR *p)
{
    HRESULT hr;

    hr = THR(EnsureUserAgentString());
    if (hr)
        goto Cleanup;

    Assert(!!TLS(cstrUserAgent));
    (TLS(cstrUserAgent)).AllocBSTR(p);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_cookieEnabled(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;
    BOOL    fAllowed;

    if (p)
    {
        hr = THR(_pWindow->_pMarkup->ProcessURLAction(URLACTION_COOKIES_ENABLED, &fAllowed)); //which markup?
        if (!hr)
            *p = fAllowed ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
        hr = E_POINTER;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
COmNavigator::javaEnabled(VARIANT_BOOL *enabled)
{
    HRESULT hr;
    BOOL    fAllowed;

    hr = THR(_pWindow->_pMarkup->ProcessURLAction(URLACTION_JAVA_PERMISSIONS, &fAllowed));
    if (hr)
        goto Cleanup;

    if (enabled)
    {
        *enabled = fAllowed ?  VARIANT_TRUE : VARIANT_FALSE;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
COmNavigator::taintEnabled(VARIANT_BOOL *penabled)
{
    HRESULT hr = S_OK;

    if(penabled != NULL)
    {
        *penabled = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    RRETURN(hr);
}


HRESULT COmNavigator::toString(BSTR * pbstr)
{
    RRETURN(super::toString(pbstr));
}

//+-----------------------------------------------------------------
//
//  members : get_mimeTypes
//
//  synopsis : IHTMLELement implementaion to return the mimetypes collection
//
//-------------------------------------------------------------------

HRESULT
COmNavigator::get_mimeTypes(IHTMLMimeTypesCollection **ppMimeTypes)
{
    HRESULT     hr;

    if (ppMimeTypes == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppMimeTypes = NULL;

    if(_pMimeTypesCollection == NULL)
    {
        // create the collection
        _pMimeTypesCollection = new CMimeTypes();
        if (_pMimeTypesCollection == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(_pMimeTypesCollection->QueryInterface(IID_IHTMLMimeTypesCollection,
        (VOID **)ppMimeTypes));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-----------------------------------------------------------------
//
//  members : get_plugins
//
//  synopsis : IHTMLELement implementaion to return the filter collection
//
//-------------------------------------------------------------------

HRESULT
COmNavigator::get_plugins(IHTMLPluginsCollection **ppPlugins)
{
    HRESULT     hr;

    if (ppPlugins == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppPlugins = NULL;

    //Get existing Plugins Collection or create a new one
    if (_pPluginsCollection == NULL)
    {
        _pPluginsCollection = new CPlugins();
        if (_pPluginsCollection == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR_NOTRACE(_pPluginsCollection->QueryInterface(IID_IHTMLPluginsCollection,
        (VOID **)ppPlugins));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
COmNavigator::get_userProfile(IHTMLOpsProfile **ppOpsProfile)
{
    return  get_opsProfile(ppOpsProfile);
}

//+-----------------------------------------------------------------
//
//  members : get_opsProfile
//
//  synopsis : IHTMLOpsProfile implementaion to return the profile object.
//
//-------------------------------------------------------------------

HRESULT
COmNavigator::get_opsProfile(IHTMLOpsProfile **ppOpsProfile)
{
    HRESULT     hr;

    if (ppOpsProfile == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppOpsProfile = NULL;

    //Get existing opsProfile object or create a new one

    if (_pOpsProfile == NULL)
    {
        _pOpsProfile = new COpsProfile();
        if (_pOpsProfile == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR_NOTRACE(_pOpsProfile->QueryInterface(IID_IHTMLOpsProfile,
        (VOID **)ppOpsProfile));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT COmNavigator::get_cpuClass(BSTR *p)
{
    HRESULT hr = S_OK; // For Now
    DWORD dwArch = 0;

    if(!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    SYSTEM_INFO SysInfo;
    ::GetSystemInfo(&SysInfo);

    // mihaii NOTE:
    // I temporarly changed the switch statement below into
    // an if-then-else because of an optimization bug
    // in the 64 bit compiler

    /*
    switch(SysInfo.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        *p = SysAllocString(_T("x86"));
        break;
    case PROCESSOR_ARCHITECTURE_AMD64:
        *p = SysAllocString(_T("AMD64"));
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        *p = SysAllocString(_T("IA64"));
        break;
    default:
        *p = SysAllocString(_T("Other"));
        break;
    }
    */

    dwArch = SysInfo.wProcessorArchitecture;

    if (dwArch == PROCESSOR_ARCHITECTURE_INTEL)
    {
        *p = SysAllocString(_T("x86"));
    }
    else if (dwArch == PROCESSOR_ARCHITECTURE_AMD64)
    {
        *p = SysAllocString(_T("AMD64"));
    }
    else if (dwArch == PROCESSOR_ARCHITECTURE_IA64)
    {
        *p = SysAllocString(_T("IA64"));
    }
    else
    {
        *p = SysAllocString(_T("Other"));
    }

    if(*p == NULL)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_systemLanguage(BSTR *p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    hr = THR(mlang().GetRfc1766FromLcid(::GetSystemDefaultLCID(), p));

Cleanup:
    RRETURN(hr);
}

HRESULT
COmNavigator::get_browserLanguage(BSTR *p)
{
    HRESULT hr;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    hr = THR(mlang().GetRfc1766FromLcid(MAKELCID(MLGetUILanguage(), SORT_DEFAULT), p));

Cleanup:
    RRETURN(hr);
}


HRESULT
COmNavigator::get_userLanguage(BSTR *p)
{
    HRESULT hr;

    if(!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    hr = THR(mlang().GetRfc1766FromLcid(::GetUserDefaultLCID(), p));

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_platform(BSTR *p)
{
    HRESULT hr = S_OK;

    // Nav compatability item, returns the following in Nav:-
    // Win32,Win16,Unix,Motorola,Max68k,MacPPC
    TCHAR *pszPlatform =
#ifdef WIN16
        _T("Win16");
#else
#ifdef WINCE
        _T("WinCE");    // Invented - obviously not a Nav compat issue!
#else
#ifndef UNIX
        _T("Win32");
#else
#ifndef ux10
        *p = SysAllocString ( L"SunOS");
#else
        *p = SysAllocString ( L"HP-UX");
#endif // ux10
#endif // unix

#endif // WINCE
#endif // WIN16

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = NULL;

    hr = THR(FormsAllocString ( pszPlatform, p ));
Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_appMinorVersion(BSTR *p)
{
    HKEY hkInetSettings;
    long lResult;
    HRESULT hr = S_FALSE;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = NULL;

    lResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                        _T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                        &hkInetSettings );

    if( ERROR_SUCCESS == lResult )
    {
        DWORD dwType;
        DWORD size = pdlUrlLen;
        BYTE  buffer[pdlUrlLen];

        // If this is bigger than MAX_URL_STRING the registry is probably hosed.
        lResult = RegQueryValueEx( hkInetSettings, _T("MinorVersion"), 0, &dwType, buffer, &size );

        RegCloseKey(hkInetSettings);

        if( ERROR_SUCCESS == lResult && dwType == REG_SZ )
        {
            // Just figure out the real length since 'size' is ANSI bytes required.
            *p = SysAllocString( (LPCTSTR)buffer );
            hr = *p ? S_OK : E_OUTOFMEMORY;
        }
    }

    if ( hr )
    {
        *p = SysAllocString ( L"0" );
        hr = *p ? S_OK : E_OUTOFMEMORY;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT COmNavigator::get_connectionSpeed(long *p)
{
    *p = NULL;
    RRETURN(E_NOTIMPL);
}

extern BOOL IsGlobalOffline();

HRESULT COmNavigator::get_onLine(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if(!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = (IsGlobalOffline()) ? VB_FALSE : VB_TRUE;

Cleanup:
     RRETURN(hr);
}


//+-----------------------------------------------------------------
//
//  CPlugins implementation.
//
//-------------------------------------------------------------------

const CBase::CLASSDESC CPlugins::s_classdesc =
{
    &CLSID_CPlugins,                    // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    &IID_IHTMLPluginsCollection,        // _piidDispinterface
    &s_apHdlDescs                       // _apHdlDesc
};

HRESULT
CPlugins::get_length(LONG *pLen)
{
    HRESULT hr = S_OK;
    if(pLen != NULL)
        *pLen = 0;
    else
        hr =E_POINTER;

    RRETURN(hr);
}

HRESULT
CPlugins::refresh(VARIANT_BOOL fReload)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member  : CPlugins::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CPlugins::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            if (iid == IID_IHTMLPluginsCollection)
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLPluginsCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


const CBase::CLASSDESC CMimeTypes::s_classdesc =
{
    &CLSID_CMimeTypes,                  // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    &IID_IHTMLMimeTypesCollection,      // _piidDispinterface
    &s_apHdlDescs                       // _apHdlDesc
};



HRESULT
CMimeTypes::get_length(LONG *pLen)
{
    HRESULT hr = S_OK;
    if(pLen != NULL)
        *pLen = 0;
    else
        hr = E_POINTER;

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member  : CMimeTypes::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CMimeTypes::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            if ( iid == IID_IHTMLMimeTypesCollection )
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLMimeTypesCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+-----------------------------------------------------------------
//
//  COpsProfile implementation.
//
//-------------------------------------------------------------------

const CBase::CLASSDESC COpsProfile::s_classdesc =
{
    &CLSID_COpsProfile,                 // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                               // _pcpi
    0,                                  // _dwFlags
    &IID_IHTMLOpsProfile,               // _piidDispinterface
    &s_apHdlDescs                       // _apHdlDesc
};


HRESULT
COpsProfile::getAttribute(BSTR name, BSTR *value)
{
    HRESULT hr = S_OK;
    // Should never get called.

    // But this gets called right now and
    // is likely to not get called once this
    // is implemented in the new shdocvw.dll.

    if ( value != NULL)
    {
        *value = NULL;
    }
    else
    {
        hr = E_POINTER;
    }
    RRETURN(hr);
}

HRESULT
COpsProfile::setAttribute(BSTR name, BSTR value, VARIANT prefs, VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (p != NULL)
    {
        *p = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
COpsProfile::addReadRequest(BSTR name, VARIANT reserved, VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (p != NULL)
    {
        *p = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}


HRESULT
COpsProfile::addRequest(BSTR name, VARIANT reserved, VARIANT_BOOL *p)
{
    return addReadRequest(name,reserved,p);
}

HRESULT
COpsProfile::clearRequest()
{
    return S_OK;
}

HRESULT
COpsProfile::doRequest(VARIANT usage, VARIANT fname,
                       VARIANT domain, VARIANT path, VARIANT expire,
                       VARIANT reserved)
{
    return S_OK;
}

HRESULT
COpsProfile::doReadRequest(VARIANT usage, VARIANT fname,
                           VARIANT domain, VARIANT path, VARIANT expire,
                           VARIANT reserved)
{
    return S_OK;
}

HRESULT
COpsProfile::commitChanges(VARIANT_BOOL *p)
{
    HRESULT hr = S_OK;

    if (p != NULL)
    {
        *p = VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

HRESULT
COpsProfile::doWriteRequest(VARIANT_BOOL *p)
{
    return commitChanges(p);
}



//+---------------------------------------------------------------
//
//  Member  : COpsProfile::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
COpsProfile::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
        {
            if (iid == IID_IHTMLOpsProfile)
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLOpsProfile, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\hlink.cxx ===
//+------------------------------------------------------------------------
//
//  File:       hlink.cxx
//
//  Contents:   CDoc hyperlinking support.
//              FollowHyperlink() for linking out
//              IHlinkTarget for linking in
//              ITargetFrame for frame targeting
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"    // for cbindtask
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"        // for std hyperlink object
#endif

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"     // for ez hyperlink api
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"   // for url caching api
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"  // for _pcollectioncache
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"    // for itargetframe, itargetembedding
#endif

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include "exdisp.h"     // for iwebbrowserapp
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_URLHIST_H_
#define X_URLHIST_H_
#include "urlhist.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_BOOKMARK_HXX_
#define X_BOOKMARK_HXX_
#include "bookmark.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx" // for IHtmlLoadOptions, et al..
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_USER32_HXX_
#define X_USER32_HXX_
#include "user32.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif




extern BOOL g_fInAutoCad;
extern BOOL g_fInLotusNotes;

ExternTag(tagSecurityContext);
PerfDbgTag(tagNavigate, "Doc", "Measure FollowHyperlink");
MtDefine(FindTargetWindow, Locals, "FindTargetWindow (base target string)")
MtDefine(HlinkBaseTarget, Locals, "Hlink (base target string)")
MtDefine(CTaskLookForBookmark, Utilities, "CTaskLookForBookmark")

///////////////////////////////////////

DYNLIB g_dynlibSHDOCVW = { NULL, NULL, "SHDOCVW.DLL" };

#define WRAPIT_SHDOCVW(fn, a1, a2)\
STDAPI fn a1\
{\
    HRESULT hr;\
    static DYNPROC s_dynproc##fn = { NULL, &g_dynlibSHDOCVW, #fn };\
    hr = THR(LoadProcedure(&s_dynproc##fn));\
    if (hr)\
        goto Cleanup;\
    hr = THR((*(HRESULT (STDAPICALLTYPE *) a1)s_dynproc##fn.pfn) a2);\
Cleanup:\
    RRETURN1(hr, S_FALSE);\
}

WRAPIT_SHDOCVW(HlinkFrameNavigate,
    (DWORD                   grfHLNF,
    LPBC                    pbc,
    IBindStatusCallback *   pibsc,
    IHlink *                pihlNavigate,
    IHlinkBrowseContext *   pihlbc),
    (grfHLNF, pbc, pibsc, pihlNavigate, pihlbc))

WRAPIT_SHDOCVW(HlinkFrameNavigateNHL,
    (DWORD grfHLNF,
    LPBC pbc,
    IBindStatusCallback *pibsc,
    LPCWSTR pszTargetFrame,
    LPCWSTR pszUrl,
    LPCWSTR pszLocation),
    (grfHLNF, pbc, pibsc, pszTargetFrame, pszUrl, pszLocation))

WRAPIT_SHDOCVW(HlinkFindFrame,
    (LPCWSTR pszFrameName,
    LPUNKNOWN *ppunk),
    (pszFrameName, ppunk))

#pragma warning(disable:4706)   // assignment within conditional expression.

BOOL
IsSpecialUrl(LPCTSTR pszURL)
{
    UINT uProt = GetUrlScheme(pszURL);

    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT   == uProt ||
            URL_SCHEME_ABOUT      == uProt);
}

BOOL
IsScriptUrl(LPCTSTR pszURL)
{
    UINT uProt = GetUrlScheme(pszURL);

    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT   == uProt);
}

//----------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------

HRESULT
UnescapeAndTruncateUrl(TCHAR * pchURL, BOOL fRemoveUnescaped /* = TRUE */)
{
    HRESULT   hr = S_OK;
    CStr      cstrSafeUrl;
    TCHAR   * pch;
    TCHAR     achUrl[pdlUrlLen];
    DWORD     dwSize;
    TCHAR *   pchPos = NULL;

    if (!pchURL)
        return S_OK;

    if (IsSpecialUrl(pchURL))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // Copy the URL so we can munge it.
        //
        cstrSafeUrl.Set(pchURL);

        // someone could put in a string like this:
        //     %2501 OR %252501 OR %25252501
        // which, depending on the number of decoding steps, will bypass security
        // so, just keep decoding while there are %s and the string is getting shorter
        UINT uPreviousLen = 0;
        while ((uPreviousLen != cstrSafeUrl.Length()) && _tcschr(cstrSafeUrl, _T('%')))
        {
            uPreviousLen = cstrSafeUrl.Length();
            int nNumPercents;
            int nNumPrevPercents = 0;

            // Reduce the URL
            //
            for (;;)
            {
                // Count the % signs.
                //
                nNumPercents = 0;

                pch = cstrSafeUrl;
                while (pch = _tcschr(pch, _T('%')))
                {
                    pch++;
                    nNumPercents++;
                }

                if (nNumPercents > 0)
                {
                    // QFE 2735 (Georgi XDomain): [alanau]
                    //
                    // If the special URL contains an %00 sequence, then it will be converted to a Null char when
                    // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
                    // sequence, and display a "Permission Denied" script error.
                    //
                    // Moved from above to catch %2500, %252500 ....
                    //
                    pchPos = _tcsstr((TCHAR*) cstrSafeUrl, _T("%00"));

                    if (pchPos)
                    {
                        *pchPos = NULL;
                        hr = E_ACCESSDENIED;
                        goto Cleanup;
                    }
                }

                // If the number of % signs has changed, we've reduced the URL one iteration.
                //
                if (nNumPercents != nNumPrevPercents)
                {
                    // Encode the URL 
                    hr = THR(CoInternetParseUrl(cstrSafeUrl, 
                        PARSE_ENCODE, 
                        0, 
                        achUrl, 
                        ARRAY_SIZE(achUrl), 
                        &dwSize,
                        0));

                    cstrSafeUrl.Set(achUrl);

                    nNumPrevPercents = nNumPercents;
                }
                else
                {
                    // The URL is fully reduced.  Break out of loop.
                    //
                    break;
                }
            }
        }
    }    

Cleanup:

    if (cstrSafeUrl.Length() && 
        (fRemoveUnescaped || cstrSafeUrl.Length() != (unsigned)lstrlen(pchURL)))
    {
        pchPos = _tcsstr(cstrSafeUrl, _T("\1"));

        if (pchPos)
        {
            hr = E_ACCESSDENIED;
            pchURL[pchPos-cstrSafeUrl] = NULL;
        }
    }

    RRETURN(hr);
}

HRESULT
WrapSpecialUrl(TCHAR *pchURL, CStr *pcstrExpandedUrl, const TCHAR *pchDocUrl, BOOL fNonPrivate, BOOL fIgnoreUrlScheme)
{
    HRESULT   hr = S_OK;
    CStr      cstrSafeUrl;
    TCHAR   * pch, * pchPrev;

    if (IsSpecialUrl(pchURL) || fIgnoreUrlScheme)
    {

        hr = UnescapeAndTruncateUrl(pchURL);

        hr = THR(pcstrExpandedUrl->Set(pchURL));
        if (hr)
            goto Cleanup;

        hr = THR(pcstrExpandedUrl->Append( fNonPrivate ? _T("\1\1") : _T("\1")));
        if (hr)
            goto Cleanup;


        // Now copy the pchDocUrl
        //
        cstrSafeUrl.Set(pchDocUrl);


        // Scan the URL to ensure it appears un-spoofed.
        //
        // There may legitimately be multiple '\1' characters in the URL.  However, each one, except the last one
        // should be followed by a "special" URL (javascript:, vbscript: or about:).
        //
        pchPrev = cstrSafeUrl;
        pch = _tcschr(cstrSafeUrl, _T('\1'));
        while (pch)
        {
            pch++;                              // Bump past security marker
            if (*pch == _T('\1'))               // (Posibly two security markers)
                pch++;
                
            if (!IsSpecialUrl(pchPrev))         // If URL is not special
            {
                hr = E_ACCESSDENIED;            // then it's spoofed.
                goto Cleanup;
            }
            pchPrev = pch;
            pch = _tcschr(pch, _T('\1'));
        }

        // Look for escaped %01 strings in the Security Context.
        //
        pch = cstrSafeUrl;
        while (pch = _tcsstr(pch, _T("%01")))
        {
            pch[2] = _T('2');  // Just change the %01 to %02.
            pch += 3;          // and skip over
        }

        hr = THR(pcstrExpandedUrl->Append(cstrSafeUrl));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pcstrExpandedUrl->Set(pchURL));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

#pragma warning(default:4706)   // assignment within conditional expression.

//+---------------------------------------------------------------------------
//
//
//---------------------------------------------------------------------------+
HRESULT
CanNavigateFramesAccrossDomains(COmWindowProxy * pWindow, 
                                const TCHAR *    pchTarget, 
                                const TCHAR *    pchUrlContext)
{
    HRESULT hr = S_OK;

    if (!pWindow->AccessAllowedToNamedFrame(pchTarget))
    {
        CStr cstrCallerUrl;
        DWORD dwPolicy = 0;
        DWORD dwContext = 0;
        DWORD dwPUAF = 0;

        if (pchUrlContext)
        {
            cstrCallerUrl.Set(pchUrlContext);
        }
        else
        {
            cstrCallerUrl.Set(CMarkup::GetUrl(pWindow->Markup()));
        }

        Assert(pWindow->Window());

        if (pWindow->Window()->_fRestricted)
            dwPUAF |= PUAF_ENFORCERESTRICTED;

        if ( !hr && !SUCCEEDED(ZoneCheckUrlEx(cstrCallerUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                          URLACTION_HTML_SUBFRAME_NAVIGATE, dwPUAF, NULL))
            ||  GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
        {
            hr = E_ACCESSDENIED;
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// IsErrorPageToSpecialUrl
//
// If we are navigating from a special Url from a special Url
// Check to see if the source page is an error page.
//
// If we are an error page we have lost the LocationContext,
// because we have a new instance of Trident. The error page
// has local machine zone and Internet zone can have a 
// reference to the page.
//
//---------------------------------------------------------------------------+

BOOL IsErrorPageToSpecialUrl(COmWindowProxy* pWindow,
                             LPCTSTR pchUrl,
                             LPCTSTR pchUrlContext)
{
    if (pWindow && pWindow->Markup())
    {
        LPCTSTR pszSourceUrl  = NULL;

        pszSourceUrl = pWindow->Markup()->Url();

        UINT uProt = GetUrlScheme(pszSourceUrl);

        if ((uProt == URL_SCHEME_RES) &&
            IsSpecialUrl(pchUrl))
        {
            BOOL fIsError = TRUE;

            // If we don't have trident services we could not have trident error pages
            // and we are not hosted in IE. That is why I fail to false
            if (pWindow->Markup()->Doc()->_pTridentSvc)
            {
                HRESULT hr = THR(pWindow->Markup()->Doc()->_pTridentSvc->IsErrorUrl(pszSourceUrl, &fIsError));

                if (FAILED(hr))
                {
                    fIsError = TRUE;
                }

                if (fIsError)
                {
                    if ((pchUrlContext == NULL) ||
                        (_tcslen(pchUrlContext) == 0))
                    {
                        // This is javascript from the error page itself
                        return FALSE;
                    }

                    return TRUE;
                }
            }
        }
    }
    else
    {
        AssertSz(0,"Why do not we have a target window with a markup?");
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FollowHyperlink
//
//  Synopsis:   Hyperlinks the specified target frame to the requested url
//              using ITargetFrame/IHyperlinkTarget of host if possible
//
//  Arguments:  pchURL            : the relative URL
//              pchTarget         : the target string
//              pElementContext   : element whose base should be searched for
//                                  a target name is pchTarget is null.
//              pDwnPost          : CDwnPost to use to post data.
//              fSendAsPost       : TRUE if post should be used.
//              fOpenInNewWindow  : TRUE to open in a new window
//              pWindow           : The window proxy to navigate.
//              ppWindowOut       : output window
//              dwBindf           : options to use while binding, used to
//                                  control refresh for frames
//              dwSecurityCode    : Used to give the appropriate alert when
//                                  sending data over the network.
//              fReplace          : TRUE replaces the current entry in 
//                                  the travel log.
//              ppHTMLWindow2     : The new window to use for navigation.
//              fOpenInNewBrowser : TRUE opens a new browser window.
//              dwFlags           : Misc. FHL_* control flags (this fn has way too many params already!)
//              pchName           : The window name.
//              pStmHistory       : History stream to load.
//              pElementMaster    : Element that will be master of newly created markup/window
//
//----------------------------------------------------------------------------

HRESULT
CDoc::FollowHyperlink(LPCTSTR           pchURL,
                      LPCTSTR           pchTarget,           /* = NULL */
                      CElement *        pElementContext,     /* = NULL */
                      CDwnPost *        pDwnPost,            /* = NULL */
                      BOOL              fSendAsPost,         /* = FALSE */
                      LPCTSTR           pchExtraHeaders,     /* = NULL */
                      BOOL              fOpenInNewWindow,    /* = FALSE */
                      COmWindowProxy  * pWindow,             /* = NULL */
                      COmWindowProxy ** ppWindowOut,         /* = NULL */
                      DWORD             dwBindf,             /* = 0 */
                      DWORD             dwSecurityCode,      /* = ERROR_SUCCESS */
                      BOOL              fReplace,            /* = FALSE */
                      IHTMLWindow2 **   ppHTMLWindow2,       /* = NULL */
                      BOOL              fOpenInNewBrowser,   /* = FALSE */
                      DWORD             dwFlags,             /* = 0 */
                      const TCHAR *     pchName,             /* = NULL */
                      IStream *         pStmHistory,         /* = NULL */
                      CElement *        pElementMaster,      /* = NULL */
                      LPCTSTR           pchUrlContext,       /* = NULL */
                      BOOL *            pfLocalNavigation,   /* = NULL */
                      BOOL *            pfProtocolNavigates, /* = NULL */
                      LPCTSTR           pchLocation,         /* = NULL */
                      LPCTSTR           pchAlternativeCaller /* = NULL */)
{
    PerfDbgLog1(tagNavigate, this, "+CDoc::FollowHyperlink \"%ls\"", pchURL);

    TCHAR *          pchBaseTarget       = NULL;
    IBindCtx *       pBindCtx            = NULL;
    CDwnBindInfo *   pDwnBindInfo        = NULL;
    BOOL             fProtocolNavigates  = TRUE;
    CStr             cstrExpandedUrl;
    CStr             cstrLocation;
    LPCTSTR          pchSubReferer;
    CDwnDoc *        pDwnDocOld          = NULL;
    HRESULT          hr;
    IHTMLWindow2   * pTargetHTMLWindow   = NULL;
    COmWindowProxy * pTargetOmWindow     = NULL;
    IHTMLDocument2 * pDocument           = NULL;
    TARGET_TYPE      eTargetType;
    IUnknown       * pUnkDwnBindInfo     = NULL;
    CMarkup *        pMarkup             = NULL;
    CStr             cstrUrlOriginal;
    BOOL             doZoneCheck         = TRUE;

    LPCTSTR pchCallerUrl = NULL;

    //
    // TODO (yinxie) this is a temporary solution until we clear all the
    // doudt about navigating inside popups
    // if this is a popup doc, no navigation allowed, even inside iframes
    //

    if (_fPopupDoc)
    {
        RRETURN(SetErrorInfo(E_NOTIMPL));
    }

    SetHostNavigation(FALSE);
    _fDelegatedDownload = FALSE;
	
    Assert(pElementContext || pWindow);
  
    if (!pWindow)
    {
        // This is a stress bug fix. pElementContext should be NULL only
        // in stress situations. Therefore, do not remove the above Assert.
        //
        if (pElementContext)
        {
            pMarkup = pElementContext->GetFrameOrPrimaryMarkup();
            pWindow = pMarkup->GetWindowPending();
        }

        // pWindow would be NULL if the Markup for pElementContext is switched
        // thus clearing its Window.
        if (!(pElementContext && pWindow))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else 
    {
        pMarkup = pWindow->Markup();
    }

    Assert (pWindow && pMarkup);

    //
    //  Error pages always have local zone
    //  and special URls inherit there zone from 
    //  the context. If no context is specified, then
    //  the context is that of the souce window.
    //
    
    if (IsErrorPageToSpecialUrl(pWindow,pchURL,pchUrlContext))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    if (dwFlags & (FHL_HYPERLINKCLICK | FHL_SETURLCOMPONENT | FHL_FRAMECREATION))
        dwBindf |= BINDF_HYPERLINK;

    if ((dwFlags & (FHL_FRAMECREATION | FHL_FRAMENAVIGATION)) && pWindow->Window()->_fRestricted)
        dwBindf |= BINDF_ENFORCERESTRICTED;

    if (pDwnPost)
    {
        // this flag is set when posting through this API, no matter if
        // we ultimately do a POST or a GET
        dwBindf |= BINDF_FORMS_SUBMIT;
        dwFlags |= FHL_FORMSUBMIT;
    }

    // Remember the subreferer of this doc

    pDwnDocOld    = pMarkup->GetDwnDoc();
    pchSubReferer = pDwnDocOld ? pDwnDocOld->GetSubReferer() : NULL;

    // If we are given a location, we will use
    // that instead of parsing the URL for it.
    //
    if (pchLocation && *pchLocation)
    {
        IGNORE_HR(THR(cstrLocation.Set(pchLocation)));
    }

    // Determine the expanded url and location.
    hr = THR(DetermineExpandedUrl(
                pchURL,

                // do not expand url if this came from shdocvw (#105737)
                !(dwFlags & FHL_SHDOCVWNAVIGATE),

                pElementContext,
                pMarkup,
                pDwnPost,
                fSendAsPost,
                dwSecurityCode,
                &cstrExpandedUrl,
                &cstrLocation,
                &cstrUrlOriginal,
                &fProtocolNavigates,
                (!pchLocation || !*pchLocation)));  // don't parse the location if we are given one.
    if (hr)
        goto Cleanup;

    // See Windows Bug 491140
    if (GetUrlScheme(LPTSTR(cstrExpandedUrl)) == URL_SCHEME_FILE)
    {
        TCHAR       * expandedUrlTemp = NULL;
        TCHAR       * pchExt = NULL;
        BOOL          allowNav = TRUE;
        TCHAR       * pchQuery = _tcschr(LPTSTR(cstrExpandedUrl), _T('?'));

        expandedUrlTemp = cstrExpandedUrl.TakePch();

        if (pchQuery != NULL)
        {
            *pchQuery = _T('\0');
        }
        pchExt = _tcsrchr(expandedUrlTemp, _T('.'));
        if (pchExt)
        {
            if (_tcsnicmp(pchExt, -1, _T(".url"), 4) == 0)
            {
                allowNav = AllowNavigationToLocalInternetShortcut(expandedUrlTemp);
            }
        }     
        if (pchQuery)
        {
            *pchQuery = _T('?');
        }
        
        cstrExpandedUrl.SetPch(expandedUrlTemp);

        if (allowNav == FALSE)
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    //
    // Check to see if you need to do a Zone elevation check.  Zone elevation check is
    // done for all cases except for top level navigations.
    if ((dwFlags & FHL_NOLOCALMACHINECHECK) || 
        (dwFlags & FHL_SHDOCVWNAVIGATE) || 
        (dwFlags & FHL_LOADHISTORY) ||
        (dwFlags & FHL_SETTARGETPRINTMEDIA) ||
        (dwFlags & FHL_CREATEDOCUMENTFROMURL))
    {
        doZoneCheck = FALSE;
    }

    if (doZoneCheck)
    {
        if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, pchUrlContext, cstrExpandedUrl))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    eTargetType = GetTargetType(pchTarget);

    if (   (TARGET_SEARCH == eTargetType)
        || (TARGET_MEDIA  == eTargetType))
    {
        // Need to block special URLs in case they fail a src/dest
        // security check.
        if (IsSpecialUrl(pchURL))
        {
            if (!pWindow->AccessAllowedToNamedFrame(pchTarget))
           {
               hr = E_ACCESSDENIED;
               goto Cleanup;
           }
        }

        hr = QueryInterface(IID_IHTMLDocument2, (void**)&pDocument);
        if (hr)
            goto Cleanup;

        CLSID clsid = {0};
        if (TARGET_SEARCH == eTargetType)
        {
            clsid = CLSID_SearchBand;
        }
        else if (TARGET_MEDIA == eTargetType)
        {
            clsid = CLSID_MediaBand;
        }

        if (S_OK == NavigateInBand(pDocument,
                            pWindow->_pWindow,
                            clsid,
                            pchURL,
                            cstrExpandedUrl,
                            ppHTMLWindow2))
        {
            goto Cleanup;  // Navigation is complete.
        }
        else
        {
            if (TARGET_MEDIA == eTargetType)
            {
                fOpenInNewBrowser = TRUE;
                pchTarget = NULL;
            }
            else
            {
                pchTarget = _T("_self");
            }
        }
    }

    if (!fOpenInNewBrowser && fProtocolNavigates)
    {
        IWebBrowser2 * pTopWebOC = NULL;

        FindTargetWindow(&pchTarget,
                         &pchBaseTarget,
                         pElementContext,
                         &fOpenInNewBrowser,
                         pWindow,
                         &pTargetOmWindow,
                         &pTargetHTMLWindow,
                         &pTopWebOC,
                         dwFlags);

        // Check if we have security rights to target the top level window the 
        // name belongs to. Even if the name belongs to a frame, it is the top level
        // window that counts.
        hr = THR(CanNavigateFramesAccrossDomains(pWindow, pchTarget, pchUrlContext));
        if (hr)
            goto Cleanup;

        // There was an error finding the target window. This is 
        // usually due to the fact that a link in a band window
        // was clicked that targets the main window and the main
        // window contains a non-html file.
        //
        if (pTopWebOC)
        {
            CVariant cvarUrl(VT_BSTR);

            cstrExpandedUrl.AllocBSTR(&cvarUrl.bstrVal);

            pTopWebOC->Navigate2(&cvarUrl, NULL, NULL, NULL, NULL);
            pTopWebOC->Release();

            goto Cleanup;
        }

        if (ppHTMLWindow2)
        {
            if (pTargetHTMLWindow)
            {
                *ppHTMLWindow2 = pTargetHTMLWindow;
                (*ppHTMLWindow2)->AddRef();
            }  
            else if (pTargetOmWindow)
            {
                hr = THR(pTargetOmWindow->QueryInterface(IID_IHTMLWindow2, (void **) ppHTMLWindow2));
            }
        }

        //
        // If we are not being asked to not find existing windows and we find one, 
        // and if the initial url we received was an empty string, then bail out
        // for compat reasons.
        // We don't want to navigate an existing window to an about:blank if the URL
        // is NULL or empty.
        //
        if ((pTargetOmWindow || pTargetHTMLWindow) && 
            (!pchURL || !*pchURL) && 
            !(dwFlags & CDoc::FHL_HYPERLINKCLICK))
        {
            goto Cleanup;
        }
    }

    // 
    // Clicking on a link within a restricted frame :
    //      - Always open in new window, no in place navigation
    //      - Special URLs can not even open in new window, they fail right away
    //
    if (pWindow->Window() && pWindow->Window()->_fRestricted && (dwFlags & FHL_HYPERLINKCLICK))
    {
        if (IsSpecialUrl(cstrExpandedUrl))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        fOpenInNewBrowser = TRUE;
    }

    // Found target window out of process (hence pTargetHTMLWindow vs. pTargetOmWindow)
    if (pTargetHTMLWindow)
    {
        AssertSz( !pTargetOmWindow, "Shouldn't have both pTargetHTMLWindow and pTargetOmWindow" );        
        Assert((dwFlags & CDoc::FHL_HYPERLINKCLICK) || (pchURL && *pchURL));

        //
        // prepare BindCtx
        //

        // Set up the bind info + context.
        hr = THR(SetupDwnBindInfoAndBindCtx(
                    cstrExpandedUrl,
                    pchSubReferer,
                    pchUrlContext,
                    pDwnPost,
                    fSendAsPost,
                    pchExtraHeaders,
                    pMarkup,
                    &dwBindf,
                    &pDwnBindInfo,
                    &pBindCtx,
                    dwFlags));
        if (hr)
            goto Cleanup;

        hr = THR(DoNavigateOutOfProcess(pTargetHTMLWindow,
                                        cstrExpandedUrl,
                                        cstrLocation,
                                        cstrUrlOriginal,
                                        pBindCtx,
                                        dwFlags));
    }
    else
    {
        if (pTargetOmWindow)
        {
            // make pWindow the navigation target window
            pWindow = pTargetOmWindow;
        }
        else if (ppHTMLWindow2)
        {
            fOpenInNewBrowser = TRUE;
        }

        // Set up the bind info + context.
        hr = THR(SetupDwnBindInfoAndBindCtx(
                    cstrExpandedUrl,
                    pchSubReferer,
                    pchUrlContext,
                    pDwnPost,
                    fSendAsPost,
                    pchExtraHeaders,
                    pMarkup,
                    &dwBindf,
                    &pDwnBindInfo,
                    &pBindCtx,
                    dwFlags));
        if (hr)
            goto Cleanup;
        
        if (pchUrlContext)
        {
            pchCallerUrl = pchUrlContext;
        }
        else if (pchAlternativeCaller) 
        {
            pchCallerUrl = pchAlternativeCaller;
        }
        else
        {
            pchCallerUrl = CMarkup::GetUrl(pWindow->Markup());
        }

        // Finally, navigate to the URL.
        hr = THR(DoNavigate(
                    &cstrExpandedUrl,
                    &cstrLocation,
                    pDwnBindInfo,
                    pBindCtx,
                    pchURL,
                    pchTarget,
                    pWindow,
                    ppWindowOut,
                    fOpenInNewWindow,
                    fProtocolNavigates,
                    fReplace,
                    fOpenInNewBrowser,
                    ppHTMLWindow2,
                    eTargetType,
                    dwFlags,
                    pchName,
                    fSendAsPost,
                    pchExtraHeaders,
                    pStmHistory,
                    cstrUrlOriginal,
                    pElementMaster, 
                    pfLocalNavigation,
                    pchCallerUrl));
    }        

Cleanup:
    if ( pfProtocolNavigates )
    {
        *pfProtocolNavigates = fProtocolNavigates; 
    }
    ReleaseInterface(pUnkDwnBindInfo);
    ReleaseInterface(pBindCtx);
    ReleaseInterface(pTargetHTMLWindow);
    ReleaseInterface(pDocument);
    MemFreeString(pchBaseTarget);

    // Do not release pTargetOmWindow. It's not AddRef'ed

    if (pDwnBindInfo)
        pDwnBindInfo->Release();

    if (S_FALSE == hr)
        hr = S_OK;

    PerfDbgLog(tagNavigate, this, "-CDoc::FollowHyperlink");

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DetermineExpandedUrl
//
//  Synopsis:   determines the extended url
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::DetermineExpandedUrl(LPCTSTR           pchURL,
                           BOOL              fExpand,
                           CElement *        pElementContext,
                           CMarkup *         pMarkup,
                           CDwnPost *        pDwnPost,
                           BOOL              fSendAsPost,
                           DWORD             dwSecurityCode,
                           CStr *            pcstrExpandedUrl,
                           CStr *            pcstrLocation,
                           CStr *            pcstrUrlOriginal,
                           BOOL *            pfProtocolNavigates,
                           BOOL              fParseLocation
                          )
{
    HRESULT hr;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchExpandedUrl = cBuf;
    UINT    uProt;
    CStr    cstrTmp;

    Assert(pcstrExpandedUrl && pcstrLocation && pfProtocolNavigates);
    Assert(pMarkup || pElementContext);

    if (fExpand)
    {
        hr = THR(CMarkup::ExpandUrl(pMarkup, pchURL, ARRAY_SIZE(cBuf), 
                                    pchExpandedUrl, pElementContext));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // TODO (MohanB) need to canonicalize the url here?
        _tcscpy(pchExpandedUrl, pchURL);
    }

    // If there no submit data to append, set the display url to be the expanded url
    // w/o removing the location
    if (fSendAsPost || !pDwnPost)
    {
        if (pcstrUrlOriginal)
        {
            hr = pcstrUrlOriginal->Set(pchExpandedUrl);
            if (hr)
                goto Cleanup;

            // If the original URL does not contain a location
            // and we have been given one, append it to the
            // original URL.
            //
            if (!fParseLocation)
            {
                Assert(pcstrLocation && *pcstrLocation);
                Assert(!_tcschr(pchExpandedUrl, '#'));

                // If there is no hash, add one.
                //
                if (*pcstrLocation[0] != _T('#'))
                {
                    pcstrUrlOriginal->Append(_T("#"));
                }

                pcstrUrlOriginal->Append(*pcstrLocation);
            }
        }
    }

    // Apply the checks for our old friend %01 hack. We don't want to set the URL
    // of the markup to a URL that contains a %01 hack since it will effect the
    // security ID operation.
    hr = cstrTmp.Set(pchExpandedUrl);
    if (hr)
        goto Cleanup;
    hr = THR(UnescapeAndTruncateUrl(cstrTmp));
    if (hr)
        goto Cleanup;

    // Opaque URL?
    if (!UrlIsOpaque(pchExpandedUrl))
    {
        LPTSTR pch;

        if (fParseLocation)
        {
            pch = (LPTSTR)UrlGetLocation(pchExpandedUrl);

            // Bookmark?
            if (pch)
            {
                // Yes (But is it really a bookmark).
                Assert(*pch == _T('#'));

                hr = THR(pcstrLocation->Set(pch));
                if (hr)
                    goto Cleanup;

                // So remove bookmark from expanded URL, remember bookmark has been
                // copied to cstrLocation.
                *pch = _T('\0');
            }
        }
#ifdef DBG
        else
        {
            Assert(!_tcschr(pchExpandedUrl, '#'));
        }
#endif

        // chop of '?' part if we are going to append '?'
        // TODO: use UrlGetQuery instead of searching for '?' ourselves
        if (!fSendAsPost && pDwnPost)
        {
            pch = _tcschr(pchExpandedUrl, _T('?'));
            if (pch)
                *pch = _T('\0');
        }
    }
    
    hr = THR(pcstrExpandedUrl->Set(pchExpandedUrl));
    if (hr)
        goto Cleanup;

    // Check for security violation, of sending (POSTING) data
    // to a server without a secure channel protocol (SSL/PCT).

    uProt = GetUrlScheme(*pcstrExpandedUrl);
    if (pDwnPost && URL_SCHEME_HTTPS != uProt)
    {
        // warn when submitting over a nonsecure connection
        if (dwSecurityCode)
        {
            DWORD dwPolicyTo;
            DWORD dwPolicyFrom;
            BOOL  fAllow;

            // step 1: silently check if form submission is allowed or should be queried
            hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_TO,
                                                &fAllow, 
                                                PUAF_NOUI | PUAF_WARN_IF_DENIED, 
                                                &dwPolicyTo, 
                                                *pcstrExpandedUrl));

            // The next four if statements are structured to avoid ia64 optimization problems
            // Please check the ia64 retail free builds of the Browser and MSHTMPAD before changing.

            if (hr)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            if (GetUrlPolicyPermissions(dwPolicyTo) == URLPOLICY_DISALLOW)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_FROM,
                                                &fAllow, PUAF_NOUI | PUAF_WARN_IF_DENIED, &dwPolicyFrom));

            if (hr)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            if (GetUrlPolicyPermissions(dwPolicyFrom) == URLPOLICY_DISALLOW)
            {
                hr = E_ABORT;
                goto Cleanup;
            }

            // step 2: if needed and allowed, query the user once, giving precedence to "To"
            // if this is a mailto, we ALWAYS pop up our security alert dialog

            if (URL_SCHEME_MAILTO == uProt)
            {
                int     nResult;

                hr = ShowMessage(&nResult, MB_OKCANCEL | MB_ICONWARNING, 0, IDS_MAILTO_SUBMITALERT);
                if (hr || nResult != IDOK)
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }
            }
            else if (GetUrlPolicyPermissions(dwPolicyTo) == URLPOLICY_QUERY)
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_TO,
                                                    &fAllow, 0, NULL, *pcstrExpandedUrl));
                if (hr || !fAllow)
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }
            }
            else if (GetUrlPolicyPermissions(dwPolicyFrom) == URLPOLICY_QUERY)
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_HTML_SUBMIT_FORMS_FROM, &fAllow));

                if (hr || !fAllow)
                {
                    hr = E_ABORT;
                    goto Cleanup;
                }
            }

            // If we make it to here, it's allowed
        }
    }

    // Tack on the GET data if needed
    //
    hr = AppendGetData(pMarkup, pcstrExpandedUrl, pDwnPost, pchExpandedUrl, fSendAsPost);
    if (hr)
        goto Cleanup;

    // If there is submit data to append, set the display url to be the same as the navigate url
    if (!fSendAsPost && pDwnPost)
    {
        if (pcstrUrlOriginal)
        {
            hr = pcstrUrlOriginal->Set(*pcstrExpandedUrl);
            if (hr)
                goto Cleanup;
        }
    }

    // MHTML hook for outlook express
    // also fix for Lotus Notes - NATIVE FRAMES regression (IE 6 bug # 36342)
    if (_pHostUIHandler && !g_fInLotusNotes)
    {
        OLECHAR *pchURLOut = NULL;

        hr = _pHostUIHandler->TranslateUrl(0, *pcstrExpandedUrl, &pchURLOut);

        if (S_OK == hr
            && pchURLOut && _tcslen(pchURLOut))
        {
            // Replace the URL with the one we got back from Athena.
            pcstrExpandedUrl->Set(pchURLOut);
            CoTaskMemFree(pchURLOut);
        }
        else if (E_ABORT == hr)
        {
            // If we get back E_ABORT, it means Athena is taking over and we bail.
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    {
        DWORD dwNavigate, dwDummy;

        // Are we navigating? (mailto protocol)
        hr = THR(CoInternetQueryInfo(
                    *pcstrExpandedUrl,
                    QUERY_CAN_NAVIGATE,
                    0,
                    (LPVOID)&dwNavigate,
                    4,
                    &dwDummy,
                    0));

        if (!hr && !dwNavigate)
        {
            *pfProtocolNavigates = FALSE;
        }

        hr = S_OK;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member  : CDoc::AppendPostData
//
//  Synopsis: Appends GET data to an URL.
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::AppendGetData(CMarkup  * const pMarkup,
                    CStr     * const pcstrExpandedUrl,
                    CDwnPost * const pDwnPost,
                    LPCTSTR          pchExpandedUrl,
                    BOOL             fSendAsPost)
{
    HRESULT hr = S_OK;

    if (    pDwnPost
        &&  !fSendAsPost
        &&  pDwnPost->GetItemCount() > 0
        &&  !IsSpecialUrl(pchExpandedUrl))
    {
        CPostItem * pPostItem = pDwnPost->GetItems();

        if (pPostItem->_ePostDataType == POSTDATA_LITERAL)
        {
            UINT    cp        = NavigatableCodePage(pMarkup->GetCodePage());
            int     cchPrefix = pcstrExpandedUrl->Length() + 1; // len + '?'
            LPSTR   pszPost   = pPostItem->_pszAnsi;
            UINT    cbPost    = pszPost ? strlen(pszPost) : 0;
            UINT    cchPost   = 0;
            CStr    cstrT;

            hr = THR(mlang().ConvertStringToUnicode(NULL, cp, pszPost, &cbPost, NULL, &cchPost));
            if (FAILED(hr))
                goto Cleanup;

            // cchPost == 0 means the conversion failed
            Assert(cchPost > 0 || cbPost == 0);

            hr = THR(cstrT.Set(NULL, cchPrefix + cchPost + 1));
            if (FAILED(hr))
               goto Cleanup;

            _tcscpy(cstrT, *pcstrExpandedUrl);
            _tcscat(cstrT, _T("?"));

            hr = THR(mlang().ConvertStringToUnicode(NULL, cp, pszPost, &cbPost, (TCHAR *)cstrT + cchPrefix, &cchPost));
            if (hr != S_OK)
                goto Cleanup;

            cstrT[cchPrefix + cchPost] = 0;

            hr = THR(pcstrExpandedUrl->Set(cstrT));
            if (hr != S_OK)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Member:     CDoc::AllowNavigationToLocalInternetShortcut
//
//  Synopsis:   Block navigation to local .url files either from the address bar or from the links
//              Ignore the query string to find the extension correctly. # is valid in a file name so
//              we don't have to look for that. If this file url did have a # at the end, the navigation
//              will fail.
//
//  Arguments:  pchExpandedUrl - original expanded url
//------------------------------------------------------------------------------
BOOL            
CDoc::AllowNavigationToLocalInternetShortcut(TCHAR * pchExpandedUrl)
{
    BOOL        bAllowNav = FALSE;
    TCHAR       szDecodedURL[INTERNET_MAX_URL_LENGTH];
    DWORD       cchDecodedURL = ARRAY_SIZE(szDecodedURL);
    size_t      initialLen = _tcslen(pchExpandedUrl);
    TCHAR       tempChar = _T('\0');

    // PathCreateFromUrl only accepts null terminated strings upto INTERNET_MAX_URL_LENGTH
    // but Trident uses pdlUrlLen which is 4K
    if (initialLen >= INTERNET_MAX_URL_LENGTH)
    {
        tempChar = pchExpandedUrl[INTERNET_MAX_URL_LENGTH];
        pchExpandedUrl[INTERNET_MAX_URL_LENGTH] = _T('\0');
    }

    if (SUCCEEDED(PathCreateFromUrl(pchExpandedUrl, 
                                    szDecodedURL, 
                                    &cchDecodedURL,
                                    NULL)))
    {
        TCHAR     * pwzMimeOut  = NULL;
        HRESULT     hrMime      = S_OK;           
        HANDLE      hFile       = INVALID_HANDLE_VALUE;
        ULONG       cb          = 0;
        // If this is a regular BindToStorage/Object bind,  read in either 2048 bytes 
        // or the entire file whichever is lesser into the buffer. (This is the urlmon behavior, 
        // the sniffing tries to get at least 256 but passes in a buffer big enough for 2048 
        // and the file:// protocol does a ReadFile for the entire chunk.)
        // For a fastbind we use 200 bytes of data to get mime info, see GetMimeInfoFromData()
        char        achFileBuf[2048];

        hFile = CreateFile(szDecodedURL,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                //  security descriptor
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            hrMime = E_FAIL;
            goto CloseFile;
        }

        if (FILE_TYPE_DISK != GetFileType(hFile))
        {
            hrMime = E_FAIL;
            goto CloseFile;
        }

        //  Here the file should be open and ripe for consumption
        if ( !ReadFile(hFile, achFileBuf, sizeof(achFileBuf), &cb, NULL) )
        {
            hrMime = E_FAIL;
            goto CloseFile;
        }


CloseFile:
        if ( hFile != INVALID_HANDLE_VALUE )
        {
            Verify(CloseHandle(hFile));
            if (SUCCEEDED(hrMime))
            {
                hrMime = THR(FindMimeFromData(NULL,             // bind context - can be NULL                                     
                                              pchExpandedUrl,   // url - can be null                                              
                                              achFileBuf,       // buffer with data to sniff - can be null (pwzUrl must be valid) 
                                              cb,               // size of buffer                                                 
                                              NULL,             // proposed mime if - can be null                                 
                                              0,                // will be defined                                                
                                              &pwzMimeOut,      // the suggested mime                                             
                                              0));
                if (SUCCEEDED(hrMime) && pwzMimeOut)
                {
                    if (_tcsnicmp(pwzMimeOut, -1, TEXT("text/html"), 9) != 0)
                        bAllowNav = TRUE;
                }
            }
        }

    }
    
    if (initialLen >= INTERNET_MAX_URL_LENGTH)
    {
        pchExpandedUrl[INTERNET_MAX_URL_LENGTH] = tempChar;
    }
        
    return bAllowNav;
}

//+-----------------------------------------------------------------------------
//
//  Member:     CDoc::FindTargetWindow
//
//  Synopsis:   Searches for and returns the target window. If the target
//              window is found in the current process, a ptr to its proxy
//              is placed in ppTargOmWindowPrxy. If the target window is
//              found in another process, a ptr to its IHTMLWindow2 is 
//              placed in ppTargHTMLWindow. If the window is not found,
//              both these parameters will be null upon return.
//
//  Arguments:  pchTarget           - name of the target window
//              pElementContext     - element whose base should be searched for
//                                    a target name is pchTarget is null.
//              pfOpenInNewBrowser  - flag that indicates whether or not a
//                                    new browser window should be opened. This
//                                    will be TRUE if the target window is not
//                                    found.
//              pWindow             - window to use as a starting point for
//                                    the target search.
//              ppTargOmWindowPrxy  - COmWindowProxy of the found window. This
//                                    parameter will be non-null if the target
//                                    window is in this process.
//              ppTargHTMLWindow    - IHTMLWindow2 of the found window. This 
//                                    parameter will be non-null if the target
//                                    window is in a separate process.
//              ppTopWebOC          - the WebOC of the top-level browser. This
//                                    is set if there is a failure retrieving
//                                    the main window.
//              dwFlags             - FHL flags (FollowHyperlink)
//
//------------------------------------------------------------------------------

void
CDoc::FindTargetWindow(LPCTSTR *         ppchTarget,
                       TCHAR **          ppchBaseTarget,
                       CElement *        pElementContext,
                       BOOL *            pfOpenInNewBrowser,
                       COmWindowProxy *  pWindow,
                       COmWindowProxy ** ppTargOmWindowPrxy,
                       IHTMLWindow2   ** ppTargHTMLWindow,
                       IWebBrowser2   ** ppTopWebOC,
                       DWORD             dwFlags)
{
    HRESULT hr = S_OK;
    CWindow * pCWindow;

    Assert(ppTargHTMLWindow);

    if (ppTargOmWindowPrxy)
        *ppTargOmWindowPrxy = NULL;

    *ppTargHTMLWindow   = NULL;

    if (pfOpenInNewBrowser)
        *pfOpenInNewBrowser = FALSE;

    // The only callers to this function are DoNavigate() and FollowHyperlink()
    // and neither of them should ever pass in a NULL window.  Leaving the
    // check anyway since we're in lockdown and want to minimize changes.
    Assert(pWindow);
    if (!pWindow)
    {
        pWindow = _pWindowPrimary;
    }
    
    pCWindow = pWindow->Window();    

    //  If we don't have a specific target, check if one is defined in a base
    //
    if (    !(dwFlags & FHL_IGNOREBASETARGET)
        &&  (NULL == *ppchTarget || 0 == **ppchTarget))
    {
        hr = THR(CMarkup::GetBaseTarget(ppchBaseTarget, pElementContext));
        if (hr)
            goto Cleanup;

        *ppchTarget = *ppchBaseTarget;
    }

    if (NULL == *ppchTarget || 0 == **ppchTarget)
    {
        if (    (dwFlags & FHL_HYPERLINKCLICK)
            &&  (_fIsActiveDesktopComponent || (_fActiveDesktop && !_fViewLinkedInWebOC))
            &&  !pCWindow->_pWindowParent)
        {
            hr = THR(MemAllocString(Mt(FindTargetWindow), _T("_desktop"), ppchBaseTarget));
            if (hr)
                goto Cleanup;

            *ppchTarget = *ppchBaseTarget;
        }
        else
            goto Cleanup;
    }

    Assert(pWindow);
    Assert(pCWindow);
        
    hr = pCWindow->FindWindowByName(*ppchTarget,
                                    ppTargOmWindowPrxy,
                                    ppTargHTMLWindow,
                                    ppTopWebOC);

    if (hr && (ppTopWebOC && !*ppTopWebOC) && pfOpenInNewBrowser)
    {
        *pfOpenInNewBrowser = TRUE;
    }

Cleanup:;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetupDwnBindInfoAndBindCtx
//
//  Synopsis:   creates and sets up the bind task
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::SetupDwnBindInfoAndBindCtx(LPCTSTR           pchExpandedUrl,
                                 LPCTSTR           pchSubReferer,
                                 LPCTSTR           pchUrlContext,
                                 CDwnPost *        pDwnPost,
                                 BOOL              fSendAsPost,
                                 LPCTSTR           pchExtraHeaders,
                                 CMarkup *         pMarkup,
                                 DWORD *           pdwBindf,
                                 CDwnBindInfo **   ppDwnBindInfo,
                                 IBindCtx **       ppBindCtx,
                                 DWORD             dwFlags)
{
    CDwnDoc * pDwnDoc = NULL;
    HRESULT hr = S_OK;
    DWORD dwOfflineFlag;
    const TCHAR * pchUrlCreator;
    CStr cstrBindCtxUrl;

    Assert(pdwBindf && ppDwnBindInfo && ppBindCtx);

    *ppDwnBindInfo = new CDwnBindInfo;

    if (!*ppDwnBindInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    MemSetName((*ppDwnBindInfo, "DwnBindInfo %ls", pchExpandedUrl));

    pDwnDoc = new CDwnDoc;

    if (pDwnDoc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppDwnBindInfo)->SetDwnDoc(pDwnDoc);

    // The referer of the new document is the same as the sub referer
    // of this document.  Which should be the same as _cstrUrl, by the way.

    //
    // we should only set the referer if we are not coming from a supernavigate
    // or a history load.
    //
    if (pchSubReferer && (dwFlags & CDoc::FHL_SETDOCREFERER))
    {
        //
        // If we are navigating an existing frame using the src attribute, then
        // we want the referer to contain the URL of the parent window of the frame.
        // Otherwise, we use the current page's subreferer as the next page's referer.
        //
        if ((dwFlags & CDoc::FHL_FRAMENAVIGATION) && !(dwFlags & CDoc::FHL_FRAMECREATION))
        {
            // set the doc referer to the parent window's URL.
            Assert(pMarkup->Root()->HasMasterPtr());
            Assert(pMarkup->Root()->GetMasterPtr()->IsInMarkup());

            hr = THR(pDwnDoc->SetDocReferer(CMarkup::GetUrl(pMarkup->Root()->GetMasterPtr()->GetMarkup())));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(pDwnDoc->SetDocReferer(pchSubReferer));

            if (hr)
                goto Cleanup;
        }
    }

    // The referer of items within the new document is the fully expanded
    // URL which we are hyperlinking to.

    hr = THR(pDwnDoc->SetSubReferer(pchExpandedUrl));
    if (hr)
        goto Cleanup;

    // Tell CDwnBindInfo that this is going to be a document binding.  That
    // lets it pick the correct referer to send in the HTTP headers.

    (*ppDwnBindInfo)->SetIsDocBind();

    // Set the accept language header if one was specified.
    if (_pOptionSettings->fHaveAcceptLanguage)
    {
        hr = THR(pDwnDoc->SetAcceptLanguage(_pOptionSettings->cstrLang));
        if (hr)
            goto Cleanup;
    }

    hr = THR(pDwnDoc->SetUserAgent(_bstrUserAgent));
    if (hr)
        goto Cleanup;

    hr = THR(pDwnDoc->SetExtraHeaders(pchExtraHeaders));
    if (hr)
        goto Cleanup;

    // Post data is passed in
    if (pDwnPost && fSendAsPost)
    {
        (*ppDwnBindInfo)->SetDwnPost(pDwnPost);
    }

    IsFrameOffline(&dwOfflineFlag);
    *pdwBindf |= dwOfflineFlag;

    // Now set up bind context.
    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, ppBindCtx, 0));
    if (hr)
        goto Cleanup;

    pDwnDoc->SetBindf(*pdwBindf);
    pDwnDoc->SetDocBindf(*pdwBindf);
    if ( IsCpAutoDetect() )
        pDwnDoc->SetDocCodePage(CP_AUTO);
    else
        pDwnDoc->SetDocCodePage(
            NavigatableCodePage(_pOptionSettings->codepageDefault));

    // In case of navigating from shdocvw, set URL codepage to
    // the default codepage (to keep IE5 compatibility).
    // Encoding of current page, shouldn't affect URL encoding of
    // a new URL when navigating from the address bar.
    if (dwFlags & FHL_SHDOCVWNAVIGATE)
        pDwnDoc->SetURLCodePage(NavigatableCodePage(g_cpDefault));
    else
    {
        CODEPAGE codepage = pMarkup->GetCodePage();

        // Dmitryt: check for CP_UCS_2 prevents us from sending raw Unicode bytes (which is bad) 
        // in case we don't have "Always use UTF-8 checked"
        // In this case, we should try to convert to default codepage of the machine.
        // about:blank is Unicode page, so when we renavigate about:blank, we need this behavior
        pDwnDoc->SetURLCodePage(
            NavigatableCodePage((IsAutodetectCodePage(codepage) || codepage == CP_UCS_2) ? g_cpDefault : codepage));
    }

    // TODO (dmitryt) this load flags are not used for navigation. later, we create a new pDwnDoc
    // and don't bother to transfer this loadf, rather we get it from CDoc::SetLoadfFromPrefs
    // and this flags are lost anyway. Consider to remove this line.
    pDwnDoc->SetLoadf(_dwLoadf & (DLCTL_URL_ENCODING_DISABLE_UTF8 | DLCTL_URL_ENCODING_ENABLE_UTF8));
    // TODO (lmollico): This is for IE5 #52877. Maybe we should just set _dwLoadf completely.


    // Set up HtmlLoadOptions
    if (_pShortcutUserData && *_cstrShortcutProfile)
    {
        COptionArray *phlo = new COptionArray(IID_IHtmlLoadOptions);

        if (SUCCEEDED(hr) && phlo)
        {
            BOOL fHyperlink = TRUE;
            phlo->SetOption(HTMLLOADOPTION_HYPERLINK, &fHyperlink, sizeof(fHyperlink));
       
            if (_pShortcutUserData && *_cstrShortcutProfile)
            {
                VARIANT varName;

                V_VT(&varName) = VT_BSTR;
                _cstrShortcutProfile.AllocBSTR(&V_BSTR(&varName));

                // deliberately ignore failures here
                if (V_BSTR(&varName))
                {
                    phlo->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                V_BSTR(&varName),
                                (lstrlenW(V_BSTR(&varName)) + 1)*sizeof(WCHAR));
                    VariantClear(&varName);
                }
            }

            hr = THR((*ppBindCtx)->RegisterObjectParam(SZ_HTMLLOADOPTIONS_OBJECTPARAM,
                                                   (IOptionArray *)phlo));
            phlo->Release();
        }

        if (hr)
            goto Cleanup;
    }


    hr = THR((*ppBindCtx)->RegisterObjectParam(SZ_DWNBINDINFO_OBJECTPARAM,
                (IBindStatusCallback *)*ppDwnBindInfo));
    if (hr)
        goto Cleanup;

    //  Add the document's URL to the bind context as a parameter. The URL will be
    //  used as a security ID later in the chain.

    pchUrlCreator = pMarkup->GetAAcreatorUrl();

    TraceTag((tagSecurityContext, 
                "CDoc::SetupDwnBindInfoAndBindCtx- Markup: 0x%x URL: %ws CreatorUrl: %ws", 
                pMarkup, 
                pchExpandedUrl, 
                pchUrlCreator));

    //
    // If we have a creatorUrl ourselves for this markup, windows that are opened
    // from this markup should also contain that as the base domain.
    // Else the window that is created from this markup should have this markup's URL
    // as its base domain.
    //
    if (pchUrlCreator)
    {
        if (pchUrlContext)
        {
            TraceTag((tagSecurityContext, "                                - Creator exists, Use context URL: %ws", pchUrlContext ));

            hr = THR(cstrBindCtxUrl.Set(pchUrlContext));
        }
        else if (IsSpecialUrl(CMarkup::GetUrl(pMarkup)) || 
            (dwFlags & CDoc::FHL_ERRORPAGE))
        {
            TraceTag((tagSecurityContext, "                                - Creator exists, Carry over the creator url of the markup"));

            hr = THR(cstrBindCtxUrl.Set(pchUrlCreator));
        }
        else
        {
            TraceTag((tagSecurityContext, "                                - Creator Exists, Use markup's URL"));
            hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkup)));
        }
    }
    else
    {
        //
        // if this is a frame navigation and the URL we are going to is a special URL,
        // then the creator should be set to the parent of this frame, as it would be 
        // if we were loading this URL the first time.
        //
        if (!(dwFlags & CDoc::FHL_FRAMENAVIGATION))
        {
            if (pchUrlContext)
            {
                TraceTag((tagSecurityContext, "                                - No Creator, not frame nav. context is available, Using nav.context URL"));
                hr = THR(cstrBindCtxUrl.Set(pchUrlContext));
            }
            else
            {
                TraceTag((tagSecurityContext, "                                - No Creator, not frame nav., Using Markup's URL"));
                hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkup)));
            }
        }
        else if (IsSpecialUrl(pchExpandedUrl))
        {
            TraceTag((tagSecurityContext, "                                - Frame navigation and special URL"));

            //
            // If we are creating a new frame, pMarkup points to the markup that contains
            // the frame/iframe tag. pMarkup may point to a pending markup, but it's OK.
            //
            // If we are navigating a frame, then we should have a window for existing 
            // frames and that window will take us to the parent window's URL.
            //
            // If the frame is being created/navigated in the ether, our only chance
            // is to check the markup creator.

            if (dwFlags & CDoc::FHL_FRAMECREATION)
            {
                hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkup)));                               
                TraceTag((tagSecurityContext, "                                - Frame creation. Use Markup's URL"));
            }
            else if (pchUrlContext)  //Winseraid 25599
                hr = THR(cstrBindCtxUrl.Set(pchUrlContext));
            else if (pMarkup->Window())
            {
                CWindow * pWindowParent = NULL;

                pWindowParent = pMarkup->Window()->Window()->_pWindowParent;

                // get the parent
                hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pWindowParent->Markup())));

                TraceTag((tagSecurityContext, "                                - Frame navigation/not creation, special URL, no context URL. Use parent's URL"));
            }

            if (!cstrBindCtxUrl.Length() && pMarkup->HasWindowedMarkupContextPtr())
            {
                AssertSz(FALSE, "Why do we have this code path at all ? Creation of a frame in the ether ?");

                CMarkup * pMarkupCreator;
                // This is a markup being created in the ether. 

                pMarkupCreator = pMarkup->GetWindowedMarkupContextPtr();

                Assert(pMarkupCreator);

                pchUrlCreator = pMarkupCreator->GetAAcreatorUrl();

                if (pchUrlCreator)
                {
                    hr = THR(cstrBindCtxUrl.Set(pchUrlCreator));
                }
                else
                {
                    hr = THR(cstrBindCtxUrl.Set(CMarkup::GetUrl(pMarkupCreator)));
                }
            }
        }
    }
    if (hr)
        goto Cleanup;

    hr = THR(AddBindContextParam(*ppBindCtx, &cstrBindCtxUrl));
    if (hr)
        goto Cleanup;

Cleanup:

    
    if (pDwnDoc)
        pDwnDoc->Release();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     PrepareURLForExternalApp
//
//  Synopsis:
//
//   Decodes and strips, if needed, file:// prefix
//
//  COMPAT - for IE30 compatibility reasons, we have to Unescape all Urls - zekel - 1-JUL-97
//  before passing them to an APP.  this does limit their use, but
//  people already depend on this behavior.  specifically MS Chat.
//
//+---------------------------------------------------------------------------

BOOL PrepareURLForExternalApp (LPCWSTR psz, 
                               LPWSTR  pszOut,
                               DWORD   nBufferSize,
                               LPDWORD pcchOut)
{
    BOOL fQuoteURL = TRUE;

    if ((pcchOut == NULL) || (psz == NULL) || (psz == NULL))
    {
        if (pcchOut)
        {
            (*pcchOut) = 0;
        }

        if (pszOut)
        {
            (*pszOut) = 0;
        }

        return FALSE;
    }

    switch(GetUrlScheme(psz))
    {
    case URL_SCHEME_FILE:
        if (!SUCCEEDED(PathCreateFromUrl(psz, pszOut, pcchOut, 0)))
        {
            return FALSE;
        }
        break;
    case URL_SCHEME_NEWS:
        fQuoteURL = FALSE;  // never quote the news protocol
    default:
        if (!SUCCEEDED(UrlUnescape((LPWSTR)psz, pszOut, pcchOut, 0)))
        {
            return FALSE;
        }
        // check if we really need to quote the url or not
        if (fQuoteURL && !StrChr(pszOut, _T(' ')))
            fQuoteURL = FALSE;
    }

    // We only check for the first quote because if they aren't matched
    // The execute will fail as being bogus anyway.

    if (((*pszOut) == '"') || ((*pszOut) == '\'') || ((*pszOut) == 0) || !fQuoteURL)
    {
        return TRUE;
    }

    // Don't forget the NULL and the quotes
    if (((*pcchOut) + 3) > nBufferSize)
    {
        return FALSE;
    }

    LPWSTR pTempBuffer;
    BOOL fResult;

    pTempBuffer = new WCHAR[nBufferSize];

    (*pTempBuffer) = '"';
    fResult = StringCchCopyW(pTempBuffer+1,nBufferSize,pszOut);

    if (SUCCEEDED(fResult))
    {
        (*(pTempBuffer + (*pcchOut) + 1)) = '"';
        (*(pTempBuffer + (*pcchOut) + 2)) = 0;

        fResult = SUCCEEDED(StringCchCopyW(pszOut,nBufferSize,pTempBuffer));
        
        if (SUCCEEDED(fResult))
        {
            (*pcchOut) = (*pcchOut) + 2;
        }
        else
        {
            (*pcchOut) = 0;
            (*pszOut)  = 0;
        }
    }

    delete[] pTempBuffer;
    
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     ShouldShellExecURL
//
//  Synopsis:   See if the URL is of a type that we should
//              ShellExecute()
//
//  Notes:      Moved from shodcvw.
//
//+---------------------------------------------------------------------------

BOOL ShouldShellExecURL( LPCTSTR pszURL )
{
    BOOL fRet = FALSE;
    TCHAR sz[MAX_PATH];
    DWORD cch = ARRAY_SIZE(sz);
    HKEY hk;

    if (SUCCEEDED(UrlGetPart(pszURL, sz, &cch, URL_PART_SCHEME, 0))
     && SUCCEEDED(AssocQueryKey(0, ASSOCKEY_CLASS, sz, NULL, &hk)))
    {
        if (lstrlen(pszURL) <= 230 ||
                (StrCmpI(sz, _T("telnet")) && 
                 StrCmpI(sz, _T("rlogin")) &&
                 StrCmpI(sz, _T("tn3270"))))
        {
            fRet = (NOERROR == RegQueryValueEx(hk, TEXT("URL Protocol"), NULL, NULL, NULL, NULL));
        }

        RegCloseKey(hk);
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DoNavigate
//
//  Synopsis:   navigates to a url for FollowHyperlink
//
//+---------------------------------------------------------------------------

HRESULT
CDoc::DoNavigate(CStr *            pcstrInExpandedUrl,
                 CStr *            pcstrLocation,
                 CDwnBindInfo *    pDwnBindInfo,
                 IBindCtx *        pBindCtx,
                 LPCTSTR           pchURL,
                 LPCTSTR           pchTarget,
                 COmWindowProxy  * pWindow,     // Opener window
                 COmWindowProxy ** ppWindowOut,
                 BOOL              fOpenInNewWindow,
                 BOOL              fProtocolNavigates,
                 BOOL              fReplace,
                 BOOL              fOpenInNewBrowser,
                 IHTMLWindow2 **   ppHTMLWindow2,
                 TARGET_TYPE       eTargetType,
                 DWORD             dwFlags, /* FollowHyperlink flags, FHL_* */
                 const TCHAR *     pchName,
                 BOOL              fSendAsPost,       /* = FALSE */
                 LPCTSTR           pchExtraHeaders,
                 IStream *         pStmHistory,       /* = NULL  */
                 LPCTSTR           pchUrlOriginal,    /* = NULL  */
                 CElement *        pElementMaster,    /* = NULL  */
                 BOOL   *          pfLocalNavigation, /* = NULL  */
                 LPCTSTR           pchCallerUrl       /* = NULL  */)
{
    IMoniker  *    pMoniker          = NULL;
    IHlink *       pHlink            = NULL;
    IHlinkFrame *  pHlinkFrame       = NULL;
    HRESULT        hr                = S_OK;
    ULONG          cDie              = _cDie;
    CMarkup   *    pMarkup           = NULL;
    BOOL           fCancel           = FALSE;
    BOOL           fInFrmOrFrmTarget = FALSE;
    BOOL           fFrameTarget      = FALSE;
    BOOL           fLocalNavigation  = FALSE;
    BSTR           bstrMedia         = NULL;
    CDocument *    pTargetDocument   = NULL;
    CWindow   *    pCWindow          = NULL;
    IHTMLWindow2 * pTargetHTMLWindow = NULL;
    BOOL           fForceNewBrowser;
    BOOL           fForceUpdate      = FALSE;
    CVariant       cvarUrl(VT_BSTR);
    CVariant       cvarContinue(VT_BOOL);
    BOOL           fIsPrimaryMarkup  = FALSE;

    if (!pWindow)
    {
        pWindow = _pWindowPrimary;
    }

    fIsPrimaryMarkup = pWindow->Markup()->IsPrimaryMarkup();

    // Unfortunately, we have to reset _fDontFireWebOCEvents
    // here so that BeforeNavigate2 will fire and we have 
    // to reset it in CMarkup::LoadFromInfo() because that 
    // method is sometimes called directly. See the comment
    // in CMarkup::LoadFromInfo() about why we check
    // _fInObjectTag and _fInHTMLDlg.
    //
    if (!_fInObjectTag && !_fInHTMLDlg && !(dwFlags & FHL_CREATEDOCUMENTFROMURL)) 
    {
        _fDontFireWebOCEvents = !!(dwFlags & FHL_DONTFIREWEBOCEVENTS);
    }

    pCWindow = pWindow->Window();

    if (!(dwFlags & FHL_FRAMECREATION) && !fOpenInNewBrowser)
    {
        pCWindow->ClearWindowData();
    }

    // need to clear this flag so that we do not inadvertently print the new markup
    // instead of the old.
    _fPrintJobPending = FALSE;


    // Figure out if this is a local navigation.  If that is the
    // case, we don't want to do a navigation at all, really, 
    // just scroll the screen to that element.
    // TODO: (jbeda) shdocvw doesn't do this if it can't use the cache
    if (    pcstrLocation 
        &&  pcstrLocation->Length() 
        &&  (   !pchTarget 
            ||  !_tcscmp(_T("_unspecifiedFrame"), pchTarget)
            ||  eTargetType == TARGET_SELF
            ||  eTargetType == TARGET_FRAMENAME)
       )
    {
        DWORD   cchWindowUrl = pdlUrlLen;
        TCHAR   achWindowUrl[pdlUrlLen];

        // Get the window's URL for comparison
        if (pcstrInExpandedUrl->Length())
        {
            // We were passing a NULL URL occasionally and tripping an assert,
            // so instead we continue with the return value that we would have gotten
            // had we made the call
            LPCTSTR pchTempUrl = pCWindow->_pMarkup->Url();
            if (pchTempUrl)
            {
                hr = THR(UrlCanonicalize(
                            pchTempUrl,
                            (LPTSTR) achWindowUrl,
                            &cchWindowUrl,
                            URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE));
            }
            else
            {
                hr = E_INVALIDARG;
            }
            if (hr)
                goto Cleanup;
        }

        //
        // If we refresh an http error page, then the pending markup will 
        // be server 404 error and the achWindowUrl will be the same page
        // as our current page.  We can't do location navigation for
        // this case, so we check here.
        //

        if (!pCWindow->_fHttpErrorPage)
        {
            //
            // If expanded URL's are equal, do location navigation.
            //

            if (   !pcstrInExpandedUrl->Length() 
                || !UrlCompare(achWindowUrl, *pcstrInExpandedUrl, TRUE))
            {
                fLocalNavigation = TRUE;
            }
        }
    }

    // We want to open a new window under two conditions:
    // 1) fOpenInNewBrowser is TRUE.
    // 2) The DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION is not set
    //    and the following conditions are true:
    //    a) We are not opening a frame window (fOpenInNewWindow == FALSE)
    //    b) We are not targeting a frame (pchTarget == NULL or is empty)
    //    c) We are not navigating within a frame (i.e, pWindow does
    //       not contain the primary markup.)
    //

    fFrameTarget = pchTarget && *pchTarget && eTargetType == TARGET_FRAMENAME;

    if (fOpenInNewWindow
        || !fIsPrimaryMarkup
        || fFrameTarget)
    {
        fInFrmOrFrmTarget = TRUE;
    }

    if (!_pTopWebOC && (dwFlags & (FHL_HYPERLINKCLICK | FHL_SETURLCOMPONENT)))
    {
        IGNORE_HR(QueryService(SID_SHlinkFrame, IID_IHlinkFrame, (void **) &pHlinkFrame));

        if (!pHlinkFrame)
        {
            if (_pInPlace && _pInPlace->_pFrame)
            {
                IGNORE_HR(_pInPlace->_pFrame->QueryInterface(IID_IHlinkFrame, (void **) &pHlinkFrame));
            }
        }

        if (pHlinkFrame)
        {
            if ((dwFlags & FHL_SHDOCVWNAVIGATE) && (URL_SCHEME_FILE == GetUrlScheme(*pcstrInExpandedUrl)))
            {
                hr = THR(CreateURLMonikerEx(NULL, *pcstrInExpandedUrl, &pMoniker, URL_MK_NO_CANONICALIZE));
            }
            else
            {
                hr = THR(CreateURLMoniker(NULL, *pcstrInExpandedUrl, &pMoniker));
            }
            if (hr)
                goto Cleanup;

            hr = THR(HlinkCreateFromMoniker(pMoniker, *pcstrLocation, NULL,
                     NULL, 0, NULL, IID_IHlink, (LPVOID *) &pHlink));
            if (hr)
                goto Cleanup;

            // only set the target if there's something to set
            if (fOpenInNewBrowser && pchTarget && *pchTarget)
            {
                hr = THR(pHlink->SetTargetFrameName(pchTarget));
                if (hr)
                    goto Cleanup;
            }

            hr = THR(pHlinkFrame->Navigate(fOpenInNewBrowser ? HLNF_OPENINNEWWINDOW : 0,
                                           pBindCtx,
                                           pDwnBindInfo,
                                           pHlink));
            goto Cleanup;
        }
    }

    // We want to open a new window under two conditions:
    // 1) fOpenInNewBrowser is TRUE.
    // 2) The DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION is not set
    //    and the following conditions are true:
    //    a) We are not opening a frame window (fOpenInNewWindow == FALSE)
    //    b) We are not targeting a frame (pchTarget == NULL or is empty)
    //    c) We are not navigating within a frame (i.e, pWindow does
    //       not contain the primary markup.)
    //

    fForceNewBrowser =      !fInFrmOrFrmTarget
                        &&  !(_dwFlagsHostInfo & DOCHOSTUIFLAG_ENABLE_INPLACE_NAVIGATION)
                        &&  !_pTopWebOC
                        &&  !fLocalNavigation
                        &&  !(dwFlags & FHL_METAREFRESH);

    if (fProtocolNavigates && (fOpenInNewBrowser || fForceNewBrowser))
    {
        if ((!pchTarget || !*pchTarget) && fForceNewBrowser)
        {
            pchTarget = _T("_unspecifiedFrame");            

            FindTargetWindow(&pchTarget,
                             NULL,
                             NULL,
                             NULL,
                             pWindow,
                             NULL,
                             &pTargetHTMLWindow,
                             NULL,
                             dwFlags);

            if (pTargetHTMLWindow)
            {
                hr = THR(DoNavigateOutOfProcess(pTargetHTMLWindow,
                                                *pcstrInExpandedUrl,
                                                *pcstrLocation,
                                                (TCHAR *) pchUrlOriginal,
                                                pBindCtx,
                                                dwFlags));
                goto Cleanup;
            }
        }
        
        // If running on NT5, we must call AllowSetForegroundWindow
        // so that the new window will be shown in the foreground.
        // 
        if (VER_PLATFORM_WIN32_NT == g_dwPlatformID
           && g_dwPlatformVersion >= 0x00050000)
        {
            // TODO (scotrobe): Pass -1 to AllowSetForegroundWindow
            // to specify that all processes can set the foreground
            // window. We should really pass ASFW_ANY but at this point
            // Trident is being built with _WIN32_WINNT set to version 4
            // so this constant doesn't get included. When we start using
            // NT5 headers, the -1 should be changed to ASFW_ANY
            //
            AllowSetForegroundWindow((DWORD) -1);
        }

        CStr    strTemp;
        LPCTSTR pszURLOpen;

        if (pchURL && *pchURL)
        {
            hr = strTemp.Set(*pcstrInExpandedUrl);
            if (hr)
                goto Cleanup;

            hr = strTemp.Append(*pcstrLocation);
            if (hr)
                goto Cleanup;
            
            pszURLOpen = strTemp;
        }
        else
        {
            pszURLOpen = _T("about:blank");
        }

        hr = OpenInNewWindow(pszURLOpen,
                             pchTarget,
                             pDwnBindInfo,
                             pBindCtx,
                             pWindow,
                             fReplace,
                             ppHTMLWindow2);
    }
    else
    {
        COmWindowProxy * pWindowForEvents = pWindow;

        if (    _fDefView
            &&  !_fActiveDesktop
            &&  !(dwFlags & FHL_FRAMENAVIGATION)
            &&  !IsSpecialUrl(*pcstrInExpandedUrl))
        {
            NotifyDefView(*pcstrInExpandedUrl);
            goto Cleanup;
        }

        // 1. Reset the list only for top level navigations iff
        // (1) a new window is not being opened AND
        // (2) this is not a local navigation AND
        // (3) this is not a navigate call from a diff browser window
        // (4) this is either a shdocvw navigation (address bar, Go to, Favorites) or history OR
        //     ( if it is a hyperlink navigation at the top level AND 
        //       not in viewlink WebOC AND
        //       is not initiated by script AND
        //       it is not a script url in the href which can potentially just show a msgbox and not navigate)
        // 2. If this is top level navigation but script initiated, then add a blank record to 
        //    demarcate the set of urls pertaining to this new top level url

        if (   !fOpenInNewWindow 
            && !fLocalNavigation 
            && !(dwFlags & FHL_EXTERNALNAVIGATECALL) )
        {
            if ( dwFlags & FHL_SHDOCVWNAVIGATE )
                THR(ResetPrivacyList());
            else if (fIsPrimaryMarkup && !_fViewLinkedInWebOC && !IsScriptUrl(*pcstrInExpandedUrl))
            {
                if ((dwFlags & FHL_HYPERLINKCLICK) && !_cScriptNestingTotal)
                    THR(ResetPrivacyList());
                else if (_cScriptNestingTotal)
                    THR(AddToPrivacyList(_T(""), NULL, PRIVACY_URLISTOPLEVEL));
            }
        }

        
        // If this is a top-level navigation and the host is supposed to it
        // (as is the case if we are aggregated), then delegate to the host now.
        if (    _fHostNavigates
            &&  _pTopWebOC
            &&  (dwFlags & FHL_HYPERLINKCLICK)
            &&  !fOpenInNewWindow
            &&  (fIsPrimaryMarkup && !_fViewLinkedInWebOC)
            &&  !IsSpecialUrl(*pcstrInExpandedUrl)
           )
        {
            if (!fLocalNavigation)
            {
                if (_pClientSite)
                    CTExec(_pClientSite, &CGID_ShellDocView, SHDVID_SETNAVIGATABLECODEPAGE, 0, NULL, NULL);

                /////////////////////////////////////////////////////////////////////////////////////////
                // a-naande winse 25165 8-15-02
                // if we are navigating to a frame we need to specify that frame to shdocvw
                CVariant cvarFrameName(VT_BSTR);

                // only allocate memory if we need it
                if(fFrameTarget)cvarFrameName.bstrVal = SysAllocString(pchTarget);
                
                // check if allocation failed
                if(fFrameTarget && cvarFrameName.bstrVal)
                {
                    // urlmon attempts to parse the url before the codepage is set, which messes up
                    // the url and causes the navigation to fail, so set the codepage here
                    if(pWindow && pWindow->Markup() && pDwnBindInfo && pDwnBindInfo->GetDwnDoc())
                    {
                        if(pDwnBindInfo->GetDwnDoc()->GetDocCodePage() != pWindow->Markup()->GetCodePage())
                            pWindow->Markup()->SwitchCodePage(pDwnBindInfo->GetDwnDoc()->GetDocCodePage());
                    }

                    hr = DelegateNavigation(INET_E_TERMINATED_BIND, *pcstrInExpandedUrl, *pcstrLocation, NULL, pDwnBindInfo, NULL, &cvarFrameName);
                }
                else
                {
                    hr = DelegateNavigation(INET_E_TERMINATED_BIND, *pcstrInExpandedUrl, *pcstrLocation, NULL, pDwnBindInfo, NULL);
                }
                goto Cleanup;
            }
            else
            {
                fForceUpdate = TRUE;
            }
        }

        if (fOpenInNewWindow)
        {
            CFrameSite * pFrameSite = NULL;

            // Last argument is debug flag saying this markup will get a window.
            hr = CreateMarkup(&pMarkup, NULL, NULL, FALSE, NULL DBG_COMMA WHEN_DBG(TRUE));
            if (hr)
                goto Cleanup;

            // This markup will be trusted if it is the content of a trusted frame
            // (i.e a frame with APPLICATION=yes specified and whose parent frame is also trusted).
            if (pElementMaster)
            {
                Assert(pElementMaster->Tag() == ETAG_IFRAME || pElementMaster->Tag() == ETAG_FRAME);
                pFrameSite = DYNCAST(CFrameSite, pElementMaster);
            }

            // The markup trusted has to be called before the window is created for this markup. 
            // DO NOT change the order here.
            
            // set the markup trust bit if applicable
            if (IsHostedInHTA() || _fInTrustedHTMLDlg)
            {
                if (pFrameSite)
                {
                    pMarkup->SetMarkupTrusted(pFrameSite->_fTrustedFrame);
                }
                else
                {
                    // we hit this codepath from CreateDocumentFromUrl, 
                    // which is only available through binary, so it's 
                    // likely that it's safe to set this to TRUE. however,
                    // there may be other codepaths involved, so I'm doing
                    // the safe thing and setting it to FALSE
                    pMarkup->SetMarkupTrusted(FALSE);
                }
            }

            // create a window associate it with this markup
            hr = THR(pMarkup->CreateWindowHelper());
            if (hr)
                goto Cleanup;

            pWindowForEvents = pMarkup->Window();
            if (dwFlags & FHL_CREATEDOCUMENTFROMURL)
                pWindowForEvents->Window()->_fCreateDocumentFromUrl = TRUE;


            // if this is a frame and the frame is marked as restricted, carry
            // the information through the window object.
            Assert( !pElementMaster || pFrameSite);
            if (pElementMaster && pFrameSite->_fRestrictedFrame)
            {
                pWindowForEvents->Window()->_fRestricted = TRUE;
            }

            if (dwFlags & FHL_FRAMECREATION)
            {
                pWindowForEvents->Window()->_pWindowParent = pCWindow;
                pWindowForEvents->Window()->_pWindowParent->SubAddRef();
            }
        }
        
        //
        // The logic here needs to be done in two phases:
        //   1) Find the window which needs to be navigated.  
        //      Potentially this might need to be marshalled over somewhere.  
        //   2) Navigate that window doing the active view pending view thing.
        //      So, each window will have two views.  
        //

        // Fire the BeforeNavigate2 event.
        //
        if (!pStmHistory && (!(dwFlags & FHL_SHDOCVWNAVIGATE) || !pWindowForEvents->Window()->IsPrimaryWindow()))
        {
            BYTE *    pPostData = NULL;
            DWORD     cbPostData = 0;
            TCHAR *   pchHeaders = NULL;

            GetHeadersAndPostData(pDwnBindInfo, &pPostData, &cbPostData, &pchHeaders);

            _webOCEvents.BeforeNavigate2(pWindowForEvents,
                                         &fCancel,
                                         *pcstrInExpandedUrl,
                                         pcstrLocation ? *pcstrLocation : NULL,
                                         pchName ? pchName : pWindowForEvents->Window()->_cstrName,
                                         pPostData, 
                                         cbPostData, 
                                         pchHeaders, 
                                         (!(dwFlags & FHL_FRAMECREATION) &&
                                          !(dwFlags & CDoc::FHL_RESTARTLOAD)));

            MemFreeString(pchHeaders);

            // Save whether we are in a frame creation on the window so we can access it when we complete the navigation

            if  ((dwFlags & FHL_FRAMECREATION) || (dwFlags & FHL_RESTARTLOAD))             
                pWindowForEvents->Window()->_fNavFrameCreation = TRUE;
            else
                pWindowForEvents->Window()->_fNavFrameCreation = FALSE;

            if (!fLocalNavigation && !pWindowForEvents->Window()->IsPrimaryWindow())
            {
                _webOCEvents.FireDownloadEvents(pWindowForEvents,
                                                CWebOCEvents::eFireDownloadBegin);
            }
        }

        // If fCancel is true we can return, but only if 
        // we are not creating a new window. In the case where
        // we are creating a new window and the navigation is
        // canceled, we must still create the window but
        // nat navigate it to the URL.
        //
        if (!fOpenInNewWindow && fCancel)
        {
            goto Cleanup;
        }

        if (ppWindowOut)
        {
            *ppWindowOut = NULL;
        }

        // Check if the browser is offline. If so, only
        // navigate if the page is in the cache or if 
        // the user has chosen to connect to the Web.
        //
        hr = pcstrInExpandedUrl->AllocBSTR(&V_BSTR(&cvarUrl));
        if (hr)
            goto Cleanup;

        V_BOOL(&cvarContinue) = VARIANT_TRUE;

        Assert(_pClientSite);
        IGNORE_HR(CTExec(_pClientSite, &CGID_ShellDocView, 
                         SHDVID_CHECKINCACHEIFOFFLINE, 0, &cvarUrl, &cvarContinue));

        if (VARIANT_FALSE == V_BOOL(&cvarContinue))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        Assert(pcstrInExpandedUrl && pcstrLocation);

        // If the URL is a reference to a bookmark in this CDoc don't
        // reload -- just navigate to that bookmark (except when navigation is
        // done for a form submission).
        // TODO: (jbeda) shdocvw doesn't do this if it can't use the cache
        //
        if (!fCancel && !(dwFlags & FHL_FORMSUBMIT) && fLocalNavigation)
        {
            // Update the travel log. The window data must be
            // updated before navigating because the window 
            // can actually change and the window stream 
            // will be incorrect. The travel log is only updated
            // if the navigation is successful.
            //
            DWORD dwPositionCookie;

            BOOL fIsSameUrl = IsSameUrl(CMarkup::GetUrl(pCWindow->_pMarkup),
                                        CMarkup::GetUrlLocation(pCWindow->_pMarkup),
                                        *pcstrInExpandedUrl,
                                        *pcstrLocation,
                                        fSendAsPost);

            IGNORE_HR(pCWindow->GetPositionCookie(&dwPositionCookie));
            pCWindow->UpdateWindowData(dwPositionCookie);

            hr = CMarkup::SetUrlOriginal(pCWindow->_pMarkup, pchUrlOriginal);
            if (hr)
                goto Cleanup;

            hr = THR(pCWindow->_pMarkup->NavigateHere(dwFlags, *pcstrLocation, 0, TRUE));

            // if success, done
            if (!hr)
            {
                _fShdocvwNavigate = !!(dwFlags & FHL_SHDOCVWNAVIGATE);

                if (!fIsSameUrl)
                    UpdateTravelLog(pCWindow, TRUE, TRUE, TRUE, NULL, fForceUpdate);
            }

            // NOTE - if IsSameUrl and the bookmark name is not in the local document
            // we are not turning the metarefresh timer back on (108105). this seems 
            // to be safe since the url is the same, the document is fully loaded, and the url 
            // wasn't found.. so this is actually an optimization

            // for 5.0 compat we need to fire these event regarless of sucess/failure
            _webOCEvents.NavigateComplete2(pWindowForEvents);
            _webOCEvents.DocumentComplete(pWindowForEvents, 
                                          CMarkup::GetUrl(pWindowForEvents->Window()->_pMarkup),
                                          CMarkup::GetUrlLocation(pWindowForEvents->Window()->_pMarkup));

            // In any case, we don't want to do a real navigate
            hr = S_OK;
                
            goto Cleanup;
        }

        // If we were asked to set the target's media property, do it now, before loading from URL
        if (dwFlags & FHL_SETTARGETPRINTMEDIA)
        {
            pTargetDocument = pMarkup->Document();
            Assert(pTargetDocument);

            bstrMedia = SysAllocString(_T("print"));

            if (bstrMedia)
            {
                IGNORE_HR(pTargetDocument->putMediaHelper(bstrMedia));
            }
        }

        if (!fCancel)
        {
            // At this point we know that we are going to at least start a non-local navigation
            // of the Doc. I don't want to do this in SwitchMarkup, because of the special handling 
            // of MIME types.

            _fMhtmlDocOriginal = FALSE;


            if ((dwFlags & FHL_SHDOCVWNAVIGATE) && (URL_SCHEME_FILE == GetUrlScheme(*pcstrInExpandedUrl)))
            {
                hr = THR(CreateURLMonikerEx(NULL, *pcstrInExpandedUrl, &pMoniker, URL_MK_NO_CANONICALIZE));
            }
            else
            {
                hr = THR(CreateURLMoniker(NULL, *pcstrInExpandedUrl, &pMoniker));
            }
            if (hr)
                goto Cleanup;

            // If the protocol doesn't navigate (such as mailto:), just bind to the moniker
            if (!fProtocolNavigates)
            {
                IUnknown *pUnknown = NULL;
                IBindStatusCallback *pPreviousBindStatusCallback = NULL;
                BOOL fAddToHistory = FALSE;
                HRESULT hrBind;

                hr = THR( RegisterBindStatusCallback( pBindCtx, pDwnBindInfo,
                    &pPreviousBindStatusCallback, 0) );
                if (hr)
                    goto Cleanup;
            
                ReleaseInterface(pPreviousBindStatusCallback);
                hrBind = (pMoniker->BindToObject(
                        pBindCtx, NULL, IID_IUnknown, (void**)&pUnknown));

                if (hrBind == INET_E_UNKNOWN_PROTOCOL)
                {
                    // Here we check to see if it is a URL we really want to shell execute
                    // so it is handled by helper apps.....else it really is an error
                    
                    if (ShouldShellExecURL(pchURL))
                    {
                        TCHAR            szDecodedURL[INTERNET_MAX_URL_LENGTH];
                        DWORD            cchDecodedURL = ARRAY_SIZE(szDecodedURL);

                        if (PrepareURLForExternalApp(pchURL, 
                                                     szDecodedURL, 
                                                     INTERNET_MAX_URL_LENGTH,
                                                     &cchDecodedURL))
                        {
                            SHELLEXECUTEINFO sei = {0};

                            sei.cbSize = sizeof(sei);
                            sei.lpFile = szDecodedURL;
                            sei.nShow  = SW_SHOWNORMAL;

                            fAddToHistory = ShellExecuteEx(&sei);
                        }
                    }
                }
                else
                    fAddToHistory = !FAILED(hrBind);
                
                // Successfully navigated to that protocol
                if (   fAddToHistory
                    && (FHL_HYPERLINKCLICK & dwFlags)
                   )
                {
                    hr = EnsureUrlHistory();
                    if (S_OK == hr)
                    {
                        _pUrlHistoryStg->AddUrl(pchURL,
                                                NULL, // pchTitle
                                                ADDURL_ADDTOHISTORYANDCACHE);
                    }
                }
                ReleaseInterface(pUnknown);
                goto Cleanup;
            }

            if (!fOpenInNewWindow)
            {
                if (!pWindow->Fire_onbeforeunload())
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
                if (dwFlags & FHL_LOADHISTORY)
                {
                    // freeze the old markup and nuke any pending readystate changes
                    pCWindow->_pMarkup->ExecStop(TRUE, FALSE);
                }
            }
        }

        if (!pMarkup)
        {
            if (dwFlags & FHL_LOADHISTORY)
            {
                Assert(!fOpenInNewWindow);

                if (pWindow->Window()->_pMarkupPending)
                    pMarkup = pWindow->Window()->_pMarkupPending;
                else
                    pMarkup = pWindow->Window()->_pMarkup;

                pMarkup->_fHardStopDone = FALSE;
                pMarkup->AddRef();
            }
            else
            {
                // Last argument is debug flag saying this markup will get a window.
                hr = pWindow->Window()->Doc()->CreateMarkup(&pMarkup, NULL, NULL, FALSE, fOpenInNewWindow ? NULL : pWindow DBG_COMMA WHEN_DBG(TRUE));
                if (hr)
                    goto Cleanup;
            }

            pWindow->Window()->ClearMetaRefresh();
        }

        pMarkup->_fInRefresh = !! ( dwFlags & FHL_REFRESH );        

        if (   !fCancel
            && pMarkup)
        {
            // these are used in LoadStatusINteractive to add this url
            // to the history stream.
            hr = EnsureUrlHistory();

            if (   !FAILED(hr)
                && (FHL_HYPERLINKCLICK & dwFlags))
            {
                // (109771) for redirected links we need to call this here for the cache.
                Assert(_pUrlHistoryStg);
                _pUrlHistoryStg->AddUrl(*pcstrInExpandedUrl, NULL, ADDURL_ADDTOCACHE);

                pMarkup->_fNavFollowHyperLink = TRUE;
            }
        }

        if (!fCancel)
        {
            LOADINFO    LoadInfo = { 0 };
            CStr        cstrSearch;

            LoadInfo.pmk   = pMoniker;
            LoadInfo.pbctx = pBindCtx;
            LoadInfo.pchUrlOriginal = const_cast<TCHAR*>(pchUrlOriginal);
            LoadInfo.pElementMaster  = pElementMaster;
            LoadInfo.pchExtraHeaders = (TCHAR *) pchExtraHeaders;
            // For "file://" URLs, we need to ask for the query string explicitly (#90338)
            // shdocvw does not give it to us 
            if (GetUrlScheme(*pcstrInExpandedUrl) == URL_SCHEME_FILE)
            {
                hr = GetUrlComponentHelper(
                                    *pcstrInExpandedUrl,
                                    &cstrSearch,
                                    0,
                                    URLCOMP_SEARCH,
                                    TRUE);
                if (hr)
                    goto Cleanup;
                LoadInfo.pchSearch = cstrSearch;
            }


            if (   pDwnBindInfo
                && pDwnBindInfo->GetDwnDoc()
                && (dwFlags & (FHL_HYPERLINKCLICK | FHL_SETURLCOMPONENT | FHL_FRAMECREATION)))
            {
                // Before Native Frames, shdocvw would start the navigation using this BindInfo
                // and then abort it.  However, it was enough to get Urlmon to start bringing
                // down the new bits if this flag was out.  Because we don't do this bind now,
                // we have to prop this flag through the loadinfo.

                // This line was anding out BINDF_NEEDFILE which we need if it was set
                // TODO: Investigate which other flags might be need.
                LoadInfo.dwBindf |= pDwnBindInfo->GetDwnDoc()->GetBindf() & (BINDF_HYPERLINK | BINDF_FORMS_SUBMIT);

                // When a frame is being created, the frame window is not created until
                // DoNavigate, but the dwBindf flags are set at the top of FollowHyperlink.
                // This is the last place we can set the flags for a frame page itself so
                // we can relay the information that it is security=restricted to the binding code.
                if (pWindowForEvents->Window()->_fRestricted)
                    LoadInfo.dwBindf |= BINDF_ENFORCERESTRICTED;
            }

            if (!fOpenInNewWindow)
            {
                LoadInfo.fStartPicsCheck = TRUE;
            }

            LoadInfo.fShdocvwNavigate = !!(dwFlags & FHL_SHDOCVWNAVIGATE);
            LoadInfo.fMetaRefresh = !!(dwFlags & FHL_METAREFRESH);
            LoadInfo.fDontUpdateTravelLog = !!(dwFlags & FHL_DONTUPDATETLOG);
            LoadInfo.fCreateDocumentFromUrl = !!(dwFlags & FHL_CREATEDOCUMENTFROMURL);
            if (!LoadInfo.fCreateDocumentFromUrl)
                LoadInfo.fDontFireWebOCEvents = !!(dwFlags & FHL_DONTFIREWEBOCEVENTS);

            pMarkup->_fReplaceUrl = !! ( dwFlags & FHL_REPLACEURL ); 
            
            if (pStmHistory)
            {
                DWORD dwBindf;

                pMarkup->_fLoadingHistory = TRUE;

                if (   pDwnBindInfo
                    && pDwnBindInfo->GetDwnDoc()
                   )
                {
                    dwBindf = pDwnBindInfo->GetDwnDoc()->GetBindf();
                }
                else
                {
                    dwBindf = BINDF_FWD_BACK;
                }

                // When a frame is being created, the frame window is not created until
                // DoNavigate, but the dwBindf flags are set at the top of FollowHyperlink.
                // This is the last place we can set the flags for a frame page itself so
                // we can relay the information that it is security=restricted to the binding code.
                if (pWindowForEvents->Window()->_fRestricted)
                    dwBindf |= BINDF_ENFORCERESTRICTED;

                hr = THR(pMarkup->LoadHistoryInternal(pStmHistory,
                                                      pBindCtx,
                                                      dwBindf,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      0,
                                                      pElementMaster,
                                                      dwFlags,
                                                      pchName));

                if (hr)
                    goto Cleanup;
            }

            if (hr || !pStmHistory)
            {
                LoadInfo.fErrorPage = !!(dwFlags & FHL_ERRORPAGE);
                LoadInfo.fFrameTarget = fFrameTarget;

                hr = THR(pMarkup->LoadFromInfo(&LoadInfo, NULL ,pchCallerUrl));
                if (hr)
                {   
                    if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)  // 0x04c7
                    {
                        // If this error gets bubbled up to a script, we get
                        // a script error.  For compat with 5.01, we need to
                        // suppress the error code.
                        hr = S_OK;
                    }
                    goto Cleanup;
                }
            }

            if( !fOpenInNewWindow && !(dwFlags & FHL_LOADHISTORY))
            {
                // freeze the old markup and nuke any pending readystate changes
                pCWindow->_pMarkup->ExecStop(TRUE, FALSE);
            }
            
        }

        if (fOpenInNewWindow)
        {
            if (ppWindowOut)
            {
                *ppWindowOut = pMarkup->Window();
                (*ppWindowOut)->AddRef();
            }
        }
        else
        {
            pCWindow->UpdateWindowData(NO_POSITION_COOKIE);
        }

        if (fCancel)
            goto Cleanup;
            
        // Start up the task to navigate to the hyperlink
        // Shdocvw does this when we go interactive but this should work
        if (pcstrLocation->Length())
        {
            // Apphack for Autocad (see IE6 bug # 31485) - do not spawn task for error pages
            if ( g_fInAutoCad && (dwFlags & FHL_ERRORPAGE) && (dwFlags & FHL_SHDOCVWNAVIGATE) )
                goto Cleanup;

            // NB: Don't call NavigateHere because that will EnsureWindow and cause us
            // to increment _cDie and hence return E_ABORT.  Instead, just start up
            // the task to run later.
            IGNORE_HR( pMarkup->StartBookmarkTask(*pcstrLocation, dwFlags) );
        }
        
    }


    
Cleanup:

    if ( pfLocalNavigation )
    {
        *pfLocalNavigation = fLocalNavigation; 
    }
    
    // If the navigation was synchronous (e.g. as in Outlook9, see bug 31960),
    // the old document is destroyed at this point! All the callers in the
    // call stack above this function need to handle this gracefully. Set hr
    // to E_ABORT so that these callers abort furhter processing and return
    // immediately.
    if (_cDie != cDie)
        hr = E_ABORT;

    ReleaseInterface(pMoniker);
    ReleaseInterface(pHlink);
    ReleaseInterface(pHlinkFrame);
    ReleaseInterface(pTargetHTMLWindow);
    SysFreeString(bstrMedia);

    if (pMarkup)
    {
        pMarkup->Release();
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::DoNavigateOutOfProcess(IHTMLWindow2 * pTargetHTMLWindow,
                             TCHAR * pchExpandedUrl,
                             TCHAR * pchLocation,
                             TCHAR * pchUrlOriginal,
                             IBindCtx * pBindCtx,
                             DWORD dwFlags)
{
    HRESULT                 hr;
    BSTR                    bstrUrl       = NULL;
    BSTR                    bstrLocation  = NULL;
    BSTR                    bstrOriginal = NULL;
    IHTMLPrivateWindow2  *  pIPrivWin2    = NULL;

    hr = FormsAllocString(pchExpandedUrl, &bstrUrl);
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(pchLocation, &bstrLocation);
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(pchUrlOriginal, &bstrOriginal);
    if (hr)
        goto Cleanup;

    // Need this in the target window to determine whether to reset the privacy list or not
    dwFlags |= FHL_EXTERNALNAVIGATECALL;

    // If the target window is a Trident window call NavigateEx.
    // Otherwise it is a shell window most likely showing a folder without web view turned on.
    // We should call IHTMLWindow2::navigate directly in that case
    //
    hr = THR(pTargetHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow2, (void **) &pIPrivWin2));
    if (!hr)
    {
        hr = THR(pIPrivWin2->NavigateEx(bstrUrl, bstrOriginal, bstrLocation, NULL, pBindCtx, 0, dwFlags));
    }
    else
    {
        CStr    cstrTmp;

        // Clear the bind context param structure if there is one. Normally, the receiving Trident 
        // instance clears this. But this call path does not hit Trident and we will leak it if 
        // we don't take it out of the bind context here. 
        IGNORE_HR(GetBindContextParam(pBindCtx, &cstrTmp));

        hr = THR(pTargetHTMLWindow->navigate(bstrOriginal));
    }
    if (hr)
        goto Cleanup;

Cleanup:
    SysFreeString(bstrUrl);
    SysFreeString(bstrLocation);
    SysFreeString(bstrOriginal);
    ReleaseInterface(pIPrivWin2);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::StartBookmarkTask
//
//+---------------------------------------------------------------------------

HRESULT
CMarkup::StartBookmarkTask(LPCWSTR wzJumpLocation, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CTaskLookForBookmark * pBMTask = NULL;

    // First kill of any previous task
    TerminateLookForBookmarkTask();

    // Create the new task
    pBMTask = new CTaskLookForBookmark(this);
    if (pBMTask == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        CMarkupTransNavContext * ptnc = EnsureTransNavContext();
        if (!ptnc)
        {
            pBMTask->Terminate();
            pBMTask->Release();
            pBMTask = NULL;
            hr = E_OUTOFMEMORY;

            goto Cleanup;
        }
        ptnc->_pTaskLookForBookmark = pBMTask;
    }

    // Set the jump location
    hr = THR(pBMTask->_cstrJumpLocation.Set(wzJumpLocation));
    if (hr)
    {
        TerminateLookForBookmarkTask();
        goto Cleanup;
    }

    pBMTask->_dwFlags = dwFlags;

    // and here is the magic that acutally sets the # information for the OM string
    // see CDoc:get_URL for a discussion on why this is here
    //-----------------------------------------------------------------------------
    if (wzJumpLocation[0] !=_T('#'))
    {
        CStr cstr;
        cstr.Set(_T("#"));
        cstr.Append(wzJumpLocation);

        IGNORE_HR(SetUrlLocation(this, cstr));
    }
    else
    {
        IGNORE_HR(SetUrlLocation(this, wzJumpLocation));
    }

Cleanup:
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NotifyDefView
//
//  Synopsis:   Notifies the defview folder of our navigation.
//
//+---------------------------------------------------------------------------

void
CDoc::NotifyDefView(TCHAR * pchUrl)
{
    if (!_pClientSite)
        return;

    Assert(_fDefView);

    CVariant cvarUrl(VT_BSTR);

    // Do not pass the original URL to DefView. 
    // The encoded URL must be sent. When you click on 
    // a link to "My Documents", for example, the original
    // url is file:///::clsid, where clsid is the clsid of the
    // folder. Sending this URL to DefView causes it to show a 
    // blank page because there is an extra /. Encoding the URL
    // removes the extra /.
    //

    FormsAllocString(pchUrl, &V_BSTR(&cvarUrl));

    IGNORE_HR(CTExec(_pClientSite, &CGID_DocHostCmdPriv,
                     DOCHOST_DOCHYPERLINK, NULL, &cvarUrl, NULL));

    UpdateTitle();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRootFrame
//
//  Synopsis:   Finds the root frame of the specified frame
//              by climing up parents.
//
//----------------------------------------------------------------------------
HRESULT
GetRootFrame(IUnknown *pUnkFrame, IUnknown **ppUnkRootFrame)
{
    IUnknown *pUnkScan = pUnkFrame;
    ITargetFrame2 *pTargetFrameRoot = NULL;
    HRESULT hr;

    pUnkScan->AddRef();

    // run up to target root
    for (;;)
    {
        hr = THR(pUnkScan->QueryInterface(IID_ITargetFrame2, (void**)&pTargetFrameRoot));
        if (hr)
            goto Cleanup;

        pUnkScan->Release();
        pUnkScan = NULL;

        hr = THR(pTargetFrameRoot->GetParentFrame(&pUnkScan));
        if (hr)
            pUnkScan = NULL;

        if (!pUnkScan)
            break;

        pTargetFrameRoot->Release();
        pTargetFrameRoot = NULL;
    }
    Assert(!pUnkScan);
    Assert(pTargetFrameRoot);

    hr = THR(pTargetFrameRoot->QueryInterface(IID_IUnknown, (void**)ppUnkRootFrame));

Cleanup:
    ReleaseInterface(pUnkScan);
    ReleaseInterface(pTargetFrameRoot);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FollowHistory
//
//  Synopsis:   Goes forward or backward in history via automation on the
//              hosting shdocvw
//
//----------------------------------------------------------------------------
HRESULT
CDoc::FollowHistory(BOOL fForward)
{
    HRESULT             hr;
    ITargetFrame      * pTargetFrameSource = NULL;
    IUnknown          * pUnkSource = NULL;
    IUnknown          * pUnkTarget = NULL;
    IServiceProvider  * pServiceTarget = NULL;
    IWebBrowserApp    * pWebBrowserApp = NULL;

    hr = THR(QueryService(IID_ITargetFrame, IID_ITargetFrame, (void**)&pTargetFrameSource));
    if (hr)
        goto Cleanup;

    hr = THR(pTargetFrameSource->QueryInterface(IID_IUnknown, (void**)&pUnkSource));
    if (hr)
        goto Cleanup;

    hr = THR(pTargetFrameSource->FindFrame(_T("_top"), pUnkSource, FINDFRAME_JUSTTESTEXISTENCE, &pUnkTarget));
    if (!pUnkTarget)
        hr = E_FAIL;
    if (hr)
        goto Cleanup;

    hr = THR(pUnkTarget->QueryInterface(IID_IServiceProvider, (void**)&pServiceTarget));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceTarget->QueryService(IID_IWebBrowserApp, IID_IWebBrowserApp,(void**)&pWebBrowserApp));
    if (hr)
        goto Cleanup;

    if (fForward)
        pWebBrowserApp->GoForward();
    else
        pWebBrowserApp->GoBack();

Cleanup:
    ReleaseInterface(pTargetFrameSource);
    ReleaseInterface(pUnkSource);
    ReleaseInterface(pUnkTarget);
    ReleaseInterface(pServiceTarget);
    ReleaseInterface(pWebBrowserApp);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureUrlHistory
//
//  Synopsis:   populates the _pUrlHistoryStg variable.
//              returns S_OK if variable is valid, otherwise error code.
//
//----------------------------------------------------------------------------

HRESULT 
CDoc::EnsureUrlHistory()
{
    HRESULT hr;
        
    if(!_pUrlHistoryStg)
    {
        hr = QueryService(SID_SUrlHistory, IID_IUrlHistoryStg, (LPVOID*)&_pUrlHistoryStg);

        if(FAILED(hr))
        {
            goto Cleanup;
        }
        if (!_pUrlHistoryStg)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    hr = S_OK;
Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::IsVisitedHyperlink
//
//  Synopsis:   returns TRUE if the given url is in the Hisitory
//
//              Currently ignores #location information
//
//----------------------------------------------------------------------------

BOOL
CDoc::IsVisitedHyperlink(LPCTSTR pchURL, CElement *pElementContext)
{
    HRESULT     hr              = S_OK;
    TCHAR       cBuf[pdlUrlLen];
    TCHAR*      pchExpandedUrl  = cBuf;
    BOOL        result          = FALSE;
    TCHAR *     pch;

    // fully resolve URL
    hr = THR(CMarkup::ExpandUrl(
            NULL, pchURL, ARRAY_SIZE(cBuf), pchExpandedUrl, pElementContext));
    if (hr)
        goto Cleanup;

    pch = const_cast<TCHAR *>(UrlGetLocation(pchExpandedUrl));

    Assert(!pchExpandedUrl[0] || pchExpandedUrl[0] > _T(' '));

    // Use the history cache-container from wininet

    hr = EnsureUrlHistory();
    if (hr)
    {
        result = FALSE;
        goto Cleanup;
    }

    Assert(_pUrlHistoryStg);

    if (pchExpandedUrl)
    {
        hr = _pUrlHistoryStg->QueryUrl(pchExpandedUrl, 0, NULL);
        result = (SUCCEEDED(hr));
    }
    else
    {
        result = FALSE;
    }

Cleanup:

    return result;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetBrowseContext, IHlinkTarget
//
//  Synopsis:   Hosts calls this when we're being hyperlinked to in order
//              to supply us with the browse context.
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    ReplaceInterface(&_phlbc, pihlbc);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetBrowseContext, IHlinkTarget
//
//  Synopsis:   Returns our browse context
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDoc::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    *ppihlbc = _phlbc;
    if (_phlbc)
    {
        _phlbc->AddRef();
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NavigateOutside, helper
//
//  Synopsis:   called when there is no client site for the doc; e.g., if
//              the doc is created inside Word or Excel as doc supporting
//              a hyperlink. In this case we launch an IE instance through
//              call to shdocvw.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::NavigateOutside(DWORD grfHLNF, LPCWSTR pchLocation)
{
#if !defined(WINCE) && !defined(WIN16)

    HRESULT   hr     = E_FAIL;
    IHlink  * pHlink = NULL;
    CMarkup * pMarkupPrimary = PrimaryMarkup(); 
    IBindCtx* pbc = NULL;

    // TODO: IE 3/4 classic implements an empty hlink site; we pass NULL.
    if (pMarkupPrimary)
    {
        hr = THR(HlinkCreateFromMoniker(pMarkupPrimary->GetNonRefdMonikerPtr(), pchLocation, NULL,
                 NULL, 0, NULL, IID_IHlink, (LPVOID*) &pHlink));
        if (hr)
            goto Cleanup;

        pbc = pMarkupPrimary->HtmCtx()->GetBindCtx();
        hr = THR(HlinkFrameNavigate(0, pbc, NULL, pHlink, _phlbc));
    }

Cleanup:
    ReleaseInterface(pHlink);

    RRETURN (hr);
#else // !WINCE
    RRETURN (E_FAIL);
#endif // !WINCE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NavigateNow, helper
//
//  Synopsis:   Forces a recalc up until the position specified in the
//              current bookmark task, if any.
//
//----------------------------------------------------------------------------

void
CMarkup::NavigateNow(BOOL fScrollBits)
{
    if (!HasTransNavContext())
        return;

    CTaskLookForBookmark * pBMTask = GetTransNavContext()->_pTaskLookForBookmark;

    if (    pBMTask
        &&  !pBMTask->_cstrJumpLocation
        &&  LoadStatus() >= LOADSTATUS_INTERACTIVE
        &&  Doc()->_view.IsActive()
        &&  GetElementClient()
        &&  GetElementClient()->Tag() == ETAG_BODY)
    {
        CFlowLayout *   pFlowLayout = GetElementClient()->HasFlowLayout();
        RECT            rc;
        Assert(pFlowLayout);

        pFlowLayout->GetClientRect(&rc);
        pFlowLayout->WaitForRecalc(-1, pBMTask->_dwScrollPos + rc.bottom - rc.top);

        NavigateHere(0, NULL, pBMTask->_dwScrollPos, fScrollBits);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::NavigateHere, helper
//
//  Synopsis:   Called when the document lives inside IE (shdocvw).
//              If wzJumpLocation is not NULL, treat it as a bookmark and jump
//              there. Otheriwse, scroll the document to dwScrollPos.
//
//----------------------------------------------------------------------------

HRESULT
CMarkup::NavigateHere(DWORD grfHLNF, LPCWSTR wzJumpLocation, DWORD dwScrollPos, BOOL fScrollBits)
{
    HRESULT     hr                  = S_OK;
    CElement *  pElemBookmark;
    TCHAR    *  pBookmarkName;
    LONG        iStart, iStartAll;
    LONG        iHeight;
    BOOL        fBookmark;
    BOOL        fCreateTask         = FALSE;
    CDoc *      pDoc                = Doc();
    BOOL        fPrinting           = IsPrintMedia();
    CElement    * pElementClient    = GetCanvasElement();
    CMarkupTransNavContext * ptnc   = GetTransNavContext();
    CTaskLookForBookmark * pBMTask  = ptnc ? ptnc->_pTaskLookForBookmark : NULL;
    BOOL        fDontAdvanceStart   = FALSE;

    CCollectionCache * pCollectionCache;

    Assert( HasWindowPending() );
    Assert(!wzJumpLocation || dwScrollPos == 0);

    // Don't create bookmark task for print documents.
    if (fPrinting)
        goto Cleanup;

    fBookmark = (wzJumpLocation != NULL);

    if (!fBookmark)
    {
        if (!pElementClient) // not yet created
            fCreateTask = TRUE;
        else if (!IsScrollingElementClient(pElementClient)) // don't bother
            goto Cleanup;
        else
        {
            CElement * pElementScrolling = pElementClient;
            CLayout  * pLayoutScrolling  = pElementScrolling->GetUpdatedLayout();

            if (pLayoutScrolling)
            {
                RECT rc;
                pLayoutScrolling->GetClientRect(&rc);
                iHeight = rc.bottom - rc.top;
            }
            else
            {
                iHeight = 0;
            }
        
            if (    pDoc->State() < OS_INPLACE
                ||  (   (    LoadStatus() < LOADSTATUS_PARSE_DONE
                         ||  !pLayoutScrolling->FRecalcDone()
                        )
                    &&  pLayoutScrolling->GetContentHeight() < ((long)dwScrollPos + iHeight)
                    )
               )
            {
                fCreateTask = TRUE;
            }
            else
            {
                CDocInfo DCI(pElementScrolling);

                OnLoadStatus(LOADSTATUS_INTERACTIVE);
                pLayoutScrolling->ScrollToY(dwScrollPos, fScrollBits ? 0 : -1);
            }
        }

        // Perf optimization:
        // We don't a need a task to scroll to top. The only time we need to scroll
        // AND dwScrollPos is 0 is when we are navigating upward within the same
        // document (bug 37614). However, in this case the doc (or at leats its top)
        // is already loaded.
        if (fCreateTask && dwScrollPos == 0)
            goto Cleanup;

        pCollectionCache = CollectionCache();

        // Clear any existing OM string for the jump location
        SetUrlLocation(this, NULL);
    }
    else
    {
        if (_tcslen(wzJumpLocation) == 0)
            goto Cleanup;

        // and here is the magic that acutally sets the # information for the OM string
        // see CDoc:get_URL for a discussion on why this is here
        //-----------------------------------------------------------------------------
        if (wzJumpLocation[0] !=_T('#'))
        {
            CStr cstr;
            cstr.Set(_T("#"));
            cstr.Append(wzJumpLocation);

            IGNORE_HR(SetUrlLocation(this, cstr));
        }
        else
        {
            IGNORE_HR(SetUrlLocation(this, wzJumpLocation));
        }


        // Now continue on with the effort of determining where to scroll to
        //prepare the anchors' collection
        hr = EnsureCollectionCache(CMarkup::ANCHORS_COLLECTION);
        if (hr)
            goto Cleanup;

        pCollectionCache = CollectionCache();
        pBookmarkName = (TCHAR *)wzJumpLocation;

        iStart = iStartAll = 0;

        // Is this the same location we had stashed away? If yes then
        // do the incremental search, else search from the beginning
        if (pBMTask)
        {
            CStr cstrTemp;

            cstrTemp.Set(wzJumpLocation);
            if (pBMTask->_cstrJumpLocation.Compare(&cstrTemp))
            {
                // Check the collections' cookie because they might been changed
                if(pBMTask->_lColVer == pCollectionCache->GetVersion(CMarkup::ANCHORS_COLLECTION))
                {
                    // Continue the search
                    iStart = pBMTask->_iStartSearchingAt;
                    iStartAll = pBMTask->_iStartSearchingAtAll;
                }
                else
                {
                    // Restart the search from the beginning
                    iStart = iStartAll = 0;
                }
            }
        }

        // Find the element with given name attribute in the anchors' collection
        hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ANCHORS_COLLECTION,
            pBookmarkName, FALSE, &pElemBookmark, iStart));
        if(FAILED(hr) || !pElemBookmark)
        {
            // Try to search without the starting #
            if(pBookmarkName[0] == _T('#') && pBookmarkName[1])
            {
                pBookmarkName++;
                hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ANCHORS_COLLECTION,
                    pBookmarkName, FALSE, &pElemBookmark, iStart));

                // If not found try to search all element collection
                if(FAILED(hr) || !pElemBookmark)
                {
                    // Restore the bookmark name pointer
                    pBookmarkName--;

                    // prepare the elements' collection
                    hr = EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION);
                    if (hr)
                        goto Cleanup;

                    hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION,
                        pBookmarkName, FALSE, &pElemBookmark, iStartAll));
                    if(FAILED(hr) || !pElemBookmark)
                    {
                        // Try to search without the starting #
                        if(pBookmarkName[0] == _T('#') && pBookmarkName[1])
                        {
                            pBookmarkName++;
                            hr = THR_NOTRACE(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION,
                                pBookmarkName, FALSE, &pElemBookmark, iStartAll));
                        }
                    }
                }
            }
         }


        // treat mutliple anchors with the same name as okay
        if (FAILED(hr))
        {
            // DISP_E_MEMBERNOTFOUND is the only E_ hr that GetIntoAry may return
            Assert(hr == DISP_E_MEMBERNOTFOUND);

            // '#top' and the '#' bookmark are a special case.  '#' is necesary for 
            // ie4/NS compat
            if (    (StrCmpIC(pBookmarkName, _T("top")) == 0) 
                ||  (StrCmpIC(pBookmarkName, _T("#"))   == 0))
            {
                // Scroll to the top of the document
                if (pElementClient)
                {
                    // TODO (jbeda) go interactive here?
                    pElementClient->GetUpdatedLayout()->
                        ScrollElementIntoView(NULL, SP_TOPLEFT, SP_TOPLEFT);
                }
            }
            else if (LoadStatus() < LOADSTATUS_PARSE_DONE)
            {
                fCreateTask = TRUE;
            }
        }
        else
        {
            // If for some reason we cannot show the element yet, then return.
            // Note: we keep _iStartSearchAt the same in this case and hence
            // we will be able to find this bookmark again.
            if (!pElemBookmark->CanShow())
            {
                fCreateTask = TRUE;
                fDontAdvanceStart = TRUE;
            }
            else
            {
                BOOL fSetCurrencyAndCaret = FALSE;
                
                OnLoadStatus(LOADSTATUS_INTERACTIVE);

                if (GetReadyState() < READYSTATE_INTERACTIVE)
                    goto Ret;
                
                // Mark the anchor current, but only if the currency is already
                // in this markup (#67170)
                if (    (grfHLNF & CDoc::FHL_HYPERLINKCLICK)
                    ||  !pDoc->_pElemCurrent
                    ||  !pDoc->_pElemCurrent->IsInMarkup()
                    ||  pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup(this)
                   )
                {
                    fSetCurrencyAndCaret = TRUE;
                    hr = THR(pElemBookmark->BubbleBecomeCurrent(0));
                    if (hr)
                        goto Cleanup;
                }
                hr = pElemBookmark->ScrollIntoView(SP_TOPLEFT, SP_MINIMAL, fScrollBits);
                if (hr)
                    goto Cleanup;

                // Fire the necessary navigation events. 
                //
    
                if (!_pDoc->_fHostNavigates && HasWindowPending())
                {
                    _pDoc->_webOCEvents.FireDownloadEvents(GetWindowPending(),
                                                           CWebOCEvents::eFireBothDLEvents);
                }

                if (    fSetCurrencyAndCaret
                    &&  pElemBookmark != pDoc->_pElemCurrent
                    &&  S_OK == pDoc->GetCaret(NULL)
                    &&  pDoc->_pCaret
                   )
                {
                    // Position the caret at the beginning of the bookmark, so that the
                    // next tab would go to the expected place (IE5 63832)
                    CMarkupPointer      ptrStart(pDoc);
                    IMarkupPointer *    pIStartBookmark; 
                    IDisplayPointer *   pDispStartBookmark;

                    Assert( pElemBookmark->GetMarkup() == this );

                    hr = ptrStart.MoveToCp(pElemBookmark->GetFirstCp(), pElemBookmark->GetMarkup());
                    if (hr)
                        goto Cleanup;

                    // TODO: make sure the type of selection isn't caret here
                    if (SUCCEEDED(ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStartBookmark)))
                    {
                        if (SUCCEEDED(_pDoc->CreateDisplayPointer(&pDispStartBookmark)))
                        {
                            if (SUCCEEDED(pDispStartBookmark->SetDisplayGravity(DISPLAY_GRAVITY_NextLine)))
                            {
                                if (SUCCEEDED(pDispStartBookmark->MoveToMarkupPointer(pIStartBookmark, NULL)))
                                {
                                    IGNORE_HR(_pDoc->_pCaret->MoveCaretToPointer(pDispStartBookmark, FALSE, CARET_DIRECTION_INDETERMINATE));
                                }
                            }
                            pDispStartBookmark->Release();
                        }
                        pIStartBookmark->Release();
                    }

                    pDoc->_fFirstTimeTab = FALSE;

                }
            }
        }
    }

    if (fCreateTask)
    {

        // Start the task that periodically wakes up and checks if we
        // can jump to the desired location.
        if (!pBMTask)
        {
            pBMTask = new CTaskLookForBookmark(this);
            if (pBMTask == NULL)
            {
                goto Ret;
            }

            {
                CMarkupTransNavContext * ptnc = EnsureTransNavContext();
                if (!ptnc)
                {
                    pBMTask->Terminate();
                    pBMTask->Release();
                    pBMTask = NULL;
                    goto Cleanup;
                }
                ptnc->_pTaskLookForBookmark = pBMTask;
            }
        }
        else
        {
            // Check if this is the last time this task needs to be tried.
            // For bookmarks, we can stop when the doc is fully loaded.
            // For setting scroll position, we need to also wait for the
            // doc to go in-place and the body site to get fully recalc'ed.
            if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
            {
                if (fBookmark)
                    goto Cleanup;
                
                if (   pDoc->State() >= OS_INPLACE
                    && LoadStatus() >= LOADSTATUS_DONE
                    && IsScrollingElementClient(pElementClient)
                   )
                {
                    CLayout *pLayoutScrolling = pElementClient->GetUpdatedLayout();
                    if (pLayoutScrolling->FRecalcDone())
                        goto Cleanup;
                }
            }
        }

        if (fBookmark)
        {
            pBMTask->_dwScrollPos = 0;
            pBMTask->_cstrJumpLocation.Set(wzJumpLocation);

            // prepare the anchors' collection
            hr = EnsureCollectionCache(CMarkup::ANCHORS_COLLECTION);
            if (hr)
                goto Cleanup;

            if (S_OK != pCollectionCache->GetLength (CMarkup::ANCHORS_COLLECTION, &iStart))
            {
                // Cannot find the length for some reason, we should
                // start searching from the beginning.
                iStart = 0;
            }
            
            if (!fDontAdvanceStart)
                pBMTask->_iStartSearchingAt = iStart;
                
            if (S_OK != pCollectionCache->GetLength (CMarkup::ELEMENT_COLLECTION, &iStartAll))
            {
                // Cannot find the length for some reason, we should
                // start searching from the beginning.
                iStartAll = 0;
            }
            pBMTask->_iStartSearchingAtAll = iStartAll;

            // Save the version of the collections
            pBMTask->_lColVer = pCollectionCache->GetVersion(CMarkup::ANCHORS_COLLECTION);
        }
        else
        {
            pBMTask->_dwScrollPos = dwScrollPos;
            pBMTask->_cstrJumpLocation.Free();

            if (pBMTask->_dwTimeGotBody)
            {
                // Delay interactivity for no more than five seconds after creating the body
                if (GetTickCount() - pBMTask->_dwTimeGotBody > 5000)
                {
                    OnLoadStatus(LOADSTATUS_INTERACTIVE);
                }
            }
            else if (IsScrollingElementClient(pElementClient))
            {
                pBMTask->_dwTimeGotBody = GetTickCount();
            }
        }
        goto Ret;
    }

Cleanup:
    TerminateLookForBookmarkTask();

Ret:
    
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Navigate, IHlinkTarget
//
//  Synopsis:   Called to tell us which jump-location we need to navigate to.
//              We may not have loaded the anchor yet, so we need to save
//              the location and only jump once we find the anchor.
//              Note that when we support IHlinkTarget, containers simply
//              call Navigate instead of IOleObject::DoVerb(OLEIVERB_SHOW)
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::Navigate(DWORD grfHLNF, LPCWSTR wzJumpLocation)
{
    HRESULT hr = S_OK;
    CDoc*   pDoc = Doc();

    if (pDoc->_pClientSite)
    {
        // TODO - we should defer SHOW until there is something to show
        // TODO (jbeda) is this right for NATIVE_FRAME?
        IGNORE_HR(pDoc->DoVerb(OLEIVERB_SHOW, NULL, pDoc->_pClientSite, 0, NULL, NULL));

        if (wzJumpLocation)
            hr = THR(NavigateHere(grfHLNF, wzJumpLocation, 0, TRUE));
    }
    else
    {
        hr = THR(pDoc->NavigateOutside(grfHLNF, wzJumpLocation));
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::Navigate(DWORD grfHLNF, LPCWSTR wzJumpLocation)
{
    HRESULT hr;

    hr = THR( PrimaryMarkup()->Navigate( grfHLNF, wzJumpLocation ) );
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetMonikerHlink, IHlinkTarget
//
//  Synopsis:   Called to supply our moniker...
//              NOTE: this is renamed from GetMoniker to avoid multiple
//              inheritance problem with IOleObject::GetMoniker
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDoc::GetMonikerHlink(LPCWSTR wzLocation, DWORD dwAssign, IMoniker **ppimkLocation)
{
    if( !ppimkLocation )
        return E_INVALIDARG;

    *ppimkLocation = PrimaryMarkup()->GetNonRefdMonikerPtr();
    if (*ppimkLocation)
    {
        (*ppimkLocation)->AddRef();
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetFriendlyName, IHlinkTarget
//
//  Synopsis:   Returns a friendly name for the fragment
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CDoc::GetFriendlyName(LPCWSTR pchLocation, LPWSTR *pchFriendlyName)
{
    if (!pchLocation)
        RRETURN (E_POINTER);

    // to do: figure out where this string goes; perhaps fix it

    // for now: friendly-name = location-string
    RRETURN(TaskAllocString(pchLocation, pchFriendlyName));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetFramesContainer, ITargetContainer
//
//  Synopsis:   Provides access to our IOleContainer
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetFramesContainer(IOleContainer **ppContainer)
{
    RRETURN(QueryInterface(IID_IOleContainer, (void**)ppContainer));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetFrameUrl, ITargetContainer
//
//  Synopsis:   Provides access to our URL
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetFrameUrl(LPWSTR *ppszFrameSrc)
{
    Assert(!!GetPrimaryUrl());

    RRETURN(TaskAllocString(GetPrimaryUrl(), ppszFrameSrc));
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CDoc::GetParentFrame, ITargetFrame
//
//  Synopsis:   Provides access to our IOleContainer
//
//----------------------------------------------------------------------------
HRESULT
CDoc::GetParentFrame(IUnknown **ppUnkParentFrame)
{
    HRESULT         hr;
    ITargetFrame  * pTargetFrame = NULL;

    hr = THR(QueryService(IID_ITargetFrame, IID_ITargetFrame, (void**)&pTargetFrame));
    if (hr)
        goto Cleanup;

    hr = THR(pTargetFrame->QueryInterface(IID_IUnknown, (void**)ppUnkParentFrame));

Cleanup:
    ReleaseInterface(pTargetFrame);
    RRETURN(hr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::TerminateLookForBookmarkTask
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void
CMarkup::TerminateLookForBookmarkTask()
{
    if (!HasTransNavContext())
        return;

    CMarkupTransNavContext * ptnc = GetTransNavContext();

    if (ptnc && ptnc->_pTaskLookForBookmark)
    {
        ptnc->_pTaskLookForBookmark->Terminate();
        ptnc->_pTaskLookForBookmark->Release();
        ptnc->_pTaskLookForBookmark = NULL;

        EnsureDeleteTransNavContext(ptnc);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTaskLookForBookmark::OnRun
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CTaskLookForBookmark::OnRun(DWORD dwTimeOut)
{
    if (!_pMarkup->_fPicsProcessPending )
    {
        if (_cstrJumpLocation)
        {
            CStr cstrTemp;

            // The problem is that Navigate and its descendants will want
            // to call CStr::Set on _cstrJumpLocation, and hence we cannot
            // pass that in to Navigate (CStr::Set frees memory and then
            // allocates and copies -- you figure yet?)
            cstrTemp.Set(_cstrJumpLocation);
            if (_pMarkup->Doc()->_pClientSite)
                _pMarkup->NavigateHere(_dwFlags, cstrTemp, 0, TRUE);
            else
                _pMarkup->Navigate(_dwFlags, cstrTemp);
        }
        else
        {
            // Then try to scroll or continue waiting
            _pMarkup->NavigateHere(_dwFlags, NULL, _dwScrollPos, TRUE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\htc.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       htc.cxx
//
//  Classes:    CHtmlComponent, etc.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#define _cxx_
#include "htc.hdl"

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

DeclareTag(tagHtcConstructorRequestMarkup,  "HTC", "trace requesting markup in HTC constructor")

DeclareTag(tagHtcTags,                      "HTC", "trace HTC tags (CHtmlComponentBase::Notify, documentReady)")
DeclareTag(tagHtcOnLoadStatus,              "HTC", "trace CHtmlComponent::OnLoadStatus")
DeclareTag(tagHtcInitPassivate,             "HTC", "trace CHtmlComponent::[Init|Passivate]")
DeclareTag(tagHtcDelete,                    "HTC", "trace CHtmlComponent::~CHtmlComponent")
DeclareTag(tagHtcPropertyEnsureHtmlLoad,    "HTC", "trace CHtmlComponentProperty::EnsureHtmlLoad")
DeclareTag(tagHtcAttachFireEvent,           "HTC", "trace CHtmlComponentAttach::fireEvent")

DeclareTag(tagHtcNeverSynchronous,          "HTC", "never create synchronously")
DeclareTag(tagHtcNeverShareMarkup,          "HTC", "never share markups")

extern const CLSID CLSID_CHtmlComponent;

const CLSID CLSID_CHtmlComponentConstructorFactory = {0x3050f4f8, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};
const CLSID CLSID_CHtmlComponent                   = {0x3050f4fa, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};
const CLSID CLSID_CHtmlComponentBase               = {0x3050f5f1, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};

MtDefine(CHtmlComponentConstructor,                     Behaviors,                  "CHtmlComponentConstructor")
MtDefine(CHtmlComponentBase,                            Behaviors,                  "CHtmlComponentBase")
MtDefine(CHtmlComponent,                                Behaviors,                  "CHtmlComponent")
MtDefine(CHtmlComponentDD,                              Behaviors,                  "CHtmlComponentDD")
MtDefine(CHtmlComponentProperty,                        Behaviors,                  "CHtmlComponentProperty")
MtDefine(CHtmlComponentMethod,                          Behaviors,                  "CHtmlComponentMethod")
MtDefine(CHtmlComponentEvent,                           Behaviors,                  "CHtmlComponentEvent")
MtDefine(CHtmlComponentAttach,                          Behaviors,                  "CHtmlComponentAttach")
MtDefine(CHtmlComponentDesc,                            Behaviors,                  "CHtmlComponentDesc")
MtDefine(CHtmlComponentDefaults,                        Behaviors,                  "CHtmlComponentDefaults")

MtDefine(CHtmlComponentPropertyAgent,                   CHtmlComponentProperty,     "CHtmlComponentPropertyAgent")
MtDefine(CHtmlComponentEventAgent,                      CHtmlComponentEvent,        "CHtmlComponentEventAgent")
MtDefine(CHtmlComponentAttachAgent,                     CHtmlComponentAttach,       "CHtmlComponentAttachAgent")

MtDefine(CHtmlComponent_aryAgents,                      CHtmlComponent,             "CHtmlComponent::_aryAgents")

MtDefine(CHtmlComponentConstructor_aryRequestMarkup,    CHtmlComponentConstructor,  "CHtmlComponentConstructor::_aryRequestMarkup")

MtDefine(CProfferService_CItemsArray,                   Behaviors,                  "CProfferService::CItemsArray")

BEGIN_TEAROFF_TABLE(CHtmlComponent, IServiceProvider)
    TEAROFF_METHOD(CHtmlComponent, QueryService, queryservice, (REFGUID rguidService, REFIID riid, void ** ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CHtmlComponent, IPersistPropertyBag2)
    TEAROFF_METHOD(CHtmlComponent, GetClassID,   getclassid, (CLSID *pClassID))
    TEAROFF_METHOD(CHtmlComponent, InitNew,      initnew,    ())
    TEAROFF_METHOD(CHtmlComponent, Load,         load,       (IPropertyBag2 * pPropBag, IErrorLog * pErrLog))
    TEAROFF_METHOD(CHtmlComponent, Save,         save,       (IPropertyBag2 * pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties))
    TEAROFF_METHOD(CHtmlComponent, IsDirty,      isdirty,    ())
END_TEAROFF_TABLE()

const CBase::CLASSDESC CHtmlComponentConstructor::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentBase::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponent::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    CHtmlComponent::s_acpi,         // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CONNECTION_POINT_INFO CHtmlComponent::s_acpi[] = {
    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CHtmlComponentDD::s_classdesc =
{
    &CLSID_HTCDefaultDispatch,      // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCDefaultDispatch,       // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentProperty::s_classdesc =
{
    &CLSID_HTCPropertyBehavior,     // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCPropertyBehavior,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentMethod::s_classdesc =
{
    &CLSID_HTCMethodBehavior,       // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCMethodBehavior,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentEvent::s_classdesc =
{
    &CLSID_HTCEventBehavior,        // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCEventBehavior,         // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentAttach::s_classdesc =
{
    &CLSID_HTCAttachBehavior,       // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCAttachBehavior,        // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentDesc::s_classdesc =
{
    &CLSID_HTCDescBehavior,         // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTCDescBehavior,          // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

const CBase::CLASSDESC CHtmlComponentDefaults::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    NULL,                           // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

///////////////////////////////////////////////////////////////////////////
//
// misc helpers
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Function:   HasExpando
//
//-------------------------------------------------------------------------

BOOL
HasExpando (CElement * pElement, LPTSTR pchName)
{
    HRESULT hr;
    DISPID  dispid;
    hr = THR_NOTRACE(pElement->GetExpandoDispID(pchName, &dispid, 0));
    return S_OK == hr ? TRUE : FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   HasExpandos
//
//-------------------------------------------------------------------------

BOOL
HasExpandos (CElement * pElement)
{
    CAttrValue *  pav = NULL;
    CAttrArray ** ppaa = NULL;

    ppaa = pElement->GetAttrArray();
    pav = (*ppaa)->Find(DISPID_UNKNOWN, CAttrValue::AA_Expando);

    return !!pav;
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoStringHr
//
//  Returns:    DISP_E_UNKNOWNNAME if the attribute does not exist
//                  *ppch will be set to NULL
//              S_OK if it does
//                  *ppch will be set to value (can be NULL)
//
//-------------------------------------------------------------------------

HRESULT GetExpandoStringHr( CElement * pElement, LPTSTR pchName, LPTSTR * ppch )
{
    HRESULT         hr          = S_OK;
    DISPID          dispid;
    CAttrArray *    pAA;

    Assert( pElement && pchName && ppch );
    *ppch = NULL;

    hr = THR_NOTRACE( pElement->GetExpandoDispID( pchName, &dispid, 0 ) );
    if( hr )
        goto Cleanup;

    pAA = *(pElement->GetAttrArray());
    Assert( pAA );

    pAA->FindString(dispid, (LPCTSTR *)ppch, CAttrValue::AA_Expando);

Cleanup:
    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoBoolHr
//
//  Returns:    DISP_E_UNKNOWNNAME if the attribute does not exist
//
//-------------------------------------------------------------------------

HRESULT
GetExpandoBoolHr (CElement * pElement, LPTSTR pchName, BOOL * pf)
{
    HRESULT      hr = S_FALSE;
    LPTSTR       pchValue;

    Assert (pf);

    *pf = FALSE;
    hr = THR_NOTRACE( GetExpandoStringHr( pElement, pchName, &pchValue ) );
    if( hr )
        goto Cleanup;

    *pf = StringToBool( pchValue );

Cleanup:

    RRETURN1 (hr, DISP_E_UNKNOWNNAME);
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoBool
//
//-------------------------------------------------------------------------

BOOL
GetExpandoBool(CElement * pElement, LPTSTR pchName)
{
    HRESULT hr2;
    BOOL    fResult;

    hr2 = THR_NOTRACE(GetExpandoBoolHr(pElement, pchName, &fResult));
    if (S_OK == hr2)
    {
        return fResult;
    }
    else
    {
        return FALSE;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   GetExpandoLongHr
//
//  Returns:    DISP_E_UNKNOWNNAME if the attribute does not exist
//
//-------------------------------------------------------------------------

HRESULT
GetExpandoLongHr (CElement * pElement, LPTSTR pchName, long * pl)
{
    HRESULT      hr = S_FALSE;
    long         lReturn = 0;
    LPTSTR       pchValue = NULL;

    hr = THR_NOTRACE(GetExpandoStringHr( pElement, pchName, &pchValue ));
    if( hr )
        goto Cleanup;

    lReturn = _ttol(pchValue);

Cleanup:
    *pl = lReturn;

    RRETURN1 (hr, DISP_E_UNKNOWNNAME);
}

//+------------------------------------------------------------------------
//
//  Function:   HTCPreloadTokenizerFilter
//
//-------------------------------------------------------------------------

BOOL
HTCPreloadTokenizerFilter(LPTSTR pchNamespace, LPTSTR pchTagName, CHtmTag * pht)
{
    switch (pht->GetTag())
    {
    case ETAG_SCRIPT:
        return TRUE;

    case ETAG_GENERIC_BUILTIN:

        // NOTE (alexz) this is a fragile but perf-reasonable way to do it: currently, all tags with etag
        // ETAG_GENERIC_BUILTIN are allowed in preloaded instances of HTCs. When this becomes not the case,
        // we will have to use pchTagName to figure how to filter the tag.
        // (this is when the following assert will fire)

        // aware only of these tags to have ETAG_GENERIC_BUILTIN
        Assert (0 == StrCmpIC(_T("HTC"),        pchTagName) ||
                0 == StrCmpIC(_T("COMPONENT"),  pchTagName) ||
                0 == StrCmpIC(_T("PROPERTY"),   pchTagName) ||
                0 == StrCmpIC(_T("METHOD"),     pchTagName) ||
                0 == StrCmpIC(_T("EVENT"),      pchTagName) ||
                0 == StrCmpIC(_T("ATTACH"),     pchTagName) ||
                0 == StrCmpIC(_T("DEFAULTS"),   pchTagName) ||
                0 == StrCmpIC(_T("PUT"),        pchTagName) ||
                0 == StrCmpIC(_T("GET"),        pchTagName));

        return TRUE;
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Functions:   notification mappings
//
// CONSIDER     (alexz) using hash tables for this
//
//-------------------------------------------------------------------------

class CNotifications
{
public:

    //
    // data definitions
    //

    class CItem
    {
    public:
        LPTSTR          _pchName;
        LONG            _lEvent;
        DISPID          _dispidInternal;

    };

    static const CItem s_ary[];

    //
    // methods
    //

    static CItem const * Find(LPTSTR pch)
    {
        CItem const * pItem;
        for (pItem = s_ary; pItem->_pchName; pItem++)
        {
            if (0 == StrCmpIC(pItem->_pchName, pch))
                return pItem;
        }
        return NULL;
    };
};

const CNotifications::CItem CNotifications::s_ary[] =
{
    {   _T("onContentReady"),       BEHAVIOREVENT_CONTENTREADY,     DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY     },
    {   _T("onDocumentReady"),      BEHAVIOREVENT_DOCUMENTREADY,    DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY    },
    {   _T("onDetach"),             -1,                             -1                                          },
    {   _T("onApplyStyle"),         BEHAVIOREVENT_APPLYSTYLE,       DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE       },
    {   _T("onContentSave"),        BEHAVIOREVENT_CONTENTSAVE,      DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE      },
    {   NULL,                       -1,                             -1                                          }
};

//+------------------------------------------------------------------------
//
//  Function:   TagNameToHtcBehaviorType
//
//-------------------------------------------------------------------------

HTC_BEHAVIOR_TYPE
TagNameToHtcBehaviorType(LPCTSTR pchTagName)
{
    // NOTE(sramani): We can make use of the fact that each builtin type starts with
    // a diffent letter to our advantage, by comparing only the first letters of the 
    // generic element's tagName, as the parser enforces the correct tagname only for 
    // these ETAG_GENERIC_BUILTINs. We do the entire string compare in debug for sanity check.

    switch (*pchTagName)
    {
    case _T('P') :
    case _T('p') : 
        if (0 == StrCmpIC(pchTagName, _T("put")))
            return HTC_BEHAVIOR_NONE;
        else
        {
            Assert(0 == StrCmpIC(pchTagName, _T("property")));
            return HTC_BEHAVIOR_PROPERTY;    // property
        }

    case _T('M') :
    case _T('m') :
        Assert(0 == StrCmpIC(pchTagName, _T("method")));
        return HTC_BEHAVIOR_METHOD;      // method
    
    case _T('E') :
    case _T('e') : 
        Assert(0 == StrCmpIC(pchTagName, _T("event")));
        return HTC_BEHAVIOR_EVENT;       // event
    
    case _T('A') :
    case _T('a') :
        Assert(0 == StrCmpIC(pchTagName, _T("attach")));
        return HTC_BEHAVIOR_ATTACH;      // attach
    
    case _T('H') :
    case _T('h') :
        Assert(0 == StrCmpIC(pchTagName, _T("htc")));
        return HTC_BEHAVIOR_DESC;        // htc
    
    case _T('C') :
    case _T('c') :
        Assert(0 == StrCmpIC(pchTagName, _T("component")));
        return HTC_BEHAVIOR_DESC;        // component

    case _T('D') :
    case _T('d') :
        Assert(0 == StrCmpIC(pchTagName, _T("defaults")));
        return HTC_BEHAVIOR_DEFAULTS;    // defaults

    default  :
        return HTC_BEHAVIOR_NONE;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   GetHtcFromElement
//
//  Note:   Theoretically, the cleanest way to do this is to QI element for
//          CLSID_CHtmlComponentBase. However, this will be doing thunking so
//          returned pointer is required to be strong ref. But we want the 
//          pointer to be weak ref to keep the code cleaner in HTCs.
//
//-------------------------------------------------------------------------

CHtmlComponentBase *
GetHtcFromElement(CElement * pElement)
{
    HRESULT                 hr2;
    CHtmlComponentBase *    pBehavior;

    //
    // ideal way; pBehavior has to be strong ref.
    // pElement->QueryInterface(CLSID_CHtmlComponentBase, (void**)&pBehavior);
    //

    //
    // practical way; pBehavior is weak ref
    //

    CPeerHolder * pPeerHolder = pElement->GetIdentityPeerHolder();

    if (pPeerHolder)
    {
        hr2 = THR_NOTRACE(pPeerHolder->QueryPeerInterface(CLSID_CHtmlComponentBase, (void**)&pBehavior));
        if (hr2)
        {
            pBehavior = NULL;
        }
        else
        {
            Assert (pBehavior);
        }
    }
    else
    {
        pBehavior = NULL;
    }

    return pBehavior;
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDummy and g_HtmlComponentDummy
//
//  Synopsis:   class, instance of which is created one per mshtml process.
//              It serves as totally empty behavior. It allows us to avoid any 
//              special-casing for HTC behaviors that don't do anything,
//              such as property <PUT> or <GET>.
//
///////////////////////////////////////////////////////////////////////////

class CHtmlComponentDummy : public IElementBehavior
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)
    {
        if (IsEqualGUID(IID_IUnknown,         riid) ||
            IsEqualGUID(IID_IElementBehavior, riid))
        {
            *ppv = this;
            return S_OK;
        }
        else
        {
            RRETURN (E_NOINTERFACE);
        }
    }
    STDMETHOD_(ULONG, AddRef)()  { return 0; }
    STDMETHOD_(ULONG, Release)() { return 0; };

    STDMETHOD(Init)(IElementBehaviorSite * pSite)  { return S_OK; };
    STDMETHOD(Notify)(LONG lEvent, VARIANT * pVar) { return S_OK; };
    STDMETHOD(Detach)()                            { return S_OK; };

};

static CHtmlComponentDummy g_HtmlComponentDummy;

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentConstructor wiring
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Aux Class:   CHtmlComponentConstructorFactory
//
//-------------------------------------------------------------------------

class CHtmlComponentConstructorFactory : public CStaticCF
{
public:
    DECLARE_CLASS_TYPES(CHtmlComponentConstructorFactory, CStaticCF)

    CHtmlComponentConstructorFactory (FNCREATE * pfnCreate) : CStaticCF(pfnCreate) {};

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID * ppv)
    {
        if (IsEqualGUID(CLSID_CHtmlComponentConstructorFactory, iid))
        {
            *ppv = this; // weak ref
            RRETURN (S_OK);
        }
        else
        {
            RRETURN (super::QueryInterface(iid, ppv));
        }
    }
};

//+------------------------------------------------------------------------
//
//  Function:   CreateHtmlComponentConstructor
//
//-------------------------------------------------------------------------

HRESULT
CreateHtmlComponentConstructor(IUnknown * pUnkOuter, IUnknown ** ppUnk)
{
    HRESULT                     hr = S_OK;
    CHtmlComponentConstructor * pConstructor;

    if (!ppUnk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppUnk = NULL;

    if (pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
        goto Cleanup;
    }

    pConstructor = new CHtmlComponentConstructor();
    if (!pConstructor)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppUnk = (IUnknown*)(IClassFactory*)pConstructor;

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Global:   g_cfHtmlComponentConstructorFactory
//
//-------------------------------------------------------------------------

CHtmlComponentConstructorFactory g_cfHtmlComponentConstructorFactory (CreateHtmlComponentConstructor);

//+------------------------------------------------------------------------
//
//  Function:   HtcPrivateExec
//
//  Synopsis:   internal wiring to allow HTC do a couple of private things:
//              -   let constructor figure out if it needs to attempt to load
//                  HTC synchronously;
//              -   request parser to hold parsing while HTC is loading
//
//-------------------------------------------------------------------------

HRESULT
HtcPrivateExec(CHtmlComponent * pComponent, BOOL * pfSync)
{
    HRESULT             hr = S_OK;
    VARIANT             varSync;
    IServiceProvider *  pServiceProvider = NULL;
    IOleCommandTarget * pCommandTarget = NULL;

    Assert (pfSync);
    Assert (pComponent->_pSite);

    hr = pComponent->_pSite->QueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);
    if (hr)
        goto Cleanup;

    hr = pServiceProvider->QueryService(SID_SElementBehaviorMisc, IID_IOleCommandTarget, (void**)&pCommandTarget);
    if (hr)
        goto Cleanup;

    hr = pCommandTarget->Exec(
            &CGID_ElementBehaviorMisc, CMDID_ELEMENTBEHAVIORMISC_ISSYNCHRONOUSBEHAVIOR, 0, NULL, &varSync);
    if (hr)
        goto Cleanup;

    Assert (VT_I4 == V_VT(&varSync));

    *pfSync = (0 != V_I4(&varSync));

    hr = pCommandTarget->Exec(
            &CGID_ElementBehaviorMisc, CMDID_ELEMENTBEHAVIORMISC_REQUESTBLOCKPARSERWHILEINCOMPLETE, 0, NULL, NULL);

Cleanup:
    ReleaseInterface(pServiceProvider);
    ReleaseInterface(pCommandTarget);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentConstructor
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor constructor
//
//-------------------------------------------------------------------------

CHtmlComponentConstructor::CHtmlComponentConstructor()
{
    _idxRequestMarkup = -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::Passivate
//
//-------------------------------------------------------------------------

void
CHtmlComponentConstructor::Passivate()
{
    int                 c;
    CHtmlComponent **   ppComponent;

    AssertSz(0 == _cComponents, "Attempt to passivate HTC factory before all HTC instances have been passivated; this will cause serious bugs");

    FormsFreeString(_bstrTagName);
#if 0
    FormsFreeString(_bstrBaseTagName);
#endif

    for (ppComponent = &(_aryRequestMarkup[_idxRequestMarkup + 1]), c = _aryRequestMarkup.Size() - ( _idxRequestMarkup + 1 ); c; ppComponent++, c--)
    {
        (*ppComponent)->SubRelease();
    }
    _aryRequestMarkup.DeleteAll();
    _idxRequestMarkup = -1;
    _fRequestMarkupNext = FALSE;

    if (_pFactoryComponent)
    {
        _pFactoryComponent->PrivateRelease();
        _pFactoryComponent = NULL;
    }

    ClearInterface(&_pMoniker);

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::QueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IClassFactory*)this, IUnknown)
    QI_INHERITS(this, IPersistMoniker)
    QI_INHERITS(this, IClassFactory)
    QI_INHERITS(this, IElementBehaviorFactory)
    QI_INHERITS(this, IElementNamespaceFactory)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        // this violates object identity rules, but:
        // (1) this will only happen if _pFactoryComponent is set, and this can only happen when interacting with mshtml;
        // (2) with IConnectionPointContainer this is kinda typical anyway;
        if (_pFactoryComponent &&
            (IsEqualGUID(IID_IConnectionPointContainer, iid) ||
             IsEqualGUID(IID_IDispatchEx, iid)))
        {
            RRETURN(_pFactoryComponent->PrivateQueryInterface(iid, ppv));
        }

        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+---------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LockServer, per IClassFactory
//
//----------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LockServer (BOOL fLock)
{
    if (fLock)
        IncrementSecondaryObjectCount(4);
    else
        DecrementSecondaryObjectCount(4);

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load, per IPersistMoniker
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::Load(
    BOOL        fFullyAvailable,
    IMoniker *  pMoniker,
    IBindCtx *  pBindCtx,
    DWORD       grfMode)
{
    HRESULT     hr = S_OK;

    _pMoniker = pMoniker;
    _pMoniker->AddRef();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::FindBehavior, per IElementBehaviorFactory
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::FindBehavior(
    BSTR                    bstrName,
    BSTR                    bstrUrl,
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppBehavior)
{
    HRESULT             hr = S_OK;
    CHtmlComponent *    pComponent = NULL;

    hr = THR(EnsureFactoryComponent(pSite));
    if (hr)
        goto Cleanup;

    Assert (_pFactoryComponent);

    //
    // allowed to create the HTC?
    //

    if (!_fSupportsEditMode && _pFactoryComponent->_pDoc->DesignMode())
    {
        // the HTC does not support edit mode, and the doc is in design mode - fail the instantiation
        hr = E_FAIL;
        goto Cleanup;
    }


    //
    // create and init CHtmlComponent
    //

    pComponent = new CHtmlComponent(this);
    if (!pComponent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pComponent->InitHelper(pSite));
    if (hr)
        goto Cleanup;

    if (pComponent->IsRecursiveUrl(bstrUrl))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // get IElementBehavior interface
    //

    hr = THR(pComponent->PrivateQueryInterface(IID_IElementBehavior, (void**)ppBehavior));

Cleanup:
    if (pComponent)
        pComponent->PrivateRelease();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::EnsureFactoryComponent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::EnsureFactoryComponent(IUnknown * punkContext)
{
    if (_pFactoryComponent)
        return S_OK;

    HRESULT             hr = S_OK;
    IServiceProvider *  pServiceProvider = NULL;
    CDoc *              pDoc;

    //
    // get moniker and doc
    //

    hr = THR(punkContext->QueryInterface(IID_IServiceProvider, (void**)&pServiceProvider));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(CLSID_HTMLDocument, CLSID_HTMLDocument, (void**) &pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(pServiceProvider->QueryService(CLSID_CMarkup, CLSID_CMarkup, (void **) &_pMarkup ));
    if( hr )
        goto Cleanup;

    //
    // create and init reference CHtmlComponent
    //

    _pFactoryComponent = new CHtmlComponent(this, /* fFactoryComponent =*/TRUE);
    if (!_pFactoryComponent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_pFactoryComponent->Init(pDoc));
    if (hr)
        goto Cleanup;

    hr = THR(RequestMarkup(_pFactoryComponent));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pServiceProvider);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::Create, per IElementNamespaceFactory
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::Create(IElementNamespace * pNamespace)
{
    HRESULT      hr = S_OK;
    DWORD        dwFlags = 0;

    if (!pNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(EnsureFactoryComponent(/*punkContext =*/pNamespace));
    if (hr)
        goto Cleanup;

    Assert (_pFactoryComponent);

    if (_pFactoryComponent->GetReadyState() < READYSTATE_COMPLETE)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    if (_bstrTagName)
    {
#if 0
        if( _bstrBaseTagName )
        {
            HRESULT hr2;
            IElementNamespacePrivate * pNSPrivate = NULL;

            hr2 = THR( pNamespace->QueryInterface( IID_IElementNamespacePrivate, (void **)&pNSPrivate ) );
            if( hr2 )
                goto TestCleanup;

            hr2 = THR( pNSPrivate->AddTagPrivate( _bstrTagName, _bstrBaseTagName, _fLiteral ) );
            if( hr2 )
                goto TestCleanup;
            
TestCleanup:
            ClearInterface( &pNSPrivate );
            goto Cleanup;
        }
        else
#endif // Test code for derived element behaviors
        {
            Assert( !_fLiteral || !_fNested );
            if( _fLiteral )
            {
                dwFlags = ELEMENTDESCRIPTORFLAGS_LITERAL;
            }
            else if( _fNested )
            {
                dwFlags = ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL;
            }
            hr = THR(pNamespace->AddTag(_bstrTagName, dwFlags));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::IsFactoryMarkupReady, helper
//
//-------------------------------------------------------------------------

BOOL
CHtmlComponentConstructor::IsFactoryMarkupReady()
{
    return _pFactoryComponent &&
           _pFactoryComponent->_pMarkup &&
           _pFactoryComponent->_pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LoadMarkupAsynchronously, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LoadMarkupAsynchronously(CHtmlComponent * pComponent)
{
    HRESULT hr;

    hr = THR(pComponent->Load(_pMoniker));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LoadMarkupSynchronously, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LoadMarkupSynchronously(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    IStream *   pStream = NULL;
    TCHAR *     pchUrl = NULL;

    Assert (    _fDownloadStream          // Either we have to do a synchronous download, or
            ||  (   IsFactoryMarkupReady()                  // We have a valid factory markup to use
                 && _pFactoryComponent->_pMarkup->HtmCtx() ) );

    if( !_fDownloadStream && _pFactoryComponent->_pMarkup->HtmCtx()->HasCachedFile())
    {
        Assert( _pFactoryComponent->_pMarkup->HtmCtx() );

        hr = THR(_pFactoryComponent->_pMarkup->HtmCtx()->GetStream(&pStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( _pMoniker->GetDisplayName( NULL, NULL, &pchUrl ) );
        if( hr )
            goto Cleanup;

        hr = THR( URLOpenBlockingStreamW( NULL, pchUrl, &pStream, 0, NULL ) );
        if( hr )
            goto Cleanup;
    }

    hr = THR(pComponent->Load(pStream));
    if( hr )
        goto Cleanup;

Cleanup:
    CoTaskMemFree( pchUrl );
    ReleaseInterface( pStream );
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::LoadMarkup, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::LoadMarkup(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    BOOL        fSync = FALSE;
 
    TraceTag((tagHtcConstructorRequestMarkup, "CHtmlComponentConstructor::LoadMarkup     [%lx], component [%lx], queue size %ld, idx %ld", this, pComponent, _aryRequestMarkup.Size(), _idxRequestMarkup));

    Assert (-1 == _idxRequestMarkup ||
            0 == _aryRequestMarkup.Size() ||
            pComponent == _aryRequestMarkup[_idxRequestMarkup]);

    _fRequestMarkupLock = TRUE;

    if (_fSharedMarkup)
    {
        Assert (IsFactoryMarkupReady());

        hr = THR(pComponent->ToSharedMarkupMode( _pMarkup->Doc()->_fSyncParsing));
        goto Cleanup; // done
    }

    // There can be times where we require that the factory component be
    // created synchronously, for example innerHTML-ing in an ?IMPORT PI.
    // In this case, we have to do a synchronous download of the URL to
    // a stream.  The other, more normal case for doing a synchronous load,
    // though, is just that we need to create an element behavior synchronously
    // and load from the existing stream.  Note that if the factory component
    // is downloaded synchronously, we have to use that for all subsequent
    // components because we can't get a stream from the markup.
    if (IsFactoryMarkupReady() )
    {
        hr = THR(HtcPrivateExec(pComponent, &fSync));
        if (hr)
            goto Cleanup;

#if DBG == 1
        // reset fSync if the NeverSynchronous tag is enabled
        if (IsTagEnabled(tagHtcNeverSynchronous))
            fSync = FALSE;
#endif
    }
    else if( pComponent->_fFactoryComponent )
    {
        _fDownloadStream = fSync = _pMarkup->HtmCtx() && _pMarkup->HtmCtx()->IsSyncParsing();
    }

    if (fSync)
    {
        hr = THR(LoadMarkupSynchronously(pComponent));
    }
    else
    {
        hr = THR(LoadMarkupAsynchronously(pComponent));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::RequestMarkup, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::RequestMarkup(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;

    TraceTag((tagHtcConstructorRequestMarkup, "CHtmlComponentConstructor::RequestMarkup  [%lx], component [%lx], queue size %ld, idx %ld", this, pComponent, _aryRequestMarkup.Size(), _idxRequestMarkup));

    if (!_fRequestMarkupLock)
    {
        hr = THR(LoadMarkup(pComponent));
    }
    else
    {
        pComponent->SubAddRef();

        hr = THR(_aryRequestMarkup.Append (pComponent));

        _fRequestMarkupNext = TRUE;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::OnMarkupLoaded, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::OnMarkupLoaded(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;

    TraceTag((tagHtcConstructorRequestMarkup, "CHtmlComponentConstructor::OnMarkupLoaded [%lx], component [%lx], queue size %ld, idx %ld", this, pComponent, _aryRequestMarkup.Size(), _idxRequestMarkup));

    Assert (pComponent);

    Assert (-1 == _idxRequestMarkup ||
            0 == _aryRequestMarkup.Size() ||
            pComponent == _aryRequestMarkup[_idxRequestMarkup]);

    Assert (_fRequestMarkupLock);

    _fRequestMarkupLock = FALSE;

    if (_fLoadMarkupLock)
    {
        // Assert (CHtmlComponentConstructor::OnMarkupLoaded is somewhere above on the call stack)
        _fRequestMarkupNext = TRUE;
        goto Cleanup; // out
    }

    _fLoadMarkupLock = TRUE;

    if (pComponent->_fFactoryComponent &&
        !pComponent->IsPassivating() &&
        !pComponent->IsPassivated())
    {
        hr = THR(OnFactoryMarkupLoaded());
        if (hr)
            goto Cleanup;
    }

    do
    {
        _fRequestMarkupNext = FALSE;
 
        if (_aryRequestMarkup.Size() - 1 <= _idxRequestMarkup)
        {
            _aryRequestMarkup.DeleteAll();
            _idxRequestMarkup = -1;
        }
        else
        {
            _idxRequestMarkup++;
            pComponent = _aryRequestMarkup[_idxRequestMarkup];

            if (!pComponent->IsPassivated())
            {
                // Failure is legit here
                IGNORE_HR(LoadMarkup(pComponent));
            }
            else
            {
                _fRequestMarkupNext = TRUE;
            }

            pComponent->SubRelease();
        }
    } while (_fRequestMarkupNext);

    Assert (_fLoadMarkupLock);
    _fLoadMarkupLock = FALSE;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentConstructor::OnFactoryMarkupLoaded, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentConstructor::OnFactoryMarkupLoaded()
{
    HRESULT     hr = S_OK;
    HRESULT     hr2;
    CElement *  pElement;
    LPTSTR     pch;

    Assert (_pFactoryComponent &&
            _pFactoryComponent->_pMarkup &&
            _pFactoryComponent->_pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE);

    hr = _pFactoryComponent->GetElement((LONG*)NULL, &pElement, HTC_BEHAVIOR_DESC);
    if (hr || !pElement)
        goto Cleanup;

    //
    // get the tag name
    //

    pch = GetExpandoString(pElement, _T("tagName"));
    if (!pch)
    {
        pch = GetExpandoString(pElement, _T("name"));
    }
    if (pch)
    {
        hr = THR(FormsAllocString(pch, &_bstrTagName));
        if (hr)
            goto Cleanup;
    }

    //
    // get the base tag name
    //
#if 0
    pch = GetExpandoString(pElement, _T("__MS__baseTagName"));
    if (pch)
    {
        hr = THR(FormsAllocString(pch, &_bstrBaseTagName));
        if (hr)
            goto Cleanup;
    }
#endif 

    //
    // lightweight HTC? literal? supportsEditMode?
    //

    _fSharedMarkup      = _pFactoryComponent->_fLightWeight;
    _fSupportsEditMode  = GetExpandoBool(pElement, _T("supportsEditMode"));
    hr2 = THR_NOTRACE( GetExpandoStringHr( pElement, _T("literalContent"), &pch ) );
    if( S_OK == hr2 )
    {
        _fLiteral = StringToBool( pch );    // Normal literal?
        if( !_fLiteral )
            _fNested = !StrCmpIC( pch, _T("nested") ); // No - see if it's nested
    }

#if DBG == 1
    if (IsTagEnabled(tagHtcNeverShareMarkup))
    {
        _fSharedMarkup = FALSE;
    }
#endif

Cleanup:

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentAgentBase
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::CHtmlComponentAgentBase
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase::CHtmlComponentAgentBase(CHtmlComponent * pComponent, CHtmlComponentBase * pClient)
{
    _ulRefs = 1;

    Assert (pClient && pClient->_pElement);

    _pComponent = pComponent;
    if (_pComponent)
    {
        _pComponent->SubAddRef();
    }

    _pClient = pClient;
    _pClient->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::~CHtmlComponentAgentBase
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase::~CHtmlComponentAgentBase()
{
    if (_pComponent)
    {
        _pComponent->SubRelease();
    }
    _pClient->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::QueryInterface(REFIID iid, void ** ppv)
{

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IDispatch)
    QI_INHERITS(this, IDispatchEx)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN (E_NOTIMPL);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    if (_pClient->_pElement)
    {
        hr = THR_NOTRACE(_pClient->_pElement->GetDispID(bstrName, grfdex, pdispid));
    }
    else
    {
        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT     hr;

    if (_pClient->_pElement)
    {
        hr = THR_NOTRACE(_pClient->_pElement->InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAgentBase::GetNameSpaceParent, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAgentBase::GetNameSpaceParent(IUnknown ** ppunk)
{
    HRESULT     hr;

    hr = THR(_pComponent->_DD.PrivateQueryInterface(IID_IDispatchEx, (void**)ppunk));

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentBase
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::CHtmlComponentBase
//
//-------------------------------------------------------------------------

CHtmlComponentBase::CHtmlComponentBase()
{
    _idxAgent = -1;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentBase::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_INHERITS(this, IElementBehavior)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    if (IsEqualGUID(iid, CLSID_CHtmlComponentBase))
    {
        *ppv = this;    // weak ref
        return S_OK;
    }

    RRETURN (super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Passivate
//
//-------------------------------------------------------------------------

void
CHtmlComponentBase::Passivate()
{
    // do not do ClearInterface (&_pComponent)

    _pElement = NULL;   // Weak ref

    ClearInterface (&_pSite);

    if (_pAgentWhenStandalone)
    {
        _pAgentWhenStandalone->Release();
        _pAgentWhenStandalone = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::Init(IElementBehaviorSite * pSite)
{
    HRESULT             hr;
    IHTMLElement *      pHtmlElement = NULL;
    IServiceProvider *  pSP = NULL;

    //
    // get _pSite
    //

    _pSite = pSite;
    _pSite->AddRef();

    //
    // get _pElement
    //

    hr = THR(_pSite->GetElement(&pHtmlElement));
    if (hr)
        goto Cleanup;

    hr = THR(pHtmlElement->QueryInterface(CLSID_CElement, (void**)&_pElement));
    if (hr)
        goto Cleanup;

    Assert (_pElement);

    //
    // get _pComponent
    //

    hr = THR(_pSite->QueryInterface(IID_IServiceProvider, (void**)&pSP));
    if (hr)
        goto Cleanup;

    IGNORE_HR(pSP->QueryService(CLSID_CHtmlComponent, CLSID_CHtmlComponent, (void**)&_pComponent));

Cleanup:
    ReleaseInterface(pHtmlElement);
    ReleaseInterface(pSP);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::Notify(LONG lEvent, VARIANT * pVar)
{
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::Detach
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::Detach()
{
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetAgent
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase *
CHtmlComponentBase::GetAgent(CHtmlComponent * pComponent)
{
    CHtmlComponentAgentBase * pAgent;

    if (pComponent)
    {
        Assert (!_pAgentWhenStandalone);

        pAgent = pComponent->GetAgent(this);
    }
    else
    {
        if (!_pAgentWhenStandalone)
        {
            _pAgentWhenStandalone = CreateAgent(pComponent);
        }

        pAgent = _pAgentWhenStandalone;
    }

    return pAgent;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetExternalName, helper
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentBase::GetExternalName()
{
    return GetExpandoString(_pElement, _T("name"));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::InvokeEngines, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentBase::InvokeEngines(
    CHtmlComponent *    pComponent,
    CScriptContext *    pScriptContext,
    LPTSTR              pchName,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    CScriptCollection * pScriptCollection = NULL;

    if (!_pElement)
        goto Cleanup;
        
    if (pComponent)
    {
        pScriptCollection = pComponent->GetScriptCollection();
    }
    else
    {
        Assert (_pElement);
        pScriptCollection = _pElement->GetNearestMarkupForScriptCollection()->GetScriptCollection();
    }

    if (!pScriptCollection)
        goto Cleanup;
        
    hr = THR_NOTRACE(pScriptCollection->InvokeName(
        pScriptContext, pchName,
        g_lcidUserDefault, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetChildInternalName, helper
//
//  CONSIDER:   optimizing this so to avoid children scan
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentBase::GetChildInternalName(LPTSTR pchChild)
{
    CChildIterator  ci (_pElement);
    CTreeNode *     pNode;
    CElement *      pElement;

    while (NULL != (pNode = ci.NextChild()))
    {
        pElement = pNode->Element();
        if (0 == StrCmpIC (pElement->TagName(), pchChild))
        {
            return GetExpandoString (pElement, _T("internalName"));
        }
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentBase::GetInternalName, helper
//
//  Parameters: pfDifferent     indicates if external and internal names are different
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentBase::GetInternalName(BOOL * pfScriptsOnly, WORD * pwFlags, DISPPARAMS * pDispParams)
{
    LPTSTR  pchName;
    BOOL    fScriptsOnly;

    if (!_pElement)
        return NULL;

    if (!pfScriptsOnly)
        pfScriptsOnly = &fScriptsOnly;

    //
    // putters / getters
    //

    if (pwFlags)
    {
        if ((*pwFlags) & DISPATCH_PROPERTYGET)
        {
            pchName = GetExpandoString(_pElement, _T("GET"));
            if (!pchName)
            {
                pchName = GetChildInternalName(_T("GET"));
            }
        }
        else if ((*pwFlags) & DISPATCH_PROPERTYPUT)
        {
            pchName = GetExpandoString(_pElement, _T("PUT"));
            if (!pchName)
            {
                pchName = GetChildInternalName(_T("PUT"));
            }
        }
        else
        {
            pchName = NULL;
        }

        if (pchName)                            // if there is a putter or getter method for the property
        {
            *pwFlags = DISPATCH_METHOD;         // switch to METHOD call type
            if (pDispParams)
            {
                pDispParams->cNamedArgs = 0;    // remove any named args
            }
            *pfScriptsOnly = TRUE;
            return pchName;                     // and use the putter/getter
        }
    }

    //
    // internal name
    //

    pchName = GetExpandoString(_pElement, _T("internalName"));
    if (pchName)
    {
        *pfScriptsOnly = TRUE;
        return pchName;
    }

    //
    // name
    //

    *pfScriptsOnly = FALSE;

    return GetExternalName();
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDD
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::PrivateAddRef, per IPrivateUnknown
//
//-------------------------------------------------------------------------

ULONG
CHtmlComponentDD::PrivateAddRef()
{
    return Component()->SubAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::PrivateRelease, per IPrivateUnknown
//
//-------------------------------------------------------------------------

ULONG
CHtmlComponentDD::PrivateRelease()
{
    return Component()->SubRelease();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::PrivateQueryInterface, per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IPrivateUnknown *)this, IUnknown)
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCDefaultDispatch, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

#if DBG == 1
//+------------------------------------------------------------------------
//
//  Helper:     DDAssertDispidRanges
//
//              DEBUG ONLY
//
//-------------------------------------------------------------------------

void
DDAssertDispidRanges(DISPID dispid)
{
    struct
    {
        DISPID  dispidMin;
        DISPID  dispidMax;
    }   aryRanges[] =
    {
        // (0)  script collection - cross languages glue
        {   DISPID_OMWINDOWMETHODS,       1000000 - 1                             }, //     10,000 ..    999,999

        // (1)  markup window all collection (elements within htc accessed by id)
        {   DISPID_COLLECTION_MIN,        DISPID_COLLECTION_MAX                   }, //  1,000,000 ..  2,999,999

        // ()   doc fragment DD
        // DISPID_A_DOCFRAGMENT                 document
        // (in range 3)

        // ()   HTC DD
        // DISPID_A_HTCDD_ELEMENT               element
        // DISPID_A_HTCDD_CREATEEVENTOBJECT     createEventObject
        // (in range 3)

        // (2)  element's namespace - standard properties
        {   -1,                           -30000                                  }, // 0xFFFFFFFF .. 0xFFFF0000 (~)

        // (3)  element's namespace - properties
        {   DISPID_XOBJ_MIN,              DISPID_XOBJ_MAX                         }, // 0x80010000 .. 0x8001FFFF

        // (4)  element's namespace - expandos
        {   DISPID_EXPANDO_BASE,          DISPID_EXPANDO_MAX                      }, //  3,000,000 .. 3,999,999

        // (5)  element's namespace - properties of other behaviors attached to the element
        { DISPID_PEER_HOLDER_BASE,      DISPID_PEER_HOLDER_BASE + INT_MAX / 2     }, //  5,000,000 .. + infinity

        // (6)  element's namespace - properties CElement-derived elements
        { DISPID_NORMAL_FIRST,          DISPID_NORMAL_FIRST + 1000 * 9            },  //      1000 .. 9000
    };

    int     i, j;
    BOOL    fRangeHit;

    // check that the dispid falls into an expected range

    fRangeHit = FALSE;
    for (i = 0; i < ARRAY_SIZE(aryRanges); i++)
    {
        if (aryRanges[i].dispidMin <= dispid && dispid <= aryRanges[i].dispidMax)
        {
            fRangeHit = TRUE;
        }
    }

    Assert (fRangeHit);

    // check that the ranges do not overlap

    for (i = 0; i < ARRAY_SIZE(aryRanges) - 1; i++)
    {
        if (4 == i)
            continue;

        for (j = i + 1; j < ARRAY_SIZE(aryRanges); j++)
        {
            Assert (aryRanges[j].dispidMin < aryRanges[i].dispidMin || aryRanges[i].dispidMax < aryRanges[j].dispidMin);
            Assert (aryRanges[j].dispidMax < aryRanges[i].dispidMin || aryRanges[i].dispidMax < aryRanges[j].dispidMax);
        }
    }
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT             hr;
    CMarkup *           pMarkup = Component()->GetMarkup();
    CCollectionCache *  pWindowCollection;
    CScriptCollection * pScriptCollection;
    CScriptContext *    pScriptContext;

    //
    // standard handling
    //

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (DISP_E_UNKNOWNNAME != hr)   // if (S_OK == hr || (hr other then DISP_E_UNKNOWNNAME))
        goto Cleanup;               // get out

    //
    // gluing different script engines togather 
    //

    if (pMarkup)
    {
        pScriptCollection = Component()->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = Component()->GetScriptContext(&pScriptContext);
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pScriptCollection->GetDispID(pScriptContext, bstrName, grfdex, pdispid));
            if (DISP_E_UNKNOWNNAME != hr)   // if (S_OK or error other then DISP_E_UNKNOWNNAME)
                goto Cleanup;
        }
    }

    //
    // access to id'd elements 
    //

    if (pMarkup)
    {
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        pWindowCollection = pMarkup->CollectionCache();

        hr = THR_NOTRACE(pWindowCollection->GetDispID(
                CMarkup::WINDOW_COLLECTION,
                bstrName,
                grfdex,
                pdispid));
        if (S_OK == hr && DISPID_UNKNOWN == *pdispid)
        {
            // the collection cache GetDispID may return S_OK with DISPID_UNKNOWN if the name isn't found.
            hr = DISP_E_UNKNOWNNAME;
        }
        else if (DISP_E_UNKNOWNNAME != hr)
            goto Cleanup;
    }
    
    //
    // access to element's namespace
    //

    if (Component()->_pElement)
    {
        hr = THR_NOTRACE(Component()->_pElement->GetDispID(bstrName, grfdex, pdispid));
        if (DISP_E_UNKNOWNNAME != hr)
            goto Cleanup;
    }
    
    //
    // internal object model
    //

    if (0 == StrCmpIC(_T("__MS__isMarkupShared"), bstrName))
    {
        hr = S_OK;
        *pdispid = DISPID_A_HTCDD_ISMARKUPSHARED;
        goto Cleanup; // done
    }

Cleanup:

#if DBG == 1
    if (S_OK == hr)
    {
        DDAssertDispidRanges(*pdispid);
    }
#endif

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::InvokeEx(
    DISPID          dispid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pvarRes,
    EXCEPINFO *     pExcepInfo,
    IServiceProvider * pSrvProvider)
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    IDispatchEx *       pdispexElement = NULL;
    CMarkup *           pMarkup = Component()->GetMarkup();
    CCollectionCache *  pWindowCollection;
    CScriptCollection * pScriptCollection;
    CScriptContext *    pScriptContext;
    
#if DBG == 1
    DDAssertDispidRanges(dispid);
#endif

    //
    // gluing different script engines together 
    //

    if (pMarkup)
    {
        pScriptCollection = Component()->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = Component()->GetScriptContext(&pScriptContext);
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pScriptCollection->InvokeEx(
                pScriptContext, dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pSrvProvider));
            
            if (DISP_E_MEMBERNOTFOUND != hr)   // if (S_OK or error other then DISP_E_UNKNOWNNAME)
                goto Cleanup;
        }
    }

    //
    // access to id'd elements on the markup.
    //

    if (pMarkup)
    {
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        pWindowCollection = pMarkup->CollectionCache();

        if (pWindowCollection->IsDISPIDInCollection(CMarkup::WINDOW_COLLECTION, dispid))
        {
            hr = THR_NOTRACE(pWindowCollection->Invoke(
                CMarkup::WINDOW_COLLECTION, dispid, IID_NULL, lcid, wFlags,
                pDispParams, pvarRes, pExcepInfo, NULL));
            if (hr)
                goto Cleanup;

            if (Component()->_fSharedMarkup)
            {
                hr = THR_NOTRACE(Component()->WrapSharedElement(pvarRes));
            }
        
            goto Cleanup; // done
        }
    }
    
    if (IsStandardDispid(dispid))
    {
        //
        // standard handling
        //

        hr = THR_NOTRACE(super::InvokeEx(dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pSrvProvider));
        if (DISP_E_MEMBERNOTFOUND != hr)    // if (S_OK == hr || (hr other then DISP_E_MEMBERNOTFOUND))
            goto Cleanup;                   // get out
    }
    
    //
    // access to element's namespace
    //

    if (Component()->_pElement)
    {
        hr = THR(Component()->_pElement->QueryInterface(
            IID_IDispatchEx, (void **)&pdispexElement));
        if (hr)
            goto Cleanup;
            
        hr = THR_NOTRACE(pdispexElement->InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pSrvProvider));

        if (DISP_E_MEMBERNOTFOUND != hr)    // if (S_OK == hr || (hr other then DISP_E_MEMBERNOTFOUND))
            goto Cleanup;                   // get out
    }
    
    //
    // internal object model
    //

    if (DISPID_A_HTCDD_ISMARKUPSHARED == dispid &&
        (wFlags & DISPATCH_PROPERTYGET))
    {
        Assert (pvarRes);
        hr = S_OK;
        V_VT(pvarRes) = VT_BOOL;
        V_BOOL(pvarRes) = Component()->_fSharedMarkup;
        goto Cleanup; // done
    }

Cleanup:

    ReleaseInterface(pdispexElement);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::GetNameSpaceParent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;
    CMarkup *   pMarkup = Component()->_pMarkup;
    CDocument * pDocument;

    if (!pMarkup)
        RRETURN (E_FAIL);

    hr = THR(pMarkup->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    hr = THR(pDocument->PrivateQueryInterface(IID_IDispatchEx, (void**)ppunk));

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::get_element
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::get_element(IHTMLElement ** ppHTMLElement)
{
    HRESULT hr;
    
    if (Component()->_pElement)
    {
        hr = THR(Component()->_pElement->QueryInterface(IID_IHTMLElement, (void**) ppHTMLElement));
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::get_defaults
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::get_defaults(IDispatch ** ppDefaults)
{
    HRESULT hr;

    if (Component()->_pElement)
    {
        hr = THR(Component()->_pSiteOM->GetDefaults((IHTMLElementDefaults**)ppDefaults));
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::createEventObject
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::createEventObject(IHTMLEventObj ** ppEventObj)
{
    HRESULT hr;

    hr = THR(Component()->_pSiteOM->CreateEventObject(ppEventObj));

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDD::get_document
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDD::get_document(IDispatch ** ppDocument)
{
    HRESULT hr;

    if (Component()->_fSharedMarkup)
    {
        hr = E_ACCESSDENIED;
    }
    else if (Component()->_pMarkup)
    {
        CDocument * pDocument;

        hr = THR(Component()->_pMarkup->EnsureDocument(&pDocument));
        if (hr)
            goto Cleanup;

        hr = pDocument->QueryInterface(IID_IDispatch, (void **)ppDocument);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent constructor
//
//-------------------------------------------------------------------------

CHtmlComponent::CHtmlComponent(CHtmlComponentConstructor *pConstructor, BOOL fFactoryComponent)
{
    Assert (pConstructor);

    _pConstructor = pConstructor;

    _fFactoryComponent = fFactoryComponent;

    if (_fFactoryComponent)
    {
        _pConstructor->SubAddRef();
    }
    else
    {
        _pConstructor->AddRef();
        if (!_pConstructor->_pFactoryComponent->_fFirstInstance)
        {
            _pConstructor->_pFactoryComponent->_fFirstInstance = TRUE;
            _fFirstInstance = TRUE;
            Assert(_pConstructor->_cComponents == 0);
        }
    }

#if DBG == 1
    if (!_fFactoryComponent)
        _pConstructor->_cComponents++;
#endif

#if DBG == 1
    _DD._pComponentDbg = this;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent destructor
//
//-------------------------------------------------------------------------

CHtmlComponent::~CHtmlComponent()
{
    TraceTag((tagHtcDelete, "CHtmlComponent::~CHtmlComponent, [%lx] deleted", this));

    // force passivation of omdoc
    _DD.Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Passivate
//
//-------------------------------------------------------------------------

void
CHtmlComponent::Passivate()
{
#if DBG == 1
//    if (_pElement)
//    {
//        TraceTag((
//            tagHtcInitPassivate,
//            "CHtmlComponent::Passivate, [%lx] detached from <%ls id = %ls SN = %ld>",
//            this, _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->_nSerialNumber));
//    }
#endif

    Assert (_pConstructor);

    ClearInterface (&_pSiteOM);

    GWKillMethodCall( this, ONCALL_METHOD(CHtmlComponent, FireAsyncReadyState, fireasyncreadystate), 0 );
    GWKillMethodCall( this, ONCALL_METHOD(CHtmlComponent, SetReadystateCompleteAsync, setreadystatecompleteasync), 0 );

    if (_pMarkup)
    {
        CMarkupBehaviorContext *    pMarkupBehaviorContext = _pMarkup->BehaviorContext();

        if (pMarkupBehaviorContext)
        {
            // remove back pointer - important if someone else keeps reference on the tree
            pMarkupBehaviorContext->_pHtmlComponent = NULL;

            // ensure the booster map does not grow indefinitely
            if (pMarkupBehaviorContext->_pExtendedTagTableBooster)
                pMarkupBehaviorContext->_pExtendedTagTableBooster->ResetMap();
        }

        if (!_fGotQuickDone)
        {
            _pConstructor->OnMarkupLoaded(this);
        }
        WHEN_DBG( else Assert( _pMarkup->_LoadStatus >= LOADSTATUS_QUICK_DONE ); )

        // stop further loading of the HTC markup
        _pMarkup->_LoadStatus = LOADSTATUS_DONE;

        IGNORE_HR(_pMarkup->ExecStop(FALSE, FALSE, FALSE));

        if (_pMarkup->HasScriptContext() &&
            !_fFactoryComponent &&
            _pConstructor->_pFactoryComponent->_fClonedScript)
        {
            if (_pDoc && _pDoc->_pOptionSettings && _pDoc->_pOptionSettings->fCleanupHTCs)
            {
                CScriptContext *pScriptContext = _pMarkup->ScriptContext();
                Assert(!_pConstructor->_pFactoryComponent->_fLightWeight);
                Assert(pScriptContext);
                Assert(pScriptContext->_fClonedScript);
                Assert(pScriptContext->GetNamespace());

                pScriptContext->SetNamespace(NULL);

                CScriptCollection * pScriptCollection = GetScriptCollection();
                if (pScriptCollection && (pScriptContext->_idxDefaultScriptHolder != -1) && (pScriptCollection->_aryCloneHolder.Size() > pScriptContext->_idxDefaultScriptHolder))
                {
                    CScriptHolder * pHolder = pScriptCollection->_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder];
                    if (pHolder && pHolder->_fClone)
                    {
                        Assert(!_fFirstInstance);
                        pHolder->Close();
                        pHolder->Release();
                        pScriptCollection->_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder] = NULL;
                    }
                }
            }
            else
            {
                Assert(!_pConstructor->_pFactoryComponent->_fLightWeight);
                Assert(_pMarkup->ScriptContext()->_fClonedScript);
                Assert(_pMarkup->ScriptContext()->GetNamespace());
                _pMarkup->ScriptContext()->SetNamespace(NULL);
            }
        }

        if( _pMarkup->GetObjectRefs() > 1 )
        {
            IGNORE_HR( _pMarkup->SetOrphanedMarkup( TRUE ) );
        }

        _pMarkup->Release();
        _pMarkup = NULL;
    }
    
#if DBG == 1
    if (!_fFactoryComponent)
        _pConstructor->_cComponents--;
#endif

    if (_fFactoryComponent)
    {
        _pConstructor->SubRelease();
        if (_pCustomNames)
        {
            delete _pCustomNames;
            _pCustomNames = NULL;
        }
    }
    else
    {
        if (_pScriptContext && _pConstructor->_pFactoryComponent->_fClonedScript)
        {
            Assert(_pConstructor->_pFactoryComponent->_fLightWeight && _pScriptContext->_fClonedScript);
            _pScriptContext->SetNamespace(NULL);

            if (_pDoc && _pDoc->_pOptionSettings && _pDoc->_pOptionSettings->fCleanupHTCs)
            {
                Assert(_pScriptContext->_fClonedScript);

                CScriptCollection * pScriptCollection = GetScriptCollection();
                if (pScriptCollection && (_pScriptContext->_idxDefaultScriptHolder != -1) && (pScriptCollection->_aryCloneHolder.Size() > _pScriptContext->_idxDefaultScriptHolder))
                {
                    CScriptHolder * pHolder = pScriptCollection->_aryCloneHolder[_pScriptContext->_idxDefaultScriptHolder];
                    if (pHolder && pHolder->_fClone)
                    {
                        Assert(!_fFirstInstance);
                        pHolder->Close();
                        pHolder->Release();
                        pScriptCollection->_aryCloneHolder[_pScriptContext->_idxDefaultScriptHolder] = NULL;
                    }
                }
            }
        }

        // If this is the first instance, but the SE has not been hooked up for it yet when it goes away,
        // reset the firstinstance flag on both this and the factory, so that if another comes in it can
        // become the first instance.
        if (!_pConstructor->_pFactoryComponent->_fOriginalSECreated &&
            _pConstructor->_pFactoryComponent->_fClonedScript && 
            _fFirstInstance)
        {
            _fFirstInstance = FALSE;
            _pConstructor->_pFactoryComponent->_fFirstInstance = FALSE;
        }

        _pConstructor->Release();
        Assert(!_pCustomNames);
    }
    _pConstructor = NULL;

    _pDoc->SubRelease();

    delete _pScriptContext;
    _pScriptContext = NULL;

    // clear _aryPropertyAgents
    {
        CHtmlComponentAgentBase **  ppAgent;
        int                             c;

        for (ppAgent = _aryAgents, c = _aryAgents.Size(); c; ppAgent++, c--)
        {
            (*ppAgent)->Release();
        }
        _aryAgents.DeleteAll();
    }

    if (_pProfferService)
    {
        _pProfferService->Release();
        _pProfferService = NULL;
    }

    // super
    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponent::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IPersistPropertyBag2, NULL)
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(this, NULL);
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    if (IsEqualGUID(iid, CLSID_CHtmlComponent))
    {
        *ppv = this; // weak ref
        return S_OK;
    }

    if (_pProfferService)
    {
        HRESULT     hr;
        IUnknown *  pUnk;

        hr = THR_NOTRACE(_pProfferService->QueryService(iid, iid, (void**) &pUnk));
        if (S_OK == hr)
        {
            hr = THR(CreateTearOffThunk(
                    pUnk,
                    *(void **)pUnk,
                    NULL,
                    ppv,
                    this,
                    *(void **)(IUnknown*)(IPrivateUnknown*)this,
                    QI_MASK | ADDREF_MASK | RELEASE_MASK,
                    NULL));

            pUnk->Release();

            if (S_OK == hr)
            {
                ((IUnknown*)*ppv)->AddRef();
            }

            RRETURN (hr);
        }
    }

    RRETURN (super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::QueryService, per IServiceProvider
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObject)
{
    if (IsEqualGUID(rguidService, CLSID_CHtmlComponent))
    {
        RRETURN (PrivateQueryInterface(riid, ppvObject));
    }
    else if (IsEqualGUID(rguidService, SID_SProfferService))
    {
        if (!_pProfferService)
        {
            _pProfferService = new CProfferService();
            if (!_pProfferService)
            {
                RRETURN (E_OUTOFMEMORY);
            }
        }

        RRETURN (_pProfferService->QueryInterface(riid, ppvObject));
    }

    RRETURN(_pDoc->QueryService(rguidService, riid, ppvObject));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetScriptCollection, helper
//
//-------------------------------------------------------------------------

CScriptCollection *
CHtmlComponent::GetScriptCollection()
{
    CMarkup *   pMarkup;

    if (!_pElement)
        return NULL;

    pMarkup = _pElement->GetNearestMarkupForScriptCollection();

    return pMarkup->HasWindowPending() ? pMarkup->GetScriptCollection() : NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::CanCommitScripts
//
//-------------------------------------------------------------------------

BOOL
CHtmlComponent::CanCommitScripts(CScriptElement *pelScript)
{
    if (_fFactoryComponent)
    {
        Assert(pelScript);

        if (!pelScript->GetAAevent())
        {
            if (_fClonedScriptClamp)
            {
                _fClonedScript = FALSE;
                _pConstructor->_pelFactoryScript = NULL;
            }
            else 
            {
                BOOL fOtherScript = FALSE;
                LPCTSTR pchLanguage = pelScript->GetAAlanguage();
                if (pchLanguage)
                {
                    pelScript->_fJScript = ((*pchLanguage == _T('j') || *pchLanguage == _T('J'))    &&
                                            (0 == StrCmpIC(pchLanguage, _T("jscript"))          ||
                                            0 == StrCmpIC(pchLanguage, _T("javascript"))));

                    if (!pelScript->_fJScript)
                    {
                        fOtherScript = !((*pchLanguage == _T('v') || *pchLanguage == _T('V'))    &&
                                         (0 == StrCmpIC(pchLanguage, _T("vbs"))         ||
                                         0 == StrCmpIC(pchLanguage, _T("vbscript"))));
                    }
                }

                Assert(!_pConstructor->_pelFactoryScript);
                if (!fOtherScript && (pelScript->_pchSrcCode || pelScript->_cstrText.Length() > 512))
                {
                    _fClonedScript = TRUE;
                    _pConstructor->_pelFactoryScript = pelScript;
                }
                else
                    Assert(!_fClonedScript);

                _fClonedScriptClamp = TRUE;
            }
        }

        return FALSE;
    }

    Assert (_pConstructor);
    Assert (_pConstructor->_fSupportsEditMode || !_pDoc->DesignMode());

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::CreateMarkup, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::CreateMarkup()
{
    HRESULT     hr;
    CMarkup *   pWindowedMarkupContext = NULL;

    Assert (!_pMarkup);

    if( _fFactoryComponent )
    {
        if ( _pConstructor->_pMarkup )
            pWindowedMarkupContext = _pConstructor->_pMarkup->GetWindowedMarkupContext();
    }
    else
    {
        Assert( _pElement );
        pWindowedMarkupContext = _pElement->GetWindowedMarkupContext();
    }


    hr = _pDoc->CreateMarkup(&_pMarkup, pWindowedMarkupContext );
    if (hr)
        goto Cleanup;

    hr = _pMarkup->EnsureBehaviorContext();
    if (hr)
        goto Cleanup;

    _pMarkup->BehaviorContext()->_pHtmlComponent = this; // this should happen before load

    // If we have an element, try to inherit its media
    if ( _pElement )
    {
        CMarkup  *pParentMarkup = _pElement->GetMarkup();
        mediaType mtParentMarkup;
        if ( pParentMarkup )
        {
            mtParentMarkup = pParentMarkup->GetMedia();
            // Only inherit if the parent has a media set.
            if ( mtParentMarkup != mediaTypeNotSet )
                _pMarkup->SetMedia( mtParentMarkup );

            if (    !_pMarkup->IsPrintTemplateExplicit()
                &&  pParentMarkup->IsPrintTemplate()    )
            {
                // Why the Check? Because we are being viewlinked from a print template, and print media markups cannot be print templates.
                Check(!_pMarkup->IsPrintMedia());

                _pMarkup->SetPrintTemplate(TRUE);
            }
        }
    }


Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Load(IStream * pStream)
{
    HRESULT     hr;

    hr = THR(CreateMarkup());
    if (hr)
        goto Cleanup;

    {
        CLock       (this); // Load can make this HtmlComponent passivate;
                            // but Load will not handle it gracefully if aborted while downloading from stream

        hr = THR(_pMarkup->Load(pStream, /* pContextMarkup = */NULL, /* fAdvanceLoadStatus = */TRUE));
        if (hr)
            goto Cleanup;
    }

    Assert (LOADSTATUS_PARSE_DONE <= _pMarkup->_LoadStatus);

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Load(IMoniker * pMoniker)
{
    HRESULT                 hr;
    CDwnBindInfo *          pBSC = NULL;
    IBindCtx *              pBindCtx = NULL;

    Assert (pMoniker);

    if (_pMarkup)
    {
        hr = S_OK;
        goto Cleanup;   // done - nothing to do
    }

    //
    // create tree and connect to it
    //

    hr = THR(CreateMarkup());
    if (hr)
        goto Cleanup;

    //
    // launch download
    //

    pBSC = new CDwnBindInfo();
    if (!pBSC)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(CreateAsyncBindCtx(0, pBSC, NULL, &pBindCtx));
    if (hr)
        goto Cleanup;

    hr = THR(_pMarkup->Load(
        pMoniker,
        pBindCtx,
        /* fNoProgressUI = */TRUE,
        /* fOffline = */!_fFactoryComponent,
        /* pfnTokenizerFilterOutputToken = */ _fFactoryComponent ? HTCPreloadTokenizerFilter : NULL,
        TRUE ));
    if (hr)
        goto Cleanup;

    //
    // finalize
    //

    IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));

Cleanup:

    ReleaseInterface (pBindCtx);
    if (pBSC)
        pBSC->Release();

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetAgent, helper
//
//-------------------------------------------------------------------------

CHtmlComponentAgentBase *
CHtmlComponent::GetAgent(CHtmlComponentBase * pClient)
{
    HRESULT                         hr2;
    CHtmlComponentAgentBase *       pAgent = NULL;
    
    Assert (pClient && pClient->_pElement);

    if (-1 == pClient->_idxAgent)
    {
        //
        // create a new agent for this client
        //

        pAgent = pClient->CreateAgent(this);
        if (!pAgent)
            goto Cleanup;

        hr2 = _aryAgents.Append(pAgent);
        if (hr2)
        {
            pAgent->Release();
            pAgent = NULL;
            goto Cleanup;
        }

        pClient->_idxAgent = _aryAgents.Size() - 1;
    }
    else
    {
        Assert (0 <= pClient->_idxAgent);
        
        if (pClient->_idxAgent < _aryAgents.Size())
        {
            //
            // get the existing agent
            //

            pAgent = _aryAgents[pClient->_idxAgent];
        }
        else
        {
            //
            // adjust size of the array and create a new agent at the given idx
            //

            pAgent = pClient->CreateAgent(this);
            if (!pAgent)
                goto Cleanup;

            Assert (_aryAgents.Size() == pClient->_idxAgent);

            hr2 = _aryAgents.Append(pAgent);
            if (hr2)
            {
                pAgent->Release();
                pAgent = NULL;
                goto Cleanup;
            }
        }
    }

Cleanup:

    return pAgent;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CHtmlComponent::SetReadystateCompleteAsync
//  
//  Synopsis:   Async callback to set the component to readystate complete.
//              This prevents lightweight behaviors from skipping the loading
//              state.
//              This is done in 2 stages, so that we allow asynch operations
//              from Trident proper that were queued up
//              
//  Returns:    void
//  
//  Arguments:
//          DWORD_PTR dwContext - N/A
//  
//+----------------------------------------------------------------------------
void
CHtmlComponent::SetReadystateCompleteAsync(DWORD_PTR dwContext)
{
    Assert( _fSharedMarkup && _fEmulateLoadingState );
    _fEmulateLoadingState = FALSE;
    IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::ToSharedMarkupMode, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::ToSharedMarkupMode( BOOL fSync )
{
    HRESULT     hr = S_OK;
    CScriptCollection * pScriptCollection = GetScriptCollection();

    Assert (!_fSharedMarkup);
    _fSharedMarkup = TRUE;

    if( !fSync )
    {
        _fEmulateLoadingState = TRUE;

        GWPostMethodCall(this, ONCALL_METHOD(CHtmlComponent, SetReadystateCompleteAsync, setreadystatecompleteasync), 0, TRUE, "CHtmlComponent::SetReadystateCompleteAsync");
    }

    _pScriptContext = new CScriptContext();
    if (!_pScriptContext)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!_pConstructor->_pFactoryComponent->_fClonedScript)
    {
        if (pScriptCollection)
        {
            IGNORE_HR(pScriptCollection->AddNamedItem(
                /* pchNamespace = */ NULL, _pScriptContext, (IUnknown*)(IPrivateUnknown*)&_DD));
        }
    }
    else
    {
        _pScriptContext->_fClonedScript = TRUE;
        CMarkupScriptContext *pScriptContext = _pConstructor->_pFactoryComponent->_pMarkup->ScriptContext();

        Assert(pScriptContext && pScriptContext->GetNamespace());
        Assert(!_pConstructor->_pFactoryComponent->_pScriptContext);
        _pScriptContext->_cstrNamespace.SetPch(pScriptContext->GetNamespace());
    }

    hr = THR(CommitSharedItems());
    if (hr)
        goto Cleanup;

    hr = THR(OnMarkupLoaded( /*fAsync=*/ TRUE ));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::WrapSharedElement, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::WrapSharedElement(VARIANT * pvarElement)
{
    HRESULT                     hr = E_ACCESSDENIED;
    HRESULT                     hr2;
    CElement *                  pElement;
    CHtmlComponentBase *        pHtmlComponentBase;
    CHtmlComponentAgentBase *   pAgent;

    Assert (_fSharedMarkup);
    Assert (pvarElement);

    if (VT_UNKNOWN != V_VT(pvarElement) &&
        VT_DISPATCH != V_VT(pvarElement))
        goto Cleanup;

    hr2 = THR_NOTRACE(V_UNKNOWN(pvarElement)->QueryInterface(CLSID_CElement, (void**)&pElement));
    if (hr2)
        goto Cleanup;

    pHtmlComponentBase = GetHtcFromElement(pElement);
    if (!pHtmlComponentBase)
        goto Cleanup;

    switch (pHtmlComponentBase->GetType())
    {
    case HTC_BEHAVIOR_PROPERTY:
    case HTC_BEHAVIOR_EVENT:
    case HTC_BEHAVIOR_ATTACH:
        pAgent = GetAgent(pHtmlComponentBase);
        if (!pAgent)
            goto Cleanup;
        break;

    default:
        goto Cleanup;
    }

    V_UNKNOWN(pvarElement)->Release();

    V_VT(pvarElement) = VT_UNKNOWN;
    V_UNKNOWN(pvarElement) = pAgent;
    V_UNKNOWN(pvarElement)->AddRef();
    hr = S_OK;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Init(IElementBehaviorSite * pSite)
{
    HRESULT hr;

    hr = THR(InitHelper(pSite));
    if (hr)
        goto Cleanup;

    Assert (_pElement);

    TraceTag((
        tagHtcInitPassivate,
        "CHtmlComponent::Init, [%lx] attached to <%ls id = %ls SN = %ld>",
        this, _pElement->TagName(), STRVAL(_pElement->GetAAid()), _pElement->_nSerialNumber));

    Assert (_pConstructor);

    hr = THR(_pConstructor->RequestMarkup(this));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Init, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::InitHelper(IElementBehaviorSite * pSite)
{
    if (_pSite)         // if already initialized
        return S_OK;

    HRESULT                 hr;
    IServiceProvider *      pSP = NULL;
    IHTMLElementDefaults *  pDefaults = NULL;

    //
    // get site interface pointers
    //
    
    hr = THR(super::Init(pSite));
    if (hr)
        goto Cleanup;

    hr = THR(_pSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&_pSiteOM));
    if (hr)
        goto Cleanup;

    //
    // get the doc
    //

    hr = THR(_pSite->QueryInterface(IID_IServiceProvider, (void**)&pSP));
    if (hr)
        goto Cleanup;

    hr = THR(pSP->QueryService(CLSID_HTMLDocument, CLSID_HTMLDocument, (void**)&_pDoc));
    if (hr)
        goto Cleanup;

    Assert (_pDoc);
    _pDoc->SubAddRef();

    //
    // Decide if we're an element behavior
    // There's no direct way of asking this; however, attached behaviors don't
    // have access to a "defaults" object, so we can try and get that.
    if( SUCCEEDED( _pSiteOM->GetDefaults( &pDefaults ) ) )
    {
        _fElementBehavior = TRUE;
        ReleaseInterface( pDefaults );
    }

Cleanup:
    ReleaseInterface (pSP);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Init(CDoc * pDoc)
{
    HRESULT     hr = S_OK;

    Assert (!_pSite && !_pElement && _fFactoryComponent);

    _pDoc = pDoc;
    _pDoc->SubAddRef();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::IsRecursiveUrl, helper
//
//-------------------------------------------------------------------------

BOOL
CHtmlComponent::IsRecursiveUrl(LPTSTR pchUrl)
{
    HRESULT                     hr;
    TCHAR                       achUrlExpanded1[pdlUrlLen];
    TCHAR                       achUrlExpanded2[pdlUrlLen];
    CMarkup *                   pMarkup;
    CMarkupBehaviorContext *    pMarkupBehaviorContext;

    Assert (_pElement && pchUrl && pchUrl[0]);

    hr = THR(CMarkup::ExpandUrl(NULL, 
        pchUrl, ARRAY_SIZE(achUrlExpanded1), achUrlExpanded1, _pElement));
    if (hr)
        goto Cleanup;

    pMarkup = _pElement->GetMarkup();

    // walk up parent markup chain
    while (pMarkup)
    {
        hr = THR(CMarkup::ExpandUrl(pMarkup, 
            CMarkup::GetUrl(pMarkup), ARRAY_SIZE(achUrlExpanded2), achUrlExpanded2, _pElement));

        if (hr)
            goto Cleanup;

        if (0 == StrCmpIC(achUrlExpanded1, achUrlExpanded2))
        {
            TraceTag((tagError, "Detected recursion in HTC!"));
            return TRUE;
        }

        pMarkupBehaviorContext = pMarkup->BehaviorContext();
        if (!pMarkupBehaviorContext ||
            !pMarkupBehaviorContext->_pHtmlComponent ||
            !pMarkupBehaviorContext->_pHtmlComponent->_pElement)
            break;

        pMarkup = pMarkupBehaviorContext->_pHtmlComponent->_pElement->GetMarkup();
    }

Cleanup:
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    hr = THR(FireNotification(lEvent, pVar));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Detach, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Detach(void)
{
    HRESULT                 hr = S_OK;
    LONG                    idx;
    CElement *              pElement;
    CHtmlComponentAttach *  pAttach;
    CMarkup *               pMarkup = GetMarkup();

    Assert (!IsPassivated());

    //
    // call detachEvent on all attach tags
    //

    if (pMarkup)
    {
        for (idx = 0;; idx++)
        {
            hr = THR(GetElement(&idx, &pElement, HTC_BEHAVIOR_ATTACH));
            if (hr)
                goto Cleanup;
            if (!pElement)
                break;

            pAttach = DYNCAST(CHtmlComponentAttach, GetHtcFromElement(pElement));
            Assert (pAttach);

            hr = THR(pAttach->DetachEvent(this));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::OnMarkupLoaded
//
//----------------------------------------------------------------------------

HRESULT
CHtmlComponent::OnMarkupLoaded( BOOL fAsync /*=FALSE*/ )
{
    HRESULT     hr = S_OK;
    CLock       lockComponent(this);

    if (_pConstructor)
    {
        IGNORE_HR(_pConstructor->OnMarkupLoaded(this));
    }

    if (_fContentReadyPending)
    {
        IGNORE_HR(FireNotification (BEHAVIOREVENT_CONTENTREADY, NULL));
    }

    if (_fDocumentReadyPending)
    {
        IGNORE_HR(FireNotification (BEHAVIOREVENT_DOCUMENTREADY, NULL));
    }

    if( fAsync )
    {
        GWPostMethodCall(this, ONCALL_METHOD(CHtmlComponent, FireAsyncReadyState, fireasyncreadystate), 0, TRUE, "CHtmlComponent::FireAsyncReadyState");
    }
    else
    {
        IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));
    }

    RRETURN (hr);
}


//+----------------------------------------------------------------------------
//  
//  Method:     CHtmlComponent::FireAsyncReadyState
//  
//  Synopsis:   Async callback to handle firing the ready state change
//  
//  Returns:    void
//  
//  Arguments:
//          DWORD dwContext - Not used
//  
//+----------------------------------------------------------------------------

void
CHtmlComponent::FireAsyncReadyState(DWORD_PTR dwContext)
{
    IGNORE_HR(FirePropertyNotify(DISPID_READYSTATE, TRUE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Load
//
//----------------------------------------------------------------------------

HRESULT
CHtmlComponent::OnLoadStatus(LOADSTATUS LoadStatus)
{
    HRESULT     hr = S_OK;

    TraceTag((
        tagHtcOnLoadStatus,
        "CHtmlComponent::OnLoadStatus, [%lx] load status: %ld",
        this, LoadStatus));

    switch (LoadStatus)
    {
    case LOADSTATUS_QUICK_DONE:

        _fGotQuickDone = TRUE;
        IGNORE_HR(OnMarkupLoaded());

        break;

#if DBG == 1
    case LOADSTATUS_DONE:

        // assert that markup (other then factory or shared) does not have HtmCtx - 
        // that would be a very significant perf hit
        if (!_fFactoryComponent && 
            !_fSharedMarkup && 
            !(_pMarkup->HasScriptContext() && _pMarkup->ScriptContext()->_pScriptDebugDocument))
        {
            Assert (!_pMarkup->HtmCtx());
        }

        break;
#endif
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetScriptContext
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetScriptContext(CScriptContext ** ppScriptContext)
{
    HRESULT     hr = S_OK;

    Assert (ppScriptContext);

    if (_pScriptContext)
    {
        Assert (_fSharedMarkup);
        *ppScriptContext = _pScriptContext;
    }
    else
    {
        hr = THR(GetMarkup()->EnsureScriptContext((CMarkupScriptContext**)ppScriptContext));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetMarkup
//
//-------------------------------------------------------------------------
CMarkup *
CHtmlComponent::GetMarkup()
{
    if (_fSharedMarkup &&
        _pConstructor &&
        _pConstructor->_pFactoryComponent &&
        _pConstructor->_pFactoryComponent->_pMarkup)        
    {
        Assert(_pConstructor->_pFactoryComponent->_pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE);
        return _pConstructor->_pFactoryComponent->_pMarkup;
    }
    else
    {
        return _pMarkup;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::CommitSharedItems
//
//  CONSIDER:   (alexz) optimize the passes by storing an array of elements
//              either locally or on the factory
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::CommitSharedItems()
{
    HRESULT                     hr = S_OK;
    LONG                        idx;
    CElement *                  pElement;
    CHtmlComponentBase *        pHtmlComponentBase;
    BOOL                        fRunScript;
    CMarkup *                   pMarkup;

    Assert (_pConstructor && _pConstructor->_pFactoryComponent);
    Assert (_pScriptContext && GetNamespace());

    Assert (!_fCommitting);
    _fCommitting = TRUE;

    //
    // pass 1
    //

    for (idx = 0;; idx++)
    {
        hr = THR(_pConstructor->_pFactoryComponent->GetElement(&idx, &pElement));
        if (hr)
            goto Cleanup;

        if (!pElement)
            break;

        switch (pElement->Tag())
        {
        case ETAG_SCRIPT:
            pMarkup = GetMarkup();
            if ( pMarkup )
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
                if (hr || !fRunScript)
                    goto Cleanup;

                hr = THR(DYNCAST(CScriptElement, pElement)->CommitCode(
                    TRUE,               // fCommitOutOfMarkup
                    this,               // pchNamespace
                    _pElement));        // pElementContext

                if (hr)
                    goto Cleanup;
            }
            break;

        case ETAG_GENERIC_BUILTIN:

            pHtmlComponentBase = GetHtcFromElement (pElement);
            if(pHtmlComponentBase)
            {
                switch (pHtmlComponentBase->GetType())
                {
                case HTC_BEHAVIOR_PROPERTY:
                    IGNORE_HR(DYNCAST(CHtmlComponentProperty,pHtmlComponentBase)->EnsureHtmlLoad(
                        this, /* fScriptsOnly = */TRUE));
                    break;

                case HTC_BEHAVIOR_DEFAULTS:
                    hr = THR(DYNCAST(CHtmlComponentDefaults, pHtmlComponentBase)->Commit1(this));
                    break;
                }
            }
            break;
        }
    }

    //
    // pass 2
    //

    for (idx = 0;; idx++)
    {
        hr = THR(_pConstructor->_pFactoryComponent->GetElement(&idx, &pElement));
        if (hr)
            goto Cleanup;

        if (!pElement)
            break;

        switch (pElement->Tag())
        {
        case ETAG_GENERIC_BUILTIN:

            pHtmlComponentBase = GetHtcFromElement (pElement);
            if(pHtmlComponentBase)
            {
                switch (pHtmlComponentBase->GetType())
                {
                case HTC_BEHAVIOR_PROPERTY:
                    IGNORE_HR(DYNCAST(CHtmlComponentProperty, pHtmlComponentBase)->EnsureHtmlLoad(
                        this, /* fScriptsOnly = */FALSE));
                    break;

                case HTC_BEHAVIOR_EVENT:
                    hr = THR(DYNCAST(CHtmlComponentEvent, pHtmlComponentBase)->Commit(this));
                    break;

                case HTC_BEHAVIOR_DESC:
                    hr = THR(DYNCAST(CHtmlComponentDesc, pHtmlComponentBase)->Commit(this));
                    break;

                case HTC_BEHAVIOR_ATTACH:
                    hr = THR(DYNCAST(CHtmlComponentAttach, pHtmlComponentBase)->Attach(this, /* fInit = */TRUE));
                    break;

                case HTC_BEHAVIOR_DEFAULTS:
                    hr = THR(DYNCAST(CHtmlComponentDefaults, pHtmlComponentBase)->Commit2(this));
                    break;
                }
            }
            break;
        }
    }

    _fCommitting = FALSE;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetElement, helper
//
//  Returns:    hr == S_OK, pElement != NULL:       found the element
//              hr == S_OK, pElement == NULL:       reached the end of collection
//              hr != S_OK:                         fatal error
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetElement(LONG * pIdx, CElement ** ppElement, HTC_BEHAVIOR_TYPE typeRequested)
{
    HRESULT             hr;
    CCollectionCache *  pCollection;
    LONG                idx = 0;
    HTC_BEHAVIOR_TYPE   typeElement;
    CMarkup *           pMarkup = GetMarkup();

    if (!pMarkup)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    *ppElement = NULL;

    if (!pIdx)
        pIdx = &idx;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollection = pMarkup->CollectionCache();

    for (;; (*pIdx)++)
    {
        hr = THR_NOTRACE(pCollection->GetIntoAry(
            CMarkup::ELEMENT_COLLECTION, *pIdx, ppElement));
        Assert (S_FALSE != hr);
        if (DISP_E_MEMBERNOTFOUND == hr)        // if reached end of collection
        {
            hr = S_OK;
            *ppElement = NULL;
            goto Cleanup;
        }
        if (hr)                                 // if fatal error
            goto Cleanup;

        if (HTC_BEHAVIOR_NONE == typeRequested)
            break;

        if (ETAG_GENERIC_BUILTIN != (*ppElement)->Tag())
            continue;

        typeElement = TagNameToHtcBehaviorType((*ppElement)->TagName());

        if (typeElement & typeRequested)
            break;
    }

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::AttachNotification, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::AttachNotification(DISPID dispid, IDispatch * pdispHandler)
{
    HRESULT hr;
    hr = THR(AddDispatchObjectMultiple(dispid, pdispHandler, CAttrValue::AA_AttachEvent, CAttrValue::AA_Extra_OldEventStyle));
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::FireNotification, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::FireNotification(LONG lEvent, VARIANT *pVar)
{
    HRESULT     hr = S_OK;
    DISPPARAMS  dispParams = {NULL, NULL, 0, 0};
    DISPID      dispidEvent = 0;

    switch (lEvent)
    {
    case BEHAVIOREVENT_CONTENTREADY:

        // If we're only pretending to be loading, then we should still 
        // go ahead and fire off the notification
        if ( !_fEmulateLoadingState && GetReadyState() < READYSTATE_COMPLETE )
        {
            _fContentReadyPending = TRUE;
            goto Cleanup;   // get out
        }

        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_CONTENTREADY;

        break;

    case BEHAVIOREVENT_DOCUMENTREADY:

        if ( !_fEmulateLoadingState && GetReadyState() < READYSTATE_COMPLETE )
        {
            _fDocumentReadyPending = TRUE;
            goto Cleanup;   // get out
        }

        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_DOCUMENTREADY;
        break;

    case BEHAVIOREVENT_APPLYSTYLE:
        if (pVar)
        {
            dispParams.rgvarg = pVar;
            dispParams.cArgs = 1;
        }
        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_APPLYSTYLE;
        break;

    case BEHAVIOREVENT_CONTENTSAVE:
        dispidEvent = DISPID_INTERNAL_ONBEHAVIOR_CONTENTSAVE;
        Assert(pVar);
        dispParams.rgvarg = pVar;
        dispParams.cArgs = 1;
        break;
        
    default:
        Assert (0 && "a notification not implemented in HTC");
        goto Cleanup;
    }

    IGNORE_HR(InvokeAttachEvents(dispidEvent, &dispParams, NULL, _pDoc));

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT             hr = DISP_E_UNKNOWNNAME;
    CMarkup *           pMarkup = GetMarkup();
    STRINGCOMPAREFN     pfnStrCmp = (grfdex & fdexNameCaseSensitive) ? StrCmpC : StrCmpIC;
    CElement *          pElement;
    LPCTSTR             pchName;
    long                idx;

    //
    // search markup for all property and method tags
    //

    if (pMarkup)
    {
        if (!Dirty() && _pConstructor && _pConstructor->_pFactoryComponent)
        {
            idx = FindIndexFromName(bstrName, (grfdex & fdexNameCaseSensitive));
            if (idx != -1)
            {
                WHEN_DBG(CElement *pelActual=NULL;)
                // if an inline script tries to access a prop\method when it is not yet parsed in, return error
                if (idx < (pMarkup->NumElems() - 1))
                {
                    *pdispid = DISPID_COMPONENTBASE + idx;
#if DBG == 1
                    hr = THR(GetElement(idx, &pelActual, HTC_BEHAVIOR_PROPERTYORMETHOD));
                    Assert(hr == S_OK && pelActual);
                    pchName = GetExpandoString(pelActual, _T("name"));
                    Assert(pchName);
                    Assert(0 == pfnStrCmp(pchName, bstrName));
#endif
                    hr = S_OK;
                }
            }

            goto Cleanup;
        }

        for (idx = 0;; idx++)
        {
            hr = THR(GetElement(&idx, &pElement, HTC_BEHAVIOR_PROPERTYORMETHOD));
            if (hr)
                goto Cleanup;
            if (!pElement)
            {
                hr = DISP_E_UNKNOWNNAME;
                break;
            }

            pchName = GetExpandoString(pElement, _T("name"));
            if (!pchName)
                continue;
            
            if (0 == pfnStrCmp(pchName, bstrName))
            {
                *pdispid = DISPID_COMPONENTBASE + idx;
                break;
            }
        }
    }
    
Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::InvokeEx(
    DISPID          dispid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pDispParams,
    VARIANT *       pvarRes,
    EXCEPINFO *     pExcepInfo,
    IServiceProvider * pServiceProvider)
{
    CElement *                  pElement;
    HRESULT                     hr = DISP_E_MEMBERNOTFOUND;
    IDispatchEx *               pdexElement = NULL;
    CHtmlComponentBase *        pHtc;
    CHtmlComponentProperty *    pProperty;
    CHtmlComponentMethod *      pMethod;

    switch (dispid)
    {
    case DISPID_READYSTATE:
        V_VT(pvarRes) = VT_I4;
        hr = THR(GetReadyState((READYSTATE*)&V_I4(pvarRes)));
        goto Cleanup; // done
    }

    if (GetMarkup())
    {
        //
        // find the item
        //

        hr = THR_NOTRACE(GetElement(dispid - DISPID_COMPONENTBASE, &pElement, HTC_BEHAVIOR_PROPERTYORMETHOD));
        if (hr)
            goto Cleanup;
        if (!pElement)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        //
        // invoke the item
        //

        pHtc = GetHtcFromElement(pElement);
        Assert (pHtc);

        switch (pHtc->GetType())
        {
        case HTC_BEHAVIOR_METHOD:

            if (wFlags & DISPATCH_METHOD)
            {
                pMethod = DYNCAST(CHtmlComponentMethod, pHtc);

                hr = THR_NOTRACE(pMethod->InvokeItem(this, lcid, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
                if (hr)
                    goto Cleanup;
            }
            else
                hr = DISP_E_MEMBERNOTFOUND;

            break;

        case HTC_BEHAVIOR_PROPERTY:

            pProperty = DYNCAST(CHtmlComponentProperty, pHtc);

            if (wFlags & DISPATCH_PROPERTYGET)
            {
                pProperty->EnsureHtmlLoad(this, /* fScriptsOnly = */FALSE);
            }

            hr = THR_NOTRACE(pProperty->InvokeItem(
                this, /* fScriptsOnly = */ FALSE,
                lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
            if (hr)
                goto Cleanup;

            break;

        default:
            Assert (FALSE);
            break;
        }
    }

Cleanup:
    if (hr)
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }
    ReleaseInterface(pdexElement);
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetNextDispID, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetNextDispID(
    DWORD       grfdex,
    DISPID      dispid,
    DISPID *    pdispid)
{
    CElement *      pElement;
    HRESULT         hr;

    if (!_pMarkup)
    {
        hr = S_FALSE;
        *pdispid = DISPID_UNKNOWN;
        goto Cleanup;
    }
    
    // offset from dispid range to array idx range

    if (-1 != dispid)
    {
        dispid -= DISPID_COMPONENTBASE;
    }

    dispid++;

    // get the next index

    hr = THR(GetElement(&dispid, &pElement, HTC_BEHAVIOR_PROPERTYOREVENT));
    if (hr)
        goto Cleanup;
    if (!pElement)
    {
        hr = S_FALSE;
        *pdispid = DISPID_UNKNOWN;
        goto Cleanup;
    }

    *pdispid = DISPID_COMPONENTBASE + dispid;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetMemberName, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetMemberName(DISPID dispid, BSTR * pbstrName)
{
    HRESULT     hr;
    CElement *  pElement;

    hr = THR(GetElement(dispid - DISPID_COMPONENTBASE, &pElement, HTC_BEHAVIOR_PROPERTYORMETHODOREVENT));
    if (hr)
        goto Cleanup;
    if (!pElement)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR(FormsAllocString(GetExpandoString(pElement, _T("name")), pbstrName));
    if (hr)
        goto Cleanup;

Cleanup:        
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetReadyState
//
//-------------------------------------------------------------------------

READYSTATE
CHtmlComponent::GetReadyState()
{
    if (_fSharedMarkup)
    {
        return _fEmulateLoadingState ? READYSTATE_LOADING : READYSTATE_COMPLETE;
    }
    else if (_pMarkup)
    {
        if (_pMarkup->LoadStatus() < LOADSTATUS_QUICK_DONE )
        {
            return READYSTATE_LOADING;
        }
        else
        {
            return READYSTATE_COMPLETE;
        }
    }
    else
    {
        return READYSTATE_LOADING;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::GetReadyState
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::GetReadyState(READYSTATE * pReadyState)
{
    HRESULT     hr = S_OK;

    Assert (pReadyState);

    *pReadyState = GetReadyState();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::Save
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::Save(IPropertyBag2 * pPropBag2, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2;
    LONG                        idx;
    LPCTSTR                     pchName;
    IPropertyBag *              pPropBag = NULL;
    CElement *                  pElement;
    CHtmlComponentProperty *    pProperty;

    if (!GetMarkup())
        goto Cleanup;
    
    hr = THR(pPropBag2->QueryInterface(IID_IPropertyBag, (void**)&pPropBag));
    if (hr)
        goto Cleanup;

    //
    // for every property tag in the markup...
    //

    for (idx = 0;; idx++)
    {
        hr = THR(GetElement(&idx, &pElement, HTC_BEHAVIOR_PROPERTY));
        if (hr)
            goto Cleanup;
        if (!pElement)
            break;

        pchName = GetExpandoString(pElement, _T("name"));
        if (!pchName || !HasExpando(pElement, _T("persist")))
            continue;

        pProperty = DYNCAST(CHtmlComponentProperty, GetHtcFromElement(pElement));
        Assert (pProperty);

        {
            CInvoke invoke;
        
            hr2 = THR_NOTRACE(pProperty->InvokeItem(
                this, /* fScriptsOnly = */ FALSE,
                LCID_SCRIPTING, DISPATCH_PROPERTYGET,
                &invoke._dispParams, invoke.Res(), &invoke._excepInfo, NULL));

            if (S_OK == hr2 &&
                VT_NULL  != V_VT(invoke.Res()) &&
                VT_EMPTY != V_VT(invoke.Res()))
            {
                hr = THR(pPropBag->Write(pchName, invoke.Res()));
                if (hr)
                    goto Cleanup;
            }
        }
    }
    
Cleanup:
    ReleaseInterface (pPropBag);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponent::FindBehavior, static helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponent::FindBehavior(HTC_BEHAVIOR_TYPE type, IElementBehaviorSite * pSite, IElementBehavior ** ppBehavior)
{
    HRESULT                 hr = E_FAIL;
    CHtmlComponentBase *    pBehaviorItem = NULL;

    switch (type)
    {
    case HTC_BEHAVIOR_DESC:
        pBehaviorItem = new CHtmlComponentDesc();
        break;

    case HTC_BEHAVIOR_PROPERTY:
        pBehaviorItem = new CHtmlComponentProperty();
        break;

    case HTC_BEHAVIOR_METHOD:
        pBehaviorItem = new CHtmlComponentMethod();
        break;

    case HTC_BEHAVIOR_EVENT:
        pBehaviorItem = new CHtmlComponentEvent();
        break;

    case HTC_BEHAVIOR_ATTACH:
        pBehaviorItem = new CHtmlComponentAttach();
        break;

    case HTC_BEHAVIOR_DEFAULTS:
        pBehaviorItem = new CHtmlComponentDefaults();
        break;

    default:
        *ppBehavior = &g_HtmlComponentDummy;
        hr = S_OK;
        goto Cleanup; // done
    }

    if (!pBehaviorItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pBehaviorItem->PrivateQueryInterface(IID_IElementBehavior, (void**)ppBehavior));

Cleanup:
    if (pBehaviorItem)
        pBehaviorItem->PrivateRelease();

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentPropertyAgent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::CHtmlComponentPropertyAgent
//
//-------------------------------------------------------------------------

CHtmlComponentPropertyAgent::CHtmlComponentPropertyAgent(
    CHtmlComponent * pComponent, CHtmlComponentBase * pClient)
    : CHtmlComponentAgentBase(pComponent, pClient)
{
};

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::~CHtmlComponentPropertyAgent
//
//-------------------------------------------------------------------------

CHtmlComponentPropertyAgent::~CHtmlComponentPropertyAgent()
{
    VariantClear(&_varValue);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentPropertyAgent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (hr)
        goto Cleanup;

    switch (*pdispid)
    {
    case DISPID_CHtmlComponentProperty_fireChange:
        break;

    default:
        hr = E_ACCESSDENIED;
        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentPropertyAgent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentPropertyAgent::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = E_ACCESSDENIED;

    switch (dispid)
    {
    case DISPID_CHtmlComponentProperty_fireChange:

        hr = THR(((CHtmlComponentProperty*)_pClient)->FireChange(_pComponent));

        break;

    default:

        hr = THR_NOTRACE(super::InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));

        break;
    }

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentProperty
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentProperty::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCPropertyBehavior, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::Notify
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        switch (lEvent)
        {
        case BEHAVIOREVENT_CONTENTREADY:
            EnsureHtmlLoad(_pComponent, /* fScriptsOnly =*/TRUE);
            break;

        case BEHAVIOREVENT_DOCUMENTREADY:
            EnsureHtmlLoad(_pComponent, /* fScriptsOnly =*/FALSE);
            break;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::EnsureHtmlLoad
//
//  NOTES:      Points when EnsureHtmlLoad is called:
//                  1.  as soon as <property> tag parsed (contentReady notification on the property behavior).
//                      fScriptsOnly = TRUE in this case. This call makes sure that any 
//                      script below will see corresponding script var set to the value from html.
//                  2.  as soon as any script attempts to access the property on element.
//                      fScriptsOnly = FALSE in this case. This makes sure the property
//                      is not returned NULL in this case.
//                  3.  in the end of parsing the document.
//                      fScriptsOnly = FALSE in this case. This makes sure the property is loaded
//                      completely.
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::EnsureHtmlLoad(CHtmlComponent * pComponent, BOOL fScriptsOnly)
{
    HRESULT                         hr = S_OK;
    CHtmlComponentPropertyAgent *   pAgent;

    pAgent = GetAgent(pComponent);

    if (!pAgent || pAgent->_fHtmlLoadEnsured)
        goto Cleanup;

    hr = THR_NOTRACE(HtmlLoad(pComponent, fScriptsOnly));
    if (S_OK == hr || (pComponent && !pComponent->IsConstructingMarkup()))
    {
        pAgent->_fHtmlLoadEnsured = TRUE;
    }

    TraceTag((
        tagHtcPropertyEnsureHtmlLoad,
        "CHtmlComponentProperty::EnsureHtmlLoad, element SN: %ld, name: %ls, internal name: %ls, ensured: %ls",
        _pElement ? _pElement->SN() : 0,
        GetExternalName(), GetInternalName(), pAgent->_fHtmlLoadEnsured ? _T("TRUE") : _T("FALSE")));

Cleanup:
    RRETURN (hr);
}
        
//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::HtmlLoad
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::HtmlLoad(CHtmlComponent * pComponent, BOOL fScriptsOnly)
{
    HRESULT     hr = S_OK;
    HRESULT     hr2;
    DISPID      dispid;

    //
    // load attribute from element
    //

    if (pComponent)
    {
        hr2 = THR_NOTRACE(pComponent->_pElement->GetExpandoDispID(GetExternalName(), &dispid, 0));
        if (S_OK == hr2)
        {
            CInvoke     invoke(GetUnknown());
            DISPPARAMS  dispParams = {NULL, NULL, 0, 0};
            EXCEPINFO   excepInfo;

            invoke.AddArg();

            hr = THR(pComponent->_pElement->InvokeAA(
                dispid, CAttrValue::AA_Expando, LCID_SCRIPTING,
                DISPATCH_PROPERTYGET, &dispParams, invoke.Arg(0), &excepInfo, NULL));
            if (hr)
                goto Cleanup;

            invoke.AddNamedArg(DISPID_PROPERTYPUT);

            hr = THR(InvokeItem(
                pComponent, fScriptsOnly,
                LCID_SCRIPTING, DISPATCH_PROPERTYPUT,
                &invoke._dispParams, &invoke._varRes, &invoke._excepInfo, NULL));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr;

    switch (dispid)
    {
    case DISPID_A_HTCDISPATCHITEM_VALUE:

        hr = THR_NOTRACE(InvokeItem(
            _pComponent, /* fScriptsOnly = */ FALSE,
            lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
        break;

    default:
        hr = THR_NOTRACE(super::InvokeEx(dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
        break;
    }

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::InvokeItem, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::InvokeItem(
    CHtmlComponent *    pComponent,
    BOOL                fScriptsOnly,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT                         hr = S_OK;
    DISPID                          dispid;
    BOOL                            fNameImpliesScriptsOnly;
    LPTSTR                          pchInternalName = GetInternalName(&fNameImpliesScriptsOnly, &wFlags, pDispParams);
    CScriptContext *                pScriptContext = NULL;
    CHtmlComponentPropertyAgent *   pAgent;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // first, invoke script engines
    //

    if (pComponent)
    {
        hr = pComponent->GetScriptContext(&pScriptContext);
        if (hr)
            goto Cleanup;
    }
    else
    {
        if (_pElement->IsInMarkup())
        {
            pScriptContext = _pElement->GetMarkup()->ScriptContext();
        }
    }

    if (pScriptContext)
    {
        hr = THR_NOTRACE(InvokeEngines(
                pComponent, pScriptContext, pchInternalName,
                wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
        if (DISP_E_UNKNOWNNAME != hr)   // if (S_OK == hr || DISP_E_UNKNOWNNAME != hr)
            goto Cleanup;               // done
    }

    //
    // now do our own stuff
    //

    if (!fNameImpliesScriptsOnly &&
        !fScriptsOnly)
    {
        pAgent = GetAgent(pComponent);

        if (pAgent)
        {
            if (DISPATCH_PROPERTYGET & wFlags)
            {
                // see if we have a value in agent storage
                if (VT_EMPTY != V_VT(&pAgent->_varValue))
                {
                    if (!pvarRes)
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }

                    hr = THR(VariantCopy(pvarRes, &pAgent->_varValue));

                    goto Cleanup; // done
                }

                // see if there is expando "value"
                hr = THR_NOTRACE(_pElement->GetExpandoDispID(_T("value"), &dispid, 0));
                if (hr)
                {
                    // not found, return null
                    hr = S_OK;
                    V_VT(pvarRes) = VT_NULL;
                    goto Cleanup;       // done
                }

                hr = THR(_pElement->InvokeAA(
                    dispid, CAttrValue::AA_Expando, lcid,
                    wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

                goto Cleanup; // done

            }
            else if (DISPATCH_PROPERTYPUT & wFlags)
            {
                // put an expando in agent storage

                if (!pDispParams || 
                     pDispParams->cArgs != 1 ||
                    !pDispParams->rgvarg)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }

                hr = THR(VariantCopy(&pAgent->_varValue, &pDispParams->rgvarg[0]));

                goto Cleanup; // done
            }
        }
    }

Cleanup:
    if (S_OK == hr && (DISPATCH_PROPERTYPUT & wFlags))
    {
        IGNORE_HR(FireChange(pComponent));
    }

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::fireChange, OM
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::fireChange()
{
    HRESULT     hr;

    hr = THR(FireChange(_pComponent));

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::FireChange, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentProperty::FireChange(CHtmlComponent * pComponent)
{
    HRESULT                         hr = S_OK;
    CHtmlComponentPropertyAgent *   pAgent;

    if (!pComponent)
        goto Cleanup;   // (it is legal for a prop to not have pComponent: this happens when it is used outside of HTC)

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pAgent = GetAgent(pComponent);
    if (!pAgent || !pAgent->_fHtmlLoadEnsured)
        goto Cleanup;

    hr = THR(pComponent->FirePropertyNotify(_pElement->GetSourceIndex() + DISPID_COMPONENTBASE, TRUE));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentProperty::put_value, 
//              CHtmlComponentProperty::get_value
//
//-------------------------------------------------------------------------

HRESULT CHtmlComponentProperty::put_value(VARIANT ) { Assert (0 && "not implemented"); RRETURN (E_NOTIMPL); }
HRESULT CHtmlComponentProperty::get_value(VARIANT*) { Assert (0 && "not implemented"); RRETURN (E_NOTIMPL); }

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentMethod
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentMethod::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentMethod::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    //QI_TEAROFF(this, IHTCMethodBehavior, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentMethod::InvokeItem, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentMethod::InvokeItem(
    CHtmlComponent *    pComponent,
    LCID                lcid,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr;
    CScriptContext *    pScriptContext;

    Assert (pComponent);

    hr = THR(pComponent->GetScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(InvokeEngines(
        pComponent, pScriptContext, GetInternalName(),
        DISPATCH_METHOD, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentMethod::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentMethod::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarRes,
    EXCEPINFO *         pExcepInfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT     hr;

    if (DISPID_A_HTCDISPATCHITEM_VALUE == dispid &&
        (DISPATCH_METHOD & wFlags))
    {
        hr = THR_NOTRACE(InvokeItem(_pComponent, lcid, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
    }
    else
    {
        hr = THR_NOTRACE(super::InvokeEx(dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));
    }

    RRETURN(SetErrorInfo(hr));
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentEventAgent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEventAgent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEventAgent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (hr)
        goto Cleanup;

    switch (*pdispid)
    {
    case DISPID_CHtmlComponentEvent_fire:
        break;

    default:
        hr = E_ACCESSDENIED;
        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEventAgent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEventAgent::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = E_ACCESSDENIED;
    HRESULT             hr2;
    VARIANT *           pvarParam;
    IHTMLEventObj *     pEventObject = NULL;

    switch (dispid)
    {
    case DISPID_CHtmlComponentEvent_fire:

        //
        // extract the argument: eventObject
        //

        if (pDispParams && pDispParams->cArgs)
        {
            if ( pDispParams->cArgs != 1 ||
                !pDispParams->rgvarg)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            pvarParam = &pDispParams->rgvarg[0];

            switch (V_VT(pvarParam))
            {
            case VT_NULL:
            case VT_EMPTY:
                break;

            case VT_UNKNOWN:
            case VT_DISPATCH:
                hr2 = THR_NOTRACE(V_UNKNOWN(pvarParam)->QueryInterface(
                    IID_IHTMLEventObj, (void**)&pEventObject));
                if (hr2)
                {
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }

                break;

            default:
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        //
        // fire now
        //

        hr = THR(((CHtmlComponentEvent*)_pClient)->Fire(_pComponent, pEventObject));
        if (hr)
            goto Cleanup;

        break;

    default:

        //
        // default
        //

        hr = THR_NOTRACE(super::InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));
        if (hr)
            goto Cleanup;

        break;

    }

Cleanup:
    ReleaseInterface(pEventObject);

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentAttachAgent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::CHtmlComponentAttachAgent
//
//-------------------------------------------------------------------------

CHtmlComponentAttachAgent::CHtmlComponentAttachAgent(
    CHtmlComponent * pComponent, CHtmlComponentBase * pClient)
    : CHtmlComponentAgentBase(pComponent, pClient)
{
};

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::~CHtmlComponentAttachAgent
//
//-------------------------------------------------------------------------

CHtmlComponentAttachAgent::~CHtmlComponentAttachAgent()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::GetDispID, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttachAgent::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pdispid));
    if (hr)
        goto Cleanup;

    switch (*pdispid)
    {
    case DISPID_CHtmlComponentAttach_fireEvent:
        break;

    default:
        hr = E_ACCESSDENIED;
        break;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttachAgent::InvokeEx, per IDispatchEx
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttachAgent::InvokeEx(
    DISPID              dispid,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pServiceProvider)
{
    HRESULT             hr = E_ACCESSDENIED;
    VARIANT *           pvarParam = NULL;

    switch (dispid)
    {
    case DISPID_CHtmlComponentAttach_fireEvent:

        //
        // extract the argument: eventObject
        //

        if (pDispParams && pDispParams->cArgs)
        {
            if (!pDispParams->rgvarg)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            pvarParam = &pDispParams->rgvarg[pDispParams->cArgs - 1];
        }

        //
        // fire now
        //

        hr = THR(((CHtmlComponentAttach*)_pClient)->FireEvent(_pComponent, pvarParam ? *pvarParam : CVariant(VT_NULL)));

        break;

    default:

        //
        // default
        //

        hr = THR_NOTRACE(super::InvokeEx(
            dispid, lcid, wFlags, pDispParams, pvarResult, pexcepinfo, pServiceProvider));
        if (hr)
            goto Cleanup;

        break;
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentEvent
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentEvent::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCEventBehavior, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::Init(IElementBehaviorSite * pSite)
{
    HRESULT     hr = S_OK;
    
    hr = THR(super::Init(pSite));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        hr = THR(Commit(_pComponent));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::Commit
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::Commit(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    LPTSTR      pchName;
    LONG        lFlags;

    if (!_pElement)
        goto Cleanup;
        
    pchName = GetExternalName();

    if (pchName)
    {
        lFlags = HasExpando(_pElement, _T("bubble")) ? BEHAVIOREVENTFLAGS_BUBBLE : 0;
        
        IGNORE_HR(pComponent->_pSiteOM->RegisterEvent(pchName, lFlags, &_lCookie));
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::fire, OM
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::fire(IHTMLEventObj * pEventObject)
{
    HRESULT     hr;

    hr = THR(Fire(_pComponent, pEventObject));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentEvent::Fire, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentEvent::Fire(CHtmlComponent * pComponent, IHTMLEventObj * pEventObject)
{
    HRESULT     hr = S_OK;

    if (!pComponent)
        goto Cleanup;

    Assert (!pComponent->_fFactoryComponent && pComponent->_pSiteOM);

    hr = THR(pComponent->_pSiteOM->FireEvent(_lCookie, pEventObject));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentAttach
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::PrivateQueryInterface
//
//-------------------------------------------------------------------------

STDMETHODIMP
CHtmlComponentAttach::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTCAttachBehavior, NULL)
    QI_TEAROFF(this, IHTCAttachBehavior2, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (super::PrivateQueryInterface(iid, ppv));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Init, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::Init(IElementBehaviorSite * pSite)
{
    HRESULT     hr;

    hr = THR(super::Init(pSite));
    if (hr)
        goto Cleanup;

    hr = THR(_pSite->QueryInterface(CLSID_CPeerHolderSite, (void**)&_pSiteOM));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Passivate, virtual
//
//-------------------------------------------------------------------------

void
CHtmlComponentAttach::Passivate()
{
    _pSiteOM = NULL; // _pSiteOM is a private weak ref

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::GetExternalName, virtual helper
//
//-------------------------------------------------------------------------

LPTSTR
CHtmlComponentAttach::GetExternalName()
{
    return GetExpandoString(_pElement, _T("EVENT"));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::GetEventSource
//
//-------------------------------------------------------------------------

CBase *
CHtmlComponentAttach::GetEventSource(CHtmlComponent * pComponent, BOOL fInit)
{
    HRESULT     hr;
    CBase *     pSource = NULL;
    LPTSTR      pchFor;
    LPTSTR      pchEvent;

    pchFor = GetExpandoString(_pElement, _T("for"));
    if (pchFor)
    {
        if (0 == StrCmpIC(_T("window"), pchFor))                    // window
        {
            if (fInit && pComponent->_pElement->IsInMarkup())
            {
                pSource = pComponent->_pElement->GetFrameOrPrimaryMarkup()->Window();
            }
        }
        else if (0 == StrCmpIC(_T("document"), pchFor))             // document
        {
            if (fInit && pComponent->_pElement->IsInMarkup())
            {
                CMarkup *   pMarkup = pComponent->_pElement->GetMarkup();

                if (pMarkup)
                {
                    hr = THR(pMarkup->EnsureDocument((CDocument**)&pSource));
                    if (hr)
                        goto Cleanup;
                }
            }
        }
        else if (0 == StrCmpIC(_T("element"), pchFor))              // element
        {
            pSource = pComponent->_pElement;
        }
    }
    else
    {
        pSource = pComponent->_pElement;
    }

    /// reset pSource for any peer notifications if the source is specified to be the element
    if (pSource && pSource == pComponent->_pElement)
    {
        pchEvent = GetExternalName();

        if (pchEvent && CNotifications::Find(pchEvent))
        {
            pSource = NULL;
        }
    }

Cleanup:

    return pSource;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::GetEventHandler
//
//-------------------------------------------------------------------------

IDispatch *
CHtmlComponentAttach::GetEventHandler(CHtmlComponent * pComponent)
{
    HRESULT             hr;
    IDispatch *         pdispHandler = NULL;
    LPTSTR              pchHandler;
    CScriptContext *    pScriptContext;

    pchHandler = GetExpandoString(_pElement, _T("handler"));
    if (!pchHandler)
        goto Cleanup;

    //
    // get IDispatch from script engines
    //

    {
        VARIANT     varRes;
        DISPPARAMS  dispParams = {NULL, NULL, 0, 0};
        EXCEPINFO   excepInfo;

        hr = THR(pComponent->GetScriptContext(&pScriptContext));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(InvokeEngines(
            pComponent, pScriptContext, pchHandler,
            DISPATCH_PROPERTYGET, &dispParams, &varRes, &excepInfo, NULL));
        if (hr)
            goto Cleanup;

        if (VT_DISPATCH != V_VT(&varRes))
            goto Cleanup;

        pdispHandler = V_DISPATCH(&varRes);
    }

Cleanup:

    return pdispHandler;
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::CreateEventObject
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::CreateEventObject(VARIANT varArg, IHTMLEventObj ** ppEventObject)
{
    HRESULT             hr = S_OK;
    HRESULT             hr2;
    IHTMLEventObj2 *    pEventObject2 = NULL;
    IHTMLStyle2 *       pStyle = NULL;
    TCHAR *             pchEventName = GetExternalName();

    Assert (ppEventObject);

    hr = THR(_pSiteOM->CreateEventObject(ppEventObject));
    if (hr)
        goto Cleanup;

    hr = THR((*ppEventObject)->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObject2));
    if (hr)
        goto Cleanup;

    // Make sure we only set properties that correspond to the appropriate event
    if( pchEventName )
    {
        CNotifications::CItem const *     pNotification;

        pNotification = CNotifications::Find( pchEventName );
        if( pNotification )
        {
            if( pNotification->_lEvent == BEHAVIOREVENT_APPLYSTYLE &&
                ( ( V_VT(&varArg) == VT_DISPATCH && V_DISPATCH(&varArg) ) ||
                  ( V_VT(&varArg) == VT_UNKNOWN  && V_UNKNOWN(&varArg) ) ) )
            {
                // if the argument is a style object
                hr2 = THR_NOTRACE(V_UNKNOWN(&varArg)->QueryInterface(IID_IHTMLStyle2, (void**)&pStyle));
                if (S_OK == hr2)
                {
                    hr = THR(pEventObject2->setAttribute(_T("style"), varArg, 0));
                    if (hr)
                        goto Cleanup;
                }
            }
            else if( pNotification->_lEvent == BEHAVIOREVENT_CONTENTSAVE &&
                     V_VT(&varArg) == VT_BSTR &&
                     V_BSTR(&varArg) )
            {
                hr = THR(pEventObject2->setAttribute(_T("saveType"), varArg, 0));
                if( hr )
                    goto Cleanup;
            }
        }
    }

Cleanup:
    ReleaseInterface (pEventObject2);
    ReleaseInterface (pStyle);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::FireHandler
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::FireHandler(
    CHtmlComponent *    pComponent,
    IHTMLEventObj *     pEventObject,
    BOOL                fReuseCurrentEventObject)
{
    HRESULT hr;

	// NOTE any change here might have to be mirrored in CPeerHolder::CPeerSite::FireEvent

    if (fReuseCurrentEventObject)
    {
        hr = THR(FireHandler2(pComponent, NULL));
    }
    else if (pEventObject)
    {
        CEventObj::COnStackLock onStackLock(pEventObject);

        hr = THR(FireHandler2(pComponent, pEventObject));
    }
    else
    {
        AssertSz(_pElement && _pElement->Doc(),"Possible Async Problem Causing Watson Crashes");
        EVENTPARAM param(_pElement->Doc(), _pElement, NULL, TRUE);

        hr = THR(FireHandler2(pComponent, pEventObject));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::FireHandler2
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::FireHandler2(CHtmlComponent * pComponent, IHTMLEventObj * pEventObject)
{
    HRESULT     hr = S_OK;
    IDispatch * pdispHandler = GetEventHandler(pComponent);

    if (pdispHandler)
    {
        CInvoke     invoke(pdispHandler);
        VARIANT *   pvar;

        if (pEventObject)
        {
            hr = THR(invoke.AddArg());
            if (hr)
                goto Cleanup;

            pvar = invoke.Arg(0);
            V_VT(pvar) = VT_DISPATCH;
            V_DISPATCH(pvar) = pEventObject;
            V_DISPATCH(pvar)->AddRef();
        }
        
        hr = THR(invoke.Invoke(DISPID_VALUE, DISPATCH_METHOD));
    }

Cleanup:
    ReleaseInterface(pdispHandler);
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::fireEvent, OM
//
//  Note (JHarding): There's some slightly sneaky stuff going on here:
//  In IE5, we shipped the IHTCAttachBehavior, which contained fireEvent
//  taking an IDispatch pointer.  We have to maintain this for early-bound
//  clients, but for scripting clients, we want them to get a new version
//  that takes a VARIANT (this argument may be added as an expando to
//  the event object in certain cases).
//  The solution is to maintain the IHTCAttachBehavior interface as it
//  was, and add an IHTCAttachBehavior2, which contains a new version
//  of fireEvent taking a VARIANT.
//  Then, we tweak the mondo dispatch such that the old fireEvent is
//  replaced with the new one.
//  Executive summary:  Dispatch clients will get the new fireEvent, 
//  where the IDispatch* they were passing before gets happily converted
//  to a VARIANT.  Additionally, they can now pass strings, etc. as
//  required by new events.  Early bound clients will access the new
//  functionality by using the version on IHTCAttachBehavior2.
//  Internally, these are fireEventOld and fireEvent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::fireEventOld(IDispatch * pdispArg)
{
    HRESULT     hr;
    CVariant    vt(VT_DISPATCH);

    V_DISPATCH(&vt) = pdispArg;
    if( pdispArg )
    {
        pdispArg->AddRef();
    }
    hr = THR(FireEvent(_pComponent, vt));

    RRETURN(hr);
}

HRESULT
CHtmlComponentAttach::fireEvent(VARIANT varArg)
{
    HRESULT hr;

    hr = THR(FireEvent(_pComponent, varArg));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::FireEvent, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::FireEvent(
    CHtmlComponent *            pComponent,
    VARIANT                     varArg)
{
    HRESULT                     hr = S_OK;
    LONG                        lCookie;
    IDispatch *                 pdispContext = NULL;
    BOOL                        fReuseCurrentEventObject = FALSE;
    IHTMLEventObj *             pEventObject = NULL;

    TraceTag((tagHtcAttachFireEvent, "CHtmlComponentAttach::FireEvent, event: %ls, %lx", GetExternalName(), this));
    
    if ( pComponent && 
         pComponent->_pElement && 
         !pComponent->_pElement->IsPassivating() && 
         pComponent->_pElement->GetWindowedMarkupContext()->HasWindowPending() )
    {
        CLock lockComponent(pComponent);
    
        //
        // setup parameters
        //

        // event object
        if (_fEvent)
        {
            fReuseCurrentEventObject = TRUE;
        }
        else
        {
            hr = THR(CreateEventObject(varArg, &pEventObject));
            if (hr)
                goto Cleanup;
        }

        // pdispContext
        if (!pComponent->_fSharedMarkup)
        {
            if (!_pElement)
                goto Cleanup;

            hr = THR(_pElement->PrivateQueryInterface(IID_IDispatch, (void**)&pdispContext));
            if (hr)
                goto Cleanup;
        }
        else
        {
            pdispContext = GetAgent(pComponent);
            if (!pdispContext)
                goto Cleanup;

            pdispContext->AddRef();
        }
        Assert (pdispContext);

        //
        // fire
        //

        hr = THR(_pSiteOM->GetEventCookie(_T("onevent"), &lCookie));
        if (hr)
            goto Cleanup;

        hr = THR(_pSiteOM->FireEvent(lCookie, pEventObject, fReuseCurrentEventObject, pdispContext));
        if (hr)
            goto Cleanup;

        IGNORE_HR(FireHandler(pComponent, pEventObject, fReuseCurrentEventObject));
    }

Cleanup:
    ReleaseInterface(pdispContext);
    ReleaseInterface(pEventObject);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Attach
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::Attach(CHtmlComponent * pComponent, BOOL fInit)
{
    HRESULT                     hr = S_OK;
    CBase *                     pEventSource;
    LPTSTR                      pchEventName;
    BSTR                        bstrEventName = NULL;
    CNotifications::CItem const * pNotification;
    IDispatch *                 pdispSink = NULL;

    if (!pComponent)
        goto Cleanup;

    if (!pComponent->_fSharedMarkup)
    {
        hr = THR(PrivateQueryInterface(IID_IDispatch, (void**)&pdispSink));
        if (hr)
            goto Cleanup;
    }
    else
    {
        pdispSink = GetAgent(pComponent);
        if (!pdispSink)
            goto Cleanup;

        pdispSink->AddRef();
    }

    Assert (pdispSink);

    pchEventName = GetExternalName();
    if (!pchEventName)
        goto Cleanup;

    pEventSource = GetEventSource(pComponent, fInit);

    if (fInit)
    {
        CPeerHolder::CPeerSite *pSite;

        if (pComponent->_fSharedMarkup)
        {
            Assert(pComponent->_pConstructor->_pFactoryComponent->_fLightWeight);
            hr = THR(_pSiteOM->QueryInterface(CLSID_CPeerHolderSite, (void**)&pSite));
            if (hr)
                goto Cleanup;

            hr = THR(pSite->RegisterEventHelper(_T("onevent"), 0, NULL, pComponent));
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = THR(_pSiteOM->RegisterEvent(_T("onevent"), 0, NULL));
            if (hr)
                goto Cleanup;
        }
    }

    _fEvent = (NULL != pEventSource);

    if (pEventSource)
    {
        //
        // attach to element / document / window events
        //

        hr = THR(FormsAllocString(pchEventName, &bstrEventName));
        if (hr)
            goto Cleanup;

        if (fInit)
        {
            IGNORE_HR(pEventSource->attachEvent(bstrEventName, (IDispatch*)pdispSink, NULL));
        }
        else
        {
            IGNORE_HR(pEventSource->detachEvent(bstrEventName, (IDispatch*)pdispSink));
        }
    }
    else // if (!pEventSource)
    {
        //
        // attach to behavior-specific notifications
        //

        if (fInit)
        {
            pNotification = CNotifications::Find(pchEventName);
            if (pNotification)
            {
                if (-1 != pNotification->_dispidInternal)
                {
                    hr = THR(pComponent->AttachNotification(pNotification->_dispidInternal, pdispSink));
                    if (hr)
                        goto Cleanup;
                }

                if (-1 != pNotification->_lEvent)
                {
                    hr = THR(pComponent->_pSite->RegisterNotification(pNotification->_lEvent));
                }
            }
        }
    }
    
Cleanup:
    FormsFreeString(bstrEventName);
    ReleaseInterface(pdispSink);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::Notify
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        switch (lEvent)
        {
        case BEHAVIOREVENT_DOCUMENTREADY:

            Assert (S_OK == TestProfferService());

            IGNORE_HR(Attach(_pComponent, /* fInit = */ TRUE));

            break;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::detachEvent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::detachEvent()
{
    HRESULT     hr;

    hr = THR(DetachEvent(_pComponent));

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::DetachEvent
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::DetachEvent(CHtmlComponent * pComponent)
{
    HRESULT                     hr = S_OK;
    LPTSTR                      pchName;

    if (!pComponent)
        goto Cleanup;

    pchName = GetExternalName();
    if (!pchName)
        goto Cleanup;

    if (0 == StrCmpIC(_T("onDetach"), pchName))
    {
        IGNORE_HR(FireEvent(pComponent, CVariant(VT_NULL)));
    }

    hr = THR(Attach(pComponent, /* fInit = */ FALSE));
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDesc
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDesc::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDesc::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    switch (lEvent)
    {
    case BEHAVIOREVENT_DOCUMENTREADY:

        if (_pComponent && !_pComponent->IsSkeletonMode())
        {
            hr = THR(Commit(_pComponent));
        }

        break;
    }
    
Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDesc::Commit, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDesc::Commit(CHtmlComponent * pComponent)
{
    HRESULT     hr = S_OK;
    LPTSTR      pch;

    if (!pComponent || pComponent->IsSkeletonMode())
        goto Cleanup;

    pch = GetExpandoString(_pElement, _T("urn"));
    if (pch)
    {
        hr = THR(pComponent->_pSiteOM->RegisterUrn(pch));
        if (hr)
            goto Cleanup;
    }

    pch = GetExpandoString(_pElement, _T("name"));
    if (pch)
    {
        hr = THR(pComponent->_pSiteOM->RegisterName(pch));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// CHtmlComponentDefaults
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::Notify, per IElementBehavior
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::Notify(LONG lEvent, VARIANT * pVar)
{
    HRESULT     hr;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }
    
    hr = THR(super::Notify(lEvent, pVar));
    if (hr)
        goto Cleanup;

    if (_pComponent && !_pComponent->IsSkeletonMode())
    {
        switch (lEvent)
        {
        case BEHAVIOREVENT_CONTENTREADY:

            hr = THR(Commit1(_pComponent));

            break;

        case BEHAVIOREVENT_DOCUMENTREADY:

            hr = THR(Commit2(_pComponent));

            break;
        }
    }
    
Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::Commit1, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::Commit1(CHtmlComponent * pComponent)
{
    HRESULT                 hr = S_OK;
    IDispatch *             pdispDefaults = NULL;
    CDefaults *             pDefaults = NULL;
    BOOL                    fDefStyle;
    BOOL                    fDefProps;

    Assert (_pElement);

    //
    // access to Defaults object 
    // TODO(alexz) don't ensure it if we have no properties
    //

    hr = THR(pComponent->_DD.get_defaults(&pdispDefaults));
    if (hr)
        goto Cleanup;

    hr = THR(pdispDefaults->QueryInterface(CLSID_HTMLDefaults, (void**)&pDefaults));
    if (hr)
        goto Cleanup;

    //
    // copy the defaults
    //

    hr = THR(CommitStyle(pComponent, pDefaults, &fDefStyle));
    if (hr)
        goto Cleanup;

    hr = THR(CommitHelper(pDefaults, &fDefProps));
    if (hr)
        goto Cleanup;

    if (fDefProps || fDefStyle)
    {
        // (JHarding): We were doing an OnCSSChange, which was basically invalidating
        // the entire markup here.  Bad.  We should just have to clear the caches and
        // force a relayout of the element.
        hr = THR(pComponent->_pElement->ClearRunCaches(ELEMCHNG_CLEARCACHES));
        if( hr )
            goto Cleanup;
        pComponent->_pElement->ResizeElement();
    }

Cleanup:

    ReleaseInterface(pdispDefaults);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::Commit2, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::Commit2(CHtmlComponent * pComponent)
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2;
    BOOL                        f;
    CMarkup *                   pMarkup;
    CDocument *                 pDocument;
    IHTMLDocument *             pDocFragment = NULL;
    IHTMLElementDefaults *      pElementDefaults = NULL;

    Assert (pComponent);
    Assert (_pElement);

    // ( viewLinkContent is only allowed for HTCs that don't share markup )
    if (!pComponent->_fSharedMarkup)
    {
        // While printing, we persist & reviewlink HTC content.
        // HTCs can currently viewlink two ways:
        //  1. PUBLIC component     blocked here.
        //  2. Script               blocked by CMarkup::DontRunScripts
        pMarkup = pComponent->GetMarkup();
        if (!pMarkup->IsPrintMedia())
        {
        
            hr2 = GetExpandoBoolHr(_pElement, _T("viewLinkContent"), &f);
            if (S_OK == hr2 && f)
            {
                Assert (READYSTATE_COMPLETE == pComponent->GetReadyState());

                hr = THR(pComponent->_pSiteOM->GetDefaults(&pElementDefaults));
                if (hr)
                    goto Cleanup;

                hr = THR(pMarkup->EnsureDocument(&pDocument));
                if (hr)
                    goto Cleanup;

                hr = THR(pDocument->QueryInterface(IID_IHTMLDocument, (void **)&pDocFragment));
                if (hr)
                    goto Cleanup;

                hr = THR(pElementDefaults->put_viewLink(pDocFragment));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:

    ReleaseInterface (pElementDefaults);
    ReleaseInterface (pDocFragment);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::CommitStyle, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::CommitStyle(CHtmlComponent * pComponent, CDefaults * pDefaultsTarget, BOOL *pfDefStyle)
{
    HRESULT         hr = S_OK;
    CAttrArray *    pAASource;
    CAttrArray **   ppAATarget;
    CStyle *        pStyleTarget;

    Assert (pComponent && pComponent->_pElement);
    Assert (_pElement);
    Assert (pDefaultsTarget);
    Assert (pfDefStyle);

    *pfDefStyle = FALSE;

    //
    // get source AA
    //

    pAASource = _pElement->GetInLineStyleAttrArray();
    if (!pAASource)
        goto Cleanup;

    //
    // get target AA
    //

    hr = THR(pDefaultsTarget->EnsureStyle(&pStyleTarget));
    if (hr)
        goto Cleanup;

    ppAATarget = pStyleTarget->GetAttrArray();
    if (!ppAATarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // merge now and make sure the style is invalidated
    //

    hr = THR(pAASource->Merge(ppAATarget, NULL, NULL));
    if (hr)
        goto Cleanup;

    *pfDefStyle = TRUE;

Cleanup:

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentDefaults::CommitHelper, helper
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentDefaults::CommitHelper(CDefaults * pDefaults, BOOL *pfDefProps)
{
    HRESULT         hr = S_OK;
    HRESULT         hr2;
    BOOL            f;
    LONG            l;
    htmlEditable    editable;

    Assert (_pElement);
    Assert (pfDefProps);

    //
    // TODO (alexz) do this in a generic way
    //

    *pfDefProps = FALSE;
    editable = _pElement->GetAAcontentEditable();

    if (htmlEditableInherit != editable)
    {
        hr = THR(pDefaults->SetAAcontentEditable(editable));
        if (hr)
            goto Cleanup;

        *pfDefProps = TRUE;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("tabStop"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAtabStop((short) f));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("isMultiLine"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAisMultiLine((short) f));
        if (hr)
            goto Cleanup;

        if (!f)
        {
            CStyle *pDefaultStyle;
            CAttrArray *pDefaultStyleAA;
            CAttrArray **ppDefaultStyleAA;

            hr = THR(pDefaults->EnsureStyle(&pDefaultStyle));
            if (hr)
                goto Cleanup;

            Assert(pDefaultStyle);
            ppDefaultStyleAA = pDefaultStyle->GetAttrArray();
            if (!ppDefaultStyleAA)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            pDefaultStyleAA = *ppDefaultStyleAA;
            hr = THR(CAttrArray::SetSimple(&pDefaultStyleAA, (const PROPERTYDESC *)&s_propdescCStylewhiteSpace,
                                           styleWhiteSpaceNowrap, 0));
            if (hr)
                goto Cleanup;
        }
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("canHaveHtml"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAcanHaveHTML((short) f));
        if (hr)
            goto Cleanup;
    }
    
    hr2 = GetExpandoLongHr(_pElement, _T("scrollSegmentX"), &l);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAscrollSegmentX(l));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoLongHr(_pElement, _T("scrollSegmentY"), &l);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAscrollSegmentY(l));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("viewMasterTab"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAviewMasterTab((short) f));
        if (hr)
            goto Cleanup;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("viewInheritStyle"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAviewInheritStyle((short) f));
        if (hr)
            goto Cleanup;

        *pfDefProps = TRUE;
    }

    hr2 = GetExpandoBoolHr(_pElement, _T("frozen"), &f);
    if (S_OK == hr2)
    {
        hr = THR(pDefaults->SetAAfrozen((short) f));
        if (hr)
            goto Cleanup;

        *pfDefProps = TRUE;
    }

Cleanup:

    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
// Proffer service testing, DEBUG ONLY code
//
///////////////////////////////////////////////////////////////////////////

#if DBG == 1

const IID IID_IProfferTest = {0x3050f5d7, 0x98b5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B};

class CProfferTestObj : public IServiceProvider
{
public:
    CProfferTestObj() { _ulRefs = 1; }
    DECLARE_FORMS_STANDARD_IUNKNOWN(CProfferTestObj);
    STDMETHOD(QueryService)(REFGUID rguidService, REFIID riid, void ** ppv);
};

HRESULT
CProfferTestObj::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualGUID(riid, IID_IProfferTest))
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }

    Assert (0 && "CProfferTestObj should never be QI-ed with anything but IID_IProfferTest");

    return E_NOTIMPL;
}

HRESULT
CProfferTestObj::QueryService(REFGUID rguidService, REFIID riid, void ** ppv)
{
    Assert (IsEqualGUID(rguidService, riid));
    RRETURN (QueryInterface(riid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlComponentAttach::TestProfferService, DEBUG ONLY code
//
//-------------------------------------------------------------------------

HRESULT
CHtmlComponentAttach::TestProfferService()
{
    HRESULT             hr = S_OK;
    IServiceProvider *  pSP = NULL;
    IProfferService *   pProfferService = NULL;
    DWORD               dwServiceCookie;
    IUnknown *          pTestInterface = NULL;
    IUnknown *          pTestInterface2 = NULL;
    CProfferTestObj *   pProfferTest = NULL;

    if (!_pComponent || !_pComponent->_pElement)
        goto Cleanup;

    pProfferTest = new CProfferTestObj();
    if (!pProfferTest)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // register the interface with HTC
    //

    hr = THR(_pSite->QueryInterface(IID_IServiceProvider, (void**)&pSP));
    if (hr)
        goto Cleanup;

    hr = THR(pSP->QueryService(SID_SProfferService, IID_IProfferService, (void**)&pProfferService));
    if (hr)
        goto Cleanup;

    hr = THR(pProfferService->ProfferService(IID_IProfferTest, pProfferTest, &dwServiceCookie));
    if (hr)
        goto Cleanup;

    //
    // verify the interface is QI-able from HTC behavior and properly thunked
    //

    hr = THR(_pComponent->_pElement->GetPeerHolder()->QueryPeerInterfaceMulti(
        IID_IProfferTest, (void**)&pTestInterface, /* fIdentityOnly = */FALSE));
    if (hr)
        goto Cleanup;

    pTestInterface->AddRef();
    pTestInterface->Release();

    hr = THR(pTestInterface->QueryInterface(IID_IProfferTest, (void**)&pTestInterface2));
    if (hr)
        goto Cleanup;

    pTestInterface2->AddRef();
    pTestInterface2->Release();

Cleanup:
    ReleaseInterface (pSP);
    ReleaseInterface (pProfferService);
    ReleaseInterface (pTestInterface);
    ReleaseInterface (pTestInterface2);
    if (pProfferTest)
        pProfferTest->Release();

    RRETURN(hr);
}

#endif

///////////////////////////////////////////////////////////////////////////
//
// CProfferService
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CProfferService constructor
//
//-------------------------------------------------------------------------

CProfferService::CProfferService()
{
    _ulRefs = 1;
};

//+------------------------------------------------------------------------
//
//  Member:     CProfferService destructor
//
//-------------------------------------------------------------------------

CProfferService::~CProfferService()
{
    int i, c;

    for (i = 0, c = _aryItems.Size(); i < c; i++)
    {
        delete _aryItems[i];
    }

    _aryItems.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

STDMETHODIMP
CProfferService::QueryInterface(REFIID iid, void **ppv)
{

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS(this, IUnknown)
    QI_INHERITS(this, IProfferService)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN (E_NOTIMPL);
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::ProfferService, per IProfferService
//
//-------------------------------------------------------------------------

HRESULT
CProfferService::ProfferService(REFGUID rguidService, IServiceProvider * pSP, DWORD * pdwCookie)
{
    HRESULT                 hr;
    CProfferServiceItem *   pItem;

    pItem = new CProfferServiceItem(rguidService, pSP);
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_aryItems.Append(pItem));
    if (hr)
        goto Cleanup;

    if (!pdwCookie)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pdwCookie = _aryItems.Size() - 1;

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::RevokeService, per IProfferService
//
//-------------------------------------------------------------------------

HRESULT
CProfferService::RevokeService(DWORD dwCookie)
{
    if ((DWORD)_aryItems.Size() <= dwCookie)
    {
        RRETURN (E_INVALIDARG);
    }

    delete _aryItems[dwCookie];
    _aryItems[dwCookie] = NULL;

    RRETURN (S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CProfferService::QueryService
//
//-------------------------------------------------------------------------

HRESULT
CProfferService::QueryService(REFGUID rguidService, REFIID riid, void ** ppv)
{
    CProfferServiceItem *   pItem;
    int                     i, c;

    for (i = 0, c = _aryItems.Size(); i < c; i++)
    {
        pItem = _aryItems[i];
        if (pItem && IsEqualGUID(pItem->_guidService, rguidService))
        {
            RRETURN (pItem->_pSP->QueryService(rguidService, riid, ppv));
        }
    }

    RRETURN (E_NOTIMPL);
}

HRESULT
CHtmlComponent::EnsureCustomNames()
{
    HRESULT hr = S_OK;

    if (!_pCustomNames)
    {
        _pCustomNames = new CStringTable(CStringTable::CASEINSENSITIVE);
        if (!_pCustomNames)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    RRETURN (hr);
}

void CHtmlComponent::AddAtom(LPTSTR pchName, LPVOID pv)
{
    HRESULT hr;
    Assert(pchName);
    Assert(_fFactoryComponent);

    hr = THR(EnsureCustomNames());
    if (hr)
        return;

    IGNORE_HR(_pCustomNames->Add(pchName, pv, NULL, FALSE));
}

long CHtmlComponent::FindIndexFromName(LPTSTR pchName, BOOL fCaseSensitive)
{
    CHtmlComponent *pFactory = _pConstructor->_pFactoryComponent;
    CElement *pel = NULL;
    LONG_PTR idx = -1;

    if (pFactory->_pCustomNames)
    {
        HRESULT hr;
        LPCTSTR pActualName = NULL;
        Assert(pchName);

        hr = THR(pFactory->_pCustomNames->Find(pchName, pFactory->_fLightWeight ? (LPVOID*)&pel : (LPVOID*)&idx, NULL, fCaseSensitive ? &pActualName : NULL));
        if (hr || (pActualName && StrCmpC(pActualName, pchName)))
        {
            // No such name exists, or name is not a case sensitive match, bail out
            idx = -1;
            goto Cleanup;
        }

        if (pFactory->_fLightWeight)
        {
            if ((LONG_PTR)pel < HTC_PROPMETHODNAMEINDEX_BASE)
            {
                // Custom Event dispid, bail out
                Assert(idx == -1);
                goto Cleanup;
            }

            if (pel && (HTC_BEHAVIOR_PROPERTYORMETHOD & TagNameToHtcBehaviorType(pel->TagName())))
            {
                Assert(pel->GetMarkup() == pFactory->_pMarkup);
                idx = pel->GetSourceIndex();
            }
            else
            {
                // Not a htc property or method, bail out
                Assert(idx == -1);
                goto Cleanup;
            }
        }
        else
        {
            Assert(idx != -1);
            Assert(!_fFactoryComponent);
            if (idx < HTC_PROPMETHODNAMEINDEX_BASE)
            {
                // Custom Event dispid, bail out
                idx = -1;
                goto Cleanup;
            }

            idx -= HTC_PROPMETHODNAMEINDEX_BASE;
        }

        Assert(idx != -1);
    }

Cleanup:
    return idx;
}

long CHtmlComponent::FindEventCookie(LPTSTR pchEvent)
{
    long idx = -1;

    Assert(_fFactoryComponent);
    if (_pCustomNames)
    {
        HRESULT hr;
        Assert(pchEvent);

        hr = THR(_pCustomNames->Find(pchEvent, (LPVOID*)&idx));
        if (hr)
            idx = -1;
    }

    return idx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\hedelems.cxx ===
//+---------------------------------------------------------------------
//
//   File:      hedelems.cxx
//
//  Contents:   Elements that are normally found in the HEAD of an HTML doc
//
//  Classes:    CMetaElement, CLinkElement, CIsIndexElement, CBaseElement, CNextIdElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_BUFFER_HXX_
#define X_BUFFER_HXX_
#include "buffer.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include <htiface.h>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "hedelems.hdl"

MtDefine(CTitleElement,   Elements, "CTitleElement")
MtDefine(CMetaElement,    Elements, "CMetaElement")
MtDefine(CBaseElement,    Elements, "CBaseElement")
MtDefine(CIsIndexElement, Elements, "CIsIndexElement")
MtDefine(CNextIdElement,  Elements, "CNextIdElement")
MtDefine(CHeadElement,    Elements, "CHeadElement")
MtDefine(CHtmlElement,    Elements, "CHtmlElement")

//+------------------------------------------------------------------------
//
//  Class:      CHtmlElement
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

// The HTML element needs its own accelerator key table in strict CSS1 mode.
// We borrow the BODY's browse mode table definition.  <g>
// Since HTML layout is never used in design mode, it does not need a design mode set.
// Having a table should not impact the backwards compatible case.  (greglett) (ashrafm)
CElement::ACCELS CHtmlElement::s_AccelsHtmlRun    = CElement::ACCELS (&CElement::s_AccelsElementRun, IDR_ACCELS_BODY_RUN);

// NOTE (greglett)
// In BackCompat, HTML should never have a layout, hence the ELEMENTDESC_NOLAYOUT
// In CSS1 Strict Doctypes, it should always have a layout.
// This layoutness is hardwired into the ShouldHaveLayout functions.
const CElement::CLASSDESC CHtmlElement::s_classdesc =
{
    {
        &CLSID_HTMLHtmlElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLElement,                  // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLElement,
    &CHtmlElement::s_AccelsHtmlRun          // _pAccelsRun
};


//+----------------------------------------------------------------
//
//  Member:   CHtmlElement::CreateElement
//
//---------------------------------------------------------------

HRESULT
CHtmlElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CHtmlElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmlElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CHtmlElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLHtmlElement, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+----------------------------------------------------------------
//
//  Member:   ApplyDefaultFormat
//
//  Synopsis: this is only interesting for the HTML element. in That
//            case, we apply in the attrarray from the document. this
//            allows for default values (like from the HTMLDlg code)
//            to be incorparated at this early point.
//
//---------------------------------------------------------------

HRESULT
CHtmlElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    BOOL            fHTMLLayout = GetMarkup()->IsHtmlLayout();

    Assert(pCFI && pCFI->_pNodeContext && SameScope(pCFI->_pNodeContext, this));

    // if we have history that saved document direction we begin the chain here
    // if direction has been explicitly set, this will be overridden.
    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();
    if(GetMarkup() && GetMarkup()->Window())
    {
        WORD wDocDir = GetMarkup()->Document()->_eHTMLDocDirection;
        pCFI->_cf()._fRTL = (wDocDir == htmlDirRightToLeft);
        pCFI->_ff().SetExplicitDir(wDocDir != htmlDirNotSet);
    }
    else
    {
        pCFI->_cf()._fRTL = FALSE;
        pCFI->_ff().SetExplicitDir(FALSE);
    }
    pCFI->UnprepareForDebug();

          
    // In the strict CSS1 document, the HTML element owns the "canvas" node
    // with the outer 3D border & document scrollbar.
    if (fHTMLLayout)
    {
        BOOL  fSlaveBody  = GetMarkup()->Root()->HasMasterPtr();
        CElement * pBody  = GetMarkup()->GetElementClient();

        pCFI->PrepareFancyFormat();

        //
        // Default BORDER COLOR properties.
        //
        pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
        pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);
        pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
        pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);

        //
        //  Default SCROLLING properties
        //
        if (!pBody)
        {            
            // A BODY/FRAMESET does not exist yet.
            // Leave it as not set;
        }
        else if (pBody->Tag() == ETAG_FRAMESET)
        {
            // FRAMESET should always be auto
            pCFI->_ff().SetOverflowX(styleOverflowAuto);
            pCFI->_ff().SetOverflowY(styleOverflowAuto);
        }
        // BODY logic
        else if (   !fSlaveBody
                 && !DocIsDeskTopItem(pDoc)
                 && !(pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_SCROLL_NO | DOCHOSTUIFLAG_DIALOG)))
        {
            switch (((CBodyElement *)pBody)->GetAAscroll())
            {
            case bodyScrollno:
            case bodyScrollyes:
            case bodyScrollauto:
                break;

            default:
                // Body is always horizontal.
                pCFI->_ff().SetOverflowX(styleOverflowAuto);
                pCFI->_ff().SetOverflowY(styleOverflowScroll);
                break;
            }
        }

        pCFI->UnprepareForDebug();
    }

    //  Override with CElement/CSS values.   
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr)
        goto Cleanup;

    if (fHTMLLayout)
    {
        if (IsInViewLinkBehavior(FALSE))
        {
            CElement * pElemMaster = GetMarkup()->Root()->GetMasterPtr();

            Assert(pElemMaster);
            if (pElemMaster->IsInMarkup())
            {
                CTreeNode *             pNode   = pElemMaster->GetFirstBranch();
                const CFancyFormat *    pFF     = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
                const CCharFormat  *    pCF     = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
                BOOL                    fVLF    = pCF->HasVerticalLayoutFlow();
                BOOL                    fWMU    = pCF->_fWritingModeUsed;

                pCFI->PrepareFancyFormat();
                if (!pFF->GetLogicalWidth(fVLF, fWMU).IsNullOrEnum())
                {
                    CUnitValue uv;
                
                    uv.SetPercent(100);
                    pCFI->_ff().SetWidth(uv);
                    pCFI->_ff().SetWidthPercent(TRUE);
                }
                if (!pFF->GetLogicalHeight(fVLF, fWMU).IsNullOrEnum())
                {
                    CUnitValue uv;
                
                    uv.SetPercent(100);
                    pCFI->_ff().SetHeight(uv);
                    pCFI->_ff().SetHeightPercent(TRUE);
                }
                pCFI->UnprepareForDebug();
            }
        }
        else
        {
            pCFI->PrepareFancyFormat();       
            pCFI->_ff().SetHeightPercent(TRUE);
            pCFI->_ff().SetWidthPercent(TRUE);

            //
            // if we are in print preview, and this is the contentbody of
            // a layout rect then we need to make sure scrollbars are turned 
            // off.  (110464)
            if (IsInViewLinkBehavior(TRUE))
            {
                Assert(   GetMarkup()
                       && GetMarkup()->Root()
                       && GetMarkup()->Root()->HasMasterPtr()
                       && GetMarkup()->Root()->GetMasterPtr()->IsLinkedContentElement() 
                       );

                pCFI->_ff().SetOverflowX(styleOverflowVisible);
                pCFI->_ff().SetOverflowY(styleOverflowVisible);
            }

            pCFI->UnprepareForDebug();
        }

    }

    if (    pDoc->_fInHTMLDlg
        &&  GetMarkup()->IsPrimaryMarkup()  )
    {
        // we are in a HTML Dialog, so get its AttrArray to use
        //  in computing our values.
        IUnknown *      pUnkHTMLDlg = NULL;

        hr = THR_NOTRACE(pDoc->QueryService(IID_IHTMLDialog, IID_IUnknown, 
                                (void**)&pUnkHTMLDlg));
        if (hr)
            goto Cleanup;

        if (pUnkHTMLDlg)
        {
            CHTMLDlg *  pHTMLDlg;

            // weak QI
            hr = THR(pUnkHTMLDlg->QueryInterface(CLSID_HTMLDialog, (void**)&pHTMLDlg));
            Assert (!hr && pHTMLDlg);

            CAttrArray **ppAA = pHTMLDlg->GetAttrArray();
            if (ppAA)
            {
                hr = THR(ApplyAttrArrayValues( pCFI, ppAA ));
            }
        }

        ReleaseInterface (pUnkHTMLDlg);
    }

    // set up for potential EMs, ENs, and ES Conversions
    pCFI->PrepareParaFormat();
    pCFI->_pf()._lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(pDoc);
    pCFI->UnprepareForDebug();
  
Cleanup:
    return (hr);
}

//+----------------------------------------------------------
//
//  Member :  OnPropertyChange
//
//  Synopsis  for the HTML element if we get one of the 
//            "interesting" properties changed in its style sheet
//            then if we are in an HTMLDlg that dialog needs to be 
//            notified in order to update its size. the Doc's OPC
//            will do just this.  More accuratly,the doc's OPC calls
//            CServers which does a PropertyNotification to the 
//            sinks, and a HTMLDlg registers a sink to catch this            
//
//-----------------------------------------------------------

HRESULT
CHtmlElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    hr = THR(super::OnPropertyChange( dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    switch(dispid)
    { 
        case DISPID_A_FONT :
        case DISPID_A_FONTSIZE :
        case DISPID_A_FONTWEIGHT :
        case DISPID_A_FONTFACE :
        case DISPID_A_FONTSTYLE :
        case DISPID_A_FONTVARIANT :
        case STDPROPID_XOBJ_TOP : 
        case STDPROPID_XOBJ_LEFT :
        case STDPROPID_XOBJ_WIDTH :
        case STDPROPID_XOBJ_HEIGHT :
        case DISPID_A_DIR :
        case DISPID_A_DIRECTION:
            {
                CMarkup *pMarkup = GetMarkup();
                CDocument *pDocument = NULL;

                if (pMarkup->_fWindowPending)
                    goto Cleanup;

                hr = THR(pMarkup->EnsureDocument(&pDocument));
                if (hr)
                    goto Cleanup;
 
                hr = THR(pDocument->OnPropertyChange(dispid, dwFlags, ppropdesc));
                if (hr)
                    goto Cleanup;
                break;
            }

        case DISPID_BACKCOLOR:
        case DISPID_A_BACKGROUNDIMAGE:
            {   
                CMarkup *pMarkup = GetMarkup();
                CBodyElement * pElement = NULL;

                if (    !pMarkup->IsHtmlLayout()
                    &&  pMarkup->GetBodyElement(&pElement)
                    &&  pElement )                          // Unneccessary: returns S_FALSE                        
                {
                    CLayoutInfo * pLayoutInfo = pElement->GetUpdatedNearestLayoutInfo();
                    if (pLayoutInfo)
                    {
                        pLayoutInfo->OnPropertyChange(dispid, dwFlags);   
                    }
               
                    pElement->Invalidate();
                }
                else
                    Invalidate();
            }


        default:
            break;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     Notify
//
//-------------------------------------------------------------------------

void
CHtmlElement::Notify ( CNotification * pNF )
{
    super::Notify(pNF);

    // When we persist a file out for printing, we stash the original URL in an expando
    // on the HTML element.  Here we pull it out and push over the markup's URL; by spoofing
    // the URL like this, we make things like security checks work based on the original URL.
    switch ( pNF->Type() )
    {
        case NTYPE_ELEMENT_ENTERTREE:
            {
                CMarkup * pMarkup = GetMarkup();
                AssertSz( pMarkup, "Better have a markup, we just entered it!" );

                HRESULT     hr = E_FAIL;
                CVariant    var(VT_EMPTY);
               
                // (greglett) WARNING!
                //            If it ever becomes possible to run scripts in a PrintMedia markup, this is a security hole!
                //            We're spoofing the URL below to pretend like we're the original content document site.
                if ( IsPrintMedia() )
                {
                    AssertSz(pMarkup->DontRunScripts(), "This is a potential security hole!");

                    hr = PrimitiveGetExpando( _T("__IE_DisplayURL"), &var );

                    if ( SUCCEEDED(hr) && (V_VT(&var) == VT_BSTR) )
                    {
                        CMarkup::SetUrl( pMarkup, V_BSTR(&var) );
                        // Since we're spoofing the URL, we need to update our
                        // proxy's security ID too.
                        // TODO (KTam): this only updates the mondo proxy.
                        // If there are other outstanding proxies, they'll just
                        // get access denied errors; we can fix this by a)
                        // ensuring no proxies get handed out before this spoof
                        // (could be hard, depends on timing of script etc) or
                        // b) do this spoof earlier (at markup load time?)
                        // (this involves reworking how we persist print docs
                        // and their associated "real" URLs).
                        pMarkup->UpdateSecurityID();
                    }
                }

                {
                    BOOL fHtmlLayout = pMarkup->IsHtmlLayout();
                    // If we are CSS1 compatible, we should inheriting format like the body used to.
                    // If we expect to run more in CSS1 compatible mode, we should change the default and turn the bit off instead of on.
                    _fInheritFF = fHtmlLayout;

                    //if (fHtmlLayout)
                    //    s_classdesc._pAccels = CHtmlElement::s_AccelsHtmlRun
                }

            }
            break;

        default:
            break;
    }
}

//+-------------------------------------------------------------------
//
//  Method:     CHtmlElement::GetBorderInfo
//
//  Synopsis:   Function to get canvas border info.
//              Should be factored out & accessible from the HTML/(BODY/FRAMESET)
//
//--------------------------------------------------------------------
#define WIDTH_3DBORDER 2

inline void Set3DBorderEdgeInfo(BOOL fNeedBorderEdge, int cEdge,
                CBorderInfo * pborderinfo)
{
    if (fNeedBorderEdge)
    {
        pborderinfo->abStyles[cEdge] = fmBorderStyleSunken;
        pborderinfo->aiWidths[cEdge] = WIDTH_3DBORDER;
    }
}

extern BOOL
ShouldCallGetFrameOptions(CDoc * pDoc, CWindow * pWindow, CMarkup * pMarkup);

DWORD
CHtmlElement::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    if (    IsInViewLinkBehavior( TRUE )
        ||  !GetMarkup()->IsHtmlLayout() )
    {
        return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    }

    DWORD     dwRet = 0;
    CDoc    * pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();

    // TODO (greglett) Simplify this code!  Unify the BODY and FRAMESET rules.

    // Primary element client is a BODY.
    // Use BODY logic to determine border
    // (code originally copied from CBody::GetBorderInfo)
    if (    !pMarkup->GetElementClient()
        ||  pMarkup->GetElementClient()->Tag() == ETAG_BODY)
    {
        CWindow * pWindow = pMarkup->Window() ? pMarkup->Window()->Window() : NULL;

        // if host says no border, then we have no border.
        // if the frame options say no border, we want no border. However (85696) in
        // design mode, if there are no borders, then there is no way to wysiwyg resize
        // and so VS/VID/et. al. want this turned off.  
        if (    ShouldCallGetFrameOptions(pDoc, pWindow, pMarkup)
            &&  (   (pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0)
            &&  (   (pDoc->_dwFlagsHostInfo  & DOCHOSTUIFLAG_NO3DBORDER) == 0
                  || (   pDoc->_fScriptletDoc                                   // a scriptlet doc with an iframe
                      && pMarkup->Root()->HasMasterPtr()                        //    should still have a border on the
                      && pMarkup->Root()->GetMasterPtr()->Tag() == ETAG_IFRAME  //    IFRAME (100612)
                )    )
            &&  pWindow
            &&  !   (   pMarkup->IsPrintMedia()
                    &&  !pWindow->_pWindowParent
            )       )
        {
            // raid 41791 3D border
            // For a (nested) frameset HTML document, Trident will draw 3D border
            // for the top-level frameset (pDocRoot->_pSiteRoot->_pElemClient is
            // a CFrameSetSite), so we don't need to draw 3D border edge(s) if
            // it (they) overlaps with top-level 3D borders.
            //
            BYTE b3DBorder;

            if (!pWindow->_pWindowParent)
            {
                pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                                 | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
            }
            else
                pWindow->_pWindowParent->CheckDoc3DBorder(pWindow);

            b3DBorder = pWindow->_b3DBorder;

            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_TOP) != 0,
                    SIDE_TOP,
                    pborderinfo);
            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_LEFT) != 0,
                    SIDE_LEFT,
                    pborderinfo);
            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_BOTTOM) != 0,
                    SIDE_BOTTOM,
                    pborderinfo);
            Set3DBorderEdgeInfo(
                    (b3DBorder & NEED3DBORDER_RIGHT) != 0,
                    SIDE_RIGHT,
                    pborderinfo);

            pborderinfo->wEdges = BF_RECT;

            // Unless we're the top, add space for the frame highlighting area
            if (pWindow->_pWindowParent)
            {
                pborderinfo->xyFlat = CFrameSetSite::iPixelFrameHighlightWidth;
                pborderinfo->aiWidths[SIDE_TOP]    += pborderinfo->xyFlat;
                pborderinfo->aiWidths[SIDE_RIGHT]  += pborderinfo->xyFlat;
                pborderinfo->aiWidths[SIDE_BOTTOM] += pborderinfo->xyFlat;
                pborderinfo->aiWidths[SIDE_LEFT]   += pborderinfo->xyFlat;
                pborderinfo->acrColors[SIDE_TOP][1]
                        = pborderinfo->acrColors[SIDE_RIGHT][1]
                        = pborderinfo->acrColors[SIDE_BOTTOM][1]
                        = pborderinfo->acrColors[SIDE_LEFT][1]
                        = (pDoc->_state < OS_UIACTIVE)
                                ? GetInheritedBackgroundColor()
                                : RGB(0,0,0); // black, for now
            }
        }

        dwRet = super::GetBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

    }

    // Primary element client is a FRAMESET.
    // Use FRAMESET logic to determine border
    // (code originally copied from CFrameSetSite::GetBorderInfo)
    else
    {
        Assert(GetMarkup()->GetElementClient()->Tag() == ETAG_FRAMESET);
        
        if  (   (   pMarkup == Doc()->PrimaryMarkup()
                 || (   IsInViewLinkBehavior(TRUE)
                     && !IsInViewLinkBehavior(FALSE) ))
             && ((pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0)
             && ((pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NO3DBORDER) == 0))
        {
            // set border style and border space for top-level frameset
            //
            pborderinfo->abStyles[SIDE_TOP]
                    = pborderinfo->abStyles[SIDE_RIGHT]
                    = pborderinfo->abStyles[SIDE_BOTTOM]
                    = pborderinfo->abStyles[SIDE_LEFT]
                    = fmBorderStyleSunken;
            pborderinfo->aiWidths[SIDE_TOP]
                    = pborderinfo->aiWidths[SIDE_RIGHT]
                    = pborderinfo->aiWidths[SIDE_BOTTOM]
                    = pborderinfo->aiWidths[SIDE_LEFT]
                    = 2;
            pborderinfo->wEdges = BF_RECT;
        }

        dwRet = super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

    }

    return dwRet;
}

CBase *
CHtmlElement::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup /* = NULL */)
{
    // Messy.  We want to supply the window/markup if:
    // 1. We are backwards compatible and a BODY/FRAMESET (really should be *primary* BODY/FRAMESET).
    // 2. We are CSS1 strict, a BODY/FRAMESET (should be primary), and is not DISPID_EVPROP_ONSCROLL.
    // 3. We are CSS1 strict, an HTML element, and are DISPID_EVPROP_ONSCROLL
    // If we have to add other events to the list, we should make another static CMarkup fn.  (greglett)
    if (    !pMarkup
        &&  IsInMarkup() )
        pMarkup = GetMarkup();

    if  (   dispID == DISPID_EVPROP_ONSCROLL
        &&  pMarkup
        &&  pMarkup->IsHtmlLayout() )
    {        
        if (pMarkup->HasWindow())
            return pMarkup->Window();       // if we have a window use it 

        // if we have a pending window, we temporarily store these 
        // DISPIDs on the markup and move them onto the window when we switch
        else if (pMarkup->_fWindowPending)
            return pMarkup;
    }

    return this;
}


HRESULT
CHtmlElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;
    BOOL    fExpando = FALSE;;
    CMarkup * pMarkup = GetMarkup();


    if (    !fEnd
        &&  Doc()->_fSaveTempfileForPrinting )
    {
        CVariant cvarProp;
        V_VT(&cvarProp)     = VT_BSTR;
        V_BSTR(&cvarProp)   = SysAllocString(CMarkup::GetUrl(pMarkup));

        fExpando = pMarkup->_fExpando;
        pMarkup->_fExpando = TRUE;
        
        PrimitiveSetExpando(_T("__IE_DisplayURL"), cvarProp);
    }

    hr = THR(super::Save(pStreamWrBuff, fEnd));

    if (    !fEnd
        &&  Doc()->_fSaveTempfileForPrinting )
    {
        WHEN_DBG(HRESULT hrDbg =)  PrimitiveRemoveExpando(_T("__IE_DisplayURL"));
        Assert(!hrDbg);

        pMarkup->_fExpando = fExpando;
    }

    RRETURN1(hr, S_FALSE);
}




//+------------------------------------------------------------------------
//
//  Class:      CHeadElement
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CHeadElement::s_classdesc =
{
    {
        &CLSID_HTMLHeadElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLElement,                  // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLElement,
};


HRESULT
CHeadElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CHeadElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CHeadElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CHeadElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLHeadElement, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Class:      CTitleElement
//
//  Synopsis:   Push new parser specifically for TITLE text
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CTitleElement::s_classdesc =
{
    {
        &CLSID_HTMLTitleElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLTitleElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTitleElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT
CTitleElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CTitleElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

#define ISSPACE(ch) (((ch) == _T(' ')) || ((unsigned)((ch) - 9)) <= 13 - 9)
#define ISNSPAC(ch) (ch && !((ch) == _T(' ')) || ((unsigned)((ch) - 9)) <= 13 - 9)

#if DBG == 1
CTitleElement::~ CTitleElement ( )
{
}
#endif

HRESULT
CTitleElement::SetTitle(TCHAR *pchTitle)
{
    // NOTE (dbau) Netscape doesn't allow document.title to be set!

    // In a <TITLE> tag, Netscape eliminates multiple spaces, etc, as follows:

    HRESULT hr;
    TCHAR pchURLSite[INTERNET_MAX_URL_LENGTH];
    TCHAR *pchTemp = NULL;
    TCHAR *pch;
    TCHAR *pchTo;
    CDoc *  pDoc = Doc();

    IWebBrowser2 *      pWebBrowser = NULL;
    hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
    if (!hr)
    {
        VARIANT_BOOL vfAddressBar = VARIANT_TRUE;
        hr = pWebBrowser->get_AddressBar(&vfAddressBar);
        if (vfAddressBar != VARIANT_TRUE)
        {
            pchTemp = pchURLSite + 2; // Move pointer with 2 positions so we can insert '//' if necessary
            DWORD dw = INTERNET_MAX_URL_LENGTH-6;
            int insertPos = 0;
            if (SUCCEEDED(UrlGetPart(CMarkup::GetUrl(GetMarkup()), pchTemp, &dw, URL_PART_HOSTNAME, URL_PARTFLAG_KEEPSCHEME)) && dw>0)
            {
                // Insert "//" after protocol name
                LPCTSTR protocols[] = {_T("http:"), _T("https:"), _T("ftp:")};
                for (int index=0; index<ARRAY_SIZE(protocols); index++)
                {
                    if (_tcsncicmp(pchTemp, protocols[index],  _tcslen(protocols[index]))==0)
                    {
                        insertPos = _tcslen(protocols[index]);
                        pchTemp = pchURLSite;
                        StringCchCopy(pchTemp, insertPos+1, protocols[index]);
                        pchURLSite[insertPos]=_T('/');
                        pchURLSite[insertPos+1]=_T('/');
                        break;
                    }
                }

                // Put pchURLSite before pchTitle
                if (pchTitle)
                {
                    StringCchCat(pchTemp, INTERNET_MAX_URL_LENGTH - 8, _T(" - "));
                    StringCchCat(pchTemp, INTERNET_MAX_URL_LENGTH - 8, pchTitle);
                }
                pchTitle = pchTemp;
            }
        }
        ReleaseInterface(pWebBrowser);
    }


    if (!pchTitle)
        goto NULLSTR;

    hr = THR(MemAllocString(Mt(CTitleElement), pchTitle, &pchTemp));
    if (hr)
        goto Cleanup;

    pch = pchTo = pchTemp;
    
    // remove leading spaces
    goto LOOPSTART;

    do
    {
        *pchTo++ = _T(' ');
        
LOOPSTART:
        while (ISNSPAC(*pch))
            *pchTo++ = *pch++;

        // remove multiple/trailing spaces
        while (ISSPACE(*pch))
            pch++;
            
    } while (*pch);
    
    *pchTo = _T('\0');

NULLSTR:
    hr = THR(_cstrTitle.Set(pchTemp));
    if (hr)
        goto Cleanup;
    if (IsInMarkup() && GetMarkup()->HasWindow())
    {
        IGNORE_HR(GetMarkup()->Document()->OnPropertyChange(
            DISPID_CDocument_title, SERVERCHNG_NOVIEWCHANGE, (PROPERTYDESC *)&s_propdescCDocumenttitle));
    }
    pDoc->DeferUpdateTitle( GetMarkup() );

Cleanup:
    MemFreeString(pchTemp);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CHeadElement::Save
//
//  Synopsis:   Standard element saver.  Includes hook for saving out
//              additional tags for printing such as BASE and STYLE tag
//
//  Arguments:  pStreamWriteBuff    The stream to write into
//              fEnd                If this is the end tag
//
//-------------------------------------------------------------------------

HRESULT
CHeadElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = THR(super::Save(pStreamWriteBuff, fEnd));
    if (hr || fEnd)
        goto Cleanup;

    if (pStreamWriteBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        if( GetMarkup() )
            hr = THR( GetMarkup()->SaveHtmlHead( pStreamWriteBuff ) );
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTitleElement::Save
//
//  Synopsis:   standard element saver
//
//  Arguments:  pStreamWriteBuff    The stream to write into
//              fEnd                If this is the end tag
//
//-------------------------------------------------------------------------

HRESULT
CTitleElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    DWORD   dwOld;

    // if no title string and synthetic, don't save tags
    if ( _fSynthesized && !_cstrTitle.Length())
        goto Cleanup;

    // Save tagname and attributes.
    hr = THR(super::Save(pStreamWriteBuff, fEnd));
    if (hr)
        goto Cleanup;

    // Tell the write buffer to just write this string
    // literally, without checking for any entity references.
    
    dwOld = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);
    
    // Tell the stream to now not perform any fancy indenting
    // or such stuff.
    pStreamWriteBuff->BeginPre();

    if (!fEnd)
    {
        hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrTitle));
        if (hr)
            goto Cleanup;
    }
        
    pStreamWriteBuff->EndPre();
    pStreamWriteBuff->SetFlags(dwOld);
    
Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Class: CMetaElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CMetaElement::s_classdesc =
{
    {
        &CLSID_HTMLMetaElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLMetaElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLMetaElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CMetaElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CMetaElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CMetaElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CMetaElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLMetaElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CMetaElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;
        
#if 0 // commented out to fix bug 54067: allow meta-http-equiv to work inside the BODY
    if (SearchBranchToRootForTag(ETAG_HEAD))
#endif
    {
        CDoc *  pDoc = Doc();
        LPCTSTR pchHttpEquiv;
        LPCTSTR pchName;
        LPCTSTR pchContent;

        if (    pDoc
            &&  _pAA )
        {
            if(    
                   pContext->_pTargetMarkup && 
                   _pAA->FindString(DISPID_CMetaElement_httpEquiv, &pchHttpEquiv)
               &&  pchHttpEquiv
               &&  pchHttpEquiv[0]
               &&  _pAA->FindString(DISPID_CMetaElement_content, &pchContent)
               &&  pchContent)
            {
                pContext->_pTargetMarkup->ProcessHttpEquiv(pchHttpEquiv, pchContent);
            }
            else if (    _pAA->FindString(DISPID_CMetaElement_name, &pchName)
                     &&  pchName
                     &&  pchName[0]
                     &&  _pAA->FindString(DISPID_CMetaElement_content, &pchContent)
                     &&  pchContent)
            {
                pDoc->ProcessMetaName(pchName, pchContent);
            }

        }
    }

Cleanup:
    RRETURN(hr);
}

static BOOL LocateCodepageMeta ( CMetaElement * pMeta )
{
    return pMeta->IsCodePageMeta();
}

HRESULT
CMetaElement::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    CMetaElement * pMeta;

    // NOTE: (jbeda) It looks like the intention of this code is that when the
    //       WBF_NO_CHARSET_META flag is specified that codepage meta tags not
    //       be saved.  Instead, it looks like there is an issue with the parens
    //       where no meta tage will be saved in this case.  This is only used
    //       right now for saving to the clipboard and printing (I think) so it
    //       isn't worth risking to change it.

    // NOTE: (jbeda) When saving for treesync we don't want to do the head
    //       search as the tree may be in a wacky state so just always save this
    //       guy out.

    if (    IsCodePageMeta() 
        &&  (   !pStmWrBuff->TestFlag( WBF_FOR_TREESYNC ) 
            &&  IsInMarkup() 
            &&  GetMarkup()->LocateHeadMeta(LocateCodepageMeta, &pMeta) == S_OK 
            &&  pMeta != this )
        ||  pStmWrBuff->TestFlag(WBF_NO_CHARSET_META) )
    {
        // Only write out the first charset meta tag in the head
        return S_OK;
    }

    return super::Save(pStmWrBuff, fEnd);
}

BOOL
CMetaElement::IsCodePageMeta( )
{
    return ( GetAAhttpEquiv() && !StrCmpIC(GetAAhttpEquiv(), _T("content-type")) &&
             GetAAcontent()) || 
             GetAAcharset();
}

CODEPAGE
CMetaElement::GetCodePageFromMeta( )
{
    if( GetAAhttpEquiv() && StrCmpIC( GetAAhttpEquiv( ), _T("content-type") ) == 0 &&
        GetAAcontent() )
    {
        // Check if we are of the form:
        //  <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=xxx">
        return CodePageFromString( (LPTSTR) GetAAcontent(), TRUE );
    }
    else if ( GetAAcharset() )
    {
        // Check if we are either:
        //  <META HTTP-EQUIV CHARSET=xxx> or <META CHARSET=xxx>
        return CodePageFromString( (LPTSTR) GetAAcharset(), FALSE );
    }

    // Either this meta tag does not specify a codepage, or the codepage specified
    //  is unrecognized.
     return CP_UNDEFINED;
}

//+----------------------------------------------------------------------------+
//
// IsGalleryMeta:
//      returns
//      true  : if <META Name="ImageToolbar" CONTENT="yes">
//      false : if <META Name="ImageToolbar" CONTENT="no">
//      true  : otherwise
//
//+----------------------------------------------------------------------------+
 
BOOL
CMetaElement::IsGalleryMeta()
{
    if(     GetAAname()
        &&  StrCmpIC(GetAAname(), _T("ImageToolbar")) == 0
        &&  GetAAcontent()
        &&  StrCmpIC(GetAAcontent(), _T("No")) == 0)
    {
            return FALSE;
    }
    return TRUE;
} 

//+----------------------------------------------------------------------------+
//
// TestThemeMeta:
//      returns
//      1 : if <META HTTP-EQUIV="MSThemeCompatible" CONTENT="yes">
//      0 : if <META HTTP-EQUIV="MSThemeCompatible" CONTENT="no">
//     -1 : otherwise
//
//+----------------------------------------------------------------------------+

int
CMetaElement::TestThemeMeta( )
{
    if(     GetAAhttpEquiv()
        &&  StrCmpIC( GetAAhttpEquiv( ), _T("MSThemeCompatible") ) == 0
        &&  GetAAcontent())
    {
        if (StrCmpIC( GetAAcontent( ), _T("Yes") ) == 0)
        {
            return 1;
        }
        else if (StrCmpIC( GetAAcontent( ), _T("No") ) == 0)
        {
            return 0;
        }
    }
    return -1;
}
       
BOOL
CMetaElement::IsPersistMeta(long eState)
{
    BOOL fRes = FALSE;

    if (GetAAname() &&  GetAAcontent() &&
            (StrCmpNIC(GetAAname(), 
                        PERSISTENCE_META, 
                        ARRAY_SIZE(PERSISTENCE_META))==0))
    {
        int         cchNameLen = 0;
        LPCTSTR     pstrNameStart = NULL;
        CDataListEnumerator   dleContent(GetAAcontent(), _T(','));


        // for each name token in the content string check to see if
        //   it specifies the persistence type we are intereseted in
        while (dleContent.GetNext(&pstrNameStart, &cchNameLen))
        {
            switch (eState)
            {
            case 1:     // favorite
                fRes = (0 == _tcsnicmp(_T("favorite"), 8, (LPTSTR)pstrNameStart, cchNameLen));
                break;
            case 2:     // History
                fRes = (0 == _tcsnicmp(_T("history"), 7, (LPTSTR)pstrNameStart, cchNameLen));
                break;
            case 3:     // Snapshot
                fRes = (0 == _tcsnicmp(_T("snapshot"), 8, (LPTSTR)pstrNameStart, cchNameLen));
                break;
            default:
                fRes = FALSE;
                break;
            }

            // if we still don't have it, give the "all" type a chance
            if (!fRes)
                fRes = (0 == _tcsnicmp(_T("all"), 3, (LPTSTR)pstrNameStart, cchNameLen));
        }

    }

    return fRes;
}

HRESULT
CMetaElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    if( dispid == DISPID_CMetaElement_content &&
        IsCodePageMeta() )
    {
        CODEPAGE cp = GetCodePageFromMeta();

        if( cp != CP_UNDEFINED )
        {
            // TODO (johnv) What should we do when we get this message?
        }
    }

    hr = THR(super::OnPropertyChange( dispid, dwFlags, ppropdesc ));
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Class: CBaseElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CBaseElement::s_classdesc =
{
    {
        &CLSID_HTMLBaseElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBaseElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBaseElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBaseElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CBaseElement(pht->GetTag(), pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

HRESULT SetUrlDefaultScheme(const TCHAR *pchHref, CStr *pStr)
{
    HRESULT hr = S_OK;
    TCHAR achQualifiedHref[pdlUrlLen];
    DWORD cchQualifiedHref = ARRAY_SIZE(achQualifiedHref);

    if (pchHref)
    {
        hr = UrlApplyScheme(pchHref, achQualifiedHref, &cchQualifiedHref,
            URL_APPLY_GUESSSCHEME | URL_APPLY_GUESSFILE | URL_APPLY_DEFAULT);
    }

    if (hr || !pchHref)
        hr = THR(pStr->Set(pchHref));
    else
        hr = THR(pStr->Set(achQualifiedHref));

    RRETURN(hr);
}

HRESULT
CBaseElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    hr = SetUrlDefaultScheme(GetAAhref(), &_cstrBase);

Cleanup:
    RRETURN(hr);
}

void
CBaseElement::Notify( CNotification * pNF )
{
    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        // we might be in the head...tell doc to look
        Doc()->_fHasBaseTag = TRUE;

        // only send the notification when the element is entering 
        // because of non-parsing related calls
        if ( !(pNF->DataAsDWORD() & ENTERTREE_PARSE) )
            BroadcastBaseUrlChange();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if ( !(pNF->DataAsDWORD() & EXITTREE_DESTROY) )
            BroadcastBaseUrlChange();
        break;
    }
}

HRESULT
CBaseElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    if (dispid == DISPID_CBaseElement_href)
    {
        hr = SetUrlDefaultScheme(GetAAhref(), &_cstrBase);
        if (hr)
            goto Cleanup;

        // send notification to the descendants, if we
        // are in a markup
        if ( IsInMarkup() )
            BroadcastBaseUrlChange();
    }

    hr = super::OnPropertyChange(dispid, dwFlags, ppropdesc);

Cleanup:
    RRETURN(hr);
}

void 
CBaseElement::BroadcastBaseUrlChange( )
{
    CNotification   nf;
    CDoc *          pDoc = Doc();

    // send the notification to change non-cached properties.
    SendNotification( NTYPE_BASE_URL_CHANGE );
        
    // Force a re-render
    THR(pDoc->ForceRelayout() );

    // and force recomputing behavior on the markup that contains this 
    // base element.
    nf.RecomputeBehavior( MarkupRoot() );
    
    pDoc->BroadcastNotify(&nf);
}


//+------------------------------------------------------------------------
//
//  Class: CIsIndexElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CIsIndexElement::s_classdesc =
{
    {
        &CLSID_HTMLIsIndexElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLIsIndexElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLIsIndexElement,    // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CIsIndexElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CIsIndexElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CIsIndexElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CIsIndexElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLIsIndexElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Class: CNextIdElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CNextIdElement::s_classdesc =
{
    {
        &CLSID_HTMLNextIdElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLNextIdElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLNextIdElement,     // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CNextIdElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CNextIdElement(pDoc);
    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\inplace.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inplace.cxx
//
//  Contents:   CDoc implementation (partial)
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef UNIX
#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_BOOKMARK_HXX_
#define X_BOOKMARK_HXX_
#include "bookmark.hxx"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DRAGDROP_HXX_
#define X_DRAGDROP_HXX_
#include "dragdrop.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

EXTERN_C const GUID SID_SMenuBandHandler;

//TODO : (chandras 05/25/1999) As edit resources are not in common place, this needs to be done
//       when they are moved to a commonplace, this needs to be removed
#ifndef IDS_EDUNDODRAGDROP
#define IDS_EDUNDODRAGDROP 2009
#endif 

#define SCROLLPERCENT   125

ATOM GetWndClassAtom(UINT uIndex);

UINT   g_msgMouseWheel  = 0;

EXTERN_C const CLSID CLSID_HTMLDialog;

#ifndef NO_IME
extern HRESULT ActivateDIMM(); // imm32.cxx
extern HRESULT FilterClientWindowsDIMM(ATOM *aaWindowClasses, UINT uSize);
#endif // ndef NO_IME

CLayout * GetLayoutForDragDrop(CElement * pElement); // defined below

DeclareTagOther(tagFirstTimeTab, "Currency", "Enable IE FirstTime Tab")

//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureInPlaceObject, CServer
//
//  Synopsis:   Creates the InPlace object when needed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

HRESULT
CDoc::EnsureInPlaceObject()
{
    if (!_pInPlace)
    {
        _pInPlace = new CFormInPlace();
        if (!_pInPlace)
            RRETURN(E_OUTOFMEMORY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormInPlace::~CFormInplace
//
//  Synopsis:   Cleanup before destruction.
//
//----------------------------------------------------------------------------

CFormInPlace::~CFormInPlace()
{
    // Make sure we have released all window resources.
    ClearInterface(&_pHostShowUI);
}


HRESULT
CDoc::OnSelectChange(void)
{
    if (_state != OS_UIACTIVE)
        return S_OK;

    HRESULT                         hr = S_OK;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     FormOverlayWndProc
//
//  Synopsis:   Transparent window for use during drag-drop.
//
//-------------------------------------------------------------------------

static LRESULT CALLBACK
FormOverlayWndProc(HWND hWnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm)
    {
    case WM_PAINT:
        {
            PAINTSTRUCT     ps;
            BeginPaint(hWnd, &ps);
            EndPaint(hWnd, &ps);
        }
        return 0;

    case WM_ERASEBKGND:
        return TRUE;

    default:
        return DefWindowProc(hWnd, wm, wParam, lParam);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::CreateOverlayWindow
//
//  Synopsis:   Creates a transparent window for use during drag-drop.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HWND
CDoc::CreateOverlayWindow(HWND hwndCover)
{
    Assert(_pInPlace->_hwnd);
    HWND hwnd;
    TCHAR * pszBuf;

    if (!GetWndClassAtom(WNDCLASS_OVERLAY))
    {
        HRESULT     hr;

        hr = THR(RegisterWindowClass(
                WNDCLASS_OVERLAY,
                FormOverlayWndProc,
                CS_DBLCLKS,
                NULL, 
                NULL));
        if (hr)
            return NULL;
    }

#if defined(WIN16) || defined(_MAC)
    TCHAR szBuf[128];
    GlobalGetAtomName(GetWndClassAtom(WNDCLASS_OVERLAY), szBuf, ARRAY_SIZE(szBuf));
    pszBuf = szBuf;
#else
    pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_OVERLAY);
#endif


    // TODO (garybu) Overlay window should be same size as hwndCover and
    // just above it in the zorder.

    hwnd = CreateWindowEx(
            WS_EX_TRANSPARENT,
            pszBuf,
            NULL,
            WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
            0, 0,
            SHRT_MAX / 2, SHRT_MAX / 2,
            _pInPlace->_hwnd,
            0,
            g_hInstCore,
            this);
    if (!hwnd)
        return NULL;

    SetWindowPos(
            hwnd,
            HWND_TOP,
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    return hwnd;
}


//+---------------------------------------------------------------
//
//  Member:    CDoc::AttachWin
//
//  Synopsis:  Create our InPlace window
//
//  Arguments: [hwndParent] -- our container's hwnd
//
//  Returns:   hwnd of InPlace window, or NULL
//
//---------------------------------------------------------------

HRESULT
CDoc::AttachWin(HWND hwndParent, RECT * prc, HWND * phwnd)
{
    HRESULT     hr = S_OK;
    HWND        hwnd = NULL;
    const DWORD STYLE_ENABLED = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    //  Note: this code is duplicated in CServer::AttachWin.

    if (!GetWndClassAtom(WNDCLASS_SERVER))
    {
        hr = THR(RegisterWindowClass(
                WNDCLASS_SERVER,
                CServer::WndProc,
                CS_DBLCLKS,
                NULL, NULL));

        if (hr)
        {
            WHEN_DBG(GetLastError());
            AssertSz(0, "RegisterWindowClass for server failed");
            goto Cleanup;
        }

#ifndef NO_IME
        // if dimm is installed, we only want ime interaction with the server class
        ATOM atomWndClass = GetWndClassAtom(WNDCLASS_SERVER);
        FilterClientWindowsDIMM(&atomWndClass, 1);
#endif // ndef NO_IME
    }

    Assert(phwnd);

    if (_hwndCached)
    {
        hwnd = _hwndCached;
        _hwndCached = NULL; // this is necessary because if the window is destroyed later by WM_DESTROY,
                            // which we don't intercept, then _hwndCached should not be != NULL
        if (SetParent (hwnd, hwndParent))
        {
            UINT uiSWPFlags = (_fPopupDoc ? SWP_NOACTIVATE : 0) | SWP_SHOWWINDOW | SWP_NOREDRAW;
            _pInPlace->_hwnd = hwnd;
            PrivateAddRef();
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(CServer *) this); // connect this CDoc to the window
                                                                 // NOTE the cast to CServer for WIN16
            SetWindowPos (
                hwnd,
                HWND_TOP,
                prc->left, prc->top,
                prc->right - prc->left, prc->bottom - prc->top,
                uiSWPFlags);
        }
        else
        {
            DestroyWindow(hwnd);
            hwnd = NULL; // this will cause it to create new window
        }
    }

    if (!hwnd)
    {
        TCHAR * pszBuf;
        TCHAR achClassName[256];

        DWORD dwExStyle = 0;
        DWORD dwStyle = STYLE_ENABLED;

        if (_fPopupDoc)
        {
            dwExStyle   |=  WS_EX_TOPMOST
                          | WS_EX_TOOLWINDOW
                          | WS_EX_NOPARENTNOTIFY;

            dwStyle     |=  WS_POPUP
                          | WS_CLIPCHILDREN;
        }

#ifdef WIN16
        char szBuf[128];
        GlobalGetAtomName(GetWndClassAtom(WNDCLASS_SERVER), szBuf, ARRAY_SIZE(szBuf));
        pszBuf = szBuf;
#else
        pszBuf = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_SERVER);
#endif

        hwnd = CreateWindowEx(
                dwExStyle,
                pszBuf,
                NULL,
                dwStyle,
                prc->left, prc->top,
                prc->right - prc->left, prc->bottom - prc->top,
                hwndParent,
                0,              // no child identifier - shouldn't send WM_COMMAND
                g_hInstCore,
                (CServer *)this);

        ::GetClassName(hwndParent, achClassName, ARRAY_SIZE(achClassName));
        _fVB = (StrCmpIW(achClassName, _T("HTMLPageDesignerWndClass")) == 0) ? TRUE : FALSE;
    }

    if (!hwnd)
        goto Win32Error;

    // Lazily register/revoke drag-drop
#ifndef NO_DRAGDROP
    IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CDoc, EnableDragDrop, enabledragdrop), 0, FALSE, "CDoc::EnableDragDrop"));
#endif // NO_DRAGDROP

#ifndef WIN16
#ifndef NO_IME
    // if DIMM is installed, activate it
    ActivateDIMM();
#endif // ndef NO_IME

    if (g_msgMouseWheel == 0 && GetVersion() >= 0x80000000)
    {
        // special for Windows 95, equivalent to WM_MOUSEWHEEL
        //
        g_msgMouseWheel = RegisterWindowMessage(_T("MSWHEEL_ROLLMSG"));
    }

    // Initialize our _wUIState from the window.
    // TODO: do we need to clear formats here? (jbeda)
    if (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
    {
        _wUIState = SendMessage(hwnd, WM_QUERYUISTATE, 0, 0);
    }
#endif // ndef WIN16

    //
    // We need to give editor a chance to initialize DIMM 
    // if it has already been created. 
    //
    if (GetHTMLEditor(FALSE))
    {
        IGNORE_HR( NotifySelection(EDITOR_NOTIFY_ATTACH_WIN, this) );
    }
Cleanup:
    *phwnd = hwnd;

    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    DetachWin();
    goto Cleanup;
}

//+---------------------------------------------------------------
//
// Local Helper: IsInIEBrowser
//
// Synopsis: Determine if Trident is in IE browser
//
//----------------------------------------------------------------
BOOL
IsInIEBrowser(CDoc * pDoc)
{
    BOOL             fResult     = FALSE;
    IOleClientSite * pClientSite = pDoc->_pClientSite;
    IUnknown         * pUnk2 = NULL;
    
    if ((!(pDoc->DesignMode()))
            && ((pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG) == 0)
            && (pClientSite))
    {
        HRESULT hr;
        IServiceProvider * psp1, * psp2;
        IUnknown         * pUnk;


        hr = pClientSite->QueryInterface(IID_IServiceProvider, (void **) &psp1);
        if (!hr && psp1)
        {
            hr = psp1->QueryService(
                    SID_STopLevelBrowser,
                    IID_IServiceProvider,
                    (void **) &psp2);

                                   
            if (!hr && psp2)
            {                    
                hr = psp2->QueryInterface(SID_SShellDesktop, (void **) &pUnk);
                if (!hr && pUnk)
                    pUnk->Release();
                else
                {
                    hr = psp2->QueryService( SID_SMenuBandHandler, IID_IUnknown, (void**) & pUnk2 );
                    if ( SUCCEEDED( hr ))
                        fResult = TRUE;
#if DBG == 1                        
                    else if (IsTagEnabled(tagFirstTimeTab))
                    {
                        fResult = TRUE;
                    }
#endif                    
                    ReleaseInterface( pUnk2 );                        
                }    
                psp2->Release();
            }
            psp1->Release();
        }
    }
    
    return fResult;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RunningToInPlace
//
//  Synopsis:   Effects the running to inplace-active state transition
//
//  Returns:    SUCCESS if the object results in the in-place state
//
//  Notes:      This method in-place activates all inside-out embeddings
//              in addition to the normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::RunningToInPlace(LPMSG lpmsg)
{
    HRESULT         hr;
    CNotification   nf;

    TraceTag((tagCDoc, "%lx CDoc::RunningToInPlace", this));

    _fFirstTimeTab = IsInIEBrowser(this);
    
    _fInPlaceActivating = TRUE;
    _fEnableInteraction = TRUE;

    //  Do the normal transition, creating our main window

    hr = THR(CServer::RunningToInPlace(lpmsg));
    if (hr)
        goto Cleanup; // Do not goto error because CServer has already
                      // performed all necessary cleanup.

    // Make sure that we have a current element before we set focus to one.
    // If we are parse done, and just becoming inplace, then we don't have an
    // active element yet.
    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)	
        DeferSetCurrency(0);    

    //
    // Prepare the view
    //
    _view.Activate();
    {
        SIZE    sizeDst;
        sizeDst.cx = _pInPlace->_rcPos.right  - _pInPlace->_rcPos.left;
        sizeDst.cy = _pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top;
        if (sizeDst.cx == 0) sizeDst.cx = 1;
        if (sizeDst.cy == 0) sizeDst.cy = 1;
        _view.SetViewSize(sizeDst);
    }
    _view.SetFocus(_pElemCurrent, _lSubCurrent);

    //
    // Look for IDocHostShowUI
    //

    Assert(!InPlace()->_pHostShowUI);

    // first look on the DocHostUIHandler
    // If the handler is imposed on us through ICustomDoc,
    //   it has already happened
    // If we use CSmartDocHostUIHandler, it will also
    //   pass IDocHostShowUI calls to the super site.
    if(_pHostUIHandler)
    {
        hr = THR_NOTRACE(_pHostUIHandler->QueryInterface(
                                                IID_IDocHostShowUI,
                                                (void **)&(InPlace()->_pHostShowUI)));
        if(hr != S_OK)
        {
            InPlace()->_pHostShowUI = NULL;
        }
    }

    // next look on the client site
    if(_pClientSite && !InPlace()->_pHostShowUI)
    {
        hr = THR_NOTRACE(_pClientSite->QueryInterface(
                                           IID_IDocHostShowUI,
                                           (void **)&(InPlace()->_pHostShowUI)));
        if(hr != S_OK)
        {
            InPlace()->_pHostShowUI = NULL;
        }
    }

    // not having a DocHostShowUI is not a failing condition for this function
    hr = S_OK;

    //
    // Make sure that everything is laid out correctly
    // *before* doing the BroadcastNotify because with olesites,
    // we want to baseline them upon the broadcast.  When doing this,
    // we better know the olesite's position.
    //

    _view.EnsureView(LAYOUT_SYNCHRONOUS);

    nf.DocStateChange1(PrimaryRoot(), (void *)OS_RUNNING);
    BroadcastNotify(&nf);

    if (LoadStatus() >= LOADSTATUS_PARSE_DONE)
    {
        // Now is the time to ask the sites to load any history
        // that they could not earlier (e.g. scroll/caret positions
        // because they require the doc to be recalced, the site
        // arrays built, etc.)
        CMarkup * pMarkupPrimary = PrimaryMarkup();
        CMarkupTransNavContext * ptnc;
        if (    pMarkupPrimary 
            &&  pMarkupPrimary->HasTransNavContext() 
            &&  (ptnc = pMarkupPrimary->GetTransNavContext())->_fDoDelayLoadHistory)
        {
            CNotification   nf;
            
            // TODO: (jbeda) We need to do this for ALL markups 
            // -- not just the primary
            ptnc->_fDoDelayLoadHistory = FALSE;
            pMarkupPrimary->EnsureDeleteTransNavContext(ptnc);

            nf.DelayLoadHistory(pMarkupPrimary->Root());
            BroadcastNotify(&nf);
        }
    }

#if DBG == 1
    DisplayChildZOrder(_pInPlace->_hwnd);
#endif

    //
    // Show document window *after* all child windows have been
    // created, to reduce clipping region recomputations.  To avoid
    // WM_ERASEBKGND sent outside of a WM_PAINT, we show without
    // redraw and then invalidate.
    //

    SetWindowPos(_pInPlace->_hwnd, NULL, 0, 0, 0, 0,
            SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE |
            SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);

    // Unblock any script execution/parsing that was waiting for inplace activation
    NotifyMarkupsInPlace();

    // If we have a task to look for a certain scroll position, make sure
    // we have recalc'd at least to that point before display.

    // Supress scrollbits because we're about to inval the entire window
    PrimaryMarkup()->NavigateNow(FALSE);

    // This inval does nothing if LoadStatus() < LOADSTATUS_INTERACTIVE
    Invalidate(NULL, NULL, NULL, INVAL_CHILDWINDOWS);

    // run scripts if not in  mode
    if (!DesignMode())
    {
        if (LoadStatus() >= LOADSTATUS_DONE)
        {
            CScriptCollection * pScriptCollection = PrimaryMarkup()->GetScriptCollection();

            if (pScriptCollection)
            {
                hr = THR(pScriptCollection->SetState(SCRIPTSTATE_CONNECTED));
                if (hr)
                    goto Error;
            }

            if (!_pWindowPrimary->_fFiredOnLoad)
            {
                _pWindowPrimary->_fFiredOnLoad = TRUE;

                {
                    CDoc::CLock Lock(this);

                    if (    CMarkup::HtmCtxHelper(PrimaryMarkup())
                        && !(CMarkup::HtmCtxHelper(PrimaryMarkup())->GetState() & (DWNLOAD_ERROR | DWNLOAD_STOPPED)))
                    {
                        // these memberdata will only be here if a peer was present to put them
                        // there.  thus we don't need to check for _fPeersPossible
                        CMarkupBehaviorContext * pContext = NULL;

                        hr = THR(PrimaryMarkup()->EnsureBehaviorContext(&pContext));
                        if (hr)
                            goto Cleanup;

                        if ( pContext->_cstrHistoryUserData || _pShortcutUserData)
                            PrimaryMarkup()->FirePersistOnloads();

                        _pWindowPrimary->Fire_onload();
                    }

                    // Let the client site know we are loaded
                    // Only HTMLDialog pays attention to this
                    if (_pClientSite && _fInHTMLDlg)
                    {
                        CTExec(_pClientSite, &CLSID_HTMLDialog,
                               0, 0, NULL, NULL);
                    }
                }
            }
        }
    }

    RefreshStatusUI();
    DeferUpdateUI();

Cleanup:

    _fInPlaceActivating = FALSE;
    RRETURN(hr);

Error:

    IGNORE_HR(InPlaceToRunning());
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::InPlaceToRunning
//
//  Synopsis:   Effects the inplace-active to running state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//  Notes:      This method in-place deactivates all inside-out embeddings
//              in addition to normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::InPlaceToRunning(void)
{
    HRESULT             hr = S_OK;
    CNotification       nf;
    CScriptCollection * pScriptCollection;

    TraceTag((tagCDoc, "%lx CDoc::InPlaceToRunning", this));
    {
        CElement *pElemFireTarget;
        pElemFireTarget = _pElemCurrent->GetFocusBlurFireTarget(_lSubCurrent);
        Assert(pElemFireTarget);

        CElement::CLock LockUpdate(pElemFireTarget, CElement::ELEMENTLOCK_UPDATE);
        _fInhibitFocusFiring = TRUE;

        if (pElemFireTarget->IsInMarkup())
        {
            IGNORE_HR(pElemFireTarget->RequestYieldCurrency(TRUE));
        }

        if (pElemFireTarget->IsInMarkup())
        {
            hr = THR(pElemFireTarget->YieldCurrency(_pElementDefault));
            if (hr)
                goto Cleanup;

            if (!TestLock(FORMLOCK_CURRENT))
            {
                Assert(pElemFireTarget == _pElemCurrent || pElemFireTarget->Tag() == ETAG_AREA);
                pElemFireTarget->Fire_onblur(0);
            }
        }
        _fInhibitFocusFiring = FALSE;
    }

    if (_pElemUIActive)
    {
        _pElemUIActive->YieldUI(PrimaryRoot());
    }
    _pElemCurrent = _pElemUIActive = PrimaryRoot();

    SetMouseCapture (NULL, NULL);

    // stop scripts if not in design mode
    
    _pWindowPrimary->Window()->CleanupScriptTimers();

    if (_pWindowPrimary->_fFiredOnLoad)
    {
        _pWindowPrimary->_fFiredOnLoad = FALSE;
        {
            CDoc::CLock Lock(this);
            _pWindowPrimary->Fire_onunload();
        }
    }

    //
    // Shutdown the view
    //

    hr = THR(CServer::InPlaceToRunning());

    //
    // if we are a popup restore the _pDT of our parent
    //
    if (_fPopupDoc && _pHostUIHandler)
    {
        IDropTarget *   pDTOut = NULL;
        if (!_pHostUIHandler->GetDropTarget(_pPopupParentWindow->Doc()->_pDT, &pDTOut))
        {
            ReleaseInterface(pDTOut);
        }
    }

    ClearInterface(&_pDT);


    //
    // Clear these variables so we don't stumble over stale
    // values should we be inplace activated again.
    //

    FormsKillTimer(this, TIMER_ID_MOUSE_EXIT);
    _fMouseOverTimer = FALSE;
    if (_pNodeLastMouseOver)
    {
        CTreeNode * pNodeRelease = _pNodeLastMouseOver;
        _pNodeLastMouseOver = NULL;
        pNodeRelease->NodeRelease();
    }

    nf.DocStateChange1(PrimaryRoot(), (void *)OS_INPLACE);
    BroadcastNotify(&nf);

    _view.Deactivate();

    pScriptCollection = PrimaryMarkup()->GetScriptCollection();
    if (pScriptCollection)
    {
        pScriptCollection->SetState(SCRIPTSTATE_DISCONNECTED);
    }


Cleanup:

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InPlaceToUIActive, public
//
//  Synopsis:   Overridden helper method in CServer.  Called when we
//              transition from InPlace to UIActive.
//
//  Returns:    HRESULT
//
//  Notes:      If the form is in run mode, then the first control on the
//              tab-stop list is UI Activated in leu of the form.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::InPlaceToUIActive(LPMSG lpmsg)
{
    HRESULT         hr  = S_OK;
    CNotification   nf;

    //
    // Try to get into the UI active state by UI activating
    // a contained site. If this works, CServer::InPlaceToUIActivate
    // will be called from CDoc::SetUIActiveSite.  Do this as long as
    // a child within us is not activating.
    //

    if (!_pInPlace->_fChildActivating)
    {
        if (_fDefView && !_fActiveDesktop && _pInPlace->_hwnd)
        {
            // Bring to top of z-order (fix for #77063)
            // Ideally, we would like to bring ourselves to the top
            // always, but this would break ActiveDesktop! They keep us behind the
            // transparent ListView which contains the desktop icons.
            SetWindowPos(
                    _pInPlace->_hwnd,
                    HWND_TOP,
                    0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }

        if (_pElemCurrent != PrimaryRoot())
        {
            hr = THR(_pElemCurrent->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
        }
        else
        {
            ActivateFirstObject(lpmsg);
        }
    }


    // If we couldn't get a site to activate, then activate the document.

    if (_state != OS_UIACTIVE && !_fIsPrintWithNoUI)
    {
        hr = THR(CServer::InPlaceToUIActive(lpmsg));
    }

    _view.SetFocus(_pElemCurrent, _lSubCurrent);

    // Tell the caret to update
    if( _pCaret )
        _pCaret->DeferredUpdateCaret((DWORD_PTR) this);

    IGNORE_HR(OnSelectChange());
    
    if (_fHasOleSite)
    {
        nf.DocStateChange1(PrimaryRoot(), (void *)OS_INPLACE);
        Assert( nf.Element() );
        BroadcastNotify(&nf);
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::UIActiveToInPlace
//
//  Synopsis:   Effects the U.I. active to inplace-active state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//  Notes:      This method U.I. deactivates any U.I. active embedding
//              in addition to normal CServer base processing.
//
//---------------------------------------------------------------

HRESULT
CDoc::UIActiveToInPlace()
{
    HRESULT         hr;
    CNotification   nf;
    
    //
    //  Tell the editor to lose focus
    //

    hr = THR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS, NULL ));

    _state = OS_INPLACE;

    if (_fHasOleSite)
    {
        nf.DocStateChange1(PrimaryRoot(), (void *)OS_UIACTIVE);
        BroadcastNotify(&nf);
    }

    _view.SetFocus(NULL, 0);
    
    //  Clear ourselves as the active selection container

    hr = THR(CServer::UIActiveToInPlace());

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DragEnter, IDropTarget
//
//  Synopsis:   Setup for possible drop
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::DragEnter(
        IDataObject * pDataObj,
        DWORD         grfKeyState,
        POINTL        ptlScreen,
        DWORD *       pdwEffect)
{
#ifdef UNIX
    if (_dwTID != GetCurrentThreadId())
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
#endif

    _fRightBtnDrag = (grfKeyState & MK_RBUTTON) ? 1 : 0;

    HRESULT hr = CServer::DragEnter(pDataObj, grfKeyState, ptlScreen, pdwEffect);
    if (hr)
    {
        RRETURN(hr);
    }

    TCHAR pUndoTitle[ 256 ];
    hr = THR( GetEditingString( IDS_EDUNDODRAGDROP, pUndoTitle ));
    if ( hr )
    {
        RRETURN( hr );
    }
    BeginUndoUnit(pUndoTitle);

    Assert(!_pDragDropTargetInfo);
    _pDragDropTargetInfo = new CDragDropTargetInfo( this );
    if (!_pDragDropTargetInfo)
        return E_OUTOFMEMORY;

    RRETURN(THR(DragOver(grfKeyState, ptlScreen, pdwEffect)));
}

CLayout *
GetLayoutForDragDrop(CElement * pElement)
{
    CLayout * pLayout = pElement->GetUpdatedLayout();

    // Handle slaves
    if (!pLayout && pElement->HasMasterPtr())
    {
        pLayout = pElement->GetMasterPtr()->GetUpdatedLayout();
    }
    return pLayout;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DragOver, IDropTarget
//
//  Synopsis:   Handle scrolling and dispatch to site.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::DragOver(DWORD grfKeyState, POINTL ptScreen, DWORD *pdwEffect)
{

    HRESULT     hr              = S_OK;
    POINT       pt;
    CTreeNode * pNodeElement    = NULL;
    DWORD       dwLoopEffect;
    CMessage    msg;
    DWORD       dwScrollDir     = 0;
    BOOL        fRedrawFeedback;
    BOOL        fRet;
    BOOL        fDragEnter;

    Assert(_pInPlace->_pDataObj);

    if (!_pDragDropTargetInfo)
    {
        AssertSz(0, "DragDropTargetInfo is NULL. Possible cause - DragOver called without calling DragEnter");
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    // Cache for possible use in CDoc::Drop.  See comment there.
    _pDragDropTargetInfo->_dwLastKeyState = grfKeyState;
    
    pt = *(POINT *)&ptScreen;
    ScreenToClient(_pInPlace->_hwnd, &pt);

    msg.pt = pt;
    HitTestPoint(&msg, &pNodeElement, HT_IGNOREINDRAG);
    if ( !pNodeElement )
        goto Cleanup;
        
    // Point to the content
    if (pNodeElement->Element()->HasSlavePtr())
    {
        pNodeElement = pNodeElement->Element()->GetSlavePtr()->GetFirstBranch();
    }

    // We should not change pdwEffect unless DragEnter succeeded, and always call
    // DragEnter with the original effect
    dwLoopEffect = *pdwEffect;

    if (pNodeElement->Element() != _pDragDropTargetInfo->_pElementHit)
    {
        fDragEnter = TRUE;
        _pDragDropTargetInfo->_pElementHit = pNodeElement->Element();
    }
    else
        fDragEnter = FALSE;

    while (pNodeElement)
    {
        CLayout * pLayout = GetLayoutForDragDrop(pNodeElement->Element());

        hr = THR( pNodeElement->NodeAddRef() );
        if( hr )
            goto Cleanup;

        //  Bug 102481: If this is an atomic element, we do not want to allow drops onto it.
        //  We'll only do this check once when we cross between elements.

        if (fDragEnter && IsElementAtomic(pNodeElement->Element()))
        {
            *pdwEffect = DROPEFFECT_NONE;
            break;
        }

        if (pNodeElement->Element() == _pDragDropTargetInfo->_pElementTarget)
        {
            fRet = pNodeElement->Element()->Fire_ondragHelper(
                0,
                &s_propdescCElementondragover,
                pdwEffect);

            if (pNodeElement->IsDead())
            {
                pNodeElement->NodeRelease();
                goto Cleanup;
            }
            if (fRet)
            {
                if (pLayout)
                    hr = THR(pLayout->DragOver(grfKeyState, ptScreen, pdwEffect));
                else
                    *pdwEffect = DROPEFFECT_NONE;
            }
            break;
        }

        if (fDragEnter)
        {
            fRet = pNodeElement->Element()->Fire_ondragHelper(
                0,
                &s_propdescCElementondragenter,
                &dwLoopEffect);

            if (pNodeElement->IsDead())
            {
                pNodeElement->NodeRelease();
                goto Cleanup;
            }
            if (fRet)
            {
                if (pLayout)
                {
                    hr = THR(pLayout->DragEnter(_pInPlace->_pDataObj, grfKeyState, ptScreen, &dwLoopEffect));

                    if (dwLoopEffect == DROPEFFECT_NONE)
                    {
                        _fDragFeedbackVis = FALSE;
                        IGNORE_HR(_pCaret->Hide());
                    }

                    if (hr != S_FALSE)
                        break;
                }
            }
            else
                break;
        }

        // TODO: what if pNodeElement goes away on this first release?!?
        pNodeElement->NodeRelease();
        pNodeElement = pNodeElement->GetUpdatedParentLayoutNode();
        dwLoopEffect = *pdwEffect;
    }
    if ( pNodeElement && DifferentScope(pNodeElement, _pDragDropTargetInfo->_pElementTarget) )
    {
        if (_pDragDropTargetInfo->_pElementTarget && _pDragDropTargetInfo->_pElementTarget->GetFirstBranch())
        {
            CLayout * pLayout;

            _pDragDropTargetInfo->_pElementTarget->Fire_ondragleave();

            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
            if (pLayout)
                IGNORE_HR(pLayout->DragLeave());
        }

        _pDragDropTargetInfo->_pElementTarget = pNodeElement->Element();
        *pdwEffect = dwLoopEffect;
    }

    if (NULL == _pDragDropTargetInfo->_pElementTarget)
    {
        *pdwEffect = DROPEFFECT_NONE;
    }


    // Find the site to scroll and the direction, if any

    if (pNodeElement)
    {
        // TODO: what if pNodeElement goes away on this first release!?!?
        pNodeElement->NodeRelease();
        if (pNodeElement->IsDead())
            goto Cleanup;
    }

    {
        Assert(_view.IsActive());

        CDispScroller * pDispScroller = _view.HitScrollInset((CPoint *) &pt, &dwScrollDir);

        if (pDispScroller)
        {
            Assert(dwScrollDir);
            *pdwEffect |= DROPEFFECT_SCROLL;

            if (_pDragDropTargetInfo->_pDispScroller == pDispScroller)
            {
                if (IsTimePassed(_pDragDropTargetInfo->_uTimeScroll))
                {
                    CElement        *pElement = NULL;
                    CTreeNode       *pNodeElement = NULL;
                    styleOverflow   stO = styleOverflowNotSet;

                    //  Get the element that refers to the disp scroller
                    //  and get the overflow attribute.
                    pElement = GetDispNodeElement(pDispScroller);
                    if (pElement)
                    {
                        pNodeElement = pElement->GetFirstBranch();
                        Assert(pNodeElement);
                        if (pNodeElement)
                            stO = pNodeElement->GetCascadedoverflow();
                    }

                    //  We want to scroll only if the scroller does not have
                    //  overflow:hidden.
                    if (stO != styleOverflowHidden)
                    {
                        CSize sizeOffset;
                        CSize sizePercent(0, 0);
                        CSize sizeDelta;
                        CRect rc;

                        // Hide drag feedback while scrolling
                        fRedrawFeedback = _fDragFeedbackVis;
                        if (_fDragFeedbackVis)
                        {
                            CLayout * pLayout;

                            Assert(_pDragDropTargetInfo->_pElementTarget);

                            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
                            if (pLayout)
                                pLayout->DrawDragFeedback(FALSE);
                        }

                        // open display tree for scrolling
                        Verify(_view.OpenView());

                        pDispScroller->GetClientRect(&rc, CLIENTRECT_CONTENT);
                        pDispScroller->GetScrollOffset(&sizeOffset);

                        if (dwScrollDir & SCROLL_LEFT)
                            sizePercent.cx = -SCROLLPERCENT;
                        else if (dwScrollDir & SCROLL_RIGHT)
                            sizePercent.cx = SCROLLPERCENT;
                        if (dwScrollDir & SCROLL_UP)
                            sizePercent.cy = -SCROLLPERCENT;
                        else if (dwScrollDir & SCROLL_DOWN)
                            sizePercent.cy = SCROLLPERCENT;

                        sizeDelta.cx = (sizePercent.cx ? (rc.Width() * sizePercent.cx) / 1000L : 0);
                        sizeDelta.cy = (sizePercent.cy ? (rc.Height() * sizePercent.cy) / 1000L : 0);

                        sizeOffset += sizeDelta;
                        sizeOffset.Max(g_Zero.size);

                        if( _pCaret )
                        {
                            _pCaret->BeginPaint();
                        }
                    
                        pDispScroller->SetScrollOffset(sizeOffset, TRUE);
                    
                        if( _pCaret )
                        {
                            _pCaret->EndPaint();
                        }
                    
                        //  Ensure all deferred calls are executed
                        _view.EndDeferred();

                        // Show drag feedback after scrolling is finished
                        if (fRedrawFeedback)
                        {
                            CLayout * pLayout;

                            Assert(_pDragDropTargetInfo->_pElementTarget);

                            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
                            if (pLayout)
                                pLayout->DrawDragFeedback(TRUE);
                        }
                    }

                    // Wait a while before scrolling again
                    _pDragDropTargetInfo->_uTimeScroll = NextEventTime(g_iDragScrollInterval / 2);
                }
            }
            else
            {
                _pDragDropTargetInfo->_pDispScroller = pDispScroller;
                _pDragDropTargetInfo->_uTimeScroll = NextEventTime(g_iDragScrollDelay);
            }
        }
        else
        {
            _pDragDropTargetInfo->_pDispScroller = NULL;
        }
    }

Cleanup:
    // S_FALSE from DragOver() does not make sense for OLE. Also, since we
    // call DragOver() from within DragEnter(), we DO NOT want to return
    // S_FALSE because that would result in OLE passing on DragOver() to
    // the parent drop target.
    if (hr == S_FALSE)
        hr = S_OK;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DragLeave, IDropTarget
//
//  Synopsis:   Remove any user feedback
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::DragLeave(BOOL fDrop)
{
    if (_pDragDropTargetInfo)
    {

        CLayout * pLayout = NULL;

        if (_pDragDropTargetInfo->_pElementTarget)
        {            
            //TODO (t-jeffg) This makes sure that when dragging out of the source window
            //the dragged item will be deleted.  Will be removed when _pdraginfo is dealt
            //with properly on leave.  (Anandra)
            _fSlowClick = FALSE;

            if (!fDrop)
                _pDragDropTargetInfo->_pElementTarget->Fire_ondragleave();

            pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
            if (pLayout)
                IGNORE_HR(pLayout->DragLeave());
        }
        if ( ! fDrop && pLayout && _pDragDropTargetInfo->SavedSelection() )
        {
            _pDragDropTargetInfo->RestoreSelection();    
        }            
        delete _pDragDropTargetInfo;
        _pDragDropTargetInfo = NULL;
               
        if ( _pCaret )
        {
            _pCaret->LoseFocus();
        }        
    }

    EndUndoUnit();

    RRETURN(CServer::DragLeave(fDrop));
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::Drop, IDropTarget
//
//  Synopsis:   Handle the drop operation
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDoc::Drop(
    IDataObject *pDataObj,
    DWORD        grfKeyState,
    POINTL       ptScreen,
    DWORD *      pdwEffect)
{
    HRESULT   hr = S_OK;
    CLayout * pLayout;

    CCurs   curs(IDC_WAIT);
    DWORD   dwEffect = *pdwEffect;

    // Since the keystate now might be (probably is) different than the last DragOver, use
    // cached keystate from that call.  Otherwise, things like MK_BUTTON might not be set.
    hr = THR(DragOver(_pDragDropTargetInfo ? _pDragDropTargetInfo->_dwLastKeyState : grfKeyState,
                ptScreen, &dwEffect));
    
    // Continue only if drop can happen (i.e. at least one of DROPEFFECT_COPY,
    // DROPEFFECT_MOVE, etc. is set in dwEffect).
    if (hr || DROPEFFECT_NONE == dwEffect || DROPEFFECT_SCROLL == dwEffect)
        goto Cleanup;

    Assert(_pDragDropTargetInfo);
    if (!_pDragDropTargetInfo->_pElementTarget)
    {
        *pdwEffect = DROPEFFECT_NONE;
        goto Cleanup;
    }

    if (_pDragDropTargetInfo->_pElementTarget->Fire_ondragHelper(
                0,
                &s_propdescCElementondrop,
                pdwEffect))
    {
        if (!_pDragDropTargetInfo->_pElementTarget)
        {
            *pdwEffect = DROPEFFECT_NONE;
            goto Cleanup;
        }

        pLayout = GetLayoutForDragDrop(_pDragDropTargetInfo->_pElementTarget);
        if (pLayout)
            hr = THR(pLayout->Drop(pDataObj, grfKeyState, ptScreen, pdwEffect));
        else
            *pdwEffect = DROPEFFECT_NONE;
    }

    // Drop can change the current site.  Set the UI active
    // site to correspond to the current site.

    if (_pElemUIActive != _pElemCurrent)
    {
        _pElemCurrent->BecomeUIActive();
    }

Cleanup:
    IGNORE_HR(DragLeave( hr == S_OK ));    

    RRETURN1(hr,S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ReactivateAndUndo, public
//
//  Synopsis:   Transitions us to UI Active and performs an undo.  This is
//              called if we just deactivated and the user selected our
//              parent's Undo option.
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ReactivateAndUndo(void)
{
    HRESULT      hr;
    CDoc::CLock Lock(this);

    TransitionTo(OS_UIACTIVE);

#ifdef NO_EDIT
    hr = S_OK;
#else
    hr = THR(EditUndo());
#endif // NO_EDIT

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     DoTranslateAccelerator, public
//
//  Synopsis:   Overridden method of IOleInPlaceActiveObject
//
//  Arguments:  [lpmsg] -- Message to translate
//
//  Returns:    S_OK if translated, S_FALSE if not.  Error otherwise
//
//  History:    07-Feb-94     LyleC    Created
//              08-Feb-95     AndrewL  Turned off noisy trace.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::DoTranslateAccelerator(LPMSG lpmsg)
{
    HRESULT  hr = S_FALSE;
    HRESULT  hr2;
    CMessage Message(lpmsg);

    if (    _pDocPopup 
        &&  _pDocPopup->_pInPlace)
    {
        hr = _pDocPopup->DoTranslateAccelerator(lpmsg);
        if (hr != S_FALSE)
        {
            RRETURN(hr);
        }

        if (lpmsg->message == WM_KEYDOWN && (lpmsg->wParam == VK_ESCAPE || lpmsg->wParam == VK_TAB))
        {
            hr = THR(_pDocPopup->DoVerb(    OLEIVERB_HIDE,
                                            NULL,
                                            _pDocPopup->_pClientSite,
                                            0,
                                            NULL,
                                            NULL));

            if (lpmsg->wParam == VK_ESCAPE && hr != S_FALSE)
                RRETURN(hr);
        }
    }

    Assert(_pElemCurrent && _pElemCurrent->GetFirstBranch());

    CTreeNode::CLock Lock;

    hr2 = THR( Lock.Init(_pElemCurrent->GetFirstBranch()) );
    if( hr2 )
    {
        hr = hr2;
        goto Cleanup;
    }


    switch (lpmsg->message)
    {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        break;
    default:
        goto Cleanup;
    }

    //
    // Do not handle any messages if our window or one of our children
    // does not have focus.
    //

    // TODO (sujalp): We should not be dispatching this message from here.
    // It should be dispatched only from CDoc::OnWindowMessage. When this
    // problem is fixed up, remove the following switch.
    switch (lpmsg->message)
    {
    case WM_KEYDOWN:
        _fGotKeyDown = TRUE;
        // if we are Tabbing into Trident the first time directly from address bar
        // do not tab into address bar again on next TAB. (sramani: see bug#28426)

        if (lpmsg->wParam == VK_TAB && ::GetFocus() != _pInPlace->_hwnd)
            _fFirstTimeTab = FALSE;

        break;

    case WM_KEYUP:
        if (!_fGotKeyDown)
            return S_FALSE;
        break;
    }

    // If there was no captured object, or if the capture object did not
    // handle the message, then lets pass it to the current site
    hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch(), TRUE));

Cleanup:
    RRETURN1_NOTRACE(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CallParentTA, public
//
//  Synopsis:   Calls the parent's TranslateAccelerator method and returns
//              TRUE if the parent handled the message.
//
//  Arguments:  pmsg    Message for parent to translate.  If NULL,
//                      then this function always returns FALSE.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CallParentTA(CMessage * pmsg)
{
    HRESULT             hr;
    IOleControlSite *   pCtrlSite;

    Assert(_pClientSite);

    //  If we didn't have a message to translate, no need to call
    //    to our parent.  It is OK for the parent to not
    //    support IOleControlSite. In that case we just indicate
    //    the event was not handled.

    if (pmsg &&
            _pClientSite &&
            !THR_NOTRACE(_pClientSite->QueryInterface(
                IID_IOleControlSite,
                (void **) &pCtrlSite)))
    {
        hr = THR(pCtrlSite->TranslateAccelerator(
                                pmsg,
                                VBShiftState(pmsg->dwKeyState)));
        pCtrlSite->Release();
        if (FAILED(hr))
            hr = S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


    //+---------------------------------------------------------------------------
//
//  Member:     Form::ActivateFirstObject
//
//  Synopsis:   Activate the first object in the tab order.
//
//  Arguments:  lpmsg       Message which prompted this rotation, or
//                          NULL if no message is available
//              pSiteStart  Site to start the search at.  If null, start
//                          at beginning of tab order.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ActivateFirstObject(LPMSG lpmsg)
{
    HRESULT     hr              = S_OK;
    CElement *  pElementClient  = CMarkup::GetElementTopHelper(PrimaryMarkup());
    BOOL        fDeferActivate  = FALSE;

    if( pElementClient == NULL )
        goto Cleanup;


    if ( pElementClient && ( pElementClient->IsEditable(/*fCheckContainerOnly*/FALSE) || pElementClient->Tag() == ETAG_FRAMESET ))
    {
        // In design mode or in frameset case, just activate the ped.
        //
        hr = THR(pElementClient->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
        goto Cleanup;
    }

    if (_fInHTMLDlg || !_fMsoDocMode
                    || ((_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG) != 0))
    {
        // only if we are a dialog or no one is activating us as a doc obj

        if (LoadStatus() < LOADSTATUS_PARSE_DONE)
        {
            // We need to wait until the doc is fully parsed before we can
            // determine the first tabbable object (IE5 #73116).
            fDeferActivate = !_fCurrencySet;
        }
        else
        {
            CElement *      pElement    = NULL;
            long            lSubNext    = 0;
            FOCUS_DIRECTION dir         = DIRECTION_FORWARD;

            if (lpmsg && (lpmsg->message == WM_KEYDOWN ||
                          lpmsg->message == WM_SYSKEYDOWN))
            {
                if (GetKeyState(VK_SHIFT) & 0x8000)
                {
                    dir = DIRECTION_BACKWARD;
                }
            }

            FindNextTabOrder(dir, FALSE, NULL, NULL, 0, &pElement, &lSubNext);
            if (pElement)
            {
                Assert(pElement->IsTabbable(lSubNext));
                hr = THR(pElement->BecomeCurrentAndActive(lSubNext, NULL, NULL, TRUE));
                if (hr)
                    goto Cleanup;

                IGNORE_HR(THR(pElement->ScrollIntoView()));
                _fFirstTimeTab = FALSE;                
                goto Cleanup;
            }
        }
    }

    hr = THR(PrimaryMarkup()->GetElementTop()->BecomeCurrentAndActive(0, NULL, NULL, !g_fInMoney99));

    // Although we have set the currency, if we have not completed the 
    // parsing yet, we were only able to set it to the element client. Once
    // the parsing is completed, it will be set on the proper tab-stop element.
    // We ignore the _fCurrencySet value set by the BecomeCurrentAndActive call.
    if (fDeferActivate)
    {
        _fCurrencySet = FALSE;
    }

    // Fire window onfocus here the first time if not fired before in
    // onloadstatus when it goes to LOADSTATUS_DONE
    _pWindowPrimary->Post_onfocus();

Cleanup:
    RRETURN1(hr, S_FALSE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\ipwnd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       ipwnd.cxx
//
//  Contents:   forms kernel window proc
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif


#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLEACC_H_
#define X_OLEACC_H_
#include "oleacc.h"
#endif

#ifndef UNIX
#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEMENT_HXX_
#define X_ROOTELEMENT_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#if !defined(NO_IME)
#ifndef WM_IME_REQUEST
#define WM_IME_REQUEST 0x0288
#endif
#ifndef IMR_RECONVERTSTRING
#define IMR_RECONVERTSTRING 0x0004
#endif
#endif

#ifdef UNIX

#include <mainwin.h>
extern "C" HANDLE MwGetPrimarySelectionData();
#include "quxcopy.hxx"

#endif //UNIX

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_ACCUTIL_HXX_
#define X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

EXTERN_C const GUID CGID_DocHostCommandHandler;

#ifndef X_OLEACC_H
#define X_OLEACC_H
#include <oleacc.h>
#endif

#ifndef WIN16
DYNLIB g_dynlibOLEACC = { NULL, NULL, "OLEACC.DLL" };
#endif // !WIN16

MtDefine(MsoCmdText, Locals, "MSOCMDTEXT structure (temp)")

// Holds the user defined windows message
UINT CDoc::_g_msgHtmlGetobject = 0;
#if !defined(NO_IME)
UINT CDoc::_g_msgImeReconvert = 0;
#endif // !NO_IME

ExternTag(tagRects);
DeclareTag(tagCapture, "DocCapture", "trace SetMouseCapture")
DeclareTag(tagPaintRedraw, "Doc", "trace WM_PAINT, WM_SETREDRAW");

extern HRESULT EnsureAccWindow( CWindow * pWindow );

extern void RestartImgAnimTimerProc();
extern void KillImgAnimTimerProc();

#define WM_CHECKMINIMIZED (WM_USER + 145)

//+---------------------------------------------------------------
//
// Local Helper: ShowTooltipHelper
//
//----------------------------------------------------------------
void
ShowTooltipHelper(CDoc * pDoc, CTreeNode * pNodeContext, CMessage * pMsg)
{
    CMarkup * pMarkup = pNodeContext ? pNodeContext->GetMarkup() : NULL;

    if (!(pMarkup && pMarkup->_fDesignMode))
    {
        BOOL    fDismissed;

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        //
        //  Give tooltips a chance to dismiss
        //
        fDismissed = FormsTooltipMessage(
                pMsg->message,
                pMsg->wParam,
                pMsg->lParam);

        // If we're not captured and the tooltip is being dismissed....
        //
        if (fDismissed == FALSE)
        {
            //  If hitted element has tooltip, put up its tooltip, otherwise,
            //  Walk through the element hierarchy.  If any element
            //  has tooltip text, put up the tooltip.
            //
            CTreeNode * pNode = pNodeContext;
            for (; pNode && pNode->Tag() != ETAG_ROOT ;
                       pNode = pNode->Parent())
            {
                if (pNode->Element()->ShowTooltip(pMsg, pMsg->pt) != S_FALSE)
                {
                    break;
                }
            }
        }
    }
}


//+====================================================================================
//
// Method: IsTridentHWND
//
// Synopsis: Helper to check to see if a given HWND belongs to a trident window
//
//------------------------------------------------------------------------------------


BOOL
IsTridentHwnd( HWND hwnd )
{
    TCHAR strClassName[100] ;

    ::GetClassName( hwnd, strClassName, 100 );

    if ( StrCmpIW( strClassName, _T("Internet Explorer_Server") ) == 0 )
    {
        return TRUE;
    }
    else
        return FALSE;
}

//+====================================================================================
//
// Method: OnChildBeginSelection
//
// Synopsis: Called by enumeration of all child windows 
//           If you are a TridentHwnd - post a WM_BEGINSELECTION message to yourself.
//           Otherwise do nothing
//
//------------------------------------------------------------------------------------

BOOL
CALLBACK
OnChildBeginSelection( HWND hwnd, LPARAM lParam )
{
    if ( IsTridentHwnd( hwnd ) )
    {
        ::SendMessage( hwnd,
                       WM_BEGINSELECTION,
                       lParam,  // Cascade the Selection Type.
                       0 );
    }
    return TRUE;
}

BOOL
CDoc::IsPopupChildHwnd( HWND hwnd )
{
    CDoc *pDocChild = _pDocPopup;

    while (pDocChild)
    {
        if (    pDocChild->_pInPlace->_hwnd == hwnd
            ||   ::IsChild(pDocChild->_pInPlace->_hwnd, hwnd))
            return TRUE;

        pDocChild = pDocChild->_pDocPopup;
    }

    return FALSE;
}


#ifdef UNIX
//+---------------------------------------------------------------------------
//
//  Member:     MwTransalteUnixKeyBinding
//
//  Synopsis:   This routine acts as a late stage TranslateAccelerator call with
//              the caveat that if translated only the wParam and Modifiers 
//              arguments will be changed.
//
//              This means that for the KEYDOWN/KEYUP messages the key code and 
//              modifier state could be translated to something else.  This 
//              implies GetKeyState for the modifiers will not be re-queried 
//              after a call to this function as it might not be the same as the
//              now translated modifier state.
//
//  Returns:    void
//
//----------------------------------------------------------------------------
extern "C" BOOL MwTranslateUnixKeyBinding( HWND hwnd, DWORD message, 
                                           WPARAM *pwParam, DWORD *pModifiers );
#endif

//+---------------------------------------------------------------
//
//  Member:     CDoc::OnWindowMessage
//
//  Synopsis:   Handle window messages dispatched from the wndproc.
//
//  Returns:    S_FALSE if message should be passed on to the
//              default window procedure.
//
//---------------------------------------------------------------

HRESULT
CDoc::OnWindowMessage(
        UINT msg,
        WPARAM wParam,
        LPARAM lParam,
        LRESULT *plResult)
{
    HRESULT     hr;
    HWND        hwnd = _pInPlace->_hwnd;
    HWND        hwndControl = NULL;
    CLock       Lock(this);
#ifdef UNIX
    BOOL        bCutToEOL = FALSE;
    BOOL        bCutFullLine = FALSE;
#endif
    BOOL        fWeJustHidSelection = FALSE;
    HWND        hwndParent = NULL;
    HWND        hwndLoseFocus = NULL;
    HWND        hwndTemp = NULL;
    BOOL        fTridentHwnd = FALSE;
    BOOL        fLosingFocusToTridentChild;
    CMarkup*    pCurMarkup;

    Assert(_pElemCurrent);

    hr = S_OK;
    *plResult = 0;
    if (    _pDocPopup 
        &&  msg >= WM_KEYFIRST 
        &&  msg <= WM_KEYLAST
        &&  _pDocPopup->_pInPlace)
    {
        HRESULT hr2 = S_OK;
        hr2 = THR(_pDocPopup->OnWindowMessage(msg, wParam, lParam, plResult));
        if (S_OK == hr2)
            goto Cleanup;
    }

#if DBG == 1
    if (msg == WM_PAINT || msg == WM_SETREDRAW)
    {
        TraceTag((tagPaintRedraw, "%x +%d %x %x",
                        this, msg, wParam, lParam));
    }
#endif

    switch (msg)
    {
    case WM_APPCOMMAND:
    case WM_INPUTLANGCHANGE:
        {
            CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);
            PumpMessage(&Message, _pElemCurrent->GetFirstBranch());
        }
        break;

#ifndef NO_MENU
     case WM_MENUSELECT:
     case WM_INITMENUPOPUP:
        {
            CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);

            if (_pMenuObject)
            {
                PumpMessage(&Message, _pMenuObject->GetFirstBranch());
            }
            else
            {
                PumpMessage(&Message, _pElemCurrent->GetFirstBranch());
            }
        }
        break;
#endif // NO_MENU

     case WM_TIMER:

        if (wParam == TIMER_DEFERUPDATEUI)
        {
            OnUpdateUI();
        }
        break;
            

    //
    // Somewhere inside us a Selection is begin made. We clear any selection we have
    // and post the message on to all our child windows.
    //
    case WM_BEGINSELECTION:
    {
        IGNORE_HR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS_FRAME, NULL, wParam ));

        ::EnumChildWindows( _pInPlace->_hwnd,
                            (WNDENUMPROC) OnChildBeginSelection,
                            wParam );
    }
    break;
    case WM_KILLFOCUS:
    {
        _pInPlace->_fFocus = FALSE;
        // Release any mouse capture when we loose focus
        SetMouseCapture (NULL, NULL);

        _fGotKeyUp = TRUE;

        //
        //  Tell the editor to lose focus
        //
        //
        // marka - check to see if 
        // a) we're losing focus to another frameset (we kill our selection )
        // b) we're losing focus to another window ( we hide our selection )
        // c) just losing focus - we call Lose Focus ( to hide the caret ).
        //


        //
        // See if we're losing focus to another Window in the same window as us.
        //

        hwndTemp  = _pInPlace->_hwnd;
        while(hwndTemp)
        {
            hwndParent = hwndTemp;
            hwndTemp = GetParent(hwndTemp);
        }

        fLosingFocusToTridentChild = FALSE;
        hwndTemp = (HWND) wParam;
        while(hwndTemp)
        {      
            hwndLoseFocus = hwndTemp;

            if (hwndLoseFocus == _pInPlace->_hwnd)
            {
                fLosingFocusToTridentChild = TRUE;

                // shortcut the serach, because we already
                // know the top-level parent in this case
                hwndLoseFocus = hwndParent;
                break;
            }

            hwndTemp = GetParent(hwndTemp);
        }

        fTridentHwnd = wParam && IsTridentHwnd( (HWND) wParam ) ;
        
        if ( hwndLoseFocus != hwndParent && HasTextSelection() ) 
        {
            CMarkup *pMarkup = GetCurrentMarkup();

            if( pMarkup )
            {
                pMarkup->HideSelection();
                SET_EDIT_BIT( pMarkup, _fSelectionHidden , TRUE)
                fWeJustHidSelection = TRUE;
            }
        }
        else  if ( hwndLoseFocus == hwndParent && fTridentHwnd )
        {
#if 0        
           hr = THR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS_FRAME, NULL ));
#endif            
        }
        else
        {
            hr = THR( NotifySelection( EDITOR_NOTIFY_LOSE_FOCUS, NULL ));
        }
        
        // If losing focus to a window that is not a Trident child, but is a
        // child of Trident's top-level parent (for example, the address box
        // of IE), clear the first-time-tab flag (37950)
        if (!fLosingFocusToTridentChild && hwndParent == hwndLoseFocus)
        {
            _fFirstTimeTab = FALSE;
        }

        if (    _pDocPopup
            &&  (   GetWindowThreadProcessId((HWND) wParam, NULL)
                        != GetWindowThreadProcessId(_pInPlace->_hwnd, NULL)
                ||  !IsPopupChildHwnd( (HWND) wParam ))
            )
        {
            IGNORE_HR(_pDocPopup->DoVerb(OLEIVERB_HIDE,
                                        NULL,
                                        _pDocPopup->_pClientSite,
                                        0,
                                        NULL,
                                        NULL));
        }

        // check if we go iconic
        ::PostMessage(hwnd, WM_CHECKMINIMIZED, NULL, NULL);

    }           // Fall through

    case WM_SETFOCUS:
    {
        // check if we go maximized / restored
        if ( _fIconic && (msg == WM_SETFOCUS))
        {
            while (hwnd)
            {
                hwndParent = hwnd;
                hwnd = GetParent(hwnd);
            }
        
            if ( !IsIconic( hwndParent ) )
            {
                _fIconic = FALSE;
                InternetSetOption(NULL, INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS , NULL, NULL); 
                RestartImgAnimTimerProc();
            }
        }

        CMessage  Message(_pInPlace->_hwnd, msg, wParam, lParam);

        CElement *pElemFireTarget;

        pElemFireTarget = _pElemCurrent->GetFocusBlurFireTarget(_lSubCurrent);
        Assert(pElemFireTarget);

        // Whenever we get focus, we set the flag to false to indicate
        // that we have not received a key down, so donot fire the keyups
        if (WM_SETFOCUS == msg)
        {
            _fGotKeyDown = FALSE;
            // Do not fire window onfocus if we are here as a result of onblur\onfocus
            // bringing up a modal dialog. However, we do want to fire it if window onblur
            // brought up a modal dialog that was dismissed.
            if (!TestLock(FORMLOCK_CURRENT) ||
                (   !pElemFireTarget->TestLock(CElement::ELEMENTLOCK_FOCUS)
                 && !pElemFireTarget->TestLock(CElement::ELEMENTLOCK_BLUR)
                 && _fModalDialogInOnblur
                )
               )
            {
                GetCurrentWindow()->Post_onfocus();
            }
        }

        if (    _pInPlace
            &&  !_pInPlace->_fDeactivating
            &&  !TestLock(FORMLOCK_CURRENT))
        {
            // Do not fire site onfocus\onblur if we come here either
            // as a result of calling blur() or focus(), because it would
            // have been already fired in BecomeCurrent()
            if (!_fInhibitFocusFiring)
            {
                // SELECT, being a windowed control should receive WM_KILLFOCUS directly
                if (WM_SETFOCUS == msg || (WM_KILLFOCUS == msg && _pElemCurrent->Tag() != ETAG_SELECT))
                {
                    // if the doc is not locked, the elem can't be locked either
                    Assert(!pElemFireTarget->TestLock(CElement::ELEMENTLOCK_FOCUS));
                    Assert(!pElemFireTarget->TestLock(CElement::ELEMENTLOCK_BLUR));

                    // fire focus/blur events
                    _pElemCurrent->Fire_ActivationHelper(
                                                        _lSubCurrent,
                                                        NULL,
                                                        0,
                                                        FALSE,
                                                        (WM_KILLFOCUS == msg),
                                                        TRUE, 
                                                        NULL,
                                                        FALSE);
                }

                if (WM_SETFOCUS == msg)
                {
                    // Fire window onblur if onfocus previously fired and the
                    // current site is not the body
                    if (_pElemCurrent->IsInMarkup() && _pElemCurrent != _pElemCurrent->GetMarkup()->GetElementClient())
                    {
                        GetCurrentWindow()->Post_onblur();
                    }
                }
            }
        }
        // we get here if a modal dialog from current element's onblur is dismissed.
        // In this case we wan't to fire its onfocus again.
        else if (pElemFireTarget->TestLock(CElement::ELEMENTLOCK_BLUR) &&
                 WM_SETFOCUS == msg && _fModalDialogInOnblur)
        {
            GWPostMethodCall(pElemFireTarget, ONCALL_METHOD(CElement, Fire_onfocus, fire_onfocus), 0, TRUE, "CElement::Fire_onfocus");
        }

        if (_view.IsActive())
        {
            _view.InvalidateFocus();

            // Display the caret
            if (_pCaret &&  WM_SETFOCUS == msg)
            {
                _pCaret->UpdateCaret();
            }
        }

        pCurMarkup = GetCurrentMarkup();        
        if ( !fWeJustHidSelection && pCurMarkup ) 
        {     
            if ( CHECK_EDIT_BIT( pCurMarkup, _fSelectionHidden ))
            {
                pCurMarkup->ShowSelection();                 
                SET_EDIT_BIT( pCurMarkup, _fSelectionHidden , FALSE)            
            }
            else if ( HasTextSelection() )
            {
                // Always inval the selection here. Fixes problems with inval from Alerts fired OnSelectStart
                pCurMarkup->InvalidateSelection( ); 
            }                
        }

        IGNORE_HR(InvalidateDefaultSite());

        IGNORE_HR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));

        // Forward the WM_KILLFOCUS, WM_SETFOCUS messages to CServer which
        // will notify the control site of the focus change.  Forward the
        // messages when no site has focus or when the site with focus is
        // a dataframe (non ole site).
        if (!_pElemCurrent->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));

        // Do not fire window onblur if we are here as a result of onblur\onfocus
        // bringing up a modal dialog.
        if (WM_KILLFOCUS == msg && !TestLock(FORMLOCK_CURRENT))
        {
            GetCurrentWindow()->Post_onblur(TRUE);
        }

        break;
    }

    case WM_CAPTURECHANGED:
#if DBG==1
        TLS(fHandleCaptureChanged) = TRUE;
#endif
        SetMouseCapture(NULL, NULL);

#if DBG==1
        TLS(fHandleCaptureChanged) = FALSE;
#endif
        break;

    //
    // Messages sent to site under mouse.
    //

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            POINT pt;

            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);

            hr = THR(OnMouseMessage(
                    msg,
                    wParam,
                    lParam,
                    plResult,
                    pt.x, pt.y));

            //we couldn't find who is under us (BODY having "display:none" is example)
            //use default processing (it will eventually set arrow cursor)
            if(hr != S_OK)
                hr = CServer::OnWindowMessage(msg, wParam, lParam, plResult);
        }
        else
        {
            hr = CServer::OnWindowMessage(msg, wParam, lParam, plResult);
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;
            pt.x = MAKEPOINTS(lParam).x;
            pt.y = MAKEPOINTS(lParam).y;
            if ( (pt.x  == -1 && pt.y == -1) && _pElemCurrent )
            {
                // pt.x & pt.y are supposed to be in screen coordinates;
                // the only case when they are -1,-1 is if WM_CONTEXTMENU
                // originated from Shift-F10 or Windows keyboard
                // key 'Menu'; in this case we send the message to the
                // current site.

                CMessage  Message(_pInPlace->_hwnd, msg, wParam, lParam);
                hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            }
            else
            {               
                ScreenToClient(_pInPlace->_hwnd, &pt);

                // CONSIDER: should this set the focus before
                // sending the OnMouseMessage.  Does anything actually
                // use this code path? (jbeda)

                hr = THR(OnMouseMessage(
                        msg,
                        wParam,
                        lParam,
                        plResult,
                        pt.x, pt.y));
            }
        }
        break;

#ifndef WIN16
    case WM_MOUSEWHEEL:
HandleMouseWheel:
        if (_pDocPopup)
        {
            SendMessage(_pDocPopup->_pInPlace->_hwnd, msg, wParam, lParam);
        }
        else
        {
            POINT ptCursor;
            RECT  rcCurrent;

            // Check where the wheel rotates.
            // If the wheel is rotated inside the current CDoc window, let
            // us handle it. Otherwise, let DefWindowProc and handle it and
            // bubble to the parent window.
            ptCursor.x = MAKEPOINTS(lParam).x;
            ptCursor.y = MAKEPOINTS(lParam).y;
            ::GetWindowRect(InPlace()->_hwnd, &rcCurrent);

            if (PtInRect(&rcCurrent, ptCursor))
            {
                ScreenToClient(hwnd, &ptCursor);
                Assert(msg == WM_MOUSEWHEEL || msg == g_msgMouseWheel);
                hr = THR(OnMouseMessage(
                        WM_MOUSEWHEEL,
                        wParam,
                        lParam,
                        plResult,
                        ptCursor.x,
                        ptCursor.y));
            }
            else
            {
                hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));
            }
        }
        break;
#endif // ndef WIN16

    //
    // Messages sent to site under mouse
    //

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
        switch (msg)
        {
        case WM_LBUTTONDOWN:
            _fCanFireDblClick = TRUE;
            // fall through
        
        case WM_LBUTTONDBLCLK:
            _fGotLButtonDown = TRUE;
            break;
        case WM_MBUTTONDOWN:
        case WM_MBUTTONDBLCLK:
            _fGotMButtonDown = TRUE;
            break;
        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            _fGotRButtonDown = TRUE;
            break;
        }
        _fGotKeyUp = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_LBUTTONUP:
        if (!_fGotLButtonDown)
        {
            hr = S_OK;
            goto Cleanup;
        }
        _fGotLButtonDown = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_MBUTTONUP:
        if (!_fGotMButtonDown)
        {
            hr = S_OK;
            goto Cleanup;
        }
        _fGotMButtonDown = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_RBUTTONUP:
        if (!_fGotRButtonDown)
        {
            hr = S_OK;
            goto Cleanup;
        }
        _fGotRButtonDown = FALSE;
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_MOUSEMOVE:
        hr = THR(OnMouseMessage(
                msg,
                wParam,
                lParam,
                plResult,
                MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y));
        break;

    case WM_MOUSELEAVE:
        // Default messages get forwarded to the base class's
        // window procedure.
        hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));
        break;

    case WM_NCLBUTTONDOWN:
    {
        RECT    rcCurrent;

        if (OnNCLButtonDown(wParam, MAKEPOINTS(lParam), &rcCurrent))
        {
            SIZE size;

            TraceTag((tagRects,
                    "%08x OnNCLButtonDown > OnPosRectChange %d %d %d %d",
                    this, rcCurrent));

            HimetricFromDevice(size,
                    rcCurrent.right - rcCurrent.left,
                    rcCurrent.bottom - rcCurrent.top);
            SetExtent(DVASPECT_CONTENT, &size);

            IGNORE_HR(_pInPlace->_pInPlaceSite->OnPosRectChange(ENSUREOLERECT(&rcCurrent)));
        }
        break;
    }

    case WM_HELP:
        hr = THR(OnHelp((HELPINFO *)lParam));
        break;


    //
    // Keyboard messages: (Sent to _pElemCurrent)
    //

#ifdef UNIX
    //
    // Two new windows messages under Unix.  Kind of ironic huh?
    // These are generated from the TranslateUnixKeyBinding call
    // in the case where Ctrl-K (cut to the end of the line) or
    // Ctrl-U (cut full line) is pressed.
    //
    case WM_CUTTOEOL:
        bCutToEOL = TRUE;
        // fall thru
#endif
    case WM_KEYDOWN:
        /*
        if (_fPopupDoc && wParam == VK_ESCAPE)
        {
            // close Popup window if esc key pressed
            Assert(_pClientSite);

            hr = THR(DoVerb(    OLEIVERB_HIDE,
                                NULL,
                                _pClientSite,
                                0,
                                NULL,
                                NULL));
            if (hr)
                goto Cleanup;
            break;
        }
        */
        _fGotKeyDown = TRUE;
        // fall thru
    case WM_KEYUP:
        if (!_fGotKeyDown)
        {
            // NOTE (sujalp): Do not reset the _fGotKeyDown to
            // FALSE here. It is set to FALSE only when we get
            // the focus and that too to eat up the spurious key
            // up which we might get after we GOT_FOCUS.
            hr = S_OK;
            goto Cleanup;
        }
        // fall thru
    case WM_CHAR:
    case WM_DEADCHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:

#ifndef NO_IME
    case WM_IME_SETCONTEXT:
    case WM_IME_NOTIFY:
    case WM_IME_CONTROL:
    case WM_IME_COMPOSITIONFULL:
    case WM_IME_SELECT:
    case WM_IME_CHAR:
    case WM_IME_KEYDOWN:
    case WM_IME_KEYUP:
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_REQUEST:
ReconvertIME:
#endif // !NO_IME
    {
        CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);

#if !defined(NO_IME)
        // Simulate IME Reconversion message
        if (msg == _g_msgImeReconvert)
        {
            Message.message = WM_IME_REQUEST;
            Message.wParam = IMR_RECONVERTSTRING;
        }
#endif // !(NO_IME)
        
#ifdef UNIX
        //
        // See MwTranslateUnixKeyBinding above for what it does.  
        // Basically we allow keys to be translated from emacs bindings
        // keys to windows keys.
        //


        if ((msg == WM_KEYDOWN) ||
            (msg == WM_KEYUP)) {
            BOOL bTranslated;

            bTranslated = MwTranslateUnixKeyBinding( Message.hwnd,
                                                     Message.message, 
                                                     &Message.wParam, 
                                                     &Message.dwKeyState );

            if ( bTranslated &&
                 msg == WM_KEYDOWN &&
                 Message.wParam == VK_DELETE ) {

                //
                // VK_DELETE is normally translated via resource
                // accelerators into an IDM_DELETE.  That code path
                // at this point has already passed though... so we
                // do it manually.
                //
                MSOCMD msocmd;

                msocmd.cmdID = IDM_DELETE;
                msocmd.cmdf = 0;

                QueryStatus((GUID *) &CGID_MSHTML,
                            1,
                            &msocmd,
                            NULL);
            
                if ( msocmd.cmdf != MSOCMDSTATE_DISABLED ) {
                    
                    Exec((GUID *)&CGID_MSHTML, IDM_DELETE, 0, NULL, NULL);
                }

                hr = S_OK;
                break;
            }
        }

        if ( bCutToEOL ) {
            //
            // Bit of a hack here.  When we're instructed to cut the 
            // current line or to the end of the current line we 
            // spoof the appropriate keystrokes into PumpMessage.
            //

            if ( Message.wParam == TRUE ) {
                bCutFullLine = TRUE;

                Message.message = WM_KEYDOWN;
                Message.wParam = VK_HOME;
                Message.lParam = 0L;
                Message.dwKeyState = 0;
            } else {
 CutToEOL:
                Message.message = WM_KEYDOWN;
                Message.wParam  = VK_END;
                Message.lParam  = 0L;
                Message.dwKeyState = FSHIFT;

                //
                // However, in order to not mess up the currently highlighted
                // item we first hide the selection.  This assures we don't
                // overwrite the current selection copy buffer.
                //
                // (Under Unix the currently selected item of which there are
                //  at most one can be pasted by pressing the middle mouse button)
                //

#if 0
                pTxtSite = _pSiteCurrent->GetTxtSite();
                if ( pTxtSite ) {
                    pTxtSite->GetSel(&pSel,FALSE);
                    if (pSel) {
                        pSel->ShowSelection(FALSE);
                    }
                }
#else

#endif
            }
        }
#endif // UNIX

        hr = S_FALSE;

        //
        // If the captured site didn't handle it, pass message to current
        // site.
        //

        if (S_FALSE == hr)
        {
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            *plResult = Message.lresult;
        }
        DeferUpdateUI();

#ifdef UNIX_NOTYET
        //
        // Tail portion of cut line hack
        //

        if ( bCutFullLine ) {
            bCutFullLine = FALSE;
            goto CutToEOL;
        }

        if ( bCutToEOL ) {
            LRESULT lResult;
            OnWindowMessage(WM_CUT, 0, 0L, &lResult);
            if ( pSel ) {
                pSel->ShowSelection(TRUE);
            }
        }
#endif
        break;
    }

    //
    //  Messages that are either handled or reflected.
    //

    case WM_COMMAND:
        if (!_pMenuObject &&
                lParam &&
                GetParent(GET_WM_COMMAND_HWND(wParam, lParam)) == _pInPlace->_hwnd)
        {
            // Command is bubbling up from a control. Reflect it back.

            hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
            goto ReflectMessage;
        }
        else
        {
            // It's our command.
            OnCommand(GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam), GET_WM_COMMAND_CMD(wParam, lParam));
        }
        break;

    case WM_DEFERZORDER:
        {
            FixZOrder();
        }
        break;

    case WM_ACTIVEMOVIE:
        {
            CNotification   nf;

            nf.ActiveMovie(PrimaryRoot(), (void *)lParam);
            BroadcastNotify(&nf);
        }
        break;

    //
    //  OLE Control v1.0 reflected messages
    //

    case WM_DRAWITEM:
        hwndControl = ((DRAWITEMSTRUCT *) lParam)->hwndItem;
        goto ReflectMessage;

    case WM_MEASUREITEM:
        //  TODO how did the control ID ever get set?
        hwndControl = GetDlgItem(hwnd, (UINT) wParam);
        goto ReflectMessage;

    case WM_DELETEITEM:
        hwndControl = ((DELETEITEMSTRUCT *) lParam)->hwndItem;
        goto ReflectMessage;

    case WM_COMPAREITEM:
        hwndControl = ((COMPAREITEMSTRUCT *) lParam)->hwndItem;
        goto ReflectMessage;

    case WM_NOTIFY:
#if DBG == 1 && !defined(WINCE) && defined(DBG_TOOLTIPS)
        if (DbgExIsFullDebug())
        {
            if ((TTN_NEEDTEXTA == ((LPNMHDR) lParam)->code) ||
                    (TTN_NEEDTEXTW == ((LPNMHDR) lParam)->code))
            {
                LPTOOLTIPTEXT   lpToolTipText;
                static TCHAR    szBuffer[256];

                // query tooltips for buttons on the in-place toolbar.

                lpToolTipText = (LPTOOLTIPTEXT) lParam;

                MSOCMD      msocmd;
                MSOCMDTEXT *pmsocmdtext;

                pmsocmdtext = (MSOCMDTEXT *) MemAlloc(Mt(MsoCmdText),
                    sizeof(MSOCMDTEXT) + (FORMS_BUFLEN * sizeof(TCHAR)));
                pmsocmdtext->cmdtextf = MSOCMDTEXTF_NAME;
                pmsocmdtext->cwBuf    = FORMS_BUFLEN;
                pmsocmdtext->cwActual = 0;

                msocmd.cmdID = lpToolTipText->hdr.idFrom;
                msocmd.cmdf  = 0;

                if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboTag)
                {
                    msocmd.cmdID = IDM_BLOCKFMT;
                }
                else if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboFont)
                {
                    msocmd.cmdID = IDM_FONTNAME;
                }
                else if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboSize)
                {
                    msocmd.cmdID = IDM_FONTSIZE;
                }
                else if ((UINT) msocmd.cmdID == (UINT) InPlace()->_hwndComboColor)
                {
                    msocmd.cmdID = IDM_FORECOLOR;
                }

                QueryStatus(
                        (GUID *) &CGID_MSHTML,
                        1,
                        &msocmd,
                        pmsocmdtext);

                if (pmsocmdtext->cwActual > 0)
                {
                    _tcscpy(szBuffer, pmsocmdtext->rgwz);
                }
                else
                {
                    LoadString(
                            g_hInstResource,
                            IDS_TOOLTIP(msocmd.cmdID),
                            szBuffer,
                            ARRAY_SIZE(szBuffer));
                }

                DWORD dwVersion = GetVersion();
                if (dwVersion >= 0x80000000) // Windows 95 or Win32s with Windows 3.1
                {
                    TCHAR szTemp[256];

                    _tcscpy(szTemp, szBuffer);
                    WideCharToMultiByte(
                            CP_ACP,
                            0,
                            szTemp,
                            -1,
                            (char *) szBuffer,
                            sizeof(szBuffer),
                            NULL,
                            NULL);
                }
                lpToolTipText->lpszText = szBuffer;
                MemFree(pmsocmdtext);
                break;
            }
            // else fall through & hit the goto ReflectMessage.
        }
#endif // DBG == 1 && !WINCE

        hwndControl = ((LPNMHDR) lParam)->hwndFrom;
        goto ReflectMessage;

    case WM_VSCROLL:
    case WM_HSCROLL:
        if (!lParam)
        {
            // If lParam is NULL, should try to scroll ourselves
            //
            CMessage Message(_pInPlace->_hwnd, msg, wParam, lParam);
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            break;
        }
        // if lParam is defined, should fall through to ReflectMessage

#ifndef WIN16
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOREDIT:
#endif // !WIN16
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        hwndControl = (HWND) lParam;
        goto ReflectMessage;

#ifndef WINCE
    case WM_PARENTNOTIFY:
        if (LOWORD(wParam) == WM_CREATE ||
            LOWORD(wParam) == WM_DESTROY)
        {
            hwndControl = (HWND) lParam;

            // Hack for PhotoSuite (#94834)
            if (_pElemOleSiteActivating && LOWORD(wParam) == WM_CREATE)
            {
                COleSite * pOleSite = DYNCAST(COleSite, _pElemOleSiteActivating);

                if (!pOleSite->_hwndPrivate)
                {
                    pOleSite->_hwndPrivate = hwndControl;
                }
            }
            goto ReflectMessage;
        }
        break;
#endif // WINCE

    case WM_GETDLGCODE:
        *plResult = DesignMode() ? DLGC_WANTALLKEYS : DLGC_WANTCHARS | DLGC_WANTARROWS;
        hr = S_OK;
        break;

    case WM_ERASEBKGND:
        if (wParam != 0)
        {
            *plResult = OnEraseBkgnd((HDC)wParam);
        }
        hr = S_OK;
        break;
        
#ifdef UNIX
    //
    // Under Unix handle the standard WM_CUT & PASTE messages.
    // Again, these are generated by the TranslateUnixKeyBinding
    // call on certain keystrokes... this happens too late to 
    // conver to the right IDM_ commands so I do it here.
    //

    case WM_CUT:
    {
        MSOCMD msocmd[2];

        msocmd[0].cmdID = IDM_CUT;
        msocmd[0].cmdf = 0;
        msocmd[1].cmdID = IDM_DELETE;
        msocmd[1].cmdf = 0;

        QueryStatus((GUID *) &CGID_MSHTML,
                    2,
                    msocmd,
                    NULL);
            
        //
        // Here we either delete or cut depending on whether cut
        // is available or not.  It's usually not available because
        // it's on a password field
        //

        if ( msocmd[0].cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_CUT,0, NULL, NULL);
        } 
        else 
        if ( msocmd[1].cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_DELETE, 0, NULL, NULL);
        }

        hr = S_OK;
        break;
    }
    case WM_COPY:
    {
        MSOCMD msocmd;

        msocmd.cmdID = IDM_COPY;
        msocmd.cmdf = 0;

        QueryStatus((GUID *) &CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);

        if ( msocmd.cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_COPY, 0, NULL, NULL);
        }

        hr = S_OK;
        break;
    }
    case WM_PASTE:
        MSOCMD msocmd;

        msocmd.cmdID = IDM_PASTE;
        msocmd.cmdf = 0;

        QueryStatus((GUID *) &CGID_MSHTML,
                    1,
                    &msocmd,
                    NULL);
            
        if ( msocmd.cmdf != MSOCMDSTATE_DISABLED ) {
            Exec((GUID *)&CGID_MSHTML, IDM_PASTE, 0, NULL, NULL);
        }

        hr = S_OK;
        break;

    //
    // These two messages implement the Unix selection copy buffer
    // (clipboard) for Trident.
    //
    // Basically, if we get "GETTEXTPRIMARY" the system is doing 
    // the equivalent of a RenderFormat wanting the selected text.
    //
    // UNDOPRIMARYSELECTION tells us someone else has selected text
    // and we should undo our selection.
    //

    case WM_GETTEXTPRIMARY:
    case WM_UNDOPRIMARYSELECTION:
        {
            //
            // Send these messages down to the current Text Selection via
            // PumpMessage
            //
            CMessage  Message(_pInPlace->_hwnd, msg, wParam, lParam);
            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
            break;
        }
#endif // UNIX

    case WM_GETOBJECT :
            // ActiveX "accessibility", creation of in-context proxy
            OnAccGetObjectInContext(msg, wParam, lParam, plResult);
            hr = S_OK;  // no need to continue 
            break;

    case WM_UISTATEUPDATE:
        {
            WORD wUIStateOld = _wUIState;

            if (LOWORD(wParam) == UIS_SET)
                _wUIState |= HIWORD(wParam);
            else if (LOWORD(wParam) == UIS_CLEAR)
                _wUIState &= ~HIWORD(wParam);

            // Use XOR to see which bits changed.
            wUIStateOld ^= _wUIState;

            if (wUIStateOld & UISF_HIDEACCEL)
            {
                if (_fHaveAccelerators)
                {
                    CNotification   nf;

                    nf.ChangeAccelerator(PrimaryRoot());
                    nf.SetData((DWORD)0);
                    BroadcastNotify(&nf);
                    Assert(nf.IsDataValid());

                    // If there were any accelerators then they would
                    // have set the DWORD to non-zero
                    if (nf.DataAsDWORD() == 0)
                        _fHaveAccelerators = FALSE;
                    else
                        Invalidate();
                }
            }
            else if ((wUIStateOld & UISF_HIDEFOCUS) && _view.IsActive())
            {
                _view.InvalidateFocus();
            }
        }

        *plResult = DefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam);
        hr = S_OK;
        break;

    case WM_CHECKMINIMIZED:
        // check if we went iconic        
        if ( !_fIconic )
        {
            while (hwnd)
            {
                hwndParent = hwnd;
                hwnd = GetParent(hwnd);
            }

            if ( IsIconic( hwndParent ) )
            {
                _fIconic = TRUE;
                InternetSetOption(NULL, INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS, NULL, NULL); 
                KillImgAnimTimerProc();
                if (_pCaret)
                {
                    ::DestroyCaret();
                }
            }
        }
        break;
                        
    default:

        if (msg == WM_MOUSEACTIVATE && _fPopupDoc)
        {
            *plResult = (LRESULT)MA_NOACTIVATE;
            break;
        }

#ifndef WIN16
        // different WM_MOUSEWHEEL message between Windows 95 and NT 40
        //
        if (msg != 0 && msg == g_msgMouseWheel)
        {
            POINT ptCursor;

            ::GetCursorPos(&ptCursor);
            wParam = MAKEWPARAM(HIWORD(wParam), LOWORD(wParam));
            lParam = MAKELPARAM(ptCursor.x, ptCursor.y);
            goto HandleMouseWheel;
        }
#endif // ndef WIN16
        if(msg == _g_msgHtmlGetobject)
        {
            // ActiveX "accessibility"
            OnAccGetObject(msg, wParam, lParam, plResult);
            hr = S_OK;  // Stop bubbling.
            break;
        }

#if !defined(NO_IME)
        if( (msg == _g_msgImeReconvert) && (_g_msgImeReconvert) )
        {
            goto ReconvertIME;
        }
#endif // !NO_IME

        //  All other messages get forwarded to the base class's
        //    window procedure.

        hr = THR(CServer::OnWindowMessage(msg, wParam, lParam, plResult));
        break;
    }

Cleanup:

#if DBG == 1
    if (msg == WM_PAINT || msg == WM_SETREDRAW)
    {
        TraceTag((tagPaintRedraw, "%x -%d %x %x",
                        this, msg, wParam, lParam));
    }
#endif

    // TODO should we come here with S_FALSE, or does that mean
    // defProc was not called when should?
    RRETURN1(hr, S_FALSE);

ReflectMessage:

    Assert(hwndControl);
    *plResult= SendMessage(
            hwndControl,
            msg + OCM__BASE,
            wParam,
            lParam);

    hr = S_OK;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::EnableDragDrop
//
//  Synopsis:   Register or revoke drag-drop as appropriate.
//
//-------------------------------------------------------------------------
void
CDoc::EnableDragDrop(DWORD_PTR dwContext)
{
    IDropTarget *   pDT;

    if (State() >= OS_INPLACE)
    {
        if (!THR_NOTRACE(GetDropTarget(&pDT)))
        {
            BOOL    fRegHostDT = FALSE;
            if (_pHostUIHandler)
            {
                IDropTarget *   pDTOut = NULL;

                if (!_pHostUIHandler->GetDropTarget(pDT, &pDTOut))
                {
                    //cache our Drop target so it can be restored if it's overwriten by a popup
                    _pDT = pDT;
                    _pDT->AddRef();

                    // Register host's drop target
                    IGNORE_HR(RegisterDragDrop(_pInPlace->_hwnd, pDTOut));
                    fRegHostDT = TRUE;
                }
                ReleaseInterface(pDTOut);
            }

            if (!fRegHostDT)
                IGNORE_HR(RegisterDragDrop(_pInPlace->_hwnd, pDT));

            pDT->Release();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnMouseMessage
//
//  Synopsis:   Handle WM_MOUSEMOVE, WM_LBUTTONDOWN and so on.
//
//----------------------------------------------------------------------------

HRESULT
CDoc::OnMouseMessage(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *plResult,
    int x, int y)
{
    HRESULT         hr  = S_OK;
    CMessage        Message(_pInPlace->_hwnd, msg, wParam, lParam);
    CTreeNode *     pNodeHit = NULL;
    CTreeNode *     pNodeNewMouse = NULL;
    long            lNewSubDivision;
    BOOL            fCapture;
    DWORD           dwHitTestFlags;
    ULONG           cDie = _cDie;
    CTreeNode::CLock *pLockNodeNewMouse = 0;

    Message.pt.x = x;
    Message.pt.y = y;

    //--------------------------------------------------------------------
    //
    // NOTE(SujalP and GaryBu):
    //
    // Normally, a button down implies a BecomeCurrent() which implies
    // a transition to the UIActive state. The BecomeCurrent() happens
    // in PumpMessage(). However, we do not call BecomeCurrent() when
    // the mouse goes down on a scrollbar. This is needed to fix bugs
    // like bug48127, where clicking on the scrollbar changes the current
    // site.
    //
    // However, if we do not perform BecomeCurrent() on the button down
    // in PumpMessage(), then we have to atleast transition of UIActive
    // otherwise we will break the frame case. Consider a doc with 2 frames.
    // Lets say the focus is on the left frame. The user now clicks on
    // the right frame scrollbar. The right frame will not call BecomeCurrent
    // because the hit was on the scrollbar and hence not even transition to
    // UIActive state. Hence, we do the transition here. Note that the
    // transition has to be on a button down (not on a button up -- as it
    // was done originally) because if the object takes capture then we
    // may not get the button up message at all (scrollbar are guilty of
    // this).
    //
    // If non-client area like scrollbars are hit, then under certain hosts
    // we do not want to become UIActive either. Consider the case of Athena
    // (bug33562) where clicking on the scrollbar, takes focus away from
    // the "To:" input box of Athena. To prevent us from taking focus, we
    // ask hosts such as Athena to turn on the following doc host flag:
    // DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY. Note that we will still take
    // focus if the hit were on the body (done by PumpMessage() as explained
    // earlier).
    //
    //--------------------------------------------------------------------

    if (   State() < OS_UIACTIVE
        && !(_dwFlagsHostInfo & DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY)
        && (   msg == WM_LBUTTONDOWN
            || msg == WM_RBUTTONDOWN
            || msg == WM_MBUTTONDOWN
           )
       )
    {
        // Do not fire onfocus on the current element, because the
        // current element may change because of the button down.
        _fInhibitFocusFiring = TRUE;
        TransitionTo(OS_UIACTIVE);
        _fInhibitFocusFiring = FALSE;
    }
    // We need to check to see that we really have the capture
    // because WM_CAPTURECHANGED is not sent on all platforms.
    fCapture = FALSE;
    dwHitTestFlags = 0;

    if (HasCapture())
    {
        fCapture = TRUE;
        
        dwHitTestFlags = HT_IGNORESCROLL | HT_NOGRABTEST;
    }

    //
    // Locate the "hit" element
    //

    Message.htc = HitTestPoint(
                     &Message,
                     &pNodeHit,
                     dwHitTestFlags);

    if( !fCapture && Message.htc == HTC_NO )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert( !pNodeHit || pNodeHit->IsInMarkup() );

    // IE6 bug 29944 - this is a workaround trying to 
    // fix this stress failure. This should not happen
    // however it is a safe bet to bail out at this point.
    if (pNodeHit && !pNodeHit->IsInMarkup())
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    hr = THR( Message.SetNodeHit( pNodeHit ) );
    if( hr )
        goto Cleanup;

    if( Message.pNodeHit )
        pNodeHit->Element()->SubDivisionFromPt(Message.ptContent, &Message.lSubDivision);
    
    pNodeNewMouse = Message.pNodeHit;
    lNewSubDivision = Message.lSubDivision;

        // $$ktam: Revisit ref-counting _pLCLastMouseOver like _pNodeLastMouseOver.

    {
        // don't let the hit-tested element go away til we're ready
        if (pNodeNewMouse)
        {
            pLockNodeNewMouse = new CTreeNode::CLock;
            hr = THR( pLockNodeNewMouse->Init(pNodeNewMouse) );
            if( hr )
                goto Cleanup;
        }
        
        {
            CTreeNode * pNodeOldOver = _pNodeLastMouseOver;
            CLayoutContext *pLCOldOver = _pLCLastMouseOver;
    
            //
            // Hand the message to the site.  However, if the htc is >= HTC_GRPTOPBORDER
            // we can just hand it off to the parent.  htc >= HTC_GRPTOPBORDER implies
            // a hit on the grab handles or border.
            //
    
            if ((Message.htc >= HTC_GRPTOPBORDER) && Message.pNodeHit->Element()->IsEditable(TRUE))
            {
                pNodeNewMouse = Message.pNodeHit->GetUpdatedParentLayoutNode();
                pNodeNewMouse = (pNodeNewMouse && Message.pNodeHit->Element()->IsInMarkup())
                                    ? pNodeNewMouse
                                    : Message.pNodeHit;
            }
    
    
            // Do not send MouseOver/MouseLeave messages in response to a
            // WM_SETCURSOR! WM_SETCURSOR is not a true mouse message and Windows
            // can send us this message any time it thinks the cursor needs to be
            // redrawn. This can cause nasty situations if the script handler for
            // MouseOver/MouseOut generates another WM_SETCURSOR message! See bug
            // 13590. (MohanB)
    
            // deal with the last element under mouse
            if (    Message.message != WM_SETCURSOR
                &&  State() >= OS_INPLACE
                &&  cDie == _cDie
                &&  _pNodeLastMouseOver
                &&  pNodeNewMouse
                &&  (   _pNodeLastMouseOver != pNodeNewMouse
                     || _lSubDivisionLast != lNewSubDivision)

                // Ignore transitions from master to slave and vice versa (39135)
                && !(       _pNodeLastMouseOver->Element()->HasMasterPtr()
                        &&  _pNodeLastMouseOver->Element()->GetMasterPtr() == pNodeNewMouse->Element()
                     ||     pNodeNewMouse->Element()->HasMasterPtr()
                        &&  pNodeNewMouse->Element()->GetMasterPtr() == _pNodeLastMouseOver->Element()
                    )
               )
            {
                CTreeNode * pNodeTo = pNodeNewMouse->Ancestor(ETAG_A);
    
                CMessage MessageOut(_pInPlace->_hwnd, WM_MOUSELEAVE, NULL, lParam);
                hr = THR( MessageOut.SetNodeHit( pNodeOldOver ) );
                if( hr )
                    goto Cleanup;
                MessageOut.pt.x = x;
                MessageOut.pt.y = y;
                MessageOut.lSubDivision = _lSubDivisionLast;
                MessageOut.pLayoutContext = pLCOldOver;
    
                // set up for the 'from' & 'to' event object parameters. This part
                // is tricky. we are firing and WM_MOUSEEXIT, the this pointer is
                // the 'from' element, the 'to' element is accessed by TEMPORARILY
                // putting it into the _pNodeLastMouseOver pointer (since it is
                // redundant with the this pointer anyhow). after this call to HM
                // (which assumes the _pelemlast.. is the 'to' pointer (see CElement::
                // FireStdEventOnMessage)) the _pNodeLastMouseOver is restored for
                // the remainder of the HM calls.
                _pNodeLastMouseOver = pNodeNewMouse;
                hr = THR( _pNodeLastMouseOver->NodeAddRef() );
                if( hr )
                    goto Cleanup;
                _pLCLastMouseOver = Message.pLayoutContext;
                // if the timer is set, we want to turn it off. otherwise it is possible
                //  that the _pNodeLastMouseOver will be Nulled out from under use (root
                //  cause of bug 21062)
                if (_fMouseOverTimer)
                {
                    FormsKillTimer(this, TIMER_ID_MOUSE_EXIT);
                    _fMouseOverTimer = FALSE;
                }

                hr = THR(PumpMessage(&MessageOut, pNodeOldOver));
                //restore to fire the message itself
                if (_pNodeLastMouseOver)
                    _pNodeLastMouseOver->NodeRelease();
    
                _pNodeLastMouseOver = pNodeOldOver;
                _pLCLastMouseOver = pLCOldOver;

                // Is this node no longer connected to the primary markup? (#30760)
                if (!_pNodeLastMouseOver->IsConnectedToPrimaryMarkup())
                {
                    _pNodeLastMouseOver->NodeRelease();
                    _pNodeLastMouseOver = NULL;
                }

                if (Message.pNodeHit && !Message.pNodeHit->IsConnectedToPrimaryMarkup())
                {
                    // The hit element got nuked! Get out now before we hurt ourselves!
                    goto Cleanup;
                }
    
                // if the element being hit is not an anchor or its child then show appropriate status text
                if (!pNodeTo)
                    (void)THR_NOTRACE(SetStatusText(NULL, STL_ROLLSTATUS));
            }
    
    
            // Watch for the mouse going off the window.
    
            if (!_fMouseOverTimer)
            {
                hr = THR(FormsSetTimer(this,
                       ONTICK_METHOD(CDoc, DetectMouseExit, detectmouseexit),
                       TIMER_ID_MOUSE_EXIT,
                       300));
                if (!hr)
                    _fMouseOverTimer = TRUE;
            }
    
            //
            //  Handle tooltips
            //
    
            if (Message.pNodeHit)
            {
                ShowTooltipHelper(this, Message.pNodeHit, &Message);
            }
    
            //TODO: This used to be working in IE4 (ie401)
            //          (Pri1 BUG: 7164)
            //  but crashing in IE5. seems related to some major changes
            //  We can no longer assume GetRootDoc()->_pInPlace to be valid
            //  any more. Therefore, we need to revisit this issue to make
            //  sure that all reference to _pInPlace are safe.
            if (!_pNodeLastMouseOver)
                IGNORE_HR(SetStatusText(NULL, STL_ROLLSTATUS));
    
            hr = THR(PumpMessage(&Message, pNodeNewMouse));

            // Fire the event unless the element got nuked in event handler!
            if (pNodeNewMouse && !pNodeNewMouse->IsDead() && pNodeNewMouse->IsInViewTree())
            {
                // Now fire MouseOver if applicable
                if (    Message.message != WM_SETCURSOR
                    &&  State() >= OS_INPLACE
                    &&  cDie == _cDie
                    &&  (   _pNodeLastMouseOver != pNodeNewMouse
                         || _lSubDivisionLast != lNewSubDivision)

                    // Ignore transitions from master to slave and vice versa (39135)
                    && !(   _pNodeLastMouseOver
                         && (
                                    _pNodeLastMouseOver->Element()->HasMasterPtr()
                                &&  _pNodeLastMouseOver->Element()->GetMasterPtr() == pNodeNewMouse->Element()
                             ||     pNodeNewMouse->Element()->HasMasterPtr()
                                &&  pNodeNewMouse->Element()->GetMasterPtr() == _pNodeLastMouseOver->Element()
                            )
                        )
                   )
                {
                    Assert(_pInPlace && _pInPlace->_hwnd);
                    CMessage MessageOut(_pInPlace->_hwnd, WM_MOUSEOVER, NULL, lParam);
                    hr = THR( MessageOut.SetNodeHit( pNodeNewMouse ) );
                    if( hr )
                        goto Cleanup;
                    MessageOut.pt.x = x;
                    MessageOut.pt.y = y;
                    MessageOut.lSubDivision = lNewSubDivision;
                    MessageOut.pLayoutContext = Message.pLayoutContext;
    
                    hr = THR(PumpMessage(&MessageOut, pNodeNewMouse));

                    if (pNodeNewMouse->IsDead() || !pNodeNewMouse->IsInViewTree())
                    {
                        Verify( !CTreeNode::ReplacePtr(&_pNodeLastMouseOver, NULL) );
                        _lSubDivisionLast = 0;
                        _pLCLastMouseOver = NULL;
                    }

                    // don't assign if this is the rootsite
                    else if (pNodeNewMouse->Element() != PrimaryRoot())
                    {
                        hr = THR( CTreeNode::ReplacePtr(&_pNodeLastMouseOver, pNodeNewMouse) );
                        if( hr )
                            goto Cleanup;
                        _lSubDivisionLast = MessageOut.lSubDivision;
                        _pLCLastMouseOver = MessageOut.pLayoutContext;
                    }
                }
            }
        }
    }

    //
    // Ensure that UI Active site matches the current site on mouse button up.
    //

    if ((msg == WM_LBUTTONUP || msg == WM_RBUTTONUP || msg == WM_MBUTTONUP) &&
        (_pElemUIActive != _pElemCurrent) &&
        (cDie == _cDie ) && 
        (State() >= OS_INPLACE ))
    {
        _pElemCurrent->BecomeUIActive();
    }

    if (msg != WM_MOUSEMOVE && msg != WM_SETCURSOR)
    {
        DeferUpdateUI();
    }

Cleanup:
    if  (pLockNodeNewMouse)
    {
        delete pLockNodeNewMouse;
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Member: FireMouseOverTest
//
// Sysnopsis:  Timer Callback. this function's job is to detect when a mouse move
//      has taken us outside the client rectl. when that is detected, we fire
//      an exit message.
//              in any case we clear the doc flag, and we kill the timer.
//
//-----------------------------------------------------------------------------

HRESULT BUGCALL
CDoc::DetectMouseExit( UINT uTimerID)
{
    HRESULT hr = S_OK;

    if (    !_fInhibitOnMouseOver
        &&  !HasCapture()
        &&  State() >= OS_INPLACE)
    {
        POINT     ptMouse;
        HWND      hwndMouse;

        GetCursorPos(&ptMouse);

        if ((hwndMouse = WindowFromPoint(ptMouse)) != NULL
            && hwndMouse != _pInPlace->_hwnd
            && !IsDuringDrag())
        {
            if (::IsChild(_pInPlace->_hwnd, hwndMouse))
            {
                LRESULT lResult;

                // We always send mousemove messages to the document so 
                // the onmouseover/out events will get fired correctly. 
                MapWindowPoints(NULL, _pInPlace->_hwnd, &ptMouse, 1);
                IGNORE_HR(OnWindowMessage(WM_MOUSEMOVE, 0, 
                    MAKELPARAM(ptMouse.x, ptMouse.y),  &lResult));
            }
            else if (_pNodeLastMouseOver)
            {
                CMessage  Message(_pInPlace->_hwnd, WM_MOUSELEAVE, NULL, NULL);
                CTreeNode * pNode = _pNodeLastMouseOver;

                hr = THR( Message.SetNodeHit( pNode ) );
                if( hr )
                    goto Cleanup;
                Message.pt.x = -1;      // we know we are outside client rect
                Message.pt.y = -1;
                Message.pLayoutContext = _pLCLastMouseOver;

                // Don't need timer any more.

                FormsKillTimer(this, uTimerID);
                _fMouseOverTimer = FALSE;

                // Set this first in order to properly fill the EVENTPARAM from,to

                _pNodeLastMouseOver = NULL;
                _pLCLastMouseOver = NULL;
                _lSubDivisionLast = 0;
            
                IGNORE_HR(PumpMessage(&Message, pNode));

                // Release our addref on the lastmouseoverelem.

                pNode->NodeRelease();
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::OnHelp
//
//  Synopsis:   Handle keboard messages
//
//----------------------------------------------------------------------------

//#ifndef WIN16
HRESULT
CDoc::OnHelp(HELPINFO *phi)
{
    HRESULT hr      = S_FALSE;
    LRESULT lResult = TRUE;

    // If the F1 key is down or the mouse is not down, then treat it
    // like a keyboard message. Otherwise, treat it like a mouse message.

    if ((GetKeyState(VK_F1) & 0x8000) || !(GetKeyState(VK_LBUTTON) & 0x8000))
    {
        // give a chance to ShowHelp which calls IDocHostShowUI; if that failed,
        // show help ourselves
        if (S_OK != ShowHelp(NULL, 0, 0, g_Zero.pt))
        {
            CMessage Message(_pInPlace->_hwnd, WM_HELP, 0, (LPARAM)phi);

            hr = THR(PumpMessage(&Message, _pElemCurrent->GetFirstBranch()));
        }
    }
    else
    {
#ifndef WIN16
        POINT pt = phi->MousePos;
#else
        POINT pt;
        pt.x = (phi->MousePos).x;
        pt.y = (phi->MousePos).y;
#endif

        ScreenToClient(_pInPlace->_hwnd, &pt);
        hr = THR(OnMouseMessage(
                WM_HELP,
                0,
                (LPARAM)phi,
                &lResult,
                pt.x, pt.y));
    }

    RRETURN1(hr, S_FALSE);
}
//#endif // !WIN16

//+--------------------------------------------------------------------------
//
//  Member:     CDoc::OnCommand
//
//  Synopsis:   Handle WM_COMMAND
//
//----------------------------------------------------------------------------

void
CDoc::OnCommand(int idm, HWND hwndCtl, UINT code)
{
    BOOL fRestoreFocus = FALSE;

#if DBG==1
    switch (idm)
    {
    case IDM_DEBUG_TRACETAGS:
        DbgExDoTracePointsDialog(FALSE);
        return;

    case IDM_DEBUG_RESFAIL:
        DbgExShowSimFailDlg();
        return;

    case IDM_DEBUG_DUMPOTRACK:
        DbgExTraceMemoryLeaks();
        return;

    case IDM_DEBUG_BREAK:
        DebugBreak();
        return;

    case IDM_DEBUG_VIEW:
        DbgExOpenViewObjectMonitor(_pInPlace->_hwnd, (IUnknown *)(IViewObject *) this, TRUE);
        return;
    }
#endif

        //
        // These are the cases which can be handled by Exec().
        //

        VARIANTARG *pvarIn  = NULL;
        if( idm >= IDM_MIMECSET__FIRST__ && idm <= IDM_MIMECSET__LAST__ )
        {
            CODEPAGE cp = GetCodePageFromMenuID(idm);
            if (CP_UNDEFINED != cp && PrimaryMarkup()->GetCodePage() != cp)
            {
                PrimaryMarkup()->SwitchCodePage(cp);

                if (_pClientSite)
                {
                    // Let shdocvw know about it
                    VARIANT var;

                    V_VT(&var) = VT_I4;
                    V_I4(&var) = cp;

                    CTExec(_pClientSite, &CGID_ShellDocView, SHDVID_ONCODEPAGECHANGE,
                           0, &var, NULL);
                }

                IGNORE_HR(_pWindowPrimary->ExecRefresh());
            }
            return;
        }
        Exec((GUID *)&CGID_MSHTML, idm, 0, pvarIn, NULL);

        // When the user selects a combo item, pop the focus pack into the document.

        if (fRestoreFocus)
        {
            ::SetFocus (_pInPlace->_hwnd);
        }
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::OnAccGetObject
//
//  Synopsis:   Handles receipt of the WM_GET_HTML_OBJECT by the form
//
//  Input:      msg
//              wParam  Opaque, pass through.
//              lParam  idObject from NotifyWinEvent.
//
//  Returns:    LRESULT containing a IAccessible object.
//
//  Notes:      This must work in concert with the corresponding NotifyWinEvents,
//              which must pass the address of the object in idObject.
//
//-------------------------------------------------------------------------

void
CDoc::OnAccGetObject(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
#if !defined(_MAC) && !defined(WIN16)
    HRESULT hr;

    static DYNPROC s_dynprocLresultFromObject =
            { NULL, &g_dynlibOLEACC, "LresultFromObject" };

    if (!plResult)
        goto Cleanup;

    // Load up the LresultFromObject pointer.
    hr = THR(LoadProcedure(&s_dynprocLresultFromObject));
    if (hr)
    {
        goto Cleanup;
    }

    // Convert the punk into an lresult, which is an OS means of
    // converting the punk into a handle that can be marshalled.

    // Note: Although this returns an interface pointer, we do not
    // addref it here.  copy semantics are inplace for the lresult 
    // so this function does the requisite stuff

    //  pass out the _OmDocument, this is necessary to handle QI's (et al)
    //  properly when we are in the webbrowser.ocx and other aggregating
    //  hosts.

    *plResult = (*(LRESULT (APIENTRY *)(REFCLSID, WPARAM, IUnknown *))
            s_dynprocLresultFromObject.pfn)(IID_IHTMLDocument2, 
                                            wParam, 
                                            (IUnknown*)_pWindowPrimary->Document());

Cleanup:
#endif
    return;
}

//+--------------------------------------------------
//
//   member : OnAccGetObjectIncontenxt
//
//  Synopsis : WM_GETOBJECT processing
//          rather than passing the document pointer to oleacc
//        for them to cocreate the proxy, we can create the proxy
//        ourselves and thus save lots of work by not marshalling 
//
//
//------------------------------------------------------
// Note: lParam is intentionaly declared as a LONG since 
// Objids are 32bits everywhere (according to brendanm)
// and Win64 fills differently the upper 64bits of the
// LPARAM depending on the caller beign 32bits or 64bits
void
CDoc::OnAccGetObjectInContext (UINT msg, 
                              WPARAM wParam, 
                              LONG lParam, 
                              LRESULT *plResult)
{
#if !defined(_MAC) && !defined(WIN16)
    HRESULT         hr = S_OK;
    CAccBase *      pAccObj = NULL;
    ACCEVTRECORD    accEvtRec;

    static DYNPROC s_dynprocLresultFromObject =
            { NULL, &g_dynlibOLEACC, "LresultFromObject" };

    if (!plResult)
        goto Cleanup;

    // Load up the LresultFromObject pointer.
    hr = THR(LoadProcedure(&s_dynprocLresultFromObject));
    if (hr)
    {
        goto Cleanup;
    }

    if ( (lParam == OBJID_WINDOW) || (lParam == OBJID_CLIENT))
    {
        CWindow * pWindow = _pWindowPrimary->Window();
        
        //check if this document has a Window Accessible object associated with it.
        //if not, create one, else AddRef and return the existing one.
        hr = EnsureAccWindow(pWindow);
        if (hr)
            goto Cleanup;

        pAccObj = pWindow->_pAccWindow;
    }
    else if (lParam > 0)
    {
        hr = _aryAccEvents.GetAccEvtSource(lParam, &accEvtRec);
        if (hr)
            goto Cleanup;

        Assert(accEvtRec.pObj);

        // The base object can be a window or an element
        // We will only release the additional reference we have on the element
        // once we have created the accessible object for it, since the reference
        // we have may be the only reference left.
        if (accEvtRec.fWindow)
        {
            hr = EnsureAccWindow(DYNCAST(CWindow, accEvtRec.pObj));
            if (hr)
                goto Cleanup;

            pAccObj = DYNCAST(CWindow, accEvtRec.pObj)->_pAccWindow;
        }
        else
        {
            CElement * pElement = DYNCAST(CElement, accEvtRec.pObj);

            // if an element is out of a markup, don't try to return a pointer to it at all.
            if (pElement->HasMarkupPtr())
            {
                // Ensure the accwindow object for this element.
                if (EnsureAccWindow(pElement->GetCWindowPtr()))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                pAccObj = GetAccObjOfElement(pElement);
                if (!pAccObj)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }
    // else is cases such as the title bar window, system menu window etc. 
    // all have negative handles used by OLEACC.

    // Convert the punk into an lresult, which is an OS means of
    // converting the punk into a handle that can be marshalled.

    // Note: Although this returns an interface pointer, we do not
    // addref it here.  There will be an addref performed when the
    // caller call ObjectFromLresult. (This isn't in the documentation,
    // but LauraBu swears it happens.)
    //
    // Of course, this is craziness, because if the object we return
    // is deallocated before the client calls ObjectFromLResult, someone
    // is in trouble. Laura replies that inproc clients always call
    // immediately, and out-of-proc clients somehow deal with it.

    if ( pAccObj )
    {
        *plResult = (*(LRESULT (APIENTRY *)(REFCLSID, WPARAM, IUnknown *))
                s_dynprocLresultFromObject.pfn)(IID_IAccessible, 
                                                wParam, 
                                                (IAccessible *)pAccObj);
    }

Cleanup:

    // we want to bail not fail.  if ANY error happens we want to pretend nothing 
    //  was ever processed, and that the WM_GETOBJECT was never handled to begin 
    //  with. 
    if (hr || (plResult && FAILED(*plResult)))
        *plResult = S_OK;

#endif
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ActivateDefaultButton, protected
//
//  Synopsis:   Activate the default button on the form, if any
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ActivateDefaultButton(LPMSG lpmsg)
{
    HRESULT         hr = S_FALSE;
    CElement *      pElem;   

    //  The container of this form is always given precedence,
    //    unless the currently active control is a "Push" button

    if (_pElemCurrent && _pElemCurrent->_fActsLikeButton)
    {
        pElem = _pElemCurrent;
        hr = S_OK;
    }
    else
    {
        pElem = _pElemCurrent->FindDefaultElem(TRUE);
    }

    if (pElem)
    {
        Assert(!pElem->IsEditable(/*fCheckContainerOnly*/TRUE));
        Assert(pElem->_fDefault);

        //  TODO error dialog?
        _fFirstTimeTab = FALSE;
        hr = THR(pElem->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
        if (hr)
            goto Cleanup;

        hr = THR(pElem->DoClick());
    }
    else
    {
        hr = S_FALSE;
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ActivateCancelButton, protected
//
//  Synopsis:   Activate the cancel button on the form, if any
//
//----------------------------------------------------------------------------

HRESULT
CDoc::ActivateCancelButton(LPMSG lpmsg)
{
    HRESULT     hr = S_FALSE;
    CElement *  pElem = _pElemCurrent;
    
    if (!pElem)
        goto Cleanup;

    if (!pElem->TestClassFlag(CElement::ELEMENTDESC_CANCEL))
    {
        // find cancel site
        pElem = _pElemCurrent->FindDefaultElem(FALSE, TRUE);
    }
    if (!pElem)
        goto Cleanup;

    Assert(!pElem->IsEditable(/*fCheckContainerOnly*/TRUE));

    _fFirstTimeTab = FALSE;
    hr = THR(pElem->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
    if (!hr)
    {
        hr = THR(pElem->DoClick());
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::InvalidateDefaultSite
//
//  Synopsis:   Invalidate the current site
//
//----------------------------------------------------------------------------

HRESULT
CDoc::InvalidateDefaultSite()
{
    CElement * pElemDefault;
    if (!_pElemCurrent->IsEditable(/*fCheckContainerOnly*/TRUE) && !_pElemCurrent->_fDefault)
    {
        pElemDefault = _pElemCurrent->FindDefaultElem(TRUE);
        if (pElemDefault && pElemDefault != _pElemCurrent)
        {
            pElemDefault->Invalidate();
        }
    }

    RRETURN(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::FixZOrder
//
//  Synopsis:   Inserts the given site's window at the proper place in
//              physical Z order, given the site's position in the logical
//              Z order as well as its current OLE state
//
//-------------------------------------------------------------------------
void
CDoc::FixZOrder()
{
    _view.SetFlag(CView::VF_DIRTYZORDER);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetZOrder
//
//  Synopsis:   Moves the current selection in the logical Z order.
//
//  Arguments:  [zorder]    action
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetZOrder(int zorder)
{
    CLayout *   pLayoutCurrent = _pElemCurrent->GetUpdatedLayout();


    if (!pLayoutCurrent)
        goto Cleanup;


    FixZOrder();
    Invalidate();

    //  TODO send OnDataChange?

Cleanup:
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ShowErrorDialog
//
//-------------------------------------------------------------------------
HRESULT
CWindow::ShowErrorDialog(VARIANT_BOOL *pfRet)
{
    HRESULT hr = S_OK;
    VARIANT varIn;
    CVariant varOut;
    CDoc * pDoc = Doc();
    CDoEnableModeless dem(pDoc, this);

    if (pDoc->_dwLoadf & DLCTL_SILENT)
        goto Cleanup;    

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)(IPrivateUnknown *) Document();

    if (pDoc->_pHostUICommandHandler && !pDoc->_fOutlook98)
    {
        hr = pDoc->_pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                OLECMDID_SHOWSCRIPTERROR,
                0,
                &varIn,
                &varOut);
        if (!hr)
            goto Cleanup;
    }

    pDoc->EnsureBackupUIHandler();
    if (pDoc->_pBackupHostUIHandler)
    {
        IOleCommandTarget * pBackupHostUICommandHandler;

        hr = pDoc->_pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                (void **) &pBackupHostUICommandHandler);
        if (hr)
            goto Cleanup;

        hr = pBackupHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                OLECMDID_SHOWSCRIPTERROR,
                0,
                &varIn,
                &varOut);

        ReleaseInterface(pBackupHostUICommandHandler);
    }

Cleanup:
    if (V_VT(&varOut) == VT_BOOL)
        *pfRet = V_BOOL(&varOut);   
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ShowContextMenu
//
//  Synopsis:   Returns the context menu based on the sub-menu id.
//
//-------------------------------------------------------------------------

HRESULT
CDoc::ShowContextMenu(
        int x,
        int y,
        int id,
        CElement * pMenuObject)
{
    HRESULT                 hr = S_FALSE;   // Assume we keep bubbling.
#ifndef NO_MENU
    IOleCommandTarget *     pCommandTarget = NULL;
    IDispatch *             pDispatch = NULL;
    CElement::CLock         lock(pMenuObject);
    GDIPOINT                pt;
    BOOL                    fSkipHostUIHandler;

    _fDisableReaderMode = TRUE;
    _pMenuObject = pMenuObject;
   
    pt.x = x;
    pt.y = y;

    // DEBUG menu is only valid in debug builds. 
    if (GetAsyncKeyState(VK_CONTROL) < 0)
    {    
#if DBG==1 && !defined(WINCE)     
        id = CONTEXT_MENU_DEBUG;
#else
        if (id == CONTEXT_MENU_DEBUG)
            goto Cleanup;
#endif
    }


    // Query the host UIHandler to handle the context menu
    hr = THR(QueryInterface(
            IID_IOleCommandTarget,
            (void **) &pCommandTarget));
    if (hr)
        goto Cleanup;

    if (pMenuObject)
    {
        pMenuObject->QueryInterface(
                IID_IDispatch,
                (void **) &pDispatch);
    }
    
    // if pMenuObject==NULL or doesn't support IDispatch
    // then default to the document's IDispatch
    if (!pDispatch)
    {
        hr = THR(QueryInterface(
                IID_IDispatch,
                (void **) &pDispatch));
        if (hr)
            goto Cleanup;
    }

    
    // for active desktop items, trident is directly hosted by shell32, which also handles context menus
    // if we are in an active desktop item, we want trident context menus not shell context menus, 
    // so we need to bypass the shell32 UI handler
    fSkipHostUIHandler = DocIsDeskTopItem(this) && pMenuObject && !pMenuObject->IsInPrimaryMarkup();


    if (    !fSkipHostUIHandler
#if DBG==1
        &&  id != CONTEXT_MENU_DEBUG           // Don't let hosts override debug menu                 
#endif        
       )
    {
        if (_pHostUIHandler)
        {
            _fInhibitOnMouseOver = TRUE;
            hr = _pHostUIHandler->ShowContextMenu(
                id,
                (POINT *)&pt,           //cast is for win16, doesn't affect 32bit.
                pCommandTarget,
                pDispatch);
            
            _fInhibitOnMouseOver = FALSE;

            // Host has displayed context menu, forms3 will not display it.
            if (!hr)
                goto Cleanup;
        }
    }

    // If we don't allow a selection, don't allow a contex menu either
    // More detail: We want to disallow context menus on everything that
    // matched the following conditions:
    //      1. we're in a dialog.
    //      2. we're not an text input control (textbox, textarea, etc).
    // DisallowSelection checks if we're in a dialog and if the layout
    // has the _fAllowSelectionInDialog bit set. That bit is currently only
    // set on textareas, htmlareas, and text inputs.
    if (pMenuObject->DisallowSelection())
    {
        hr = S_OK;
        goto Cleanup;
    }

    
    // Either we don't have a _pHostUIHandler, or it didn't return S_OK.  Go to our backup.
    EnsureBackupUIHandler();     
    if (_pBackupHostUIHandler)    
    {
        _fInhibitOnMouseOver = TRUE;
        hr = THR(_pBackupHostUIHandler->ShowContextMenu(        
            id,            
            (POINT *)&pt,           //cast is for win16, doesn't affect 32bit.           
            pCommandTarget,            
            pDispatch));

        _fInhibitOnMouseOver = FALSE;
        
        // Backup has displayed context menu        
        hr = S_OK;
        goto Cleanup;
    }     
    

Cleanup:
    _pMenuObject = NULL;
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pDispatch);

    _fDisableReaderMode = FALSE;

#endif // NO_MENU
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::InsertMenuExt
//
//  Arguments:  hMenu       The menu to insert in
//
//  Synopsis:   Takes the hMenu passed in and then adds a separator
//              followed by all of the menu extensions.  These are
//              insterted if and where IDM_MENUEXT_PLACEHOLDER is.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

DeclareTag(tagMenuExt, "MenuExt", "Menu Extensions");

HRESULT
CDoc::InsertMenuExt(HMENU hMenu, int id)
{
    HRESULT     hr = S_OK;
    int         nExts;

    Assert(IsMenu(hMenu));

    // If our placeholder is gone or was never there, then just exit
    if(GetMenuState(hMenu, IDM_MENUEXT_PLACEHOLDER, MF_BYCOMMAND) == (UINT) -1)
    {
        goto Cleanup;
    }

    //
    // Add the context menu extensions
    //
    nExts = _pOptionSettings->aryContextMenuExts.Size();
    if(nExts != 0)
    {
        CONTEXTMENUEXT **   ppCME;
        int                 nExtCur = 0;
        int                 nExtFirst = 0;

        // Limit the number of extensions
        if(nExts > IDM_MENUEXT_LAST__ - IDM_MENUEXT_FIRST__)
        {
            nExts = IDM_MENUEXT_LAST__ - IDM_MENUEXT_FIRST__;
        }

        TraceTag((tagMenuExt, "%d menu exts", nExts));

        //
        // Add each of the extensions
        //

        for(ppCME = _pOptionSettings->aryContextMenuExts;
            nExtCur < nExts;
            nExtCur++, ppCME++)
        {
            if((*ppCME)->dwContexts & (0x1 << id))
            {
                Assert(IDM_MENUEXT_FIRST__ + nExtCur <= IDM_MENUEXT_LAST__);

                TraceTag((tagMenuExt, "Inserting %d: %ls",
                          IDM_MENUEXT_FIRST__ + nExtCur,
                          (LPTSTR)(*ppCME)->cstrMenuValue));

                if(!InsertMenu(hMenu,                           // The Context Menu
                               IDM_MENUEXT_PLACEHOLDER,         // The item to insert before
                               MF_BYCOMMAND|MF_STRING,          // by item ident and str value
                               IDM_MENUEXT_FIRST__ + nExtCur,   // the command id
                               (LPTSTR)(*ppCME)->cstrMenuValue))// The menu name
                {
                    hr = GetLastWin32Error();
                    goto Cleanup;
                }

                if(!nExtFirst)
                {
                    nExtFirst = IDM_MENUEXT_FIRST__ + nExtCur;
                }
            }
        }

        //
        // Add a separator if necessary
        //

        if(nExtFirst)
        {
            if(!InsertMenu(hMenu,                       // The context menu
                           nExtFirst,                   // The item to insert before
                           MF_BYCOMMAND|MF_SEPARATOR,   // by item ident
                           0,                           // the command id
                           NULL))                       // type value
            {
                hr = GetLastWin32Error();
                goto Cleanup;
            }
        }
    }

    //
    // Remove our placeholder
    //

    if(!DeleteMenu(hMenu,                   // The context menu
                   IDM_MENUEXT_PLACEHOLDER, // The item to delete
                   MF_BYCOMMAND))           // by item ident
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ShowDragContextMenu
//
//  Synopsis:   Shows the drag context menu upon a right button drop.
//
//  Arguments:  ptl           Where to pop the menu up
//              dwAllowed     Allowed actions for drag
//              piSelection   The choice selected by the menu.
//
//  Returns:    If the user selected a choice on the menu, S_OK.
//              If the menu was brought down, S_FALSE, errors otherwise.
//
//-------------------------------------------------------------------------
HRESULT
CDoc::ShowDragContextMenu(POINTL ptl, DWORD dwAllowed, int *piSelection, LPTSTR lptszFileType)
{
#ifdef NO_DRAGDROP
    return S_OK;
#else
    HRESULT                     hr;

    HMENU   hMenu;
    HMENU   hCtxMenu;
    HCURSOR hOldCursor;
    HCURSOR hArrow = LoadCursor(NULL, IDC_ARROW);

    if(hArrow == NULL)
        RRETURN(GetLastError());

    hMenu = TW32(0, LoadMenu(GetResourceHInst(), MAKEINTRESOURCE(IDR_DRAG_CONTEXT_MENU)));
    if (!hMenu)
        RRETURN(GetLastWin32Error());

    hCtxMenu = GetSubMenu(hMenu, 0);

    // Modify the sub menu based on whether particular choices are
    // available.
    if (!(dwAllowed & DROPEFFECT_MOVE) || (_fFromCtrlPalette))
    {
        EnableMenuItem(hCtxMenu,
            DROPEFFECT_MOVE,
            MF_BYCOMMAND | MF_GRAYED);
    }
    if (!(dwAllowed & DROPEFFECT_COPY))
    {
        EnableMenuItem(hCtxMenu,
            DROPEFFECT_COPY,
            MF_BYCOMMAND | MF_GRAYED);
    }

    //
    // Get the old cursor, and make new cursor into arrow
    //
    hOldCursor = ::SetCursor(hArrow);

    hr = THR(FormsTrackPopupMenu(
            hCtxMenu,
            TPM_LEFTALIGN | TPM_RIGHTBUTTON,
            ptl.x + CX_CONTEXTMENUOFFSET,
            ptl.y + CY_CONTEXTMENUOFFSET,
            NULL,
            piSelection));

    // Now set back the old cursor
    ::SetCursor(hOldCursor);

    RRETURN1(hr, S_FALSE);
#endif // NO_DRAGDROP
}

#if DBG == 1
#ifndef UNIX

DeclareTag(tagZOrder, "ZOrder", "Form ZOrder information");

#define GetWinText(hwnd, sz, cch) if (!GetWindowText(hwnd, sz, cch)) _tcscpy(sz, _T("(null)"));

void
DisplayChildZOrder(HWND hwnd)
{
    TCHAR szClass[255], szTitle[255];
    LONG  lStyle;

    if (!hwnd)
        return;

    GetClassName(hwnd, szClass, 255);
    GetWinText(hwnd, szTitle, 255);

    TraceTag((tagZOrder, "Parent Window: %p, %ls, %ls", hwnd, szClass, szTitle));

    HWND hwndChild = GetWindow(hwnd, GW_CHILD);

    if (!hwndChild)
    {
        TraceTag((tagZOrder, "No Child Windows!"));
        return;
    }

    GetClassName(hwndChild, szClass, 255);
    GetWinText(hwndChild, szTitle, 255);
    lStyle = GetWindowLong(hwndChild, GWL_EXSTYLE);

    TraceTag((tagZOrder, "Highest Child Window: %p, %ls, %ls%ls",
                   hwndChild, szClass, szTitle,
                   (lStyle & WS_EX_TOPMOST) ? _T(" (Topmost)") : _T("")
                   ));

    while ((hwndChild = GetWindow(hwndChild, GW_HWNDNEXT)) != NULL)
    {
        GetClassName(hwndChild, szClass, 255);
        GetWinText(hwndChild, szTitle, 255);
        lStyle = GetWindowLong(hwndChild, GWL_EXSTYLE);

        TraceTag((tagZOrder, "   Next Child Window: %p, %ls, %ls%ls",
                       hwndChild, szClass, szTitle,
                       (lStyle & WS_EX_TOPMOST) ? _T(" (Topmost)") : _T("")
                       ));
    }

    return;
}
#else
void
DisplayChildZOrder(HWND hwnd)
{}
#endif // !UNIX
#endif // DBG

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::HasCapture
//
//  Synopsis:   
//
//----------------------------------------------------------------------------

BOOL CDoc::HasCapture(CElement *pElement)
{
    if (!_pInPlace)
        return FALSE;

    if (!pElement)
    {
        if (_aryStackCapture.Size())
        {
            Assert(GetCapture());
            return TRUE;
        }
    }
    else
    {
        int i, lSizeStack = _aryStackCapture.Size();

        for ( i = 0; i < lSizeStack; i ++ )
        {
            if (_aryStackCapture[i]->_pElement == pElement)
            {
                Assert(GetCapture());
                return TRUE;
            }
        }
    }
    return GetCapture();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetMouseCapture
//
//  Synopsis:   Mouse capture utilities.
//
//----------------------------------------------------------------------------

void CDoc::SetMouseCapture(
    PFN_ELEMENT_MOUSECAPTURE   pfnTo,
    CElement                *pElement,
    BOOL                    fContainer,
    BOOL                    fFireOnNodeHit)
{
    int i;
    int lSizeStack = _aryStackCapture.Size();
    CElementCapture *pCapture;

    TraceTag((tagCapture, "SetCapture %x %x %ls-%d  fCont: %d  _fOnLose: %d",
            this, pElement, (pElement ? pElement->TagName() : L"null"),
            (pElement ? pElement->SN() : 0), fContainer, _fOnLoseCapture));

    if (_fOnLoseCapture)
    {
        //
        // make sure we empty the whole capture array
        //
        pElement = NULL;
    }

    if (!pElement)
    {
        //
        // request for a full capture release
        //

        if (lSizeStack)
        {
            for (i = lSizeStack - 1; i >= 0; i --)
            {
                if (    !_aryStackCapture[i]->_fFiredEvent
                    &&  !_aryStackCapture[i]->_pElement->_fExittreePending)
                {
                    _aryStackCapture[i]->_fFiredEvent = TRUE;
                    _fOnLoseCapture = TRUE;
                    
                    _aryStackCapture[i]->_pElement->Fire_onlosecapture();
                   
                    _fOnLoseCapture = FALSE;
                }
                //
                // during the event firing, the stack might be insane
                //
                lSizeStack = _aryStackCapture.Size();

                //
                // if insane
                // go out of the loop
                //

                if (!lSizeStack)
                    break;
                
                delete _aryStackCapture[i];
            }
            _aryStackCapture.DeleteAll();
        }

        if (    State() < OS_INPLACE
            &&  ::GetCapture() == _hwndCached)
        {
            // NOTE(sujalp): When we are no longer inplace, but we
            // may still have our window around in CDoc::hwndCached.
            // Check if this window has the capture and if it does
            // then release the capture. If not then, probably some
            // other window has captured the mouse so do not release it.
#if DBG==1
            Assert(!TLS(fHandleCaptureChanged));
#endif
            ::ReleaseCapture();
        }
        else
        {
            SetCapture(FALSE);
        }
        return;
    }

    //
    // verify if pElement has the capture, if so, do nothing
    //

    for (i = lSizeStack-1; i >= 0 && _aryStackCapture[i]->_pElement != pElement; i--);

    if (i >= 0)
        return;

    //
    // Add the new capture object
    //

    CElementCapture *pCaptureNew = new CElementCapture(pfnTo, pElement, fContainer, fFireOnNodeHit);

    if (!pCaptureNew)
        return;

    pCapture = GetLastCapture();

    //
    // Container capture means that the element takes
    // the capture and all mouse messages/events should
    // be targeting to it.
    // When the capture is not a container capture, events
    // will be targeting to the elements scoped inside it
    //

    if (!pCapture || !HasContainerCapture(pElement->GetFirstBranch()))
    {
        //
        // the Doc doesn't have container capture
        // push the capture in the stack
        //
        IGNORE_HR(_aryStackCapture.Append(pCaptureNew));
        if (!pCapture)
        {
            SetCapture(TRUE);
        }
        return;
    }
    //
    //
    // If we've got a capture object which is different from the argument
    // object, tell it that we're losing capture
    // 
    CMessage Message((MSG *)NULL);

    Message.message = WM_CAPTURECHANGED;

    // Tell the captured object that it's losing the capture
    IGNORE_HR( PumpMessage(&Message, NULL) );

    //
    // delete the previous capture if it is not Container Capture
    // has to do the container part
    //

    if (!pCapture->_fFiredEvent && !pCapture->_pElement->_fExittreePending)
    {
        pCapture->_fFiredEvent = TRUE;
        _fOnLoseCapture = TRUE;

        pCapture->_pElement->Fire_onlosecapture( );

        _fOnLoseCapture = FALSE;
    }

    //
    // during the event firing, the stack might be insane
    // if insane
    // don't do any capture work
    //

    if (!_aryStackCapture.Size())
    {
        delete pCaptureNew;
        return;
    }

    delete pCapture;
    _aryStackCapture.Delete(lSizeStack - 1);

    IGNORE_HR(_aryStackCapture.Append(pCaptureNew));
}

//+--------------------------------------------------------------------------
//
//  Member:     CDoc::ClearMouseCapture
//
//  Synopsis:   Releases the capture object without notification. Used by
//              objects to revoke their own capture.
//              if pvObject is NULL, we will release all captures
//
//---------------------------------------------------------------------------

void
CDoc::ClearMouseCapture(CElement *pElement)
{
    int lSizeStack2, lSizeStack = _aryStackCapture.Size();
    int i, j;

    if (!lSizeStack)
        return;

    if (!pElement || _aryStackCapture[0]->_pElement == pElement)
    {
        SetMouseCapture(NULL, NULL);
        return;
    }

    //
    // Search for the capture element
    //
    
    for (i = lSizeStack-1; i > 0 && _aryStackCapture[i]->_pElement != pElement; i--);

    if (i == 0)
        return;

    Assert(lSizeStack > 1);
    j = i;

    for (i = lSizeStack - 1; i >= j; i --)
    {
        if (    !_aryStackCapture[i]->_fFiredEvent
            &&  !_aryStackCapture[i]->_pElement->_fExittreePending)
        {
            _aryStackCapture[i]->_fFiredEvent = TRUE;
            _fOnLoseCapture = TRUE;

            _aryStackCapture[i]->_pElement->Fire_onlosecapture( );
            
            _fOnLoseCapture = FALSE;
        }
        //
        // during the event firing, the stack might be insane
        //
        lSizeStack2 = _aryStackCapture.Size();

        //
        // if insane
        // go out of the loop
        //

        if (!lSizeStack2)
            return;
        delete _aryStackCapture[i];
    }
    _aryStackCapture.DeleteMultiple(j, lSizeStack - 1);

    //
    // Since there is still at least one capture object in the stack
    // we don't release window capture
    //
}

//+--------------------------------------------------------------------------
//
//  Member:     CDoc::ReleaseDetachedCaptures
//
//  Synopsis:   Releases the capture object which is no longer in the tree
//
//---------------------------------------------------------------------------

void
CDoc::ReleaseDetachedCaptures()
{
    int lSizeStack = _aryStackCapture.Size();
    int i, j;

    if (!lSizeStack)
        return;

    if (!_aryStackCapture[0]->_pElement->GetFirstBranch())
    {
        SetMouseCapture(0, 0);
        return;
    }

    for ( i = 1; i < lSizeStack && _aryStackCapture[i]->_pElement->GetFirstBranch(); i ++ );

    if (i == lSizeStack)
        return;

    j = i;

    for (; i < lSizeStack; i ++ )
    {
        delete _aryStackCapture[i];
    }
    _aryStackCapture.DeleteMultiple(j, lSizeStack - 1);
}

CElementCapture * CDoc::GetLastCapture()
{
    int iSize = _aryStackCapture.Size();

    if (!iSize)
        return NULL;

    return _aryStackCapture[iSize - 1];
}
 
CElementCapture::CElementCapture(PFN_ELEMENT_MOUSECAPTURE pfn, CElement *pElem, BOOL fContainer, BOOL fFireOnNodeHit)
{
    //
    // Args must be either both NULL == Release capture
    // Or both non-null == Set capture
    //
    // AssertSz(pfn && pElem || !pfn && !pElem, "Bad Arguments");

    _pfn        = pfn;
    _pElement   = pElem;

    Assert (_pElement);
    _pElement->AddRef();
    _fContainer = fContainer;
    _fFiredEvent = FALSE;
    _fFireOnNodeHit = fFireOnNodeHit;
}

CElementCapture::~CElementCapture()
{
    if (_pElement)
    {
        _pElement->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::HasContainerCapture(CTreeNode *pNode)
//
//  Synopsis:   .
//
//----------------------------------------------------------------------------

BOOL    CDoc::HasContainerCapture(CTreeNode *pNode)
{
    CElementCapture *pCapture = GetLastCapture();
    BOOL            fHasContainerCapture = FALSE;

    if( pCapture )
    {
        //
        // if we have container capture, or the node passed in is the capture element,
        // then we have capture
        //
        fHasContainerCapture = pCapture->_fContainer || 
                                ( pNode && (pNode == pCapture->_pElement->GetFirstBranch() ) );

        if( !fHasContainerCapture )
        {
            //
            // We know that container capture is NOT set, so all children of the current capture
            // element should continue to get mouse events as normal.  So 
            // we need to check to see if the node passed in is a child of the element which
            // currently has capture.  If it is a child, then we DO NOT have container capture, 
            // route the message as normal.  If the node in question IS NOT a child of the
            // element which has setup capture, we need to hand all mouse messages to the 
            // element with capture, and we need to return TRUE.
            //
            CTreeNode *pMaster = pNode->GetNodeInMarkup( pCapture->_pElement->GetMarkupPtr() );

            fHasContainerCapture = !pMaster || !pMaster->SearchBranchToRootForScope( pCapture->_pElement );
        }
    }
    
    return fHasContainerCapture;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::PumpMessage
//
//  Synopsis:   Fires the event and then hands over the message to pTarget. If
//              ptarget is NULL, the message is handed over to the capture
//              object.
//
//----------------------------------------------------------------------------
HRESULT
CDoc::PumpMessage(CMessage * pMessage, CTreeNode * pNodeTarget, BOOL fPerformTA)
{
    HRESULT     hr              = S_OK;
    BOOL        fInRecursion    = _fInPumpMessage;
    BOOL        fSaveModalState = _fModalDialogInScript; // to handle recursion
    BOOL        fEventCancelled = FALSE;
    CTreeNode * pNodeHit        = pMessage->pNodeHit;
    CTreeNode * pCurNode        = NULL;
    CTreeNode * pNodeFireEvent  = NULL;
    CTreeNode * pNodeFireEventSrcElement = NULL;
    CElement  * pElemCurrentOld = _pElemCurrent;
    ULONG       cDie            = _cDie;
    BOOL        fMouseMessage   =   (   (pMessage->message >= WM_MOUSEFIRST)
                                     && (pMessage->message <= WM_MOUSELAST))
                                  ||    (pMessage->message == WM_SETCURSOR)
                                  ||    (pMessage->message == WM_CAPTURECHANGED)
                                  ||    (pMessage->message == WM_MOUSELEAVE)
                                  ||    (pMessage->message == WM_MOUSEOVER);
    BOOL        fSiteSelected   = FALSE;
    EVENTINFO evtInfo;
    BOOL fHadCapture = FALSE;
    CTreeNode * pNodePrimaryRoot   = PrimaryRoot()->GetFirstBranch();
    IHTMLEditor* ped = _pIHTMLEditor;
    BOOL        fPopupKeyMsg    =   _fPopupDoc 
                                &&  pMessage->message >= WM_KEYFIRST
                                &&  pMessage->message <= WM_KEYLAST;
     
    if ( ped )
    {
        ped->AddRef();
    }
    
    Assert(pNodePrimaryRoot);
    
    //  TODO(laszlog): This should be changed into a real fix!
    if ( ! _pElemCurrent || _pElemCurrent->Tag() == ETAG_DEFAULT )
    {
        return S_OK;
    }

    Assert(pMessage);

    AssertSz((  pNodeTarget
                && !pNodeTarget->IsDead()
                && pNodeTarget->Element()
                && pNodeTarget->IsInMarkup())
            || HasCapture() // TODO: investigate this (marka)
            || !GetLastCapture()
            || GetLastCapture()->_pElement->IsInMarkup()
            || pMessage->message == WM_MOUSEOVER
            || pMessage->message == WM_MOUSELEAVE,
             "Trying to send a windows message to an element not in the tree");

    _fInPumpMessage = TRUE;

    // In browse mode, if the mouse is clicked on a child of BUTTON,
    // we want to send that click to the BUTTON instead. IE5 #34796, #26572
    switch (pMessage->message)
    {
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        if (pNodeHit && !pNodeHit->Element()->IsEditable(TRUE))
        {
            CTreeNode * pNodeLoop = pNodeHit;

            while (pNodeLoop && pNodeLoop->Tag() != ETAG_BUTTON)
            {
                pNodeLoop = pNodeLoop->Parent();
            }
            if (pNodeLoop)
            {
                if (pNodeLoop != pNodeHit)
                {
                    if (pNodeTarget == pNodeHit)
                    {
                        pNodeTarget = pNodeLoop;
                    }

                    // pNodeHit is parented by a BUTTON.
                    pNodeHit = pNodeLoop;
                    hr = THR( pMessage->SetNodeHit(pNodeHit) );
                    if( hr )
                        goto Cleanup;
                    pMessage->lSubDivision = 0;
                }
            }
        }
    }

    switch (pMessage->message)
    {
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
        Assert(pNodeHit || !pNodeTarget);
        hr = THR( CTreeNode::ReplacePtr(&_pNodeGotButtonDown, pNodeHit) );
        if( hr )
            goto Cleanup;
        _fFirstTimeTab = FALSE;
        // fall-through
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if (fPerformTA)
        {
            if (g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
            {
                extern BOOL IsNumpadKey(CMessage *);
                if (!(pMessage->message == WM_SYSKEYDOWN && IsNumpadKey(pMessage)))
                {
                    switch (pMessage->wParam)
                    {
                    case VK_MENU:
                        if (_wUIState & UISF_HIDEACCEL)
                            SendMessage(_pInPlace->_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);
                        break;
                    case VK_RIGHT:
                    case VK_LEFT:
                    case VK_UP:
                    case VK_DOWN:
                    case VK_TAB:
                        if (_wUIState & UISF_HIDEFOCUS)
                            SendMessage(_pInPlace->_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
                        break;                
                    }
                }
            }
        }

        // Kill any task that's waiting to scroll or jump to a bookmark
        // TODO (jbeda) we have to figure out he right markup to send these to

        // Set a flag to indicate that the user has started interacting.
        // We use this flag to cancel restoring history like scroll/caret
        // positions.    
        {
            CMarkup * pMarkupCurrent = _pElemCurrent->GetMarkup();

            pMarkupCurrent->_fUserInteracted = TRUE;
            pMarkupCurrent->TerminateLookForBookmarkTask();
        }
        break;

    case WM_CONTEXTMENU:
        // if generated by the mouse, this WM_CONTEXTMENU should be treated as
        // a mouse message.  This will cause proper mouse capture behavior.
            if ((GET_X_LPARAM(pMessage->lParam) != -1) || 
                (GET_Y_LPARAM(pMessage->lParam) != -1))
            {
                fMouseMessage = TRUE;
            }
        break;
    }

#ifndef WIN16
    // NB (cthrash) If we get a TranslateAccelerator message directly from
    // our host, we need to be sensitive to whether the host's message loop
    // gets Unicode our Multibyte window messages.  For our internal purposes,
    // we need the WM_CHAR message to be in Unicode, so we need to convert
    // when appropriate.
    if (pMessage->message == WM_CHAR &&
        ( VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID ||
          !IsWindowUnicode( pMessage->hwnd ) ))
    {
        UINT uKeyboardCodePage = GetKeyboardCodePage();
        
        if (!_bLeadByte && IsDBCSLeadByteEx(uKeyboardCodePage, (BYTE)pMessage->wParam))
        {
            _bLeadByte = BYTE(pMessage->wParam);
            goto Cleanup;
        }
        else
        {
            // Translate the character to unicode
            CHAR ach[2];
            wchar_t wch;

            if (_bLeadByte)
            {
                ach[0] = _bLeadByte;
                ach[1] = (BYTE)pMessage->wParam;
            }
            else
            {
                ach[0] = (BYTE)pMessage->wParam;
                ach[1] = 0;
            }

            WHEN_DBG(int cchDbg =)
            MultiByteToWideChar(uKeyboardCodePage, 0,
                                ach, ach[1] ? 2 : 1, &wch, 1);

            //
            // HACK (cthrash) For codepages which don't support the Euro symbol,
            // convert multibyte value of 128 simply results in U+0080.  Since
            // this is never what the user wanted (it's a control character), we
            // hack this to convert to the Euro.
            //  

            if (   wch == 128
                && ach[1] == 0
                && BYTE(ach[0]) == 128)
            {
                wch = WCH_EURO;
            }
                
            AssertSz(1== cchDbg, "Char convert failed");
            pMessage->wParam = wch;
            _bLeadByte = 0;
        }
    }
#endif // WIN16

    // Determine who should fire the event for this message

    if (!pNodeHit)
    {
        pNodeFireEvent = _pElemCurrent ? _pElemCurrent->GetFirstBranch() : NULL;
    }
    else
    {
        if (pMessage->pElementEventTarget)
        {
            pNodeFireEvent = pMessage->pElementEventTarget->GetFirstBranch();
            pNodeFireEventSrcElement = pNodeHit;
        }
        else
        {
            pNodeFireEvent = pNodeHit;
        }
    }

    if (!pNodeFireEvent)
        goto Cleanup;

    Assert(pNodeFireEvent);

    _fModalDialogInScript = FALSE;


    //
    // release all detached captures
    //

    ReleaseDetachedCaptures();

    if (    fMouseMessage
        &&  HasContainerCapture(pNodeFireEvent))
    {
        CElementCapture *pCapture = GetLastCapture();
        pNodeFireEventSrcElement = pNodeFireEvent;
        if (!pCapture->_fFireOnNodeHit)
            pNodeFireEvent = pCapture->_pElement->GetFirstBranch();

        Assert(pNodeFireEventSrcElement);
        Assert(pNodeFireEvent);
        if (pNodeFireEventSrcElement->GetMarkup() != pNodeFireEvent->GetMarkup())
        {
            // Fix for #86892
            // If a master has capture and its slave is the src element, then change
            // the src element to be the master, to ensure encapsulation.
            if (    pNodeFireEventSrcElement->Element()->HasMasterPtr()
                &&  pNodeFireEventSrcElement->Element()->GetMasterPtr() == pNodeFireEvent->Element())
            {
                pNodeFireEventSrcElement = NULL;
            }
            else
            {
                pNodeFireEventSrcElement = NULL;
            }
        }
        fHadCapture = TRUE;
    }

    if (!fPerformTA)
    {
        // We have already fired the event for certain messages in the TA pass
        switch (pMessage->message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
            pMessage->fEventsFired = TRUE;
            break;
        }
    }

    if (    !pMessage->fEventsFired
         && pNodeFireEvent != pNodePrimaryRoot)
    {
    
        CTreeNode::CLock lock;
        hr = THR( lock.Init( pNodeFireEvent ) );
        if( hr )
            goto Cleanup;


        fEventCancelled = (S_FALSE != THR(pNodeFireEvent->Element()->
                                            FireStdEventOnMessage(pNodeFireEvent, pMessage, NULL, pNodeFireEventSrcElement, & evtInfo )));

        Assert( ! evtInfo._fDontFireEvent ||
                ( evtInfo._fDontFireEvent && !fEventCancelled ));
                
        if ( evtInfo._pParam == NULL &&
             ( pMessage->message == WM_IME_STARTCOMPOSITION ||
               pMessage->message == WM_IME_ENDCOMPOSITION || 
               pMessage->message == WM_IME_COMPOSITIONFULL ||
               pMessage->message == WM_IME_CHAR ||
               pMessage->message == WM_IME_COMPOSITION ||
               pMessage->message == WM_IME_NOTIFY ||
               pMessage->message == WM_INPUTLANGCHANGE ||
               pMessage->message == WM_IME_REQUEST ))
        {
            hr = THR(CreateIMEEventInfo(pMessage, &evtInfo, pNodeFireEvent->Element()));
            if (FAILED(hr))
                goto Cleanup;
        }

        //
        // This is a slight hack.  Well more than a slight hack.  IN IE 5.0, the editor
        // listened directly to windows messages.  Windows fires the WM_LBUTTONDBLCLK message
        // in the following order.  LBUTTONDOWN, LBUTTONUP, LBUTTONDBLCLK, LBUTTONUP.  In 
        // IE 5.0, the editor would intercept the LBUTTONDBLCLK message and fire the
        // OnSelectStart event, notifying our clients that a selection was beginning.
        //
        // In IE 5.5, the editor is only using trident events in order to do all its work.
        // Trident, however, sends the DBLCLICK message in the following order.
        //  LBUTTONDOWN, LBUTTONUP, CLICK, LBUTTONUP, LBUTTONDBLCLK.
        //
        // Therefore the editor is unable to send the OnSelectStart event at the same
        // time as it used to, breaking other applications because of compat.  See bug
        // 86923 for more information.
        // 
        if( evtInfo._pParam == NULL && pMessage->message == WM_LBUTTONDBLCLK )
        {
            hr = THR( CreateDblClickInfo( pMessage, &evtInfo, pNodeFireEvent, pNodeFireEventSrcElement ) );
            if( FAILED(hr) )
                goto Cleanup;
        }
                                                
        if (!AreWeSaneAfterEventFiring(pMessage, cDie))
            goto Cleanup;

        // script may have removed pNodeFireEvent from the tree
        if(pNodeFireEvent->IsDead())
            pNodeFireEvent = pNodeFireEvent->Element()->GetFirstBranch();

        if(!pNodeFireEvent || !pNodeFireEvent->Element()->IsInMarkup())
            goto Cleanup;
    }

    //
    // TODO-NEW_EDIT_EVENTS : Why not always do the currency change irregardless of who has capture ?
    //                        This code is being reworked to put SetEditContext inside of mshtmled. Shouldn't be an issue
    // 

    // Do special stuff for MouseDown/Up messages

    //
    // TODO - designmode check is just for setting currency issue. 
    // Remove this after my set edit context work goes in.
    // 
    if (!HasContainerCapture(pNodeFireEvent) || pNodeTarget && pNodeTarget->GetMarkup()->_fDesignMode )
    {
        switch (pMessage->message)
        {
            case WM_LBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONDOWN:

            if ( !HasContainerCapture(pNodeFireEvent) )
            {
                // Give currency to the site under the mouse, unless the event
                // handler changed currency or the mouse is on a selection.
                // Leave OLEsites alone; let them set their own currency in HandleMessage (#60183)
                Assert(pNodeHit);

                if (_fFirstTimeTab)
                {
                    CLayout * pLayoutClient = pNodeHit->GetMarkup()->GetElementClient()->GetUpdatedLayout();
                    RECT      rc;

                    pLayoutClient->GetRect(&rc);
                    if (PtInRect(&rc, pMessage->pt))
                    {
                        _fFirstTimeTab = FALSE;
                    }
                }
            }

            pCurNode = pMessage->pNodeHit;
            
            if (    pCurNode
                && ! fSiteSelected
                &&  _pElemCurrent == pElemCurrentOld
                &&  (   DifferentScope(_pElemCurrent, pCurNode )
                    ||  _lSubCurrent != pMessage->lSubDivision || !_pInPlace->_fFocus)
                &&  !pCurNode->Element()->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            {
                Assert( pCurNode->GetMarkup() );
                
                //
                // Look for the topmost element client - for frameset pages. 
                //
                CElement* pElemFrame = NULL;
                CWindow * pWindowTop = pCurNode->GetMarkup()->Window() ? pCurNode->GetMarkup()->Window()->Window() : NULL;                
                CMarkup* pMarkupFrame = pWindowTop && pWindowTop->_pWindowParent ? pWindowTop->_pWindowParent->_pMarkup : NULL;                

                pElemFrame = pMarkupFrame ? pMarkupFrame->GetElementClient() : NULL ;            
                
                if (    pMessage->htc <  HTC_GRPTOPBORDER
                    &&  (   pCurNode->Element()->Tag() != ETAG_BODY
                        ||  (   pMessage->htc != HTC_HSCROLLBAR
                            &&  pMessage->htc != HTC_VSCROLLBAR)) 

                        //
                        // Currently our editing in framesets in desing mode doesn't work
                        // properly. A click UI-activates, not site-selects
                        // the code below makes this behavior consistent
                        //
                        
                        ||  ( pElemFrame && 
                              pElemFrame->Tag() == ETAG_FRAMESET &&
                              pElemFrame->IsEditable( FALSE ) &&
                              pCurNode->GetMarkup()->IsScrollingElementClient( pCurNode->Element()) ))                            
                {
                    BOOL        fYieldFailed    = FALSE;
                    CElement *  pElemCurrentNew = pCurNode->Element();

#ifdef UNIX
                    if ((pMessage->message == WM_MBUTTONDOWN) &&  
                        pMessage->pNodeHit->Element()->IsEditable())
                    {
                        // Get selected text before it's gone.
                        HANDLE hszText = MwGetPrimarySelectionData();
                        if(hszText)
                        {
                            g_uxQuickCopyBuffer.GetTextSelection(hszText, FALSE, NULL);
                            GlobalFree(hszText);
                        }
                    }
#endif
                    LONG lButton = 0;

                    switch( pMessage->message )
                    {
                        case WM_LBUTTONDOWN:
                        lButton = 1;
                        break;

                        case WM_RBUTTONDOWN:
                        lButton = 2;
                        break;

                        case WM_MBUTTONDOWN:
                        lButton = 4;
                        break;
                    }

                        
                    if (S_FALSE == NotifySelectionHelper(  EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE, pElemCurrentNew)
                        || S_OK != pElemCurrentNew->BubbleBecomeCurrent(
                            pMessage->lSubDivision, &fYieldFailed, pMessage, TRUE, lButton ))
                    {
                        if (fYieldFailed)
                        {
                            fEventCancelled = TRUE;
                        }
                    }

                    if (!AreWeSaneAfterEventFiring(pMessage, cDie))
                        goto Cleanup;

                    // script may have removed pNodeFireEvent from the tree
                    if(pNodeFireEvent->IsDead())
                        pNodeFireEvent = pNodeFireEvent->Element()->GetFirstBranch();

                    if(!pNodeFireEvent || !pNodeFireEvent->Element()->IsInMarkup())
                        goto Cleanup;
                }
            }

            // if a modal dialog was brought by the event handler, treat it
            // as a cancel
            fEventCancelled = (fEventCancelled || _fModalDialogInScript);
            
            break;

            case WM_LBUTTONUP:
            case WM_MBUTTONUP:
            case WM_RBUTTONUP:
            // If a MouseUp is cancelled, release capture. Any further cleanup
            // required should be performed by the site/element by handling
            // WM_CAPTURECHANGED
            if (fEventCancelled)
            {
                SetMouseCapture (NULL, NULL);
            }
            break;
        }
    }

    //
    // release all detached captures
    //

    ReleaseDetachedCaptures();

    if (!fEventCancelled)
    {
        hr = S_FALSE;
    }

    if (!fEventCancelled && !fPopupKeyMsg)
    {
        if (fPerformTA)
        {
            // don't bubbel through element handlemessage
            hr = THR(PerformTA(pMessage, & evtInfo ));
        }
        else
        {
            if (    fMouseMessage
                &&  HasContainerCapture(pNodeFireEvent))
            {
                hr = THR(GetLastCapture()->CallCaptureFunction(pMessage));                
            }
            else
            {
                // if we lost capture in the event handler or while setting focus,
                // send the message to the element that fired the event
                pNodeTarget = pNodeFireEvent;
                Assert(pNodeTarget->IsInMarkup());
                //
                // Since the htmlInputFile version of CInput has an input
                // and a button that we're simulating, we have to 
                // do this hack.
                //
                BOOL fGiveMsgToEditor = TRUE;

                // Verify that we have a CInput and the message is a WM_CHAR
                if ((pMessage->message  == WM_CHAR) && 
                    (_pElemCurrent->Tag() == ETAG_INPUT))
                {
                    CInput * pInput = DYNCAST(CInput, _pElemCurrent);

                    // We only want the htmlInputFile version of CInput
                    if (pInput->GetType() == htmlInputFile)
                    {
                        // Give the message only if the button doesn't have focus.
                        fGiveMsgToEditor = !pInput->_fButtonHasFocus;
                    }
                }

                // give first chance to the Editor in certain cases

                //
                // TODO-NEW_EDIT_EVENTS : Completely remove all the above fGiveMsgToEditor junk
                //
                                
                if (  fGiveMsgToEditor )
                {
                    if ( ! fHadCapture )
                    {
                        if ( evtInfo._pParam != NULL  ||
                             pMessage->message == WM_KEYDOWN )
                        {

                            if ( evtInfo._pParam == NULL )
                            {
                                evtInfo._pParam = new EVENTPARAM(this, pNodeFireEvent->Element(), NULL, TRUE /*fInitState*/, FALSE /*fPush*/ );
                                
                                const PROPERTYDESC_BASIC* pDesc;
                                
                                InitEventParamForKeyEvent(
                                    evtInfo._pParam , 
                                    pNodeFireEvent, 
                                    pMessage, 
                                    (int*)&pMessage->wParam, 
                                    & pDesc );

                                evtInfo._dispId = (DISPID)(pDesc->c);                               
                            }
                            Assert( evtInfo._pParam != NULL );
                        
                            hr = THR(HandleSelectionMessage(pMessage, FALSE, & evtInfo, HM_Pre ));
                        }                            
                    }
                }

                if (   hr == S_FALSE && 
                       pMessage->pNodeHit &&
                       pMessage->message == WM_LBUTTONUP &&
                       ! pMessage->pNodeClk )
                {
                    SetClick( pMessage );
                }             

                if (hr == S_FALSE)
                {
                    while (pNodeTarget && pNodeTarget->IsInMarkup() && pNodeTarget != pNodePrimaryRoot)
                    {
                        Assert( pNodeTarget && pNodeTarget->IsInMarkup() );
                        // TODO (jbeda) I don't feel confident enough in this
                        // code to let the assert above handle this problem.  Break
                        // out here if we aren't in the markup because otherwise
                        // we *will* crash
                        if (!pNodeTarget || !pNodeTarget->IsInMarkup())
                            break;

                        hr = THR(pNodeTarget->Element()->HandleMessage(pMessage));

                        if (hr != S_FALSE)
                            break;


                        if (pNodeTarget->Element()->HasMasterPtr())
                        {
                            pNodeTarget = pNodeTarget->Element()->GetMasterPtr()->GetFirstBranch();
                        }
                        else
                        {
                            pNodeTarget = pNodeTarget->Parent();
                        }
                        
                        // Don't bubble up WM_MOUSEHWEEL into frameset. Frameset sent the message
                        // down
                        if (    pMessage->message == WM_MOUSEWHEEL
                            &&  pNodeTarget
                            &&  pNodeTarget->Tag() == ETAG_FRAMESET)
                        {
                            break;
                        }
                    }
                }
                // give a second and final chance to the Editor
                if ((hr == S_FALSE) && fGiveMsgToEditor)
                {
                    if ( ! fHadCapture 
                        //
                        // We only call HandleSelectionMessage if there was an OM message
                        // like the windows message.
                        //
                        && ( evtInfo._pParam != NULL  ||
                             ( pMessage->message == WM_KEYDOWN && !fPerformTA ))
                    )
                    {
                        //
                        // TODO-NEW_EDIT_EVENTS : Talk to mohan abt. a better way of acheiving this.
                        //

                        if (evtInfo._pParam == NULL)
                        {
                            evtInfo._pParam = new EVENTPARAM(this, pNodeFireEvent->Element(), NULL, TRUE /*fInitState*/, FALSE /*fPush*/ );
                            
                            const PROPERTYDESC_BASIC* pDesc;
                            
                            InitEventParamForKeyEvent(
                                evtInfo._pParam , 
                                pNodeFireEvent, 
                                pMessage, 
                                (int*)&pMessage->wParam, 
                                & pDesc );

                            evtInfo._dispId = (DISPID)(pDesc->c);                               
                        }
                        Assert( evtInfo._pParam != NULL );
                        
                        hr = THR(HandleSelectionMessage(pMessage, FALSE, & evtInfo , HM_Post ));

                    }                        

                }
            }

            if (hr == S_FALSE)
            {
                LRESULT lr;

                hr = THR(OnDefWindowMessage(pMessage->message, pMessage->wParam, pMessage->lParam, &lr));
            }

        }

        if (!SUCCEEDED(hr))
            goto Cleanup;

        if (S_OK == hr && !fPerformTA)
        {
            CElementCapture * pCapture = GetLastCapture();
            CElement *pelFireTarget = NULL;
            CTreeNode *pNode = NULL;
            BOOL    fFireDblClick = FALSE;

            // Do click or dblclick as appropriate
            if (_fGotDblClk && pMessage->message == WM_LBUTTONUP)
            {
                fFireDblClick = TRUE;
                if (HasContainerCapture(pNodeHit))
                {
                    pelFireTarget = pCapture->_pElement;
                }
                else if (pNodeHit)
                {
                    pelFireTarget = pNodeHit->Element();
                    pNode = pNodeHit;
                }
            }
            else if (pMessage->pNodeClk)
            {
                if (HasContainerCapture(pMessage->pNodeClk) )
                {
                    pelFireTarget = pCapture->_pElement;
                }
                else
                {
                    pelFireTarget = pMessage->pNodeClk->Element();
                    pNode = pMessage->pNodeClk;
                }                
            }
            else if (pMessage->message == WM_LBUTTONUP && HasCapture())
            {
                if (!HasContainerCapture(pNodeHit))
                    pelFireTarget = pNodeHit->Element();
                else
                    pelFireTarget = pCapture->_pElement;
            }

            BOOL fDoOleSite;
            EVENTINFO clkEvtInfo;
            
            if (!pelFireTarget || pelFireTarget->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
            {
                fDoOleSite = TRUE;
                clkEvtInfo._fDontFireEvent = TRUE;                
            }
            else
            {
                fDoOleSite = FALSE;
            }                
                
            if (!fDoOleSite || fFireDblClick)
            {
                if (pelFireTarget)
                {
                    if (fFireDblClick)
                    {
                        hr = THR(pelFireTarget->Fire_ondblclick(pNode, pMessage ? pMessage->lSubDivision : 0, & clkEvtInfo ));
                        _fGotDblClk = FALSE;                    
                    }
                    else
                    {
                        hr = THR(pelFireTarget->DoClick(pMessage, pNode, FALSE, & clkEvtInfo ));
                    }
                }

                pMessage->fSelectionHMCalled = FALSE;
                if ( clkEvtInfo._pParam )
                {
                    hr = THR(HandleSelectionMessage(pMessage, FALSE, & clkEvtInfo, HM_Post ));                    
                }
            }
                
        }
    }

    if (!AreWeSaneAfterEventFiring(pMessage, cDie))
        goto Cleanup;

    if (_fInvalInScript && !fInRecursion)
    {
        Assert(_pInPlace);
        Assert(_pInPlace->_hwnd);
        UpdateWindow(_pInPlace->_hwnd);
    }
Cleanup:
    switch (pMessage->message)
    {
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
    case WM_KILLFOCUS:
        Verify( !CTreeNode::ReplacePtr(&_pNodeGotButtonDown, NULL) );
        break;
    }

    if ( ped )
    {
        ped->Release();
    }

    _fModalDialogInScript = fSaveModalState;
    _fInPumpMessage = fInRecursion;


    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AreWeSaneAfterEventFiring
//
//  Synopsis:   Determines if anything during the event firing has changed
//              things adversly.
//
//----------------------------------------------------------------------------
BOOL
CDoc::AreWeSaneAfterEventFiring(CMessage *pMessage, ULONG cDie)
{
    BOOL fAreWeSane = FALSE;

    if (State() < OS_INPLACE || cDie != _cDie)
        goto Cleanup;

    if ((   pMessage->message >= WM_MOUSEFIRST
         && pMessage->message <= WM_MOUSELAST
        )
        || pMessage->message == WM_SETCURSOR
       )
    {
        if (   pMessage->pNodeHit
            && !pMessage->pNodeHit->Element()->IsInMarkup()
           )
            goto Cleanup;
    }

    fAreWeSane = TRUE;

Cleanup:
    return fAreWeSane;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\gsecdn16.cxx ===
// copy of GetSecurityDomainFromURL from 32bit shdocvw
// Why is that in shdocvw? Shouldn't it be in shlwapi?
// This uses MemAlloc for it's mem allocation, so use MemFree to free it.

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define MAX_URL_STRING 1024
#define ASSERT Assert

// HRESULT GetSecurityDomainFromURL(WCHAR *pchURL, WCHAR **ppchDomain);
//
// The pchURL argument is the URL of a page. A string representing
// the security domain of the URL is returned in ppchDomain.
// The caller is responsible for freeing the string using CoTaskMemFree.
// The caller can compare security domains using wcscmp (case sensitive compare).
// The security domain string always begins with "<url scheme>:".
// If the scheme is HTTP or HTTPS and the host is specified as an IP address,
// then the second component of the security domain string is the IP address.
//
// If the scheme is HTTP or HTTPS and the host is specified as a domain name,
// then the second component of the security domain is the host's second
// level domain name.  For example, if the host is "www.microsoft.com",
// then the second level domain name is "microsoft.com".
// If the URL is a is a UNC file name, then the second component is the
// server name.
// If the URL is a file name rooted at a drive letter and the driver letter
// is mapped to a server, then the second component is the server name.
// If the URL is a local file, then the second component is the empty string.
// If the URL uses some other scheme not mentioned above, then the second
// component is the empty string.

STDAPI GetSecurityDomainFromURL(LPCTSTR pchURL, TCHAR **ppchDomain)
{
    HRESULT hres;
    *ppchDomain = NULL;

    // BUGWIN16 this needs more apis from urlmon, so until then.....
    CHAR szIn[MAX_URL_STRING];
#ifdef WIN16
    strncpy(szIn, pchURL, MAX_URL_STRING);
#else
    UnicodeToAnsi(pchURL, szIn, ARRAYSIZE(szIn));
#endif
    CHAR szInC[MAX_URL_STRING];
    DWORD cchT = ARRAYSIZE(szInC);
    hres = UrlCanonicalize(szIn, szInC, &cchT, 0); 

    if (SUCCEEDED(hres)) {
    
        CHAR * const pszOut = szIn; // re-use
        LPTSTR pszT;

        // Find the protocol and prefix
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);
        hres = ParseURL(szInC, &pu);

        if (SUCCEEDED(hres))
        {
            // Copy the protocol + separator. Make it zero-terminated.
            lstrcpyn(pszOut, pu.pszProtocol, pu.cchProtocol+2);
    
            // Copy additional protocol specific data
            if (pu.nScheme==URL_SCHEME_HTTP || pu.nScheme==URL_SCHEME_HTTPS)
            {
                LPCSTR pszSep = pu.pszSuffix;
                // skip '/'s
                while(*pszSep=='/') pszSep++;
    
                // Find the separator '/' and truncate the rest.
                pszT = strchr(pszSep, '/');
                if (pszT) {
                    *pszT = '\0';
                }
    
                // Copy the remaining.
#ifdef WIN16
                pszT = strrchr(pszSep, '.');
                if (pszT)
                {
                    // check if it's an IP address...
                    // fast check--only check last byte of address (x.x.x.lastbyte)                    
                    LPTSTR pszT2 = pszT;
                    while (*pszT2)
                    {
                        if (*pszT2 < '0' || *pszT2 > '9')
                        {
                            break;
                        }
                    }
                    if (*pszT2)
                    {
                        // not an IP address
                        // Find the second last dot.
                        while (pszT > pszSep && *pszT != '.')
                        { 
                            pszT--;
                        }
                        if (*pszT == '.')
                        {
                            pszSep = pszT + 1;
                        }
                    }
                }
#else
                if (!_IsThisIPAddress(pszSep)) {
                    // Find the last dot.
                    pszT = StrRChrA(pszSep, NULL, '.');
                    if (pszT) {
                        // Find the second last dot.
                        pszT = StrRChrA(pszSep, pszT, '.');
                        if (pszT) {
                            // Copy the "microsoft.com" portion only.
                            pszSep = pszT+1;
                        }
                    } 
                }
#endif // win16 else
                strncat(pszOut, pszSep, ARRAYSIZE(szIn));
    
                //TraceMsg(DM_SDOMAIN, "HTTP + %s", pszSep);
    
            } else if (pu.nScheme==URL_SCHEME_FILE) {
                CHAR szPath[MAX_PATH];
                cchT = MAX_PATH; //ARRAYSIZE(szPath);
                hres = PathCreateFromUrl(szInC, szPath, &cchT, 0);
    
                // Copy the server name.
                if (SUCCEEDED(hres)) {
                    if (PathIsUNC(szPath)) {
                        ASSERT(szPath[0]=='\\');
                        ASSERT(szPath[1]=='\\');
                        // Find the separator '\\' and truncate the rest.
                        LPSTR pszT = strchr(szPath+2, '\\');
                        if (pszT) {
                            *pszT = '\0';
                        }
                        strncat(pszOut, szPath, ARRAYSIZE(szIn));
                    }
                }
            }

            if (SUCCEEDED(hres)) {
#ifdef WIN16
                *ppchDomain = (char *)CoTaskMemAlloc(strlen(pszOut)+1);
                strcpy(*ppchDomain, pszOut);
#else
                TraceMsg(DM_SDOMAIN, "Returning %s", pszOut);
                *ppchDomain = MakeWideStrFromAnsi(pszOut, STR_OLESTR);
#endif
                if (*ppchDomain==NULL) {
                    hres = E_OUTOFMEMORY;
                }
            }
        } else {
            hres = E_INVALIDARG;
        }
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\krnlundo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       undo.cxx
//
//  Contents:   Implementation of Undo classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  CUndoNewControl Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::CUndoDeleteControl, public
//
//  Synopsis:   CUndoDeleteControl ctor
//
//  Arguments:  [pDoc] -- Pointer to owner form
//
//----------------------------------------------------------------------------

CUndoDeleteControl::CUndoDeleteControl(CSite * pSite)
    : CUndoUnitBase(pSite, IDS_UNDODELETE)
{
    TraceTag((tagUndo, "CUndoDeleteControl ctor"));

    _pDOBag = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::CUndoDeleteControl, public
//
//  Synopsis:   CUndoDeleteControl dtor
//
//----------------------------------------------------------------------------

CUndoDeleteControl::~CUndoDeleteControl()
{
    ReleaseInterface(_pDOBag);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::Init, public
//
//  Synopsis:   Initializes the undo object.
//
//  Arguments:  [parySiteDelete] -- Array of sites that are going to be
//                                  deleted.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoDeleteControl::Init(int c, CSite ** ppSite)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoDeleteControl::Do, public
//
//  Synopsis:   Performes an undo of a control deletion.
//
//  Arguments:  [pUM] -- Pointer to undo manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoDeleteControl::Do(IOleUndoManager * pUM)
{
    HRESULT    hr;
    IStorage * pStg      = NULL;
    DWORD      dwCookie;
    CDoc *    pDoc = Site()->_pDoc;

    if (!pUM)
    {
        hr = pDoc->BlockNewUndoUnits(&dwCookie);
        if (hr)
            goto Cleanup;
    }

//    hr = THR(GetcfPrivateFmt(_pDOBag, &pStg));
 //   if (hr)
  //      goto Cleanup;

    //
    // This puts a Redo action on the stack.
    //
    hr = S_OK;

    pDoc->OnControlInfoChanged();

    if (!pUM)
    {
        pDoc->UnblockNewUndoUnits(dwCookie);
    }

    pDoc->UndoManager()->DiscardFrom(NULL);

Cleanup:
    ReleaseInterface(pStg);
    ClearInterface(&_pDOBag);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoNewControl Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoNewControl::CUndoNewControl, public
//
//  Synopsis:   CUndoNewControl ctor
//
//----------------------------------------------------------------------------

CUndoNewControl::CUndoNewControl(CSite * pSite, CSite * pSiteNew)
    : CUndoUnitBase(pSite->_pDoc, IDS_UNDONEWCTRL)
{
    TraceTag((tagUndo, "CUndoNewControl ctor"));

    _arySites.Append(pSiteNew);
}

CUndoNewControl::CUndoNewControl(CSite * pSite, int c, CSite ** ppSite)
    : CUndoUnitBase(pSite->_pDoc, IDS_UNDONEWCTRL)
{
    TraceTag((tagUndo, "CUndoNewControl ctor"));

    _arySites.CopyIndirect(c, ppSite, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoNewControl::Do, public
//
//  Synopsis:   Performs an undo of adding a new control. Deletes the control
//              that was added.
//
//----------------------------------------------------------------------------

HRESULT
CUndoNewControl::Do(IOleUndoManager * pUndoMgr)
{
    TraceTag((tagUndo, "CUndoNewControl::Do"));

    HRESULT     hr = S_OK;
    DWORD       dwCookie;
    CDoc *      pDoc = Site()->_pDoc;
    CDoc::CLock Lock(pDoc);

    if (!pUndoMgr)
    {
        hr = pDoc->BlockNewUndoUnits(&dwCookie);
        if (hr)
            goto Cleanup;
    }

    //
    // Puts a redo action on the stack.
    //
    Site()->ShowLastErrorInfo(hr);

    if (!pUndoMgr)
    {
        pDoc->UnblockNewUndoUnits(dwCookie);
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CUndoMove Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoMove::CUndoMove, public
//
//  Synopsis:   CUndoMove ctor
//
//----------------------------------------------------------------------------

CUndoMove::CUndoMove(CSite * pSite, RECT *prc, DWORD dwFlags)
    : CUndoUnitBase(pSite, IDS_UNDONEWCTRL)
{
    TraceTag((tagUndo, "CUndoMove ctor"));

    Assert(prc);

    _rc      = *prc;
    _dwFlags = dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoMove::Do, public
//
//  Synopsis:   Performs an undo of moving a control.
//
//----------------------------------------------------------------------------

HRESULT
CUndoMove::Do(IOleUndoManager * pUndoMgr)
{
    HRESULT      hr;
    DWORD        dwCookie;
    CDoc *         pDoc = Site()->_pDoc;
    CDoc::CLock Lock(pDoc);

    TraceTag((tagUndo, "CUndoMove::Do"));

    if (!pUndoMgr)
    {
        hr = pDoc->BlockNewUndoUnits(&dwCookie);
        if (hr)
            RRETURN(hr);
    }

    //
    // This move should put a corresponding move action on the redo stack
    // unless we're blocking new actions.
    //
    hr = Site()->Move(&_rc, _dwFlags);
    Site()->ShowLastErrorInfo(hr);

    if (!pUndoMgr)
    {
        pDoc->UnblockNewUndoUnits(dwCookie);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\krnldisp.cxx ===
//+---------------------------------------------------------------------
//
//  File:       krnldisp.cxx
//
//  Contents:   dispatch implemtation for form object
//
//  Classes:    CDoc (partial)
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

MtDefine(CDocBuildObjectTypeInfo_aryEntry_pv, Locals, "CDoc::BuildObjectTypeInfo aryEntry::_pv")

//---------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureObjectTypeInfo
//
//
//---------------------------------------------------------------------------

HRESULT
CDoc::EnsureObjectTypeInfo()
{
    HRESULT     hr = S_OK;
    CCollectionCache *pCollectionCache;

    if (!_pTypInfo || !_pTypInfoCoClass)
    {
        hr = THR(PrimaryMarkup()->InitCollections());
        if (hr)
            goto Cleanup;

        pCollectionCache = PrimaryMarkup()->CollectionCache();

        hr = THR(BuildObjectTypeInfo(
            pCollectionCache,
            CMarkup::ELEMENT_COLLECTION,                                     // index of array in coll cache
            DISPID_COLLECTION_MIN,                                  // Min DISPID
            pCollectionCache->GetMinDISPID(CMarkup::WINDOW_COLLECTION) - 1, // Max DISPID
            &_pTypInfo,
            &_pTypInfoCoClass,
            TRUE));
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CDoc::BuildObjectTypeInfo
//
//  Synopsis:   Build a typeinfo from the objects that are
//              to be added to some namespace.
//
//  Arguments:  guidTLib        ???
//              guidTInfo       ???
//              pCollCache      The collection cache to use
//              lIndex          Index in the collection cache to use
//              dispidMin       Minimum dispid to put in the typeinfo
//              ppTI            Outgoing generated typeinfo
//              ppTICoClass     Outgoing generated coclass
//              pvObject        Object implementing validate function.
//              pfnValidate     Function to call for validation of element
//
//---------------------------------------------------------------------------

HRESULT
CDoc::BuildObjectTypeInfo(
    CCollectionCache *  pCollCache,
    long                lIndex,
    DISPID              dispidMin,
    DISPID              dispidMax,
    ITypeInfo **        ppTI,
    ITypeInfo **        ppTICoClass,
    BOOL                fDocument/* = FALSE*/)
{
    HRESULT             hr          = S_OK;
    FUNCDESC            funcdesc    = {0};
    TYPEDESC            tdescUser   = {0};
    long                index       = 0;
    long                i;
    BOOL                fAtomAssigned;
    CElement *          pElement;
    TCHAR *             pchName;
    CStr                cstrUniqueName;
    ITypeInfo *         pTypInfoElement = NULL;
    CDataAry<DISPID>    aryEntry(Mt(CDocBuildObjectTypeInfo_aryEntry_pv));
    BOOL                fDidCreate;

    CCreateTypeInfoHelper Helper;

    Assert ( dispidMin < dispidMax );

    //
    // start creating the typeinfo
    //

    hr = THR(Helper.Start(g_Zero.guid));
    if (hr)
        goto Cleanup;

    //
    // Set up the function descriptor we'll be using.
    //

    funcdesc.funckind = FUNC_DISPATCH;
    funcdesc.invkind = INVOKE_PROPERTYGET;
    funcdesc.callconv = CC_STDCALL;
    funcdesc.cScodes = -1;
    funcdesc.elemdescFunc.tdesc.vt = VT_PTR;
    funcdesc.elemdescFunc.tdesc.lptdesc = &tdescUser;
    tdescUser.vt = VT_USERDEFINED;
    funcdesc.wFuncFlags = FUNCFLAG_FSOURCE;

    //
    // ensure the array
    //

    if (!pCollCache)
    {
        hr = THR(PrimaryMarkup()->EnsureCollectionCache(lIndex));
        if (hr)
            goto Cleanup;
        pCollCache = PrimaryMarkup()->CollectionCache();
    }

    hr = THR(pCollCache->EnsureAry(lIndex));
    if (hr)
        goto Cleanup;

    //
    // Finally loop through all elements in specified collection,
    // creating typeinfos for those elements which pass the
    // validation criteria defined in the validate function.
    //

    // TODO: (anandra) This will forestall addition of controls whose ID
    // changes after this occurs.

    for (i = 0; i < pCollCache->SizeAry(lIndex); i++)
    {

        hr = THR(pCollCache->GetIntoAry(lIndex, i, &pElement));
        if (hr)
            goto Cleanup;
        Assert(pElement);

        // if we are being called on the DOCUMENT's collectionCachethen
        // we are using the ALL collecion and not the window_collection.
        //are we w/n the scope of a form just continue the loop
        if (fDocument &&  
            PrimaryMarkup()->InFormCollection(pElement->GetFirstBranch()))
        {
            continue;
        }

        //
        // Validate this element: calculate name for type info
        //

        if (ETAG_INPUT == pElement->Tag()
            && DYNCAST(CInput, pElement)->GetType() == htmlInputRadio)
        {
            // radio buttons case - get id (can not be be accessed by name) 
            pchName = (TCHAR *) pElement->GetAAid();
        }
        else
        {
            // The forms have been moved to the window collection as a result
            // we don't want the form names to be sinked up twice once for the
            // AddNamedItem done in Init2 of CFormElement and then again when
            // drilling through the dynamic typelib.  If not form for window
            // then the main case -- get id or name.
            pchName = (fDocument && lIndex == CMarkup::ELEMENT_COLLECTION && pElement->Tag() == ETAG_FORM) ?
                        NULL : (TCHAR *) pElement->GetIdentifier();
        }

        fAtomAssigned = FALSE;


        if (pchName)
        {
            // if name is already present in atom table, this call will return index
            // of the name in table
            hr = THR_NOTRACE(_AtomTable.AddNameToAtomTable(pchName, &funcdesc.memid));
            if (hr)
                goto Cleanup;

            if (-1 == aryEntry.FindIndirect(&funcdesc.memid))
            {
                //
                // the id/name does not conflict with any other name
                //
                fAtomAssigned = TRUE;
            }
            else
            {
                //
                // name conflict; have to use unique name
                //
                hr = THR(pElement->GetUniqueIdentifier(&cstrUniqueName, TRUE, &fDidCreate ));
                if (hr)
                    goto Cleanup;

                pchName = (TCHAR*) cstrUniqueName;

                // Need to rebuild the WINDOW_COLLECTION, when added a unique name.
                // Do not use the passed in Collection Cache, it may not be the right one
                if ( fDidCreate )
                {
                    Assert(PrimaryMarkup());
                    Assert(PrimaryMarkup()->CollectionCache());
                    PrimaryMarkup()->CollectionCache()->InvalidateItem (CMarkup::WINDOW_COLLECTION );
                }
            }
        }

        // add VBScript scriptlets, if there are any.
        // if (NULL == pchName && (there is a scriptlet to add)) this call will
        // create a unique identifier
        hr = THR(pElement->AddAllScriptlets (pchName));
        if (hr)
            goto Cleanup;

        if (!pchName)
        {
            pchName = (TCHAR*) pElement->GetAAuniqueName();
        }

        if (!pchName || !*pchName)
            continue;

        // Add this element to the atom table of the doc

        if (!fAtomAssigned) 
        {
            hr = THR(_AtomTable.AddNameToAtomTable(pchName, &funcdesc.memid));
            if (hr)
                goto Cleanup;
        }

        // at this point it should not be possible to have id conflicts
        Assert (-1 == aryEntry.FindIndirect(&funcdesc.memid));

        hr = THR(aryEntry.AppendIndirect(&funcdesc.memid));
        if (hr)
            goto Cleanup;

        // The ID'd items here are resolved alongside the regular window collection items
        // The difference here is that the collection needs to return just the first
        // item whose name matches.
        funcdesc.memid += dispidMin;


        // Detect too many items - this is a seriously unlikely event !!
        if ( dispidMax <= funcdesc.memid)
            break;

        //
        // If we're here then it's ok for this element to create an
        // entry in the typelibrary for this element.
        //

        hr = THR(pElement->GetClassInfo(&pTypInfoElement));
        if (hr)
            goto Cleanup;

        hr = THR(Helper.pTypInfoCreate->AddRefTypeInfo(
            pTypInfoElement,
            &tdescUser.hreftype));
        if (hr)
            goto Cleanup;

        hr = THR(Helper.pTypInfoCreate->AddFuncDesc(index, &funcdesc));
        if (hr)
            goto Cleanup;

        LPTSTR ncpch = const_cast <LPTSTR> (pchName);
        hr = THR(Helper.pTypInfoCreate->SetFuncAndParamNames(
            index,
            &ncpch,
            1));
        if (hr)
            goto Cleanup;

        ClearInterface(&pTypInfoElement);
        index++;
    } // eo for (i = 0; i < pCollCache->SizeAry(lIndex); i++)

    //
    // finalize creating the typeinfo
    //

    hr = THR(Helper.Finalize(IMPLTYPEFLAG_FDEFAULT));
    if (hr)
        goto Cleanup;

    ReplaceInterface (ppTI, Helper.pTIOut);
    ReplaceInterface (ppTICoClass, Helper.pTICoClassOut);

Cleanup:
    aryEntry.DeleteAll();
    ReleaseInterface(pTypInfoElement);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\markupctx.cxx ===
//+---------------------------------------------------------------------
//
//  File:       markupctx.cxx
//
//  Classes:    CMarkupContext, etc
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MARKUPCTX_HXX_
#define X_MARKUPCTX_HXX_
#include "markupctx.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CMarkupContext, Mem, "CMarkupContext")

///////////////////////////////////////////////////////////////////////////
//
// CMarkupContext
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CMarkupContext constructor
//
//-------------------------------------------------------------------------

CMarkupContext::CMarkupContext()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkupContext destructor
//
//-------------------------------------------------------------------------

CMarkupContext::~CMarkupContext()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\jsprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       jsprot.cxx
//
//  Contents:   Implementation of the javascript: protocol
//
//  History:    01-14-97    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

MtDefine(CJSProtocol,  Protocols, "CJSProtocol")
MtDefine(JSProtResult, Protocols, "JavaScript protocol evaluation (temp)")
MtDefine(CJSProtocolParseAndBind_pbOutput, Protocols, "CJSProtocol::ParseAndBind pbOutput")
ExternTag(tagSecurityContext);

HRESULT VariantToPrintableString (VARIANT * pvar, CStr * pstr);

#define WRITTEN_SCRIPT _T("<<HTML><<SCRIPT LANGUAGE=<0s>>var __w=<1s>;if(__w!=null)document.write(__w);<</SCRIPT><</HTML>")

//+---------------------------------------------------------------------------
//
//  Function:   CreateJSProtocol
//
//  Synopsis:   Creates a javascript: Async Pluggable protocol
//
//  Arguments:  pUnkOuter   Controlling IUnknown
//
//----------------------------------------------------------------------------

CBase * 
CreateJSProtocol(IUnknown *pUnkOuter)
{
    return new CJSProtocol(pUnkOuter);
}


CJSProtocolCF   g_cfJSProtocol(CreateJSProtocol);

//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CJSProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    CStr    cstr;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (ParseAction == PARSE_SECURITY_URL)
    {
        hr = THR(UnwrapSpecialUrl(pwzUrl, cstr));
        if (hr)
            goto Cleanup;

        *pcchResult = cstr.Length() + 1;
        
        if (cstr.Length() + 1 > cchResult)
        {
            // Not enough room
            hr = S_FALSE;
            goto Cleanup;
        }

        _tcscpy(pwzResult, cstr);
    }
    else
    {
        hr = THR_NOTRACE(super::ParseUrl(
            pwzUrl,
            ParseAction,
            dwFlags,
            pwzResult,
            cchResult,
            pcchResult,
            dwReserved));
    }
    
Cleanup:    
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


const CBase::CLASSDESC CJSProtocol::s_classdesc =
{
    &CLSID_JSProtocol,              // _pclsid
};


//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocol::CJSProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CJSProtocol::CJSProtocol(IUnknown *pUnkOuter) : super(pUnkOuter)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocol::~CJSProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CJSProtocol::~CJSProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CJSProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding & execution of script.
//
//----------------------------------------------------------------------------

HRESULT
CJSProtocol::ParseAndBind()
{
    HRESULT         hr = S_OK;
    TCHAR *         pchScript = NULL;
    CVariant        Var;
    CStr            cstrResult;
    CStr            cstrProtocol;
    CROStmOnBuffer *prostm = NULL;
    UINT            uProt;
    IHTMLWindow2 *  pHTMLWindow = NULL;
    CWindow *       pWindow = NULL;
    TCHAR *         pchOutput = NULL;
    BYTE *          pbOutput = NULL;
    long            cb = 0;
    BOOL            fAllow = FALSE;
    DWORD           dwPolicyTo;
    CScriptCollection * pScriptCollection = NULL;    

    // skip protocol part
    pchScript = _tcschr(_cstrURL, ':');
    if (!pchScript)
    {
        hr = MK_E_SYNTAX;
        goto Cleanup;
    }

    hr = THR(cstrProtocol.Set(_cstrURL, pchScript - _cstrURL));
    if (hr)
        goto Cleanup;

    // Go past the :
    pchScript++;
    
    uProt = GetUrlScheme(_cstrURL);
    Assert(URL_SCHEME_VBSCRIPT == uProt || 
           URL_SCHEME_JAVASCRIPT == uProt);
    
    hr = THR(QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void **) &pHTMLWindow));

    if (hr == S_OK)
    {
        hr = pHTMLWindow->QueryInterface(CLSID_HTMLWindow2, (void **) &pWindow);
        if (hr)
            goto Cleanup;

        pScriptCollection = pWindow->_pMarkup->GetScriptCollection();

        // check cross domain access rights for this script
        if (pScriptCollection)
        {
            CStr    cstrSourceUrl;
            TCHAR * pchUrl = NULL;

            //
            TraceTag((tagSecurityContext, "CJSProtocol::ParseAndBind - GetBindInfoParam"));

            // Get the security ID for the parent document, if the bind context carries one
            if (S_OK == GetBindInfoParam(_pOIBindInfo, &cstrSourceUrl))
                pchUrl = cstrSourceUrl;

            // check if the security settings allow running scripts for this domain
            hr = THR(pWindow->_pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                         &fAllow, 
                                                         0, 
                                                         &dwPolicyTo, 
                                                         pchUrl));
            if (hr)
                goto Cleanup;

            // Only allow script to execute if security settings allow it and security context's match
            //
            if (fAllow && cstrSourceUrl.Length() && 
                !pWindow->_pMarkup->AccessAllowed(cstrSourceUrl))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
        }
    }
    else
    {
        fAllow = TRUE;
    }

    if (fAllow)
    {
        if (pScriptCollection)
        {
            // Any errors from this are ignored so URLMON doesn't throw
            // an exception to IE which causes them to shutdown due to an
            // unexpected error. -- TerryLu.
            IGNORE_HR(pScriptCollection->ParseScriptText(
                        cstrProtocol,           // pchLanguage
                        NULL,                   // pMarkup
                        NULL,                   // pchType
                        pchScript,              // pchCode
                        DEFAULT_OM_SCOPE,       // pchItemName
                        NULL,                   // pchDelimiter
                        0,                      // ulOffset
                        0,                      // ulStartingLine
                        NULL,                   // pSourceObject
                        SCRIPTTEXT_ISVISIBLE | SCRIPTTEXT_ISEXPRESSION, // dwFlags
                        &Var,                   // pvarResult
                        NULL));                 // pExcepInfo

            if (V_VT(&Var) != VT_EMPTY)
            {
                hr = THR(VariantToPrintableString(&Var, &cstrResult));
                if (hr)
                    goto Cleanup;

                hr = THR(MemAllocString(Mt(JSProtResult), cstrResult, &pchOutput));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                //
                // There was no output from the script.  Since we got back
                // a document from the target frame, abort now.
                //
            
                hr = E_ABORT;
            }
        }
        else
        {
            //
            // New document.  Execute script in this new 
            // document's context.
            //

            hr = THR(Format(
                    FMT_OUT_ALLOC,
                    &pchOutput,
                    0,
                    WRITTEN_SCRIPT,
                    (LPTSTR)cstrProtocol,
                    pchScript));
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Convert string into a stream.
    //

    if (pchOutput)
    {
        cb = WideCharToMultiByte(
                _bindinfo.dwCodePage,
                0, 
                pchOutput, 
                -1, 
                NULL, 
                0,
                NULL, 
                NULL);

        pbOutput = new(Mt(CJSProtocolParseAndBind_pbOutput)) BYTE[cb + 1];
        if (!pbOutput)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        WideCharToMultiByte(
                _bindinfo.dwCodePage,
                0, 
                pchOutput, 
                -1, 
                (char *)pbOutput, 
                cb,
                NULL, 
                NULL);
        
        prostm = new CROStmOnBuffer();
        if (!prostm)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(prostm->Init(pbOutput, cb));
        if (hr)
            goto Cleanup;
            
        _pStm = (IStream *)prostm;
        _pStm->AddRef();
    }
    
Cleanup:
    if (!_fAborted)
    {
        if (!hr)
        {
            _pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, CFSTR_MIME_HTML);

            _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
            _pProtSink->ReportData(_bscf, cb, cb);
        }
        if (_pProtSink)
        {
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    ReleaseInterface(pHTMLWindow);
    if (prostm)
    {
        prostm->Release();
    }
    MemFreeString(pchOutput);
    delete pbOutput;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\site\base\logmgr.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LOGMGR_HXX_
#define X_LOGMGR_HXX_
#include "logmgr.hxx"
#endif

#ifndef X_MARKUP_HXX
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_CHNGLOG_HXX_
#define X_CHNGLOG_HXX_
#include "chnglog.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif 

#ifndef X_STYLE_HXX
#define X_STYLE_HXX
#include "style.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif // X_GENERIC_HXX_



MtDefine(CLogManager_ChangeRecord_pv, Tree, "CLogManager::ChangeRecord_pv");
MtDefine(CLogManager_aryLogs_pv, Tree, "CLogManager::_aryLogs_pv");
MtDefine(CLogManager_aryfElemInTree, Locals, "CLogManager::ConvertChunksToRecords data array");

DeclareTag(tagTraceTreeSync, "TreeSync", "Trace TreeSync actions");

CLogManager::CLogManager( CMarkup * pMarkup ) 
    : _aryLogs(Mt(CLogManager_aryLogs_pv))
{
    TraceTag((tagTraceTreeSync, "TreeSync: Creating Log Manager"));

    _pMarkup = pMarkup;
    _dwFlags = 0;
    pMarkup->QueryService( IID_ISequenceNumber, IID_ISequenceNumber, (void **)&_pISequencer );
    _nSequenceNumber = _pISequencer ? -1 : 0;

    // Set up the queue
    _pchrecHead = _pchrecTail = NULL;
}

CLogManager::~CLogManager()
{
    TraceTag((tagTraceTreeSync, "TreeSync: Destroying Log Manager"));

    // Kill any outstanding callback we may have posted
    if( TestCallbackPosted() )
    {
        ClearCallbackPosted();
        GWKillMethodCall( this, ONCALL_METHOD(CLogManager, NotifySinksCallback, notifysinkscallback), 0 );
    }

    DisconnectFromMarkup();
    Assert( _aryLogs.Size() == 0 && _pchrecHead == NULL && _pchrecTail == NULL );

    ReleaseInterface( _pISequencer );
}


/*******************************************************************/
/*                  Record creation functions                      */
/*******************************************************************/

//+----------------------------------------------------------------+
//
//  Method: InsertText
//
//  Synopsis: Creates and appends a Change Record for an Insert
//      Text operation.
//
//+----------------------------------------------------------------+

HRESULT
CLogManager::InsertText( long cp, long cch, const TCHAR * pchText )
{
    HRESULT                     hr = S_OK;
    CChangeRecord_TextChange *  pchrec;
    long                        cchRec = TestForward() ? cch : 0;

    WHEN