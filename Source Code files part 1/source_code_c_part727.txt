Alloc(pOEMUIPSParam->hOEMHeap,
                                                             HEAP_ZERO_MEMORY,
                                                             sizeof(UIDATA))))
                {
                    PROPSHEETPAGE   Page;
                    PUIDATA         pUiData = (PUIDATA)pPSUIInfo->UserData;
                    FILEDATA        FileData;   // <- pFileData (formerly use MemAllocZ) @2000/03/15

                    // read PRINT_DONE flag from data file
                    FileData.fUiOption = 0;
// @Mar/01/2002 ->
//                    RWFileData(&FileData, pOEMExtra->SharedFileName, GENERIC_READ);
                    RWFileData(&FileData, pOEMExtra->SharedFileName, sizeof(pOEMExtra->SharedFileName), GENERIC_READ);
// @Mar/01/2002 <-
                    // set PRINT_DONE flag
                    if (BITTEST32(FileData.fUiOption, PRINT_DONE))
                        BITSET32(pOEMExtra->fUiOption, PRINT_DONE);
                    VERBOSE((DLLTEXT("** Flag=%lx,File Name=%ls **\n"),
                            pOEMExtra->fUiOption, pOEMExtra->SharedFileName));

                    pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
                    pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                    pUiData->pOEMExtra = pOEMExtra;

                    // Init property page.
// Use SecureZeroMemory  @Mar/29/2002 ->
#if defined(WINNT_40) || defined(RICOH_RELEASE)
                    memset(&Page, 0, sizeof(PROPSHEETPAGE));
#else
                    SecureZeroMemory(&Page, sizeof(PROPSHEETPAGE));
#endif
// Mar/29/2002 <-
                    Page.dwSize = sizeof(PROPSHEETPAGE);
                    Page.dwFlags = PSP_DEFAULT;
                    Page.hInstance = ghInstance;
                    Page.pszTemplate = MAKEINTRESOURCE(IDD_JOBMAIN);
                    Page.pfnDlgProc = JobPageProc;
                    Page.lParam = (LPARAM)pUiData;

                    // Add property sheets.
                    lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet,
                                                         CPSFUNC_ADD_PROPSHEETPAGE,
                                                         (LPARAM)&Page, 0);
                    pUiData->hPropPage = (HANDLE)lResult;
                    VERBOSE((DLLTEXT("** INIT: lResult=%x **\n"), lResult));
                    lResult = (lResult > 0)? TRUE : FALSE;
                }
#endif // JOBLOGSUPPORT_DLG
#endif // GWMODEL
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            lResult = TRUE;
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            if (pPSUIInfo->UserData)
            {
                POEMUIPSPARAM   pOEMUIPSParam = (POEMUIPSPARAM)pPSUIInfo->lParamInit;

                HeapFree(pOEMUIPSParam->hOEMHeap, 0, (void*)pPSUIInfo->UserData);
            }
            break;
    }

    pPSUIInfo->Result = lResult;
    return lResult;
} //*** OEMDocumentPropertySheets

} // End of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\rpdlui\rpdlui.h ===
//#ifndef _OEMUI_H
//#define _OEMUI_H

/*++

Copyright (c) 1996-2002  Microsoft Corp. & Ricoh Co., Ltd. All rights reserved.

FILE:           RPDLUI.H

Abstract:       Header file for OEM UI plugin.

Environment:    Windows NT Unidrv5 driver

Revision History:
    04/22/99 -Masatoshi Kubokura-
        Last modified for Windows2000.
    09/29/99 -Masatoshi Kubokura-
        Modified for NT4SP6(Unidrv5.4).
    02/10/2000 -Masatoshi Kubokura-
        V.1.02
    05/22/2000 -Masatoshi Kubokura-
        V.1.03 for NT4
    11/29/2000 -Masatoshi Kubokura-
        Last modified for Whistler.
    10/04/2001 -Masatoshi Kubokura-
        Add MF1340,1540.
    03/05/2002 -Masatoshi Kubokura-
        Add RIFAX PRN TYPE N.
    03/18/2002 -Masatoshi Kubokura-
        RIFAX PRN TYPE N -> RIFAX ML4600

--*/

BYTE UpdateDate[] = "03/05/2002";

// registry value name
#define REG_HARDDISK_INSTALLED  L"HardDiskInstalled"

//
// Unique models (no duplex, scaling, fax)
//
typedef struct {
    LPWSTR  Name;
    DWORD   fCapability;
} UNIQUEMODEL;

UNIQUEMODEL UniqueModel[] = {
#ifndef GWMODEL
    {L"RICOH SP4mkII(+) RPDL",           BIT(OPT_NODUPLEX)},
    {L"RICOH SP5(+) RPDL",               BIT(OPT_NODUPLEX)},
    {L"RICOH SP7 RPDL",                  BIT(OPT_NODUPLEX)},
    {L"RICOH SP8 RPDL",                  BIT(OPT_NODUPLEX)},
    {L"RICOH SP80 RPDL",                 BIT(OPT_NODUPLEX)},
    {L"RICOH SP-10PS RPDL",              BIT(OPT_NODUPLEX)},
    {L"RICOH SP-90 RPDL",                BIT(OPT_NODUPLEX)},
    {L"RICOH NX-100 RPDL",               BIT(OPT_NODUPLEX)},
    {L"RICOH NX-110 RPDL",               BIT(OPT_NODUPLEX)},
    {L"RICOH NX-210 RPDL",               BIT(OPT_NODUPLEX)},
    {L"RICOH IP-1 RPDL",                 BIT(OPT_NODUPLEX)},
    {L"RICOH imagio MF3300W RPDL",       BIT(OPT_NODUPLEX)},
    {L"RICOH IPSiO NX70 RPDL",           BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH IPSiO NX600 RPDL",          BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH IPSiO NX700 RPDL",          BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH IPSiO NX900 RPDL",          BIT(OPT_VARIABLE_SCALING)},    // @Jan/07/99
    {L"RICOH IMAGIO MF-P250(T) RPDL",    BIT(OPT_NODUPLEX)},
    {L"RICOH IMAGIO MF-P250e RPDL",      BIT(OPT_NODUPLEX)},
    {L"RICOH IMAGIO MF-P250 RPDL(FAX)",  BIT(OPT_NODUPLEX)|BIT(FAX_MODEL)},
    {L"RICOH IMAGIO MF-P355 RPDL(FAX)",  BIT(FAX_MODEL)},
    {L"RICOH imagio MF2700 RPDL(FAX)",   BIT(FAX_MODEL)},
    {L"RICOH imagio MF3500 RPDL(FAX)",   BIT(FAX_MODEL)},
    {L"RICOH imagio MF3550 RPDL(FAX)",   BIT(FAX_MODEL)},
    {L"RICOH imagio MF4550 RPDL(FAX)",   BIT(FAX_MODEL)},
// @Feb/16/99 ->
    {L"RICOH imagio MF3530 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3570 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF4570 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3530 RPDL(FAX)",   BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF3570 RPDL(FAX)",   BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF4570 RPDL(FAX)",   BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
// @Feb/16/99 <-
// @Mar/03/99 ->
    {L"RICOH IPSiO NX710 RPDL",          BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF1530 RPDL",        BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF1530 RPDL(FAX)",   BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
// @Mar/03/99 <-
// @Mar/10/99 ->
    {L"RICOH IPSiO NX610 RPDL",          BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH IPSiO NX800 RPDL",          BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF5550EX RPDL",      BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF6550EX RPDL",      BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH FAX Printer RPDL",          BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
// @Mar/10/99 <-
// @Mar/19/99 ->
    {L"RICOH imagio MF2230 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF2730 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF2230 RPDL(FAX)",   BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF2730 RPDL(FAX)",   BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
// @Mar/19/99 <-
// @Feb/10/2000 ->
    {L"RICOH IPSiO NX910 RPDL",          BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH IPSiO MF700 RPDL",          BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3530e RPDL",       BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3570e RPDL",       BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF4570e RPDL",       BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF5570 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF7070 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF8570 RPDL",        BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3530e RPDL(FAX)",  BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF3570e RPDL(FAX)",  BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF4570e RPDL(FAX)",  BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
// @Feb/10/2000 <-
// @Apr/27/2000 ->
    {L"RICOH IPSiO NX71 RPDL",           BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH IPSiO NX810 RPDL",          BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF105Pro RPDL",      BIT(OPT_VARIABLE_SCALING)},
// @Apr/27/2000 <-
// @Sep/26/2000 ->
    {L"RICOH IPSiO NX410 RPDL",          BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3540W RPDL",       BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3540W RPDL(FAX)",  BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF3580W RPDL",       BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF3580W RPDL(FAX)",  BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
// @Sep/26/2000 <-
// @Oct/04/2001 ->
    {L"RICOH imagio MF1340 RPDL",        BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF1340 RPDL(FAX)",   BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
    {L"RICOH imagio MF1540 RPDL",        BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)},
    {L"RICOH imagio MF1540 RPDL(FAX)",   BIT(OPT_NODUPLEX)|BIT(OPT_VARIABLE_SCALING)|BIT(FAX_MODEL)},
// @Oct/04/2001 <-
#else  // GWMODEL
    {L"RICOH RIFAX ML4600 RPDL",         BIT(OPT_NODUPLEX)},  // @Mar/18/2002
#endif // GWMODEL
    {L"", 0}                                                // 0:terminator
};
//#endif // !_OEMUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\st24tres\etc\star24ec.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "STAR24EC";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\appcompat.h ===
/*++
Copyright (c) 2000, Microsoft Corporation

Module Name:

    appcompat.h

Abstract:

    Definitions and prototypes for the app compat functions that are not
    published in the DDK but that we need to build the printer drivers off it.
    Normally they reside in winuserp.h/user32p.lib.

--*/

#ifndef _WINUSERP_
#ifndef _PRINTAPPCOMPAT_
#define _PRINTAPPCOMPAT_

#ifdef BUILD_FROM_DDK

#define GACF2_NOCUSTOMPAPERSIZES  0x00001000  // PostScript driver bit for Harvard Graphics
#define VER40           0x0400

#else

#include <winuserp.h>

#endif

DWORD GetAppCompatFlags2(WORD);

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\yjlbpres\etc\yjlbp.c ===
//----------------------------------------------------------------------------//
// Filename:    yjlbp.c                                                       //
//                                                                            //
// This file contains code for using Scalable Fonts on Yangjae Page printers  //
//                                                                            //
//  Copyright (c) 1992-1994 Microsoft Corporation                             //
//----------------------------------------------------------------------------//

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

// Added code in OEMSendScalableFontCmd to check for English or
// Hangeul Font Width command - Garydo 1/20/95

char *rgchModuleName = "YJLBP";

#define PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"
#include <memory.h>

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#define CCHMAXCMDLEN            128

typedef struct
{
  BYTE  fGeneral;       // General purpose bitfield
  BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
  WORD  wCount;         // # of EXTCD structures following
  WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

#ifdef WINNT
LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprint
#define wsprintf sprintf

#define GlobalAllocPtr(a,b)  UniDrvAllocMem(b)
#define GlobalFreePtr  UniDrvFreeMem
#endif //WINNT



//----------------------------*OEMScaleWidth*--------------------------------
// Action: return the scaled width which is calcualted based on the
//      assumption that Yangjae printers assume 72 points in one 1 inch.
//
// Formulas:
//  <extent> : <font units> = <base Width> : <hRes>
//  <base width> : <etmMasterHeight> = <newWidth> : <newHeight>
//  <etmMasterUnits> : <etmMasterHeight> = <font units> : <vRes>
// therefore,
//   <newWidth> = (<extent> * <hRes> * <newHeight>) / 
//                  (<etmMasterUnits> * <vRes>)
//---------------------------------------------------------------------------
short FAR PASCAL OEMScaleWidth(width, masterUnits, newHeight, vRes, hRes)
short width;        // in units specified by 'masterUnits'.
short masterUnits;
short newHeight;    // in units specified by 'vRes'.
short vRes, hRes;   // height and width device units.
{
    DWORD newWidth10;
    short newWidth;

    // assert that hRes == vRes to avoid overflow problem.
    if (vRes != hRes)
        return 0;

    newWidth10 = (DWORD)width * (DWORD)newHeight * 10;
    newWidth10 /= (DWORD)masterUnits;

    // we multiplied 10 first in order to maintain the precision of
    // the width calcution. Now convert it back and round to the
    // nearest integer.
    newWidth = (short)((newWidth10 + 5) / 10);

    return newWidth;
}


//---------------------------*OEMSendScalableFontCmd*--------------------------
// Action:  send Qnix-style font selection command.
//-----------------------------------------------------------------------------
VOID FAR PASCAL OEMSendScalableFontCmd(lpdv, lpcd, lpFont)
LPDV    lpdv;
LPCD    lpcd;     // offset to the command heap
LPFONTINFO lpFont;
{
    LPSTR   lpcmd;
    short   ocmd;
    WORD    i;
    BYTE    rgcmd[CCHMAXCMDLEN];    // build command here

    if (!lpcd || !lpFont)
        return;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd+1);
    ocmd = 0;

    for (i = 0; i < lpcd->wLength && ocmd < CCHMAXCMDLEN; )
        if (lpcmd[i] == '#' && lpcmd[i+1] == 'Y')      // height
        {
            long    height;

            // use 1/300 inch unit, which should have already been set.
            // convert font height to 1/300 inch units
            height = ((long)(lpFont->dfPixHeight - lpFont->dfInternalLeading)
                      * 300)  / lpFont->dfVertRes ;

            ocmd += wsprintf(&rgcmd[ocmd], "%ld", height);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'X')     // pitch
        {
            if (lpFont->dfPixWidth > 0)
            {
                long width;

                // Check if we are going to print an English Font, if so
                // then we use PixWidth, Else use MaxWidth which is
                // twice as wide in DBCS fonts.
                // Note: Command Format = '\x1B+#X;#Y;1C' or '\x1B+#X;#Y;2C'
                // Or, in text: ESC+<Width>;<Height>;<Font type>C
                // English Font type = 1, Korean Font = 2.

                if (lpcmd[i+6] == '1')
                        width = ((long)(lpFont->dfPixWidth) * 300) / (lpFont->dfHorizRes);
                else
                        width = ((long)(lpFont->dfMaxWidth) * 300) / (lpFont->dfHorizRes);

                ocmd += wsprintf(&rgcmd[ocmd], "%ld", width);

            }
            i += 2;
            
        }
        else
            rgcmd[ocmd++] = lpcmd[i++];

    WriteSpoolBuf(lpdv, (LPSTR) rgcmd, ocmd);
}

#ifdef WINNT

DRVFN  MiniDrvFnTab[] =
{

    {  INDEX_OEMScaleWidth1,          (PFN)OEMScaleWidth  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
};
/*************************** Function Header *******************************
 *  MiniDrvEnableDriver
 *      Requests the driver to fill in a structure containing recognized
 *      functions and other control information.
 *      One time initialization, such as semaphore allocation may be
 *      performed,  but no device activity should happen.  That is done
 *      when dhpdevEnable is called.
 *      This function is the only way the rasdd can determine what
 *      functions we supply to it.
 *
 * HISTORY:
 *  June 19, 1996   -by-    Weibing Zhan [Weibz]
 *      Created it,  following KK Codes.
 *
 ***************************************************************************/
BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}
#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\afm2ntm.h ===
/*++

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996-1999  Microsoft Corporation


Module Name:

    afm2ntm.h

Abstract:

    Header file for converting AFM to NTM.

Environment:

    Windows NT PostScript driver.

Revision History:

    02/16/1998  -ksuzuki-
        Added CS_SHIFTJIS83 and others for OCF font support.

    10/17/1997  -ksuzuki-
        Added CJK CMap names, fixed typos, and did clean-up.

    10/24/1996  rkiesler@adobe.com
        Implemented.

    09/16/1996  -slam-
        Created.
--*/


#ifndef _AFM2NTM_H_
#define _AFM2NTM_H_

//
// Parsing Macros.
//

#define EOL(a)  \
    (*a == '\r' || *a == '\n')

#define IS_EOF(a)  \
    (*a == -1)

#define IS_WHTSPACE(a) \
    (*(a) <= ' ')

#define IS_ALPHA(a) \
    ((*a > 'A' && *a < 'Z') || (*a > 'a' && *a < 'z'))

#define IS_NUM(a) \
    (*(a) >= '0' && *(a) <= '9')

#define IS_HEX_ALPHA(a) \
    ((*(a) >= 'a' && *(a) <= 'f') || (*(a) >= 'A' && *(a) <= 'F'))

#define IS_HEX_DIGIT(a) \
    (IS_NUM(a) || IS_HEX_ALPHA(a))

#define SKIP_WHTSPACE(a)     \
    while ((IS_WHTSPACE(a)) && (!IS_EOF(a))) \
    {                        \
        ((ULONG_PTR) a)++;       \
    }

#define NEXT_LINE(a)    \
    while ((!EOL(a)) && (!IS_EOF(a)))   \
    {                   \
        ((ULONG_PTR) a)++;  \
    }                   \
    SKIP_WHTSPACE(a)

#define PARSE_TOKEN(a, Tok) \
    SKIP_WHTSPACE(a); \
    Tok = a; \
    do \
    { \
        if (!IS_EOF(a)) \
            ((ULONG_PTR) a)++; \
    } while (!IS_WHTSPACE(a) && !IS_EOF(a)); \
    while (!EOL(a) && !IS_EOF(a) && IS_WHTSPACE(a)) \
    { \
        ((ULONG_PTR) a)++; \
    }
#define NEXT_TOKEN(a) \
    while(!EOL(a) && *(a) != ';')           \
        ((ULONG_PTR) a)++;                      \
    while ((*(a) == ';' || IS_WHTSPACE(a))) \
    {                                       \
        ((ULONG_PTR) (a))++;                    \
    }

#define PARSE_RECT(ptr, rect)               \
        rect.left = atoi(ptr);              \
        while (!IS_WHTSPACE(ptr))           \
            ptr++;                          \
        SKIP_WHTSPACE(ptr);                 \
        rect.bottom = atoi(ptr);            \
        while (!IS_WHTSPACE(ptr))           \
            ptr++;                          \
        SKIP_WHTSPACE(ptr);                 \
        rect.right = atoi(ptr);             \
        while (!IS_WHTSPACE(ptr))           \
            ptr++;                          \
        SKIP_WHTSPACE(ptr);                 \
        rect.top = atoi(ptr);               \
        while (!IS_WHTSPACE(ptr))           \
            ptr++;                          \
        SKIP_WHTSPACE(ptr)



//
// Macro to detect comments in font .DAT files. This macro is NOT for use
// with AFMs.
//
#define IS_COMMENT(a) \
    (*(a) == '#')

//
// Token structure.
//
typedef struct _AFM_TOKEN
{
    PSZ psTokName;              // ASCII Key Name
    PFN pfnTokHndlr;            // Ptr to token handler fct
} AFM_TOKEN;

#define PS_CH_METRICS_TOK       "StartCharMetrics"
#define PS_CH_NAME_TOK          "N"
#define PS_CH_CODE_TOK          "C"
#define PS_CH_BBOX_TOK          "B"
#define PS_FONT_NAME_TOK        "FontName"
#define PS_FONT_FULL_NAME_TOK   "FullName"
#define PS_FONT_MS_NAME_TOK     "MSFaceName"
#define PS_FONT_FAMILY_NAME_TOK "FamilyName"
#define PS_FONT_VERSION_TOK     "Version"
#define PS_CHAR_WIDTH_TOK       "CharWidth"
#define PS_PITCH_TOK            "IsFixedPitch"
#define PS_CH_WIDTH_TOK         "WX"
#define PS_CH_WIDTH0_TOK        "W0X"
#define PS_COMMENT_TOK          "Comment"
#define PS_END_METRICS_TOK      "EndCharMetrics"
#define PS_FONT_BBOX_TOK        "FontBBox"
#define PS_FONT_BBOX2_TOK       "FontBBox2"
#define PS_EOF_TOK              "EndFontMetrics"
#define PS_UNDERLINE_POS_TOK    "UnderlinePosition"
#define PS_UNDERLINE_THICK_TOK  "UnderlineThickness"
#define PS_KERN_DATA_TOK        "StartKernData"
#define PS_NUM_KERN_PAIRS_TOK   "StartKernPairs"
#define PS_END_KERN_PAIRS_TOK   "EndKernPairs"
#define PS_KERN_PAIR_TOK        "KPX"
#define PS_CHARSET_TOK          "CharacterSet"
#define PS_STANDARD_CHARSET_TOK "Standard"
#define PS_SPECIAL_CHARSET_TOK  "Special"
#define PS_EXTENDED_CHARSET_TOK "ExtendedRoman"
#define PS_ITALIC_TOK           "ItalicAngle"
#define PS_WEIGHT_TOK           "Weight"
#define PS_ENCODING_TOK         "EncodingScheme"
#define PS_SYMBOL_ENCODING      "FontSpecific"
#define PS_STANDARD_ENCODING    "AdobeStandardEncoding"
#define PS_CH_NAME_EASTEUROPE   "ncaron"
#define PS_CH_NAME_RUSSIAN      "afii10071"
#define PS_CH_NAME_ANSI         "ecircumflex"
#define PS_CH_NAME_GREEK        "upsilondieresis"
#define PS_CH_NAME_TURKISH      "Idotaccent"
#define PS_CH_NAME_HEBREW       "afii57664"
#define PS_CH_NAME_ARABIC       "afii57410"
#define PS_CH_NAME_BALTIC       "uogonek"
#define PS_CIDFONT_TOK          "IsCIDFont"
#define CHAR_NAME_LEN           50
#define NUM_PS_CHARS            602
#define NUM_UNICODE_CHARS       0x10000
#define MAX_TOKENS              3
#define NUM_CHARSETS            8
#define CS_THRESHOLD            200
#define MAX_CSET_CHARS          256
#define MAX_ASCII               127
#define CAP_HEIGHT_CHAR         "H"
#define CAP_HEIGHT_CH           'H'
#define X_HEIGHT_CHAR           "x"
#define X_HEIGHT_CH             'x'
#define LWR_ASCENT_CHAR         "d"
#define LWR_ASCENT_CH           'd'
#define LWR_DESCENT_CHAR        "p"
#define LWR_DESCENT_CH          'p'
#define UNICODE_PRV_STRT        0xf000
#define ANSI_CCODE_MAX          0x007f

// Equivalent symbol to '.notdef1f' (ref. unipstbl.c)
#define NOTDEF1F                0x1f

// Some CharSet numbers made up - only meaningful to the driver itself
#define ADOBE228_CHARSET 255    // Internally, we use the CodePage 0xFFF1 to match CharCol256
#define ADOBE314_CHARSET 255    // Internally, we use the CodePage 0xFFF2 to match CharCol257

// Special codepage for symbol fonts and the driver itself
#define SYMBOL_CODEPAGE 4

//
// Defs related to FD_GLYPHSET (unicode->glyphindex map) generation.
//
// Type which indicates source of "recommended" PS character name.
//
typedef enum
{
    SRC_NONE,                   // There is no "recommended" PS char name
    SRC_ADOBE_CURRENT,          // Font name used in "shipping" font
    SRC_ADOBE_FUTURE,           // Font name to be used in future fonts
    SRC_MSDN,                   // Name from MS Dev Network Docs
    SRC_AFII                    // Some folks met and agreed on this name
} CHARNAMESRC;

//
// Possible Charsets supported by this font. Note that the charsets are
// listed in Win 3.x codepage order.
//
typedef enum
{
    CS_228 = 0,
    CS_314,
    CS_EASTEUROPE,
    CS_SYMBOL,
    CS_RUSSIAN,
    CS_ANSI,
    CS_GREEK,
    CS_TURKISH,
    CS_HEBREW,
    CS_ARABIC,
    CS_BALTIC,
    CS_ANSI_RUS,
    CS_ANSI_RUS_EE_BAL_TURK,

    CS_WEST_MAX,

    CS_CHINESEBIG5 = CS_WEST_MAX,
    CS_GB2312,
    CS_SHIFTJIS,
    CS_SHIFTJISP,
    CS_SHIFTJIS83,              // Bogus for OCF font support
    CS_HANGEUL,
    CS_HANGEULHW,               // Added for fixing bug 360206
    CS_JOHAB,

    CS_MAX,

    CS_UNICODE,                 // This codepage NOT to be referenced by NTMs!
    CS_DEFAULT,
    CS_OEM,
    CS_VIETNAMESE,
    CS_THAI,
    CS_MAC,
    CS_NOCHARSET
} CHSETSUPPORT, *PCHSETSUPPORT;

#define CS_UNIQUE   CS_MAX      // Charset is unique to this font.

#define CS_EURO \
    (\
        CSUP(CS_228)                    | \
        CSUP(CS_EASTEUROPE)             | \
        CSUP(CS_RUSSIAN)                | \
        CSUP(CS_ANSI)                   | \
        CSUP(CS_GREEK)                  | \
        CSUP(CS_TURKISH)                | \
        CSUP(CS_HEBREW)                 | \
        CSUP(CS_ARABIC)                 | \
        CSUP(CS_BALTIC)                  \
    )


#define CS_ALL \
    (\
        CSUP(CS_228)                    | \
        CSUP(CS_314)                    | \
        CSUP(CS_EASTEUROPE)             | \
        CSUP(CS_SYMBOL)                 | \
        CSUP(CS_RUSSIAN)                | \
        CSUP(CS_ANSI)                   | \
        CSUP(CS_GREEK)                  | \
        CSUP(CS_TURKISH)                | \
        CSUP(CS_HEBREW)                 | \
        CSUP(CS_ARABIC)                 | \
        CSUP(CS_BALTIC)                 | \
        CSUP(CS_ANSI_RUS)               | \
        CSUP(CS_ANSI_RUS_EE_BAL_TURK)   | \
                                          \
        CSUP(CS_CHINESEBIG5)            | \
        CSUP(CS_GB2312)                 | \
        CSUP(CS_SHIFTJIS)               | \
        CSUP(CS_SHIFTJISP)              | \
        CSUP(CS_SHIFTJIS83)             | \
        CSUP(CS_HANGEUL)                | \
        CSUP(CS_HANGEULHW)              | \
        CSUP(CS_JOHAB)                  | \
                                          \
        CSUP(CS_DEFAULT)                | \
        CSUP(CS_OEM)                    | \
        CSUP(CS_VIETNAMESE)             | \
        CSUP(CS_THAI)                   | \
        CSUP(CS_MAC)                      \
    )

#define CS_CJK \
    (\
        CSUP(CS_CHINESEBIG5)            | \
        CSUP(CS_GB2312)                 | \
        CSUP(CS_SHIFTJIS)               | \
        CSUP(CS_SHIFTJISP)              | \
        CSUP(CS_SHIFTJIS83)             | \
        CSUP(CS_HANGEUL)                | \
        CSUP(CS_HANGEULHW)              | \
        CSUP(CS_JOHAB)                    \
    )

//
// Standard GLYPHSETDATA names. These are #defines as someday they may
// become public.
//
#define ADOBE228_GS_NAME                "228"
#define ADOBE314_GS_NAME                "314"
#define EASTEUROPE_GS_NAME              "Eastern European"
#define SYMBOL_GS_NAME                  "Symbol"
#define CYRILLIC_GS_NAME                "Cyrillic"
#define ANSI_GS_NAME                    "ANSI"
#define GREEK_GS_NAME                   "Greek"
#define TURKISH_GS_NAME                 "Turkish"
#define HEBREW_GS_NAME                  "Hebrew"
#define ARABIC_GS_NAME                  "Arabic"
#define BALTIC_GS_NAME                  "Baltic"
#define ANSI_CYR_GS_NAME                "ANSI/Cyrillic"
#define ANSI_CYR_EE_BAL_TURK_GS_NAME    "ANSI/Cyrillic/EastEurope/Baltic/Turkish"
#define CHN_BIG5_GS_NAME                "--ETen-B5-"
#define CHN_SMPL_GBK_GS_NAME            "--GBK-EUC-"
#define SHIFTJIS_GS_NAME                "-90ms-RKSJ-"
#define SHIFTJIS_P_GS_NAME              "-90msp-RKSJ-"
#define KSCMS_UHC_GS_NAME               "--KSCms-UHC-"
#define KSC_JOHAB_GS_NAME               "--KSC-Johab-"
#define UNICODE_GS_NAME                 "Unicode"

#define CHN_SMPL_GB_GS_NAME             "--GB-EUC-"
#define CHN_SMPL_GBT_GS_NAME            "--GBT-EUC-"
#define CHN_B5_GS_NAME                  "--B5-"
#define SHIFTJIS_83PV_GS_NAME           "-83pv-RKSJ-"
#define KSC_GS_NAME                     "--KSC-EUC-"
#define KSCMS_UHC_HW_GS_NAME            "--KSCms-UHC-HW-"

#define SHIFTJIS_P_GS_HNAME             "-90msp-RKSJ-H"
#define SHIFTJIS_P_GS_VNAME             "-90msp-RKSJ-V"

#define KSCMS_UHC_GS_HNAME               "--KSCms-UHC-H"
#define KSCMS_UHC_GS_VNAME               "--KSCms-UHC-V"

//
// CJK related stuff.
//
#define CMAPS_PER_COL   4

//
// Win CJK Codepage values.
//
#define CH_BIG5     950     // Traditional Chinese
#define CH_SIMPLE   936     // Simplified Chinese
#define CH_JIS      932     // Japanese
#define CH_HANA     949     // Korean Wansung
#define CH_JOHAB    1361    // Korean Johab

//
// Font Metrics Stuff.
//
#define EM 1000
#define NOTDEF_WIDTH_BIAS   166     // Bias of space char in avg charwidth
                                    // computation.

//
// Structure to xlat between Postscript char names and unicode code points.
//
typedef struct _UPSCODEPT
{
    WCHAR           wcUnicodeid;            // Unicode code point
    PUCHAR          pPsName;                // PS Char Name
    CHSETSUPPORT    flCharSets;             // Which Win CPs are supported?
} UPSCODEPT, *PUPSCODEPT;

//
// Structure to store AFM char metrics.
//
typedef struct _AFMCHMETRICS
{
    ULONG   chWidth;                        // WX, W0X: Char width
} AFMCHMETRICS, *PAFMCHMETRICS;

//
// PS Char Info Structure.
//
typedef struct _PSCHARMETRICS
{
    CHAR  pPsName[CHAR_NAME_LEN];
    ULONG   chWidth;
    RECT    rcChBBox;
} PSCHARMETRICS, *PPSCHARMETRICS;

//
// Codepage mapping table structure. Maps PS char names to Win
// codepages/codepoints.
//

//
// Win codept to PS char name mapping.
//
typedef struct _WINCPT
{
    PUCHAR  pPsName;                        // PS Char Name
    USHORT  usWinCpt;                       // Windows codept
} WINCPT, *PWINCPT;

//
// Win Codepage to PS char name mapping.
//
typedef struct _WINCPTOPS
{
    USHORT  usACP;                          // Windows ANSI Codepage
    BYTE    jWinCharset;                    // Win 3.1 IFIMETRICS.jWinCharset
    PUCHAR  pGSName;                        // Glyphset name for this Codepage
    ULONG   ulChCnt;                        // Count of supported chars
    WINCPT aWinCpts[MAX_CSET_CHARS];

} WINCPTOPS, *PWINCPTOPS;

//
// Win codepoint to Unicode mapping.
//
typedef struct _UNIWINCPT
{
    WCHAR   wcWinCpt;                       // Windows charcode value
    WCHAR   wcUnicodeid;                    // Unicode id
} UNIWINCPT, *PUNIWINCPT;

//
// Windows codepage structure.
//
typedef struct _WINCODEPAGE
{
    USHORT          usNumBaseCsets;         // # of base csets
    PSZ             pszCPname;              // Name of this "codepage"
    CHSETSUPPORT    pCsetList[CS_MAX];      // ptr to base csets supported
} WINCODEPAGE, *PWINCODEPAGE;

//
// Structure used to store EXTTEXTMETRIC info which must be derived
// from the AFM char metrics. These fields are identical to the fields
// etmCapHeight -> etmLowerCaseDescent in the EXTTEXTMETRIC struct.
//
typedef struct _ETMINFO
{
    SHORT  etmCapHeight;
    SHORT  etmXHeight;
    SHORT  etmLowerCaseAscent;
    SHORT  etmLowerCaseDescent;
} ETMINFO, *PETMINFO;

//
// Generic Key-Value pair.
//
typedef struct _KEY
{
    CHAR    pName[CHAR_NAME_LEN];           // Key name
    USHORT  usValue;                        // Value
} KEY, *PKEY;

//
// Format of table entries which map PS font names to MS face (family) names.
//
typedef struct _PSFAMILYINFO
{
    CHAR    pFontName[CHAR_NAME_LEN];
    CHAR    pEngFamilyName[CHAR_NAME_LEN];
    KEY     FamilyKey;
    USHORT  usPitch;
} PSFAMILYINFO, *PPSFAMILYINFO;

//
// Generic table struct.
//
typedef struct _TBL
{
    USHORT  usNumEntries;                   // Number of PSFAMILYINFOs
    PVOID   pTbl;                           // -> to table entries
} TBL, *PTBL;

//
// Macro used to determine if a particular codept's CHSETSUPPORT field
// (see UPSCODEPT above) indicates support for a particular charset.
//
#define CSUP(a) \
    (1 << a)
#define CSET_SUPPORT(cpt, cset) \
    (cpt & (CSUP(cset)))

//
// Macros used to determine if a char from a glyphset is supported by a
// font. Takes the char index and IsCharDefined table as parms.
//
#define CHR_DEF(gi) \
    (1 << (gi % 8))
#define CHR_DEF_INDEX(gi) \
    (gi / 8)
#define IS_CHAR_DEFINED(gi, cdeftbl) \
    (cdeftbl[CHR_DEF_INDEX(gi)] & CHR_DEF(gi))
#define DEFINE_CHAR(gi, cdeftbl) \
    (cdeftbl[CHR_DEF_INDEX(gi)] |= CHR_DEF(gi))

//
// Macro used to create a void ptr from a pointer to a structure and its
// element name. The result must be cast to the desired type.
//
#ifndef MK_PTR
#define MK_PTR(pstruct, element) ((PVOID)((PBYTE)(pstruct)+(pstruct)->element))
#endif

//
// External global data defined in UNIPSTBL.C.
//
extern ULONG        cFontChsetCnt[CS_MAX];
extern UPSCODEPT    PstoUnicode[NUM_PS_CHARS];
extern PUPSCODEPT   UnicodetoPs;
extern WINCODEPAGE  aStdCPList[];
extern AFM_TOKEN    afmTokenList[MAX_TOKENS];
extern WINCPTOPS    aPStoCP[];
extern WINCODEPAGE  aStdCPList[];
extern char         *TimesAlias[];
extern char         *HelveticaAlias[];
extern char         *CourierAlias[];
extern char         *HelveticaNarrowAlias[];
extern char         *PalatinoAlias[];
extern char         *BookmanAlias[];
extern char         *NewCenturySBAlias[];
extern char         *AvantGardeAlias[];
extern char         *ZapfChanceryAlias[];
extern char         *ZapfDingbatsAlias[];
extern KEY          FontFamilies[];
extern PWCHAR       DatFileName;
extern PTBL         pFamilyTbl;
extern TBL          FamilyKeyTbl;
extern TBL          PitchKeyTbl;
extern TBL          WeightKeyTbl[];
extern TBL          CjkColTbl;
extern ULONG        CharWidthBias[];
extern PWCHAR       CjkFnameTbl[8][CMAPS_PER_COL];
extern WINCODEPAGE  UnicodePage;
extern char         *PropCjkGsNames[];
extern PSTR         pAFMCharacterSetString;

//
// Local fct protos.
//
PNTM
AFMToNTM(
    PBYTE           pAFM,
    PGLYPHSETDATA   pGlyphSetData,
    PULONG          pUniPs,
    CHSETSUPPORT    *pCharSet,
    BOOL            bIsCJKFont,
    BOOL            bIs90mspFont
    );

CHSETSUPPORT
GetAFMCharSetSupport(
    PBYTE           pAFM,
    CHSETSUPPORT    *pGlyphSet
    );

PBYTE
FindAFMToken(
    PBYTE   pAFM,
    PSZ     pszToken
    );

extern int __cdecl
StrCmp(
    const VOID *str1,
    const VOID *str2
    );

extern size_t
StrLen(
    PBYTE   pString
    );

extern int
AFM2NTMStrCpy(
    const VOID *str1,
    size_t     cchDest,
    const VOID *str2
    );

extern int __cdecl
StrPos(
    const PBYTE str1,
    CHAR  c
    );

int __cdecl
CmpUniCodePts(
    const VOID *p1,
    const VOID *p2
    );

static int __cdecl
CmpUnicodePsNames(
    const VOID  *p1,
    const VOID  *p2
    );

extern int __cdecl
CmpPsChars(
    const VOID  *p1,
    const VOID  *p2
    );

ULONG
CreateGlyphSets(
    PGLYPHSETDATA   *pGlyphSet,
    PWINCODEPAGE    pWinCodePage,
    PULONG          *pUniPs
    );

ULONG
BuildPSFamilyTable(
    PBYTE   pDatFile,
    PTBL    *pPsFamilyTbl,
    ULONG   ulFileSize
    );

LONG
FindClosestCodePage(
    PWINCODEPAGE    *pWinCodePages,
    ULONG           ulNumCodePages,
    CHSETSUPPORT    chSets,
    PCHSETSUPPORT   pchCsupMatch
    );

ULONG
GetAFMCharWidths(
    PBYTE           pAFM,
    PWIDTHRUN       *pWidthRuns,
    PPSCHARMETRICS  pFontChars,
    PULONG          pUniPs,
    ULONG           ulChCnt,
    PUSHORT         pusAvgCharWidth,
    PUSHORT         pusMaxCharWidth
    );

ULONG
GetAFMETM(
    PBYTE           pAFM,
    PPSCHARMETRICS  pFontChars,
    PETMINFO        pEtmInfo
    );

ULONG
GetAFMKernPairs(
    PBYTE           pAFM,
    FD_KERNINGPAIR  *pKernPairs,
    PGLYPHSETDATA   pGlyphSetData
    );

static int __cdecl
CmpPsChars(
    const VOID  *p1,
    const VOID  *p2
    );

static int __cdecl
CmpPsNameWinCpt(
    const VOID  *p1,
    const VOID  *p2
    );

static int __cdecl
CmpKernPairs(
    const VOID  *p1,
    const VOID  *p2
    );

int __cdecl
CmpGlyphRuns(
    const VOID *p1,
    const VOID *p2
    );

ULONG
BuildPSCharMetrics(
    PBYTE           pAFM,
    PULONG          pUniPs,
    PPSCHARMETRICS  pFontChars,
    PBYTE           pCharDefTbl,
    ULONG           cGlyphSetChars
);

ULONG
cjGetFamilyAliases(
    IFIMETRICS *pifi,
    PSTR        pstr,
    UINT        cp
    );

PBYTE
FindStringToken(
    PBYTE   pPSFile,
    PBYTE   pToken
    );

BOOLEAN
AsciiToHex(
    PBYTE   pStr,
    PUSHORT pNum
    );

BOOLEAN
IsPiFont(
    PBYTE   pAFM
    );

BOOLEAN
IsCJKFixedPitchEncoding(
    PGLYPHSETDATA pGlyphSetData
    );

PBYTE
FindUniqueID(
    PBYTE   pAFM
    );

#endif  //!_AFM2NTM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\cppfunc.h ===
//
// Copyright (c) 1998 - 1999 Microsoft Corporation
//

inline void* __cdecl operator new(size_t nSize)
{
      // return pointer to allocated memory
      return  DrvMemAllocZ(nSize);
}
inline void __cdecl operator delete(void *p)
{
    if (p)
        DrvMemFree(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\ddint5.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    ddint5.h

Abstract:

    Common header file for NT 4.0 specific declarations for porting unidrv to
    NT 4.0.

Environment:

    Windows NT printer drivers

Revision History:
    Created by:

    17:05:45 on 8/19/1998  -by-    Ganesh Pandey   [ganeshp]


--*/

#ifndef _DDINT5_H_
#define _DDINT5_H_

#ifdef WINNT_40

typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;

#define GCAPS_ARBRUSHTEXT       0x10000000
#define GCAPS_SCREENPRECISION   0x20000000
#define GCAPS_FONT_RASTERIZER   0x40000000

#if defined(_X86_) && !defined(USERMODE_DRIVER)

//
// x86 does not support floating-point instruction in the kernel mode,
// the floating-point data would like be handled 32bits value as double words.
//
typedef DWORD FLOATL;
#else
//
// Any platform that has support for floats in the kernel
//
typedef FLOAT FLOATL;
#endif // _X86_

#define atoi        iDrvAtoi
#define strncpy     pchDrvStrncpy

int    __cdecl  iDrvAtoi(const char *);
char *  __cdecl pchDrvStrncpy(char *, const char *, size_t);

#endif //WINNT_40

#endif // _DDINT5_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\debug.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Macros used for debugging purposes

Environment:

    Windows NT printer drivers

Revision History:

    03/16/96 -davidx-
        Created it.

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5

#if DBG

//
// Strip the directory prefix from a filename (ANSI version)
//

PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    );

extern INT giDebugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

extern VOID DbgPrint(PCSTR, ...);
#define DbgBreakPoint EngDebugBreak

#else

extern ULONG _cdecl DbgPrint(PCSTR, ...);
extern VOID DbgBreakPoint(VOID);

#endif

#define DBGMSG(level, prefix, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                DbgPrint msg; \
            } \
        }

#define DBGPRINT(level, msg) { \
            if (giDebugLevel <= (level)) { \
                DbgPrint msg; \
            } \
        }

#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)
#define ERR(msg) DBGMSG(DBG_ERROR, "ERR", msg)

#ifndef __MDT__         // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond) { \
            if (! (cond)) { \
                RIP(("\n")); \
            } \
        }
#endif

#define ASSERTMSG(cond, msg) { \
            if (! (cond)) { \
                RIP(msg); \
            } \
        }

#define RIP(msg) { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DbgBreakPoint(); \
        }


#else // !DBG

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)
#define ERR(msg)

#ifndef __MDT__         // Don't redefine ASSERT when included in MINIDEV.EXE.
#define ASSERT(cond)
#endif

#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg)
#define DBGPRINT(level, msg)

#endif

//
// The following macros let you enable tracing on per-file and per-function level.
// To use these macros in a file, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  Define a bit constant for each function you want to trace
//  Add the following line
//      DEFINE_FUNCTION_TRACE_FLAGS(flags);
//  where flags is a bit-wise OR of the functions you want to trace, e.g.
//      TRACE_FLAG_FUNC1 | TRACE_FLAG_FUNC2 | ...
//
//  To generate trace inside each function you want to trace, use:
//      FUNCTION_TRACE(FunctionTraceFlag, (args));
//

#if DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags) \
        static DWORD gdwFunctionTraceFlags = (flags)

#define FUNCTION_TRACE(flag, args) { \
            if (gdwFunctionTraceFlags & (flag)) { \
                DbgPrint args; \
            } \
        }

#else // !DBG

#define DEFINE_FUNCTION_TRACE_FLAGS(flags)
#define FUNCTION_TRACE(flag, args)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif  // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\fmoldfm.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmoldmf.h

Abstract:

    NT4.0 Font metrics file format.
    Structures used to determine the file layout of files generated
    by any font installers, and then read by us.

Environment:

    Windows NT printer drivers

Revision History:

    11/11/96 -eigos-
        From NT4.0 header file.

    mm/dd/yy -eigos-
        Description

--*/

//
//   Define the structure that heads each record in the font installer
// files.  Basically it contains selection information and offsets
// to the remaining data in this record.
//   This structure is actually written to the file.  It is also the header
// employed in the font resources in minidrivers - each font has one of these
// at the beginning.
//

//
// Reduced from 4 to three as WFontType is added.
// Reducde from three to two when dwETM was added
//

#define EXP_SIZE        2       // DWORDS allowed for future expansion

//
// Font installer header.
//

typedef struct
{
    WORD     cjThis;            // Our size,  for consistency checking
    WORD     wFlags;            // Miscellaneous information

    DWORD    dwSelBits;         // Font availability information

    DWORD    dwIFIMet;          // Offset to the IFIMETRICS for this font
    DWORD    dwCDSelect;        // How to select/deselect this fontg
    DWORD    dwCDDeselect;
    DWORD    dwWidthTab;        // Width vector (proportional font) else 0g
    DWORD    dwIdentStr;        // Identification stringg

    union
    {
        short    sCTTid;        // Index into CTT datag
        DWORD    dwCTT;         // Offset here to mapping data of some sortg
    } u;

    WORD     wXRes;             // Resolution used for font metrics numbersg
    WORD     wYRes;             // Ditto for the y coordinatesg

    short    sYAdjust;          // Adjust Y position before output - for g
                                // double height characters on dot matrixg
    short    sYMoved;           // Cursor has shifted after printing fontg

    short    fCaps;             // Capabilities flagsg

    WORD     wPrivateData;      // Special purpose: e.g. DeskJet permutationsg

    WORD     wFontType;         // Type of Device fontg

    WORD     wReserved;         // reserved for future useg

    DWORD    dwETM;             // offset to ETM for this font. Could be NULL.

    DWORD    dwMBZ[ EXP_SIZE ]; // Must Be Zero: in case we need spaceg

} FI_DATA_HEADER;

//
//  The version ID.
//

#define FDH_VER 0x100           // 1.00 in BCD

//
//  Flags bits.
//

#define FDH_SOFT        0x0001  // Softfont, thus needs downloadingg
#define FDH_CART        0x0002  // This is a cartridge fontg
#define FDH_CART_MAIN   0x0004  // Main (first) entry for this cartridgeg

//
//  Selection criteria bits:  dwSelBits.  These bits are used as
// follows.  During font installation,  the installer set the following
// values as appropriate.  During initialisation,  the driver sets
// up a mask of these bits,  depending upon the printer's abilities.
// For example,  the FDH_SCALABLE bit is set only if the printer can
// handle scalable fonts.   When the fonts are examined to see if
// they are usable,  the following test is applied:
//
//      (font.dwSelBits & printer.dwSelBits) == font.dwSelBits
//
// If true,  the font is usable.
//

#define FDH_LANDSCAPE   0x00000001      // Font is landscape orientationg
#define FDH_PORTRAIT    0x00000002      // Font is portraitg
#define FDH_OR_REVERSE  0x00000004      // 180 degree rotation of aboveg
#define FDH_BITMAP      0x00000008      // Bitmap fontg
#define FDH_COMPRESSED  0x00000010      // Data is compressed bitmapg
#define FDH_SCALABLE    0x00000020      // Font is scalableg
#define FDH_CONTOUR     0x00000040      // Intellifont contourg

#define FDH_ERROR       0x80000000      // Set if some error conditiong


//
//  The following structure should be returned from the specific
// minidriver to the common font installer code.  It is used by
// the common font installer code to generate the above structure
// which is then placed in the font file.
//

typedef  struct _DATA_SUM
{
    void  *pvData;      // Address of data of importanceg
    int    cBytes;      // Number of bytes in the aboveg
}  DATA_SUM;

//
// Font file header.
//

typedef  struct _FI_DATA
{
    DATA_SUM   dsIFIMet;        // IFIMETRICS
    DATA_SUM   dsSel;           // Selection string/whatever
    DATA_SUM   dsDesel;         // Deselection string
    DATA_SUM   dsWidthTab;      // Width tables (proportional font)
    DATA_SUM   dsCTT;           // Translation data
    DATA_SUM   dsIdentStr;      // Identification string (Dialog box etc)
    DATA_SUM   dsETM;           // EXTENDED TEXT METRICS

    DWORD      dwSelBits;       // Font availability information

    WORD       wVersion;        // Version ID
    WORD       wFlags;          // Miscellaneous information

    WORD       wXRes;           // X resolution of font
    WORD       wYRes;           // Y resolution

    short      sYAdjust;        // Adjust Y position before output - for
                                // double height characters on dot matrix
    short      sYMoved;         // Cursor has shifted after printing font


    WORD       fCaps;           // Font/device caps
    WORD       wFontType;       // Type of Device font
    WORD       wPrivateData;    // Pad to DWORD multiple
} FI_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\devmode.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    devmode.h

Abstract:

    DEVMODE related declarations and definitions

[Environment:]

    Win32 subsystem, printer drivers

Revision History:

    02/04/07 -davidx-
        Devmode changes to support OEM plugins.

    07/31/96 -davidx-
        Add BValidateDevmodeFormFields.

    07/31/96 -amandan-
        Updated for UI Module

    07/22/96 -srinivac-
        Updated for PSCRIPT5

    07/25/95 -davidx-
        Created it.

--*/

#ifndef _DEVMODE_H_
#define _DEVMODE_H_

//
// Maximum scale factor and maximum copy count
//

#define MIN_SCALE           1
#define MAX_SCALE           1000
#define MIN_COPIES          1
#define MAX_COPIES          9999

//
// PostScript driver private devmode flags
//

#define PSDEVMODE_EPS               0x00000001 // outputting EPS file
#define PSDEVMODE_EHANDLER          0x00000002 // download error handler
#define PSDEVMODE_MIRROR            0x00000004 // mirror image
#define PSDEVMODE_BLACK             0x00000008 // all colors set to black
#define PSDEVMODE_NEG               0x00000010 // negative image
#define PSDEVMODE_FONTSUBST         0x00000020 // font substitution enabled
#define PSDEVMODE_COMPRESSBMP       0x00000040 // bitmap compr. is enabled
#define PSDEVMODE_ENUMPRINTERFONTS  0x00000080 // use printer fonts
#define PSDEVMODE_INDEPENDENT       0x00000100 // do page independence
#define PSDEVMODE_LSROTATE          0x00000200 // rotated landscape
#define PSDEVMODE_NO_LEVEL2         0x00000400 // don't use level 2 features
#define PSDEVMODE_CTRLD_BEFORE      0x00000800 // send ^D before job - obsolete
#define PSDEVMODE_CTRLD_AFTER       0x00001000 // send ^D after job - obsolete
#define PSDEVMODE_METAFILE_SPOOL    0x00002000 // enable metafile spooling
#define PSDEVMODE_NO_JOB_CONTROL    0x00004000 // don't send job control code


//
// The following flags are obsolete and are used for compatibility. When
// a devmode comes into the driver or a devmode leaves the driver, these
// fields are checked or updated respectively. Internally the driver
// uses new fields to mainatain these values. The obsolete flags are:
//
// PSDEVMODE_EPS
// PSDEVMODE_INDEPENDENT
// PSDEVMODE_NO_LEVEL2
// PSDEVMODE_FONTSUBST
//

//
// Nup values
//

typedef enum {
    ONE_UP,
    TWO_UP,
    FOUR_UP,
    SIX_UP,
    NINE_UP,
    SIXTEEN_UP,
    BOOKLET_UP,
} LAYOUT;


//
// Output dialect values
//

typedef enum {
    SPEED,                                      // optimize for speed
    PORTABILITY,                                // optimize for portability
    EPS,                                        // generate eps output
    ARCHIVE,                                    // output for archival
} DIALECT;

//
// TT font downloading formats
//

typedef enum {
    TT_DEFAULT,                                 // download in default format
    TYPE_1,                                     // download as Type 1 outlines
    TYPE_3,                                     // download as Type 3 bitmaps
    TYPE_42,                                    // download as Type 42 fonts
    TRUEIMAGE,                                  // download as TrueType
    TT_NODOWNLOAD,                              // do not download TT fonts
} TTDLFMT;

//
// Custom page size feed directions
// Use #define instead of enums because they're used in resource file.
//

#define LONGEDGEFIRST           0               // long edge first
#define SHORTEDGEFIRST          1               // short edge first
#define LONGEDGEFIRST_FLIPPED   2               // long edge first, upside down
#define SHORTEDGEFIRST_FLIPPED  3               // short edge first, upside down
#define MAX_FEEDDIRECTION       4

//
// PostScript driver devmode
//

typedef struct _CUSTOMSIZEDATA {    // custom page size parameters

    DWORD   dwX;                    // logical paper width (in microns)
    DWORD   dwY;                    // logical paper height
    DWORD   dwWidthOffset;          // offset perpendicular to feed direction
    DWORD   dwHeightOffset;         // offset parallel to feed direction
    WORD    wFeedDirection;         // paper feed direction
    WORD    wCutSheet;              // use cut-sheet behavior or not

} CUSTOMSIZEDATA, *PCUSTOMSIZEDATA;

typedef struct _PSDRVEXTRA {

    DWORD       dwSignature;                    // private devmode signature
    DWORD       dwFlags;                        // flag bits
    WCHAR       wchEPSFile[40];                 // EPS file name
    COLORADJUSTMENT coloradj;                   // structure for halftoning

    WORD        wReserved1;                     // old PPD checksum set to 0
    WORD        wSize;                          // size of PRIVATEDEVMODE

    FIX_24_8    fxScrFreq;                      // halftone screen frequency
    FIX_24_8    fxScrAngle;                     // halftone screen angle
    DIALECT     iDialect;                       // output dialect
    TTDLFMT     iTTDLFmt;                       // download TT fonts as
    BOOL        bReversePrint;                  // print in reverse order?
    LAYOUT      iLayout;                        // nup value
    INT         iPSLevel;                       // Language level (1, 2 or 3)

    DWORD       dwReserved2;                    // reserved
    WORD        wOEMExtra;                      // size of OEM private data
    WORD        wVer;                           // DRIVEREXTRA version
    CUSTOMSIZEDATA csdata;                      // custom page size parameters

    DWORD       dwReserved3[4];                 // reserved for future use

    DWORD       dwChecksum32;                   // checksum for option array
    DWORD       dwOptions;                      // number of doc-sticky features
    OPTSELECT   aOptions[MAX_PRINTER_OPTIONS];  // printer options

} PSDRVEXTRA, *PPSDRVEXTRA;

//
// Constants for PSDRVEXTRA.dwSignature and PSDRVEXTRA.wVer
//

#define PSDEVMODE_SIGNATURE 0x56495250
#define PSDRVEXTRA_VERSION  0x0010

//
// Declarations of earlier version DEVMODEs
//

#define PSDRIVER_VERSION_351  0x350             // 3.51 driver version number

typedef struct _PSDRVEXTRA351 {

    DWORD           dwSignature;
    DWORD           dwFlags;
    WCHAR           wchEPSFile[40];
    COLORADJUSTMENT coloradj;

} PSDRVEXTRA351;

#define PSDRIVER_VERSION_400  0x400             // 4.00 driver version number

typedef struct _PSDRVEXTRA400 {

    DWORD           dwSignature;
    DWORD           dwFlags;
    WCHAR           wchEPSFile[40];
    COLORADJUSTMENT coloradj;
    WORD            wChecksum;
    WORD            wOptions;
    BYTE            aubOptions[64];

} PSDRVEXTRA400;

//
// We have changed PSDRIVER_VERSION number from Win2K's 0x501 to XP's 0x502.
// We must use Win2K's 0x501 here. (see PConvertToCurrentVersionDevmodeWithOemPlugins)
//
#define PSDRIVER_VERSION_500  0x501             // 5.00 driver version number

typedef struct _PSDRVEXTRA500 {

    DWORD       dwSignature;                    // private devmode signature
    DWORD       dwFlags;                        // flag bits
    WCHAR       wchEPSFile[40];                 // EPS file name
    COLORADJUSTMENT coloradj;                   // structure for halftoning

    WORD        wReserved1;                     // old PPD checksum set to 0
    WORD        wSize;                          // size of PRIVATEDEVMODE

    FIX_24_8    fxScrFreq;                      // halftone screen frequency
    FIX_24_8    fxScrAngle;                     // halftone screen angle
    DIALECT     iDialect;                       // output dialect
    TTDLFMT     iTTDLFmt;                       // download TT fonts as
    BOOL        bReversePrint;                  // print in reverse order?
    LAYOUT      iLayout;                        // nup value
    INT         iPSLevel;                       // Language level (1, 2 or 3)

    DWORD       dwReserved2;                    // reserved
    WORD        wOEMExtra;                      // size of OEM private data
    WORD        wVer;                           // DRIVEREXTRA version
    CUSTOMSIZEDATA csdata;                      // custom page size parameters

    DWORD       dwReserved3[4];                 // reserved for future use

    DWORD       dwChecksum32;                   // checksum for option array
    DWORD       dwOptions;                      // number of doc-sticky features
    OPTSELECT   aOptions[MAX_PRINTER_OPTIONS];  // printer options

} PSDRVEXTRA500;

//
// Unidrv driver devmode
//

//
// Quality macro definitions to be saved in DEVMODE.dmDitherType
//

#define MAX_QUALITY_SETTINGS     3
#define MIN_QUALITY_SETTINGS     1

#define QUALITY_MACRO_START     DMDITHER_USER   // 256
#define QUALITY_MACRO_BEST      QUALITY_MACRO_START + QS_BEST
#define QUALITY_MACRO_BETTER    QUALITY_MACRO_START + QS_BETTER
#define QUALITY_MACRO_DRAFT     QUALITY_MACRO_START + QS_DRAFT
#define QUALITY_MACRO_END       QUALITY_MACRO_START + MAX_QUALITY_SETTINGS

#define QUALITY_MACRO_CUSTOM    0xFFFFFFFF

//
//   Used for bits in the dwFlags field below.
//

#define DXF_TEXTASGRAPHICS      0x0002  // Set to disable font cacheing in printer
#define DXF_JOBSEP              0x0004  // Enable Job Separator operation on printer
#define DXF_PAGEPROT            0x0008  // Page memory protected: PCL 5
#define DXF_NOEMFSPOOL          0x0010  // Set to disable EMF spooling; default off
#define DXF_VECTOR              0x0020  // Set to indicate user selected vector mode
#define DXF_DOWNLOADTT          0x0040  // Set to indicate printer supports tt downloading
#define DXF_CUSTOM_QUALITY      0x0080  // Set to indicate Custom quality is selected

typedef struct _UNIDRVEXTRA {

    DWORD           dwSignature;
    WORD            wVer;
    WORD            sPadding;
    WORD            wSize;                      // was dmDefaultDest
    WORD            wOEMExtra;                  // was dmTextQuality
    DWORD           dwChecksum32;
    DWORD           dwFlags;
    BOOL            bReversePrint;              // print in reverse order?
    LAYOUT          iLayout;                    // nup value
    QUALITYSETTING  iQuality;                   // quality settings
    WORD            wReserved[6];
    DWORD           dwOptions;                  // number of doc-sticky features
    OPTSELECT       aOptions[MAX_PRINTER_OPTIONS];
    DWORD           dwEndingPad;                // padding DWORD to make size of public devmode
                                                // plus Unidrv private devmode multiple of 8-bytes.

} UNIDRVEXTRA, *PUNIDRVEXTRA;

//
// Constants for UNIDRVEXTRA.dwSignature and UNIDRVEXTRA.wVersion
//

#define UNIDEVMODE_SIGNATURE    'UNID'
#define UNIDRVEXTRA_VERSION     0x0022

#define MAXHE                   30
#define MAXCART                 4
#define UNIDRIVER_VERSION_351   0x301
#define UNIDRIVER_VERSION_400   0x301
#define UNIDRIVER_VERSION_500   0x500

typedef struct _UNIDRVEXTRA351 {

    SHORT           sVer;                       // Version for validity testing
    SHORT           sDefaultDest;
    SHORT           sTextQuality;
    WORD            wMiniVer;                   // Minidriver Version
    SHORT           sBrush;                     // type of dithering brush
    SHORT           sCTT;                       // CTT value for txtonly
    SHORT           sNumCarts;                  // # of cartridges selected.
    SHORT           aFontCarts[MAXCART];
    SHORT           sMemory;                    // current printer memory configuration.
    SHORT           aIndex[MAXHE];

                                                // Following are NT additions
    SHORT           sFlags;                     // Miscellaneous flags; defined below
    SHORT           sPadding;
    COLORADJUSTMENT ca;                         // Halftoning information. (see wingdi.h)

} UNIDRVEXTRA351, UNIDRVEXTRA400;

typedef struct _UNIDRVEXTRA500 {

    DWORD           dwSignature;
    WORD            wVer;
    WORD            sPadding;
    WORD            wSize;                      // was dmDefaultDest
    WORD            wOEMExtra;                  // was dmTextQuality
    DWORD           dwChecksum32;
    DWORD           dwFlags;
    BOOL            bReversePrint;              // print in reverse order?
    LAYOUT          iLayout;                    // nup value
    QUALITYSETTING  iQuality;                   // quality settings
    WORD            wReserved[6];
    DWORD           dwOptions;                  // number of doc-sticky features
    OPTSELECT       aOptions[MAX_PRINTER_OPTIONS];

    //
    // See PConvertToCurrentVersionDevmodeWithOemPlugins() for the reason
    // why dwEndingPad field is not here.
    //
} UNIDRVEXTRA500;

//
// Default halftone parameters
//

extern DEVHTINFO gDefaultDevHTInfo;
extern COLORADJUSTMENT gDefaultHTColorAdjustment;

//
// Validate the form-related fields in the input devmode and
// make sure they're consistent with each other.
//

BOOL
BValidateDevmodeFormFields(
    HANDLE      hPrinter,
    PDEVMODE    pDevmode,
    PRECTL      prcImageArea,
    FORM_INFO_1 *pForms,
    DWORD       dwForms
    );

//
// Initialized the form-related devmode fields with their default values
//

#define LETTER_FORMNAME     TEXT("Letter")
#define A4_FORMNAME         TEXT("A4")

VOID
VDefaultDevmodeFormFields(
    PUIINFO     pUIInfo,
    PDEVMODE    pDevmode,
    BOOL        bMetric
    );

//
// Unit for DEVMODE.dmPaperWidth and DEVMODE.dmPaperLength fields
//  0.1mm = 100 microns
//

#define DEVMODE_PAPER_UNIT  100

//
// Allocate memory and initialize it with default devmode information
// This include public devmode, driver private devmode, as well as
// private devmode for any OEM plugins.
//

// NOTE: type POEM_PLUGINS is defined in oemutil.h. To avoid unnecessarily
// include that header file everywhere (which includes winddiui.h, compstui.h, ...)
// we declare the type here as well.

typedef struct _OEM_PLUGINS *POEM_PLUGINS;

PDEVMODE
PGetDefaultDevmodeWithOemPlugins(
    IN LPCTSTR          ptstrPrinterName,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN BOOL             bMetric,
    IN OUT POEM_PLUGINS pOemPlugins,
    IN HANDLE           hPrinter
    );

//
// Valicate input devmode and merge it into the output devmode.
// This include public devmode, driver private devmode, as well as
// private devmode for any OEM plugins.
//
// The output devmode must be valid when this function is called.
//

BOOL
BValidateAndMergeDevmodeWithOemPlugins(
    IN OUT PDEVMODE     pdmOutput,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN PDEVMODE         pdmInput,
    IN OUT POEM_PLUGINS pOemPlugins,
    IN HANDLE           hPrinter
    );

//
// These functions are implemented in driver-specific libraries
// lib\ps and lib\uni.
//

BOOL
BInitDriverDefaultDevmode(
    OUT PDEVMODE        pdmOut,
    IN LPCTSTR          ptstrPrinterName,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN BOOL             bMetric
    );

BOOL
BMergeDriverDevmode(
    IN OUT PDEVMODE     pdmOut,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN PDEVMODE         pdmIn
    );

//
// Information about driver private devmode
//

typedef struct _DRIVER_DEVMODE_INFO {

    WORD    dmDriverVersion;    // current driver version
    WORD    dmDriverExtra;      // size of current version private devmode

    WORD    dmDriverVersion500; // 5.0 driver version
    WORD    dmDriverExtra500;   // size of 5.0 private devmode
    WORD    dmDriverVersion400; // 4.0 driver version
    WORD    dmDriverExtra400;   // size of 4.0 private devmode
    WORD    dmDriverVersion351; // 3.51 driver version
    WORD    dmDriverExtra351;   // size of 3.51 private devmode

} DRIVER_DEVMODE_INFO;

extern CONST DRIVER_DEVMODE_INFO gDriverDMInfo;
extern CONST DWORD gdwDriverDMSignature;

//
// Given a pointer to a public devmode, return
// a pointer to the driver private portion.
//

#define GET_DRIVER_PRIVATE_DEVMODE(pdm) ((PBYTE) (pdm) + (pdm)->dmSize)

#endif // !_DEVMODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\lib.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    lib.h

Abstract:

    Common header file shared by all NT printer drivers

Environment:

    Windows NT printer drivers

Revision History:

    08/30/96 -davidx-
        Coding style changes after code review.

    08/13/96 -davidx-
        Add memory debug function declarations.

    07/31/96 -davidx-
        Created it.

--*/


#ifndef _PRNLIB_H_
#define _PRNLIB_H_

#include <stddef.h>
#include <stdlib.h>

#ifdef OEMCOM
#include <objbase.h>
#endif

#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#if _WIN32_WINNT < 0x0500
typedef unsigned long   DESIGNVECTOR;
#endif
#include <winddi.h>
#include <tchar.h>
#include <excpt.h>

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

#include "winsplkm.h"
#include <windows.h>

#else

#include <windows.h>
#include <winspool.h>

#ifndef KERNEL_MODE
#include <stdio.h>
#endif

#endif

#ifdef WINNT_40

#include "p64_nt4.h"

#endif // WINNT_40

//
//
// Driver version numbers: This variable must be defined in each driver's DLL
//

#define PSDRIVER_VERSION    0x502
#define UNIDRIVER_VERSION   0x500

extern CONST WORD gwDriverVersion;

//
// Kernel-mode memory pool tag:
//  Define and initialize this variable in each driver's kernel mode DLL
//

extern DWORD    gdwDrvMemPoolTag;

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif

#ifndef MAX_BYTE
#define MAX_BYTE        0xff
#endif

//
// Number of bytes in 1KB
//

#define KBYTES  1024

//
// Directory seperator character
//

#define PATH_SEPARATOR  '\\'

//
// Declarations for 24.8 format precision fixed-point number
//

typedef LONG   FIX_24_8;

#define FIX_24_8_SHIFT  8
#define FIX_24_8_SCALE  (1 << FIX_24_8_SHIFT)

#define MAX_DISPLAY_NAME        128   // max length for feature/option display names

//
// Include other header files here
//

#include "debug.h"
#include "parser.h"
#include "devmode.h"
#include "regdata.h"
#include "helper.h"
#include <strsafe.h>

//
// Deal with the difference between user and kernel mode functions
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

#define WritePrinter        EngWritePrinter
#define GetPrinterDriver    EngGetPrinterDriver
#define GetPrinterData      EngGetPrinterData
#define SetPrinterData      EngSetPrinterData
#define EnumForms           EngEnumForms
#define GetPrinter          EngGetPrinter
#define GetForm             EngGetForm
#define SetLastError        EngSetLastError
#define GetLastError        EngGetLastError
#define MulDiv              EngMulDiv

#undef  LoadLibrary
#define LoadLibrary         EngLoadImage
#define FreeLibrary         EngUnloadImage
#define GetProcAddress      EngFindImageProcAddress

#define MemAlloc(size)      EngAllocMem(0, size, gdwDrvMemPoolTag)
#define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, gdwDrvMemPoolTag)
#define MemFree(p)          { if (p) EngFreeMem(p); }

#else // !KERNEL_MODE

#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

//
// Change the size of a specified memory block. The size can increase
// or decrease.
//
// We are not using LocalReAlloc() since our LocalAlloc uses LMEM_FIXED.
//

PVOID
MemRealloc(
    IN PVOID    pvOldMem,
    IN DWORD    cbOld,
    IN DWORD    cbNew
    );

//
// DLL instance handle - You must initialize this variable when the driver DLL
// is attached to a process.
//

extern HINSTANCE    ghInstance;

#endif // !KERNEL_MODE

//
// Macros and constants for working with character strings
//

#define NUL             0
#define EQUAL_STRING    0

#define IS_EMPTY_STRING(p)  ((p)[0] == NUL)
#define SIZE_OF_STRING(p)   ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IS_NUL_CHAR(ch)     ((ch) == NUL)

//
// String copy function similar to _tcsncpy but it gurantees
// the destination string is always nul terminated
//

VOID
CopyStringW(
    OUT PWSTR  pwstrDest,
    IN PCWSTR  pwstrSrc,
    IN INT     iDestSize
    );

VOID
CopyStringA(
    OUT PSTR    pstrDest,
    IN PCSTR    pstrSrc,
    IN INT      iDestSize
    );

#ifdef  UNICODE
#define CopyString  CopyStringW
#else
#define CopyString  CopyStringA
#endif

//
// Convert index to keyword
//

PSTR
PstrConvertIndexToKeyword(
    IN  HANDLE      hPrinter,
    IN  POPTSELECT  pOptions,
    IN  PDWORD      pdwKeywordSize,
    IN  PUIINFO     pUIInfo,
    IN  POPTSELECT  pCombineOptions,
    IN  DWORD       dwFeatureCount
    );

VOID
VConvertKeywordToIndex(
    IN  HANDLE      hPrinter,
    IN  PSTR        pstrKeyword,
    IN  DWORD       dwKeywordSize,
    OUT POPTSELECT  pOptions,
    IN  PRAWBINARYDATA pRawData,
    IN  PUIINFO     pUIInfo,
    IN  POPTSELECT  pCombineOptions,
    IN  DWORD       dwFeatureCount
    );

//
// Make a duplicate of the specified character string
//

PTSTR
DuplicateString(
    IN LPCTSTR  ptstrSrc
    );

//
// Macros for converting binary data to hex digits
//

extern const CHAR gstrDigitString[];

#define HexDigit(n) gstrDigitString[(n) & 0xf]

//
// Determine wheter the system is running in a metric country
// NOTE: Avaiable in user-mode only
//

BOOL
IsMetricCountry(
    VOID
    );

//
// Map a data file into memory
//

typedef PVOID HFILEMAP;

HFILEMAP
MapFileIntoMemory(
    IN LPCTSTR  ptstrFilename,
    OUT PVOID  *ppvData,
    OUT PDWORD  pdwSize
    );

//
// Unmapp a file from memory
//

VOID
UnmapFileFromMemory(
    IN HFILEMAP hFileMap
    );

//
// Map a data file into memory for write
//

HANDLE
MapFileIntoMemoryForWrite(
    IN LPCTSTR  ptstrFilename,
    IN DWORD    dwDesiredSize,
    OUT PVOID  *ppvData,
    OUT PDWORD  pdwSize
    );

//
// Generate a temporary file name in kernel mode
//

PTSTR
GenerateTempFileName(
    IN LPCTSTR lpszPath,
    IN DWORD   dwSeed
    );

//
// Wrapper function for spooler APIs:
//  GetPrinter
//  GetPrinterDriver
//  GetPrinterDriverDirectory
//  EnumForms
//

PVOID
MyGetPrinter(
    IN HANDLE   hPrinter,
    IN DWORD    dwLevel
    );

PVOID
MyGetPrinterDriver(
    IN HANDLE   hPrinter,
    IN HDEV     hDev,
    IN DWORD    dwLevel
    );

PVOID
MyEnumForms(
    IN HANDLE   hPrinter,
    IN DWORD    dwLevel,
    OUT PDWORD  pdwFormsReturned
    );

PVOID
MyGetForm(
    IN HANDLE   hPrinter,
    IN PTSTR    ptstrFormName,
    IN DWORD    dwLevel
    );

//
// Figure out what EMF features (such as N-up and reverse-order printing)
// the spooler can support
//

VOID
VGetSpoolerEmfCaps(
    IN  HANDLE  hPrinter,
    OUT PBOOL   pbNupOption,
    OUT PBOOL   pbReversePrint,
    IN  DWORD   cbOut,
    OUT PVOID   pSplCaps
    );

//
// Generate a hash value for the given string.
//

DWORD
HashKeyword(
    LPCSTR  pKeywordStr
    );

//
// DBCS CharSet handling macros
//

// 128: SHIFTJIS_CHARSET
// 129: HANGEUL_CHARSET
// 130: JOHAB_CHARSET (defined if WINVER >= 0x0400)
// 134: GB2312_CHARSET
// 136: CHINESEBIG5_CHARSET

#define IS_DBCSCHARSET(j) \
    (((j) == SHIFTJIS_CHARSET)    || \
     ((j) == HANGEUL_CHARSET)     || \
     ((j) == JOHAB_CHARSET)       || \
     ((j) == GB2312_CHARSET)      || \
     ((j) == CHINESEBIG5_CHARSET))

//  932: Japan
//  936: Chinese (PRC, Singapore)
//  949: Korean
//  950: Chinese (Taiwan, Hong Kong SAR)
// 1361: Korean (Johab)

#define IS_DBCSCODEPAGE(j) \
    (((j) == 932)   || \
     ((j) == 936)   || \
     ((j) == 949)   || \
     ((j) == 950)   || \
     ((j) == 1361))

UINT PrdGetACP(VOID);

BOOL PrdTranslateCharsetInfo(
    IN  UINT dwSrc,
    OUT LPCHARSETINFO lpCs,
    IN  DWORD dwFlags);

//
// Macros for working with array of bit flags
//

#define BITTST(p, i) (((PBYTE) (p))[(i) >> 3] & (1 << ((i) & 7)))
#define BITSET(p, i) (((PBYTE) (p))[(i) >> 3] |= (1 << ((i) & 7)))
#define BITCLR(p, i) (((PBYTE) (p))[(i) >> 3] &= ~(1 << ((i) & 7)))

//
// Count of characters
//
#define CCHOF(x) (sizeof(x)/sizeof(*(x)))

#endif // !_PRNLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\gpd.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    gpd.h

Abstract:

    GPD parser specific header file

Environment:

    Windows NT Unidrv driver

Revision History:

    10/15/96 -amandan-
        Created it.

    10/22/96 -zhanw-
        add definition of all GPD constants

    1/16/97 -zhanw-
        update based on the latest GPD spec
--*/


#ifndef _GPD_H_
#define _GPD_H_


#define UNUSED_ITEM      0xFFFFFFFF
#define END_OF_LIST      0XFFFFFFFF
#define END_SEQUENCE     0xFFFFFFFF
#define MAX_THRESHOLD    0x7FFF

#define HT_PATSIZE_AUTO         255

//
// Binary printer description filename extension
//

#define BUD_FILENAME_EXT    TEXT(".BUD")

//  driver chooses 'best' GDI halftone pattern.

// ---- Qualified Names  Section ---- //

//  Note:  Current practice of using the same code
//  to store Integers, constants, and Qualified Names
//  in List structures requires the QUALNAME structure
//  to fit inside one DWORD.

typedef  struct
{
    WORD   wFeatureID ;
    WORD    wOptionID ;
}  QUALNAME, * PQUALNAME  ;
//  assign this struct the tag 'qn'

// ---- End of Qualified Names  Section ---- //

typedef DWORD LISTINDEX;

//
// PRINTER TYPE enumeration
//

typedef enum _PRINTERTYPE {
    PT_SERIAL,
    PT_PAGE,
    PT_TTY
} PRINTERTYPE;


//
// OEMPRINTINGCALLBACKS enumeration
//

typedef enum _OEMPRINTINGCALLBACKS {
    OEMPC_OEMDownloadFontheader,
    OEMPC_OEMDownloadCharGlyph,
    OEMPC_OEMTTDownloadMethod,
    OEMPC_OEMOutputCharStr,
    OEMPC_OEMImageProcessing,
    OEMPC_OEMCompression,
    OEMPC_OEMHalftonePattern,
    OEMPC_OEMFilterGraphics
} OEMPRINTINGCALLBACKS;


//
// define possible values for *CursorXAfterCR keyword
//
typedef enum _CURSORXAFTERCR {
    CXCR_AT_PRINTABLE_X_ORIGIN,
    CXCR_AT_CURSOR_X_ORIGIN
} CURSORXAFTERCR;

//
// define values for *CursorXAfterSendBlockData keyword
//
typedef enum _CURSORXAFTERSENDBLOCKDATA {
    CXSBD_AT_GRXDATA_END,
    CXSBD_AT_GRXDATA_ORIGIN,
    CXSBD_AT_CURSOR_X_ORIGIN
} CURSORXAFTERSENDBLOCKDATA;

//
// define values for *CursorYAfterSendBlockData keyword
//
typedef enum _CURSORYAFTERSENDBLOCKDATA {
    CYSBD_NO_MOVE,
    CYSBD_AUTO_INCREMENT
} CURSORYAFTERSENDBLOCKDATA;

//
// define values for *OutputDataFormat keyword
//
typedef enum _OUTPUTDATAFORMAT {
    ODF_H_BYTE,
    ODF_V_BYTE
} OUTPUTDATAFORMAT;

//
// define values for *CharPosition keyword
//
typedef enum _CHARPOSITION {
    CP_UPPERLEFT,
    CP_BASELINE
} CHARPOSITION;

//
// define values for *DLSymbolSet
//
typedef enum _DLSYMBOLSET {
    DLSS_PC8,
    DLSS_ROMAN8

} DLSYMBOLSET;

//
// define values for *FontFormat keyword
//
typedef enum _FONTFORMAT {
    FF_HPPCL,
    FF_HPPCL_RES,
    FF_HPPCL_OUTLINE,
    FF_OEM_CALLBACK
} FONTFORMAT;

typedef enum _CURSORXAFTERRECTFILL {
    CXARF_AT_RECT_X_ORIGIN,
    CXARF_AT_RECT_X_END

} CURSORXAFTERRECTFILL;

typedef enum _CURSORYAFTERRECTFILL {
    CYARF_AT_RECT_Y_ORIGIN,
    CYARF_AT_RECT_Y_END

} CURSORYAFTERRECTFILL;

typedef enum _RASTERMODE {
    RASTMODE_DIRECT,
    RASTMODE_INDEXED

} RASTERMODE;


//
// GLOBAL ENTRIES
// Global entries applies to the whole GPD file.
// The driver creates a GLOBALS struct and the parsers initializes
// it.  The driver keeps a pointer to the GLOBALS struct in PDEVICE.
//

typedef struct _GLOBALS {

    //
    // General
    //

    PWSTR       pwstrGPDSpecVersion;    // "GPDSPecVersion"
    PWSTR       pwstrGPDFileVersion;    // "GPDFileVersion"
    POINT       ptMasterUnits;          // "MasterUnits"
    PWSTR       pwstrModelName;         // "ModelName"
    PWSTR       pwstrGPDFileName;         // "GPDFileName"
    PRINTERTYPE printertype;            // "PrinterType"
    PWSTR       pwstrIncludeFiles;      // "Include"
    PWSTR       pwstrResourceDLL;       // "ResourceDLL"
    DWORD       dwMaxCopies;            // "MaxCopies"
    DWORD       dwFontCartSlots;        // "FontCartSlots"

    //  these two fields hold a true pointer and the number of bytes of
    //  OEM supplied binary data defined in the GPD file.
    PBYTE       pOEMCustomData;       // "OEMCustomData"   location of data
    DWORD       dwOEMCustomData;            // "OEMCustomData"   byte count of data




    BOOL        bRotateCoordinate;      // "RotateCoordinate"
    BOOL        bRotateRasterData;      // "RotateRaster"
    LISTINDEX   liTextCaps;             // *TextCaps, offset to a list of
    BOOL        bRotateFont;            // "RotateFont"
    LISTINDEX   liMemoryUsage;          // *MemoryUsage
    LISTINDEX   liReselectFont;          // *ReselectFont
    LISTINDEX   liOEMPrintingCallbacks;          // *OEMPrintingCallbacks


    //
    // Cursor Control related information
    //

    CURSORXAFTERCR  cxaftercr;                  // "CursorXAfterCR"
    LISTINDEX       liBadCursorMoveInGrxMode;   // "BadCursorMoveInGrxMode"
    LISTINDEX       liYMoveAttributes;          // "YMoveAttributes"
    DWORD       dwMaxLineSpacing;               // "MaxLineSpacing"
    BOOL        bEjectPageWithFF;               // "EjectPageWithFF"
    BOOL        bUseSpaceForXMove ;         //  UseSpaceForXMove?
    BOOL        bAbsXMovesRightOnly ;         //  AbsXMovesRightOnly?
    DWORD       dwXMoveThreshold;               // *XMoveThreshold, never negative
    DWORD       dwYMoveThreshold;               // *YMoveThreshold, never negative
    POINT       ptDeviceUnits;                  // *XMoveUnit, *YMoveUnit
    DWORD       dwLineSpacingMoveUnit;               // *LineSpacingMoveUnit

    //
    // Color related information
    //

    BOOL        bChangeColorMode;       // "ChangeColorModeOnPage"

    DWORD       dwMagentaInCyanDye;       // "MagentaInCyanDye"
    DWORD       dwYellowInCyanDye;       // "YellowInCyanDye"
    DWORD       dwCyanInMagentaDye;       // "CyanInMagentaDye"
    DWORD       dwYellowInMagentaDye;       // "YellowInMagentaDye"
    DWORD       dwCyanInYellowDye;       // "CyanInYellowDye"
    DWORD       dwMagentaInYellowDye;       // "MagentaInYellowDye"
    BOOL        bEnableGDIColorMapping;   // "EnableGDIColorMapping?"

    DWORD       dwMaxNumPalettes;       // "MaxNumPalettes"
    //  the Palette entries are indicies to first item in a list.
    LISTINDEX   liPaletteSizes;         // "PaletteSizes"
    LISTINDEX   liPaletteScope;         // "PaletteScope"

    //
    // Raster related information
    //
    OUTPUTDATAFORMAT    outputdataformat;       // "OutputDataFormat"
    BOOL        bOptimizeLeftBound;             // *OptimizaLeftBound?
    LISTINDEX   liStripBlanks ;                 // "StripBlanks"
    BOOL        bRasterSendAllData ;            // "RasterSendAllData?"
    CURSORXAFTERSENDBLOCKDATA   cxafterblock;   // "CursorXAfterSendBlockData"
    CURSORYAFTERSENDBLOCKDATA   cyafterblock;   // "CursorYAfterSendBlockData"
    BOOL        bUseCmdSendBlockDataForColor;   // "UseExpColorSelectCmd"
    BOOL        bMoveToX0BeforeColor;           // "MoveToX0BeforeSetColor"
    BOOL        bSendMultipleRows;              // *SendMultipleRows?
    DWORD       dwMaxMultipleRowBytes ;  //  "*MaxMultipleRowBytes"
    BOOL        bMirrorRasterByte;              // *MirrorRasterByte?
    BOOL        bMirrorRasterPage;              // *MirrorRasterPage?

    //
    //Font Information
    //Device Font Specific.
    //

    LISTINDEX   liDeviceFontList;       // "DeviceFonts" Index to Font List Node
    DWORD       dwDefaultFont;          // "DefaultFont ID"
    DWORD       dwMaxFontUsePerPage;    // "MaxFontUsePerPage"
    DWORD       dwDefaultCTT;           // *DefaultCTT
    DWORD       dwLookaheadRegion;      // *LookAheadRegion, never negative
    INT         iTextYOffset;           // *TextYOffset, could be negative
    CHARPOSITION    charpos;            // "CharPosition"

    //
    //Font Substitution.
    //

    BOOL        bTTFSEnabled ;          //"TTFSEnabled?"

    //
    //Font Download
    //

    DWORD       dwMinFontID;            // "MinFontID"
    DWORD       dwMaxFontID;            // "MaxFontID"
    DWORD       dwMaxNumDownFonts;      // *MaxNumDownFonts
    DLSYMBOLSET dlsymbolset;            // *DLSymbolSet
    DWORD       dwMinGlyphID;           // "MinGlyphID"
    DWORD       dwMaxGlyphID;           // "MaxGlyphID"
    FONTFORMAT  fontformat;             // "FontFormat"

    //
    // font simulation
    //

    BOOL        bDiffFontsPerByteMode;  // "DiffFontsPerByteMode?"

    //
    // rectangle area fill
    //

    CURSORXAFTERRECTFILL    cxafterfill;    // *CursorXAfterRectFill
    CURSORYAFTERRECTFILL    cyafterfill;    // *CursorYAfterRectFill
    DWORD                   dwMinGrayFill;  // *MinGrayFill
    DWORD                   dwMaxGrayFill;  // *MaxGrayFill
    DWORD       dwTextHalftoneThreshold ;  //  *TextHalftoneThreshold


} GLOBALS, *PGLOBALS;


//
// DATA TYPE
// Enumeration of all data types in DataType array refernce
//

typedef enum _DATATYPE {
    DT_COMMANDTABLE,                    // maps UnidrvID to index into COMMANDARRAY
    DT_COMMANDARRAY,
    DT_PARAMETERS,
    DT_TOKENSTREAM,                     // stream of RPN operator tokens
    DT_LISTNODE,                        // holds a LIST of dword values
    DT_LOCALLISTNODE,                   // holds a LIST of dword values
    DT_FONTSCART,                       // list of FontCartridges
    DT_FONTSUBST,                       // Font Substitution table.

    DT_LAST
} DATATYPE;

//
// GPDDRIVERINFO fields will be access via by predefined macros due
// to the possiblities that different base address might be required
// by the GPD parser.
//


typedef struct _GPDDRIVERINFO {

    DWORD       dwSize;                 // Size if GPDDRIVERINFO
    ARRAYREF    DataType[DT_LAST];      // global list of ALL
                                        // Array References.  See DATATYPE
                                        // enumeration for details.
    DWORD       dwJobSetupIndex;        // Index to listnode containing
    DWORD       dwDocSetupIndex;        // list of indicies to COMMANDARRAY.
    DWORD       dwPageSetupIndex;       //
    DWORD       dwPageFinishIndex;      //
    DWORD       dwDocFinishIndex;       //
    DWORD       dwJobFinishIndex;       //

    PBYTE       pubResourceData;        // Pointer to resource data base address
    PINFOHEADER pInfoHeader;            // Pointer to InfoHeader;
    GLOBALS     Globals;                // GLOBALS struct

} GPDDRIVERINFO, *PGPDDRIVERINFO;


// ---- WARNING, the following section is owned ---- //
//   by peterwo.  Do not make any changes in these   //
//   definitions without his permission.             //
// ---------------  No  Tresspassing --------------- //

//
// SEQUENCE COMMANDS
// The GPD identifies 6 sections of a job stream.  Within a section, the commands
// are sent out in the increasing order of the sequence number.  The number doesn
// not have to be consecutive.
// The driver will send out sequence commands for each
// of the following sections:
//  JOB_SETUP
//  DOC_SETUP
//  PAGE_SETUP
//  PAGE_FINISH
//  DOC_FINISH
//  JOB_FINISH

//
// SECTION enumeration
//

typedef enum  _SEQSECTION {

    SS_UNINITIALIZED,
    SS_JOBSETUP,
    SS_DOCSETUP,
    SS_PAGESETUP,
    SS_PAGEFINISH,
    SS_DOCFINISH,
    SS_JOBFINISH,

} SEQSECTION;


#if 0
//  the sequence structure has been abandoned in favor
//  of storing the list of COMMAND indicies in LISTNODE
//  structures.  The parser will convert wFeatureIndex
//  into a command Index so the UI module will only
//  deal with command indicies.

typedef struct _SEQUENCE{
    WORD            wIndexOfCmd;        // Index into the COMMAND array
    WORD            wFeatureIndex;      // Index into the FEATURE array
                                        // FEATURE array is in UIINFO
    WORD            wNextInSequence;    // Next sequence commands to send for this setion
                                        // If equal to END_SEQUENCE, means no more for this section
    WORD            wReserved;
} SEQUENCE, *PSEQUENCE;
#endif

//
// ORDERDEPENDENCY
// Orderdepend is not use by the graphics driver, it's mainly present
// for the parsers.
//


typedef  struct
{
    SEQSECTION     eSection;    // Specifies the section
    DWORD          dwOrder   ;  // order within each section.
}  ORDERDEPENDENCY  , * PORDERDEPENDENCY  ;
//  assign this struct the type  'ord'

//
// COMMAND
// All commands listed in GPD will be parsed into the format defined below.
// The command array is a one dimensional array, accessible via predefined index.
// The invocation string an be in the form of one or more binary string concatenated
// together.  Between binary string, there can exists parameter reference, always headed
// by a %.  For example, %paramref, where paramref is the index into the PARAMETER array.
//

typedef struct _COMMAND{
    INVOCATION      strInvocation;      // binary string and parameter references
    ORDERDEPENDENCY ordOrder;           // ORDERDEPENDENCY info
    DWORD           dwCmdCallbackID;    // Command callback IDs are defined in
                                        // GPD.  If set to NO_CALLBACK_ID, it means
                                        // that this cmd doesn't need to be hooked
    DWORD           dwStandardVarsList; // If the dwCmdCallbackID is not used, ignore this
                                        // Otherwise, use dwStandardVarsList as the
                                        // as a list of standard variable that need to be
                                        // passed in command callbacks.
                                        // dwStandardVarsList is an index into the
                                        // LIST array
    BOOL           bNoPageEject;                    // does command cause ejection of current page?
            //   bitfield type doesn't exist for keywords not in snapshot table.
            //  all StartDoc commands with this flag set form a subset that
            //  may be sent as a group.   They will not cause a page ejection.

} COMMAND, *PCOMMAND;
//  assign this struct the type  'cmd'

#define  NO_CALLBACK_ID   (0xffffffff)


//
// PARAMETER
// All the parameters required by defined commands are stored in the PARAMETER array
// The driver will use the parameter reference in INVOCATION string as the index
// into this array for parameters.
//

typedef struct _PARAMETER{
    DWORD           dwFormat;           // Specifies the format of the parameter
    DWORD           dwDigits;           // Specifies the number of digits to be
                                        // emmitted, this is only valid if the
                                        // format is "D" or "d" AND dwFlags has
                                        // PARAM_FLAG_FIELDWIDTH_USED
    DWORD           dwFlags;            // Flags for parameters, which action to carray out:
                                        // PARAM_FLAG_MIN_USED
                                        // PARAM_FLAG_MAX_USED
                                        // PARAM_FLAG_FIELDWIDTH_USED
    LONG            lMin;               // If PARAMETER_MINUSED is set, use this
                                        // as the min value for parameter
    LONG            lMax;               // If PARAMETER_MAXUSED is set, use this
                                        // as the max value for parameter
    ARRAYREF        arTokens;           // Refernce to array of TOKENs for RPN calculator

} PARAMETER, *PPARAMETER;
//  assign this struct the type  'param'


#define PARAM_FLAG_MIN_USED  0x00000001
    //  lMin field is used
#define PARAM_FLAG_MAX_USED  0x00000002
    //  lMax field is used
#define PARAM_FLAG_FIELDWIDTH_USED  0x00000004
    //  if fieldwidth was specified for 'd' or 'D' format.
#define PARAM_FLAG_MAXREPEAT_USED  0x00000008  //  dead
    //  dwMaxRepeat field is used


//
// OPERATOR
// The following is an enumeration of the OPERATOR in TOKENSTREAM
//

typedef enum _OPERATOR
{
    OP_INTEGER,                       //  dwValue contains an integer
    OP_VARI_INDEX,                    //  dwValue contains index to Standard Variable Table.

    //
    //  these operators will actually be inserted into the token
    //  stream.
    //
    OP_MIN, OP_MAX, OP_ADD, OP_SUB, OP_MULT,
    OP_DIV, OP_MOD, OP_MAX_REPEAT, OP_HALT,

    //
    //  these operators are used only in the temporary stack
    //
    OP_OPENPAR, OP_CLOSEPAR, OP_NEG,

    //
    //  these operators are processed immediately by the
    //  token parser and are not stored.
    //

    OP_COMMA, OP_NULL, OP_LAST

}OPERATOR ;


//
// TOKENSTREAM
// This contains the token stream (operands and operators) for the parameter.
//
typedef struct _TOKENSTREAM{
    DWORD           dwValue;             // Integer for Standard variable
    OPERATOR        eType;               // Type of Value or Operator
} TOKENSTREAM, *PTOKENSTREAM;
//  assign this struct the type  'tstr'

//
//FONTSUBSTITUTION
//Font substitution Table. This structure is same as that defined by the parser.
//

typedef  struct _TTFONTSUBTABLE
{
    ARRAYREF    arTTFontName ;  //True Type Font name to be substituted.
    ARRAYREF    arDevFontName ;   // Device Font name of the Font to be used.
    DWORD           dwRcTTFontNameID ;  //
    DWORD           dwRcDevFontNameID ;   //
} TTFONTSUBTABLE, *PTTFONTSUBTABLE ;
//  tag  'ttft'


// ----  List Values Section ---- //


/*  this defines the nodes used to implement a singly-linked
    list of DWORD  items.  Some values are stored in Lists.  */


typedef  struct
{
    DWORD       dwData ;
    DWORD       dwNextItem ;  //  index of next listnode
}  LISTNODE, * PLISTNODE ;
//  assign this struct the type  'lst'

// ----  End of List Values Section ---- //

// ---- Special default values used in snapshot ---- //

#define NO_LIMIT_NUM            0xffffffff
///  #define NO_RC_CTT_ID            0xffffffff  set to zero if none supplied.
#define  WILDCARD_VALUE     (0x80000000)
    //  if '*' appears in place of an integer, it is assigned this value.



// ---- End of Peterwo's Restricted Area ---- //


//
// STANDARD VARIABLE
// The following is an enumeration of the standard variable as defined in the GPD,
// the TOKEN STREAM struct will contain either the actual parameter value or an index
// to this table. The Control Module will keep a table of this in the PDEVICE,
// the parser will use this enumeration table to initialize the dwValue of TOKENSTREAM
//

typedef enum _STDVARIABLE{

        SV_NUMDATABYTES,          // "NumOfDataBytes"
        SV_WIDTHINBYTES,          // "RasterDataWidthInBytes"
        SV_HEIGHTINPIXELS,        // "RasterDataHeightInPixels"
        SV_COPIES,                // "NumOfCopies"
        SV_PRINTDIRECTION,        // "PrintDirInCCDegrees"
        SV_DESTX,                 // "DestX"
        SV_DESTY,                 // "DestY"
        SV_DESTXREL,              // "DestXRel"
        SV_DESTYREL,              // "DestYRel"
        SV_LINEFEEDSPACING,       // "LinefeedSpacing"
        SV_RECTXSIZE,             // "RectXSize"
        SV_RECTYSIZE,             // "RectYSize"
        SV_GRAYPERCENT,           // "GrayPercentage"
        SV_NEXTFONTID,            // "NextFontID"
        SV_NEXTGLYPH,             // "NextGlyph"
        SV_PHYSPAPERLENGTH,       // "PhysPaperLength"
        SV_PHYSPAPERWIDTH,        // "PhysPaperWidth"
        SV_FONTHEIGHT,            // "FontHeight"
        SV_FONTWIDTH,             // "FontWidth"
        SV_FONTMAXWIDTH,             // "FontMaxWidth"
        SV_FONTBOLD,              // "FontBold"
        SV_FONTITALIC,            // "FontItalic"
        SV_FONTUNDERLINE,         // "FontUnderline"
        SV_FONTSTRIKETHRU,        // "FontStrikeThru"
        SV_CURRENTFONTID,         // "CurrentFontID"
        SV_TEXTYRES,              // "TextYRes"
        SV_TEXTXRES,              // "TextXRes"

        SV_GRAPHICSYRES,              // "GraphicsYRes"
        SV_GRAPHICSXRES,              // "GraphicsXRes"

        SV_ROP3,                  // "Rop3"
        SV_REDVALUE,              // "RedValue"
        SV_GREENVALUE,            // "GreenValue"
        SV_BLUEVALUE,             // "BlueValue"
        SV_PALETTEINDEXTOPROGRAM, // "PaletteIndexToProgram"
        SV_CURRENTPALETTEINDEX,   // "CurrentPaletteIndex"
        SV_PATTERNBRUSH_TYPE,     // "PatternBrushType"
        SV_PATTERNBRUSH_ID,       // "PatternBrushID"
        SV_PATTERNBRUSH_SIZE,     // "PatternBrushSize"
        SV_CURSORORIGINX,           //  "CursorOriginX"
        SV_CURSORORIGINY,           //  "CursorOriginY"
                //  this is in MasterUnits and in the coordinates of the currently selected orientation.
                //  this value is defined as ImageableOrigin - CursorOrigin
        SV_PAGENUMBER,  //  "PageNumber"
                //  this value tracks number of times DrvStartBand has been called since
                //  StartDoc.

        //
        // Put new enum above SV_MAX
        //
        SV_MAX

}STDVARIABLE;

//
// GENERAL PRINTING COMMAND
// General printing commands contains such commands as
// cusor control, color, and overlay etc.
// The following is the enumeration of general printing commands.  The list
// of commands are in GPDDRIVERINFO Cmds array, this list is accessed by
// the SEQUENCE struct.
//


typedef enum CMDINDEX
{  //  unidrv index for commands


    //  Printer Configuration
    FIRST_CONFIG_CMD,
    CMD_STARTJOB = FIRST_CONFIG_CMD,    //  "CmdStartJob"
    CMD_STARTDOC,                       //  "CmdStartDoc"
    CMD_STARTPAGE,                      //  "CmdStartPage"
    CMD_ENDPAGE,                        //  "CmdEndPage"
    CMD_ENDDOC,                         //  "CmdEndDoc"
    CMD_ENDJOB,                         //  "CmdEndJob"
    CMD_COPIES,                         //  "CmdCopies"
    CMD_SLEEPTIMEOUT,                   //  "CmdSleepTimeOut"
    LAST_CONFIG_CMD,        // Larger than any Config Command value.

    //
    //  GENERAL
    //

    //
    // CURSOR CONTROL
    //

    CMD_XMOVEABSOLUTE,                  // "CmdXMoveAbsolute"
    CMD_XMOVERELLEFT,                   // "CmdXMoveRelLeft"
    CMD_XMOVERELRIGHT,                  // "CmdXMoveRelRight"
    CMD_YMOVEABSOLUTE,                  // "CmdYMoveAbsolute"
    CMD_YMOVERELUP,                     // "CmdYMoveRelUp"
    CMD_YMOVERELDOWN,                   // "CmdYMoveRelDown"
    CMD_SETSIMPLEROTATION,              // "CmdSetSimpleRotation"
    CMD_SETANYROTATION,                 // "CmdSetAnyRotation"
    CMD_UNIDIRECTIONON,                 // "CmdUniDirectionOn"
    CMD_UNIDIRECTIONOFF,                // "CmdUniDirectionOff"
    CMD_SETLINESPACING,                 // "CmdSetLineSpacing"
    CMD_PUSHCURSOR,                     // "CmdPushCursor"
    CMD_POPCURSOR,                      // "CmdPopCursor"
    CMD_BACKSPACE,                      // "CmdBackSpace"
    CMD_FORMFEED,                       // "CmdFF"
    CMD_CARRIAGERETURN,                 // "CmdCR"
    CMD_LINEFEED,                       // "CmdLF"

    //
    // COLOR
    //

    CMD_SELECTBLACKCOLOR,               // "CmdSelectBlackColor"
    CMD_SELECTREDCOLOR,                 // "CmdSelectRedColor"
    CMD_SELECTGREENCOLOR,               // "CmdSelectGreenColor"
    CMD_SELECTYELLOWCOLOR,              // "CmdSelectYellowColor"
    CMD_SELECTBLUECOLOR,                // "CmdSelectBlueColor"
    CMD_SELECTMAGENTACOLOR,             // "CmdSelectMagentaColor"
    CMD_SELECTCYANCOLOR,                // "CmdSelectCyanColor"
    CMD_SELECTWHITECOLOR,               // "CmdSelectWhiteColor"
    CMD_BEGINPALETTEDEF,                // "CmdBeginPaletteDef"
    CMD_ENDPALETTEDEF,                  // "CmdEndPaletteDef"
    CMD_DEFINEPALETTEENTRY,             // "CmdDefinePaletteEntry"
    CMD_BEGINPALETTEREDEF,              //  "CmdBeginPaletteReDef"
    CMD_ENDPALETTEREDEF,                    //  "CmdEndPaletteReDef"
    CMD_REDEFINEPALETTEENTRY,           //  "CmdReDefinePaletteEntry"
    CMD_SELECTPALETTEENTRY,             // "CmdSelectPaletteEntry"
    CMD_PUSHPALETTE,                    // "CmdPushPalette"
    CMD_POPPALETTE,                     // "CmdPopPalette"

    //
    // DATACOMPRESSION
    //

    CMD_ENABLETIFF4,                    // "CmdEnableTIFF4"
    CMD_ENABLEDRC,                      // "CmdEnableDRC"
    CMD_ENABLEFERLE,                    // CmdEnableFE_RLE
    CMD_ENABLEOEMCOMP,                  // "CmdEnableOEMComp"
    CMD_DISABLECOMPRESSION,             // "CmdDisableCompression"

    //
    //  Raster Data Emission
    //

    CMD_BEGINRASTER,                    // "CmdBeginRaster"
    CMD_ENDRASTER,                      // "CmdEndRaster"
    CMD_SETDESTBMPWIDTH,                // "CmdSetDestBmpWidth"
    CMD_SETDESTBMPHEIGHT,               // "CmdSetDestBmpHeight"
    CMD_SETSRCBMPWIDTH,                 // "CmdSetSrcBmpWidth"
    CMD_SETSRCBMPHEIGHT,                // "CmdSetSrcBmpHeight"
    CMD_SENDBLOCKDATA,                  // "CmdSendBlockData"
    CMD_ENDBLOCKDATA,                   // "CmdEndBlockData"
    CMD_SENDREDDATA,                    // "CmdSendRedData"
    CMD_SENDGREENDATA,                  // "CmdSendGreenData"
    CMD_SENDBLUEDATA,                   // "CmdSendBlueData"
    CMD_SENDCYANDATA,                   // "CmdSendCyanData"
    CMD_SENDMAGENTADATA,                // "CmdSendMagentaData"
    CMD_SENDYELLOWDATA,                 // "CmdSendYellowData"
    CMD_SENDBLACKDATA,                  // "CmdSendBlackData"

    //
    //  Font Downloading
    //

    CMD_SETFONTID,                      // "CmdSetFontID"
    CMD_SELECTFONTID,                   // "CmdSelectFontID"
    CMD_SETCHARCODE,                    // "CmdSetCharCode"

    CMD_DESELECTFONTID,                     //  "CmdDeselectFontID"
    CMD_SELECTFONTHEIGHT,               //  "CmdSelectFontHeight"
    CMD_SELECTFONTWIDTH,                    //  "CmdSelectFontWidth"

    CMD_DELETEFONT,                     // "CmdDeleteFont"

    //
    //  Font Simulation
    //

    CMD_SETFONTSIM,                     // "CmdSetFontSim"
    CMD_BOLDON,                         // "CmdBoldOn"
    CMD_BOLDOFF,                        // "CmdBoldOff"
    CMD_ITALICON,                       // "CmdItalicOn"
    CMD_ITALICOFF,                      // "CmdItalicOff"
    CMD_UNDERLINEON,                    // "CmdUnderlineOn"
    CMD_UNDERLINEOFF,                   // "CmdUnderlineOff"
    CMD_STRIKETHRUON,                   // "CmdStrikeThruOn"
    CMD_STRIKETHRUOFF,                  // "CmdStrikeThruOff"
    CMD_WHITETEXTON,                    // "CmdWhiteTextOn"
    CMD_WHITETEXTOFF,                   // "CmdWhiteTextOff"
    CMD_SELECTSINGLEBYTEMODE,           // "CmdSelectSingleByteMode"
    CMD_SELECTDOUBLEBYTEMODE,           // "CmdSelectDoubleByteMode"
    CMD_VERTICALPRINTINGON,             // "CmdVerticalPrintingOn"
    CMD_VERTICALPRINTINGOFF,            // "CmdVerticalPrintingOff"
    CMD_CLEARALLFONTATTRIBS,            // "CmdClearAllFontAttribs"

    //
    // Print Object Specific Halftone Alogorithms (Used mainly for color devices)
    //
    CMD_SETTEXTHTALGO,                  // "CmdSetTextHTAlgo"
    CMD_SETGRAPHICSHTALGO,              // "CmdSetGraphicsHTAlgo"
    CMD_SETPHOTOHTALGO,                 // "CmdSetPhotoHTAlgo"

    //
    //  Vector Printing
    //

    CMD_FIRST_RULES,    //  existence of the RULES commands
                        // imples  RULES_ABLE
    CMD_SETRECTWIDTH = CMD_FIRST_RULES, // "CmdSetRectWidth"
    CMD_SETRECTHEIGHT,                  // "CmdSetRectHeight"
    CMD_SETRECTSIZE,                    // "CmdSetRectSize"
    CMD_RECTGRAYFILL,                   // "CmdRectGrayFill"
    CMD_RECTWHITEFILL,                  // "CmdRectWhiteFill"
    CMD_RECTBLACKFILL,                  // "CmdRectBlackFill"
    CMD_LAST_RULES = CMD_RECTBLACKFILL,

    //
    // Brush Selection
    //

    CMD_DOWNLOAD_PATTERN,               // "CmdDownloadPattern"
    CMD_SELECT_PATTERN,                 // "CmdSelectPattern"
    CMD_SELECT_WHITEBRUSH,              // "CmdSelectWhiteBrush"
    CMD_SELECT_BLACKBRUSH,              // "CmdSelectBlackBrush"

    //
    // Put new commands above CMD_MAX
    //

    CMD_MAX

} CMDINDEX;


//
// Rendering Information for Predefined Features
//

//
// GID_RESOLUTION
//

typedef struct _RESOLUTIONEX {
    POINT       ptGrxDPI;                   // *DPI
    POINT       ptTextDPI;                  // *TextDPI
    DWORD       dwMinStripBlankPixels ;     // *MinStripBlankPixels
    DWORD       dwPinsPerPhysPass;          // *PinsPerPhysPass
    DWORD       dwPinsPerLogPass;           // *PinsPerLogPass
    DWORD       dwSpotDiameter;             // *SpotDiameter
    BOOL        bRequireUniDir;             // *RequireUniDir?
    DWORD       dwRedDeviceGamma ;          // "RedDeviceGamma"
    DWORD       dwGreenDeviceGamma ;        // "GreenDeviceGamma"
    DWORD       dwBlueDeviceGamma ;         // "BlueDeviceGamma"

} RESOLUTIONEX, * PRESOLUTIONEX;

//
// GID_COLORMODE
//

typedef struct _COLORMODEEX {
    BOOL        bColor;                 // *Color?
    DWORD       dwPrinterNumOfPlanes;   // *DevNumOfPlanes
    DWORD       dwPrinterBPP;           // *DevBPP
    LISTINDEX   liColorPlaneOrder;      // *ColorPlaneOrder
    DWORD       dwDrvBPP;               // *DrvBPP
    DWORD       dwIPCallbackID ;        // *IPCallbackID
    RASTERMODE  dwRasterMode ;          //  *RasterMode
    DWORD       dwPaletteSize ;         //  *PaletteSize
    BOOL        bPaletteProgrammable;   //  *PaletteProgrammable?

} COLORMODEEX, *PCOLORMODEEX;

//
// GID_PAGESIZE
//

typedef struct _PAGESIZEEX {
    SIZEL       szImageArea;            // *PrintableArea, for non-CUSTOMSIZE options
    POINT       ptImageOrigin;          // *PrintableOrigin, for non-CUSTOMSIZE options
    POINT       ptPrinterCursorOrig;    // *CursorOrigin
    POINT       ptMinSize;              // *MinSize, for CUSTOMSIZE option only
    POINT       ptMaxSize;              // *MaxSize, for CUSTOMSIZE option only
    DWORD       dwTopMargin;            // *TopMargin, for CUSTOMSIZE option only
    DWORD       dwBottomMargin;         // *BottomMargin, for CUSTOMSIZE option only
    DWORD       dwMaxPrintableWidth;    // *MaxPrintableWidth, for CUSTOMSIZE option only
    DWORD       dwMinLeftMargin;        // *MinLeftMargin, for CUSTOMSIZE option only
    BOOL        bCenterPrintArea;       // *CenterPrintable?, for CUSTOMSIZE option only
    BOOL        bRotateSize;            // *RotateSize?
    DWORD        dwPortRotationAngle;            // *PortRotationAngle
    INVOCATION      strCustCursorOriginX ;  //  "CustCursorOriginX"
    INVOCATION      strCustCursorOriginY ;  //  "CustCursorOriginY"
    INVOCATION      strCustPrintableOriginX ;  //  "CustPrintableOriginX"
    INVOCATION      strCustPrintableOriginY ;  //  "CustPrintableOriginY"
    INVOCATION      strCustPrintableSizeX;  //   "CustPrintableSizeX"
    INVOCATION      strCustPrintableSizeY;  //   "CustPrintableSizeY"


} PAGESIZEEX, *PPAGESIZEEX;

//
// define standard PageProtect options (for PAGEPROTECT.dwPageProtectID)
//
typedef enum _PAGEPRO {
    PAGEPRO_ON,
    PAGEPRO_OFF
} PAGEPRO;

//
// define possible values for *FeatureType keyword
//
typedef enum _FEATURETYPE {
    FT_DOCPROPERTY,
    FT_JOBPROPERTY,
    FT_PRINTERPROPERTY
} FEATURETYPE;

//
// define possible values for *PromptTime keyword
//
typedef enum _PROMPTTIME {
    PROMPT_UISETUP,
    PROMPT_PRTSTARTDOC
} PROMPTTIME;

//
// define color plane id's, used by *ColorPlaneOrder keyword
//
typedef enum _COLORPLANE {
    COLOR_YELLOW,
    COLOR_MAGENTA,
    COLOR_CYAN,
    COLOR_BLACK,
    COLOR_RED,
    COLOR_GREEN,
    COLOR_BLUE
} COLORPLANE;

//
// define values for *BadCursorMoveInGrxMode keyword
//
typedef enum _BADCURSORMOVEINGRXMODE {
    NOCM_X_PORTRAIT,
    NOCM_X_LANDSCAPE,
    NOCM_Y_PORTRAIT,
    NOCM_Y_LANDSCAPE
} BADCURSORMOVEINGRXMODE;

//
// define values for *YMoveAttributes keyword
//
typedef enum _YMOVEATTRIBUTE {
    YMOVE_FAVOR_LINEFEEDSPACING,
    YMOVE_SENDCR_FIRST,
} YMOVEATTRIBUTE;

//
// define values for *PaletteScope keyword
//
typedef enum _PALETTESCOPE {
    PALS_FOR_RASTER,
    PALS_FOR_TEXT,
    PALS_FOR_VECTOR
} PALETTESCOPE;

//
// define values for *StripBlanks keyword
//
typedef enum _STRIPBLANKS {
    SB_LEADING,
    SB_ENCLOSED,
    SB_TRAILING
} STRIPBLANKS;

//
// define values for *TextCaps
//
typedef enum _TEXTCAP {
    TEXTCAPS_OP_CHARACTER,
    TEXTCAPS_OP_STROKE,
    TEXTCAPS_CP_STROKE,
    TEXTCAPS_CR_90,
    TEXTCAPS_CR_ANY,
    TEXTCAPS_SF_X_YINDEP,
    TEXTCAPS_SA_DOUBLE,
    TEXTCAPS_SA_INTEGER,
    TEXTCAPS_SA_CONTIN,
    TEXTCAPS_EA_DOUBLE,
    TEXTCAPS_IA_ABLE,
    TEXTCAPS_UA_ABLE,
    TEXTCAPS_SO_ABLE,
    TEXTCAPS_RA_ABLE,
    TEXTCAPS_VA_ABLE
} TEXTCAP;

//
// define values for *MemoryUsage
//
typedef enum _MEMORYUSAGE {
    MEMORY_FONT,
    MEMORY_RASTER,
    MEMORY_VECTOR

} MEMORYUSAGE;

//
// define values for *ReselectFont
//
typedef enum _RESELECTFONT {
    RESELECTFONT_AFTER_GRXDATA,
    RESELECTFONT_AFTER_XMOVE,
    RESELECTFONT_AFTER_FF

} RESELECTFONT;


// ----  macrodefinitions to access various data structures: ---- //


//  this macro returns a pointer to the COMMAND structure
//  corresponding to the specified Unidrv CommandID.
#ifndef PERFTEST

#define  COMMANDPTR(pGPDDrvInfo , UniCmdID )   \
((((PDWORD)((PBYTE)(pGPDDrvInfo)->pInfoHeader + \
(pGPDDrvInfo)->DataType[DT_COMMANDTABLE].loOffset)) \
[(UniCmdID)] == UNUSED_ITEM ) ? NULL : \
(PCOMMAND)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_COMMANDARRAY].loOffset) \
+ ((PDWORD)((PBYTE)(pGPDDrvInfo)->pInfoHeader + \
(pGPDDrvInfo)->DataType[DT_COMMANDTABLE].loOffset)) \
[(UniCmdID)])

#else //PERFTEST

#define  COMMANDPTR         CommandPtr

PCOMMAND
CommandPtr(
    IN  PGPDDRIVERINFO  pGPDDrvInfo,
    IN  DWORD           UniCmdID
    );

#endif //PERFTEST

// this macro returns a pointer to the COMMAND structure
// corresponding to specified index(to the COMMAND ARRAY)

#define  INDEXTOCOMMANDPTR(pGPDDrvInfo , CmdIndex )   \
((CmdIndex == UNUSED_ITEM ) ? NULL : \
(PCOMMAND)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_COMMANDARRAY].loOffset) \
+ CmdIndex)

//  this macro returns a pointer to the specified PARAMETER structure
//  within the parameter array

#define  PARAMETERPTR(pGPDDrvInfo , dwIndex )   \
(PPARAMETER)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_PARAMETERS].loOffset) \
+ (dwIndex)


//  this macro returns a pointer to the start of the specified
//  TOKENSTREAM structure, dwIndex comes from pParameter->Tokens.loOffset

#define  TOKENSTREAMPTR(pGPDDrvInfo , dwIndex )   \
(PTOKENSTREAM)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_TOKENSTREAM].loOffset) \
+ (dwIndex)

//  This macro returns a pointer to the start of the FontCart Array.
//  FONTCART is ARRAYREF so all the elements are contiguous.

#define  GETFONTCARTARRAY(pGPDDrvInfo)   \
(PFONTCART)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_FONTSCART].loOffset)


//  This macro returns a pointer to the start of the Font Substitution table.
//  Substitution table is ARRAYREF so all the elements are contiguous.

#define  GETTTFONTSUBTABLE(pGPDDrvInfo)   \
(PTTFONTSUBTABLE)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_FONTSUBST].loOffset)

//  This macro returns the string pointer. The string is  null terminated.
//  Use the dwcount member of ARRAYEF to verify the correct size.
#define  GETSTRING(pGPDDrvInfo, arfString)   \
        (WCHAR *)((pGPDDrvInfo)->pubResourceData + (arfString).loOffset )

//  this macro returns a pointer to the start of the specified
//  LISTNODE structure, for example, dwIndex may come from
//  pParameter->dwStandardVarsList

#define  LISTNODEPTR(pGPDDrvInfo , dwIndex )   \
((dwIndex == END_OF_LIST ) ? NULL : \
(PLISTNODE)((pGPDDrvInfo)->pubResourceData + \
(pGPDDrvInfo)->DataType[DT_LISTNODE].loOffset) \
+ (dwIndex))



//  this macro returns a pointer to the start of the specified
//  LOCALLISTNODE structure, for example, dwIndex may come from
//  pParameter->dwStandardVarsList.   Returns NULL if
//  (dwIndex == UNUSED_ITEM)

#define  LOCALLISTNODEPTR(pGPDDrvInfo , dwIndex )   \
((dwIndex == UNUSED_ITEM ) ? NULL : \
(PLISTNODE)((PBYTE)(pGPDDrvInfo)->pInfoHeader + \
(pGPDDrvInfo)->DataType[DT_LOCALLISTNODE].loOffset) \
+ (dwIndex))


//  ----  end macrodefinitions section  ----- //


//  -----  GPD parser only helper function     ----- //
DWORD
UniMapToDeviceOptIndex(
    IN PINFOHEADER  pInfoHdr ,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes,       // used only for GID_PAGESIZE
    IN    PDWORD       pdwPaperID   //  optional paperID
    ) ;



#endif // !_GPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\helper.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    helper.h

Abstract:

    Helper functions header file

Environment:

    Windows NT printer drivers

Revision History:

--*/

#define FLAG_INIPROCESS_UPGRADE     0x0001

VOID
VFreeParserInfo(
    IN  PPARSERINFO pParserInfo
    );


PUIINFO
PGetUIInfo(
    IN  HANDLE         hPrinter,
    IN  PRAWBINARYDATA pRawData,
    IN  POPTSELECT     pCombineOptions,
    IN  POPTSELECT     pOptions,
    OUT PPARSERINFO    pParserInfo,
    OUT PDWORD         pdwFeatureCount
    );


//
// Process OEM plugin configuration file and
// save the resulting information into registry
//

BOOL
BProcessPrinterIniFile(
    HANDLE          hPrinter,
    PDRIVER_INFO_3  pDriverInfo3,
    PTSTR           *ppParsedData,
    DWORD           dwFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\fontinst.h ===
/****************************Module*Header******************************\
* Module Name: FONTINST.H
*
* Module Descripton:
*      Font installer related structures. Some of these define the format
*      of the font file, and others are internal structures used by Unidrv's
*      built in font installer.
*
* Warnings:
*
* Issues:
*
* Created:  22 October 1997
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996 - 1999  Microsoft Corporation
\***********************************************************************/

#ifndef _FONTINST_H_

#define _FONTINST_H_

//
// Structure to keep track of font data obtained from softfont (PCL) files
//

typedef struct _FNTDAT
{
    struct  _FNTDAT *pNext;          // Forms a linked list
    PBYTE   pVarData;                // Pointer to buffer having PCL data
    DWORD   dwSize;                  // Size of variable data
    FI_DATA fid;                     // The specific font information
    WCHAR   wchFileName[MAX_PATH];   // Corresponding file in directory
} FNTDAT, *PFNTDAT;

//
// Font installer callback function
//

INT_PTR CALLBACK FontInstProc(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY BInstallSoftFont(HANDLE, HANDLE, PBYTE, DWORD);
BOOL APIENTRY BUpdateExternalFonts(HANDLE, HANDLE, PWSTR);

BOOL          BGetFontCartridgeFile(HANDLE, HANDLE);

//
// Functions to read the font file
//

#ifdef KERNEL_MODE
HANDLE             FIOpenFontFile(HANDLE, HANDLE, HANDLE);
#else
HANDLE             FIOpenFontFile(HANDLE, HANDLE);
#endif
#ifdef KERNEL_MODE
HANDLE             FIOpenCartridgeFile(HANDLE, HANDLE, HANDLE);
#else
HANDLE             FIOpenCartridgeFile(HANDLE, HANDLE);
#endif
VOID               FICloseFontFile(HANDLE);
DWORD              FIGetNumFonts(HANDLE);
PUFF_FONTDIRECTORY FIGetFontDir(HANDLE);
PWSTR              FIGetFontName(HANDLE, DWORD);
PWSTR              FIGetFontCartridgeName(HANDLE, DWORD);
PDATA_HEADER       FIGetFontData(HANDLE, DWORD);
PDATA_HEADER       FIGetGlyphData(HANDLE, DWORD);
PDATA_HEADER       FIGetVarData(HANDLE, DWORD);
HANDLE             FICreateFontFile(HANDLE, HANDLE, DWORD);
BOOL               FIWriteFileHeader(HANDLE);
BOOL               FIWriteFontDirectory(HANDLE);
VOID               FIAlignedSeek(HANDLE, DWORD);
BOOL               FICopyFontRecord(HANDLE, HANDLE, DWORD, DWORD);
BOOL               FIAddFontRecord(HANDLE, DWORD, FNTDAT*);
BOOL               FIUpdateFontFile(HANDLE, HANDLE, BOOL);


//
// Functions to write PCL data
//

DWORD FIWriteFix(HANDLE, WORD, FI_DATA*);
DWORD FIWriteVar(HANDLE, PTSTR);
DWORD FIWriteRawVar(HANDLE, PBYTE, DWORD);

#endif  // #ifndef _FONTINST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\p64_nt4.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    p64_nt4.h

Abstract:

    P64 Type Definitions for NT4. (This header file is
    used so our NT5 source tree can be compiled for NT4.)

Revision History:

    04/21/98 -fengy-
        Created it.

--*/

#ifndef _P64_NT4_H_
#define _P64_NT4_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// The LONG_PTR is guaranteed to be the same size as a pointer.  Its
// size with change with pointer size (32/64).  It should be used
// anywhere that a pointer is cast to an integer type. ULONG_PTR is
// the unsigned variation.
//

typedef long LONG_PTR, *PLONG_PTR;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

#ifndef _BASETSD_H_

//
// This is to resolve the typedef conflict with VC++ 6's basetsd.h,
// which uses "typedef long INT_PTR, *PINT_PTR;".
//

typedef int INT_PTR, *PINT_PTR;

#endif // _BASETSD_H_

#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
#define PtrToLong( p )  ((LONG)(LONG_PTR) (p) )
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
#define PtrToShort( p )  ((short)(LONG_PTR)(p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define ULongToPtr( ul ) ((VOID *)(ULONG_PTR)((unsigned long)ul))

#define GWLP_USERDATA       GWL_USERDATA
#define DWLP_USER           DWL_USER
#define SetWindowLongPtr    SetWindowLong
#define GetWindowLongPtr    GetWindowLong

#ifdef __cplusplus
}
#endif

#endif // _P64_NT4_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\oemutil.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    oemutil.h

Abstract:

    Declarations used to implement OEM plugin architecture

Environment:

    Windows NT printer driver

Revision History:

    01/21/97 -davidx-
         Created it.

    04/01/97 -zhanw-
        Added Unidrv specific DDI hooks (OEMDitherColor, OEMNextBand, OEMStartBanding,
        OEMPaint, OEMLineTo).

--*/


#ifndef _OEMUTIL_H_
#define _OEMUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WINNT_40

#undef IsEqualGUID
#define IsEqualGUID(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

#include <wtypes.h>

#endif

typedef BOOL (APIENTRY *PFN_OEMGetInfo)(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded
    );

typedef BOOL (APIENTRY *PFN_OEMDriverDMS)(
    PVOID    pDevObj,
    PVOID    pBuffer,
    DWORD    cbSize,
    PDWORD   pcbNeeded
    );

typedef BOOL (APIENTRY *PFN_OEMDevMode)(
    DWORD   dwMode,
    POEMDMPARAM pOemDMParam
    );

//
// *** Kernel-mode rendering module - OEM entrypoints ***
//

#ifdef KERNEL_MODE


typedef BOOL (APIENTRY *PFN_OEMEnableDriver)(
    DWORD           DriverVersion,
    DWORD           cbSize,
    PDRVENABLEDATA  pded
    );

typedef VOID (APIENTRY *PFN_OEMDisableDriver)(
    VOID
    );

typedef PDEVOEM (APIENTRY *PFN_OEMEnablePDEV)(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded
    );

typedef VOID (APIENTRY *PFN_OEMDisablePDEV)(
    PDEVOBJ pdevobj
    );

typedef BOOL (APIENTRY *PFN_OEMResetPDEV)(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    );

typedef DWORD (APIENTRY *PFN_OEMCommand)(
    PDEVOBJ pdevobj,
    DWORD   dwIndex,
    PVOID   pData,
    DWORD   cbSize
    );

typedef INT (APIENTRY *PFN_OEMCommandCallback)(
    PDEVOBJ         pdevobj,
    DWORD           dwCallbackID,
    DWORD           dwCount,
    PDWORD          pdwParams
    );

typedef PBYTE (APIENTRY *PFN_OEMImageProcessing)(
    PDEVOBJ     pdevobj,
    PBYTE       pSrcBitmap,
    PBITMAPINFOHEADER pBitmapInfoHeader,
    PBYTE       pColorTable,
    DWORD       dwCallbackID,
    PIPPARAMS   pIPParams
    );

typedef BOOL (APIENTRY *PFN_OEMFilterGraphics)(
    PDEVOBJ pdevobj,
    PBYTE   pBuf,
    DWORD   dwLen
    );

typedef INT (APIENTRY *PFN_OEMCompression)(
    PDEVOBJ pdevobj,
    PBYTE   pInBuf,
    PBYTE   pOutBuf,
    DWORD   dwInLen,
    DWORD   dwOutLen
    );

typedef BOOL (APIENTRY *PFN_OEMHalftonePattern)(
    PDEVOBJ pdevobj,
    PBYTE   pHTPattern,
    DWORD   dwHTPatternX,
    DWORD   dwHTPatternY,
    DWORD   dwHTNumPatterns,
    DWORD   dwCallbackID,
    PBYTE   pResource,
    DWORD   dwResourceSize
    );

typedef VOID (APIENTRY *PFN_OEMMemoryUsage)(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE   pMemoryUsage
    );

typedef DWORD (APIENTRY *PFN_OEMDownloadFontHeader)(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

typedef DWORD (APIENTRY *PFN_OEMDownloadCharGlyph)(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwFreeMem
    );

typedef DWORD (APIENTRY *PFN_OEMTTDownloadMethod)(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    );

typedef VOID (APIENTRY *PFN_OEMOutputCharStr)(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph
    );

typedef VOID (APIENTRY *PFN_OEMSendFontCmd)(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv
    );

typedef BOOL (APIENTRY *PFN_OEMTTYGetInfo)(
    PDEVOBJ      pdevobj,
    DWORD        dwInfoIndex,
    PVOID        pOutputBuf,
    DWORD        dwSize,
    DWORD        *pcbNeeded
    );

typedef BOOL (APIENTRY *PFN_OEMTextOutAsBitmap)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

enum {
    EP_OEMGetInfo,
    EP_OEMDevMode,
    EP_OEMEnableDriver,
    EP_OEMDisableDriver,
    EP_OEMEnablePDEV,
    EP_OEMDisablePDEV,
    EP_OEMResetPDEV,
    EP_OEMCommand,
    EP_OEMDriverDMS,

    MAX_OEMENTRIES
};

#ifdef DEFINE_OEMPROC_NAMES

static CONST PSTR OEMProcNames[MAX_OEMENTRIES] = {
    "OEMGetInfo",
    "OEMDevMode",
    "OEMEnableDriver",
    "OEMDisableDriver",
    "OEMEnablePDEV",
    "OEMDisablePDEV",
    "OEMResetPDEV",
    "OEMCommand",
    "OEMDriverDMS",
};

#endif // DEFINE_OEMPROC_NAMES

//
// NOTE: These are different from the entrypoints above.
// They are returned by the OEM module in a table instead
// of being exported by the DLL.
//

typedef BOOL (APIENTRY *PFN_OEMBitBlt)(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    );

typedef BOOL (APIENTRY *PFN_OEMStretchBlt)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    );

typedef BOOL (APIENTRY *PFN_OEMCopyBits)(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    );

typedef BOOL (APIENTRY *PFN_OEMTextOut)(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_OEMStrokePath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    );

typedef BOOL (APIENTRY *PFN_OEMFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_OEMStrokeAndFillPath)(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    );

typedef BOOL (APIENTRY *PFN_OEMRealizeBrush)(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    );

typedef BOOL (APIENTRY *PFN_OEMStartPage)(
    SURFOBJ    *pso
    );

typedef BOOL (APIENTRY *PFN_OEMSendPage)(
    SURFOBJ    *pso
    );

typedef ULONG (APIENTRY *PFN_OEMEscape)(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef BOOL (APIENTRY *PFN_OEMStartDoc)(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    );

typedef BOOL (APIENTRY *PFN_OEMEndDoc)(
    SURFOBJ    *pso,
    FLONG       fl
    );

typedef PIFIMETRICS (APIENTRY *PFN_OEMQueryFont)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG_PTR   *pid
    );

typedef PVOID (APIENTRY *PFN_OEMQueryFontTree)(
    DHPDEV      dhpdev,
    ULONG_PTR    iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR   *pid
    );

typedef LONG (APIENTRY *PFN_OEMQueryFontData)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    );

typedef BOOL (APIENTRY *PFN_OEMQueryAdvanceWidths)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    );

typedef ULONG (APIENTRY *PFN_OEMFontManagement)(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    );

typedef ULONG (APIENTRY *PFN_OEMGetGlyphMode)(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    );

typedef BOOL (APIENTRY *PFN_OEMNextBand)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef BOOL (APIENTRY *PFN_OEMStartBanding)(
    SURFOBJ *pso,
    POINTL *pptl
    );

typedef ULONG (APIENTRY *PFN_OEMDitherColor)(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    );

typedef BOOL (APIENTRY *PFN_OEMPaint)(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    );

typedef BOOL (APIENTRY *PFN_OEMLineTo)(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    );

#ifndef WINNT_40

typedef BOOL (APIENTRY *PFN_OEMStretchBltROP)(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    );

typedef BOOL (APIENTRY *PFN_OEMPlgBlt)(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    );

typedef BOOL (APIENTRY *PFN_OEMAlphaBlend)(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    );

typedef BOOL (APIENTRY *PFN_OEMGradientFill)(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    );

typedef HANDLE (APIENTRY *PFN_OEMIcmCreateColorTransform)(
    DHPDEV           dhpdev,
    LPLOGCOLORSPACEW pLogColorSpace,
    PVOID            pvSourceProfile,
    ULONG            cjSourceProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile,
    DWORD            dwReserved
    );

typedef BOOL (APIENTRY *PFN_OEMIcmDeleteColorTransform)(
    DHPDEV dhpdev,
    HANDLE hcmXform
    );

typedef BOOL (APIENTRY *PFN_OEMQueryDeviceSupport)(
    SURFOBJ    *pso,
    XLATEOBJ   *pxlo,
    XFORMOBJ   *pxo,
    ULONG      iType,
    ULONG      cjIn,
    PVOID      pvIn,
    ULONG      cjOut,
    PVOID      pvOut
    );

typedef BOOL (APIENTRY *PFN_OEMTransparentBlt)(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    );

#endif // !WINNT_40


//
// WARNING!!!
// Do not change the following declaration without consulting with
// the people responsible for PSCRIPT and UNIDRV kernel modes.
//

enum {
    EP_OEMRealizeBrush,
    EP_OEMDitherColor,
    EP_OEMCopyBits,
    EP_OEMBitBlt,
    EP_OEMStretchBlt,
    EP_OEMStretchBltROP,
    EP_OEMPlgBlt,
    EP_OEMTransparentBlt,
    EP_OEMAlphaBlend,
    EP_OEMGradientFill,
    EP_OEMTextOut,
    EP_OEMStrokePath,
    EP_OEMFillPath,
    EP_OEMStrokeAndFillPath,
    EP_OEMPaint,
    EP_OEMLineTo,
    EP_OEMStartPage,
    EP_OEMSendPage,
    EP_OEMEscape,
    EP_OEMStartDoc,
    EP_OEMEndDoc,
    EP_OEMNextBand,
    EP_OEMStartBanding,
    EP_OEMQueryFont,
    EP_OEMQueryFontTree,
    EP_OEMQueryFontData,
    EP_OEMQueryAdvanceWidths,
    EP_OEMFontManagement,
    EP_OEMGetGlyphMode,
    EP_OEMIcmCreateColorTransform,
    EP_OEMIcmDeleteColorTransform,
    EP_OEMQueryDeviceSupport,

    //
    // The following Unidrv-specific callbacks allow at most one OEM to hook
    // out for each function at a time. They must be exported by the OEM dll's.
    // New callbacks must be added between EP_UNIDRV_ONLY_FIRST and
    // EP_UNIDRV_ONLY_LAST. If you change the first or the last callback,
    // remember to update these two constants!! Don't forget to update
    // OEMUnidrvProcNames[] in unidrv\control\oemkm.c accordingly.
    //
    EP_UNIDRV_ONLY_FIRST,
    EP_OEMCommandCallback = EP_UNIDRV_ONLY_FIRST,
    EP_OEMImageProcessing,
    EP_OEMFilterGraphics,
    EP_OEMCompression,
    EP_OEMHalftonePattern,
    EP_OEMMemoryUsage,
    EP_OEMDownloadFontHeader,
    EP_OEMDownloadCharGlyph,
    EP_OEMTTDownloadMethod,
    EP_OEMOutputCharStr,
    EP_OEMSendFontCmd,
    EP_OEMTTYGetInfo,
    EP_OEMTextOutAsBitmap,
    EP_OEMWritePrinter,
    EP_UNIDRV_ONLY_LAST = EP_OEMWritePrinter,

    MAX_OEMHOOKS,
};

#define MAX_UNIDRV_ONLY_HOOKS   (EP_UNIDRV_ONLY_LAST - EP_UNIDRV_ONLY_FIRST + 1)
#define INVALID_EP               0xFFFFFFFF

#endif // KERNEL_MODE


//
// *** User-mode UI module - OEM entrypoints ***
//

#ifndef KERNEL_MODE

typedef BOOL (APIENTRY *PFN_OEMCommonUIProp)(
    DWORD dwMode,
    POEMCUIPPARAM pOemCUIPParam
    );

typedef LRESULT (APIENTRY *PFN_OEMDocumentPropertySheets)(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

typedef LRESULT (APIENTRY *PFN_OEMDevicePropertySheets)(
    PPROPSHEETUI_INFO pPSUIInfo,
    LPARAM            lParam
    );

typedef BOOL (APIENTRY *PFN_OEMDevQueryPrintEx)(
    POEMUIOBJ           poemuiobj,
    PDEVQUERYPRINT_INFO pDQPInfo,
    PDEVMODE            pPublicDM,
    PVOID               pOEMDM
    );

typedef DWORD (APIENTRY *PFN_OEMDeviceCapabilities)(
    POEMUIOBJ   poemuiobj,
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    DWORD       dwOld
    );

typedef BOOL (APIENTRY *PFN_OEMUpgradePrinter)(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo
    );

typedef BOOL (APIENTRY *PFN_OEMPrinterEvent)(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam
    );

typedef BOOL (APIENTRY *PFN_OEMDriverEvent)(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    );


typedef BOOL (APIENTRY *PFN_OEMQueryColorProfile)(
    HANDLE      hPrinter,
    POEMUIOBJ   poemuiobj,
    PDEVMODE    pPublicDM,
    PVOID       pOEMDM,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    );

typedef BOOL (APIENTRY *PFN_OEMUpgradeRegistry)(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo,
    PFN_DrvUpgradeRegistrySetting pfnUpgradeRegistry
    );

typedef INT_PTR (CALLBACK *PFN_OEMFontInstallerDlgProc)(
    HWND    hWnd,
    UINT    usMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

typedef BOOL (APIENTRY *PFN_OEMUpdateExternalFonts)(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges
        );

enum {
    EP_OEMGetInfo,
    EP_OEMDevMode,
    EP_OEMCommonUIProp,
    EP_OEMDocumentPropertySheets,
    EP_OEMDevicePropertySheets,
    EP_OEMDevQueryPrintEx,
    EP_OEMDeviceCapabilities,
    EP_OEMUpgradePrinter,
    EP_OEMPrinterEvent,
    EP_OEMQueryColorProfile,
    EP_OEMUpgradeRegistry,
    EP_OEMFontInstallerDlgProc,
    EP_OEMUpdateExternalFonts,
    EP_OEMDriverEvent,

    MAX_OEMENTRIES
};

#ifdef DEFINE_OEMPROC_NAMES

static CONST PSTR OEMProcNames[MAX_OEMENTRIES] = {
    "OEMGetInfo",
    "OEMDevMode",
    "OEMCommonUIProp",
    "OEMDocumentPropertySheets",
    "OEMDevicePropertySheets",
    "OEMDevQueryPrintEx",
    "OEMDeviceCapabilities",
    "OEMUpgradePrinter",
    "OEMPrinterEvent",
    "OEMQueryColorProfile",
    "OEMUpgradeRegistry",
    "OEMFontInstallerDlgProc",
    "OEMUpdateExternalFonts",
    "OEMDriverEvent",
};

#endif // DEFINE_OEMPROC_NAMES

#endif // !KERNEL_MODE


//
// Data structure containing information about each OEM plugin
//

typedef LONG (APIENTRY *OEMPROC)();

// Constant flag bits for OEM_PLUGIN_ENTRY.dwFlags field

#define OEMENABLEDRIVER_CALLED  0x0001
#define OEMENABLEPDEV_CALLED    0x0002
#define OEMDEVMODE_CALLED       0x0004
#define OEMWRITEPRINTER_HOOKED  0x0008
#define OEMNOT_UNLOAD_PLUGIN     0x0010 //If set, the plugin dll will not be unloaded

#define MAX_OEM_PLUGINS 8

typedef struct _OEM_PLUGIN_ENTRY {

    //
    // Filenames are fully qualified, NULL means not present
    //

    PTSTR       ptstrDriverFile;    // KM module filename
    PTSTR       ptstrConfigFile;    // UM module filename
    PTSTR       ptstrHelpFile;      // help filename
    DWORD       dwSignature;        // unique OEM signature
    HANDLE      hInstance;          // handle to loaded KM or UM module
    PVOID       pParam;             // extra pointer parameter for KM or UM module
    DWORD       dwFlags;            // misc. flag bits
    PVOID       pOEMDM;             // pointer to OEM private devmode
    DWORD       dwOEMDMSize;        // size of OEM private devmode

    //
    // OEM interface information
    //

    PVOID       pIntfOem;           // pointer to OEM plugin's interface
    GUID        iidIntfOem;         // OEM plugin's interface ID

    //
    // Pointers to various plugin entrypoints, NULL means not present.
    // Note that the set of entrypoints diff for KM and UM module.
    //

    BYTE       aubProcFlags[(MAX_OEMENTRIES + 7) / 8];
    OEMPROC    oemprocs[MAX_OEMENTRIES];

} OEM_PLUGIN_ENTRY, *POEM_PLUGIN_ENTRY;

//
// Information about all plugins assocaited with a driver
//

#define OEM_HAS_PUBLISHER_INFO          0x00000001

typedef struct _OEM_PLUGINS {

    PVOID               pdriverobj;     // reference pointer to driver data structure
    DWORD               dwCount;        // number of plugins
    DWORD               dwFlags;        // misc flags
    PUBLISHERINFO       PublisherInfo;  // info about publisher printing
    OEM_PLUGIN_ENTRY    aPlugins[1];    // information about each plugin

} OEM_PLUGINS, *POEM_PLUGINS;

//
// Get OEM plugin interface and publish driver helper interface
//

BOOL
BGetOemInterface(
    POEM_PLUGIN_ENTRY  pOemEntry
    );

//
// Retrieve the latest interface supported by OEM plugin
//

BOOL
BQILatestOemInterface(
    IN HANDLE       hInstance,
    IN REFCLSID     rclsid,
    IN const GUID   *PrintOem_IIDs[],
    OUT PVOID       *ppIntfOem,
    OUT GUID        *piidIntfOem
    );

//
// Release OEM interface
//

ULONG
ReleaseOemInterface(
    POEM_PLUGIN_ENTRY  pOemEntry
    );

//
// Free OEM component
//

VOID
Driver_CoFreeOEMLibrary(
    IN HANDLE       hInstance
    );

HRESULT
HComOEMGetInfo(
    POEM_PLUGIN_ENTRY     pOemEntry,
    DWORD                 dwMode,
    PVOID                 pBuffer,
    DWORD                 cbSize,
    PDWORD                pcbNeeded
    );

HRESULT
HComOEMDevMode(
    POEM_PLUGIN_ENTRY     pOemEntry,
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam
    );

#if defined(KERNEL_MODE) && defined(WINNT_40)

typedef struct _OEM_PLUGIN_REFCOUNT {

    DWORD                         dwRefCount;        // ref count for the OEM render plugin DLL
    PTSTR                         ptstrDriverFile;   // OEM render plugin DLL name
    struct _OEM_PLUGIN_REFCOUNT   *pNext;            // next ref count node

} OEM_PLUGIN_REFCOUNT, *POEM_PLUGIN_REFCOUNT;

BOOL
BOEMPluginFirstLoad(
    IN PTSTR                      ptstrDriverFile,
    IN OUT POEM_PLUGIN_REFCOUNT   *ppOEMPluginRefCount
    );

BOOL
BOEMPluginLastUnload(
    IN PTSTR                      ptstrDriverFile,
    IN OUT POEM_PLUGIN_REFCOUNT   *ppOEMPluginRefCount
    );

VOID
VFreePluginRefCountList(
    IN OUT POEM_PLUGIN_REFCOUNT   *ppOEMPluginRefCount
    );

BOOL
BHandleOEMInitialize(
    POEM_PLUGIN_ENTRY   pOemEntry,
    ULONG               ulReason
    );

#endif  // KERNEL_MODE && WINNT_40

//
// In kernel mode, only OEM rendering module is used.
// In user mode, only OEM UI module is loaded.
//

#ifdef  KERNEL_MODE

#define CURRENT_OEM_MODULE_NAME(pOemEntry) (pOemEntry)->ptstrDriverFile

HRESULT
HComOEMEnableDriver(
    POEM_PLUGIN_ENTRY     pOemEntry,
    DWORD                 DriverVersion,
    DWORD                 cbSize,
    PDRVENABLEDATA  pded
    );

HRESULT
HComOEMEnablePDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    PWSTR                 pPrinterName,
    ULONG                 cPatterns,
    HSURF                *phsurfPatterns,
    ULONG                 cjGdiInfo,
    GDIINFO              *pGdiInfo,
    ULONG                 cjDevInfo,
    DEVINFO              *pDevInfo,
    DRVENABLEDATA        *pded,
    OUT PDEVOEM          *pDevOem
    );

HRESULT
HComOEMResetPDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobjOld,
    PDEVOBJ               pdevobjNew
    );

HRESULT
HComOEMDisablePDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj
    );

HRESULT
HComOEMDisableDriver(
    POEM_PLUGIN_ENTRY     pOemEntry
    );

HRESULT
HComOEMCommand(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    DWORD                 dwIndex,
    PVOID                 pData,
    DWORD                 cbSize,
    OUT DWORD             *pdwResult
    );

HRESULT
HComOEMWritePrinter(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    PVOID                 pBuf,
    DWORD                 cbBuffer,
    OUT PDWORD            pcbWritten
    );

HRESULT
HComOEMGetPDEVAdjustment(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    DWORD                 dwAdjustType,
    PVOID                 pBuf,
    DWORD                 cbBuffer,
    OUT BOOL              *pbAdjustmentDone);

#else   // !KERNEL_MODE

#define CURRENT_OEM_MODULE_NAME(pOemEntry) (pOemEntry)->ptstrConfigFile


HRESULT
HComOEMCommonUIProp(
    POEM_PLUGIN_ENTRY   pOemEntry,
    DWORD               dwMode,
    POEMCUIPPARAM       pOemCUIPParam
    );

HRESULT
HComOEMDocumentPropertySheets(
    POEM_PLUGIN_ENTRY   pOemEntry,
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM             lParam
    );

HRESULT
HComOEMDevicePropertySheets(
    POEM_PLUGIN_ENTRY   pOemEntry,
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM             lParam
    );

HRESULT
HComOEMDevQueryPrintEx(
    POEM_PLUGIN_ENTRY    pOemEntry,
    POEMUIOBJ            poemuiobj,
    PDEVQUERYPRINT_INFO  pDQPInfo,
    PDEVMODE             pPublicDM,
    PVOID                pOEMDM
    );

HRESULT
HComOEMDeviceCapabilities(
    POEM_PLUGIN_ENTRY    pOemEntry,
    POEMUIOBJ            poemuiobj,
    HANDLE               hPrinter,
    PWSTR                pDeviceName,
    WORD                 wCapability,
    PVOID                pOutput,
    PDEVMODE             pPublicDM,
    PVOID                pOEMDM,
    DWORD                dwOld,
    DWORD                *pdwResult
    );

HRESULT
HComOEMUpgradePrinter(
    POEM_PLUGIN_ENTRY    pOemEntry,
    DWORD                dwLevel,
    PBYTE                pDriverUpgradeInfo
    );

HRESULT
HComOEMPrinterEvent(
    POEM_PLUGIN_ENTRY   pOemEntry,
    PWSTR               pPrinterName,
    INT                 iDriverEvent,
    DWORD               dwFlags,
    LPARAM              lParam
    );

HRESULT
HComOEMDriverEvent(
    POEM_PLUGIN_ENTRY   pOemEntry,
    DWORD               dwDriverEvent,
    DWORD               dwLevel,
    LPBYTE              pDriverInfo,
    LPARAM              lParam
    );


HRESULT
HComOEMQUeryColorProfile(
    POEM_PLUGIN_ENTRY  pOemEntry,
    HANDLE             hPrinter,
    POEMUIOBJ          poemuiobj,
    PDEVMODE           pPublicDM,
    PVOID              pOEMDM,
    ULONG              ulQueryMode,
    VOID               *pvProfileData,
    ULONG              *pcbProfileData,
    FLONG              *pflProfileData
    );



HRESULT
HComOEMFontInstallerDlgProc(
    POEM_PLUGIN_ENTRY   pOemEntry,
    HWND                hWnd,
    UINT                usMsg,
    WPARAM              wParam,
    LPARAM              lParam
    );


HRESULT
HComOEMUpdateExternalFonts(
    POEM_PLUGIN_ENTRY   pOemEntry,
    HANDLE  hPrinter,
    HANDLE  hHeap,
    PWSTR   pwstrCartridges
    );

HRESULT
HComOEMQueryJobAttributes(
    POEM_PLUGIN_ENTRY   pOemEntry,
    HANDLE      hPrinter,
    PDEVMODE    pDevMode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo
    );

HRESULT
HComOEMHideStandardUI(
    POEM_PLUGIN_ENTRY   pOemEntry,
    DWORD   dwMode
    );

HRESULT
HComOEMDocumentEvent(
    POEM_PLUGIN_ENTRY   pOemEntry,
    HANDLE   hPrinter,
    HDC      hdc,
    INT      iEsc,
    ULONG    cbIn,
    PVOID    pbIn,
    ULONG    cbOut,
    PVOID    pbOut,
    PINT     piResult
    );

#endif  // KERNEL_MODE

//
// Get information about OEM plugins for a printer
//

POEM_PLUGINS
PGetOemPluginInfo(
    HANDLE  hPrinter,
    LPCTSTR pctstrDriverPath,
    PDRIVER_INFO_3  pDriverInfo3
    );

//
// Load OEM plugins modules into memory
//

BOOL
BLoadOEMPluginModules(
    POEM_PLUGINS    pOemPlugins
    );


//
// Dispose of information about OEM plugins and
// unload OEM plugin modules if necessary
//

VOID
VFreeOemPluginInfo(
    POEM_PLUGINS    pOemPlugins
    );

//
// Macro to detect if OEM is using COM interface.
//
// Only exists for user mode drivers.
//


#define HAS_COM_INTERFACE(pOemEntry) \
        ((pOemEntry)->pIntfOem != NULL)

//
// Get the address for the specified OEM entrypoint.
//
// NOTE!!! You should always use the macro version
// instead of calling the function directly.
//

#define GET_OEM_ENTRYPOINT(pOemEntry, ep) (PFN_##ep) \
        (BITTST((pOemEntry)->aubProcFlags, EP_##ep) ? \
            (pOemEntry)->oemprocs[EP_##ep] : \
            PGetOemEntrypointAddress(pOemEntry, EP_##ep))


OEMPROC
PGetOemEntrypointAddress(
    POEM_PLUGIN_ENTRY   pOemEntry,
    DWORD               dwIndex
    );

//
// Find the OEM plugin entry having the specified signature
//

POEM_PLUGIN_ENTRY
PFindOemPluginWithSignature(
    POEM_PLUGINS pOemPlugins,
    DWORD        dwSignature
    );

//
// Calculate the total private devmode size for all OEM plugins
//

BOOL
BCalcTotalOEMDMSize(
    HANDLE       hPrinter,
    POEM_PLUGINS pOemPlugins,
    PDWORD       pdwOemDMSize
    );

//
// Initialize OEM plugin default devmodes
//

BOOL
BInitOemPluginDefaultDevmode(
    IN HANDLE               hPrinter,
    IN PDEVMODE             pPublicDM,
    OUT POEM_DMEXTRAHEADER  pOemDM,
    IN OUT POEM_PLUGINS     pOemPlugins
    );

//
// Validate and merge OEM plugin private devmode fields
//

BOOL
BValidateAndMergeOemPluginDevmode(
    IN HANDLE               hPrinter,
    OUT PDEVMODE            pPublicDMOut,
    IN PDEVMODE             pPublicDMIn,
    OUT POEM_DMEXTRAHEADER  pOemDMOut,
    IN POEM_DMEXTRAHEADER   pOemDMIn,
    IN OUT POEM_PLUGINS     pOemPlugins
    );

//
// This function scans through the OEM plugin devmodes block and
// verifies if every plugin devmode in that block is constructed correctly.
//
BOOL
bIsValidPluginDevmodes(
    IN POEM_DMEXTRAHEADER   pOemDM,
    IN LONG                 cbOemDMSize
    );

//
// Convert OEM plugin default devmodes to current version
//

BOOL
BConvertOemPluginDevmode(
    IN HANDLE               hPrinter,
    OUT PDEVMODE            pPublicDMOut,
    IN PDEVMODE             pPublicDMIn,
    OUT POEM_DMEXTRAHEADER  pOemDMOut,
    IN POEM_DMEXTRAHEADER   pOemDMIn,
    IN LONG                 cbOemDMInSize,
    IN POEM_PLUGINS         pOemPlugins
    );

//
// Function called by OEM plugins to access driver private devmode settings
//

BOOL
BGetDevmodeSettingForOEM(
    IN  PDEVMODE    pdm,
    IN  DWORD       dwIndex,
    OUT PVOID       pOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    );

//
// Function called by OEM plugins to access driver settings in registry
//

BOOL
BGetPrinterDataSettingForOEM(
    IN  PRINTERDATA *pPrinterData,
    IN  DWORD       dwIndex,
    OUT PVOID       pOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    );

//
// Function called by OEM plugins to find out the currently selected
// option(s) for the specified feature
//

BOOL
BGetGenericOptionSettingForOEM(
    IN  PUIINFO     pUIInfo,
    IN  POPTSELECT  pOptionsArray,
    IN  PCSTR       pstrFeatureName,
    OUT PSTR        pstrOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded,
    OUT PDWORD      pdwOptionsReturned
    );

#ifdef __cplusplus
}
#endif

#endif  // !_OEMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\parser.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    parser.h

Abstract:

    Common header file for both PPD and GPD parsers

Revision History:

    12/03/96 -davidx-
        Check binary file date against all included source files.

    10/14/96 -davidx-
        Add new interface function MapToDeviceOptIndex.

    10/11/96 -davidx-
        Make CustomPageSize feature an option of PageSize.

    09/25/96 -davidx-
        New helper function CheckFeatureOptionConflict.
        Overlow iMode parameter to ResolveUIConflicts.

    08/30/96 -davidx-
        Coding style changes after code review.

    8/15/96 -davidx-
        Define common parser interfaces.

    7/22/96 -amandan-
        Modified it to include shared binary data structs and UI requirements

    4/18/95 -davidx-
        Created it.

--*/


#ifndef _PARSER_H_
#define _PARSER_H_

//
// Parser version number is a DWORD. High-order WORD is the version number shared
// by PPD and GPD parsers. Low-order WORD is the private version number specific
// to PPD or GPD parser.
//
// When you make a change that affects both parsers, increment the shared parser
// version number below. If your change only affects one of the parsers, then
// increment the private parser version number in ppd.h or parsers\gpd\gpdparse.h.
//  also increment the shared version whenever a new OS version is released
//  for example Whistler or Blackcomb.
//

#define SHARED_PARSER_VERSION 0x0010

//
// Printer feature selection information is stored in an array of OPTSELECT structures
// (in DEVMODE as well as printer-sticky data in registry). Maximum number of entries
// in the array is limited to MAX_PRINTER_OPTIONS. The parsers should make sure the
// total number of printer features doesn't exceed this number.
//
// To accommodate PickMany printer features, the selected options for each feature form
// a linked list. The selection list for printer feature N starts at the N'th element
// of the array.
//
// For the last OPTSELECT structure in a list, ubNext field will be 0.
//
// If the option index in an OPTSELECT structure is 0xff, it means no option is
// selected for the corresponding feature.
//

#define MAX_PRINTER_OPTIONS     256
#define MAX_COMBINED_OPTIONS    (MAX_PRINTER_OPTIONS * 2)
#define OPTION_INDEX_ANY        0xff
#define GET_RESOURCE_FROM_DLL   0x80000000
#define USE_SYSTEM_NAME         0xFFFFFFFF
#define KEYWORD_SIZE_EXTRA      32

#define RESERVED_STRINGID_START 10000
#define RESERVED_STRINGID_END   20000


typedef DWORD LISTINDEX;


typedef enum _QUALITYSETTING {
    QS_BEST,
    QS_BETTER,
    QS_DRAFT,

} QUALITYSETTING;


typedef struct _OPTSELECT {

    BYTE    ubCurOptIndex;  // option index for the current selection
    BYTE    ubNext;         // link pointer to the next selection

} OPTSELECT, *POPTSELECT;

#define NULL_OPTSELECT  0

//
// Macro for converting byte offsets to pointers.
// NOTE: If the byte offset is zero, the resulting pointer is NULL.
//

#define OFFSET_TO_POINTER(pStart, offset) \
        ((PVOID) ((offset) ? (PBYTE) (pStart) + (offset) : NULL))

#define POINTER_TO_OFFSET(pStart, pEnd) \
        ( ((pEnd) ? (PVOID)((PBYTE) (pEnd) - (PBYTE)(pStart)) : NULL) )
//
// Macro for getting the quality value, be it the resolution or the negative
// quality value
//

#define GETQUALITY_X(pRes) \
    (((INT)pRes->dwResolutionID >= DMRES_HIGH  &&  (INT)pRes->dwResolutionID <= DMRES_DRAFT) ? (INT)pRes->dwResolutionID : pRes->iXdpi)

#define GETQUALITY_Y(pRes) \
    (((INT)pRes->dwResolutionID >= DMRES_HIGH  &&  (INT)pRes->dwResolutionID <= DMRES_DRAFT) ? (INT)pRes->dwResolutionID : pRes->iYdpi)


//
// Pointers in the binary data are represented as byte offsets to the beginning
// of the binary data.
//

typedef DWORD   PTRREF;

//
// Resource reference type:
//  If the most significant bit is on, then it's a resource ID (without MSB)
//  otherwise, it's an offset from the beginning of the binary data
//

typedef DWORD   RESREF;

//
// Data structure used to represent the format of loOffset when indicating resource Ids
//

typedef  struct
{
    WORD    wResourceID ;   // ResourceID
    BYTE    bFeatureID ;    // Feature index for the resource DLL feature.
                            // If zero, we will use the name specified
                            // in ResourceDLL
    BYTE    bOptionID ;     // Option index for the qualified resource dll name.
}  QUALNAMEEX, * PQUALNAMEEX  ;


//
// Data structure used to represent an array in the binary data
// It's also used to represent an invocation string in the binary data
//
// Note (Unidrv only): for all arrayrefs containing Strings the dwCount field
// holds the number of bytes which the string contains. For Unicode strings
// this is TWICE the number of Unicode characters.
//

typedef struct _ARRAYREF {

    DWORD       dwCount;        // number of elements in the array,
                                // If using it as an INVOCATION, dwCount is
                                // the number of bytes in the invocation string
    PTRREF      loOffset;       // byte-offset to the beginning of the array

} ARRAYREF, *PARRAYREF, INVOCATION, *PINVOCATION;

//
// Data structure used to represent a job patch file in the binary data
//

typedef struct _JOBPATCHFILE {

    DWORD       dwCount;        // number of bytes in the patch string
    PTRREF      loOffset;       // byte-offset to the beginning of the string
    LONG        lJobPatchNo;    // number of the patch file as specified in the PPD-file

} JOBPATCHFILE, *PJOBPATCHFILE;

//
// Data structure used to represent a conflict feature/option pair:
//  nFeatureIndex1/nOptionIndex1 specifies the higher priority feature/option pair
//  nFeatureIndex2/nOptionIndex2 specifies the lower priority feature/option pair
//

typedef struct _CONFLICTPAIR {

    DWORD       dwFeatureIndex1;
    DWORD       dwOptionIndex1;
    DWORD       dwFeatureIndex2;
    DWORD       dwOptionIndex2;

} CONFLICTPAIR, *PCONFLICTPAIR;

//
// Raw binary printer description data
//

typedef struct _RAWBINARYDATA {

    DWORD           dwFileSize;                 // size of binary data file
    DWORD           dwParserSignature;          // parser signature
    DWORD           dwParserVersion;            // parser version number
    DWORD           dwChecksum32;               // 32-bit CRC checksum of Feature/Option keywords
    DWORD           dwSrcFileChecksum32;    // 32-bit CRC checksum of printer description file
    DWORD           dwDocumentFeatures;         // number of doc-sticky features
    DWORD           dwPrinterFeatures;          // number of printer-sticky features
    ARRAYREF        FileDateInfo;               // date info about printer description files

    //
    // These fields are only filled out and used during runtime.
    // They should be zeroed out inside the binary data file.
    //

    PVOID           pvReserved;                 // reserved, must be NULL for now
    PVOID           pvPrivateData;              // private data for parser use

} RAWBINARYDATA, *PRAWBINARYDATA;

//
// Data structure for RAWBINARYDATA.FileDateInfo:
//  dwCount - number of source printer description files
//  loOffset - offset to an array of FILEDATEINFO structures, one per file
//      FILEDATEINFO.loFileName - offset to the filename (Unicode full pathname)
//      FILEDATEINFO.FileTime - timestamp on the file
//

typedef struct _FILEDATEINFO {

    PTRREF          loFileName;
    FILETIME        FileTime;

} FILEDATEINFO, *PFILEDATEINFO;


//
// Instances of binary printer description data
//

typedef struct  _INFOHEADER {

    RAWBINARYDATA   RawData;                    // raw binary data header
    PTRREF          loUIInfoOffset;             // byte-offset to common UIINFO structure
    PTRREF          loDriverOffset;             // byte-offset to unique driver infoformation

} INFOHEADER, *PINFOHEADER;

//
// Parser signatures for INFOHEADER.dwParserSignature field
//

#define PPD_PARSER_SIGNATURE    'PPD '
#define GPD_PARSER_SIGNATURE    'GPD '

//
// Given a pointer to INFOHEADER, return a pointer to UIINFO or driver info structure
//

#define GET_UIINFO_FROM_INFOHEADER(pInfoHdr) \
        ((PUIINFO) OFFSET_TO_POINTER(pInfoHdr, (pInfoHdr)->loUIInfoOffset))

#define GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr) \
        OFFSET_TO_POINTER(pInfoHdr, (pInfoHdr)->loDriverOffset)

//
// IDs used to reference the predefined printer features
//

#define GID_RESOLUTION      0
#define GID_PAGESIZE        1
#define GID_PAGEREGION      2
#define GID_DUPLEX          3
#define GID_INPUTSLOT       4
#define GID_MEDIATYPE       5
#define GID_MEMOPTION       6
#define GID_COLORMODE       7
#define GID_ORIENTATION     8
#define GID_PAGEPROTECTION  9
#define GID_COLLATE         10
#define GID_OUTPUTBIN       11
#define GID_HALFTONING      12
#define GID_LEADINGEDGE     13
#define GID_USEHWMARGINS    14
#define MAX_GID             15
#define GID_UNKNOWN         0xffff

//
// Common information provided by both GPD and PPD parsers and
// used by the user-interface DLL.
//

typedef struct _UIINFO {

    DWORD           dwSize;                     // size of this structure
    PTRREF          loResourceName;             // name of the resource DLL
    PTRREF          loPersonality ;         //  printer's PDL language
    PTRREF          loNickName;                 // printer model name
    DWORD           dwSpecVersion;              // printer description file format version
    DWORD           dwTechnology;               // see TECHNOLOGY enumeration
    DWORD           dwDocumentFeatures;         // number of doc-sticky features
    DWORD           dwPrinterFeatures;          // number of printer-sticky features
    PTRREF          loFeatureList;              // byte-offset to array of FEATUREs
    RESREF          loFontSubstTable;           // default font substitution table - these fields
    DWORD           dwFontSubCount;             // have different meanings for PPD and GPD parsers
    ARRAYREF        UIConstraints;              // array of UICONSTRAINTs
    ARRAYREF        UIGroups;                   // array of UIGROUPs
    DWORD           dwMaxCopies;                // maximum copies allowed
    DWORD           dwMinScale;                 // mimimum scale factor (percent)
    DWORD           dwMaxScale;                 // maximum scale factor (percent)
    DWORD           dwLangEncoding;             // translation string language encoding
    DWORD           dwLangLevel;                // page description langauge level
    INVOCATION      Password;                   // password invocation string
    INVOCATION      ExitServer;                 // exitserver invocation string
    DWORD           dwProtocols;                // supported comm protocols
    DWORD           dwJobTimeout;               // default job timeout value
    DWORD           dwWaitTimeout;              // default wait timeout value
    DWORD           dwTTRasterizer;             // TrueType rasterizer option
    DWORD           dwFreeMem;                  // free memory - global default
    DWORD           dwPrintRate;                // print speed
    DWORD           dwPrintRateUnit;            // print speed unit
    DWORD           dwPrintRatePPM;                // print speed in PPM equivalents
    FIX_24_8        fxScreenAngle;              // screen angle - global default
    FIX_24_8        fxScreenFreq;               // screen angle - global default
    DWORD           dwFlags;                    // misc. flag bits
    DWORD           dwCustomSizeOptIndex;       // custom size option index if supported
    RESREF          loPrinterIcon;              // MUST BE ID, not OFFSET.  Icon ID for printer
                                                // MUST BE LESS than IDI_CPSUI_ICONID_FIRST
    DWORD           dwCartridgeSlotCount;       // number of font cartridge slot
    ARRAYREF        CartridgeSlot;              // array of font cartridges names
    PTRREF          loFontInstallerName;        //
    PTRREF          loHelpFileName;             // name of custom help file, if 0 -> no custom help
    POINT           ptMasterUnits;              // master units per inch
    BOOL            bChangeColorModeOnDoc ;     //  is driver allowed to switch colormodes on a per page
                                                //  basis - within a single document , but not within a page?
                                                //  Don't confuse with bChangeColorModeOnPage  which is stored
                                                //  in bChangeColorMode in GLOBALS.


     //  these fields hold settings for driver to assume whenever
     //  the user presses the associated button.
    LISTINDEX       liDraftQualitySettings;      // "DraftQualitySettings"
    LISTINDEX       liBetterQualitySettings;     // "BetterQualitySettings"
    LISTINDEX       liBestQualitySettings;       // "BestQualitySettings"
    QUALITYSETTING  defaultQuality ;             //  "DefaultQuality"



    //
    // Byte-offsets to predefined printer features.
    // If a predefined printer feature is not supported, its
    // corresponding entry in the array should be 0.
    //

    PTRREF          aloPredefinedFeatures[MAX_GID];
    DWORD           dwMaxDocKeywordSize;
    DWORD           dwMaxPrnKeywordSize;
    DWORD           dwReserved[6];

    //
    // Pointer to the beginning of resource data. This is only used during runtime
    // and should be set to 0 inside the binary data file.
    //

    PBYTE           pubResourceData;

    //
    // Pointer back to the INFOHEADER structure for convenience.
    // This is only used during runtime and should be set to 0
    // inside the binary data file.
    //

    PINFOHEADER     pInfoHeader;

} UIINFO, *PUIINFO;

//
// Given a pointer to a UIINFO structure and a predefined feature ID,
// return a pointer to the FEATURE structure corresponding to the specified
// feature. If the specified feature is not supported on the printer,
// a NULL is returned.
//

#define GET_PREDEFINED_FEATURE(pUIInfo, gid) \
        OFFSET_TO_POINTER((pUIInfo)->pInfoHeader, (pUIInfo)->aloPredefinedFeatures[gid])

//
// Given a pointer to UIINFO structure and a pointer to a FEATURE,
// return the feature index of the specified feature.
//

#define GET_INDEX_FROM_FEATURE(pUIInfo, pFeature) \
        ((DWORD)((((PBYTE) (pFeature) - (PBYTE) (pUIInfo)->pInfoHeader) - \
          (pUIInfo)->loFeatureList) \
         / sizeof(FEATURE)))

//
// Bit constants for UIINFO.dwFlags field
//

#define FLAG_RULESABLE          0x00000001
#define FLAG_FONT_DOWNLOADABLE  0x00000002
#define FLAG_ROTATE90           0x00000004
#define FLAG_COLOR_DEVICE       0x00000008
#define FLAG_ORIENT_SUPPORT     0x00000010
#define FLAG_CUSTOMSIZE_SUPPORT 0x00000020
#define FLAG_FONT_DEVICE        0x00000040
#define FLAG_STAPLE_SUPPORT     0x00000080
#define FLAG_REVERSE_PRINT      0x00000100
#define FLAG_LETTER_SIZE_EXISTS 0x00000200
#define FLAG_A4_SIZE_EXISTS     0x00000400
#define FLAG_ADD_EURO           0x00000800
#define FLAG_TRUE_GRAY          0x00001000
#define FLAG_REVERSE_BAND_ORDER 0x00002000


//
// Macros for checking various flags bit in UIINFO.dwFlags
//

#define IS_COLOR_DEVICE(pUIInfo)    ((pUIInfo)->dwFlags & FLAG_COLOR_DEVICE)
#define SUPPORT_CUSTOMSIZE(pUIInfo) ((pUIInfo)->dwFlags & FLAG_CUSTOMSIZE_SUPPORT)


//
// Conversion from master units to microns:
//  N = master units to be converted
//  u = number of master units per inch
//

#define MICRONS_PER_INCH            25400
#define MASTER_UNIT_TO_MICRON(N, u) MulDiv(N, MICRONS_PER_INCH, u)

//
// Bit constants for UIINFO.dwProtocols field
//

#define PROTOCOL_ASCII          0x0000
#define PROTOCOL_PJL            0x0001
#define PROTOCOL_BCP            0x0002
#define PROTOCOL_TBCP           0x0004
#define PROTOCOL_SIC            0x0008
#define PROTOCOL_BINARY         0x0010

//
// Constants for UIINFO.dwTTRasterizer field
//

#define TTRAS_NONE              0
#define TTRAS_ACCEPT68K         1
#define TTRAS_TYPE42            2
#define TTRAS_TRUEIMAGE         3

//
// Constants for UIINFO.dwLangEncoding field
//

#define LANGENC_NONE            0
#define LANGENC_ISOLATIN1       1
#define LANGENC_UNICODE         2
#define LANGENC_JIS83_RKSJ      3

//
// Data structure used to represent a constrained feature/option
// For each feature and option, there is a linked-list of feature/options
// that are constrained by this feature or option.
//

typedef struct _UICONSTRAINT {

    DWORD       dwNextConstraint;   // link pointer to the next constraint
    DWORD       dwFeatureIndex;     // index of the constrained feature
    DWORD       dwOptionIndex;      // index of the constrained option or OPTION_INDEX_ANY

} UICONSTRAINT , *PUICONSTRAINT;

//
// Link pointer constant to indicate the end of the constraint list
//

#define NULL_CONSTRAINT 0xffffffff


//
// Data structure used to represent invalid feature/option combinations
//  the prefix tag shall be 'invc'
//  Note:  both dwNextElement and dwNewCombo are terminated by END_OF_LIST.
//


typedef  struct
{
    DWORD   dwFeature ;     //  the INVALIDCOMBO construct defines
    DWORD   dwOption ;      //  a set of elements subject to the constraint
    DWORD   dwNextElement ;  // that all elements of the set  cannot be
    DWORD   dwNewCombo ;     // selected at the same time.
}
INVALIDCOMBO , * PINVALIDCOMBO ;


//
// Data structure used to combine printer features into groups and subgroups
//

typedef struct _UIGROUP {

    PTRREF          loKeywordName;          // group keyword name
    RESREF          loDisplayName;          // display name
    DWORD           dwFlags;                // flag bits
    DWORD           dwNextGroup;            // index of the next group
    DWORD           dwFirstSubGroup;        // index of the first subgroup
    DWORD           dwParentGroup;          // index of the parent group
    DWORD           dwFirstFeatureIndex;    // index of the first feature belonging to the group
    DWORD           dwFeatures;             // number of features belonging to the group

} UIGROUP, *PUIGROUP;

//
// Data structure used to present a printer feature
//

typedef struct _FEATURE {

    PTRREF          loKeywordName;              // feature keyword name
    RESREF          loDisplayName;              // display name
    DWORD           dwFlags;                    // flag bits
    DWORD           dwDefaultOptIndex;          // default option index
    DWORD           dwNoneFalseOptIndex;        // None or False option index
    DWORD           dwFeatureID;                // predefined feature ID
    DWORD           dwUIType;                   // UI type
    DWORD           dwUIConstraintList;         // index to the list of UIConstraints
    DWORD           dwPriority;                 // priority used during conflict resolution
    DWORD           dwFeatureType;              // Type of feature, see FEATURETYPE defines
    DWORD           dwOptionSize;               // size of each option structure
    ARRAYREF        Options;                    // array of option structures
    INVOCATION      QueryInvocation;            // query invocation string
    DWORD           dwFirstOrderIndex;          // Bidi
    DWORD           dwEnumID;                   // Bidi
    DWORD           dwEnumFormat;               // Bidi
    DWORD           dwCurrentID;                // Bidi
    DWORD           dwCurrentFormat;            // Bidi
    RESREF          loResourceIcon;             //
    RESREF          loHelpString;               //
    RESREF          loPromptMessage;            //
    INT             iHelpIndex;                 // Help Index for this feature, 0 for none
//    BOOL        bConcealFromUI ;        // don't display this feature in the UI.

} FEATURE, *PFEATURE;

//
// Constants for FEATURE.uiType field - types of feature option list
//

#define UITYPE_PICKONE      0
#define UITYPE_PICKMANY     1
#define UITYPE_BOOLEAN      2

//
// Defines for FEATURE.dwFeatureType
//
#define FEATURETYPE_DOCPROPERTY         0
#define FEATURETYPE_JOBPROPERTY         1
#define FEATURETYPE_PRINTERPROPERTY     2

//
// Bit constants for FEATURE.dwFlags field
//

#define FEATURE_FLAG_NOUI           0x0001      // don't display in the UI
#define FEATURE_FLAG_NOINVOCATION   0x0002      // don't emit invocation string
#define FEATURE_FLAG_UPDATESNAPSHOT           0x0004      //  Update the snapshot
        // whenever an option change has occurred for this feature.

//
// Constant to indicate that the help index is not available
//

#define HELP_INDEX_NONE     0

//
// Data structure used to represent a printer feature option
//

typedef struct _OPTION {

    PTRREF          loKeywordName;              // option keyword name
    RESREF          loDisplayName;              // display name
    union
    {
        INVOCATION      Invocation;                 // invocation string
        DWORD       dwCmdIndex ;                    // for Unidrv the index into the CommandArray.
    }   ;
    DWORD           dwUIConstraintList;         // index to the list of UIConstraints
    RESREF          loResourceIcon;             //
    RESREF          loHelpString;               //
    RESREF          loPromptMessage;            //
    DWORD           dwPromptTime;
    PTRREF          loRenderOffset;             //
    INT             iHelpIndex;                 // Help Index for this option, 0 for none
    LISTINDEX       liDisabledFeatures;         // *DisabledFeatures

} OPTION, *POPTION;

//
// Data structures used to represent PageProtect feature option
//
typedef struct _PAGEPROTECT {
    OPTION  GenericOption;
    DWORD   dwPageProtectID;    // id values are defined in gpd.h (PAGEPRO)
} PAGEPROTECT, *PPAGEPROTECT;

//
// Data structures used to represent Collation feature option
//

typedef struct _COLLATE {

    OPTION      GenericOption;                  // generic option information
    DWORD       dwCollateID;                    // DEVMODE.dmMediaType index

} COLLATE, *PCOLLATE;

//
// Data structure used to represent Resolution feature options
//

typedef struct _RESOLUTION {

    OPTION      GenericOption;                  // generic option information
    INT         iXdpi;                          // horizontal resolution in dpi
    INT         iYdpi;                          // vertical resolution
    FIX_24_8    fxScreenAngle;                  // default screen angle and frequency
    FIX_24_8    fxScreenFreq;                   //  for this particular resolution
    DWORD       dwResolutionID;                    // DEVMODE.dmPrintQuality index
                                                                    //  set to RES_ID_IGNORE  if not explicitly set in GPD.
                                                                    //  only values between DMRES_DRAFT and DMRES_HIGH  are valid.

} RESOLUTION , *PRESOLUTION;


#define      RES_ID_IGNORE  (DWORD)(-5L)

//
// Data structure used to represent ColorMode feature options
// Note: Extra fields in COLORMODE structure has been moved to
// a GPD parser private data structure. We should probably
// remove this definition here.
//

typedef struct _COLORMODE {

    OPTION      GenericOption;                  // generic option information

} COLORMODE, *PCOLORMODE;

//
// Data structure used to represent Halftoning feature options
//

typedef struct _HALFTONING {

    OPTION      GenericOption;                  // generic option information
    DWORD       dwHTID;                   //  Halftone pattern ID
    DWORD       dwRCpatternID ;         // resource ID of custom halftone pattern
    POINT       HalftonePatternSize;            // Halftone pattern size
    INT         iLuminance;                      // Luminance
    DWORD       dwHTNumPatterns;                   //  number of patterns (if different
                                                    //  patterns are used for each color plane
    DWORD       dwHTCallbackID;                   //  ID of pattern generation/decryption
                                                    //  function

} HALFTONING, *PHALFTONING;

//
// Data structure used to represent Duplex feature options
//

typedef struct _DUPLEX {

    OPTION      GenericOption;                  // generic option information
    DWORD       dwDuplexID;                     // DEVMODE.dmDuplex index

} DUPLEX, *PDUPLEX;

//
// Data structure used to represent Orientation feature options (GPD only)
//

typedef struct _ORIENTATION {

    OPTION      GenericOption;
    DWORD       dwRotationAngle;                // Should be one of the following
                                                // enumeration:
                                                // ROTATE_NONE, ROTATE_90, ROTATE_270
} ORIENTATION, *PORIENTATION;

enum {
    ROTATE_NONE = 0,
    ROTATE_90 = 90,
    ROTATE_270 = 270,
};

//
// Data structure used to represent PageSize feature options
//

typedef struct _PAGESIZE {

    OPTION      GenericOption;                  // generic option information
    SIZE        szPaperSize;                    // paper dimension
    RECT        rcImgArea;                      // imageable area for the page size
    DWORD       dwPaperSizeID;                  // DEVMODE.dmPaperSize index
    DWORD       dwFlags;                        // flag bits
    DWORD       dwPageProtectionMemory;         // Page protection memory in bytes
                                                // for this paper size

} PAGESIZE, *PPAGESIZE;

//
// Driver defined paper sizes have IDs starting at DRIVER_PAPERSIZE_ID
//

#define DRIVER_PAPERSIZE_ID 0x7f00
#define DMPAPER_CUSTOMSIZE  0x7fff

//
// Data structure used to represent InputSlot feature options
//

typedef struct _INPUTSLOT {

    OPTION      GenericOption;                  // generic option information
    DWORD       dwFlags;                        // flag bits
    DWORD       dwPaperSourceID;                // DEVMODE.dmDefaultSource index

} INPUTSLOT, *PINPUTSLOT;

#define INPUTSLOT_REQ_PAGERGN   0x0001          // requires PageRegion

//
// Data structure used to represent OutputBin feature options
//

typedef struct _OUTPUTBIN {

    OPTION      GenericOption;                  // generic option information
    BOOL        bOutputOrderReversed ;      //  when the document is finished printing do the
                                                //    pages need to be sorted to order them first to last?

} OUTPUTBIN, *POUTPUTBIN;



//
// Data structure used to represent MediaType feature options
//

typedef struct _MEDIATYPE {

    OPTION      GenericOption;                  // generic option information
    DWORD       dwMediaTypeID;                  // DEVMODE.dmMediaType index

} MEDIATYPE, *PMEDIATYPE;

//
// Data structure used to represent InstalledMemory/VMOption options
//
// PS specific: dwInstalledMem field was never used by PPD parser/PS driver before,
// since we don't care about the amount of installed memory, we only need to know
// dwFreeMem and dwFreeFontMem. Now we are adding the support of new plugin helper
// interface, whose function GetOptionAttribute() should return the original *VMOption
// value specified in PPD. Because PPD parser may not store the original *VMOption
// value into dwFreeMem (see function VPackPrinterFeatures(), case GID_MEMOPTION),
// we now use field dwInstalledMem to store PPD's original *VMOption value.
// (We don't add a new field since this strucutre is shared by GPD parser, and we
// want to minimize the change.)
//

typedef struct _MEMOPTION {

    OPTION      GenericOption;                  // generic option information
    DWORD       dwInstalledMem;                 // amount of total installed memory
    DWORD       dwFreeMem;                      // amount of usable memory
    DWORD       dwFreeFontMem;                  // size of font cache memory

} MEMOPTION, *PMEMOPTION;

//
// FONTCARTS
// This structures contains the Font Cartridge information. This structure is
// a same as that defined by the parser. The Parser will update the Portarit
// and Landscape Font list so that they include common fonts. So each list
// will be complete. Only applicable for GPD parser
//

typedef  struct _FONTCART
{
    DWORD       dwRCCartNameID ;
    ARRAYREF    strCartName ;
    DWORD       dwFontLst ;     // Index to list of Common FontIDs
    DWORD       dwPortFontLst ; // List of Portrait Fons
    DWORD       dwLandFontLst ; // List of Landscape Fonts.
} FONTCART , * PFONTCART ;  // the prefix tag shall be  'fc'

//
// struct to carry around parser information
//

typedef struct _PARSERINFO
{
    PRAWBINARYDATA  pRawData;
    PINFOHEADER     pInfoHeader;
} PARSERINFO, * PPARSERINFO;


//
// Filename suffix and magic header to differentiate between PPD and GPD files
//

#define PPD_FILENAME_EXT    TEXT(".PPD")
#define GPD_FILENAME_EXT    TEXT(".GPD")

//
// Given a UIINFO structure and a feature index, return a pointer to
// the FEATURE structure corresponding to the specified feature.
//

PFEATURE
PGetIndexedFeature(
    PUIINFO pUIInfo,
    DWORD   dwFeatureIndex
    );

//
// Find the option whose keyword string matches the specified name
//

POPTION
PGetNamedOption(
    PUIINFO pUIInfo,
    PFEATURE pFeature,
    PCSTR   pstrOptionName,
    PDWORD  pdwOptionIndex
    );


//
// Find the feature whose keyword string matches the specified name
//

PFEATURE
PGetNamedFeature(
    PUIINFO pUIInfo,
    PCSTR   pstrFeatureName,
    PDWORD  pdwFeatureIndex
    );

//
// Given UIINFO and FEATURE structures and an option index, return a pointer to
// the OPTION structure corresponding to the specified feature option
//

PVOID
PGetIndexedOption(
    PUIINFO     pUIInfo,
    PFEATURE    pFeature,
    DWORD       dwOptionIndex
    );

//
// Given a UIINFO structure, a feature index, and an option index,
// return a pointer to the OPTION structure corresponding to
// the specified feature option
//

PVOID
PGetIndexedFeatureOption(
    PUIINFO pUIInfo,
    DWORD   dwFeatureIndex,
    DWORD   dwOptionIndex
    );

//
// Return a pointer to the PAGESIZE option structure which
// contains custom page size information (e.g. max width and height)
//

PPAGESIZE
PGetCustomPageSizeOption(
    PUIINFO pUIInfo
    );

//
// Compute the 32-bit CRC checksum on a buffer of data
//

DWORD
ComputeCrc32Checksum(
    IN PBYTE    pbuf,
    IN DWORD    dwCount,
    IN DWORD    dwChecksum
    );

//
// Copy the current option selections for a single feature from
// the source OPTSELECT array to the destination OPTSELECT array
//

VOID
VCopyOptionSelections(
    OUT POPTSELECT  pDestOptions,
    IN INT          iDestIndex,
    IN POPTSELECT   pSrcOptions,
    IN INT          iSrcIndex,
    IN OUT PINT     piNext,
    IN INT          iMaxOptions
    );

//
// Check if the raw binary data is up-to-date
// This function is only available in user-mode.
// It always returns TRUE when called from kernel-mode.
//

BOOL
BIsRawBinaryDataUpToDate(
    IN PRAWBINARYDATA   pRawData
    );


#if defined(PSCRIPT) && !defined(KERNEL_MODE)
//
// delete the raw binary data file. This is only needed for the PPD parser, since
// the GPD parser does not store parser-localized stuff in it's .bud
//
void
DeleteRawBinaryData(
    IN PTSTR    ptstrDataFilename
    );
#endif


//
// Common interface exported by both PPD and GPD parsers. Some of the complexity
// here is not necessary for the PPD parser but it's needed by the GPD parser.
//

//
//  Routine Description: LoadRawBinaryData
//
//      Load raw binary printer description data.
//
//  Arguments:
//
//      ptstrDataFilename - Specifies the name of the original printer description file
//
//  Return Value:
//
//      Pointer to raw binary printer description data
//      NULL if there is an error
//

PRAWBINARYDATA
LoadRawBinaryData(
    IN PTSTR    ptstrDataFilename
    );


//
//  Routine Description: UnloadRawBinaryData
//
//      Unload raw binary printer description data previously loaded using LoadRawBinaryData
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//
//  Return Value:
//
//      NONE
//

VOID
UnloadRawBinaryData(
    IN PRAWBINARYDATA   pRawData
    );


//
//  Routine Description: InitBinaryData
//
//      Initialize and return an instance of binary printer description data
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pInfoHdr - Points to an existing of binary data instance
//      pOptions - Specifies the options used to initialize the binary data instance
//
//  Return Value:
//
//      Pointer to an initialized binary data instance
//
//  Note:
//
//      If pInfoHdr parameter is NULL, the parser returns a new binary data instance
//      which should be freed by calling FreeBinaryData. If pInfoHdr parameter is not
//      NULL, the existing binary data instance is reinitialized.
//
//      If pOption parameter is NULL, the parser should use the default option values
//      for generating the binary data instance. The parser may have special case
//      optimization to handle this case.
//

PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    );


//
//  Routine Description: FreeBinaryData
//
//      Free an instance of the binary printer description data
//
//  Arguments:
//
//      pInfoHdr - Points to a binary data instance previously returned from an
//          InitBinaryData(pRawData, NULL, pOptions) call
//
//  Return Value:
//
//      NONE
//

VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    );


//
//  Routine Description: UpdateBinaryData
//
//      Update an instance of binary printer description data
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pInfoHdr - Points to an existing of binary data instance
//      pOptions - Specifies the options used to update the binary data instance
//
//  Return Value:
//
//      Pointer to the updated binary data instance
//      NULL if there is an error
//
//  Note:
//
//      If this function fails for whatever reason, the parser should leave
//      the original instance of printer description data untouched and return NULL.
//
//      Upon sucuessful return, it is assume that the parser has already disposed
//      of the original instance of printer description data.
//

PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    );


//
//  Routine Description: InitDefaultOptions
//
//      Initialize the option array with default settings from the printer description file
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to an array of OPTSELECT structures for storing the default settings
//      iMaxOptions - Max number of entries in pOptions array
//      iMode - Specifies what the caller is interested in:
//          MODE_DOCUMENT_STICKY
//          MODE_PRINTER_STICKY
//          MODE_DOCANDPRINTER_STICKY
//
//  Return Value:
//
//      FALSE if the input option array is not large enough to hold
//      all default option values, TRUE otherwise.
//

BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pRawData,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    );

//
//  Routine Description: ValidateDocOptions
//
//      Validate the devmode option array and correct any invalid option selections
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to an array of OPTSELECT structures that need validation
//      iMaxOptions - Max number of entries in pOptions array
//
//  Return Value:
//
//      None
//

VOID
ValidateDocOptions(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    );

//
// Mode constants passed as iMode parameter to
// InitDefaultOptions and ResolveUIConflicts
//

#define MODE_DOCUMENT_STICKY        0
#define MODE_PRINTER_STICKY         1
#define MODE_DOCANDPRINTER_STICKY   2


//
//  Routine Description: CheckFeatureOptionConflict
//
//       Check if (dwFeature1, dwOption1) constrains (dwFeature2, dwOption2)
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      dwFeature1, dwOption1 - Feature and option indices of the first feature/option pair
//      dwFeature2, dwOption2 - Feature and option indices of the second feature/option pair
//
//  Return Value:
//
//      TRUE if (dwFeature1, dwOption1) constrains (dwFeature2, dwOption2)
//      FALSE otherwise
//

BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    );


//
//  Routine Description: ResolveUIConflicts
//
//       Resolve any conflicts between printer feature option selections
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to an array of OPTSELECT structures for storing the modified options
//      iMaxOptions - Max number of entries in pOptions array
//      iMode - Specifies how the conflicts should be resolved:
//          MODE_DOCUMENT_STICKY - only resolve conflicts between doc-sticky features
//          MODE_PRINTER_STICKY - only resolve conflicts between printer-sticky features
//          MODE_DOCANDPRINTER_STICKY - resolve conflicts all features
//
//          If the most significant bit (DONT_RESOLVE_CONFLICT) of iMode is set,
//          then the caller is only interested in checking whether any conflicts
//          exist. Upon returning to the caller, the input options array will be
//          left untouched.
//
//  Return Value:
//
//      TRUE if there are no UI conflicts, otherwise FALSE if any
//      UI conflict is detected.
//

BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    );

//
// Additional flag bit for iMode parameter of ResolveUIConflicts
//

#define DONT_RESOLVE_CONFLICT       0x80000000


//
//  Routine Description: EnumEnabledOptions
//
//      Determine which options of the specified feature should be enabled
//      based on the current option selections of printer features
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to the current feature option selections
//      dwFeatureIndex - Specifies the index of the feature in question
//      pbEnabledOptions - An array of BOOLs, each entry corresponds to an option
//          of the specified feature. On exit, if the entry is TRUE, the corresponding
//          option is enabled. Otherwise, the corresponding option should be disabled.
//      iMode - Specifies how the conflicts should be resolved:
//          MODE_DOCUMENT_STICKY - only resolve conflicts between doc-sticky features
//          MODE_PRINTER_STICKY - only resolve conflicts between printer-sticky features
//          MODE_DOCANDPRINTER_STICKY - resolve conflicts all features
//
//  Return Value:
//
//      TRUE if any option for the specified feature is enabled,
//      FALSE if all options of the specified feature are disabled
//      (i.e. the feature itself is disabled)
//

BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions,
    IN INT              iMode
    );


//
//  Routine Description: EnumNewUIConflict
//
//      Check if there are any conflicts between the currently selected options
//      for the specified feature an other feature/option selections.
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to the current feature/option selections
//      dwFeatureIndex - Specifies the index of the interested printer feature
//      pbSelectedOptions - Specifies which options for the specified feature are selected
//      pConflictPair - Return the conflicting pair of feature/option selections
//
//  Return Value:
//
//      TRUE if there is a conflict between the selected options for the specified feature
//      and other feature option selections.
//
//      FALSE if the selected options for the specified feature is consistent with other
//      feature option selections.
//

BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    );


//
//  Routine Description: EnumNewPickOneUIConflict
//
//      Check if there are any conflicts between the currently selected option
//      for the specified feature an other feature/option selections.
//
//      This is similar to EnumNewUIConflict above except that only one selected
//      option is allowed for the specified feature.
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to the current feature/option selections
//      dwFeatureIndex - Specifies the index of the interested printer feature
//      dwOptionIndex - Specifies the selected option of the specified feature
//      pConflictPair - Return the conflicting pair of feature/option selections
//
//  Return Value:
//
//      TRUE if there is a conflict between the selected option for the specified feature
//      and other feature/option selections.
//
//      FALSE if the selected option for the specified feature is consistent with other
//      feature/option selections.
//

BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    );


//
//  Routine Description: ChangeOptionsViaID
//
//      Modifies an option array using the information in public devmode fields
//
//  Arguments:
//
//      pInfoHdr - Points to an instance of binary printer description data
//      pOptions - Points to the option array to be modified
//      dwFeatureID - Specifies which field(s) of the input devmode should be used
//      pDevmode - Specifies the input devmode
//
//  Return Value:
//
//      TRUE if successful, FALSE if the specified feature ID is not supported
//      or there is an error
//

BOOL
ChangeOptionsViaID(
    IN PINFOHEADER      pInfoHdr,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    );


//
//  Routine Description: MapToDeviceOptIndex
//
//      Map logical values to device feature option index
//
//  Arguments:
//
//      pInfoHdr - Points to an instance of binary printer description data
//      dwFeatureID - Indicate which feature the logical values are related to
//      lParam1, lParam2  - Parameters depending on dwFeatureID
//    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
//        which match the search criteria.   In this case the return value
//        is the number of elements in the array initialized.   Currently
//        we assume the array is large enough (256 elements).
//
//      dwFeatureID = GID_PAGESIZE:
//          map logical paper specification to physical page size option
//
//          lParam1 = paper width in microns
//          lParam2 = paper height in microns
//
//      dwFeatureID = GID_RESOLUTION:
//          map logical resolution to physical resolution option
//
//          lParam1 = x-resolution in dpi
//          lParam2 = y-resolution in dpi
//
//  Return Value:
//
//      Index of the feature option corresponding to the specified logical values;
//      OPTION_INDEX_ANY if the specified logical values cannot be mapped to
//      any feature option.
//
//    if pdwOptionIndexes  Not NULL, the return value is the number of elements
//    written to.  Zero means  the specified logical values cannot be mapped to
//    any feature option.
//

DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER      pInfoHdr,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT  PDWORD    pdwOptionIndexes
    );


//
//  Routine Description: CombineOptionArray
//
//      Combine doc-sticky with printer-sticky option selections to form a single option array
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pCombinedOptions - Points to an array of OPTSELECTs for holding the combined options
//      iMaxOptions - Max number of entries in pCombinedOptions array
//      pDocOptions - Specifies the array of doc-sticky options
//      pPrinterOptions - Specifies the array of printer-sticky options
//
//  Return Value:
//
//      FALSE if the combined option array is not large enough to store
//      all the option values, TRUE otherwise.
//
//  Note:
//
//      Either pDocOptions or pPrinterOptions could be NULL but not both. If pDocOptions
//      is NULL, then in the combined option array, the options for document-sticky
//      features will be OPTION_INDEX_ANY. Same is true when pPrinterOptions is NULL.
//

BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    );


//
//  Routine Description: SeparateOptionArray
//
//      Separate an option array into doc-sticky and for printer-sticky options
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pCombinedOptions - Points to the combined option array to be separated
//      pOptions - Points to an array of OPTSELECT structures
//          for storing the separated option array
//      iMaxOptions - Max number of entries in pOptions array
//      iMode - Whether the caller is interested in doc- or printer-sticky options:
//          MODE_DOCUMENT_STICKY
//          MODE_PRINTER_STICKY
//
//  Return Value:
//
//      FALSE if the destination option array is not large enough to hold
//      the separated option values, TRUE otherwise.
//

BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    );


//
//  Routine Description: ReconstructOptionArray
//
//      Modify an option array to change the selected options for the specified feature
//
//  Arguments:
//
//      pRawData - Points to raw binary printer description data
//      pOptions - Points to an array of OPTSELECT structures to be modified
//      iMaxOptions - Max number of entries in pOptions array
//      dwFeatureIndex - Specifies the index of printer feature in question
//      pbSelectedOptions - Which options of the specified feature is selected
//
//  Return Value:
//
//      FALSE if the input option array is not large enough to hold
//      all modified option values. TRUE otherwise.
//
//  Note:
//
//      Number of BOOLs in pSelectedOptions must match the number of options
//      for the specified feature.
//
//      This function always leaves the option array in a compact format (i.e.
//      all unused entries are left at the end of the array).
//

BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    );


#endif // !_PARSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\pfm.h ===
//--------------------------------------------------------------------------
//
// Module Name:  PFM.H
//
// Brief Description:  This module contains the PSCRIPT driver's
// font metrics defines.
//
// Author:  Kent Settle (kentse)
// Created: 22-Jan-1991
//
// Copyright (C) 1991 - 1999 Microsoft Corporation.
//--------------------------------------------------------------------------

#define MAX_KERNPAIRS   1024

#define ANSI_CHARSET    0
#define SYMBOL_CHARSET  2
#define OEM_CHARSET     255

#define NTM_VERSION     0x00010000
#define FL_NTFM_SOFTFONT              1
#define FL_NTFM_NO_TRANSLATE_CHARSET  2


#define INIT_IFI    2048
#define INIT_PFM  262144 + INIT_IFI   // storage to allocate to build NTFM.

#define MIN_UNICODE_VALUE       0
#define MAX_UNICODE_VALUE       0xFFFE
#define INVALID_UNICODE_VALUE   0xFFFF
// The AFM tokens.

#define TK_UNDEFINED            0
#define TK_STARTKERNDATA        2
#define TK_STARTKERNPAIRS       3
#define TK_KPX                  4
#define TK_ENDKERNPAIRS         5
#define TK_ENDKERNDATA          6
#define TK_FONTNAME             7
#define TK_WEIGHT               8
#define TK_ITALICANGLE          9
#define TK_ISFIXEDPITCH         10
#define TK_UNDERLINEPOSITION    11
#define TK_UNDERLINETHICKNESS   12
#define TK_FONTBBOX             13
#define TK_CAPHEIGHT            14
#define TK_XHEIGHT              15
#define TK_DESCENDER            16
#define TK_ASCENDER             17
#define TK_STARTCHARMETRICS     18
#define TK_ENDCHARMETRICS       19
#define TK_ENDFONTMETRICS       20
#define TK_STARTFONTMETRICS     21
#define TK_ENCODINGSCHEME       22
#define TK_FULLNAME             23
#define TK_FAMILYNAME           24
#define TK_MSFAMILY             25

// font defines.

#define ARIAL                               1
#define ARIAL_BOLD                          2
#define ARIAL_BOLDOBLIQUE                   3
#define ARIAL_OBLIQUE                       4
#define ARIAL_NARROW                        5
#define ARIAL_NARROW_BOLD                   6
#define ARIAL_NARROW_BOLDOBLIQUE            7
#define ARIAL_NARROW_OBLIQUE                8
#define AVANTGARDE_BOOK                     9
#define AVANTGARDE_BOOKOBLIQUE              10
#define AVANTGARDE_DEMI                     11
#define AVANTGARDE_DEMIOBLIQUE              12
#define BOOKMAN_DEMI                        13
#define BOOKMAN_DEMIITALIC                  14
#define BOOKMAN_LIGHT                       15
#define BOOKMAN_LIGHTITALIC                 16
#define COURIER                             17
#define COURIER_BOLD                        18
#define COURIER_BOLDOBLIQUE                 19
#define COURIER_OBLIQUE                     20
#define GARAMOND_BOLD                       21
#define GARAMOND_BOLDITALIC                 22
#define GARAMOND_LIGHT                      23
#define GARAMOND_LIGHTITALIC                24
#define HELVETICA                           25
#define HELVETICA_BLACK                     26
#define HELVETICA_BLACKOBLIQUE              27
#define HELVETICA_BOLD                      28
#define HELVETICA_BOLDOBLIQUE               29
#define HELVETICA_CONDENSED                 30
#define HELVETICA_CONDENSED_BOLD            31
#define HELVETICA_CONDENSED_BOLDOBL         32
#define HELVETICA_CONDENSED_OBLIQUE         33
#define HELVETICA_LIGHT                     34
#define HELVETICA_LIGHTOBLIQUE              35
#define HELVETICA_NARROW                    36
#define HELVETICA_NARROW_BOLD               37
#define HELVETICA_NARROW_BOLDOBLIQUE        38
#define HELVETICA_NARROW_OBLIQUE            39
#define HELVETICA_OBLIQUE                   40
#define KORINNA_BOLD                        41
#define KORINNA_KURSIVBOLD                  42
#define KORINNA_KURSIVREGULAR               43
#define KORINNA_REGULAR                     44
#define LUBALINGRAPH_BOOK                   45
#define LUBALINGRAPH_BOOKOBLIQUE            46
#define LUBALINGRAPH_DEMI                   47
#define LUBALINGRAPH_DEMIOBLIQUE            48
#define NEWCENTURYSCHLBK_BOLD               49
#define NEWCENTURYSCHLBK_BOLDITALIC         50
#define NEWCENTURYSCHLBK_ITALIC             51
#define NEWCENTURYSCHLBK_ROMAN              52
#define PALATINO_BOLD                       53
#define PALATINO_BOLDITALIC                 54
#define PALATINO_ITALIC                     55
#define PALATINO_ROMAN                      56
#define SOUVENIR_DEMI                       57
#define SOUVENIR_DEMIITALIC                 58
#define SOUVENIR_LIGHT                      59
#define SOUVENIR_LIGHTITALIC                60
#define SYMBOL                              61
#define TIMES_BOLD                          62
#define TIMES_BOLDITALIC                    63
#define TIMES_ITALIC                        64
#define TIMES_ROMAN                         65
#define TIMES_NEW_ROMAN                     66
#define TIMES_NEW_ROMAN_BOLD                67
#define TIMES_NEW_ROMAN_BOLDITALIC          68
#define TIMES_NEW_ROMAN_ITALIC              69
#define VARITIMES_BOLD                      70
#define VARITIMES_BOLDITALIC                71
#define VARITIMES_ITALIC                    72
#define VARITIMES_ROMAN                     73
#define ZAPFCALLIGRAPHIC_BOLD               74
#define ZAPFCALLIGRAPHIC_BOLDITALIC         75
#define ZAPFCALLIGRAPHIC_ITALIC             76
#define ZAPFCALLIGRAPHIC_ROMAN              77
#define ZAPFCHANCERY_MEDIUMITALIC           78
#define ZAPFDINGBATS                        79

#define FIRST_FONT                          1
#define DEFAULT_FONT                        COURIER
#define NUM_INTERNAL_FONTS                  79

extern PutByte(SHORT);
extern PutWord(SHORT);
extern PutLong(long);

typedef USHORT  SOFFSET;        // short offset.

#define DWORDALIGN(a) ((a + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1))
#define WCHARALIGN(a) ((a + (sizeof(WCHAR) - 1)) & ~(sizeof(WCHAR) - 1))

// entry for each soft font.

// NT Font Metrics structure.

typedef ULONG   LOFFSET;        // long offset.

typedef struct
{
    ULONG   cjNTFM;             // size of NTFM struct, with attached data.
    LOFFSET loszFontName;       // offset to FontName.
    LOFFSET loIFIMETRICS;       // offset to IFIMETRICS structure.
    ULONG   cKernPairs;
    LOFFSET loKernPairs;        // offset to start of FD_KERNINGPAIR structs.
} NTFMSZ;

typedef struct
{
    ULONG           ulVersion;          // version
    NTFMSZ          ntfmsz;             // size inormation
    FLONG           flNTFM;             // flags [bodind]
    EXTTEXTMETRIC   etm;
    USHORT          ausCharWidths[256];
} NTFM, *PNTFM;

// This is value needed to determine if a particular soft font needs
// encoding vector remapping (stolen win31 source code) [bodind]

#define NO_TRANSLATE_CHARSET    200

// Maximum length of font names

#define MAX_FONTNAME            128

// An estimate of average PS font size =~ 33K

#define AVERAGE_FONT_SIZE       (33*1024)

/*--------------------------------------------------------------------*\
*  The PFB file format is a sequence of segments, each of which has a  *
*  header part and a data part. The header format, defined in the      *
*  struct PFBHEADER below, consists of a one byte sanity check number  *
*  (128) then a one byte segment type and finally a four byte length   *
*  field for the data following data. The length field is stored in    *
*  the file with the least significant byte first.                     *
*                                                                      *
*  The segment types are:                                              *
*  1.) The data is a sequence of ASCII characters.                     *
*  2.) The data is a sequence of binary characters to be converted     *
*      to a sequence of pairs of hexadecimal digits.                   *
*  3.) The last segment in the file. This segment has no length or     *
*      data fields.                                                    *
*                                                                      *
*  The segment types are defined explicitly rather than as an          *
*  enumerated type because the values for each type are defined by the *
*  file format rather than the compiler manipulating them.             *
\*--------------------------------------------------------------------*/

#define CHECK_BYTE      128         // first byte of file segment
#define ASCII_TYPE      1           // segment type identifier
#define BINARY_TYPE     2
#define EOF_TYPE        3

// Macro to verify whether a PFBHEADER is valid

#define ValidPfbHeader(p)   (*((PBYTE)(p)) == CHECK_BYTE)

// Macro to retrieve the segment type field of PFBHEADER

#define PfbSegmentType(p)   (((PBYTE)(p))[1])

// Macro to retrieve the segment length field of PFBHEADER

#define PfbSegmentLength(p) (((DWORD) ((PBYTE)(p))[2]      ) |  \
                             ((DWORD) ((PBYTE)(p))[3] <<  8) |  \
                             ((DWORD) ((PBYTE)(p))[4] << 16) |  \
                             ((DWORD) ((PBYTE)(p))[5] << 24))

// Size of PFBHEADER = 6 bytes

#define PFBHEADER_SIZE  6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\psglyph.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    psglyph.h

Abstract:

    Header file for glyph set data.

Environment:

    Windows NT PostScript driver.

Revision History:

    10/10/1997  -ksuzuki-
        Moved all the Standard GLYPHSETDATA names to AFM2NTM.H.

    11/12/1996  -slam-
        Created.

    dd-mm-yy -author-
        description

--*/


#ifndef _PSGLYPH_H_
#define _PSGLYPH_H_

typedef struct _CODEPAGEINFO
{
    DWORD   dwCodePage;
    DWORD   dwWinCharset;
    DWORD   dwEncodingNameOffset;
    DWORD   dwEncodingVectorDataSize;
    DWORD   dwEncodingVectorDataOffset;

} CODEPAGEINFO, *PCODEPAGEINFO;

typedef struct _GLYPHRUN
{

    WCHAR   wcLow;
    WORD    wGlyphCount;

} GLYPHRUN, *PGLYPHRUN;

#define GLYPHSETDATA_VERSION    0x00010000

typedef struct _GLYPHSETDATA
{

    DWORD   dwSize;                 // size of the glyphset data
    DWORD   dwVersion;              // glyphset data format version number
    DWORD   dwFlags;                // flags
    DWORD   dwGlyphSetNameOffset;   // offset to glyphset name string
    DWORD   dwGlyphCount;           // number of glyphs supported
    DWORD   dwRunCount;             // number of GLYPHRUNs
    DWORD   dwRunOffset;            // offset to array of GLYPHRUNs
    DWORD   dwCodePageCount;        // number of code pages supported
    DWORD   dwCodePageOffset;       // offset to array of CODEPAGEINFOs
    DWORD   dwMappingTableOffset;   // offset to glyph handle mapping table
    DWORD   dwReserved[2];          // reserved

} GLYPHSETDATA, *PGLYPHSETDATA;

//
// Mapping table type flag defintions (set to GLYPHSETDATA.dwFlags)
//
#define GSD_MTT_DWCPCC  0x00000000  // DWORD:CodePage/CharCode pair (default)
#define GSD_MTT_WCC     0x00000001  // WORD:CharCode only
#define GSD_MTT_WCID    0x00000002  // WORD:CID only (not used yet)
#define GSD_MTT_MASK    (GSD_MTT_WCC|GSD_MTT_WCID)

//
// Macros to get GLYPHSETDATA elements
//
#ifndef MK_PTR
#define MK_PTR(pstruct, element)  ((PVOID)((PBYTE)(pstruct)+(pstruct)->element))
#endif

#define GSD_GET_SIZE(pgsd)              (pgsd->dwSize)
#define GSD_GET_FLAGS(pgsd)             (pgsd->dwFlags)
#define GSD_GET_MAPPINGTYPE(pgsd)       (pgsd->dwFlags & GSD_MTT_MASK)
#define GSD_GET_GLYPHSETNAME(pgsd)      ((PSTR)MK_PTR(pgsd, dwGlyphSetNameOffset))
#define GSD_GET_GLYPHCOUNT(pgsd)        (pgsd->dwGlyphCount)
#define GSD_GET_GLYPHRUNCOUNT(pgsd)     (pgsd->dwRunCount)
#define GSD_GET_GLYPHRUN(pgsd)          ((PGLYPHRUN)(MK_PTR(pgsd, dwRunOffset)))
#define GSD_GET_CODEPAGEINFOCOUNT(pgsd) (pgsd->dwCodePageCount)
#define GSD_GET_CODEPAGEINFO(pgsd)      ((PCODEPAGEINFO)MK_PTR(pgsd, dwCodePageOffset))
#define GSD_GET_MAPPINGTABLE(pgsd)      (MK_PTR(pgsd, dwMappingTableOffset))


//
// GLYPHSETDATA related function prototypes and macros
//

PFD_GLYPHSET
GlyphConvert(
    PGLYPHSETDATA   pGlyphSet
    );

PFD_GLYPHSET
GlyphConvertSymbol(
    PGLYPHSETDATA   pGlyphSet
    );

PFD_GLYPHSET
GlyphConvert2(
    PGLYPHSETDATA   pGlyphSet
    );

#define GlyphCreateFD_GLYPHSET(pGlyph)  (GlyphConvert2(pGlyph))

#endif  //!_PSGLYPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\ppd.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ppd.h

Abstract:

    PPD parser specific header file

Environment:

    Windows NT PostScript driver

Revision History:

    10/11/96 -davidx-
        Make CustomPageSize feature an option of PageSize.

    08/16/96 -davidx-
        Created it.

--*/


#ifndef _PPD_H_
#define _PPD_H_

//
// We need to include <printoem.h> for its definition of CUSTOMPARAM_xxx
// constants and CUSTOMSIZEPARAM structure.
//

#ifndef KERNEL_MODE
#include <winddiui.h>
#endif

#include <printoem.h>

//
// PPD parser version number
//

#define PRIVATE_PARSER_VERSION  0x0017
#define PPD_PARSER_VERSION      MAKELONG(PRIVATE_PARSER_VERSION, SHARED_PARSER_VERSION)

//
// Current PPD spec version
//

#define PPD_SPECVERSION_43  0x00040003

//
// Binary printer description filename extension
//

#ifndef ADOBE
#define BPD_FILENAME_EXT    TEXT(".BPD")
#else
#define BPD_FILENAME_EXT    TEXT(".ABD")
#endif

//
// Given a pointer to raw printer description data, initialize pointers
// to INFOHEADER and UIINFO structures
//

#define PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo) { \
            ASSERT((pRawData) != NULL && (pRawData) == (pRawData)->pvPrivateData); \
            (pInfoHdr) = (PINFOHEADER) (pRawData); \
            (pUIInfo) = GET_UIINFO_FROM_INFOHEADER(pInfoHdr); \
        }

//
// Given a pointer to raw printer description data, initialize pointers
// to INFOHEADER and PPDDATA structures
//

#define PPD_GET_PPDDATA_FROM_RAWDATA(pRawData, pInfoHdr, pPpdData) { \
            ASSERT((pRawData) != NULL && (pRawData) == (pRawData)->pvPrivateData); \
            (pInfoHdr) = (PINFOHEADER) (pRawData); \
            (pPpdData) = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr); \
        }


//
// Constants for PPDDATA.dwCustomSizeFlags
//

#define CUSTOMSIZE_CUTSHEET         0x0001      // device supports cut-sheet
#define CUSTOMSIZE_ROLLFED          0x0002      // device supports roll-feed
#define CUSTOMSIZE_DEFAULTCUTSHEET  0x0004      // default to cut-sheet
#define CUSTOMSIZE_SHORTEDGEFEED    0x0008      // default to short edge feed
#define CUSTOMSIZE_CENTERREG        0x0010      // center-registered

#define CUSTOMORDER(pPpdData, csindex) \
        ((pPpdData)->CustomSizeParams[csindex].dwOrder)

#define MINCUSTOMPARAM(pPpdData, csindex) \
        ((pPpdData)->CustomSizeParams[csindex].lMinVal)

#define MAXCUSTOMPARAM(pPpdData, csindex) \
        ((pPpdData)->CustomSizeParams[csindex].lMaxVal)

#define MAXCUSTOMPARAM_WIDTH(pPpdData)          MAXCUSTOMPARAM(pPpdData, CUSTOMPARAM_WIDTH)
#define MAXCUSTOMPARAM_HEIGHT(pPpdData)         MAXCUSTOMPARAM(pPpdData, CUSTOMPARAM_HEIGHT)
#define MAXCUSTOMPARAM_WIDTHOFFSET(pPpdData)    MAXCUSTOMPARAM(pPpdData, CUSTOMPARAM_WIDTHOFFSET)
#define MAXCUSTOMPARAM_HEIGHTOFFSET(pPpdData)   MAXCUSTOMPARAM(pPpdData, CUSTOMPARAM_HEIGHTOFFSET)
#define MAXCUSTOMPARAM_ORIENTATION(pPpdData)    MAXCUSTOMPARAM(pPpdData, CUSTOMPARAM_ORIENTATION)

#define MINCUSTOMPARAM_WIDTH(pPpdData)          MINCUSTOMPARAM(pPpdData, CUSTOMPARAM_WIDTH)
#define MINCUSTOMPARAM_HEIGHT(pPpdData)         MINCUSTOMPARAM(pPpdData, CUSTOMPARAM_HEIGHT)
#define MINCUSTOMPARAM_WIDTHOFFSET(pPpdData)    MINCUSTOMPARAM(pPpdData, CUSTOMPARAM_WIDTHOFFSET)
#define MINCUSTOMPARAM_HEIGHTOFFSET(pPpdData)   MINCUSTOMPARAM(pPpdData, CUSTOMPARAM_HEIGHTOFFSET)
#define MINCUSTOMPARAM_ORIENTATION(pPpdData)    MINCUSTOMPARAM(pPpdData, CUSTOMPARAM_ORIENTATION)

//
// This structure contains the information parsed from the PPD file that's
// not stored in UIINFO structure.
//

typedef struct _PPDDATA {

    DWORD           dwSizeOfStruct;     // size of this structure
    DWORD           dwFlags;            // misc. flags
    DWORD           dwExtensions;       // language extensions
    DWORD           dwSetResType;       // how to set resolution
    DWORD           dwPpdFilever;       // PPD file version
    DWORD           dwPSVersion;        // PostScript interpreter version number
    INVOCATION      PSVersion;          // PSVersion string
    INVOCATION      Product;            // Product string

    DWORD           dwOutputOrderIndex; // index of feature "OutputOrder"
    DWORD           dwCustomSizeFlags;  // custom page size flags and parameters
    DWORD           dwLeadingEdgeLong;  // option index for *LeadingEdge Long
    DWORD           dwLeadingEdgeShort; // option index for *LeadingEdge Short
    DWORD           dwUseHWMarginsTrue; // option index for *UseHWMargins True
    DWORD           dwUseHWMarginsFalse;// option index for *UseHWMargins False
    CUSTOMSIZEPARAM CustomSizeParams[CUSTOMPARAM_MAX];

    DWORD           dwNt4Checksum;      // NT4 PPD checksum
    DWORD           dwNt4DocFeatures;   // NT4 number of doc-sticky features
    DWORD           dwNt4PrnFeatures;   // NT4 number of printer-sticky features
    ARRAYREF        Nt4Mapping;         // feature index mapping from NT4 to NT5

    INVOCATION      PatchFile;          // PatchFile invocation string
    INVOCATION      JclBegin;           // JCLBegin invocation string
    INVOCATION      JclEnterPS;         // JCLEnterLanguage invocation string
    INVOCATION      JclEnd;             // JCLEnd invocation string
    INVOCATION      ManualFeedFalse;    // *ManualFeed False invocation string

    PTRREF          loDefaultFont;      // byte-offset to the default device font
    ARRAYREF        DeviceFonts;        // array of DEVFONT structures

    ARRAYREF        OrderDeps;          // array of ORDERDEPEND structures
    ARRAYREF        QueryOrderDeps;     // array of ORDERDEPEND structures for query order dependency
    ARRAYREF        JobPatchFiles;      // array of JobPatchFile invocation strings

    DWORD           dwUserDefUILangID;  // user's default UI language ID when .bpd is generated

} PPDDATA, *PPPDDATA;

//
// Constants for PPDDATA.dwFlags field
//

#define PPDFLAG_REQEEXEC        0x0001  // requires eexec-encoded Type1 font
#define PPDFLAG_PRINTPSERROR    0x0002  // print PS error page
#define PPDFLAG_HAS_JCLBEGIN    0x0004  // JCLBegin entry is present
#define PPDFLAG_HAS_JCLENTERPS  0x0008  // JCLToPSInterpreter entry is present
#define PPDFLAG_HAS_JCLEND      0x0010  // JCLEnd entry is present

//
// Decide if the printer can fully support custom page size feature:
//  PPD4.3 device (cut-sheet or roll-fed)
//  pre-PPD4.3 roll-fed device
//

#define SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUIInfo, pPpdData) \
        ((pUIInfo)->dwSpecVersion >= PPD_SPECVERSION_43 || \
         ((pPpdData)->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))

//
// PPD spec says if *CustomPageSize is present, *LeadingEdge should also be
// present. But there are some PPD files that don't have *LeadingEdge statements,
// in which case we assume the device supports both Long and Short leading edges.
//
// Also, there are PPD files that specify neither Long nor Short option for
// *LeadingEdge, in which case we also assume the device supports both Long and
// Short leading edges.
//

#define SKIP_LEADINGEDGE_CHECK(pUIInfo, pPpdData) \
        ((GET_PREDEFINED_FEATURE((pUIInfo), GID_LEADINGEDGE) == NULL) || \
         ((pPpdData)->dwLeadingEdgeLong == OPTION_INDEX_ANY && \
          (pPpdData)->dwLeadingEdgeShort == OPTION_INDEX_ANY))

#define LONGEDGEFIRST_SUPPORTED(pUIInfo, pPpdData) \
        (SKIP_LEADINGEDGE_CHECK(pUIInfo, pPpdData) || \
        ((pPpdData)->dwLeadingEdgeLong != OPTION_INDEX_ANY))

#define SHORTEDGEFIRST_SUPPORTED(pUIInfo, pPpdData) \
        (SKIP_LEADINGEDGE_CHECK(pUIInfo, pPpdData) || \
        ((pPpdData)->dwLeadingEdgeShort != OPTION_INDEX_ANY))

//
// Minimum amount of free VM for Level1 and Level2 printer
//

#define MIN_FREEMEM_L1             (172*KBYTES)
#define MIN_FREEMEM_L2             (249*KBYTES)

//
// Default job timeout and wait timeout measured in seconds
//

#define DEFAULT_JOB_TIMEOUT     0
#define DEFAULT_WAIT_TIMEOUT    300

//
// Landscape orientation options
//

#define LSO_ANY                 0
#define LSO_PLUS90              90
#define LSO_MINUS90             270

//
// How to set resolution
//

#define RESTYPE_NORMAL          0
#define RESTYPE_JCL             1
#define RESTYPE_EXITSERVER      2

//
// Language extensions
//

#define LANGEXT_DPS             0x0001
#define LANGEXT_CMYK            0x0002
#define LANGEXT_COMPOSITE       0x0004
#define LANGEXT_FILESYSTEM      0x0008

//
// Default resolution when no information is provided in the PPD file
//

#define DEFAULT_RESOLUTION      300

//
// Data structure for storing information about device fonts
//

typedef struct _DEVFONT {

    PTRREF      loFontName;         // byte offset to font name (ANSI string)
    PTRREF      loDisplayName;      // byte offset to translation string (Unicode string)
    PTRREF      loEncoding;         // encoding (ANSI string)
    PTRREF      loCharset;          // charset (ANSI string)
    PTRREF      loVersion;          // version (ANSI string)
    DWORD       dwStatus;           // status

} DEVFONT, *PDEVFONT;

#define FONTSTATUS_UNKNOWN  0
#define FONTSTATUS_ROM      1
#define FONTSTATUS_DISK     2

//
// Data structure for storing information about order dependencies
//

typedef struct _ORDERDEPEND {

    LONG    lOrder;                 // order value from *OrderDependency entry
    DWORD   dwSection;              // in which section should the code appear
    DWORD   dwPPDSection;           // orignal section specified in PPD (no parser conversion)
    DWORD   dwFeatureIndex;         // index of the feature involved
    DWORD   dwOptionIndex;          // index of the option involved (if any)
    DWORD   dwNextOrderDep;         // points to the list of order dependencies
                                    // related to a feature; always starts with
                                    // the entry whose dwOptionIndex = OPTION_INDEX_ANY

} ORDERDEPEND, *PORDERDEPEND;

#define NULL_ORDERDEP            0xffffffff
#define INVALID_FEATURE_INDEX    0xffffffff

//
// Constants for ORDERDEPENDENCY.section field
//

#define SECTION_JCLSETUP    0x0001
#define SECTION_EXITSERVER  0x0002
#define SECTION_PROLOG      0x0004
#define SECTION_UNASSIGNED  0x0008

//
// Change SECTION_ANYSETUP to be smaller than SECTION_DOCSETUP/SECTION_PAGESETUP
// so that in the ascending order dependency list, for nodes with the same order value,
// SECTION_ANYSETUP nodes will be in front of SECTION_DOCSETUP/SECTION_PAGESETUP nodes.
//

#define SECTION_ANYSETUP    0x0010
#define SECTION_DOCSETUP    0x0020
#define SECTION_PAGESETUP   0x0040

//
// Load cached binary PPD data file into memory
//

PRAWBINARYDATA
PpdLoadCachedBinaryData(
    IN PTSTR    ptstrPpdFilename
    );

//
// Parse the ASCII text PPD file and cached the resulting binary data
//

PRAWBINARYDATA
PpdParseTextFile(
    IN PTSTR    ptstrPpdFilename
    );

//
// Generate a filename for the cached binary PPD data given a PPD filename
//

PTSTR
GenerateBpdFilename(
    IN PTSTR    ptstrPpdFilename
    );

//
// Validate the specified custom page size parameters and
// Fix up any inconsistencies found.
//

BOOL
BValidateCustomPageSizeData(
    IN PRAWBINARYDATA       pRawData,
    IN OUT PCUSTOMSIZEDATA  pCSData
    );

//
// Initialize custom page size parameters to their default values
//

VOID
VFillDefaultCustomPageSizeData(
    IN PRAWBINARYDATA   pRawData,
    OUT PCUSTOMSIZEDATA pCSData,
    IN BOOL             bMetric
    );

//
// Return the valid ranges for custom page size width, height,
// and offset parameters based on the specifed paper feed direction
//

typedef struct _CUSTOMSIZERANGE {

    DWORD   dwMin;
    DWORD   dwMax;

} CUSTOMSIZERANGE, *PCUSTOMSIZERANGE;

VOID
VGetCustomSizeParamRange(
    IN PRAWBINARYDATA    pRawData,
    IN PCUSTOMSIZEDATA   pCSData,
    OUT PCUSTOMSIZERANGE pCSRange
    );

//
// Convert NT4 feature/option selections to NT5 format
//

VOID
VConvertOptSelectArray(
    PRAWBINARYDATA  pRawData,
    POPTSELECT      pNt5Options,
    DWORD           dwNt5MaxCount,
    PBYTE           pubNt4Options,
    DWORD           dwNt4MaxCount,
    INT             iMode
    );

//
// Return a copy of the default font substitution table
//

PTSTR
PtstrGetDefaultTTSubstTable(
    PUIINFO pUIInfo
    );


//
// Check whether a form is supported through custom paper size, and if yes
// which direction the paper is fed. pwFeedDirection can be NULL
//
BOOL
BFormSupportedThruCustomSize(
    PRAWBINARYDATA  pRawData,
    DWORD           dwX,
    DWORD           dwY,
    PWORD           pwFeedDirection
    );

#endif  // !_PPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\psntf.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    psntf.h

Abstract:

    Header file for NTF format.

Environment:

    Windows NT PostScript driver.

Revision History:

    11/12/96 -slam-
        Created.

    dd-mm-yy -author-
        description

--*/


#ifndef _PSNTF_H_
#define _PSNTF_H_

#define MAX_NTF         6   // maximum number of NTF files per device
#define MAX_NTF_CACHE   4   // maximum number of cached NTF files


typedef struct _NTF_FONTMTXENTRY
{

    DWORD   dwFontNameOffset;   // offset to font name string
    DWORD   dwHashValue;        // hash value of name string
    DWORD   dwDataSize;         // size of font metrics data
    DWORD   dwDataOffset;       // offset to font metrics data
    DWORD   dwVersion;          // font version number
    DWORD   dwReserved[3];      // reserved

} NTF_FONTMTXENTRY, *PNTF_FONTMTXENTRY;


typedef struct _NTF_GLYPHSETENTRY
{

    DWORD   dwNameOffset;       // offset to glyphset name string
    DWORD   dwHashValue;        // hash value of name string
    DWORD   dwDataSize;         // size of glyphset data
    DWORD   dwDataOffset;       // offset to glyphset data
    DWORD   dwGlyphSetType;     // glyphset data type
    DWORD   dwFlags;            // flags
    DWORD   dwReserved[2];      // reserved

} NTF_GLYPHSETENTRY, *PNTF_GLYPHSETENTRY;


//
// NTF_VERSION_NUMBER history
//
// Version     Comment           Driver
// 0x00010000  Initial version   AdobePS5-NT4 5.0 and 5.1. and W2k Pscript5 (which also has the EOF marker)
// 0x00010001  Added EOF marker  AdobePS5-NT4 5.1.1 and AdobePS5-W2K
//

#define NTF_FILE_MAGIC      'NTF1'
#define NTF_DRIVERTYPE_PS   'NTPS'
#define NTF_EOF_MARK        '%EOF'

#ifdef ADOBE
#define NTF_VERSION_NUMBER  0x00010001
#else
#define NTF_VERSION_NUMBER  0x00010000
#endif

typedef struct _NTF_FILEHEADER
{

    DWORD   dwSignature;        // file magic number
    DWORD   dwDriverType;       // driver's magic number
    DWORD   dwVersion;          // NTF version number
    DWORD   dwReserved[5];      // reserved

    DWORD   dwGlyphSetCount;    // no. of glyph sets included
    DWORD   dwGlyphSetOffset;   // offset to the glyphset table

    DWORD   dwFontMtxCount;     // no. of font metrics
    DWORD   dwFontMtxOffset;    // offset to the font metrics table

} NTF_FILEHEADER, *PNTF_FILEHEADER;


#define NTF_GET_ENTRY_DATA(pNTF, pEntry) (OFFSET_TO_POINTER(pNTF, pEntry->dwDataOffset))


#endif  //!_PSNTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\pslib.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    pslib.h

Abstract:

    PostScript specific library functions

Environment:

    Windows NT printer drivers

Revision History:

    09/25/96 -davidx-
        Created it.

--*/


#ifndef _PSLIB_H_
#define _PSLIB_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "psglyph.h"
#include "psntm.h"
#include "psntf.h"
#include "psvmerr.h"

//
// Macros for converting between microns and PostScript points
//

#define MICRON_TO_POINT(micron)      MulDiv(micron, 72,  25400)
#define POINT_TO_MICRON(point)       MulDiv(point, 25400, 72)

//
// Convert between ANSI and Unicode strings (using the current ANSI codepage)
//

VOID
VCopyUnicodeStringToAnsi(
    PSTR    pstr,
    PCWSTR  pwstr,
    INT     iMaxChars
    );

//
// Check if the devmode form fields are specifying PostScript custom page size
//

BOOL
BValidateDevmodeCustomPageSizeFields(
    PRAWBINARYDATA  pRawData,
    PUIINFO         pUIInfo,
    PDEVMODE        pdm,
    PRECTL          prclImageArea
    );

#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

//
// Get VM? Error message ID
//

DWORD
DWGetVMErrorMessageID(
    VOID
    );

#endif // !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

//
// Filename extension for PostScript driver device font data file
//

#define NTF_FILENAME_EXT        TEXT(".NTF")

//
// Font downloader NTF file directory
//  %SystemRoot%\system32\spool\drivers\psfont\
//

#define FONTDIR                 TEXT("\\psfont\\")

//
// Private escapes between driver graphics module and driver UI
//
//  To get a list of permanant device font names, driver UI should
//  call ExtEscape(DRIVERESC_QUERY_DEVFONTS) with cjIn=sizeof(DWORD)
//  and pvIn points to a DWORD whose value equals to QUERY_FAMILYNAME.
//
//  Driver UI should first call this escape with cjOut=0 and pvOut=NULL
//  in order to find out how big the output buffer should be. After
//  allocating a large enough output buffer, driver UI should call this
//  escape again to retrieve the list of device font names.
//
//  The list of device font names is returned as Unicode strings in
//  MULTI_SZ format. Note that duplicate font names may appear in the list.
//

#define DRIVERESC_QUERY_DEVFONTS    0x80000001
#define QUERY_FAMILYNAME            'PSFF'

//
// synthesized PS driver feature prefix
//

#define PSFEATURE_PREFIX   '%'

//
// synthesized PS driver features
//

extern const CHAR kstrPSFAddEuro[];
extern const CHAR kstrPSFCtrlDAfter[];
extern const CHAR kstrPSFCtrlDBefore[];
extern const CHAR kstrPSFCustomPS[];
extern const CHAR kstrPSFTrueGrayG[];
extern const CHAR kstrPSFJobTimeout[];
extern const CHAR kstrPSFMaxBitmap[];
extern const CHAR kstrPSFEMF[];
extern const CHAR kstrPSFMinOutline[];
extern const CHAR kstrPSFMirroring[];
extern const CHAR kstrPSFNegative[];
extern const CHAR kstrPSFPageOrder[];
extern const CHAR kstrPSFNup[];
extern const CHAR kstrPSFErrHandler[];
extern const CHAR kstrPSFPSMemory[];
extern const CHAR kstrPSFOrientation[];
extern const CHAR kstrPSFOutFormat[];
extern const CHAR kstrPSFOutProtocol[];
extern const CHAR kstrPSFOutPSLevel[];
extern const CHAR kstrPSFTrueGrayT[];
extern const CHAR kstrPSFTTFormat[];
extern const CHAR kstrPSFWaitTimeout[];

//
// some commonly used keyword strings
//

extern const CHAR kstrKwdTrue[];
extern const CHAR kstrKwdFalse[];

typedef BOOL (*_BPSFEATURE_PROC)(
    IN  HANDLE,
    IN  PUIINFO,
    IN  PPPDDATA,
    IN  PDEVMODE,
    IN  PPRINTERDATA,
    IN  PCSTR,
    IN  PCSTR,
    OUT PSTR,
    IN  INT,
    OUT PDWORD,
    IN  DWORD);

//
// constant definitions for _BPSFEATURE_PROC's dwMode parameter
//

#define PSFPROC_ENUMOPTION_MODE   0
#define PSFPROC_GETOPTION_MODE    1
#define PSFPROC_SETOPTION_MODE    2

typedef struct _PSFEATURE_ENTRY {

    PCSTR             pszPSFeatureName;   // feature name
    BOOL              bPrinterSticky;     // TRUE if printer-sticky
    BOOL              bEnumerableOptions; // TRUE if options are enumerable
    BOOL              bBooleanOptions;    // TRUE if has boolean options
    _BPSFEATURE_PROC  pfnPSProc;          // option handling proc

} PSFEATURE_ENTRY, *PPSFEATURE_ENTRY;

extern const PSFEATURE_ENTRY kPSFeatureTable[];

//
// PS driver's helper functions for OEM plugins
//
// The following helper functions are available to both UI and render plugins
//

HRESULT
HGetGlobalAttribute(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    );

HRESULT
HGetFeatureAttribute(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszFeatureKeyword,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    );

HRESULT
HGetOptionAttribute(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszFeatureKeyword,
    IN  PCSTR       pszOptionKeyword,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    );

HRESULT
HEnumFeaturesOrOptions(
    IN  HANDLE      hPrinter,
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszFeatureKeyword,
    OUT PSTR        pmszOutputList,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    );

HRESULT
HGetOptions(
    IN  HANDLE        hPrinter,
    IN  PINFOHEADER   pInfoHeader,
    IN  POPTSELECT    pOptionsArray,
    IN  PDEVMODE      pdm,
    IN  PPRINTERDATA  pPrinterData,
    IN  DWORD         dwFlags,
    IN  PCSTR         pmszFeaturesRequested,
    IN  DWORD         cbIn,
    OUT PSTR          pmszFeatureOptionBuf,
    IN  DWORD         cbSize,
    OUT PDWORD        pcbNeeded,
    IN  BOOL          bPrinterSticky
    );

//
// Following are internal utility functions used by helper functions
//

BOOL
BValidMultiSZString(
    IN  PCSTR     pmszString,
    IN  DWORD     cbSize,
    IN  BOOL      bCheckPairs
    );

#ifdef __cplusplus
}
#endif

#endif // !_PSLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\psntm.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ntm.h

Abstract:

    Header file for NTM data.

Environment:

    Windows NT PostScript driver.

Revision History:

    09/16/96 -slam-
        Created.

    dd-mm-yy -author-
        description

--*/


#ifndef _PSNTM_H_
#define _PSNTM_H_


#ifdef  KERNEL_MODE

// Declarations used when compiling for kernel mode

#define MULTIBYTETOUNICODE  EngMultiByteToUnicodeN
#define UNICODETOMULTIBYTE  EngUnicodeToMultiByteN

#else   //!KERNEL_MODE

// Declarations used when compiling for user mode

LONG
RtlMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    );

LONG
RtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

#define MULTIBYTETOUNICODE  RtlMultiByteToUnicodeN
#define UNICODETOMULTIBYTE  RtlUnicodeToMultiByteN

#endif  //!KERNEL_MODE


#define DWORDALIGN(a) ((a + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1))


typedef struct _EXTTEXTMETRIC
{
    SHORT  etmSize;
    SHORT  etmPointSize;
    SHORT  etmOrientation;
    SHORT  etmMasterHeight;
    SHORT  etmMinScale;
    SHORT  etmMaxScale;
    SHORT  etmMasterUnits;
    SHORT  etmCapHeight;
    SHORT  etmXHeight;
    SHORT  etmLowerCaseAscent;
    SHORT  etmLowerCaseDescent;
    SHORT  etmSlant;
    SHORT  etmSuperScript;
    SHORT  etmSubScript;
    SHORT  etmSuperScriptSize;
    SHORT  etmSubScriptSize;
    SHORT  etmUnderlineOffset;
    SHORT  etmUnderlineWidth;
    SHORT  etmDoubleUpperUnderlineOffset;
    SHORT  etmDoubleLowerUnderlineOffset;
    SHORT  etmDoubleUpperUnderlineWidth;
    SHORT  etmDoubleLowerUnderlineWidth;
    SHORT  etmStrikeOutOffset;
    SHORT  etmStrikeOutWidth;
    WORD   etmNKernPairs;
    WORD   etmNKernTracks;
} EXTTEXTMETRIC;

#define CHARSET_UNKNOWN     0
#define CHARSET_STANDARD    1
#define CHARSET_SPECIAL     2
#define CHARSET_EXTENDED    3

typedef struct _NTM {

    DWORD   dwSize;                 // size of font metrics data
    DWORD   dwVersion;              // NTFM version number
    DWORD   dwFlags;                // flags
    DWORD   dwFontNameOffset;       // offset to font name
    DWORD   dwDisplayNameOffset;    // offset to display name
    DWORD   dwFontVersion;          // font version number
    DWORD   dwGlyphSetNameOffset;   // offset to glyphset name
    DWORD   dwGlyphCount;           // number of glyphs supported
    DWORD   dwIFIMetricsOffset;     // offset to the first IFIMETRICS structure
    DWORD   dwIFIMetricsOffset2;    // offset to the second IFIMETRICS structure
    DWORD   dwCharWidthCount;       // number of char width entries
    DWORD   dwCharWidthOffset;      // offset to array char width entries
    DWORD   dwDefaultCharWidth;     // default glyph width
    DWORD   dwKernPairCount;        // number of FD_KERNINGPAIRs
    DWORD   dwKernPairOffset;       // offset to array of FD_KERNINGPAIRs
    DWORD   dwCharDefFlagOffset;    // offset to bit tbl of defined chars
    DWORD   dwCharSet;              // font character set
    DWORD   dwCodePage;             // font codepage
    DWORD   dwReserved[3];          // reserved
    EXTTEXTMETRIC etm;              // extended text metrics info

} NTM, *PNTM;

#define NTM_VERSION        0x00010000

// Macros to access NT font metrics structure.

#define NTM_GET_SIZE(pNTM)              (pNTM->dwSize)
#define NTM_GET_FLAGS(pNTM)             (pNTM->dwFlags)

#define NTM_GET_FONT_NAME(pNTM)         ((PSTR)MK_PTR(pNTM, dwFontNameOffset))
#define NTM_GET_DISPLAY_NAME(pNTM)      ((PWSTR)MK_PTR(pNTM, dwDisplayNameOffset))
#define NTM_GET_GLYPHSET_NAME(pNTM)     ((PSTR)MK_PTR(pNTM, dwGlyphSetNameOffset))

#define NTM_GET_GLYPHCOUNT(pNTM)        (pNTM->dwGlyphCount)

#define NTM_GET_IFIMETRICS(pNTM)        ((PIFIMETRICS)(MK_PTR(pNTM, dwIFIMetricsOffset)))
#define NTM_GET_IFIMETRICS2(pNTM)       ((PIFIMETRICS)(MK_PTR(pNTM, dwIFIMetricsOffset2)))

#define NTM_GET_CHARWIDTHCOUNT(pNTM)    (pNTM->dwCharWidthCount)
#define NTM_GET_CHARWIDTH(pNTM)         ((PWIDTHRUN)(MK_PTR(pNTM, dwCharWidthOffset)))

#define NTM_GET_DEFCHARWIDTH(pNTM)      (pNTM->dwDefaultCahrWidth)

#define NTM_GET_KERNPAIRCOUNT(pNTM)     (pNTM->dwKernPairCount)
#define NTM_GET_KERNPAIR(pNTM)          (MK_PTR(pNTM, dwKernPairOffset))

#define NTM_GET_CHARDEFTBL(pNTM)        (MK_PTR(pNTM, dwCharDefFlagOffset))

#define NTM_GET_CHARSET(pNTM)           (pNTM->dwCharSet)
#define NTM_GET_CODEPAGE(pNTM)          (pNTM->dwCodePage)

#define NTM_GET_ETM(pNTM)               (pNTM->etm)


#define CH_DEF(gi)                  (1 << ((gi) % 8))
#define CH_DEF_INDEX(gi)            ((gi) / 8)
#define NTM_CHAR_DEFINED(pNTM, gi) \
            (((PBYTE)MK_PTR((pNTM), dwCharDefFlagOffset))[CH_DEF_INDEX(gi)] & CH_DEF(gi))

typedef struct _WIDTHRUN {

    WORD    wStartGlyph;    // glyph handle of the first glyph
    WORD    wGlyphCount;    // number of glyphs covered
    DWORD   dwCharWidth;    // glyph width

} WIDTHRUN, *PWIDTHRUN;

#define WIDTHRUN_COMPLEX    0x80000000


#endif  //!_PSNTM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\psvmerr.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    psvmerr.h

Abstract:

    PostScript specific: definitions for localized virtual memory error message

Environment:

    Windows NT printer drivers

Revision History:

    03/31/98 -ksuzuki-
        Created it.

--*/


#ifndef _PSVMERR_H_
#define _PSVMERR_H_

#define REGVAL_VMERRORMESSAGEID TEXT("VMErrorMessageID")

//
// Localized VM error msg resource values except for US English. Make sure
// that values assigned here are different from the ones assigned to other
// PSPROC_xxxx_ps identifiers defined in PROCSET.H.
//
#define PSPROC_vmerr_Dutch_ps               70  //  vmerrdut.cps
#define PSPROC_vmerr_French_ps              71  //  vmerrfre.cps
#define PSPROC_vmerr_German_ps              72  //  vmerrger.cps
#define PSPROC_vmerr_Italian_ps             73  //  vmerrita.cps
#define PSPROC_vmerr_Portuguese_ps          74  //  vmerrpor.cps
#define PSPROC_vmerr_Spanish_ps             75  //  vmerrspa.cps
#define PSPROC_vmerr_Swedish_ps             76  //  vmerrswe.cps
#define PSPROC_vmerr_SimplifiedChinese_ps   77  //  vmerrsim.cps
#define PSPROC_vmerr_TraditionalChinese_ps  78  //  vmerrtra.cps
#define PSPROC_vmerr_Japanese_ps            79  //  vmerrjpn.cps
#define PSPROC_vmerr_Korean_ps              80  //  vmerrkor.cps
// Adobe bug #342407
#define PSPROC_vmerr_Danish_ps              81  //  vmerrdan.cps
#define PSPROC_vmerr_Finnish_ps             82  //  vmerrfin.cps
#define PSPROC_vmerr_Norwegian_ps           83  //  vmerrnor.cps

#endif // !_PSVMERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\win30def.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    win30def.h

Abstract:

    Windows 3.0 ( and 95) definitions

Environment:

    Windows NT printer drivers

Revision History:

    10/31/96 -eigos-
        Created it.

--*/


#ifndef _WIN30DEF_H_
#define _WIN30DEF_H_


//
//  The Windows 3.0 defintion of a POINT.  Note that the definition actually
//  uses int rather than short,  but in a 16 bit environment,  an int is
//  16 bits,  and so for NT we explicitly make them shorts.
//  The same applies to the RECT structure.
//

typedef struct
{
    short x;
    short y;
} POINTw;


typedef struct
{
    short  left;
    short  top;
    short  right;
    short  bottom;
} RECTw;

#ifndef max
#define max(a,b)        (((a) > (b)) ? (a) : (b))
#endif

#endif // _WIN30DEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\unirc.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    unirc.h

Abstract:

    Universal printer driver specific resource header
    This file contains definitions for tables contained in the resource file
    of the Mini Driver resource DLL. It should be shared by both gentool and the
    generic library.

Environment:

    Windows NT printer drivers

Revision History:

    11/05/96 -eigos-
        Created it.

--*/

#ifndef _UNIRC_H_
#define _UNIRC_H_

//
//  The following are the resource types used in minidrivers and
//  used in the .rc file.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// 5.0 resource types
//

#define RC_UFM         260
#define RC_GTT         261
#define RC_HTPATTERN   264
//
// Internal resource type
//

#define RC_FD_GLYPHSET 262


#endif // _UNIRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\sf_pcl.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    sf_pcl.h

Abstract:

     Structures etc used to define PCL Softfont file format.

[Environment:]

    Win32 subsystem, printer drivers

Revision History:

    03/05/97 -ganeshp-
        Created it.

--*/

/*
 *    A structure corresponding to the layout of Font Descriptor for a PCL
 *  soft font file.  The Font Descriptor is at the beginning of the file,
 *  and contains overall font info.
 *
 *    Note that there are several different versions of this structure;
 *  the first is the original (pre LJ4) format,  while the second is
 *  the LJ4 introduced variety that allows specifying the resolution
 *  at which the font was digitised.  This is used for downloading TT
 *  fonts etc. which are generated at the graphics resolution.
 *
 *    NOTE:  The data layout is designed for the 68000 family - which is
 *  big endian.  So,  an amount of shuffling is required for little
 *  endian machines like the x86.
 */

typedef  signed  char  SBYTE;

#define SFH_NM_SZ       16      /* Bytes allowed in name field */

typedef  struct
{
    WORD   wSize;               /* Number of bytes in here */
    BYTE   bFormat;             /* Format: original, TT, intellifont, etc */
    BYTE   bFontType;           /* 7, 8 or PC-8 style font */
    WORD   wRes1;               /* Reserved */
    WORD   wBaseline;           /* Baseline to cell top, PCL dots */
    WORD   wCellWide;           /* Cell width in dots */
    WORD   wCellHeight;         /* Cell height in dots */
    BYTE   bOrientation;        /* Orientation: 0 portrait, 1 Landscape */
    BYTE   bSpacing;            /* 0 fixed pitch, 1 proportional */
    WORD   wSymSet;             /* Symbol set, using HP encoding */
    WORD   wPitch;              /* Pitch in quarter dot units == HMI */
    WORD   wHeight;             /* Design height in quarter dot units */
    WORD   wXHeight;            /* Design height, quarter dots, of x */
    SBYTE  sbWidthType;         /* Relative width of glyphs */
    BYTE   bStyle;              /* 0 for regular, 1 for italic */
    SBYTE  sbStrokeW;           /* Stroke weight; -7 (thin) to +7 (thick) */
    BYTE   bTypeface;           /* Typeface ID - predefined types */
    BYTE   bRes2;
    BYTE   bSerifStyle;         /* Serif style; predefined values */
    WORD   wRes3;
    SBYTE  sbUDist;             /* Underline distance from baseline */
    BYTE   bUHeight;            /* Underline height */
    WORD   wTextHeight;         /* Quarter dot interline spacing */
    WORD   wTextWidth;          /* Quarter dot glyph increment */
    WORD   wRes4;
    WORD   wRes5;
    BYTE   bPitchExt;           /* Additional pitch resolution */
    BYTE   bHeightExt;          /* Ditto, for height */
    WORD   wRes6;
    WORD   wRes7;
    WORD   wRes8;
    char   chName[ SFH_NM_SZ ]; /* May not be null terminated! */
} SF_HEADER;


typedef  struct
{
    WORD   wSize;               /* Number of bytes in here */
    BYTE   bFormat;             /* Format: original, TT, intellifont, etc */
    BYTE   bFontType;           /* 7, 8 or PC-8 style font */
    WORD   wRes1;               /* Reserved */
    WORD   wBaseline;           /* Baseline to cell top, PCL dots */
    WORD   wCellWide;           /* Cell width in dots */
    WORD   wCellHeight;         /* Cell height in dots */
    BYTE   bOrientation;        /* Orientation: 0 portrait, 1 Landscape */
    BYTE   bSpacing;            /* 0 fixed pitch, 1 proportional */
    WORD   wSymSet;             /* Symbol set, using HP encoding */
    WORD   wPitch;              /* Pitch in quarter dot units == HMI */
    WORD   wHeight;             /* Design height in quarter dot units */
    WORD   wXHeight;            /* Design height, quarter dots, of x */
    SBYTE  sbWidthType;         /* Relative width of glyphs */
    BYTE   bStyle;              /* 0 for regular, 1 for italic */
    SBYTE  sbStrokeW;           /* Stroke weight; -7 (thin) to +7 (thick) */
    BYTE   bTypeface;           /* Typeface ID - predefined types */
    BYTE   bRes2;
    BYTE   bSerifStyle;         /* Serif style; predefined values */
    WORD   wRes3;
    SBYTE  sbUDist;             /* Underline distance from baseline */
    BYTE   bUHeight;            /* Underline height */
    WORD   wTextHeight;         /* Quarter dot interline spacing */
    WORD   wTextWidth;          /* Quarter dot glyph increment */
    WORD   wRes4;
    WORD   wRes5;
    BYTE   bPitchExt;           /* Additional pitch resolution */
    BYTE   bHeightExt;          /* Ditto, for height */
    WORD   wRes6;
    WORD   wRes7;
    WORD   wRes8;
    char   chName[ SFH_NM_SZ ]; /* May not be null terminated! */
    WORD   wXResn;              /* X resolution of font design */
    WORD   wYResn;              /* Y design resolution */
} SF_HEADER20;


/*
 *   Typical values used above to identify different types of fonts.
 */

#define PCL_FM_ORIGINAL     0     /* Bitmap font, digitised at 300 DPI */
#define PCL_FM_RESOLUTION  20     /* Bitmap font, includes digitised resn */
#define PCL_FM_TT          15     /* TT scalable, bound or unbound */
#define PCL_FM_2B_TT       16     /* TT 2 Byte (format 16) */


/*   bFontType values */

#define PCL_FT_7BIT     0       /* 7 bit: glyphs from 32 - 127 inc */
#define PCL_FT_8LIM     1       /* 8 bit, glyphs 32 - 127 & 160 - 255 */
#define PCL_FT_PC8      2       /* PC-8, glyphs 0 - 255, transparent too! */


/*   sbStrokeW values */

#define PCL_LIGHT       -3
#define PCL_BOLD         3



/*
 *   In addition,  each glyph in the font contains a Character Descriptor.
 *  So now define a structure for that too!
 */

typedef  struct
{
    BYTE    bFormat;            /* Format identifier: 4 for PCL 4 */
    BYTE    bContinuation;      /* Set if continuation of prior entry */
    BYTE    bDescSize;          /* Size of this structure */
    BYTE    bClass;             /* Format of data: 1 for PCL 4 */
    BYTE    bOrientation;       /* Zero == portrait; 1 == landscape */
    BYTE    bRes0;
    short   sLOff;              /* Dots from ref. to left side of char */
    short   sTOff;              /* Dots from ref. to top of char */
    WORD    wChWidth;           /* Char width in dots */
    WORD    wChHeight;          /* Char height in dots */
    WORD    wDeltaX;            /* Quarter dot position increment after print */
} CH_HEADER;

/*
 *   Character records can be continued due to the limit of 32767 bytes in
 * a PCL command sequence.  Continuation records have the following
 * format.  Really it is only the first two elements of the above
 * structure.
 */

typedef  struct
{
    BYTE    bFormat;            /* Format identifier; 4 for PCL 4 */
    BYTE    bContinuation;      /* TRUE if this is a continuation record */
}  CH_CONT_HDR;

/*
 *   Values for some of the fields in the above structs.
 */

/*  bFormat */
#define CH_FM_RASTER             4      /* Bitmap type */
#define CH_FM_SCALE             10      /* Intellifont scalable */

/*  bClass */
#define CH_CL_BITMAP            1       /* A bitmap font */
#define CH_CL_COMPBIT           2       /* Compressed bitmap */
#define CH_CL_CONTOUR           3       /* Intellifont scalable contour */
#define CH_CL_COMPCONT          4       /* Ditto, but compound contour */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\regdata.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    regdata.h

Abstract:

    Funtions for dealing with registry data

Environment:

    Win32 subsystem, printer drivers (kernel and user mode)

Revision History:

    02/04/97 -davidx-
        Use REG_MULTI_SZ instead of REG_BINARY where possible.

    09/25/96 -davidx-
        Functions to manipulate MultiSZ string pairs.

    09/25/96 -davidx-
        Convert to Hungarian notation.

    08/13/96 -davidx-
        New functions and interface.

    07/22/96 -srinivac-
        Updated for PSCRIPT5

    06/19/95 -davidx-
        Created it.

--*/

#ifndef _REGDATA_H_
#define _REGDATA_H_

//
// Value names for printer data in the registry
//

// values common to pscript and unidrv

#define REGVAL_PRINTER_DATA_SIZE    TEXT("PrinterDataSize")
#define REGVAL_PRINTER_DATA         TEXT("PrinterData")
#define REGVAL_FONT_SUBST_TABLE     TEXT("TTFontSubTable")
#define REGVAL_FORMS_ADDED          TEXT("Forms?")
#define REGVAL_PRINTER_INITED       TEXT("InitDriverVersion")
#define REGVAL_KEYWORD_NAME         TEXT("FeatureKeyword")
#define REGVAL_KEYWORD_SIZE         TEXT("FeatureKeywordSize")

#ifdef WINNT_40  // for NT4

#define REGVAL_INIDATA              TEXT("IniData4")

#else // for Win2K

#define REGVAL_INIDATA              TEXT("IniData5")

#endif // WINNT_40

// pscript specific

#define REGVAL_FREEMEM              TEXT("FreeMem")
#define REGVAL_JOBTIMEOUT           TEXT("JobTimeOut")
#define REGVAL_PROTOCOL             TEXT("Protocol")

// unidrv specific

#define REGVAL_CURRENT_DEVHTINFO    TEXT("CurDevHTInfo")
#define REGVAL_FONTCART             TEXT("FontCart")
#define REGVAL_PAGE_PROTECTION      TEXT("RasddFlags")
#define REGVAL_FONTFILENAME         TEXT("ExternalFontFile")
#define REGVAL_CARTRIDGEFILENAME    TEXT("ExtFontCartFile")
#define REGVAL_EXEFONTINSTALLER     TEXT("FontInstaller")
#define REGVAL_EXTFONTCART          TEXT("ExtFontCartNames")
#define REGVAL_PARTIALCLIP          TEXT("PartialClip")

// pscript 4.0 compatibility

#define REGVAL_FONT_SUBST_SIZE_PS40 TEXT("TTFontSubTableSize")
#define REGVAL_TRAY_FORM_TABLE_PS40 TEXT("TrayFormTable")
#define REGVAL_TRAY_FORM_SIZE_PS40  TEXT("TrayFormSize")

#define REGVAL_DEPFILES             TEXT("DependentFiles")
#define REGVAL_NTFFILENAME          TEXT("FontDownloaderNTF")

// rasdd 4.0 compatibility

#define REGVAL_TRAYFORM_TABLE_RASDD TEXT("TrayFormTable")
#define REGVAL_MODELNAME            TEXT("Model")
#define REGVAL_RASDD_FREEMEM        TEXT("FreeMem")

//
// delimiter for keyword name conversion
//

#define END_OF_FEATURE              '\n'

//
// Get a DWORD value from the registry under PrinerDriverData key
//

BOOL
BGetPrinterDataDWord(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    OUT PDWORD  pdwValue
    );

//
// Save a DWORD value to the registry under PrinerDriverData key
//

BOOL
BSetPrinterDataDWord(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    IN DWORD    dwValue
    );

//
// Get a string value from PrinterDriverData registry key
//

PTSTR
PtstrGetPrinterDataString(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    OUT PDWORD  pdwSize
    );

//
// Save a string or multi-sz value under PrinerDriverData registry key
//

BOOL
BSetPrinterDataString(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    IN LPCTSTR  ptstrValue,
    IN DWORD    dwType
    );



//
// Get a MULTI_SZ value from PrinerDriverData registry key
//

PTSTR
PtstrGetPrinterDataMultiSZPair(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    OUT PDWORD  pdwSize
    );

//
// Save a MULTI_SZ value under PrinerDriverData registry key
//

BOOL
BSetPrinterDataMultiSZPair(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    IN LPCTSTR  ptstrValue,
    IN DWORD    dwSize
    );


//
// Get binary data from the registry under PrinterDriverData key
//

PVOID
PvGetPrinterDataBinary(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrSizeKey,
    IN LPCTSTR  ptstrDataKey,
    OUT PDWORD  pdwSize
    );

//
// Save binary data to the registry under PrinterDriverData key
//

BOOL
BSetPrinterDataBinary(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrSizeKey,
    IN LPCTSTR  ptstrDataKey,
    IN PVOID    pvData,
    IN DWORD    dwSize
    );

//
// Functions for working with TrueType font substitution table:
//  Retrieve TrueType font substitution table from registry
//  Save TrueType font substitution table to registry
//  Find out the substituted device font given a TrueType font name
//
// TrueType font substitution table has a very simple structure.
// Each TrueType font name is followed is followed by its
// corresponding device font name. Font names are NUL-terminated
// character strings. The entire table is terminated by a NUL character.
// For example:
//
//  "Arial"     "Helvetica"
//  "Courier"   "Courier"
//  ...
//  ""
//

typedef PTSTR   TTSUBST_TABLE;

#define PGetTTSubstTable(hPrinter, pSize) \
        PtstrGetPrinterDataMultiSZPair(hPrinter, REGVAL_FONT_SUBST_TABLE, pSize)

#define PtstrSearchTTSubstTable(pTTSubstTable, ptstrTTFontName) \
        PtstrSearchStringInMultiSZPair(pTTSubstTable, ptstrTTFontName)

BOOL
BSaveTTSubstTable(
    IN HANDLE           hPrinter,
    IN TTSUBST_TABLE    pTTSubstTable,
    IN DWORD            dwSize
    );

//
// Functions for working with form-to-tray assignment table:
//  Retrieve form-to-tray assignment table from registry
//  Save form-to-tray assignment table to registry
//  Search form-to-tray assignment table
//
// The format of form-to-tray assignment table is fairly simple.
//  for each table entry:
//      tray name (NUL-terminated character string)
//      form name (NUL-terminated character string)
//  NUL terminator
//

typedef PTSTR   FORM_TRAY_TABLE;

FORM_TRAY_TABLE
PGetFormTrayTable(
    IN HANDLE   hPrinter,
    OUT PDWORD  pdwSize
    );

BOOL
BSaveFormTrayTable(
    IN HANDLE           hPrinter,
    IN FORM_TRAY_TABLE  pFormTrayTable,
    IN DWORD            dwSize
    );

//
// These functions are implemented in lib\ps and lib\uni.
//
// If there is no new format form-to-tray table, PGetFormTrayTable will
// call PGetAndConvertOldVersionFormTrayTable to see if any old version
// form-to-tray table exists and can be converted to the new format.
//
// BSaveFormTrayTable calls BSaveAsOldVersionFormTrayTable to save
// a form-tray table in NT 4.0 compatible format.
//

FORM_TRAY_TABLE
PGetAndConvertOldVersionFormTrayTable(
    IN HANDLE           hPrinter,
    OUT PDWORD          pdwSize
    );

BOOL
BSaveAsOldVersionFormTrayTable(
    IN HANDLE           hPrinter,
    IN FORM_TRAY_TABLE  pFormTrayTable,
    IN DWORD            dwSize
    );

//
// Macros for accessing font cartridge registry data
//

#define PtstrGetFontCart(hPrinter, pSize) \
        PtstrGetPrinterDataString(hPrinter, REGVAL_FONTCART, pSize)

#define BSaveFontCart(hPrinter, pFontCart) \
        BSetPrinterDataString(hPrinter, REGVAL_FONTCART, pFontCart, REG_MULTI_SZ)

//
// Data structure for storing the result of searching form-to-tray assignment table
//

typedef struct _FINDFORMTRAY {

    PVOID       pvSignature;        // signature
    PTSTR       ptstrTrayName;      // tray name
    PTSTR       ptstrFormName;      // form name
    PTSTR       ptstrNextEntry;     // where to start the next search

} FINDFORMTRAY, *PFINDFORMTRAY;

BOOL
BSearchFormTrayTable(
    IN FORM_TRAY_TABLE      pFormTrayTable,
    IN PTSTR                ptstrTrayName,
    IN PTSTR                ptstrFormName,
    IN OUT PFINDFORMTRAY    pFindData
    );

//
// Initialize FINDFORMTRAY structure. This must be called before calling
// BSearchFormTrayTable for the first time.
//

#define RESET_FINDFORMTRAY(pFormTrayTable, pFindData) \
        { \
            (pFindData)->pvSignature = (pFindData); \
            (pFindData)->ptstrNextEntry = (pFormTrayTable); \
        }

//
// Printer sticky properties
//

typedef struct _PRINTERDATA {

    WORD      wDriverVersion;                       // driver version number
    WORD      wSize;                                // size of the structure
    DWORD     dwFlags;                              // flags
    DWORD     dwFreeMem;                            // amount of free memory
    DWORD     dwJobTimeout;                         // job timeout
    DWORD     dwWaitTimeout;                        // wait timeout
    WORD      wMinoutlinePPEM;                      // min size to download as Type1
    WORD      wMaxbitmapPPEM;                       // max size to download as Type3
    DWORD     dwReserved1[3];                       // reserved space

    WORD      wReserved2;                           // old 16-bit checksum set to 0
    WORD      wProtocol;                            // output protocol
    DWORD     dwChecksum32;                         // checksum of printer description file
    DWORD     dwOptions;                            // number of printer-sticky features
    OPTSELECT aOptions[MAX_PRINTER_OPTIONS];        // installable options

} PRINTERDATA, *PPRINTERDATA;

//
// Constant flags for PRINTERDATA.dwFlags field
//

#define PFLAGS_METRIC           0x0001              // running on metric system
#define PFLAGS_HOST_HALFTONE    0x0002              // use host halftoning
#define PFLAGS_IGNORE_DEVFONT   0x0004              // ignore device fonts
#define PFLAGS_SLOW_FONTSUBST   0x0008              // slow but accurate font subst
#define PFLAGS_NO_HEADERPERJOB  0x0010              // don't download header with job
#define PFLAGS_PAGE_PROTECTION  0x0020              // page protection is turned on
#define PFLAGS_CTRLD_BEFORE     0x0040              // send ^D before each job
#define PFLAGS_CTRLD_AFTER      0x0080              // send ^D after each job

#define PFLAGS_TRUE_GRAY_TEXT   0x0100              // enable TrueGray detection
#define PFLAGS_TRUE_GRAY_GRAPH  0x0200              // enable TrueGray detection
#define PERFORM_TRUE_GRAY_TEXT(pdev)   ((pdev)->PrinterData.dwFlags & PFLAGS_TRUE_GRAY_TEXT)
#define PERFORM_TRUE_GRAY_GRAPH(pdev)  ((pdev)->PrinterData.dwFlags & PFLAGS_TRUE_GRAY_GRAPH)

#define PFLAGS_ADD_EURO         0x0400              // enable Euro augmentation
#define PFLAGS_EURO_SET         0x0800              // set if PFLAGS_ADD_EURO has been set to it's current value intentionally
                                                    // as opposed to just because it wasn't set in an older version
#define PERFORM_ADD_EURO(pdev)    (((pdev)->PrinterData.dwFlags & PFLAGS_ADD_EURO) && \
                                    (TARGET_PSLEVEL(pdev) >= 2))


//
// Default Max/Min point sizes in PPEM for switching between Type1 and Type3
//

#define DEFAULT_MINOUTLINEPPEM  100
#define DEFAULT_MAXBITMAPPPEM   600

//
// Functions for accessing printer properties data:
//  retrieve printer property data in the registry
//  get the default printer property data
//  save printer property data to registry
//

BOOL
BGetPrinterProperties(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData
    );

BOOL
BGetDefaultPrinterProperties(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData
    );

BOOL
BSavePrinterProperties(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData,
    IN  PPRINTERDATA    pPrinterData,
    IN  DWORD           dwSize
    );

BOOL
BConvertPrinterPropertiesData(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData,
    IN PVOID            pvSrcData,
    IN DWORD            dwSrcSize
    );

VOID
VUpdatePrivatePrinterData(
    IN HANDLE           hPrinter,
    IN OUT PPRINTERDATA pPrinterData,
    IN DWORD            dwMode,
    IN PUIINFO          pUIInfo,
    IN POPTSELECT       pCombineOptions
    );

#define MODE_READ       0
#define MODE_WRITE      1


//
// NT4 PS driver PRINTERDATA structure
//

typedef struct _PS4_PRINTERDATA {
    WORD    wDriverVersion;                     // driver version number
    WORD    wSize;                              // size of the structure
    DWORD   dwFlags;                            // flags
    DWORD   dwFreeVm;                           // amount of VM
    DWORD   dwJobTimeout;                       // job timeout
    DWORD   dwWaitTimeout;                      // wait timeout
    DWORD   dwReserved[4];                      // reserved space
    WORD    wChecksum;                          // PPD file checksum
    WORD    wOptionCount;                       // number of options to follow
    BYTE    options[64];                        // installable options
} PS4_PRINTERDATA, *PPS4_PRINTERDATA;

//
// Retrieve device halftone setup information from registry
//

BOOL
BGetDeviceHalftoneSetup(
    HANDLE      hPrinter,
    DEVHTINFO  *pDevHTInfo
    );

//
// Save device halftone setup information to registry
//

BOOL
BSaveDeviceHalftoneSetup(
    HANDLE      hPrinter,
    DEVHTINFO  *pDevHTInfo
    );

//
// Figure out printer driver directory from the driver DLL's full pathname
//

PTSTR
PtstrGetDriverDirectory(
    IN LPCTSTR  ptstrDriverDllPath
    );

//
// Search the list of dependent files (in REG_MULTI_SZ format)
// for a file with the specified extension
//

LPCTSTR
PtstrSearchDependentFileWithExtension(
    IN LPCTSTR  ptstrDependentFiles,
    IN LPCTSTR  ptstrExtension
    );

//
// Verify the input data block is in REG_MULTI_SZ format and
// it consists of multiple string pairs
//

BOOL
BVerifyMultiSZPair(
    IN LPCTSTR  ptstrData,
    IN DWORD    dwSize
    );

BOOL
BVerifyMultiSZ(
    IN LPCTSTR  ptstrData,
    IN DWORD    dwSize
    );

DWORD
DwCountStringsInMultiSZ(
    IN LPCTSTR ptstrData
    );


//
// Search for the specified key in MultiSZ key-value string pairs
//

LPCTSTR
PtstrSearchStringInMultiSZPair(
    IN LPCTSTR  ptstrMultiSZ,
    IN LPCTSTR  ptstrKey
    );

#endif //!_REGDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\unilib.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    unilib

Abstract:

    Unidrv specific library functions

Environment:

    Windows NT printer drivers

Revision History:

    10/15/96 -amandan-
        Created it.

--*/


#ifndef _UNILIB_H_
#define _UNILIB_H_

//
// Alignment functions
//

WORD
DwAlign2(
    IN PBYTE pubData);

DWORD
DwAlign4(
    IN PBYTE pubData);


//
// String handling function
// Convert Unicode string to multi-byte string and vice versa
//

DWORD
DwCopyStringToUnicodeString(
    IN  UINT  uiCodePage,
    IN  PSTR  pstrCharIn,
    OUT PWSTR pwstrCharOut,
    IN  INT   iwcOutSize);

DWORD
DwCopyUnicodeStringToString(
    IN  UINT  uiCodePage,
    IN  PWSTR pwstrCharIn,
    OUT PSTR  pstrCharOut,
    IN  INT   icbOutSize);


//
// CodePage and Character set handling functions
//

ULONG
UlCharsetToCodePage(
    IN UINT uiCharSet);

#ifdef KERNEL_MODE


//
// These are safer versions of iDrvPrintfA/W designed to prevent 
// buffer overflow. Only these safer versions should be used.
//
#ifdef __cplusplus
extern "C" {
#endif

INT iDrvPrintfSafeA (
        IN        PCHAR pszDest,
        IN  CONST ULONG cchDest,
        IN  CONST PCHAR pszFormat,
        IN  ...);

INT iDrvPrintfSafeW (
        IN        PWCHAR pszDest,
        IN  CONST ULONG  cchDest,
        IN  CONST PWCHAR pszFormat,
        IN  ...);

INT iDrvVPrintfSafeA (
        IN        PCHAR   pszDest,
        IN  CONST ULONG   cchDest,
        IN  CONST PCHAR   pszFormat,
        IN        va_list arglist);


INT iDrvVPrintfSafeW (
        IN        PWCHAR pszDest,
        IN  CONST ULONG  cchDest,
        IN  CONST PWCHAR pszFormat,
        IN        va_list arglist);
#ifdef __cplusplus
}
#endif

#endif //KERNEL_MODE

//
// Font installer font file directory
//  %SystemRoot%\system32\spool\drivers\unifont\
//

#define FONTDIR                 TEXT("\\unifont\\")

#endif // !_UNILIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\winsplkm.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    winsplkm.h

Abstract:

    Duplicate definitions for some of the stuff in winspool.h.
    They are duplicated here because kernel mode components cannot include winspool.h

Environment:

    Windows NT printer driver

Revision History:

    01/22/97 -davidx-
        Created it.

--*/


#ifndef _WINSPLKM_H_
#define _WINSPLKM_H_

typedef struct _FORM_INFO_1 {
    DWORD   Flags;
    PWSTR   pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1, *PFORM_INFO_1;

#define FORM_USER    0x0000
#define FORM_BUILTIN 0x0001
#define FORM_PRINTER 0x0002

typedef struct _DRIVER_INFO_2 {
    DWORD   cVersion;
    PWSTR   pName;
    PWSTR   pEnvironment;
    PWSTR   pDriverPath;
    PWSTR   pDataFile;
    PWSTR   pConfigFile;
} DRIVER_INFO_2, *PDRIVER_INFO_2;

typedef struct _DRIVER_INFO_3 {
    DWORD   cVersion;
    PWSTR   pName;
    PWSTR   pEnvironment;
    PWSTR   pDriverPath;
    PWSTR   pDataFile;
    PWSTR   pConfigFile;
    PWSTR   pHelpFile;
    PWSTR   pDependentFiles;
    PWSTR   pMonitorName;
    PWSTR   pDefaultDataType;
} DRIVER_INFO_3, *PDRIVER_INFO_3;

typedef struct _PRINTER_INFO_2 {
    PWSTR    pServerName;
    PWSTR    pPrinterName;
    PWSTR    pShareName;
    PWSTR    pPortName;
    PWSTR    pDriverName;
    PWSTR    pComment;
    PWSTR    pLocation;
    PDEVMODE pDevMode;
    PWSTR    pSepFile;
    PWSTR    pPrintProcessor;
    PWSTR    pDatatype;
    PWSTR    pParameters;
    PVOID    pSecurityDescriptor;
    DWORD    Attributes;
    DWORD    Priority;
    DWORD    DefaultPriority;
    DWORD    StartTime;
    DWORD    UntilTime;
    DWORD    Status;
    DWORD    cJobs;
    DWORD    AveragePPM;
} PRINTER_INFO_2, *PPRINTER_INFO_2;

#endif  // !_WINSPLKM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\inc\winres.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    winres.h

Abstract:

    This file contain structure and function prototypes required for
    obtaining resource data from windows files

Environment:

        Windows NT Unidrv driver

Revision History:

    dd-mm-yy -author-
         description

--*/

#ifndef _WINRES_H_
#define _WINRES_H_

//
// Maximum number of resources DLLs per minidriver.
//
#define     MAX_RESOURCE                0x80
#define     RCID_DMPAPER_SYSTEM_NAME    0x7fffffff

typedef  struct _WINRESDATA
{
    HANDLE      hResDLLModule;          // Module handle Root resource DLL
    DWORD       cLoadedEntries;         // Number of Resource Dlls loaded
    HANDLE      ahModule[MAX_RESOURCE]; // Module handle array for other resources
    WCHAR       wchDriverDir[MAX_PATH]; // Driver Directory
    PWSTR       pwstrLastBackSlash;     // Pointer to last back slash in Driver dir.
    PUIINFO     pUIInfo;                // Pointer to UI Info
} WINRESDATA,  *PWINRESDATA;


//
//  The structure passed to,  and filled in by, GetWinRes().  Contains
//  information about a specific resource type & name.
//

typedef  struct
{
    VOID    *pvResData;         // Address of data
    INT     iResLen;            // Resource size
} RES_ELEM;

#define WINRT_STRING    6       // Minidriver string resource ID

BOOL
BInitWinResData(
    WINRESDATA  *pWinResData,
    PWSTR       pwstrDriverName,
    PUIINFO     pUIInfo
    );

HANDLE
HGetModuleHandle(
    WINRESDATA      *pWinResData,
    PQUALNAMEEX     pQualifiedID
);

BOOL
BGetWinRes(
    WINRESDATA  *pWinResData,
    PQUALNAMEEX pQualifiedID,
    INT         iType,
    RES_ELEM    *pRInfo
    );

VOID
VWinResClose(
    WINRESDATA  *pWinResData
    );

INT
ILoadStringW (
    WINRESDATA  *pWinResData,
    INT         iID,
    PWSTR       wstrBuf,
    WORD        wBuf
    );

#endif // ! _WINRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\helper\sources.inc ===
!IF 0

Copyright (c) 1996-1997  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

SOURCES=..\helper.c     \
        ..\parseini.c  \
        ..\appcompat.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\helper\appcompat.c ===
/*++
Copyright (c) 2000, Microsoft Corporation

Module Name:

    appcompat.c

Abstract:

    App compat functions that is not published in the DDK but that we need to build the printer drivers off it.
    Normally they reside in winuserp.h/user32p.lib.

--*/

#ifdef BUILD_FROM_DDK

#include "lib.h"
#include "appcompat.h"

typedef DWORD (* LPFN_GET_APP_COMPAT_FLAGS_2)(WORD);

DWORD GetAppCompatFlags2(WORD wVersion)
{
    HINSTANCE hUser;
    LPFN_GET_APP_COMPAT_FLAGS_2 pfnGetAppCompatFlags2;
    DWORD dwRet;

    if (!(hUser = LoadLibrary(TEXT("user32.dll"))) ||
        !(pfnGetAppCompatFlags2 = (LPFN_GET_APP_COMPAT_FLAGS_2)
            GetProcAddress(hUser, "GetAppCompatFlags2")))
    {
        if (hUser)
        {
            ERR(("Couldn't find GetAppCompatFlags2 in user32.dll: %d\n", GetLastError()));
            FreeLibrary(hUser);
        }
        else
            ERR(("Couldn't load user32.dll: %d\n", GetLastError()));

        return 0;
    }

    dwRet = pfnGetAppCompatFlags2(wVersion);

    FreeLibrary(hUser);

    return dwRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\helper\helper.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    helper.c

Abstract:

    Helper functions

Environment:

    Windows NT printer drivers

Revision History:

--*/

#include "lib.h"

VOID
VFreeParserInfo(
    IN  PPARSERINFO pParserInfo
    )
/*++

Routine Description:

    This function frees and unload binary data

Arguments:

    pParserInfo - Pointer to parser information

Return Value:

    None

--*/
{
    if (pParserInfo->pInfoHeader)
    {
        FreeBinaryData(pParserInfo->pInfoHeader);
        pParserInfo->pInfoHeader = NULL;
    }

    if ( pParserInfo->pRawData)
    {
        UnloadRawBinaryData(pParserInfo->pRawData);
        pParserInfo->pRawData = NULL;
    }
}


PUIINFO
PGetUIInfo(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData,
    IN  POPTSELECT      pCombineOptions,
    IN  POPTSELECT      pOptions,
    OUT PPARSERINFO     pParserInfo,
    OUT PDWORD          pdwFeatureCount
    )
/*++

Routine Description:

    This function loads up the binary data and returns the pUIInfo

Arguments:

    hPrinter - Identifies the printer in question
    pRawData - Points to raw binary printer description data
    pCombineOptions - Points to buffer to contain the combined options array
    pParserInfo - Points to struct that contains pInfoHeader and pRawData
    pdwFeatureCount - Retrieve the count of the features

Return Value:

    Point to UIINFO struct

--*/
{
    OPTSELECT       DocOptions[MAX_PRINTER_OPTIONS], PrinterOptions[MAX_PRINTER_OPTIONS];
    PINFOHEADER     pInfoHeader = NULL;
    PUIINFO         pUIInfo = NULL;

    ASSERT(pRawData != NULL);

    if (pOptions == NULL)
    {
        if (! InitDefaultOptions(pRawData,
                                 PrinterOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_PRINTER_STICKY))
            goto getuiinfo_exit;
    }

    if (! InitDefaultOptions(pRawData,
                             DocOptions,
                             MAX_PRINTER_OPTIONS,
                             MODE_DOCUMENT_STICKY))
        goto getuiinfo_exit;

    //
    // Combine doc sticky options with printer sticky items
    //

    CombineOptionArray(pRawData,
                       pCombineOptions,
                       MAX_COMBINED_OPTIONS,
                       DocOptions,
                       pOptions ? pOptions : PrinterOptions);

    //
    // Get an updated instance of printer description data
    //

    pInfoHeader = InitBinaryData(pRawData,
                                 NULL,
                                 pCombineOptions);

    if (pInfoHeader == NULL)
    {
        ERR(("InitBinaryData failed\n"));
        goto getuiinfo_exit;
    }

    pUIInfo = OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loUIInfoOffset);

    if (pdwFeatureCount)
        *pdwFeatureCount = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;

getuiinfo_exit:

    //
    // PGetUIInfo always use the passed in pRawData. We assign NULL to
    // pParserInfo->pRawData, so VFreeParserInfo won't unload it.
    //

    pParserInfo->pRawData = NULL;
    pParserInfo->pInfoHeader = pInfoHeader;

    if (pUIInfo == NULL)
        VFreeParserInfo(pParserInfo);

    return pUIInfo;
}

PSTR
PstrConvertIndexToKeyword(
    IN  HANDLE      hPrinter,
    IN  POPTSELECT  pOptions,
    IN  PDWORD      pdwKeywordSize,
    IN  PUIINFO     pUIInfo,
    IN  POPTSELECT  pCombineOptions,
    IN  DWORD       dwFeatureCount
    )
/*++

Routine Description:

    This function convert the indexed based pOptions array to
    Feature.Option keywordname.

Arguments:

    hPrinter - Identifies the printer in question
    pOptions - Index based optionsarray (pPrinterData->aOptions)
    pdwKeywordSize - Retrieve the size of the buffer to write to registry
    pUIInfo - Pointer to UIINFO
    pCombinedOptions - Pointer to the combined options
    dwFeatureCount - Number of features in pCombinedOptions

Return Value:

    Pointer to buffer containing Feature.Option keyword names

--*/
{

    PFEATURE pFeature;
    POPTION  pOption;
    PSTR     pstrKeywordBuf, pstrEnd, pstrBufTop = NULL;
    DWORD    i;
    PSTR    pFeatureKeyword, pOptionKeyword;
    BYTE    ubNext, ubCurOptIndex;

    if ((pCombineOptions && pUIInfo && dwFeatureCount) &&
        (pUIInfo->dwMaxPrnKeywordSize) &&
        (pFeature = PGetIndexedFeature(pUIInfo, 0)) &&
        (pstrBufTop = pstrKeywordBuf = MemAllocZ( pUIInfo->dwMaxPrnKeywordSize )))
    {
        pstrEnd = pstrBufTop + pUIInfo->dwMaxPrnKeywordSize;

        for (i = 0; i < dwFeatureCount; i++ , pFeature++)
        {
            if (pFeature && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY)
            {
                pFeatureKeyword = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                    pFeature->loKeywordName);
                ASSERT(pFeatureKeyword != NULL);

                if (pFeatureKeyword != NULL)
                {
                    StringCchCopyA(pstrKeywordBuf, pstrEnd - pstrKeywordBuf, pFeatureKeyword);
                    pstrKeywordBuf += strlen(pFeatureKeyword) + 1;
                }

                if ((pFeatureKeyword == NULL) || (pstrKeywordBuf >= pstrEnd))
                {
                    ERR(("ConvertToKeyword, Feature failed"));
                    MemFree(pstrBufTop);
                    pstrBufTop = NULL;
                    goto converttokeyword_exit;
                }

                //
                // Handle multiple selections
                //

                ubNext = (BYTE)i;

                while (1)
                {
                    if (ubNext == NULL_OPTSELECT )
                        break;

                    ubCurOptIndex = pCombineOptions[ubNext].ubCurOptIndex;

                    pOption = PGetIndexedOption(pUIInfo, pFeature,
                                                ubCurOptIndex == OPTION_INDEX_ANY ?
                                                0 : ubCurOptIndex);

                    ubNext = pCombineOptions[ubNext].ubNext;

                    ASSERT(pOption != NULL);

                    if (pOption == NULL)
                        break;

                    pOptionKeyword = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                       pOption->loKeywordName);

                    ASSERT(pOptionKeyword != NULL);

                    if (pOptionKeyword != NULL)
                    {
                        StringCchCopyA(pstrKeywordBuf, pstrEnd - pstrKeywordBuf, pOptionKeyword);
                        pstrKeywordBuf += strlen(pOptionKeyword) + 1;
                    }

                    if ((pOptionKeyword == NULL) || (pstrKeywordBuf >= pstrEnd))
                    {
                        ERR(("ConvertToKeyword, Option failed"));
                        MemFree(pstrBufTop);
                        pstrBufTop = NULL;
                        goto converttokeyword_exit;
                    }
                }

                //
                // terminate the Feature.Option... with valid delimiter
                //

                *pstrKeywordBuf++ = END_OF_FEATURE;

                if (pstrKeywordBuf >= pstrEnd)
                {
                    ERR(("ConvertToKeyword, Over writing buffer"));
                    MemFree(pstrBufTop);
                    pstrBufTop = NULL;
                    goto converttokeyword_exit;
                }
            }
        }

        //
        // Add 2 NULs termination for MULTI_SZ buffer
        //
        if ((pstrEnd - pstrKeywordBuf) < 2)
        {
            ERR(("ConvertToKeyword, Over writing buffer"));
            MemFree(pstrBufTop);
            pstrBufTop = NULL;
            goto converttokeyword_exit;
        }

        *pstrKeywordBuf++ = NUL;
        *pstrKeywordBuf++ = NUL;

        if (pdwKeywordSize)
            *pdwKeywordSize = (DWORD)(pstrKeywordBuf - pstrBufTop);

    }

converttokeyword_exit:

    return pstrBufTop;

}

VOID
VConvertKeywordToIndex(
    IN  HANDLE          hPrinter,
    IN  PSTR            pstrKeyword,
    IN  DWORD           dwKeywordSize,
    OUT POPTSELECT      pOptions,
    IN  PRAWBINARYDATA  pRawData,
    IN  PUIINFO         pUIInfo,
    IN  POPTSELECT      pCombineOptions,
    IN  DWORD           dwFeatureCount
    )

/*++

Routine Description:


Arguments:

    hPrinter - Identifies the printer in question
    ptstrKeyword - Buffer containing Feature.Option keyword names
    pOptions - Index based options array contain the conversion
    pUIInfo - Pointer to UIINFO
    pCombinedOptions - Pointer to the combined options
    dwFeatureCount - Number of features in pCombinedOptions


Return Value:

    None, if for some reasons we could not convert, we get the default.

--*/

{
    PSTR       pstrEnd = pstrKeyword + dwKeywordSize;


    if (pCombineOptions && pUIInfo && dwFeatureCount)
    {

        CHAR     achName[256];
        BOOL     abEnableOptions[MAX_PRINTER_OPTIONS];
        PFEATURE pFeature;
        POPTION  pOption;
        DWORD    dwFeatureIndex, dwOptionIndex = OPTION_INDEX_ANY;

        while (pstrKeyword < pstrEnd && *pstrKeyword != NUL)
        {
            ZeroMemory(abEnableOptions, sizeof(abEnableOptions));

            //
            // Get the feature keyword name
            //

            StringCchCopyA(achName, CCHOF(achName), pstrKeyword);
            pstrKeyword += strlen(achName) + 1;

            if (pstrKeyword >= pstrEnd)
            {
                ERR(("Feature: Over writing the allocated buffer \n"));
                goto converttoindex_exit;
            }

            pFeature = PGetNamedFeature(pUIInfo,
                                        achName,
                                        &dwFeatureIndex);

            if (pFeature == NULL)
            {
                //
                // If we can't map the registry Feature name to a valid feature,
                // we need to skip all the feature's option names in the registry.
                //

                while (*pstrKeyword != END_OF_FEATURE && pstrKeyword < pstrEnd)
                    pstrKeyword++;

                pstrKeyword++;
                continue;
            }

            //
            // Handle multiple selection
            //

            while (pstrKeyword < pstrEnd && *pstrKeyword != END_OF_FEATURE)
            {
                StringCchCopyA(achName, CCHOF(achName), pstrKeyword);
                pstrKeyword += strlen(achName) + 1;

                if (pstrKeyword >= pstrEnd)
                {
                    ERR(("Option: Over writing the allocated buffer \n"));
                    goto converttoindex_exit;
                }

                pOption = PGetNamedOption(pUIInfo,
                                          pFeature,
                                          achName,
                                          &dwOptionIndex);
                if (pOption)
                    abEnableOptions[dwOptionIndex] = TRUE;
            }

            if (dwOptionIndex != OPTION_INDEX_ANY)
                ReconstructOptionArray(pRawData,
                                       pCombineOptions,
                                       MAX_COMBINED_OPTIONS,
                                       dwFeatureIndex,
                                       abEnableOptions);

            //
            // skip our delimiter to go to next feature
            //

            pstrKeyword++;

        }

        SeparateOptionArray(pRawData,
                            pCombineOptions,
                            pOptions,
                            MAX_PRINTER_OPTIONS,
                            MODE_PRINTER_STICKY);
    }

converttoindex_exit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\mini\mini.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    libutil.c

Abstract:

    Utility functions

Environment:

    Windows NT printer drivers

Revision History:

    08/13/96 -davidx-
        Added CopyString functions and moved SPRINTF functions.

    08/13/96 -davidx-
        Added devmode conversion routine and spooler API wrapper functions.

    03/13/96 -davidx-
        Created it.

--*/

#include <lib.h>

#if DBG

//
// Variable to control the amount of debug messages generated
//

INT giDebugLevel = DBG_WARNING;

PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\helper\parseini.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parseini.c

Abstract:

    Process model-specific printer INI file, if any

Environment:

    Windows NT printer driver

Revision History:

    01/22/97 -davidx-
        Allow ANSI-format INI file as well.

    01/21/97 -davidx-
        Created it.

--*/

#include "lib.h"

#define INI_FILENAME_EXT            TEXT(".INI")
#define INI_COMMENT_CHAR            '#'
#define OEMFILES_SECTION            "[OEMFiles]"
#define INI_COMMENT_CHAR_UNICODE    L'#'
#define OEMFILES_SECTION_UNICODE    L"[OEMFiles]"



DWORD
DwCopyAnsiCharsToUnicode(
    PSTR    pstr,
    DWORD   dwLength,
    PWSTR   pwstr)

/*++

Routine Description:

    Convert the specified ANSI source string into a Unicode string.
    It doesn't assume the ANSI source string is NULL terminated.

Arguments:

    pstr - Points to the ANSI source string
    dwLength - Specifies number of bytes in the ANSI source string
    pwstr - Points to the buffer where the resulting Unicode string is returned

Return Value:

    Number of wide characters written to the buffer pointed to by pwstr

--*/

{
    ULONG   ulBytesWritten;

    #if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

    return MultiByteToWideChar(CP_ACP, 0, pstr, dwLength, pwstr, dwLength);

    #else // NT4 kernel mode render module

    EngMultiByteToUnicodeN(pwstr, dwLength*sizeof(WCHAR), &ulBytesWritten, (PCHAR)pstr, dwLength);

    return (DWORD)(ulBytesWritten / sizeof(WCHAR));

    #endif
}



PWSTR
PwstrParsePrinterIniFileW(
    PWSTR   pwstrFileData,
    DWORD   dwCharCount,
    PDWORD  pdwReturnSize
    )

/*++

Routine Description:

    Parse a model-specific printer INI file (Unicode text) and
    assemble all key=value entries into MultiSZ string pairs

Arguments:

    pwstrFileData - Points to printer INI file data (Unicode text file)
    dwCharCount - Size of printer INI file (in characters)
    pdwReturnSize - Return size of the parsed MultiSZ data (in bytes)

Return Value:

    Pointer to parsed MultiSZ data, NULL if there is an error

--*/

{
    PWSTR   pwstrCurLine, pwstrNextLine;
    PWSTR   pwstrLineEnd, pwstrFileEnd;
    PWSTR   pwstrEqual, pwstrResult, pwstr;
    DWORD   dwLength;
    BOOL    bOEMFilesSection = FALSE;

    //
    // Allocate a buffer to hold the parsed data.
    // We ask for a size equaling to that of the original file.
    // This may be a little redundant but it's better than
    // having to go through the data twice.
    //

    *pdwReturnSize = 0;

    if (! (pwstrResult = MemAlloc(sizeof(WCHAR) * (dwCharCount + 2))))
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    pwstr = pwstrResult;
    pwstrFileEnd = pwstrFileData + dwCharCount;

    for (pwstrCurLine = pwstrFileData;
         pwstrCurLine < pwstrFileEnd;
         pwstrCurLine = pwstrNextLine)
    {
        //
        // Find the end of current line and
        // the beginning of next line
        //

        pwstrLineEnd = pwstrCurLine;

        while (pwstrLineEnd < pwstrFileEnd &&
               *pwstrLineEnd != L'\r' &&
               *pwstrLineEnd != L'\n')
        {
            pwstrLineEnd++;
        }

        pwstrNextLine = pwstrLineEnd;

        while ((pwstrNextLine < pwstrFileEnd) &&
               (*pwstrNextLine == L'\r' ||
                *pwstrNextLine == L'\n'))
        {
            pwstrNextLine++;
        }

        //
        // Throw away leading and trailing spaces
        // and ignore empty and comment lines
        //

        while (pwstrCurLine < pwstrLineEnd && iswspace(*pwstrCurLine))
            pwstrCurLine++;

        while (pwstrLineEnd > pwstrCurLine && iswspace(pwstrLineEnd[-1]))
            pwstrLineEnd--;

        if (pwstrCurLine >= pwstrLineEnd || *pwstrCurLine == INI_COMMENT_CHAR_UNICODE)
            continue;

        //
        // Handle [section] entries
        //

        if (*pwstrCurLine == L'[')
        {
            dwLength = (DWORD)(pwstrLineEnd - pwstrCurLine);

            bOEMFilesSection =
                dwLength == wcslen(OEMFILES_SECTION_UNICODE) &&
                _wcsnicmp(pwstrCurLine, OEMFILES_SECTION_UNICODE, dwLength) == EQUAL_STRING;

            if (! bOEMFilesSection)
                TERSE(("[Section] entry ignored\n"));

            continue;
        }

        //
        // Ignore all entries outside of [OEMFiles] section
        //

        if (! bOEMFilesSection)
        {
            TERSE(("Entries outside of [OEMFiles] section ignored\n"));
            continue;
        }

        //
        // Find the first occurrence of = character
        //

        pwstrEqual = pwstrCurLine;

        while (pwstrEqual < pwstrLineEnd && *pwstrEqual != L'=')
            pwstrEqual++;

        if (pwstrEqual >= pwstrLineEnd || pwstrEqual == pwstrCurLine)
        {
            WARNING(("Entry not in the form of key=value\n"));
            continue;
        }

        //
        // Add the key/value pair to the result buffer
        //

        if ((dwLength = (DWORD)(pwstrEqual - pwstrCurLine)) != 0)
        {
            CopyMemory(pwstr, pwstrCurLine, dwLength*sizeof(WCHAR));
            pwstr += dwLength;
        }
        *pwstr++ = NUL;

        pwstrEqual++;

        if ((dwLength = (DWORD)(pwstrLineEnd - pwstrEqual)) > 0)
        {
            CopyMemory(pwstr, pwstrEqual, dwLength*sizeof(WCHAR));
            pwstr += dwLength;
        }
        *pwstr++ = NUL;
    }

    *pwstr++ = NUL;
    *pdwReturnSize =(DWORD)((pwstr - pwstrResult) * sizeof(WCHAR));
    return pwstrResult;
}



PWSTR
PwstrParsePrinterIniFileA(
    PSTR    pstrFileData,
    DWORD   dwCharCount,
    PDWORD  pdwReturnSize
    )

/*++

Routine Description:

    Parse a model-specific printer INI file (ANSI text) and
    assemble all key=value entries into MultiSZ string pairs

Arguments:

    pstrFileData - Points to printer INI file data (ANSI text file)
    dwCharCount - Size of printer INI file (in characters)
    pdwReturnSize - Return size of the parsed MultiSZ data (in bytes)

Return Value:

    Pointer to parsed MultiSZ data, NULL if there is an error

--*/

{
    PSTR    pstrCurLine, pstrNextLine;
    PSTR    pstrLineEnd, pstrFileEnd, pstrEqual;
    PWSTR   pwstrResult, pwstr;
    DWORD   dwLength;
    BOOL    bOEMFilesSection = FALSE;

    //
    // Allocate a buffer to hold the parsed data.
    // We ask for a size equaling to that of the original file.
    // This may be a little redundant but it's better than
    // having to go through the data twice.
    //

    *pdwReturnSize = 0;

    if (! (pwstrResult = MemAlloc(sizeof(WCHAR) * (dwCharCount + 2))))
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    pwstr = pwstrResult;
    pstrFileEnd = pstrFileData + dwCharCount;

    for (pstrCurLine = pstrFileData;
         pstrCurLine < pstrFileEnd;
         pstrCurLine = pstrNextLine)
    {
        //
        // Find the end of current line and
        // the beginning of next line
        //

        pstrLineEnd = pstrCurLine;

        while (pstrLineEnd < pstrFileEnd &&
               *pstrLineEnd != '\r' &&
               *pstrLineEnd != '\n')
        {
            pstrLineEnd++;
        }

        pstrNextLine = pstrLineEnd;

        while ((pstrNextLine < pstrFileEnd) &&
               (*pstrNextLine == '\r' ||
                *pstrNextLine == '\n'))
        {
            pstrNextLine++;
        }

        //
        // Throw away leading and trailing spaces
        // and ignore empty and comment lines
        //

        while (pstrCurLine < pstrLineEnd && isspace(*pstrCurLine))
            pstrCurLine++;

        while (pstrLineEnd > pstrCurLine && isspace(pstrLineEnd[-1]))
            pstrLineEnd--;

        if (pstrCurLine >= pstrLineEnd || *pstrCurLine == INI_COMMENT_CHAR)
            continue;

        //
        // Handle [section] entries
        //

        if (*pstrCurLine == '[')
        {
            dwLength = (DWORD)(pstrLineEnd - pstrCurLine);

            bOEMFilesSection =
                dwLength == strlen(OEMFILES_SECTION) &&
                _strnicmp(pstrCurLine, OEMFILES_SECTION, dwLength) == EQUAL_STRING;

            if (! bOEMFilesSection)
                TERSE(("[Section] entry ignored\n"));

            continue;
        }

        //
        // Ignore all entries outside of [OEMFiles] section
        //

        if (! bOEMFilesSection)
        {
            TERSE(("Entries outside of [OEMFiles] section ignored\n"));
            continue;
        }

        //
        // Find the first occurrence of = character
        //

        pstrEqual = pstrCurLine;

        while (pstrEqual < pstrLineEnd && *pstrEqual != '=')
            pstrEqual++;

        if (pstrEqual >= pstrLineEnd || pstrEqual == pstrCurLine)
        {
            WARNING(("Entry not in the form of key=value\n"));
            continue;
        }

        //
        // Add the key/value pair to the result buffer
        // Convert ANSI chars to Unicode chars using system default code page
        //

        if ((dwLength = (DWORD)(pstrEqual - pstrCurLine)) != 0)
            pwstr += DwCopyAnsiCharsToUnicode(pstrCurLine, dwLength, pwstr);

        *pwstr++ = NUL;

        pstrEqual++;

        if ((dwLength = (DWORD)(pstrLineEnd - pstrEqual)) != 0)
            pwstr += DwCopyAnsiCharsToUnicode(pstrEqual, dwLength, pwstr);

        *pwstr++ = NUL;
    }

    *pwstr++ = NUL;
    *pdwReturnSize = (DWORD)((pwstr - pwstrResult) * sizeof(WCHAR));
    return pwstrResult;
}



BOOL
BProcessPrinterIniFile(
    HANDLE          hPrinter,
    PDRIVER_INFO_3  pDriverInfo3,
    PTSTR           *ppParsedData,
    DWORD           dwFlags
    )

/*++

Routine Description:

    Process model-specific printer INI file, if any

Arguments:

    hPrinter - Handle to a local printer, with admin access
    pDriverInfo3 - Printer driver info level 3
    ppParsedData - output buffer to return ini file content
    dwFlags - FLAG_INIPROCESS_UPGRADE is set if the printer is being upgraded

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCWSTR          pwstrIniFilename;  // the .INI file with latest LastWrite time
    PCWSTR          pwstrCurFilename;  // the current .INI file we see in the list
    PWSTR           pwstrExtension;
    PWSTR           pwstrParsedData;
    DWORD           dwParsedDataSize;
    BOOL            bResult = TRUE;

    //
    // Find INI filename associated with the printer driver
    //

    #if !defined(WINNT_40) || !defined(KERNEL_MODE)

    pwstrIniFilename = PtstrSearchDependentFileWithExtension(pDriverInfo3->pDependentFiles,
                                                             INI_FILENAME_EXT);

    //
    // We only need to do .INI FileTime comparison if there are
    // more than one .INI file in the dependent file list.
    //
    if (pwstrIniFilename &&
        PtstrSearchDependentFileWithExtension(pwstrIniFilename + wcslen(pwstrIniFilename) + 1,
                                              INI_FILENAME_EXT))
    {
        FILETIME ftLatest = {0, 0};

        pwstrIniFilename = NULL;
        pwstrCurFilename = pDriverInfo3->pDependentFiles;

        while (pwstrCurFilename = PtstrSearchDependentFileWithExtension(pwstrCurFilename,
                                                                        INI_FILENAME_EXT))
        {
            HANDLE hFile;

            hFile = CreateFile(pwstrCurFilename,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                FILETIME ftCurrent = {0, 0};

                if (GetFileTime(hFile, NULL, NULL, &ftCurrent))
                {
                    //
                    // If it's the first .INI file we encountered, we just
                    // neeed to remember its file name and time as the latest.
                    //
                    // Otherwise, we need to compare its file time with the
                    // latest .INI file time we've seen before and choose the
                    // newer file as the latest.
                    //
                    if ((pwstrIniFilename == NULL) ||
                        (CompareFileTime(&ftCurrent, &ftLatest) == 1))
                    {
                        ftLatest = ftCurrent;
                        pwstrIniFilename = pwstrCurFilename;
                    }
                }
                else
                {
                    ERR(("GetFileTime failed: %d\n", GetLastError()));
                }

                CloseHandle(hFile);
            }
            else
            {
                ERR(("CreateFile failed: %d\n", GetLastError()));
            }

            pwstrCurFilename += wcslen(pwstrCurFilename) + 1;
        }
    }

    #else   // NT4 kernel mode only

    //
    // In point-and-print case, the client may not have admin
    // priviledge to write to server's registry, and in NT4
    // kernel mode we can't get the printer's DriverInfo3 for
    // the dependent file list, so in order to allow us get
    // the plugin info, we require following:
    //
    // If the printer's data file is named XYZ.PPD/XYZ.GPD, and
    // the printer has plugins, then it must use file named XYZ.INI
    // to specify its plugin info.
    //

    if ((pwstrIniFilename = DuplicateString(pDriverInfo3->pDataFile)) == NULL ||
        (pwstrExtension = wcsrchr(pwstrIniFilename, TEXT('.'))) == NULL ||
        wcslen(pwstrExtension) != _tcslen(INI_FILENAME_EXT))
    {
        ERR(("Can't compose the .ini file name from PPD/GPD name."));

        MemFree((PWSTR)pwstrIniFilename);

        return FALSE;
    }

    StringCchCopyW(pwstrExtension, wcslen(pwstrExtension) + 1, INI_FILENAME_EXT);

    #endif // !defined(WINNT_40) || !defined(KERNEL_MODE)

    //
    // We only have work to do if there is a model-specific printer INI file
    //

    if (pwstrIniFilename != NULL)
    {
        HFILEMAP    hFileMap;
        PBYTE       pubIniFileData;
        DWORD       dwIniFileSize;

        hFileMap = MapFileIntoMemory(pwstrIniFilename,
                                     (PVOID *) &pubIniFileData,
                                     &dwIniFileSize);

        if (hFileMap != NULL)
        {
            //
            // If the first two bytes are FF FE, then we assume
            // the text file is in Unicode format. Otherwise,
            // assume the text is in ANSI format.
            //

            if (dwIniFileSize >= sizeof(WCHAR) &&
                pubIniFileData[0] == 0xFF &&
                pubIniFileData[1] == 0xFE)
            {
                ASSERT((dwIniFileSize % sizeof(WCHAR)) == 0);

                pwstrParsedData = PwstrParsePrinterIniFileW(
                                        (PWSTR) pubIniFileData + 1,
                                        dwIniFileSize / sizeof(WCHAR) - 1,
                                        &dwParsedDataSize);
            }
            else
            {
                pwstrParsedData = PwstrParsePrinterIniFileA(
                                        (PSTR) pubIniFileData,
                                        dwIniFileSize,
                                        &dwParsedDataSize);
            }

            bResult = (pwstrParsedData != NULL);

            #ifndef KERNEL_MODE

            //
            // If not in kernel mode (where we can't write to registry),
            // we will try to save the parsed data into registry.
            // This may not succeed if user doesn't have proper right.
            //

            //
            // Fixing RC1 bug #423567
            //

            #if 0
            if (bResult && hPrinter)
            {
                BSetPrinterDataMultiSZPair(
                                  hPrinter,
                                  REGVAL_INIDATA,
                                  pwstrParsedData,
                                  dwParsedDataSize);
            }
            #endif

            #endif

            //
            // If caller ask for the parsed data directly,
            // don't free it and save the pointer for caller.
            // Caller is responsible for freeing the memory
            //

            if (ppParsedData)
            {
                *ppParsedData = pwstrParsedData;
            }
            else
            {
                MemFree(pwstrParsedData);
            }

            UnmapFileFromMemory(hFileMap);
        }
        else
            bResult = FALSE;

        #if defined(WINNT_40) && defined(KERNEL_MODE)

        //
        // Need to free memory allocated by DuplicateString
        //

        MemFree((PWSTR)pwstrIniFilename);

        #endif
    }
    else
    {
        #ifndef KERNEL_MODE

        if (dwFlags & FLAG_INIPROCESS_UPGRADE)
        {
            DWORD  dwType, dwSize, dwStatus;

            //
            // We know there is no .ini file in the dependent list. So
            // we will check if there is an old INI registry value there,
            // if so delete it.
            //

            ASSERT(hPrinter != NULL);

            dwStatus = GetPrinterData(hPrinter,
                                      REGVAL_INIDATA,
                                      &dwType,
                                      NULL,
                                      0,
                                      &dwSize);

            if ((dwStatus == ERROR_MORE_DATA || dwStatus == ERROR_SUCCESS) &&
                (dwSize > 0) &&
                (dwType == REG_MULTI_SZ))
            {
                dwStatus = DeletePrinterData(hPrinter, REGVAL_INIDATA);

                if (dwStatus != ERROR_SUCCESS)
                {
                    ERR(("Couldn't delete '%ws' during upgrade: %d\n", REGVAL_INIDATA, dwStatus));
                }
            }
        }

        #endif // !KERNEL_MODE

        bResult = FALSE;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\mini\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

!if !defined(WINNT_40) && !defined(KM_DRIVER)   # NT5 user-mode driver

C_DEFINES=$(C_DEFINES) -DOEMCOM

!endif

SOURCES=..\mini.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\oemutil\oemutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oemutil.c

Abstract:

    Library functions to implement OEM plugin architecture

Environment:

        Windows NT printer driver

Revision History:

    04/17/97 -davidx-
        Provide OEM plugins access to driver private settings.

    01/24/97 -davidx-
        Add function for loading DLLs and get entrypoint addresses.

    01/21/97 -davidx-
        Created it.

--*/


#define DEFINE_OEMPROC_NAMES

#include "lib.h"

#ifndef KERNEL_MODE
#include <winddiui.h>
#endif

#include <printoem.h>
#include "oemutil.h"


//
// Macros used to loop through each OEM plugin
//

#define FOREACH_OEMPLUGIN_LOOP(pOemPlugins) \
        { \
            DWORD _oemCount = (pOemPlugins)->dwCount; \
            POEM_PLUGIN_ENTRY pOemEntry = (pOemPlugins)->aPlugins; \
            for ( ; _oemCount--; pOemEntry++) \
            {

#define END_OEMPLUGIN_LOOP \
            } \
        }



BOOL
BExpandOemFilename(
    PTSTR  *ppDest,
    LPCTSTR pSrc,
    LPCTSTR pDir
    )

/*++

Routine Description:

    Expand an OEM plugin filename to a fully qualified pathname

Arguments:

    ppDest - Returns a pointer to fully qualified OEM filename
    pSrc - Specifies OEM filename without any directory prefix
    pDir - Specifies printer driver directory

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     iSrcLen, iDirLen;
    PTSTR   pDest;

    *ppDest = NULL;

    if (pSrc != NULL && pDir != NULL)
    {
        iSrcLen = _tcslen(pSrc);
        iDirLen = _tcslen(pDir);

        if ((pDest = MemAlloc((iSrcLen + iDirLen + 1) * sizeof(TCHAR))) == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        CopyMemory(pDest, pDir, iDirLen * sizeof(TCHAR));
        CopyMemory(pDest+iDirLen, pSrc, (iSrcLen+1) * sizeof(TCHAR));
        *ppDest = pDest;
    }

    return TRUE;
}



POEM_PLUGINS
PGetOemPluginInfo(
    HANDLE  hPrinter,
    LPCTSTR pctstrDriverPath,
    PDRIVER_INFO_3  pDriverInfo3
    )

/*++

Routine Description:

    Get information about OEM plugins for a printer

Arguments:

    hPrinter - Handle to a printer
    pctstrDriverPath - Points to the full pathname of driver DLL

Return Value:

    Pointer to OEM plugin information for the printer
    NULL if there is an error

Note:

    If there is no OEM plugin associated with the printer,
    an OEM_PLUGINS structure is still returned but
    its dwCount field will be zero.

    Notice the difference between user-mode and kernel-mode implementations.
    In user-mode, we're only interested in OEMConfigFileN and OEMHelpFileN.
    In kernel-mode, we're only interested in OEMDriverFileN.

--*/

{
    LPCTSTR         driverfiles[MAX_OEM_PLUGINS];
    LPCTSTR         configfiles[MAX_OEM_PLUGINS];
    LPCTSTR         helpfiles[MAX_OEM_PLUGINS];
    POEM_PLUGINS    pOemPlugins;
    PTSTR           ptstrIniData = NULL;
    PTSTR           pTemp = NULL;
    DWORD           dwCount = 0;

    //
    // Retrieve the data from model-specific printer INI file
    //

    //
    // Fixing RC1 bug #423567
    //

    #if 0
    if (hPrinter)
        ptstrIniData = PtstrGetPrinterDataMultiSZPair(hPrinter, REGVAL_INIDATA, NULL);
    #endif

    //
    // In the following 2 cases, we need to parse the INI file:
    //
    // 1. hPrinter is NULL;
    //
    // 2. When NT5 Unidrv/PScript5 client connecting to NT4 RASDD/PScript server,
    //    the server printer's registry initially doesn't contain the REGVAL_INIDATA,
    //    so we need to parse the INI file and write it into RASDD/PScript registry.
    //

    if (hPrinter == NULL || ptstrIniData == NULL)
    {
        if (BProcessPrinterIniFile(hPrinter, pDriverInfo3, &pTemp, 0))
            ptstrIniData = pTemp;
        else
            ptstrIniData = NULL;
    }

    if (ptstrIniData != NULL)
    {
        TCHAR   atchDriverKey[20];
        TCHAR   atchConfigKey[20];
        TCHAR   atchHelpKey[20];
        PTSTR   ptstrDriverKeyDigit;
        PTSTR   ptstrConfigKeyDigit;
        PTSTR   ptstrHelpKeyDigit;

        ZeroMemory((PVOID) driverfiles, sizeof(driverfiles));
        ZeroMemory((PVOID) configfiles, sizeof(configfiles));
        ZeroMemory((PVOID) helpfiles, sizeof(helpfiles));

        StringCchCopyW(atchDriverKey, CCHOF(atchDriverKey), TEXT("OEMDriverFile1"));
        StringCchCopyW(atchConfigKey, CCHOF(atchConfigKey), TEXT("OEMConfigFile1"));
        StringCchCopyW(atchHelpKey, CCHOF(atchHelpKey), TEXT("OEMHelpFile1"));

        ptstrDriverKeyDigit = &atchDriverKey[_tcslen(atchDriverKey) - 1];
        ptstrConfigKeyDigit = &atchConfigKey[_tcslen(atchConfigKey) - 1];
        ptstrHelpKeyDigit = &atchHelpKey[_tcslen(atchHelpKey) - 1];

        while (TRUE)
        {
            //
            // Find the files associated with the next OEM plugin.
            // Stop if there are no more OEM plugins left.
            //

            driverfiles[dwCount] = PtstrSearchStringInMultiSZPair(ptstrIniData, atchDriverKey);
            configfiles[dwCount] = PtstrSearchStringInMultiSZPair(ptstrIniData, atchConfigKey);
            helpfiles[dwCount] = PtstrSearchStringInMultiSZPair(ptstrIniData, atchHelpKey);

            if (!driverfiles[dwCount] && !configfiles[dwCount] && !helpfiles[dwCount])
                break;

            //
            // Check if there are too many OEM plugins
            //

            if (dwCount >= MAX_OEM_PLUGINS)
            {
                ERR(("Exceeded max number of OEM plugins allowed: %d\n", MAX_OEM_PLUGINS));
                break;
            }

            //
            // Move on to look for the next OEM plugin
            // We assume max number of plugins is less than 10
            //

            dwCount++;
            (*ptstrDriverKeyDigit)++;
            (*ptstrConfigKeyDigit)++;
            (*ptstrHelpKeyDigit)++;
        }
    }

    if ((pOemPlugins = MemAllocZ(offsetof(OEM_PLUGINS, aPlugins) +
                                 sizeof(OEM_PLUGIN_ENTRY) * dwCount)) == NULL)
    {
        ERR(("Memory allocation failed\n"));
    }
    else if (pOemPlugins->dwCount = dwCount)
    {
        PTSTR   ptstrDriverDir;
        BOOL    bResult = TRUE;

        VERBOSE(("Number of OEM plugins installed: %d\n", dwCount));
        dwCount = 0;

        if ((ptstrDriverDir = PtstrGetDriverDirectory(pctstrDriverPath)) == NULL)
        {
            ERR(("Couldn't get printer driver directory\n"));
            bResult = FALSE;
        }
        else
        {
            FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

                #ifdef KERNEL_MODE

                bResult = BExpandOemFilename(&pOemEntry->ptstrDriverFile,
                                             driverfiles[dwCount],
                                             ptstrDriverDir);
                #else

                bResult = BExpandOemFilename(&pOemEntry->ptstrConfigFile,
                                             configfiles[dwCount],
                                             ptstrDriverDir) &&
                          BExpandOemFilename(&pOemEntry->ptstrHelpFile,
                                             helpfiles[dwCount],
                                             ptstrDriverDir);
                #endif

                if (! bResult)
                    break;

                dwCount++;

            END_OEMPLUGIN_LOOP

            MemFree(ptstrDriverDir);
        }

        if (! bResult)
        {
            VFreeOemPluginInfo(pOemPlugins);
            pOemPlugins = NULL;
        }
    }

    MemFree(ptstrIniData);
    return pOemPlugins;
}



VOID
VFreeSinglePluginEntry(
    POEM_PLUGIN_ENTRY  pOemEntry
    )

/*++

Routine Description:

    Unload one plugin and dispose information about it

Arguments:

    pOemEntry - Pointer to the single plugin entry information

Return Value:

    NONE

--*/
{
    if (pOemEntry->hInstance)
    {
        //
        // Since we are calling plugin's DllInitialize(DLL_PROCESS_ATTACH)
        // no matter the plugin is using COM or non-COM interface, we must
        // do the same for DllInitialize(DLL_PROCESS_DETACH), so plugin will
        // get balanced DllInitialize calls.
        //

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            ReleaseOemInterface(pOemEntry);

            #if defined(KERNEL_MODE) && defined(WINNT_40)

            //
            // This must be called after COM interface is released,
            // because the Release() interface function still needs
            // the kernel semaphore.
            //

            (void) BHandleOEMInitialize(pOemEntry, DLL_PROCESS_DETACH);

            #endif // KERNEL_MODE && WINNT_40

            //
            // FreeLibrary happens in Driver_CoFreeOEMLibrary
            //

            #if defined(KERNEL_MODE)
               if ( !(pOemEntry->dwFlags & OEMNOT_UNLOAD_PLUGIN)  )
            #endif
            Driver_CoFreeOEMLibrary(pOemEntry->hInstance);
        }
        else
        {
            #if defined(KERNEL_MODE) && defined(WINNT_40)

            (void) BHandleOEMInitialize(pOemEntry, DLL_PROCESS_DETACH);

            #endif // KERNEL_MODE && WINNT_40

            #if defined(KERNEL_MODE)
               if ( !(pOemEntry->dwFlags & OEMNOT_UNLOAD_PLUGIN)  )
            #endif
            FreeLibrary(pOemEntry->hInstance);
        }

        pOemEntry->hInstance = NULL;
    }

    //
    // BHandleOEMInitialize needs to use the kernel mode render plugin
    // DLL name, so we should free the names here.
    //

    MemFree(pOemEntry->ptstrDriverFile);
    MemFree(pOemEntry->ptstrConfigFile);
    MemFree(pOemEntry->ptstrHelpFile);

    pOemEntry->ptstrDriverFile = NULL;
    pOemEntry->ptstrConfigFile = NULL;
    pOemEntry->ptstrHelpFile = NULL;
}


VOID
VFreeOemPluginInfo(
    POEM_PLUGINS    pOemPlugins
    )

/*++

Routine Description:

    Dispose of information about OEM plugins

Arguments:

    pOemPlugins - Pointer to OEM plugin information

Return Value:

    NONE

--*/

{
    ASSERT(pOemPlugins != NULL);

    FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

      #if defined(KERNEL_MODE)
        //
        // If this is debug build, and if the appropriate registry flag
        // (DoNotUnloadPluginDLL) is set, then the OEM plugin driver
        // should not be unloaded.
        // One use of this is to find out memory leaks using umdh/dhcmp.
        // umdh.exe needs the plugin to be present in the memory to give a
        // good stack trace.
        //
        DWORD   dwType               = 0;
        DWORD   ul                   = 0;
        DWORD   dwNotUnloadPluginDLL = 0;
        PDEVOBJ pdevobj              = (PDEVOBJ) (pOemPlugins->pdriverobj);

        if( pdevobj                                         &&
            (GetPrinterData( pdevobj->hPrinter,
                             L"DoNotUnloadPluginDLL",
                             &dwType,
                             (LPBYTE) &dwNotUnloadPluginDLL,
                             sizeof( dwNotUnloadPluginDLL ),
                             &ul ) == ERROR_SUCCESS)        &&
             ul == sizeof( dwNotUnloadPluginDLL )           &&
             dwNotUnloadPluginDLL )
        {
            pOemEntry->dwFlags |= OEMNOT_UNLOAD_PLUGIN;
        }

      #endif

        VFreeSinglePluginEntry(pOemEntry);

    END_OEMPLUGIN_LOOP

    MemFree(pOemPlugins);
}



BOOL
BLoadOEMPluginModules(
    POEM_PLUGINS    pOemPlugins
    )

/*++

Routine Description:

    Load OEM plugins modules into memory

Arguments:

    pOemPlugins - Points to OEM plugin info structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFN_OEMGetInfo  pfnOEMGetInfo;
    DWORD           dwData, dwSize;
    DWORD           dwCount, dwIndex;
    PTSTR           ptstrDllName;

    //
    // Quick exit when no OEM plugin is installed
    //

    if (pOemPlugins->dwCount == 0)
        return TRUE;

    //
    // Load each OEM module in turn
    //

    FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

        //
        // Load driver or config DLL depending on whether
        // we're being called from kernel or user mode
        //

        if (ptstrDllName = CURRENT_OEM_MODULE_NAME(pOemEntry))
        {
            //
            // Return failure if there is an error when loading the OEM module
            // or if the OEM module doesn't export OEMGetInfo entrypoint
            //
            // Note: LoadLibraryEx is only available for UI mode and user-mode
            //       rendering module
            //

            #if defined(KERNEL_MODE) && defined(WINNT_40)

            if (! (pOemEntry->hInstance = LoadLibrary(ptstrDllName)) )
            {
                ERR(("LoadLibrary failed for OEM module '%ws': %d\n", ptstrDllName, GetLastError()));
                goto oemload_error;
            }

            //
            // Notice this is called no matter plugin uses COM or non-COM interface.
            //

            if (!BHandleOEMInitialize(pOemEntry, DLL_PROCESS_ATTACH))
            {
                ERR(("BHandleOEMInitialize failed for OEM module '%ws': %d\n", ptstrDllName, GetLastError()));
                goto oemload_error;
            }

            #else  // !KERNEL_MODE || !WINNT_40

            SetErrorMode(SEM_FAILCRITICALERRORS);

            if (! (pOemEntry->hInstance = LoadLibraryEx(ptstrDllName,
                                                        NULL,
                                                        LOAD_WITH_ALTERED_SEARCH_PATH)) )
            {
                ERR(("LoadLibrary failed for OEM module '%ws': %d\n", ptstrDllName, GetLastError()));
                goto oemload_error;
            }

            #endif // KERNEL_MODE && WINNT_40

            //
            // If we can get an interface from OEM plugin, then OEM is using COM interface
            //

            if (BGetOemInterface(pOemEntry))
            {
                ASSERT(pOemEntry->pIntfOem != NULL);
            }
            else
            {
                //
                // Make sure to NULL the pointer to indicate no COM interface available.
                //

                pOemEntry->pIntfOem = NULL;
            }

            //
            // Call OEMGetInfo to verify interface version and
            // get OEM module's signature
            //

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                if (!SUCCEEDED(HComOEMGetInfo(pOemEntry,
                                              OEMGI_GETSIGNATURE,
                                              &pOemEntry->dwSignature,
                                              sizeof(DWORD),
                                              &dwSize)) ||
                    pOemEntry->dwSignature == 0)
                {
                    ERR(("HComOEMGetInfo failed for OEM module '%ws': %d\n", ptstrDllName, GetLastError()));
                    goto oemload_error;
                }
            }
            else
            {

                if (!(pfnOEMGetInfo = GET_OEM_ENTRYPOINT(pOemEntry, OEMGetInfo)) ||
                    !pfnOEMGetInfo(OEMGI_GETINTERFACEVERSION, &dwData, sizeof(DWORD), &dwSize) ||
                    dwData != PRINTER_OEMINTF_VERSION ||
                    !pfnOEMGetInfo(OEMGI_GETSIGNATURE, &pOemEntry->dwSignature, sizeof(DWORD), &dwSize) ||
                    pOemEntry->dwSignature == 0)
                {
                    ERR(("OEMGetInfo failed for OEM module '%ws': %d\n", ptstrDllName, GetLastError()));
                    goto oemload_error;
                }
            }

            continue;

            oemload_error:

                ERR(("Failed to load OEM module '%ws': %d\n", ptstrDllName, GetLastError()));
                return FALSE;
        }

    END_OEMPLUGIN_LOOP

    //
    // Verify that no two OEM modules share the same signature
    //

    for (dwCount = 1; dwCount < pOemPlugins->dwCount; dwCount++)
    {
        POEM_PLUGIN_ENTRY pOemEntry;

        pOemEntry = &pOemPlugins->aPlugins[dwCount];

        if (pOemEntry->hInstance == NULL)
            continue;

        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            //
            // If there is a signature conflict, unload the plugin
            // which appears later in the order.
            //

            if (pOemPlugins->aPlugins[dwIndex].dwSignature == pOemEntry->dwSignature)
            {
                ERR(("Duplicate signature for OEM plugins\n"));
                VFreeSinglePluginEntry(pOemEntry);

                pOemEntry->dwSignature = 0;
                break;
            }
        }
    }

    return TRUE;
}



OEMPROC
PGetOemEntrypointAddress(
    POEM_PLUGIN_ENTRY   pOemEntry,
    DWORD               dwIndex
    )

/*++

Routine Description:

    Get the address for the specified OEM entrypoint

Arguments:

    pOemEntry - Points to information about the OEM module
    dwIndex - OEM entrypoint index

Return Value:

    Address of the specified OEM entrypoint
    NULL if the entrypoint is not found or if there is an error

--*/

{
    ASSERT(dwIndex < MAX_OEMENTRIES);

    BITSET(pOemEntry->aubProcFlags, dwIndex);

    if (pOemEntry->hInstance != NULL)
    {
        pOemEntry->oemprocs[dwIndex] = (OEMPROC)
            GetProcAddress(pOemEntry->hInstance, OEMProcNames[dwIndex]);

        #if 0

        if (pOemEntry->oemprocs[dwIndex] == NULL && GetLastError() != ERROR_PROC_NOT_FOUND)
            ERR(("Couldn't find proc %s: %d\n", OEMProcNames[dwIndex], GetLastError()));

        #endif
    }

    return pOemEntry->oemprocs[dwIndex];
}



POEM_PLUGIN_ENTRY
PFindOemPluginWithSignature(
    POEM_PLUGINS pOemPlugins,
    DWORD        dwSignature
    )

/*++

Routine Description:

    Find the OEM plugin entry having the specified signature

Arguments:

    pOemPlugins - Specifies information about all loaded OEM plugins
    dwSignature - Specifies the signature in question

Return Value:

    Pointer to the OEM plugin entry having the specified signature
    NULL if no such entry is found

--*/

{
    FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

        if (pOemEntry->hInstance == NULL)
            continue;

        if (pOemEntry->dwSignature == dwSignature)
            return pOemEntry;

    END_OEMPLUGIN_LOOP

    WARNING(("Cannot find OEM plugin whose signature is: 0x%x\n", dwSignature));
    return NULL;
}



BOOL
BCalcTotalOEMDMSize(
    HANDLE       hPrinter,
    POEM_PLUGINS pOemPlugins,
    PDWORD       pdwOemDMSize
    )

/*++

Routine Description:

    Calculate the total private devmode size for all OEM plugins

Arguments:

    hPrinter - Handle to the current printer
    pOemPlugins - Specifies information about all loaded OEM plugins
    pdwOemDMSize - Return the total private size for all OEM plugins

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD           dwSize;
    OEMDMPARAM      OemDMParam;
    PFN_OEMDevMode  pfnOEMDevMode;
    BOOL            bOemCalled;

    HRESULT         hr;

    //
    // Quick exit when no OEM plugin is installed
    //

    *pdwOemDMSize = dwSize = 0;

    if (pOemPlugins->dwCount == 0)
        return TRUE;

    FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

        if (pOemEntry->hInstance == NULL)
            continue;

        bOemCalled = FALSE;

        //
        // OEM private devmode size is saved in OEM_PLUGIN_ENTRY.dwOEMDMSize
        // if this is the very first call, we must call into OEM plugin's
        // OEMDevMode entrypoint to find out its private devmode size.
        //

        if (!(pOemEntry->dwFlags & OEMDEVMODE_CALLED))
        {
            pOemEntry->dwFlags |= OEMDEVMODE_CALLED;

            //
            // We reinitialize all field of OemDMParam inside
            // the loop in case an ill-behaving plugin touches
            // read-only fields.
            //

            ZeroMemory(&OemDMParam, sizeof(OemDMParam));
            OemDMParam.cbSize = sizeof(OemDMParam);
            OemDMParam.pdriverobj = pOemPlugins->pdriverobj;
            OemDMParam.hPrinter = hPrinter;
            OemDMParam.hModule = pOemEntry->hInstance;

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                hr = HComOEMDevMode(pOemEntry, OEMDM_SIZE, &OemDMParam);

                if ((hr != E_NOTIMPL) && FAILED(hr))
                {
                    ERR(("Cannot get OEM devmode size for '%ws': %d\n",
                         CURRENT_OEM_MODULE_NAME(pOemEntry),
                         GetLastError()));

                    return FALSE;
                }

                if (SUCCEEDED(hr))
                    bOemCalled = TRUE;
            }
            else
            {
                if (!BITTST((pOemEntry)->aubProcFlags, EP_OEMDevMode) &&
                    (pfnOEMDevMode = GET_OEM_ENTRYPOINT(pOemEntry, OEMDevMode)))
                {
                    //
                    // Query OEM plugin to find out the size of their
                    // private devmode size.
                    //

                    if (! pfnOEMDevMode(OEMDM_SIZE, &OemDMParam))
                    {
                        ERR(("Cannot get OEM devmode size for '%ws': %d\n",
                             CURRENT_OEM_MODULE_NAME(pOemEntry),
                             GetLastError()));

                        return FALSE;
                    }

                    bOemCalled = TRUE;
                }
            }

            if (bOemCalled)
            {
                //
                // Make sure the OEM private devmode size is at least
                // as big as OEM_DMEXTRAHEADER.
                //

                if (OemDMParam.cbBufSize > 0 &&
                    OemDMParam.cbBufSize < sizeof(OEM_DMEXTRAHEADER))
                {
                    ERR(("OEM devmode size for '%ws' is too small: %d\n",
                         CURRENT_OEM_MODULE_NAME(pOemEntry),
                         OemDMParam.cbBufSize));

                    return FALSE;
                }

                pOemEntry->dwOEMDMSize = OemDMParam.cbBufSize;
            }
        }

        dwSize += pOemEntry->dwOEMDMSize;

    END_OEMPLUGIN_LOOP

    *pdwOemDMSize = dwSize;
    return TRUE;
}



BOOL
BCallOEMDevMode(
    HANDLE              hPrinter,
    PVOID               pdriverobj,
    POEM_PLUGIN_ENTRY   pOemEntry,
    DWORD               fMode,
    PDEVMODE            pPublicDMOut,
    PDEVMODE            pPublicDMIn,
    POEM_DMEXTRAHEADER  pOemDMOut,
    POEM_DMEXTRAHEADER  pOemDMIn
    )

/*++

Routine Description:

    Helper function to invoke OEM plugin's OEMDevMode entrypoint

Arguments:

    argument-name - description of argument

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    OEMDMPARAM      OemDMParam;
    PFN_OEMDevMode  pfnOEMDevMode;

    HRESULT         hr;

    if (!pOemEntry->hInstance || !pOemEntry->dwOEMDMSize)
        return TRUE;

    //
    // Call OEMDevMode to get OEM's default devmode
    //

    OemDMParam.cbSize = sizeof(OemDMParam);
    OemDMParam.pdriverobj = pdriverobj;
    OemDMParam.hPrinter = hPrinter;
    OemDMParam.hModule = pOemEntry->hInstance;
    OemDMParam.pPublicDMIn = pPublicDMIn;
    OemDMParam.pPublicDMOut = pPublicDMOut;
    OemDMParam.pOEMDMIn = pOemDMIn;
    OemDMParam.pOEMDMOut = pOemDMOut;
    OemDMParam.cbBufSize = pOemEntry->dwOEMDMSize;

    //
    // If OEM private devmode size is not 0, we should
    // have OEMDevMode entrypoint address already.
    //

    if (HAS_COM_INTERFACE(pOemEntry))
    {
        hr = HComOEMDevMode(pOemEntry, fMode, &OemDMParam);

        ASSERT(hr != E_NOTIMPL);

        if (FAILED(hr))
        {
            ERR(("OEMDevMode(%d) failed for '%ws': %d\n",
                 fMode,
                 CURRENT_OEM_MODULE_NAME(pOemEntry),
                 GetLastError()));

            return FALSE;
        }
    }
    else
    {
        pfnOEMDevMode = GET_OEM_ENTRYPOINT(pOemEntry, OEMDevMode);
        ASSERT(pfnOEMDevMode != NULL);

        if (! pfnOEMDevMode(fMode, &OemDMParam))
        {
            ERR(("OEMDevMode(%d) failed for '%ws': %d\n",
                 fMode,
                 CURRENT_OEM_MODULE_NAME(pOemEntry),
                 GetLastError()));

            return FALSE;
        }
    }

    //
    // Perform simple sanity check on the output devmode
    // returned by the OEM plugin
    //

    if (pOemDMOut->dwSize != pOemEntry->dwOEMDMSize ||
        OemDMParam.cbBufSize != pOemEntry->dwOEMDMSize ||
        pOemDMOut->dwSignature != pOemEntry->dwSignature)
    {
        ERR(("Bad output data from OEMDevMode(%d) for '%ws'\n",
             fMode,
             CURRENT_OEM_MODULE_NAME(pOemEntry)));

        return FALSE;
    }

    return TRUE;
}


BOOL
BInitOemPluginDefaultDevmode(
    IN HANDLE               hPrinter,
    IN PDEVMODE             pPublicDM,
    OUT POEM_DMEXTRAHEADER  pOemDM,
    IN OUT POEM_PLUGINS     pOemPlugins
    )

/*++

Routine Description:

    Initialize OEM plugin default devmodes

Arguments:

    hPrinter - Handle to the current printer
    pPublicDM - Points to default public devmode information
    pOemDM - Points to output buffer for storing default OEM devmodes
    pOemPlugins - Information about OEM plugins

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    After this function successfully returns, OEM_PLUGIN_ENTRY.pOEMDM field
    for corresponding to each OEM plugin is updated with pointer to appropriate
    private OEM devmode.

--*/

{
    //
    // Quick exit when no OEM plugin is installed
    //

    if (pOemPlugins->dwCount == 0)
        return TRUE;

    FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

        if (pOemEntry->hInstance == NULL)
            continue;

        //
        // Call OEM plugin to get its default private devmode
        //

        if (! BCallOEMDevMode(hPrinter,
                              pOemPlugins->pdriverobj,
                              pOemEntry,
                              OEMDM_DEFAULT,
                              NULL,
                              pPublicDM,
                              pOemDM,
                              NULL))
        {
            return FALSE;
        }

        //
        // Save a pointer to current OEM plugin's private devmode
        // and move on to the next OEM plugin
        //

        if (pOemEntry->dwOEMDMSize)
        {
            pOemEntry->pOEMDM = pOemDM;
            pOemDM = (POEM_DMEXTRAHEADER) ((PBYTE) pOemDM + pOemEntry->dwOEMDMSize);
        }

    END_OEMPLUGIN_LOOP

    return TRUE;
}



BOOL
BValidateAndMergeOemPluginDevmode(
    IN HANDLE               hPrinter,
    OUT PDEVMODE            pPublicDMOut,
    IN PDEVMODE             pPublicDMIn,
    OUT POEM_DMEXTRAHEADER  pOemDMOut,
    IN POEM_DMEXTRAHEADER   pOemDMIn,
    IN OUT POEM_PLUGINS     pOemPlugins
    )

/*++

Routine Description:

    Validate and merge OEM plugin private devmode fields

Arguments:

    hPrinter - Handle to the current printer
    pPublicDMOut - Points to output public devmode
    pPublicDMIn - Points to input public devmode
    pOemDMOut - Points to output buffer for storing merged OEM devmodes
    pOemDMIn - Points to input OEM devmodes to be merged
    pOemPlugins - Information about OEM plugins

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    Both input and output public devmodes must be current version.
    Output public devmode be already validated when this function is called.

    pOemDMOut must be current version and validated as well.
    pOemDMIn must be current version but may not be valid.

    After this function successfully returns, OEM_PLUGIN_ENTRY.pOEMDM field
    for corresponding to each OEM plugin is updated with pointer to appropriate
    private OEM devmode.

--*/

{
    //
    // Quick exit when no OEM plugin is installed
    //

    if (pOemPlugins->dwCount == 0)
        return TRUE;

    FOREACH_OEMPLUGIN_LOOP(pOemPlugins)

        if (pOemEntry->hInstance == NULL)
            continue;

        //
        // Call OEM plugin to validate and merge its private devmode
        //

        if (! BCallOEMDevMode(hPrinter,
                              pOemPlugins->pdriverobj,
                              pOemEntry,
                              OEMDM_MERGE,
                              pPublicDMOut,
                              pPublicDMIn,
                              pOemDMOut,
                              pOemDMIn))
        {
            return FALSE;
        }

        //
        //
        // Save a pointer to current OEM plugin's private devmode
        // and move on to the next OEM plugin
        //

        if (pOemEntry->dwOEMDMSize)
        {
            pOemEntry->pOEMDM = pOemDMOut;
            pOemDMOut = (POEM_DMEXTRAHEADER) ((PBYTE) pOemDMOut + pOemEntry->dwOEMDMSize);
            pOemDMIn = (POEM_DMEXTRAHEADER) ((PBYTE) pOemDMIn + pOemEntry->dwOEMDMSize);
        }

    END_OEMPLUGIN_LOOP

    return TRUE;
}


/*++

Routine Name:

    bIsValidPluginDevmodes

Routine Description:

    This function scans through the OEM plugin devmodes block and
    verifies if every plugin devmode in that block is constructed correctly.

Arguments:

    pOemDM - Points to OEM plugin devmodes block
    cbOemDMSize - Size in bytes of the OEM plugin devmodes block

Return Value:

    TRUE if every plugin devmode in correctly constructed.
    FALSE otherwise.

Last Error:

    N/A

--*/
BOOL
bIsValidPluginDevmodes(
    IN POEM_DMEXTRAHEADER   pOemDM,
    IN LONG                 cbOemDMSize
    )
{
    OEM_DMEXTRAHEADER   OemDMHeader;
    BOOL                bValid = FALSE;

    ASSERT(pOemDM != NULL && cbOemDMSize != 0);

    //
    // Follow the chain of the OEM plugin devmodes, check each one's
    // OEM_DMEXTRAHEADER and verify the last OEM devmode ends at the
    // correct endpoint.
    //
    while (cbOemDMSize > 0)
    {
        //
        // Check if the remaining OEM private devmode is big enough
        //
        if (cbOemDMSize < sizeof(OEM_DMEXTRAHEADER))
        {
            WARNING(("OEM private devmode size too small.\n"));
            break;
        }

        //
        // Copy the memory since the pointer may not be properly aligned
        // if incoming devmode fields are corrupted.
        //
        CopyMemory(&OemDMHeader, pOemDM, sizeof(OEM_DMEXTRAHEADER));

        if (OemDMHeader.dwSize < sizeof(OEM_DMEXTRAHEADER) ||
            OemDMHeader.dwSize > (DWORD)cbOemDMSize)
        {
            WARNING(("Corrupted or truncated OEM private devmode\n"));
            break;
        }

        //
        // Move on to the next OEM plugin
        //
        cbOemDMSize -= OemDMHeader.dwSize;

        if (cbOemDMSize == 0)
        {
            bValid = TRUE;
            break;
        }

        pOemDM = (POEM_DMEXTRAHEADER) ((PBYTE) pOemDM + OemDMHeader.dwSize);
    }

    return bValid;
}


BOOL
BConvertOemPluginDevmode(
    IN HANDLE               hPrinter,
    OUT PDEVMODE            pPublicDMOut,
    IN PDEVMODE             pPublicDMIn,
    OUT POEM_DMEXTRAHEADER  pOemDMOut,
    IN POEM_DMEXTRAHEADER   pOemDMIn,
    IN LONG                 cbOemDMInSize,
    IN POEM_PLUGINS         pOemPlugins
    )

/*++

Routine Description:

    Convert OEM plugin default devmodes to current version

Arguments:

    hPrinter - Handle to the current printer
    pPublicDMOut - Points to output public devmode
    pPublicDMIn - Points to input public devmode
    pOemDMOut - Points to output buffer for storing merged OEM devmodes
    pOemDMIn - Points to input OEM devmodes to be converted
    cbOemDMInSize - Size of input buffer, in bytes
    pOemPlugins - Information about OEM plugins

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    When this function is called, pOemDMOut must already contain
    valid current version private OEM devmode information.

--*/

{
    //
    // Quick exit when no OEM plugin is installed or no incoming OEM devmode
    //

    if (pOemPlugins->dwCount == 0 || cbOemDMInSize == 0)
        return TRUE;

    //
    // Sanity check on the incoming OEM private devmodes.
    //
    if (!bIsValidPluginDevmodes(pOemDMIn, cbOemDMInSize))
    {
        ERR(("Found wrong boundary. Incoming OEM private devmode data are ignored.\n"));
        return TRUE;
    }

    while (cbOemDMInSize > 0)
    {
        POEM_PLUGIN_ENTRY   pOemEntry;
        OEM_DMEXTRAHEADER   OemDMInHeader;

        //
        // Copy the memory since the pointer may not be properly aligned
        // if incoming devmode fields are corrupted.
        //

        CopyMemory(&OemDMInHeader, pOemDMIn, sizeof(OEM_DMEXTRAHEADER));

        //
        // Find the OEM plugin which owns the private devmode
        //

        pOemEntry = PFindOemPluginWithSignature(pOemPlugins, OemDMInHeader.dwSignature);

        if (pOemEntry != NULL)
        {
            POEM_DMEXTRAHEADER  pOemDMCurrent;
            DWORD               dwCount;

            //
            // Find the OEM plugin's location in the output OEM devmode buffer
            // This will always succeed because the output devmode must
            // contain valid current version OEM devmodes.
            //

            pOemDMCurrent = pOemDMOut;
            dwCount = pOemPlugins->dwCount;

            while (dwCount)
            {
                if (pOemEntry->dwSignature == pOemDMCurrent->dwSignature)
                    break;

                dwCount--;
                pOemDMCurrent = (POEM_DMEXTRAHEADER)
                    ((PBYTE) pOemDMCurrent + pOemDMCurrent->dwSize);
            }

            ASSERT(dwCount != 0);

            //
            // Call OEM plugin to convert its input devmode
            // to its current version devmode
            //

            if (! BCallOEMDevMode(hPrinter,
                                  pOemPlugins->pdriverobj,
                                  pOemEntry,
                                  OEMDM_CONVERT,
                                  pPublicDMOut,
                                  pPublicDMIn,
                                  pOemDMCurrent,
                                  pOemDMIn))
            {
                return FALSE;
            }
        }
        else
            WARNING(("No owner found for OEM devmode: 0x%x\n", pOemDMIn->dwSignature));

        //
        // Move on to the next OEM plugin
        //

        cbOemDMInSize -= OemDMInHeader.dwSize;
        pOemDMIn = (POEM_DMEXTRAHEADER) ((PBYTE) pOemDMIn + OemDMInHeader.dwSize);
    }

    return TRUE;
}



BOOL
BGetPrinterDataSettingForOEM(
    IN  PRINTERDATA *pPrinterData,
    IN  DWORD       dwIndex,
    OUT PVOID       pOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )

/*++

Routine Description:

    Function called by OEM plugins to access driver settings in registry

Arguments:

    pPrinterData - Points to the PRINTERDATA structure to be accessed
    dwIndex - Predefined index specifying which field to access
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAPPRINTERDATAFIELD(index, field) \
        { index, offsetof(PRINTERDATA, field), sizeof(pPrinterData->field) }

{
    static const struct {

        DWORD   dwIndex;
        DWORD   dwOffset;
        DWORD   dwSize;

    } aIndexMap[]  = {

        MAPPRINTERDATAFIELD(OEMGDS_PRINTFLAGS, dwFlags),
        MAPPRINTERDATAFIELD(OEMGDS_FREEMEM, dwFreeMem),
        MAPPRINTERDATAFIELD(OEMGDS_JOBTIMEOUT, dwJobTimeout),
        MAPPRINTERDATAFIELD(OEMGDS_WAITTIMEOUT, dwWaitTimeout),
        MAPPRINTERDATAFIELD(OEMGDS_PROTOCOL, wProtocol),
        MAPPRINTERDATAFIELD(OEMGDS_MINOUTLINE, wMinoutlinePPEM),
        MAPPRINTERDATAFIELD(OEMGDS_MAXBITMAP, wMaxbitmapPPEM),

        { 0, 0, 0 }
    };

    INT i = 0;

    while (aIndexMap[i].dwSize != 0)
    {
        if (aIndexMap[i].dwIndex == dwIndex)
        {
            *pcbNeeded = aIndexMap[i].dwSize;

            if (cbSize < aIndexMap[i].dwSize || pOutput == NULL)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }

            CopyMemory(pOutput, (PBYTE) pPrinterData + aIndexMap[i].dwOffset, aIndexMap[i].dwSize);
            return TRUE;
        }

        i++;
    }

    WARNING(("Unknown printer data index: %d\n", dwIndex));
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
BGetGenericOptionSettingForOEM(
    IN  PUIINFO     pUIInfo,
    IN  POPTSELECT  pOptionsArray,
    IN  PCSTR       pstrFeatureName,
    OUT PSTR        pstrOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded,
    OUT PDWORD      pdwOptionsReturned
    )

/*++

Routine Description:

    Function called by OEM plugins to find out the currently selected
    option(s) for the specified feature

Arguments:

    pUIInfo - Points to UIINFO structure
    pOptionsArray - Points to current option selection array
    pstrFeatureName - Specifies the name of the interested feature
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Expected size of output buffer
    pdwOptionsReturned - Number of currently selected options

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFEATURE    pFeature;
    POPTION     pOption;
    PCSTR       pstrOptionName;
    DWORD       dwFeatureIndex, dwNext, dwSize, dwCount;

    ASSERT(pUIInfo && pOptionsArray && pstrFeatureName);

    //
    // Find the specified feature
    //

    pFeature = PGetNamedFeature(pUIInfo, pstrFeatureName, &dwFeatureIndex);

    if (pFeature == NULL)
    {
        WARNING(("Unknown feature name: %s\n", pstrFeatureName));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how big the output buffer needs to be
    //

    dwCount = 0;
    dwSize = 1;
    dwNext = dwFeatureIndex;

    do
    {
        pOption = PGetIndexedOption(pUIInfo, pFeature, pOptionsArray[dwNext].ubCurOptIndex);

        if (pOption == NULL)
        {
            ERR(("Invalid option selection index: %d\n", dwNext));
            goto first_do_next;
        }

        pstrOptionName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName);
        ASSERT(pstrOptionName != NULL);

        dwSize += strlen(pstrOptionName) + 1;
        dwCount++;

        first_do_next:
        dwNext = pOptionsArray[dwNext].ubNext;

    } while(dwNext != NULL_OPTSELECT) ;

    *pdwOptionsReturned = dwCount;
    *pcbNeeded = dwSize;

    //
    // If the output buffer is too small, return appropriate error code
    //

    if (cbSize < dwSize || pstrOutput == NULL)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Copy the selected option names
    //

    dwNext = dwFeatureIndex;

    do
    {
        pOption = PGetIndexedOption(pUIInfo, pFeature, pOptionsArray[dwNext].ubCurOptIndex);

        if (pOption == NULL)
        {
            ERR(("Invalid option selection index: %d\n", dwNext));
            goto second_do_next;
        }

        pstrOptionName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName);
        dwSize = strlen(pstrOptionName) + 1;
        CopyMemory(pstrOutput, pstrOptionName, dwSize);
        pstrOutput += dwSize;

        second_do_next:
        dwNext = pOptionsArray[dwNext].ubNext;
    }  while(dwNext != NULL_OPTSELECT) ;

    //
    // Don't forget the extra NUL character at the end
    //

    *pstrOutput = NUL;

    return TRUE;
}


VOID
VPatchDevmodeSizeFields(
    PDEVMODE    pdm,
    DWORD       dwDriverDMSize,
    DWORD       dwOemDMSize
    )

/*++

Routine Description:

    Patch various size fields in the devmode structure

Arguments:

    pdm - Points to devmode structure to be patched
    dwDriverDMSize - Size of driver private devmode
    dwOemDMSize - Size of OEM plugin private devmodes

Return Value:

    NONE

--*/

{
    pdm->dmDriverExtra = (WORD) (dwDriverDMSize + dwOemDMSize);

    if (gdwDriverDMSignature == PSDEVMODE_SIGNATURE)
    {
        PPSDRVEXTRA pPsExtra = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);
        pPsExtra->wSize = (WORD) dwDriverDMSize;
        pPsExtra->wOEMExtra = (WORD) dwOemDMSize;
    }
    else
    {
        PUNIDRVEXTRA pUniExtra = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);
        pUniExtra->wSize = (WORD) dwDriverDMSize;
        pUniExtra->wOEMExtra = (WORD) dwOemDMSize;
    }
}



PDEVMODE
PGetDefaultDevmodeWithOemPlugins(
    IN LPCTSTR          ptstrPrinterName,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN BOOL             bMetric,
    IN OUT POEM_PLUGINS pOemPlugins,
    IN HANDLE           hPrinter
    )

/*++

Routine Description:

    Allocate memory and initialize it with default devmode information
    This include public devmode, driver private devmode, as well as
    private devmode for any OEM plugins.

Arguments:

    ptstrPrinterName - Name of the current printer
    pUIInfo - Points to a UIINFO structure
    pRawData - Points to raw binary printer description data
    bMetric - Whether the system is in metric country
    pOemPlugins - Points to information about OEM plugins
    hPrinter - Handle to the current printer

Return Value:

    Pointer to a devmode structure (including driver private and
    OEM plugin private devmodes) initialized to default settings;
    NULL if there is an error

--*/

{
    PDEVMODE    pdm;
    DWORD       dwOemDMSize, dwSystemDMSize;

    //
    // Figure out the total devmode size and allocate memory:
    //  public fields
    //  driver private fields
    //  OEM plugin private fields, if any
    //

    dwSystemDMSize = sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra;

    if (! BCalcTotalOEMDMSize(hPrinter, pOemPlugins, &dwOemDMSize) ||
        ! (pdm = MemAllocZ(dwOemDMSize + dwSystemDMSize)))
    {
        return NULL;
    }

    //
    // Call driver-specific function to initialize public and driver private fields
    // Call OEM plugins to initialize their default devmode fields
    //

    if (! BInitDriverDefaultDevmode(pdm, ptstrPrinterName, pUIInfo, pRawData, bMetric) ||
        ! BInitOemPluginDefaultDevmode(
                        hPrinter,
                        pdm,
                        (POEM_DMEXTRAHEADER) ((PBYTE) pdm + dwSystemDMSize),
                        pOemPlugins))
    {
        MemFree(pdm);
        return NULL;
    }

    //
    // Patch up various private devmode size fields
    //

    VPatchDevmodeSizeFields(pdm, gDriverDMInfo.dmDriverExtra, dwOemDMSize);
    return pdm;
}



PDEVMODE
PConvertToCurrentVersionDevmodeWithOemPlugins(
    IN HANDLE         hPrinter,
    IN PRAWBINARYDATA pRawData,
    IN PDEVMODE       pdmInput,
    IN PDEVMODE       pdmDefault,
    IN POEM_PLUGINS   pOemPlugins,
    OUT PDWORD        pdwOemDMSize
    )

/*++

Routine Description:

    Convert input devmode to current version devmode.
    Memory for the converted devmode is allocated by this function.

Arguments:

    hPrinter - Handle to the current printer
    pRawData - Points to raw binary printer description data
    pdmInput - Pointer to the input devmode to be converted
    pdmDefault - Points to a valid current version devmode
    pOemPlugins - Information about OEM plugins
    pdwOemDMSize - Returns the total size of all OEM plugin devmodes

Return Value:

    Pointer to the converted devmode, NULL if there is an error

Note:

    Core private devmode portion of returned devmode contains:
      1) if pdmInput is from unknown driver (including Rasdd):
         core private devmode portion from pdmDefault
      2) if pdmInput is from our NT4 PScript/Win2K/XP/Longhorn+ drivers:
         fixed-size core private devmode of pdmInput

--*/

{
    DWORD       dwOemDMSize;
    WORD        wCoreFixSize, wOEMExtra;
    PDEVMODE    pdm;
    PVOID       pDrvExtraIn, pOemDMOut, pOemDMIn;
    BOOL        bMSdm500In = FALSE, bMSdmPS4In = FALSE;

    ASSERT(pdmInput != NULL);

    //
    // Allocate memory to hold converted devmode
    //

    if (! BCalcTotalOEMDMSize(hPrinter, pOemPlugins, &dwOemDMSize) ||
        ! (pdm = MemAllocZ(dwOemDMSize + gDriverDMInfo.dmDriverExtra + sizeof(DEVMODE))))
    {
        return NULL;
    }

    //
    // Copy public devmode fields
    //

    CopyMemory(pdm, pdmInput, min(sizeof(DEVMODE), pdmInput->dmSize));
    pdm->dmSpecVersion = DM_SPECVERSION;
    pdm->dmSize = sizeof(DEVMODE);

    //
    // Copy driver private devmode fields
    //
    pDrvExtraIn = GET_DRIVER_PRIVATE_DEVMODE(pdmInput);
    wCoreFixSize = pdmInput->dmDriverExtra;
    wOEMExtra = 0;

    if (pdmInput->dmDriverVersion >= gDriverDMInfo.dmDriverVersion500 &&
        wCoreFixSize >= gDriverDMInfo.dmDriverExtra500)
    {
        //
        // Win2K/XP/Longhorn+ drivers must be allowed to enter this if-block
        //
        // (Note that in UNIDRVEXTRA500 we didn't have the last "dwEndingPad"
        // field, since that field is only added in XP. And for PSDRIVER_VERSION_500
        // we are using the Win2K's number 0x501.)
        //
        WORD wSize = wCoreFixSize;

        if (gdwDriverDMSignature == PSDEVMODE_SIGNATURE)
        {
            if (((PPSDRVEXTRA) pDrvExtraIn)->dwSignature == PSDEVMODE_SIGNATURE)
            {
                wSize = ((PPSDRVEXTRA) pDrvExtraIn)->wSize;
                wOEMExtra = ((PPSDRVEXTRA) pDrvExtraIn)->wOEMExtra;

                if ((wSize >= gDriverDMInfo.dmDriverExtra500) &&
                    ((wSize + wOEMExtra) <= pdmInput->dmDriverExtra))
                {
                    //
                    // pdmInput is from our Win2K/XP/Longhorn+ PScript driver
                    //
                    bMSdm500In = TRUE;
                }
            }
        }
        else
        {
            if (((PUNIDRVEXTRA) pDrvExtraIn)->dwSignature == UNIDEVMODE_SIGNATURE)
            {
                wSize = ((PUNIDRVEXTRA) pDrvExtraIn)->wSize;
                wOEMExtra = ((PUNIDRVEXTRA) pDrvExtraIn)->wOEMExtra;

                if ((wSize >= gDriverDMInfo.dmDriverExtra500) &&
                    ((wSize + wOEMExtra) <= pdmInput->dmDriverExtra))
                {
                    //
                    // pdmInput is from our Win2K/XP/Longhorn+ Unidrv driver
                    //
                    bMSdm500In = TRUE;
                }
            }
        }

        if (bMSdm500In && (wCoreFixSize > wSize))
            wCoreFixSize = wSize;
    }
    else
    {
        if (gdwDriverDMSignature == PSDEVMODE_SIGNATURE)
        {
           if (pdmInput->dmDriverVersion == PSDRIVER_VERSION_400 &&
               wCoreFixSize == sizeof(PSDRVEXTRA400) &&
               (((PSDRVEXTRA400 *) pDrvExtraIn)->dwSignature == PSDEVMODE_SIGNATURE))
           {
               //
               // pdmInput is from our NT4 PScript driver
               //
               bMSdmPS4In = TRUE;
           }
        }
    }

    //
    // Possible sources for pdmInput and their outcome at this point:
    //
    // 1. unknown driver (including NT4 Rasdd)
    //       bMSdm500In = FALSE, bMSdmPS4in = FALSE,
    //       wCoreFixSize = pdmInput->dmDriverExtra, wOEMExtra = 0
    //
    // 2. NT4 PScript driver
    //       bMSdm500In = FALSE, bMSdmPS4in = TRUE,
    //       wCoreFixSize = pdmInput->dmDriverExtra, wOEMExtra = 0
    //
    // 3. Win2K/XP driver without plugin
    //       bMSdm500In = TRUE, bMSdmPS4in = FALSE,
    //       wCoreFixSize = pdmInput->dmDriverExtra, wOEMExtra = 0
    //
    // 4. Win2K/XP driver with plugin
    //       bMSdm500In = TRUE, bMSdmPS4in = FALSE,
    //       wCoreFixSize = pdmInPriv->wSize < pdmInput->dmDriverExtra,
    //       wOEMExtra = pdmInPriv->wOEMExtra > 0
    //
    if (bMSdm500In || bMSdmPS4In)
    {
        CopyMemory(GET_DRIVER_PRIVATE_DEVMODE(pdm),
                   pDrvExtraIn,
                   min(gDriverDMInfo.dmDriverExtra, wCoreFixSize));
    }
    else
    {
        //
        // pdmInput is from unknown driver, so copy our default private devmode.
        // We don't want to copy unknown private devmode and then change all the
        // size/version fields to have our current driver's values.
        //
        WARNING(("Input devmode is unknown, so ignore its private portion.\n"));

        CopyMemory(GET_DRIVER_PRIVATE_DEVMODE(pdm),
                   GET_DRIVER_PRIVATE_DEVMODE(pdmDefault),
                   gDriverDMInfo.dmDriverExtra);
    }

    //
    // Validate option array setting in the input devmode and correct
    // any invalid option selections. This is needed since our future
    // code assumes that the option array always have valid settings.
    //
    if (bMSdm500In)
    {
        PVOID       pDrvExtraOut;
        POPTSELECT  pOptions;

        //
        // We are dealing with input devmode of Win2K/XP/Longhorn+ inbox drivers
        //
        pDrvExtraOut = GET_DRIVER_PRIVATE_DEVMODE(pdm);

        if (gdwDriverDMSignature == PSDEVMODE_SIGNATURE)
        {
            pOptions = ((PPSDRVEXTRA) pDrvExtraOut)->aOptions;
        }
        else
        {
            pOptions = ((PUNIDRVEXTRA) pDrvExtraOut)->aOptions;
        }

        //
        // validate input devmode option array and correct any invalid selections
        //

        ValidateDocOptions(pRawData,
                           pOptions,
                           MAX_PRINTER_OPTIONS);
    }

    pdm->dmDriverVersion = gDriverDMInfo.dmDriverVersion;

    //
    // CopyMemory above overwrote size fields in private devmode, need to restore them.
    //
    VPatchDevmodeSizeFields(pdm, gDriverDMInfo.dmDriverExtra, dwOemDMSize);

    if (dwOemDMSize)
    {
        //
        // Convert OEM plugin private devmodes.
        // Start out with valid default settings.
        //

        pOemDMOut = (PBYTE) pdm + (sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra);

        CopyMemory(pOemDMOut,
                   (PBYTE) pdmDefault + (sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra),
                   dwOemDMSize);

        //
        // Plugins are only supported by our Win2K and above drivers.
        //
        if (bMSdm500In && (wOEMExtra > 0) && (pdmInput->dmDriverExtra > wCoreFixSize))
        {
            pOemDMIn = (PBYTE) pdmInput + (pdmInput->dmSize + wCoreFixSize);

            //
            // We used to use "pdmInput->dmDriverExtra - wCoreFixSize" instead of "wOEMExtra"
            // in this call, but that is under the assumption that everything after the core
            // fixed fields are plugin devmodes. That assumption may not be true in Longhorn.
            //
            if (! BConvertOemPluginDevmode(
                        hPrinter,
                        pdm,
                        pdmInput,
                        pOemDMOut,
                        pOemDMIn,
                        (LONG)wOEMExtra,
                        pOemPlugins))
            {
                MemFree(pdm);
                return NULL;
            }
        }
    }

    *pdwOemDMSize = dwOemDMSize;
    return pdm;
}



BOOL
BValidateAndMergeDevmodeWithOemPlugins(
    IN OUT PDEVMODE     pdmOutput,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN PDEVMODE         pdmInput,
    IN OUT POEM_PLUGINS pOemPlugins,
    IN HANDLE           hPrinter
    )

/*++

Routine Description:

    Valicate input devmode and merge it into the output devmode.
    This include public devmode, driver private devmode, as well as
    private devmode for any OEM plugins.

Arguments:

    pdmOutput - Points to the output devmode
    pUIInfo - Points to a UIINFO structure
    pRawData - Points to raw binary printer description data
    pdmInput - Points to the input devmode
    pOemPlugins - Points to information about OEM plugins
    hPrinter - Handle to the current printer

Return Value:

    TRUE if successful, FALSE otherwise

Note:

    The output devmode must be a valid current version devmode
    when this function is called.

--*/

{
    PDEVMODE    pdmConverted;
    DWORD       dwOemDMSize;
    BOOL        bResult;

    if (pdmInput == NULL)
        return TRUE;

    //
    // Otherwise, convert the input devmode to current version first
    //

    pdmConverted = PConvertToCurrentVersionDevmodeWithOemPlugins(
                            hPrinter,
                            pRawData,
                            pdmInput,
                            pdmOutput,
                            pOemPlugins,
                            &dwOemDMSize);

    if ((pdmInput = pdmConverted) == NULL)
        return FALSE;

    //
    // Validate and merge public and driver private devmode fields
    //

    bResult = BMergeDriverDevmode(pdmOutput, pUIInfo, pRawData, pdmInput);

    //
    // Validate and merge OEM plugin private devmode fields
    //

    if (bResult && dwOemDMSize)
    {
        DWORD dwSystemDMSize = sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra;

        bResult = BValidateAndMergeOemPluginDevmode(
                        hPrinter,
                        pdmOutput,
                        pdmInput,
                        (POEM_DMEXTRAHEADER) ((PBYTE) pdmOutput + dwSystemDMSize),
                        (POEM_DMEXTRAHEADER) ((PBYTE) pdmInput + dwSystemDMSize),
                        pOemPlugins);
    }

    MemFree(pdmConverted);
    return bResult;
}


#if defined(KERNEL_MODE) && defined(WINNT_40)


BOOL
BOEMPluginFirstLoad(
    IN PTSTR                      ptstrDriverFile,
    IN OUT POEM_PLUGIN_REFCOUNT   *ppOEMPluginRefCount
    )

/*++

Routine Description:

    Maintains ref count for the render plugin DLL and determines if it's
    loaded for the first time.

Arguments:

    ptstrDriverFile - OEM render plugin DLL name with fully qualified path
    ppOEMPluginRefCount - pointer to the pointer of OEM render plugin ref count link list

Return Value:

    TRUE: the render plugin DLL is loaded for the first time
    FALSE: otherwise

--*/

{
    POEM_PLUGIN_REFCOUNT    pRefCount;
    PTSTR                   ptstrPluginDllName;
    INT                     iDllNameLen;

    ASSERT(ptstrDriverFile && ppOEMPluginRefCount);

    //
    // Get the plugin DLL name without any path prefix
    //

    if ((ptstrPluginDllName = _tcsrchr(ptstrDriverFile, TEXT(PATH_SEPARATOR))) == NULL)
    {
        WARNING(("Plugin DLL path is not fully qualified: %ws\n", ptstrDriverFile));
        ptstrPluginDllName = ptstrDriverFile;
    }
    else
    {
        ptstrPluginDllName++;   // skip the last '\'
    }

    iDllNameLen = _tcslen(ptstrPluginDllName);

    pRefCount = *ppOEMPluginRefCount;

    //
    // Search to see if the plugin DLL name is already in the ref count link list
    //

    while (pRefCount)
    {
        if (_tcsicmp(pRefCount->ptstrDriverFile, ptstrPluginDllName) == EQUAL_STRING)
        {
            break;
        }

        pRefCount = pRefCount->pNext;
    }

    if (pRefCount == NULL)
    {
        //
        // A new plugin DLL is loaded. Add it to the ref count link list.
        //

        if ((pRefCount = MemAllocZ(sizeof(OEM_PLUGIN_REFCOUNT) + (iDllNameLen + 1)*sizeof(TCHAR))) == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pRefCount->ptstrDriverFile = (PTSTR)((PBYTE)pRefCount + sizeof(OEM_PLUGIN_REFCOUNT));

        pRefCount->dwRefCount = 1;
        CopyMemory(pRefCount->ptstrDriverFile, ptstrPluginDllName, iDllNameLen * sizeof(TCHAR));
        pRefCount->pNext = *ppOEMPluginRefCount;

        *ppOEMPluginRefCount = pRefCount;

        return TRUE;
    }
    else
    {
        //
        // The plugin DLL name is already in the ref count link list, so just increase its ref count.
        //

        pRefCount->dwRefCount++;

        return FALSE;
    }
}


BOOL
BOEMPluginLastUnload(
    IN PTSTR                      ptstrDriverFile,
    IN OUT POEM_PLUGIN_REFCOUNT   *ppOEMPluginRefCount
    )

/*++

Routine Description:

    Maintains ref count for the render plugin DLL and determines if it's
    unloaded by the last client.

Arguments:

    ptstrDriverFile - OEM render plugin DLL name with fully qualified path
    ppOEMPluginRefCount - pointer to the pointer of OEM render plugin ref count link list

Return Value:

    TRUE: the render plugin DLL is unloaded by the last client
    FALSE: otherwise

--*/

{
    POEM_PLUGIN_REFCOUNT    pRefCountPrev, pRefCount;
    PTSTR                   ptstrPluginDllName;

    ASSERT(ptstrDriverFile && ppOEMPluginRefCount);

    //
    // Get the plugin DLL name without any path prefix
    //

    if ((ptstrPluginDllName = _tcsrchr(ptstrDriverFile, TEXT(PATH_SEPARATOR))) == NULL)
    {
        WARNING(("Plugin DLL path is not fully qualified: %ws\n", ptstrDriverFile));
        ptstrPluginDllName = ptstrDriverFile;
    }
    else
    {
        ptstrPluginDllName++;   // skip the last '\'
    }

    pRefCountPrev = NULL;
    pRefCount = *ppOEMPluginRefCount;

    //
    // Search to locate the plugin DLL entry in the ref count link list
    //

    while (pRefCount)
    {
        if (_tcsicmp(pRefCount->ptstrDriverFile, ptstrPluginDllName) == EQUAL_STRING)
        {
            break;
        }

        pRefCountPrev = pRefCount;
        pRefCount = pRefCount->pNext;
    }

    if (pRefCount == NULL)
    {
        RIP(("Plugin DLL name is not in the ref count list: %ws\n", ptstrPluginDllName));
        return FALSE;
    }

    if (--(pRefCount->dwRefCount) == 0)
    {
        //
        // If the ref count decreases to 0, we need to remove the plugin DLL from the ref
        // count link list.
        //

        if (pRefCountPrev == NULL)
        {
            *ppOEMPluginRefCount = pRefCount->pNext;
        }
        else
        {
            pRefCountPrev->pNext = pRefCount->pNext;
        }

        MemFree(pRefCount);

        return TRUE;
    }

    return FALSE;
}


VOID
VFreePluginRefCountList(
    IN OUT POEM_PLUGIN_REFCOUNT   *ppOEMPluginRefCount
    )

/*++

Routine Description:

    Free memory allocated in the ref count link list, and remove all the nodes in the list.
    Finally the link list will be reset to empty.

Arguments:

    ppOEMPluginRefCount - pointer to the pointer of OEM render plugin ref count link list

Return Value:

    None

--*/

{
    POEM_PLUGIN_REFCOUNT    pRefCountRemove, pRefCount;

    pRefCount = *ppOEMPluginRefCount;

    while (pRefCount)
    {
        pRefCountRemove = pRefCount;
        pRefCount = pRefCount->pNext;

        MemFree(pRefCountRemove);
    }

    *ppOEMPluginRefCount = NULL;
}

#endif // KERNEL_MODE && WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\oemutil\oemcom.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    oemcom.cxx

Abstract:

    Implementation of Windows NT printer driver OEM COM plugins

Environment:

    Windows NT

Revision History:

    02/06/98 -steveki-
        Initial framework.

--*/

#include <lib.h>

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

static const CHAR szDllGetClassObject[] = "DllGetClassObject";
static const CHAR szDllCanUnloadNow[]   = "DllCanUnloadNow";

#ifdef WINNT_40
extern "C"  EngFindImageProcAddress(HMODULE, CHAR *);
extern "C"  EngUnloadImage(HMODULE);
#endif


extern "C" HRESULT
HDriver_CoGetClassObject(
    IN REFCLSID     rclsid,
    IN DWORD        dwClsContext,
    IN LPVOID       pvReservedForDCOM,
    IN REFIID       riid,
    IN LPVOID      *ppv,
    IN HANDLE       hInstance
    )

/*++

Routine Description:

    Locate and connect to the class factory object associated with the class identifier rclsid.

Arguments:

    rclsid - Specifies the class factory component.
    dwClsContext - Specifies the context in which the executable code is to be run.
    pvReservedForDCOM - Reserved for future use; must be NULL.
    riid - Specifies the interface to be used to communicate with the class object.
    ppv - Points to where to return the pointer to the requested interface.
    hInstance - Handle to the loaded OEM plugin module.

Return Value:

    S_OK if successful, E_FAIL if DllGetClassObject entry point is not found. Refer to COM spec
    for other possible error codes that can be returned.

--*/

{
    HRESULT               hr = E_FAIL;
    LPFNGETCLASSOBJECT    pfnDllGetClassObject = NULL;

    //
    // Get the class object procedure address.
    //

    if (hInstance && (pfnDllGetClassObject = (LPFNGETCLASSOBJECT)GetProcAddress((HMODULE)hInstance,
                                                                                (CHAR *)szDllGetClassObject)))
    {
        //
        // Ask for the class factory interface.
        //

        hr = pfnDllGetClassObject(rclsid, riid, ppv);
    }

    return hr;
}



extern "C" HRESULT
HDriver_CoCreateInstance(
    IN REFCLSID     rclsid,
    IN LPUNKNOWN    pUnknownOuter,
    IN DWORD        dwClsContext,
    IN REFIID       riid,
    IN LPVOID      *ppv,
    IN HANDLE       hInstance
    )

/*++

Routine Description:

    Create an instance of the class rclsid, asking for interface riid using the given execution context.

Arguments:

    rclsid - Specifies the class factory component.
    pUnknownOuter - Specifies the controlling unknown of the aggregate.
    dwClsContext - Specifies the context in which the executable is to be run.
    riid - Specifies the interface to be used to communicate with the class object.
    ppv - Points to where to return the pointer to the requested interface.
    hInstance - Handle to the loaded OEM plugin module.

Return Value:

    S_OK if successful. Refer to COM spec for other possible error codes that can be returned.

--*/

{
    HRESULT         hr          = E_FAIL;
    IClassFactory  *pIFactory   = NULL;

    //
    // Set output parameter to NULL.
    //

    *ppv = NULL;

    //
    // We can only support in process servers.  We do not have any
    // code for marshaling to another process.
    //

    if (dwClsContext == CLSCTX_INPROC_SERVER)
    {

        hr = HDriver_CoGetClassObject(rclsid,
                                     dwClsContext,
                                     NULL,
                                     IID_IClassFactory,
                                     (void **)&pIFactory,
                                     hInstance);


        if(SUCCEEDED(hr))
        {
            hr = pIFactory->CreateInstance(pUnknownOuter, riid, ppv);

            //
            // Release the class factory.
            //

            pIFactory->Release();
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}



extern "C" VOID
Driver_CoFreeOEMLibrary(
    IN HANDLE hInstance
    )

/*++

Routine Description:

    Unloads OEM plugin DLL that are no longer serving any components.

Arguments:

    hInstance - Handle to the loaded OEM plugin module.

Return Value:

    None.

--*/

{
    LPFNCANUNLOADNOW pfnDllCanUnloadNow = NULL;

    if (hInstance && (pfnDllCanUnloadNow = (LPFNCANUNLOADNOW)GetProcAddress((HMODULE)hInstance,
                                                                            (CHAR *)szDllCanUnloadNow)))
    {
        (VOID) pfnDllCanUnloadNow();

        //
        // We don't look at the return value of DllCanUnloadNow() and always do a FreeLibrary here,
        // otherwise we may end up with OEM DLL still remains in memory when all its instances are
        // unloaded.
        //
        // If OEM DLL spins off a working thread which also uses the OEM DLL, the thread needs to
        // do LoadLibrary and FreeLibraryExitThread, otherwise it may crash after we called FreeLibrary.
        //

        FreeLibrary((HMODULE)hInstance);
    }
}



extern "C" BOOL
BQILatestOemInterface(
    IN HANDLE       hInstance,
    IN REFCLSID     rclsid,
    IN const GUID   *PrintOem_IIDs[],
    OUT PVOID       *ppIntfOem,
    OUT GUID        *piidIntfOem
    )

/*++

Routine Description:

    Retrieve the latest interface supported by OEM plugin

Arguments:

    hInstance - handle to the loaded OEM plugin module
    rclsid - specifies the class factory component
    PrintOem_IIDs[] - array of IIDs for plugin interfaces (from latest to oldest) driver supports
    ppIntfOem - points to where to return the interface pointer we get from OEM plugin
    piidIntfOem - points to where to return the IID for the interface we get from OEM plguin

Return Value:

    TRUE if retrieving OEM plugin interface is successful. FALSE otherwise.

--*/

{
    IUnknown     *pIUnknown = NULL;
    IUnknown     *pIPrintOem = NULL;
    HRESULT      hr;
    INT          iid_index;
    BOOL         bIntfFound;

    hr = HDriver_CoCreateInstance(rclsid,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IUnknown,
                                  (void **)&pIUnknown,
                                  hInstance);

    if (FAILED(hr) || pIUnknown == NULL)
    {
        ERR(("HDriver_CoCreateInstance failed\n"));
        return FALSE;
    }

    iid_index = 0;
    bIntfFound = FALSE;

    //
    // QI for the driver supported plugin interfaces from latest to oldest,
    // until one is supported by the OEM plugin, or until we hit the NULL
    // terminator.
    //
    while (!bIntfFound && PrintOem_IIDs[iid_index] != NULL)
    {
        hr = pIUnknown->QueryInterface(*PrintOem_IIDs[iid_index], (void **)&pIPrintOem);

        if (SUCCEEDED(hr) && pIPrintOem != NULL)
            bIntfFound = TRUE;
        else
            iid_index++;
    }

    pIUnknown->Release();

    if (!bIntfFound)
    {
        ERR(("Can't get a plugin interface we support!\n"));
        return FALSE;
    }

    *ppIntfOem = (PVOID)pIPrintOem;
    *piidIntfOem = *PrintOem_IIDs[iid_index];

    return TRUE;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ps\sources.inc ===
!IF 0

Copyright (c) 1996-1997  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

SOURCES=..\psutil.c   \
        ..\getdata.c  \
        ..\getsetop.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\goodname.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    GoodName  -- Give a good name(searchable) for each downloaded glyph
 *
 *
 * $Header:
 */
#ifndef GOODNAME_H
#define GOODNAME_H
/* --------------------------------------------------------- */
/* For ToUnicode Information, we are interested in TTF's cmap of
 * Platform=3, Encoding=1 and cmapFormat=4  
 for other format, we need to use external CodePoint To Unicode CMaps:
  WinPlatformID EncodingID Format Description 
  3 1  4 Unicode 
  3 2  4 ShiftJIS 
  3 3  4 PRC  --- Not sure if this is PRC - TTF doc says Big5
  3 4  4 Big5 --- We know this is actually Big5, see Win95CT's MingLi.ttc.
  3 5  4 Wansung 
  3 6  4 Johab 
  Also parse cmap of format 2, fix bug 274659, 12-29-98
  WinPlatformID EncodingID Format Description 
  3 1  2 Unicode 
  3 2  2 ShiftJIS 
  3 3  2 PRC  --- Not sure if this is PRC - TTF doc says Big5
  3 4  2 Big5 --- We know this is actually Big5, see Win95CT's MingLi.ttc.
  3 5  2 Wansung 
  3 6  2 Johab 

 */

#define GSUB_HEADERSIZE 10    /* Version (4) + 3 Offsets(2) = 10 bytes */
#define mort_HEADERSIZE 76    /* fixed size - see TT Spec for glyph metamorphosis table ('mort') */

typedef enum 
{
  DTT_parseCmapOnly = 0,
  DTT_parseMoreGSUBOnly,
  DTT_parseAllTables
}TTparseFlag;

typedef enum 
{
  /* Microsoft platformID = 3 */
  DTT_Win_UNICODE_cmap2  = 0,
  DTT_Win_CS_cmap2,     
  DTT_Win_CT_cmap2,     
  DTT_Win_J_cmap2 ,
  DTT_Win_K_cmap2 ,     
  DTT_Win_UNICODE_cmap4,
  DTT_Win_CS_cmap4,     
  DTT_Win_CT_cmap4,     
  DTT_Win_J_cmap4 ,
  DTT_Win_K_cmap4 ,     
}TTcmapFormat;
#define TTcmap_IS_UNICODE(cf)  \
    ((cf) == DTT_Win_UNICODE_cmap2 || (cf) == DTT_Win_UNICODE_cmap4)
#define TTcmap_IS_FORMAT2(cf)  \
    (((cf) >= DTT_Win_UNICODE_cmap2 && (cf) <= DTT_Win_K_cmap2) )
#define TTcmap_IS_J_CMAP(cf) \
    ((cf) == DTT_Win_J_cmap2 || (cf) == DTT_Win_J_cmap4)
#define TTcmap_IS_CS_CMAP(cf) \
    ((cf) == DTT_Win_CS_cmap2 || (cf) == DTT_Win_CS_cmap4)
#define TTcmap_IS_CT_CMAP(cf) \
    ((cf) == DTT_Win_CT_cmap2 || (cf) == DTT_Win_CT_cmap4)
#define TTcmap_IS_K_CMAP(cf) \
    ((cf) == DTT_Win_K_cmap2 || (cf) == DTT_Win_K_cmap4)

typedef struct
{
    unsigned short platformID;
    unsigned short encodingID;
    unsigned long  offset;
}SubTableEntry, *PSubTableEntry;

typedef struct t_TTcmap2SubHeader
{
    unsigned short    firstCode;
    unsigned short    entryCount;  
    short             idDelta;  
    unsigned short    idRangeOffset;
}TTcmap2SH, *PTTcmap2SH;

typedef struct t_TTcmap2Stuff
{
    unsigned short*    subHeaderKeys;  /* Array of 256 USHORT, HighByte --> 8*subHeaderIndex */
    PTTcmap2SH         subHeaders;     /* SubHeaders */
    unsigned char*     pByte;          /* cmap data pointer, for Byte offset calculation */
}TTcmap2Stuff;

typedef struct t_TTcmap4Stuff
{
    unsigned short     segCount;
    unsigned short*    endCode;        /* End characterCode for each segment, last =0xFFFF.*/
    unsigned short*    startCode;
    unsigned short*    idDelta;        /* Delta for all character codes in segment */
    unsigned short*    idRangeOffset;  /* Offsets into glyphIdArray or 0 */
    unsigned short*    glyphIdArray;
}TTcmap4Stuff;

typedef struct t_TTmortStuff
{
    unsigned short     nEntries;
    unsigned short*    pGlyphSet;
}TTmortStuff;

typedef struct t_TTGSUBStuff
{
    unsigned short     lookupCount;
    unsigned short*    pLookupList;
}TTGSUBStuff;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ps\getsetop.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    getsetop.c

Abstract:

    PostScript helper functions for OEM plugins

        HGetOptions

Author:

    Feng Yue (fengy)

    8/24/2000 fengy Completed with support of both PPD and driver features.
    8/1/2000 fengy Created it with function framework.

--*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"

//
// PS driver's helper functions for OEM plugins
//

//
// synthesized PS driver features
//

const CHAR kstrPSFAddEuro[]     = "%AddEuro";
const CHAR kstrPSFCtrlDAfter[]  = "%CtrlDAfter";
const CHAR kstrPSFCtrlDBefore[] = "%CtrlDBefore";
const CHAR kstrPSFCustomPS[]    = "%CustomPageSize";
const CHAR kstrPSFTrueGrayG[]   = "%GraphicsTrueGray";
const CHAR kstrPSFJobTimeout[]  = "%JobTimeout";
const CHAR kstrPSFMaxBitmap[]   = "%MaxFontSizeAsBitmap";
const CHAR kstrPSFEMF[]         = "%MetafileSpooling";
const CHAR kstrPSFMinOutline[]  = "%MinFontSizeAsOutline";
const CHAR kstrPSFMirroring[]   = "%Mirroring";
const CHAR kstrPSFNegative[]    = "%Negative";
const CHAR kstrPSFPageOrder[]   = "%PageOrder";
const CHAR kstrPSFNup[]         = "%PagePerSheet";
const CHAR kstrPSFErrHandler[]  = "%PSErrorHandler";
const CHAR kstrPSFPSMemory[]    = "%PSMemory";
const CHAR kstrPSFOrientation[] = "%Orientation";
const CHAR kstrPSFOutFormat[]   = "%OutputFormat";
const CHAR kstrPSFOutProtocol[] = "%OutputProtocol";
const CHAR kstrPSFOutPSLevel[]  = "%OutputPSLevel";
const CHAR kstrPSFTrueGrayT[]   = "%TextTrueGray";
const CHAR kstrPSFTTFormat[]    = "%TTDownloadFormat";
const CHAR kstrPSFWaitTimeout[] = "%WaitTimeout";

//
// commonly used keyword strings
//

const CHAR kstrKwdTrue[]  = "True";
const CHAR kstrKwdFalse[] = "False";

#define MAX_WORD_VALUE     0x7fff
#define MAX_DWORD_VALUE    0x7fffffff

#define RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode) \
        if ((dwMode) == PSFPROC_ENUMOPTION_MODE) \
        { \
            SetLastError(ERROR_NOT_SUPPORTED); \
            return FALSE; \
        }


/*++

Routine Name:

    BOutputFeatureOption

Routine Description:

    output one pair of feature keyword and option keyword names

Arguments:

    pszFeature - feature keyword name
    pszOption - option keyword name
    pmszOutBuf - pointer to output data buffer
    cbRemain - remaining output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to output the keyword pair

Return Value:

    TRUE   if succeeds
    FALSE  if output data buffer size is not big enough

Last Error:

    ERROR_INSUFFICIENT_BUFFER if FALSE is returned

--*/
BOOL
BOutputFeatureOption(
    IN  PCSTR  pszFeature,
    IN  PCSTR  pszOption,
    OUT PSTR   pmszOutBuf,
    IN  INT    cbRemain,
    OUT PDWORD pcbNeeded
    )
{
    DWORD  cbFeatureSize, cbOptionSize;

    ASSERT(pszFeature && pszOption);

    cbFeatureSize = strlen(pszFeature) + 1;
    cbOptionSize  = strlen(pszOption) + 1;

    if (pcbNeeded)
    {
        *pcbNeeded = cbFeatureSize + cbOptionSize;
    }

    if (!pmszOutBuf || cbRemain < (INT)(cbFeatureSize + cbOptionSize))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    CopyMemory(pmszOutBuf, pszFeature, cbFeatureSize);
    pmszOutBuf += cbFeatureSize;
    CopyMemory(pmszOutBuf, pszOption, cbOptionSize);

    return TRUE;
}


/*++

Routine Name:

    BReadBooleanOption

Routine Description:

    return boolean value specified by the option keyword name

Arguments:

    pszOption - option keyword name
    pbValue - pointer to the variable to store returned boolean value

Return Value:

    TRUE   if the read operation succeeds
    FALSE  otherwise

Last Error:

    None

--*/
BOOL
BReadBooleanOption(
    IN  PCSTR  pszOption,
    OUT PBOOL  pbValue
    )
{
    BOOL bReadOK = TRUE;

    ASSERT(pszOption && pbValue);

    if (strcmp(pszOption, kstrKwdTrue) == EQUAL_STRING)
    {
        *pbValue = TRUE;
    }
    else if (strcmp(pszOption, kstrKwdFalse) == EQUAL_STRING)
    {
        *pbValue = FALSE;
    }
    else
    {
        bReadOK = FALSE;
    }

    return bReadOK;
}


/*++

Routine Name:

    BGetSetBoolFlag

Routine Description:

    get or set a feature's boolean setting

Arguments:

    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pdwValue - pointer to DWORD data that stores the feature's setting
    dwFlagBit - flag bit value to indicate the feature's setting is TRUE
    bValid - TRUE if get/set on the feature's setting is supported. FALSE otherwise.
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the boolean setting
    bSetMode - TRUE for set operation, FALSE for get operation

Return Value:

    TRUE   if the get or set operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if FALSE is returned because set operation
                                is not supported, or set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   (get only) see BOutputFeatureOption

--*/
BOOL
BGetSetBoolFlag(
    IN  PCSTR   pszFeature,
    IN  PCSTR   pszOption,
    IN  PDWORD  pdwValue,
    IN  DWORD   dwFlagBit,
    IN  BOOL    bValid,
    OUT PSTR    pmszOutBuf,
    IN  INT     cbRemain,
    OUT PDWORD  pcbNeeded,
    IN  BOOL    bSetMode
    )
{
    BOOL bFlagSet;

    ASSERT(pdwValue);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        if (!bValid ||
            !BReadBooleanOption(pszOption, &bFlagSet))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (bFlagSet)
        {
            *pdwValue |= dwFlagBit;
        }
        else
        {
            *pdwValue &= ~dwFlagBit;
        }

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        if (bValid && (*pdwValue & dwFlagBit))
        {
            bFlagSet = TRUE;
        }
        else
        {
            bFlagSet = FALSE;
        }

        return BOutputFeatureOption(pszFeature,
                                    bFlagSet ? kstrKwdTrue : kstrKwdFalse,
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BReadUnsignedInt

Routine Description:

    return unsigned integer value specified in the input data buffer

Arguments:

    pcstrArgument - pointer to the input data buffer, where UINT value(s) are
                    represented as string of digit characters
    bSingleArgument - TRUE if only one UINT should be read from the input data
                      FALSE if multiple UINTs can be read from the input data
    pdwValue - pointer to the variable to store returned unsigned integer value

Return Value:

    NULL      read failed due to invalid characters in the digit string
    non-NULL  read succeeds. The new pointer position in the input data buffer
              after one UINT is read will be returned.

Last Error:

    None

--*/
PCSTR
PReadUnsignedInt(
    IN  PCSTR  pcstrArgument,
    IN  BOOL   bSingleArgument,
    OUT PDWORD pdwValue
    )
{
    DWORD dwTemp = 0;

    ASSERT(pcstrArgument && pdwValue);

    //
    // skip any preceding white spaces
    //

    while (*pcstrArgument == ' ' || *pcstrArgument == '\t')
    {
        pcstrArgument++;
    }

    //
    // the first non-white space character must be a digit
    //

    if (!(*pcstrArgument >= '0' && *pcstrArgument <= '9'))
    {
        ERR(("first non-white space character is not a digit\n"));
        return NULL;
    }

    //
    // read in the digits
    //

    while (*pcstrArgument >= '0' && *pcstrArgument <= '9')
    {
        dwTemp = dwTemp * 10 + *pcstrArgument - '0';
        pcstrArgument++;
    }

    if (bSingleArgument)
    {
        //
        // any remaing characters must be white spaces
        //

        while (*pcstrArgument)
        {
            if (*pcstrArgument != ' ' && *pcstrArgument != '\t')
            {
                ERR(("character after digits is not white space\n"));
                return NULL;
            }

            pcstrArgument++;
        }
    }
    else
    {
        //
        // skip any remaining white spaces
        //

        while (*pcstrArgument == ' ' || *pcstrArgument == '\t')
        {
            pcstrArgument++;
        }
    }

    *pdwValue = dwTemp;

    return pcstrArgument;
}


/*++

Routine Name:

    BGetSetUnsignedInt

Routine Description:

    get or set a feature's unsigned integer setting

Arguments:

    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pdwValue - pointer to DWORD data that stores the feature's setting
    dwMaxVal - maximum valid UINT value for the feature's setting
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the UINT setting
    bSetMode - TRUE for set operation, FALSE for get operation

Return Value:

    TRUE   if the get or set operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if set operation failed because of
                                invalid character(s) in the digit character string
    ERROR_INSUFFICIENT_BUFFER   (get only) see BOutputFeatureOption

--*/
BOOL
BGetSetUnsignedInt(
    IN     PCSTR   pszFeature,
    IN     PCSTR   pszOption,
    IN OUT PDWORD  pdwValue,
    IN     DWORD   dwMaxVal,
    OUT    PSTR    pmszOutBuf,
    IN     INT     cbRemain,
    OUT    PDWORD  pcbNeeded,
    IN     BOOL    bSetMode
    )
{
    ASSERT(pdwValue);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        DWORD dwTemp;

        if (!PReadUnsignedInt(pszOption, TRUE, &dwTemp) ||
            dwTemp > dwMaxVal)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        *pdwValue = dwTemp;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        CHAR  pszValue[16];

        _ultoa(*pdwValue, pszValue, 10);

        return BOutputFeatureOption(pszFeature,
                                    pszValue,
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_AddEuro

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_AddEuro(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bValid, bResult;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    bValid = pUIInfo->dwLangLevel >= 2;

    bResult = BGetSetBoolFlag(pszFeature,
                              pszOption,
                              &(pPrinterData->dwFlags),
                              PFLAGS_ADD_EURO,
                              bValid,
                              pmszOutBuf,
                              cbRemain,
                              pcbNeeded,
                              bSetMode);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode && bResult)
    {
        pPrinterData->dwFlags |= PFLAGS_EURO_SET;
    }

    #endif // !KERNEL_MODE

    return bResult;
}


/*++

Routine Name:

    BPSFProc_CtrlDA

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_CtrlDA(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pPrinterData->dwFlags),
                           PFLAGS_CTRLD_AFTER,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_CtrlDB

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_CtrlDB(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pPrinterData->dwFlags),
                           PFLAGS_CTRLD_BEFORE,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_CustomPS

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested
    ERROR_INVALID_PARAMETER     if get/set of the feature setting is not supported,
                                or set operation found invalid arguments
    ERROR_INSUFFICIENT_BUFFER   (get only) if output data buffer size is not big enough

--*/
BOOL
BPSFProc_CustomPS(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    typedef struct _PSF_CUSTOMFEED_ENTRY {

        PCSTR    pszFeedName;        // feed direction name
        DWORD    dwFeedDirection;    // feed direction code

    } PSF_CUSTOMFEED_ENTRY, *PPSF_CUSTOMFEED_ENTRY;

    static const PSF_CUSTOMFEED_ENTRY kPSF_CustomFeedTable[] =
    {
        {"LongEdge",           LONGEDGEFIRST},
        {"ShortEdge",          SHORTEDGEFIRST},
        {"LongEdgeFlip",       LONGEDGEFIRST_FLIPPED},
        {"ShortEdgeFlip",      SHORTEDGEFIRST_FLIPPED},
        {NULL,                 0},
    };

    PPSF_CUSTOMFEED_ENTRY  pEntry, pMatchEntry;
    PPSDRVEXTRA pdmPrivate;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // This feature is supported when the printer supports custom
    // page size AND current custom page size is currently selected
    //
    // For reason of following check, refer to BPackItemFormName in
    // docprop.c and BDisplayPSCustomPageSizeDialog in custsize.c.
    //

    if (!SUPPORT_CUSTOMSIZE(pUIInfo) ||
        !SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUIInfo, pPpdData) ||
        pdm->dmPaperSize != DMPAPER_CUSTOMSIZE)
    {
        ERR(("custom size not supported/selected: dmPaperSize=%d, mode=%d\n", pdm->dmPaperSize, bSetMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pMatchEntry = NULL;
    pEntry = (PPSF_CUSTOMFEED_ENTRY)&(kPSF_CustomFeedTable[0]);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        PCSTR pcstrArgument = pszOption;
        CUSTOMSIZEDATA csdata;
        BOOL  bResult;

        if ((pcstrArgument = PReadUnsignedInt(pcstrArgument,
                                              FALSE,
                                              &(csdata.dwX))) &&
            (pcstrArgument = PReadUnsignedInt(pcstrArgument,
                                              FALSE,
                                              &(csdata.dwY))) &&
            (pcstrArgument = PReadUnsignedInt(pcstrArgument,
                                              FALSE,
                                              &(csdata.dwWidthOffset))) &&
            (pcstrArgument = PReadUnsignedInt(pcstrArgument,
                                             FALSE,
                                             &(csdata.dwHeightOffset))))
        {
            while (pEntry->pszFeedName)
            {
                if ((*pcstrArgument == *(pEntry->pszFeedName)) &&
                    (strcmp(pcstrArgument, pEntry->pszFeedName) == EQUAL_STRING))
                {
                    pMatchEntry = pEntry;
                    break;
                }

                pEntry++;
            }

            if (!pMatchEntry)
            {
                //
                // unrecognized feed direction name
                //

                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            //
            // All arguments are recognized. Save into private devmode and do validation.
            //

            pdmPrivate->csdata.wFeedDirection = (WORD)pMatchEntry->dwFeedDirection;
            pdmPrivate->csdata.dwX = POINT_TO_MICRON(csdata.dwX);
            pdmPrivate->csdata.dwY = POINT_TO_MICRON(csdata.dwY);
            pdmPrivate->csdata.dwWidthOffset = POINT_TO_MICRON(csdata.dwWidthOffset);
            pdmPrivate->csdata.dwHeightOffset = POINT_TO_MICRON(csdata.dwHeightOffset);
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        bResult = BValidateCustomPageSizeData((PRAWBINARYDATA)(pUIInfo->pInfoHeader),
                                              &(pdmPrivate->csdata));

        if (!bResult)
        {
            VERBOSE(("Set: custom page size input arguments are adjusted\n"));
        }

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        DWORD cbFeatureSize, cbNeeded, cbFeedNameSize;
        INT   iIndex;

        ASSERT(pszFeature);

        cbNeeded = 0;

        //
        // frist output the feature keyword
        //

        cbFeatureSize = strlen(pszFeature) + 1;

        if (pmszOutBuf && (cbRemain >= (INT)cbFeatureSize))
        {
            CopyMemory(pmszOutBuf, pszFeature, cbFeatureSize);
            pmszOutBuf += cbFeatureSize;
        }

        cbRemain -= cbFeatureSize;
        cbNeeded += cbFeatureSize;

        //
        // then output the 4 custom page size parameters
        //

        for (iIndex = 0; iIndex < 4; iIndex++)
        {
            DWORD  dwValue, cbValueSize;
            CHAR   pszValue[16];

            switch (iIndex)
            {
                case 0:
                {
                    dwValue = pdmPrivate->csdata.dwX;
                    break;
                }
                case 1:
                {
                    dwValue = pdmPrivate->csdata.dwY;
                    break;
                }
                case 2:
                {
                    dwValue = pdmPrivate->csdata.dwWidthOffset;
                    break;
                }
                case 3:
                {
                    dwValue = pdmPrivate->csdata.dwWidthOffset;
                    break;
                }
                default:
                {
                    RIP(("hit bad iIndex %d\n", iIndex));
                    break;
                }
            }

            dwValue = MICRON_TO_POINT(dwValue);
            _ultoa(dwValue, pszValue, 10);

            cbValueSize = strlen(pszValue) + 1;

            if (pmszOutBuf && (cbRemain >= (INT)cbValueSize))
            {
                //
                // output the decimal value string
                //

                CopyMemory(pmszOutBuf, pszValue, cbValueSize);

                //
                // replace NUL with space as the separator between decimal value strings
                //

                pmszOutBuf += cbValueSize - 1;
                *pmszOutBuf = ' ';
                pmszOutBuf++;
            }

            cbRemain -= cbValueSize;
            cbNeeded += cbValueSize;
        }

        //
        // lastly output the feed direction name
        //

        while (pEntry->pszFeedName)
        {
            if (pdmPrivate->csdata.wFeedDirection == pEntry->dwFeedDirection)
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        if (!pMatchEntry)
        {
            RIP(("unknown wFeedDirection %d\n", pdmPrivate->csdata.wFeedDirection));
            pMatchEntry = (PPSF_CUSTOMFEED_ENTRY)&(kPSF_CustomFeedTable[0]);
        }

        cbFeedNameSize = strlen(pMatchEntry->pszFeedName) + 1;

        if (pmszOutBuf && (cbRemain >= (INT)cbFeedNameSize))
        {
            CopyMemory(pmszOutBuf, pMatchEntry->pszFeedName, cbFeedNameSize);
            pmszOutBuf += cbFeedNameSize;
        }

        cbRemain -= cbFeedNameSize;
        cbNeeded += cbFeedNameSize;

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        //
        // check if output buffer is big enough for all of the 5 parameters
        //

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }
}


/*++

Routine Name:

    BPSFProc_TrueGrayG

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_TrueGrayG(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pPrinterData->dwFlags),
                           PFLAGS_TRUE_GRAY_GRAPH,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_JobTimeout

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetUnsignedInt

--*/
BOOL
BPSFProc_JobTimeout(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to VUnpackPrinterPropertiesItems in prnprop.c
    // and _BPackPrinterOptions in ps.c
    //

    return BGetSetUnsignedInt(pszFeature,
                              pszOption,
                              &(pPrinterData->dwJobTimeout),
                              MAX_DWORD_VALUE,
                              pmszOutBuf,
                              cbRemain,
                              pcbNeeded,
                              bSetMode);
}


/*++

Routine Name:

    BPSFProc_MaxBitmap

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetUnsignedInt

--*/
BOOL
BPSFProc_MaxBitmap(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    DWORD dwValue;
    BOOL  bResult;
    BOOL  bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    dwValue = pPrinterData->wMaxbitmapPPEM;

    bResult = BGetSetUnsignedInt(pszFeature,
                                 pszOption,
                                 &dwValue,
                                 MAX_WORD_VALUE,
                                 pmszOutBuf,
                                 cbRemain,
                                 pcbNeeded,
                                 bSetMode);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode && bResult)
    {
        pPrinterData->wMaxbitmapPPEM = (WORD)dwValue;
    }

    #endif // !KERNEL_MODE

    return bResult;
}


/*++

Routine Name:

    BPSFProc_EMF

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested
    ERROR_INVALID_PARAMETER     if get/set of the feature setting is not supported,
                                or set operation found invalid arguments
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_EMF(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    PPSDRVEXTRA pdmPrivate;
    BOOL bResult;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // refer to BPackItemEmfFeatures and VUnpackDocumentPropertiesItems
    //
    // We assume spooler EMF is enabled if reverse printing is supported.
    // (refer to PFillUiData for how it sets pUiData->bEMFSpooling)
    //

    //
    // On Win2K+, this feature is not supported if spooler EMF is disabled.
    // On NT4, spooler doesn't support the EMF capability query, so we
    // always support our driver's EMF on/off feature.
    //

    #ifndef WINNT_40
    {
        BOOL bEMFSpooling;

        VGetSpoolerEmfCaps(hPrinter, NULL, &bEMFSpooling, 0, NULL);

        if (!bEMFSpooling)
        {
            ERR(("%s not supported when spooler EMF is disabled, mode=%d", pszFeature, bSetMode));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    #endif // !WINNT_40

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pdmPrivate->dwFlags),
                           PSDEVMODE_METAFILE_SPOOL,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_MinOutline

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetUnsignedInt

--*/
BOOL
BPSFProc_MinOutline(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    DWORD dwValue;
    BOOL  bResult;
    BOOL  bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    dwValue = pPrinterData->wMinoutlinePPEM;

    bResult = BGetSetUnsignedInt(pszFeature,
                                 pszOption,
                                 &dwValue,
                                 MAX_WORD_VALUE,
                                 pmszOutBuf,
                                 cbRemain,
                                 pcbNeeded,
                                 bSetMode);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode && bResult)
    {
        pPrinterData->wMinoutlinePPEM = (WORD)dwValue;
    }

    #endif // !KERNEL_MODE

    return bResult;
}


/*++

Routine Name:

    BPSFProc_Mirroring

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_Mirroring(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    PPSDRVEXTRA pdmPrivate;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // refer to _BPackDocumentOptions and _VUnpackDocumentOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pdmPrivate->dwFlags),
                           PSDEVMODE_MIRROR,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_Negative

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_Negative(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    PPSDRVEXTRA pdmPrivate;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // refer to _BPackDocumentOptions and _VUnpackDocumentOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pdmPrivate->dwFlags),
                           PSDEVMODE_NEG,
                           !IS_COLOR_DEVICE(pUIInfo),
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_PageOrder

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     if get/set of the feature setting is not supported,
                                or set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   if output data buffer size is not big enough for
                                enum or get operation

--*/
BOOL
BPSFProc_PageOrder(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    static const CHAR pstrPageOrder[][16] =
    {
        "FrontToBack",
        "BackToFront",
    };

    PPSDRVEXTRA pdmPrivate;
    INT  iIndex;
    BOOL bReversePrint;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    //
    // option enumeration handling
    //

    if (dwMode == PSFPROC_ENUMOPTION_MODE)
    {
        DWORD  cbNeeded = 0;

        for (iIndex = 0; iIndex < 2; iIndex++)
        {
            DWORD  cbOptionNameSize;

            cbOptionNameSize = strlen(pstrPageOrder[iIndex]) + 1;

            if (pmszOutBuf && cbRemain >= (INT)cbOptionNameSize)
            {
                CopyMemory(pmszOutBuf, pstrPageOrder[iIndex], cbOptionNameSize);
                pmszOutBuf += cbOptionNameSize;
            }

            cbRemain -= cbOptionNameSize;
            cbNeeded += cbOptionNameSize;
        }

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }

    //
    // option get/set handling
    //

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    VGetSpoolerEmfCaps(hPrinter, NULL, &bReversePrint, 0, NULL);

    if (!bReversePrint)
    {
        ERR(("%s not supported when spooler EMF is disabled, mode=%d", pszFeature, bSetMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        for (iIndex = 0; iIndex < 2; iIndex++)
        {
            if ((*pszOption == pstrPageOrder[iIndex][0]) &&
                (strcmp(pszOption, pstrPageOrder[iIndex]) == EQUAL_STRING))
            {
                break;
            }
        }

        if (iIndex >= 2)
        {
            //
            // unrecognized page order name
            //

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        //
        // refer to VUnpackDocumentPropertiesItems
        //

        pdmPrivate->bReversePrint = iIndex != 0;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        INT iSelection;

        //
        // refer to BPackItemEmfFeatures
        //

        iSelection = pdmPrivate->bReversePrint ? 1 : 0;

        return BOutputFeatureOption(pszFeature,
                                    pstrPageOrder[iSelection],
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_Nup

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   if output data buffer size is not big enough for
                                enum or get operation

--*/
BOOL
BPSFProc_Nup(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    typedef struct _PSF_NUP_ENTRY {

        PCSTR   pszNupName;    // Nup name
        LAYOUT  iLayout;       // Nup code

    } PSF_NUP_ENTRY, *PPSF_NUP_ENTRY;

    static const PSF_NUP_ENTRY kPSF_NupTable[] =
    {
        "1",       ONE_UP,
        "2",       TWO_UP,
        "4",       FOUR_UP,
        "6",       SIX_UP,
        "9",       NINE_UP,
        "16",      SIXTEEN_UP,
        "Booklet", BOOKLET_UP,
        NULL,      0,
    };

    PPSF_NUP_ENTRY pEntry, pMatchEntry;
    PPSDRVEXTRA    pdmPrivate;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    pMatchEntry = NULL;
    pEntry = (PPSF_NUP_ENTRY)&(kPSF_NupTable[0]);

    //
    // option enumeration handling
    //

    if (dwMode == PSFPROC_ENUMOPTION_MODE)
    {
        BOOL   bEMFSpooling;
        DWORD  cbNeeded = 0;

        VGetSpoolerEmfCaps(hPrinter, NULL, &bEMFSpooling, 0, NULL);

        while (pEntry->pszNupName)
        {
            //
            // Booklet is not supported on NT4 and only supported when
            // spooler EMF is enabled on Win2K+.
            //

            if ((pEntry->iLayout != BOOKLET_UP) ||
                bEMFSpooling)
            {
                DWORD  cbOptionNameSize;

                cbOptionNameSize = strlen(pEntry->pszNupName) + 1;

                if (pmszOutBuf && cbRemain >= (INT)cbOptionNameSize)
                {
                    CopyMemory(pmszOutBuf, pEntry->pszNupName, cbOptionNameSize);
                    pmszOutBuf += cbOptionNameSize;
                }

                cbRemain -= cbOptionNameSize;
                cbNeeded += cbOptionNameSize;
            }

            pEntry++;
        }

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }

    //
    // option get/set handling
    //

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        while (pEntry->pszNupName)
        {
            if ((*pszOption == *(pEntry->pszNupName)) &&
                (strcmp(pszOption, pEntry->pszNupName) == EQUAL_STRING))
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // refer to VUnpackDocumentPropertiesItems
        //

        if (!pMatchEntry)
        {
            //
            // unrecognized Nup name
            //

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pdmPrivate->iLayout = pMatchEntry->iLayout;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        while (pEntry->pszNupName)
        {
            if (pdmPrivate->iLayout == pEntry->iLayout)
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // If no match, default to 1-up.
        //

        if (!pMatchEntry)
        {
            RIP(("unknown iLayout value: %d\n", pdmPrivate->iLayout));
            pMatchEntry = (PPSF_NUP_ENTRY)&(kPSF_NupTable[0]);
        }

        //
        // refer to BPackItemEmfFeatures
        //

        return BOutputFeatureOption(pszFeature,
                                    pMatchEntry->pszNupName,
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_PSErrHandler

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_PSErrHandler(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    PPSDRVEXTRA pdmPrivate;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // refer to _BPackDocumentOptions and _VUnpackDocumentOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pdmPrivate->dwFlags),
                           PSDEVMODE_EHANDLER,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_PSMemory

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetUnsignedInt

--*/
BOOL
BPSFProc_PSMemory(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    DWORD dwFreeMem;
    BOOL  bResult;
    BOOL  bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _BPackPrinterOptions in ps.c and
    // VUnpackPrinterPropertiesItems in prnprop.c
    //

    dwFreeMem = pPrinterData->dwFreeMem / KBYTES;

    bResult = BGetSetUnsignedInt(pszFeature,
                                 pszOption,
                                 &dwFreeMem,
                                 MAX_DWORD_VALUE,
                                 pmszOutBuf,
                                 cbRemain,
                                 pcbNeeded,
                                 bSetMode);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bResult && bSetMode)
    {
        DWORD dwMinimum;

        //
        // Make sure the PS memory is not set below the minimum required.
        // (refer to _BPackPrinterOptions in ps.c)
        //

        dwMinimum = (pUIInfo->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2) / KBYTES;

        pPrinterData->dwFreeMem = max(dwFreeMem, dwMinimum) * KBYTES;
    }

    #endif // !KERNEL_MODE

    return bResult;
}


/*++

Routine Name:

    BPSFProc_Orientation

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   if output data buffer size is not big enough for
                                enum or get operation

--*/
BOOL
BPSFProc_Orientation(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    static const CHAR pstrOrient[][32] =
    {
        "Portrait",
        "Landscape",
        "RotatedLandscape",
    };

    PPSDRVEXTRA pdmPrivate;
    INT  iIndex;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    //
    // option enumeration handling
    //

    if (dwMode == PSFPROC_ENUMOPTION_MODE)
    {
        DWORD  cbNeeded = 0;

        for (iIndex = 0; iIndex <= 2; iIndex++)
        {
            DWORD  cbOptionNameSize;

            cbOptionNameSize = strlen(pstrOrient[iIndex]) + 1;

            if (pmszOutBuf && cbRemain >= (INT)cbOptionNameSize)
            {
                CopyMemory(pmszOutBuf, pstrOrient[iIndex], cbOptionNameSize);
                pmszOutBuf += cbOptionNameSize;
            }

            cbRemain -= cbOptionNameSize;
            cbNeeded += cbOptionNameSize;
        }

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }

    //
    // option get/set handling
    //

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        for (iIndex = 0; iIndex <= 2; iIndex++)
        {
            if ((*pszOption == pstrOrient[iIndex][0]) &&
                (strcmp(pszOption, pstrOrient[iIndex]) == EQUAL_STRING))
            {
                break;
            }
        }

        if (iIndex > 2)
        {
            //
            // unrecognized orientation name
            //

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        //
        // refer to _VUnpackDocumentOptions in ps.c
        //

        pdm->dmFields |= DM_ORIENTATION;
        pdm->dmOrientation = (iIndex == 0) ? DMORIENT_PORTRAIT :
                                             DMORIENT_LANDSCAPE;

        if (iIndex != 2)
            pdmPrivate->dwFlags &= ~PSDEVMODE_LSROTATE;
        else
            pdmPrivate->dwFlags |= PSDEVMODE_LSROTATE;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        INT iSelection;

        //
        // refer to _BPackOrientationItem in ps.c
        //

        if ((pdm->dmFields & DM_ORIENTATION) &&
            (pdm->dmOrientation == DMORIENT_LANDSCAPE))
        {
            iSelection = pdmPrivate->dwFlags & PSDEVMODE_LSROTATE ? 2 : 1;
        }
        else
            iSelection = 0;

        return BOutputFeatureOption(pszFeature,
                                    pstrOrient[iSelection],
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_OutFormat

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   if output data buffer size is not big enough for
                                enum or get operation

--*/
BOOL
BPSFProc_OutFormat(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    typedef struct _PSF_OUTFORMAT_ENTRY {

        PCSTR    pszFormatName;      // output format name
        DIALECT  iDialect;           // output format code

    } PSF_OUTFORMAT_ENTRY, *PPSF_OUTFORMAT_ENTRY;

    static const PSF_OUTFORMAT_ENTRY kPSF_OutFormatTable[] =
    {
        {"Speed",            SPEED},
        {"Portability",      PORTABILITY},
        {"EPS",              EPS},
        {"Archive",          ARCHIVE},
        {NULL,               0},
    };

    PPSF_OUTFORMAT_ENTRY pEntry, pMatchEntry;
    PPSDRVEXTRA pdmPrivate;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    pMatchEntry = NULL;
    pEntry = (PPSF_OUTFORMAT_ENTRY)&(kPSF_OutFormatTable[0]);

    //
    // option enumeration handling
    //

    if (dwMode == PSFPROC_ENUMOPTION_MODE)
    {
        DWORD  cbNeeded = 0;

        while (pEntry->pszFormatName)
        {
            DWORD  cbOptionNameSize;

            cbOptionNameSize = strlen(pEntry->pszFormatName) + 1;

            if (pmszOutBuf && cbRemain >= (INT)cbOptionNameSize)
            {
                CopyMemory(pmszOutBuf, pEntry->pszFormatName, cbOptionNameSize);
                pmszOutBuf += cbOptionNameSize;
            }

            cbRemain -= cbOptionNameSize;
            cbNeeded += cbOptionNameSize;

            pEntry++;
        }

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }

    //
    // option get/set handling
    //

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        while (pEntry->pszFormatName)
        {
            if ((*pszOption == *(pEntry->pszFormatName)) &&
                (strcmp(pszOption, pEntry->pszFormatName) == EQUAL_STRING))
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // refer to _VUnpackDocumentOptions in ps.c
        //

        if (!pMatchEntry)
        {
            //
            // unrecognized output format name
            //

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pdmPrivate->iDialect = pMatchEntry->iDialect;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        while (pEntry->pszFormatName)
        {
            if (pdmPrivate->iDialect == pEntry->iDialect)
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // If no match, default to SPEED.
        //

        if (!pMatchEntry)
        {
            RIP(("unknown iDialect value: %d\n", pdmPrivate->iDialect));
            pMatchEntry = (PPSF_OUTFORMAT_ENTRY)&(kPSF_OutFormatTable[0]);
        }

        //
        // refer to BPackItemPSOutputOption in ps.c
        //

        return BOutputFeatureOption(pszFeature,
                                    pMatchEntry->pszFormatName,
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_Protocol

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   if output data buffer size is not big enough for
                                enum or get operation

--*/
BOOL
BPSFProc_Protocol(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    typedef struct _PSF_PROTOCOL_ENTRY {

        PCSTR    pszProtocolName;    // output protocol name
        DWORD    dwProtocol;         // output protocol code

    } PSF_PROTOCOL_ENTRY, *PPSF_PROTOCOL_ENTRY;

    static const PSF_PROTOCOL_ENTRY kPSF_ProtocolTable[] =
    {
        {"ASCII",      PROTOCOL_ASCII},
        {"BCP",        PROTOCOL_BCP},
        {"TBCP",       PROTOCOL_TBCP},
        {"Binary",     PROTOCOL_BINARY},
        {NULL,         0},
    };

    PPSF_PROTOCOL_ENTRY pEntry, pMatchEntry;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    pMatchEntry = NULL;
    pEntry = (PPSF_PROTOCOL_ENTRY)&(kPSF_ProtocolTable[0]);

    //
    // option enumeration handling
    //

    if (dwMode == PSFPROC_ENUMOPTION_MODE)
    {
        DWORD  cbNeeded = 0;

        while (pEntry->pszProtocolName)
        {
            //
            // ASCII is always supported.
            //

            if ((pEntry->dwProtocol == PROTOCOL_ASCII) ||
                (pUIInfo->dwProtocols & pEntry->dwProtocol))
            {
                DWORD  cbOptionNameSize;

                cbOptionNameSize = strlen(pEntry->pszProtocolName) + 1;

                if (pmszOutBuf && cbRemain >= (INT)cbOptionNameSize)
                {
                    CopyMemory(pmszOutBuf, pEntry->pszProtocolName, cbOptionNameSize);
                    pmszOutBuf += cbOptionNameSize;
                }

                cbRemain -= cbOptionNameSize;
                cbNeeded += cbOptionNameSize;
            }

            pEntry++;
        }

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }

    //
    // option get/set handling
    //

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        while (pEntry->pszProtocolName)
        {
            if ((*pszOption == *(pEntry->pszProtocolName)) &&
                (strcmp(pszOption, pEntry->pszProtocolName) == EQUAL_STRING))
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // refer to _VUnpackDriverPrnPropItem in ps.c
        //

        if (!pMatchEntry ||
            (pMatchEntry->dwProtocol != PROTOCOL_ASCII &&
             !(pUIInfo->dwProtocols & pMatchEntry->dwProtocol)))
        {
            //
            // Either unrecognized protocol name, or the protocol is not supported.
            // (ASCII is always supported.)
            //

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pPrinterData->wProtocol = (WORD)pMatchEntry->dwProtocol;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        while (pEntry->pszProtocolName)
        {
            if (pPrinterData->wProtocol == (WORD)pEntry->dwProtocol)
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // If no match or matched protocol is not supported, default to PROTOCOL_ASCII.
        //

        if (!pMatchEntry)
        {
            RIP(("unknown wProtocol value: %d\n", pPrinterData->wProtocol));
            pMatchEntry = (PPSF_PROTOCOL_ENTRY)&(kPSF_ProtocolTable[0]);
        }

        //
        // refer to BPackPSProtocolItem in ps.c
        //

        if (pMatchEntry->dwProtocol != PROTOCOL_ASCII &&
            !(pUIInfo->dwProtocols & pMatchEntry->dwProtocol))
        {
            ERR(("unsupported wProtocol value: %d\n", pPrinterData->wProtocol));
            pMatchEntry = (PPSF_PROTOCOL_ENTRY)&(kPSF_ProtocolTable[0]);
        }

        return BOutputFeatureOption(pszFeature,
                                    pMatchEntry->pszProtocolName,
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_PSLevel

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER     if PSLevel is set to a negative value,
                                or see BGetSetUnsignedInt
    ERROR_INSUFFICIENT_BUFFER   see BGetSetUnsignedInt

--*/
BOOL
BPSFProc_PSLevel(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    PPSDRVEXTRA pdmPrivate;
    DWORD dwPSLevel;
    BOOL  bResult;
    BOOL  bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // refer to _VUnpackDocumentOptions and BPackItemPSLevel in ps.c
    //

    dwPSLevel = (DWORD)pdmPrivate->iPSLevel;

    bResult = BGetSetUnsignedInt(pszFeature,
                                 pszOption,
                                 &dwPSLevel,
                                 pUIInfo->dwLangLevel,
                                 pmszOutBuf,
                                 cbRemain,
                                 pcbNeeded,
                                 bSetMode);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bResult && bSetMode)
    {
        //
        // set output PS level to 0 is not allowed
        //

        if (dwPSLevel > 0)
        {
            pdmPrivate->iPSLevel = (INT)dwPSLevel;
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            bResult = FALSE;
        }
    }

    #endif // !KERNEL_MODE

    return bResult;
}


/*++

Routine Name:

    BPSFProc_TrueGrayT

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetBoolFlag

--*/
BOOL
BPSFProc_TrueGrayT(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to _VUnpackDriverPrnPropItem and _BPackPrinterOptions in ps.c
    //

    return BGetSetBoolFlag(pszFeature,
                           pszOption,
                           &(pPrinterData->dwFlags),
                           PFLAGS_TRUE_GRAY_TEXT,
                           TRUE,
                           pmszOutBuf,
                           cbRemain,
                           pcbNeeded,
                           bSetMode);
}


/*++

Routine Name:

    BPSFProc_TTFormat

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_INVALID_PARAMETER     (set only) if set operation found invalid argument
    ERROR_INSUFFICIENT_BUFFER   if output data buffer size is not big enough for
                                enum or get operation

--*/
BOOL
BPSFProc_TTFormat(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    typedef struct _PSF_TTFORMAT_ENTRY {

        PCSTR    pszTTFmtName;    // TT download format name
        TTDLFMT  iTTDLFmt;        // TT download format enum code

    } PSF_TTFORMAT_ENTRY, *PPSF_TTFORMAT_ENTRY;

    static const PSF_TTFORMAT_ENTRY kPSF_TTFormatTable[] =
    {
        {"Automatic",       TT_DEFAULT},
        {"Outline",         TYPE_1},
        {"Bitmap",          TYPE_3},
        {"NativeTrueType",  TYPE_42},
        {NULL,              0},
    };

    PPSF_TTFORMAT_ENTRY  pEntry, pMatchEntry;
    PPSDRVEXTRA pdmPrivate;
    BOOL bSupportType42;
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    bSupportType42 = pUIInfo->dwTTRasterizer == TTRAS_TYPE42;

    pMatchEntry = NULL;
    pEntry = (PPSF_TTFORMAT_ENTRY)&(kPSF_TTFormatTable[0]);

    //
    // option enumeration handling
    //

    if (dwMode == PSFPROC_ENUMOPTION_MODE)
    {
        DWORD  cbNeeded = 0;

        while (pEntry->pszTTFmtName)
        {
            if ((pEntry->iTTDLFmt != TYPE_42) ||
                bSupportType42)
            {
                DWORD  cbOptionNameSize;

                cbOptionNameSize = strlen(pEntry->pszTTFmtName) + 1;

                if (pmszOutBuf && cbRemain >= (INT)cbOptionNameSize)
                {
                    CopyMemory(pmszOutBuf, pEntry->pszTTFmtName, cbOptionNameSize);
                    pmszOutBuf += cbOptionNameSize;
                }

                cbRemain -= cbOptionNameSize;
                cbNeeded += cbOptionNameSize;
            }

            pEntry++;
        }

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pmszOutBuf || cbRemain < 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        return TRUE;
    }

    //
    // option get/set handling
    //

    ASSERT(pdm);

    pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);

    #ifndef KERNEL_MODE

    //
    // set is only supported for UI plugins
    //

    if (bSetMode)
    {
        while (pEntry->pszTTFmtName)
        {
            if ((*pszOption == *(pEntry->pszTTFmtName)) &&
                (strcmp(pszOption, pEntry->pszTTFmtName) == EQUAL_STRING))
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // refer to _VUnpackDocumentOptions in ps.c
        //

        if (!pMatchEntry ||
            (!bSupportType42 && pMatchEntry->iTTDLFmt == TYPE_42))
        {
            //
            // Either unrecognized TTFormat name, or the TTFormat is not supported.
            //

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pdmPrivate->iTTDLFmt = pMatchEntry->iTTDLFmt;

        return TRUE;
    }

    #else

    ASSERT(bSetMode == FALSE);

    #endif // !KERNEL_MODE

    //
    // get is supported for both UI and render plugins
    //

    {
        while (pEntry->pszTTFmtName)
        {
            if (pdmPrivate->iTTDLFmt == pEntry->iTTDLFmt)
            {
                pMatchEntry = pEntry;
                break;
            }

            pEntry++;
        }

        //
        // If no match or matched format is not supported, default to Automatic format.
        //

        if (!pMatchEntry)
        {
            RIP(("unknown TTFormat value: %d\n", pdmPrivate->iTTDLFmt));
            pMatchEntry = (PPSF_TTFORMAT_ENTRY)&(kPSF_TTFormatTable[0]);
        }

        //
        // refer to BPackItemTTDownloadFormat in ps.c
        //

        if (!bSupportType42 && pMatchEntry->iTTDLFmt == TYPE_42)
        {
            ERR(("unsupported TTFormat value: %d\n", pdmPrivate->iTTDLFmt));
            pMatchEntry = (PPSF_TTFORMAT_ENTRY)&(kPSF_TTFormatTable[0]);
        }

        return BOutputFeatureOption(pszFeature,
                                    pMatchEntry->pszTTFmtName,
                                    pmszOutBuf,
                                    cbRemain,
                                    pcbNeeded);
    }
}


/*++

Routine Name:

    BPSFProc_WaitTimeout

Routine Description:

    %-feature enum/get/set operation handler

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    pszFeature - feature keyword name
    pszOption - (set only) option keyword name
    pmszOutBuf - (get only) pointer to output data buffer
    cbRemain - (get only) remaining output data buffer size in bytes
    pcbNeeded - (get only) buffer size in bytes needed to output the feature setting
    dwMode - indicate one of three operations: enum, get, set

Return Value:

    TRUE   if the requested operation succeeds
    FALSE  otherwise

Last Error:

    ERROR_NOT_SUPPORTED         unsupported enum operation is requested

    ERROR_INVALID_PARAMETER
    ERROR_INSUFFICIENT_BUFFER   see BGetSetUnsignedInt

--*/
BOOL
BPSFProc_WaitTimeout(
    IN  HANDLE       hPrinter,
    IN  PUIINFO      pUIInfo,
    IN  PPPDDATA     pPpdData,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  PCSTR        pszFeature,
    IN  PCSTR        pszOption,
    OUT PSTR         pmszOutBuf,
    IN  INT          cbRemain,
    OUT PDWORD       pcbNeeded,
    IN  DWORD        dwMode
    )
{
    BOOL bSetMode = (dwMode == PSFPROC_SETOPTION_MODE) ? TRUE : FALSE;

    RETURN_ON_UNSUPPORTED_ENUM_MODE(dwMode)

    //
    // refer to VUnpackPrinterPropertiesItems in prnprop.c
    // and _BPackPrinterOptions in ps.c
    //

    return BGetSetUnsignedInt(pszFeature,
                              pszOption,
                              &(pPrinterData->dwWaitTimeout),
                              MAX_DWORD_VALUE,
                              pmszOutBuf,
                              cbRemain,
                              pcbNeeded,
                              bSetMode);
}

//
// Note: for pfnPSProc handlers whose bPrinterSticky is TRUE,
// the PDEVMODE will be NULL (see PFillUiData), so you should NOT
// access PDEVMODE.
//

const PSFEATURE_ENTRY kPSFeatureTable[] =
{
    //
    // pszPSFeatureName  bPrinterSticky  bEnumerableOptions  bBooleanOptions pfnPSProc
    //

    {kstrPSFAddEuro,         TRUE,             TRUE,             TRUE,       BPSFProc_AddEuro},
    {kstrPSFCtrlDAfter,      TRUE,             TRUE,             TRUE,       BPSFProc_CtrlDA},
    {kstrPSFCtrlDBefore,     TRUE,             TRUE,             TRUE,       BPSFProc_CtrlDB},
    {kstrPSFCustomPS,        FALSE,            FALSE,            FALSE,      BPSFProc_CustomPS},
    {kstrPSFTrueGrayG,       TRUE,             TRUE,             TRUE,       BPSFProc_TrueGrayG},
    {kstrPSFJobTimeout,      TRUE,             FALSE,            FALSE,      BPSFProc_JobTimeout},
    {kstrPSFMaxBitmap,       TRUE,             FALSE,            FALSE,      BPSFProc_MaxBitmap},
    {kstrPSFEMF,             FALSE,            TRUE,             TRUE,       BPSFProc_EMF},
    {kstrPSFMinOutline,      TRUE,             FALSE,            FALSE,      BPSFProc_MinOutline},
    {kstrPSFMirroring,       FALSE,            TRUE,             TRUE,       BPSFProc_Mirroring},
    {kstrPSFNegative,        FALSE,            TRUE,             TRUE,       BPSFProc_Negative},
    {kstrPSFPageOrder,       FALSE,            TRUE,             FALSE,      BPSFProc_PageOrder},
    {kstrPSFNup,             FALSE,            TRUE,             FALSE,      BPSFProc_Nup},
    {kstrPSFErrHandler,      FALSE,            TRUE,             TRUE,       BPSFProc_PSErrHandler},
    {kstrPSFPSMemory,        TRUE,             FALSE,            FALSE,      BPSFProc_PSMemory},
    {kstrPSFOrientation,     FALSE,            TRUE,             FALSE,      BPSFProc_Orientation},
    {kstrPSFOutFormat,       FALSE,            TRUE,             FALSE,      BPSFProc_OutFormat},
    {kstrPSFOutProtocol,     TRUE,             TRUE,             FALSE,      BPSFProc_Protocol},
    {kstrPSFOutPSLevel,      FALSE,            FALSE,            FALSE,      BPSFProc_PSLevel},
    {kstrPSFTrueGrayT,       TRUE,             TRUE,             TRUE,       BPSFProc_TrueGrayT},
    {kstrPSFTTFormat,        FALSE,            TRUE,             FALSE,      BPSFProc_TTFormat},
    {kstrPSFWaitTimeout,     TRUE,             FALSE,            FALSE,      BPSFProc_WaitTimeout},
    {NULL,                   FALSE,            FALSE,            FALSE,      NULL},
};


/*++

Routine Name:

    PComposeFullFeatureList

Routine Description:

    Allocate a buffer and fill the buffer with the full keyword list
    of supported features.

    Caller is responsible to free the buffer.

Arguments:

    hPrinter - printer handle
    pUIInfo - pointer to driver's UIINFO structure

Return Value:

    NULL      if failed to allocate and correctly fill the buffer
    non-NULL  succeeds. Pointer to the buffer containing full keyword list
              of supported features will be returned.

Last Error:

    None

--*/
PSTR
PComposeFullFeatureList(
    IN  HANDLE     hPrinter,
    IN  PUIINFO    pUIInfo
    )
{
    PSTR    pmszFeatureList, pmszRet = NULL;
    DWORD   cbNeeded = 0;
    HRESULT hr;

    hr = HEnumFeaturesOrOptions(hPrinter,
                                pUIInfo->pInfoHeader,
                                0,
                                NULL,
                                NULL,
                                0,
                                &cbNeeded);

    if (hr != E_OUTOFMEMORY || cbNeeded == 0)
    {
        ERR(("HEnumFeaturesOrOptions failed. hr=%X\n", hr));
        goto exit;
    }

    if ((pmszFeatureList = MemAlloc(cbNeeded)) == NULL)
    {
        ERR(("memory allocation failed.\n"));
        goto exit;
    }

    hr = HEnumFeaturesOrOptions(hPrinter,
                                pUIInfo->pInfoHeader,
                                0,
                                NULL,
                                pmszFeatureList,
                                cbNeeded,
                                &cbNeeded);

    if (FAILED(hr))
    {
        ERR(("HEnumFeaturesOrOptions failed. hr=%X\n", hr));
        MemFree(pmszFeatureList);
        goto exit;
    }

    //
    // Succeeded
    //

    pmszRet = pmszFeatureList;

    exit:

    return pmszRet;
}


/*++

Routine Name:

    BValidMultiSZString

Routine Description:

    validate if a given ASCII string is in MULTI_SZ format

Arguments:

    pmszString - the input ASCII string that needs validation
    cbSize - size in bytes of the input ASCII string
    bCheckPairs - TRUE if need to validate the MULTI_SZ
                  string contains pairs. FALSE otherwise.

Return Value:

    TRUE    if the input ASCII string is in valid MULTI_SZ format
    FALSE   if it's not

Last Error:

    None

--*/
BOOL
BValidMultiSZString(
    IN  PCSTR     pmszString,
    IN  DWORD     cbSize,
    IN  BOOL      bCheckPairs
    )
{
    PCSTR  pszEnd;
    INT    cTokens = 0;

    if (!pmszString || !cbSize)
    {
        return FALSE;
    }

    pszEnd = pmszString + cbSize - 1;

    while (*pmszString && pmszString <= pszEnd)
    {
        while (*pmszString && pmszString <= pszEnd)
        {
            pmszString++;
        }

        if (pmszString > pszEnd)
        {
            ERR(("Missing single token's NUL terminator!\n"));
            return FALSE;
        }

        cTokens++;
        pmszString++;
    }

    if (pmszString > pszEnd)
    {
        ERR(("Missing MULTI_SZ string's last NUL terminator!\n"));
        return FALSE;
    }

    if (!bCheckPairs)
    {
        return TRUE;
    }
    else
    {
        return (cTokens % 2) ? FALSE : TRUE;
    }
}


/*++

Routine Name:

    HGetOptions

Routine Description:

    get the current setting for a specified feature

    For UI plugin's GetOptions call during DrvDocumentPropertySheets, or for
    render plugins's GetOptions call, both doc-sticky and printer-sticky features
    are supported.

    For UI plugin's GetOptions call during DrvDevicePropertySheets, only
    printer-sticky features are supported.

Arguments:

    hPrinter - printer handle
    pInfoHeader - pointer to driver's INFOHEADER structure
    pOptionsArray - pointer to driver's combined option array
    pdm - pointer to public DEVMODE
    pPrinterData - pointer to driver's PRINTERDATA structure
    dwFlags - flags for the get operation
    pmszFeaturesRequested - MULTI_SZ ASCII string containing feature keyword names
    cbin - size in bytes of the pmszFeaturesRequested string
    pmszFeatureOptionBuf - pointer to output data buffer to store feature settings
    cbSize - size in bytes of pmszFeatureOptionBuf buffer
    pcbNeeded - buffer size in bytes needed to output the feature settings
    bPrinterSticky - TRUE if we are in printer-sticky mode, FALSE if we are in
                     doc-sticky mode

Return Value:

    S_OK           if the get operation succeeds
    E_INVALIDARG   if input pmszFeaturesRequested is not in valid MULTI_SZ format
    E_OUTOFMEMORY  if output data buffer size is not big enough
    E_FAIL         if other internal failures are encountered

Last Error:

    None

--*/
HRESULT
HGetOptions(
    IN  HANDLE       hPrinter,
    IN  PINFOHEADER  pInfoHeader,
    IN  POPTSELECT   pOptionsArray,
    IN  PDEVMODE     pdm,
    IN  PPRINTERDATA pPrinterData,
    IN  DWORD           dwFlags,
    IN  PCSTR        pmszFeaturesRequested,
    IN  DWORD        cbIn,
    OUT PSTR         pmszFeatureOptionBuf,
    IN  DWORD        cbSize,
    OUT PDWORD       pcbNeeded,
    IN  BOOL         bPrinterSticky
    )
{
    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    HRESULT  hr;
    PSTR     pmszFeatureList = NULL, pCurrentOut;
    PCSTR    pszFeature;
    DWORD    cbNeeded;
    INT      cbRemain;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (!pmszFeaturesRequested)
    {
        //
        // client is asking for settings of all features.
        //

        if (!(pmszFeatureList = PComposeFullFeatureList(hPrinter, pUIInfo)))
        {
            hr = E_FAIL;
            goto exit;
        }

        pszFeature = pmszFeatureList;
    }
    else
    {
        //
        // client provided its specific feature list.
        //
        // We need to verify the MULTI_SZ input buffer first.
        //

        if (!BValidMultiSZString(pmszFeaturesRequested, cbIn, FALSE))
        {
            ERR(("Get: invalid MULTI_SZ input param\n"));
            hr = E_INVALIDARG;
            goto exit;
        }

        pszFeature = pmszFeaturesRequested;
    }

    pCurrentOut = pmszFeatureOptionBuf;
    cbNeeded = 0;
    cbRemain = (INT)cbSize;

    while (*pszFeature)
    {
        DWORD cbFeatureKeySize;

        cbFeatureKeySize = strlen(pszFeature) + 1;

        if (*pszFeature == PSFEATURE_PREFIX)
        {
            PPSFEATURE_ENTRY pEntry, pMatchEntry;

            //
            // synthesized PS driver feature
            //

            pMatchEntry = NULL;
            pEntry = (PPSFEATURE_ENTRY)(&kPSFeatureTable[0]);

            while (pEntry->pszPSFeatureName)
            {
                if ((*pszFeature == *(pEntry->pszPSFeatureName)) &&
                    (strcmp(pszFeature, pEntry->pszPSFeatureName) == EQUAL_STRING))
                {
                    pMatchEntry = pEntry;
                    break;
                }

                pEntry++;
            }

            //
            // Both doc-sticky and printer-sticky features are supported in DOC_STICKY_MODE,
            // but only printer-sticky features are supported in PRINTER_STICKY_MODE.
            // (refer to comments in HEnumConstrainedOptions)
            //

            if (!pMatchEntry ||
                (bPrinterSticky && !pMatchEntry->bPrinterSticky))
            {
                VERBOSE(("Get: invalid or mode-mismatched feature %s\n", pszFeature));
                goto next_feature;
            }

            if (pMatchEntry->pfnPSProc)
            {
                DWORD  cbPSFSize = 0;
                BOOL   bResult;

                bResult = (pMatchEntry->pfnPSProc)(hPrinter,
                                                   pUIInfo,
                                                   pPpdData,
                                                   pdm,
                                                   pPrinterData,
                                                   pszFeature,
                                                   NULL,
                                                   pCurrentOut,
                                                   cbRemain,
                                                   &cbPSFSize,
                                                   PSFPROC_GETOPTION_MODE);

                if (bResult)
                {
                    //
                    // If the handler succeeded, it should have filled in the output buffer
                    // with correct content and return the size of buffer consumption in cbPSFSize.
                    //

                    pCurrentOut += cbPSFSize;
                }
                else
                {
                    //
                    // If the handler failed because of insufficent output buffer, it should return
                    // the needed buffer size in cbPSFSize.
                    //

                    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    {
                        ERR(("Get: %%-feature handler failed on %s\n", pszFeature));
                    }
                }

                cbRemain -= cbPSFSize;
                cbNeeded += cbPSFSize;
            }
        }
        else
        {
            PFEATURE pFeature;
            POPTION  pOption;
            PSTR     pszOption;
            DWORD    dwFeatureIndex, cbOptionKeySize;

            //
            // PPD *OpenUI feature
            //

            pFeature = PGetNamedFeature(pUIInfo, pszFeature, &dwFeatureIndex);

            //
            // Both doc-sticky and printer-sticky features are supported in DOC_STICKY_MODE,
            // but only printer-sticky features are supported in PRINTER_STICKY_MODE.
            // (refer to comments in HEnumConstrainedOptions)
            //

            if (!pFeature ||
                (bPrinterSticky && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY))
            {
                VERBOSE(("Get: invalid or mode-mismatched feature %s\n", pszFeature));
                goto next_feature;
            }

            //
            // Skip GID_LEADINGEDGE, GID_USEHWMARGINS. They are not real PPD *OpenUI features.
            //

            if (pFeature->dwFeatureID == GID_LEADINGEDGE ||
                pFeature->dwFeatureID == GID_USEHWMARGINS)
            {
                VERBOSE(("Get: skip feature %s\n", pszFeature));
                goto next_feature;
            }

            pOption = PGetIndexedOption(pUIInfo, pFeature, pOptionsArray[dwFeatureIndex].ubCurOptIndex);

            if (!pOption)
            {
                WARNING(("Get: invalid option selection for feature %s\n", pszFeature));
                goto next_feature;
            }

            pszOption = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName);
            ASSERT(pszOption);

            cbOptionKeySize = strlen(pszOption) + 1;

            //
            // We don't support pick-many yet.
            //

            ASSERT(pOptionsArray[dwFeatureIndex].ubNext == NULL_OPTSELECT);

            //
            // At this point, we found a valid setting for the feature.
            //

            if (pCurrentOut && (cbRemain >= (INT)(cbFeatureKeySize + cbOptionKeySize)))
            {
                CopyMemory(pCurrentOut, pszFeature, cbFeatureKeySize);
                pCurrentOut += cbFeatureKeySize;
                CopyMemory(pCurrentOut, pszOption, cbOptionKeySize);
                pCurrentOut += cbOptionKeySize;
            }

            cbRemain -= (cbFeatureKeySize + cbOptionKeySize);
            cbNeeded += cbFeatureKeySize + cbOptionKeySize;
        }

        next_feature:

        pszFeature += cbFeatureKeySize;
    }

    //
    // remember the last NUL terminator for the MULTI_SZ output string
    //

    cbRemain--;
    cbNeeded++;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCurrentOut || cbRemain < 0)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *pCurrentOut = NUL;

    hr = S_OK;

    exit:

    MemFree(pmszFeatureList);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\oemutil\sources.inc ===
!IF 0

Copyright (c) 1996-1997  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

C_DEFINES=$(C_DEFINES) -DOEMCOM

SOURCES=..\oemutil.c  \
        ..\oemcom.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ps\psutil.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    psutil.c

Abstract:

    PostScript utility functions
        BInitDriverDefaultDevmode
        BMergeDriverDevmode
        VCopyUnicodeStringToAnsi
        PGetAndConvertOldVersionFormTrayTable
        BSaveAsOldVersionFormTrayTable

Environment:

    Windows NT printer drivers

Revision History:

    12/03/97 -fengy-
        Added VUpdatePrivatePrinterData to split fixed fields in PrinterData
        into Keyword/Value pairs in Registry.

    04/17/97 -davidx-
        Provide OEM plugins access to driver private devmode settings.

    02/04/97 -davidx-
        Devmode changes to support OEM plugins.

    10/02/96 -davidx-
        Implement BPSMergeDevmode.

    09/26/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "oemutil.h"

//
// Information about PostScript driver private devmode
//

CONST DRIVER_DEVMODE_INFO gDriverDMInfo =
{
    PSDRIVER_VERSION,       sizeof(PSDRVEXTRA),
    PSDRIVER_VERSION_500,   sizeof(PSDRVEXTRA500),
    PSDRIVER_VERSION_400,   sizeof(PSDRVEXTRA400),
    PSDRIVER_VERSION_351,   sizeof(PSDRVEXTRA351),
};

CONST DWORD gdwDriverDMSignature = PSDEVMODE_SIGNATURE;
CONST WORD  gwDriverVersion = PSDRIVER_VERSION;



static VOID
VInitNewPrivateFields(
    PRAWBINARYDATA  pRawData,
    PUIINFO         pUIInfo,
    PPSDRVEXTRA     pdmPrivate,
    BOOL            bInitAllFields
    )

/*++

Routine Description:

    Intialize the new private devmode fields for PS 5.0

Arguments:

    pUIInfo - Points to a UIINFO structure
    pRawData - Points to raw binary printer description data
    pdmPrivate - Points to the private devmode fields to be initialized
    bInitAllFields - Whether to initialize all new private fields or
        initialize the options array only

Return Value:

    NONE

--*/

{
    if (bInitAllFields)
    {
        pdmPrivate->wReserved1 = 0;
        pdmPrivate->wSize = sizeof(PSDRVEXTRA);

        pdmPrivate->fxScrFreq = 0;
        pdmPrivate->fxScrAngle = 0;
        pdmPrivate->iDialect = SPEED;
        pdmPrivate->iTTDLFmt = TT_DEFAULT;
        pdmPrivate->bReversePrint = FALSE;
        pdmPrivate->iLayout = ONE_UP;
        pdmPrivate->iPSLevel = pUIInfo->dwLangLevel;

        pdmPrivate->wOEMExtra = 0;
        pdmPrivate->wVer = PSDRVEXTRA_VERSION;

        pdmPrivate->dwReserved2 = 0;
        ZeroMemory(pdmPrivate->dwReserved3, sizeof(pdmPrivate->dwReserved3));
    }

    InitDefaultOptions(pRawData,
                       pdmPrivate->aOptions,
                       MAX_PRINTER_OPTIONS,
                       MODE_DOCUMENT_STICKY);

    pdmPrivate->dwOptions = pRawData->dwDocumentFeatures;
    pdmPrivate->dwChecksum32 = pRawData->dwChecksum32;
}



BOOL
BInitDriverDefaultDevmode(
    OUT PDEVMODE        pdmOut,
    IN LPCTSTR          ptstrPrinterName,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN BOOL             bMetric
    )

/*++

Routine Description:

    Return the driver default devmode

Arguments:

    pdmOut - Points to the output devmode to be initialized
    ptstrPrinterName - Specifies the name of the printer
    pUIInfo - Points to a UIINFO structure
    pRawData - Points to raw binary printer description data
    bMetric - Whether the system is running in metric mode

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    This function should initialize both public devmode fields
    and driver private devmode fields. It's also assumed that
    output buffer has already been zero initialized by the caller.

--*/

{
    PPSDRVEXTRA pdmPrivate;
    PFEATURE    pFeature;
    PPPDDATA    pPpdData;

    //
    // Initialize public devmode fields
    //

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    pdmOut->dmDriverVersion = PSDRIVER_VERSION;
    pdmOut->dmSpecVersion = DM_SPECVERSION;
    pdmOut->dmSize = sizeof(DEVMODE);
    pdmOut->dmDriverExtra = sizeof(PSDRVEXTRA);

    pdmOut->dmFields = DM_ORIENTATION |
                       DM_SCALE |
                       DM_COPIES |
                       DM_PRINTQUALITY |
                       DM_YRESOLUTION |
                       DM_TTOPTION |
                       #ifndef WINNT_40
                       DM_NUP |
                       #endif
                       DM_COLOR |
                       DM_DEFAULTSOURCE;

    pdmOut->dmOrientation = DMORIENT_PORTRAIT;
    pdmOut->dmDuplex = DMDUP_SIMPLEX;
    pdmOut->dmCollate = DMCOLLATE_FALSE;
    pdmOut->dmMediaType = DMMEDIA_STANDARD;
    pdmOut->dmTTOption = DMTT_SUBDEV;
    pdmOut->dmColor = DMCOLOR_MONOCHROME;
    pdmOut->dmDefaultSource = DMBIN_FORMSOURCE;
    pdmOut->dmScale = 100;
    pdmOut->dmCopies = 1;
    pdmOut->dmPrintQuality =
    pdmOut->dmYResolution = DEFAULT_RESOLUTION;
    #ifndef WINNT_40
    pdmOut->dmNup = DMNUP_SYSTEM;
    #endif

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION))
    {
        PRESOLUTION pRes;

        //
        // Use the default resolution specified in the PPD file
        //

        if (pRes = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex))
        {
            pdmOut->dmPrintQuality = (short)pRes->iXdpi;
            pdmOut->dmYResolution = (short)pRes->iYdpi;
        }
    }

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_DUPLEX))
    {
        PDUPLEX pDuplex;

        //
        // Use the default duplex option specified in the PPD file
        //

        pdmOut->dmFields |= DM_DUPLEX;

        if (pDuplex = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex))
            pdmOut->dmDuplex = (SHORT) pDuplex->dwDuplexID;
    }

    #ifdef WINNT_40

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_COLLATE))
    {
        PCOLLATE pCollate;

        pdmOut->dmFields |= DM_COLLATE;

        if (pCollate = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex))
            pdmOut->dmCollate = (SHORT) pCollate->dwCollateID;
    }

    #else // !WINNT_40

    pdmOut->dmFields |= DM_COLLATE;
    pdmOut->dmCollate = DMCOLLATE_TRUE;

    #endif // !WINNT_40

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_MEDIATYPE))
    {
        //
        // Use the default media type specified in the PPD file
        //

        pdmOut->dmFields |= DM_MEDIATYPE;

        if (pFeature->dwDefaultOptIndex != OPTION_INDEX_ANY)
            pdmOut->dmMediaType = DMMEDIA_USER + pFeature->dwDefaultOptIndex;
    }

    //
    // Adobe wants to preserve the color information even for b/w printers.
    // So for both b/w and color printers, turn color on by default for Adobe.
    //

    #ifndef ADOBE

    if (IS_COLOR_DEVICE(pUIInfo))
    {

    #endif // !ADOBE

        //
        // Turn color on by default
        //

        pdmOut->dmColor = DMCOLOR_COLOR;
        pdmOut->dmFields |= DM_COLOR;

    #ifndef ADOBE

    }

    #endif // !ADOBE

    //
    // We always set ICM off. The spooler will turn it on at install time
    // if there are color profiles installed with this printer
    //

    pdmOut->dmICMMethod = DMICMMETHOD_NONE;
    pdmOut->dmICMIntent = DMICM_CONTRAST;

    #ifndef WINNT_40

    #ifndef ADOBE

    if (IS_COLOR_DEVICE(pUIInfo))
    {

    #endif // !ADOBE

        pdmOut->dmFields |= (DM_ICMMETHOD | DM_ICMINTENT);

    #ifndef ADOBE

    }

    #endif // !ADOBE

    #endif // !WINNT_40

    //
    // dmDeviceName field will be filled elsewhere.
    // Use an arbitrary default value if the input parameter is NULL.
    //

    CopyString(pdmOut->dmDeviceName,
               ptstrPrinterName ? ptstrPrinterName : TEXT("PostScript"),
               CCHDEVICENAME);

    //
    // Initialize form-related fields
    //

    VDefaultDevmodeFormFields(pUIInfo, pdmOut, bMetric);

    //
    // Private devmode fields
    //

    pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmOut);
    pdmPrivate->dwSignature = PSDEVMODE_SIGNATURE;
    pdmPrivate->coloradj = gDefaultHTColorAdjustment;

    #ifndef WINNT_40
    pdmPrivate->dwFlags = PSDEVMODE_METAFILE_SPOOL;
    #endif

    if (pPpdData->dwFlags & PPDFLAG_PRINTPSERROR)
        pdmPrivate->dwFlags |= PSDEVMODE_EHANDLER;

    if (pUIInfo->dwLangLevel > 1)
        pdmPrivate->dwFlags |= PSDEVMODE_COMPRESSBMP;

    #ifndef KERNEL_MODE

    //
    // Set up some private devmode flag bits for compatibility
    // with previous versions of the driver.
    //

    pdmPrivate->dwFlags |= PSDEVMODE_CTRLD_AFTER;

    if (GetACP() == 1252)
        pdmPrivate->dwFlags |= (PSDEVMODE_FONTSUBST|PSDEVMODE_ENUMPRINTERFONTS);

    #endif

    //
    // Intialize the new private devmode fields for PS 5.0
    //

    VInitNewPrivateFields(pRawData, pUIInfo, pdmPrivate, TRUE);

    if (SUPPORT_CUSTOMSIZE(pUIInfo))
    {
        VFillDefaultCustomPageSizeData(pRawData, &pdmPrivate->csdata, bMetric);
    }
    else
    {
        ZeroMemory(&pdmPrivate->csdata, sizeof(pdmPrivate->csdata));
        pdmPrivate->csdata.dwX = pdmOut->dmPaperWidth * DEVMODE_PAPER_UNIT;
        pdmPrivate->csdata.dwY = pdmOut->dmPaperLength * DEVMODE_PAPER_UNIT;
    }

    return TRUE;
}



BOOL
BMergeDriverDevmode(
    IN OUT PDEVMODE     pdmOut,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN PDEVMODE         pdmIn
    )

/*++

Routine Description:

    Merge the input devmode with an existing devmode.

Arguments:

    pdmOut - Points to a valid output devmode
    pUIInfo - Points to a UIINFO structure
    pRawData - Points to raw binary printer description data
    pdmIn - Points to the input devmode

Return Value:

    TRUE if successful, FALSE if there is a fatal error

Note:

    This function should take care of both public devmode fields
    and driver private devmode fields. It can assume the input
    devmode has already been convert to the current size.

--*/

{
    PPSDRVEXTRA     pdmPrivateIn, pdmPrivateOut;
    PFEATURE        pFeature;
    PPPDDATA        pPpdData;

    ASSERT(pdmOut != NULL &&
           pdmOut->dmSize == sizeof(DEVMODE) &&
           pdmOut->dmDriverExtra >= sizeof(PSDRVEXTRA) &&
           pdmIn != NULL &&
           pdmIn->dmSize == sizeof(DEVMODE) &&
           pdmIn->dmDriverExtra >= sizeof(PSDRVEXTRA));

    pdmPrivateIn = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmIn);
    pdmPrivateOut = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmOut);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    //
    // Merge the public devmode fields
    //
    #ifndef WINNT_40
    if ( (pdmIn->dmFields & DM_NUP) &&
         (pdmIn->dmNup == DMNUP_SYSTEM ||
          pdmIn->dmNup == DMNUP_ONEUP))
    {
        pdmOut->dmNup = pdmIn->dmNup;
        pdmOut->dmFields |= DM_NUP;
    }

    #endif // #ifndef WINNT_40

    if (pdmIn->dmFields & DM_DEFAULTSOURCE &&
         ((pdmIn->dmDefaultSource >= DMBIN_FIRST &&
           pdmIn->dmDefaultSource <= DMBIN_LAST) ||
          pdmIn->dmDefaultSource >= DMBIN_USER))
    {
        pdmOut->dmFields |= DM_DEFAULTSOURCE;
        pdmOut->dmDefaultSource = pdmIn->dmDefaultSource;
    }

    if ((pdmIn->dmFields & DM_ORIENTATION) &&
        (pdmIn->dmOrientation == DMORIENT_PORTRAIT ||
         pdmIn->dmOrientation == DMORIENT_LANDSCAPE))
    {
        pdmOut->dmFields |= DM_ORIENTATION;
        pdmOut->dmOrientation = pdmIn->dmOrientation;
    }

    //
    // If both DM_PAPERLENGTH and DM_PAPERWIDTH are set, copy
    // dmPaperLength and dmPaperWidth fields. If DM_PAPERSIZE
    // is set, copy dmPaperSize field. Otherwise, if DM_FORMNAME
    // is set, copy dmFormName field.
    //

    if ((pdmIn->dmFields & DM_PAPERWIDTH) &&
        (pdmIn->dmFields & DM_PAPERLENGTH) &&
        (pdmIn->dmPaperWidth > 0) &&
        (pdmIn->dmPaperLength > 0))
    {
        pdmOut->dmFields |= (DM_PAPERLENGTH | DM_PAPERWIDTH);
        pdmOut->dmFields &= ~(DM_PAPERSIZE | DM_FORMNAME);
        pdmOut->dmPaperWidth = pdmIn->dmPaperWidth;
        pdmOut->dmPaperLength = pdmIn->dmPaperLength;
    }
    else if (pdmIn->dmFields & DM_PAPERSIZE)
    {
        if ((pdmIn->dmPaperSize != DMPAPER_CUSTOMSIZE) ||
            SUPPORT_CUSTOMSIZE(pUIInfo) &&
            SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUIInfo, pPpdData))
        {
            pdmOut->dmFields |= DM_PAPERSIZE;
            pdmOut->dmFields &= ~(DM_PAPERLENGTH | DM_PAPERWIDTH | DM_FORMNAME);
            pdmOut->dmPaperSize = pdmIn->dmPaperSize;
        }
    }
    else if (pdmIn->dmFields & DM_FORMNAME)
    {
        pdmOut->dmFields |= DM_FORMNAME;
        pdmOut->dmFields &= ~(DM_PAPERLENGTH | DM_PAPERWIDTH | DM_PAPERSIZE);
        CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);
    }

    if ((pdmIn->dmFields & DM_SCALE) &&
        (pdmIn->dmScale >= MIN_SCALE) &&
        (pdmIn->dmScale <= MAX_SCALE))
    {
        pdmOut->dmFields |= DM_SCALE;
        pdmOut->dmScale = pdmIn->dmScale;
    }

    if ((pdmIn->dmFields & DM_COPIES) &&
        (pdmIn->dmCopies >= 1) &&
        (pdmIn->dmCopies <= (SHORT) pUIInfo->dwMaxCopies))
    {
        pdmOut->dmFields |= DM_COPIES;
        pdmOut->dmCopies = pdmIn->dmCopies;
    }

    if ((pdmIn->dmFields & DM_DUPLEX) &&
        (GET_PREDEFINED_FEATURE(pUIInfo, GID_DUPLEX) != NULL) &&
        (pdmIn->dmDuplex == DMDUP_SIMPLEX ||
         pdmIn->dmDuplex == DMDUP_HORIZONTAL ||
         pdmIn->dmDuplex == DMDUP_VERTICAL))
    {
        pdmOut->dmFields |= DM_DUPLEX;
        pdmOut->dmDuplex = pdmIn->dmDuplex;
    }

    if ((pdmIn->dmFields & DM_COLLATE) &&

        #ifdef WINNT_40
        GET_PREDEFINED_FEATURE(pUIInfo, GID_COLLATE) != NULL &&
        #endif

        (pdmIn->dmCollate == DMCOLLATE_TRUE ||
         pdmIn->dmCollate == DMCOLLATE_FALSE))
    {
        pdmOut->dmFields |= DM_COLLATE;
        pdmOut->dmCollate = pdmIn->dmCollate;
    }

    if ((pdmIn->dmFields & DM_TTOPTION) &&
        (pdmIn->dmTTOption == DMTT_BITMAP ||
         pdmIn->dmTTOption == DMTT_DOWNLOAD ||
         pdmIn->dmTTOption == DMTT_SUBDEV))
    {
        pdmOut->dmFields |= DM_TTOPTION;
        pdmOut->dmTTOption = (pdmIn->dmTTOption == DMTT_SUBDEV) ? DMTT_SUBDEV : DMTT_DOWNLOAD;
    }

    //
    // Merge color and ICM fields.
    //

    #ifndef ADOBE

    if (IS_COLOR_DEVICE(pUIInfo))
    {

    #endif // !ADOBE

        if ((pdmIn->dmFields & DM_COLOR) &&
            (pdmIn->dmColor == DMCOLOR_COLOR ||
             pdmIn->dmColor == DMCOLOR_MONOCHROME))
        {
            pdmOut->dmFields |= DM_COLOR;
            pdmOut->dmColor = pdmIn->dmColor;
        }

        #ifndef WINNT_40

        if ((pdmIn->dmFields & DM_ICMMETHOD) &&
            (pdmIn->dmICMMethod == DMICMMETHOD_NONE ||
             pdmIn->dmICMMethod == DMICMMETHOD_SYSTEM ||
             pdmIn->dmICMMethod == DMICMMETHOD_DRIVER ||
             pdmIn->dmICMMethod == DMICMMETHOD_DEVICE))
        {
            pdmOut->dmFields |= DM_ICMMETHOD;
            pdmOut->dmICMMethod = pdmIn->dmICMMethod;
        }

        if ((pdmIn->dmFields & DM_ICMINTENT) &&
            (pdmIn->dmICMIntent == DMICM_SATURATE ||
             pdmIn->dmICMIntent == DMICM_CONTRAST ||
             pdmIn->dmICMIntent == DMICM_COLORIMETRIC ||
             pdmIn->dmICMIntent == DMICM_ABS_COLORIMETRIC))
        {
            pdmOut->dmFields |= DM_ICMINTENT;
            pdmOut->dmICMIntent = pdmIn->dmICMIntent;
        }

        #endif // !WINNT_40

    #ifndef ADOBE

    }

    #endif // !ADOBE

    //
    // Resolution
    //

    if ((pdmIn->dmFields & (DM_PRINTQUALITY|DM_YRESOLUTION)) &&
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION)))
    {
        PRESOLUTION pRes;
        DWORD       dwIndex;
        INT         iXdpi, iYdpi;

        switch (pdmIn->dmFields & (DM_PRINTQUALITY|DM_YRESOLUTION))
        {
        case DM_PRINTQUALITY:

            iXdpi = iYdpi = pdmIn->dmPrintQuality;
            break;

        case DM_YRESOLUTION:

            iXdpi = iYdpi = pdmIn->dmYResolution;
            break;

        default:

            iXdpi = pdmIn->dmPrintQuality;
            iYdpi = pdmIn->dmYResolution;
            break;
        }

        dwIndex = MapToDeviceOptIndex(pUIInfo->pInfoHeader,
                                      GID_RESOLUTION,
                                      iXdpi,
                                      iYdpi,
                                      NULL);

        if (pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex))
        {
            pdmOut->dmFields |= (DM_PRINTQUALITY|DM_YRESOLUTION);
            pdmOut->dmPrintQuality = (short)pRes->iXdpi;
            pdmOut->dmYResolution = (short)pRes->iYdpi;
        }
    }

    //
    // Media type
    //

    if ((pdmIn->dmFields & DM_MEDIATYPE) &&
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_MEDIATYPE)) &&
        (pdmIn->dmMediaType == DMMEDIA_STANDARD  ||
         pdmIn->dmMediaType == DMMEDIA_TRANSPARENCY  ||
         pdmIn->dmMediaType == DMMEDIA_GLOSSY  ||
         ((pdmIn->dmMediaType >= DMMEDIA_USER) &&
          (pdmIn->dmMediaType <  DMMEDIA_USER + pFeature->Options.dwCount))))
    {
        pdmOut->dmFields |= DM_MEDIATYPE;
        pdmOut->dmMediaType = pdmIn->dmMediaType;
    }

    //
    // Merge the private devmode fields
    //

    if (pdmPrivateIn->dwSignature == PSDEVMODE_SIGNATURE)
    {
        CopyMemory(pdmPrivateOut, pdmPrivateIn, sizeof(PSDRVEXTRA));

        if (pdmPrivateOut->dwChecksum32 != pRawData->dwChecksum32)
        {
            WARNING(("PSCRIPT5: Devmode checksum mismatch.\n"));

            //
            // Intialize the new private devmode fields for PS 5.0.
            // If wReserved1 field is not 0, then the devmode is of
            // a previous version. In that case, we should initialize
            // all new private fields instead of just the options array.
            //

            VInitNewPrivateFields(pRawData,
                                  pUIInfo,
                                  pdmPrivateOut,
                                  pdmPrivateOut->wReserved1 != 0);


            //
            // Convert PS4 feature/option selections to PS4 format
            //

            if (pdmPrivateIn->wReserved1 == pPpdData->dwNt4Checksum)
            {
                VConvertOptSelectArray(pRawData,
                                       pdmPrivateOut->aOptions,
                                       MAX_PRINTER_OPTIONS,
                                       ((PSDRVEXTRA400 *) pdmPrivateIn)->aubOptions,
                                       64,
                                       MODE_DOCUMENT_STICKY);
            }
        }

        if (pdmPrivateOut->iPSLevel == 0 ||
            pdmPrivateOut->iPSLevel > (INT) pUIInfo->dwLangLevel)
        {
            pdmPrivateOut->iPSLevel = pUIInfo->dwLangLevel;
        }

        if (pdmPrivateOut->iTTDLFmt == TYPE_42 && pUIInfo->dwTTRasterizer != TTRAS_TYPE42)
            pdmPrivateOut->iTTDLFmt = TT_DEFAULT;

        if (IS_COLOR_DEVICE(pUIInfo))
        {
            pdmPrivateOut->dwFlags &= ~PSDEVMODE_NEG;
        }
    }

    //
    // If custom page size is supported, make sure the custom page
    // size parameters are valid.
    //

    if (SUPPORT_CUSTOMSIZE(pUIInfo))
        (VOID) BValidateCustomPageSizeData(pRawData, &pdmPrivateOut->csdata);

    return TRUE;
}



BOOL
BValidateDevmodeCustomPageSizeFields(
    PRAWBINARYDATA  pRawData,
    PUIINFO         pUIInfo,
    PDEVMODE        pdm,
    PRECTL          prclImageArea
    )

/*++

Routine Description:

    Check if the devmode form fields are specifying PostScript custom page size

Arguments:

    pRawData - Points to raw printer description data
    pUIInfo - Points to UIINFO structure
    pdm - Points to input devmode
    prclImageArea - Returns imageable area of the custom page size

Return Value:

    TRUE if the devmode specifies PostScript custom page size
    FALSE otherwise

--*/

{
    PPPDDATA    pPpdData;
    PPSDRVEXTRA pdmPrivate;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    if ((pdm->dmFields & DM_PAPERSIZE) &&
        pdm->dmPaperSize == DMPAPER_CUSTOMSIZE &&
        SUPPORT_CUSTOMSIZE(pUIInfo) &&
        SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUIInfo, pPpdData))
    {
        pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

        pdm->dmFields &= ~(DM_PAPERWIDTH|DM_PAPERLENGTH|DM_FORMNAME);
        pdm->dmPaperWidth = (SHORT) (pdmPrivate->csdata.dwX / DEVMODE_PAPER_UNIT);
        pdm->dmPaperLength = (SHORT) (pdmPrivate->csdata.dwY / DEVMODE_PAPER_UNIT);
        ZeroMemory(pdm->dmFormName, sizeof(pdm->dmFormName));

        if (prclImageArea)
        {
            prclImageArea->left =
            prclImageArea->top = 0;
            prclImageArea->right = pdmPrivate->csdata.dwX;
            prclImageArea->bottom = pdmPrivate->csdata.dwY;
        }

        return TRUE;
    }

    return FALSE;
}



VOID
VCopyUnicodeStringToAnsi(
    PSTR    pstr,
    PCWSTR  pwstr,
    INT     iMaxChars
    )

/*++

Routine Description:

    Convert an ANSI string to a UNICODE string (using the current ANSI codepage)

Arguments:

    pstr - Pointer to buffer for holding ANSI string
    pwstr - Pointer to Unicode string
    iMaxChars - Maximum number of ANSI characters to copy

Return Value:

    NONE

Note:

    If iMaxChars is 0 or negative, we assume the caller has provided
    an ANSI buffer that's sufficiently large to do the conversion.

--*/

{
    INT iLen = wcslen(pwstr) + 1;

    if (iMaxChars <= 0)
        iMaxChars = iLen;

    #ifdef KERNEL_MODE

    (VOID) EngUnicodeToMultiByteN(pstr, iMaxChars, NULL, (PWSTR) pwstr, iLen*sizeof(WCHAR));

    #else // !KERNEL_MODE

    (VOID) WideCharToMultiByte(CP_ACP, 0, pwstr, iLen, pstr, iMaxChars, NULL, NULL);

    #endif

    pstr[iMaxChars - 1] = NUL;
}



FORM_TRAY_TABLE
PGetAndConvertOldVersionFormTrayTable(
    IN HANDLE   hPrinter,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Retrieve the old form-to-tray assignment table from registry and convert
    it to the new format for the caller.

Arguments:

    hPrinter - Handle to the printer object
    pdwSize - Returns the form-to-tray assignment table size

Return Value:

    Pointer to form-to-tray assignment table read from the registry
    NULL if there is an error

--*/

{
    PTSTR   ptstrNewTable;
    PTSTR   ptstrOld, ptstrEnd, ptstrNew, ptstrSave;
    DWORD   dwTableSize, dwNewTableSize;
    FORM_TRAY_TABLE pFormTrayTable;

    //
    // Retrieve the form-to-tray assignment information from registry
    //

    pFormTrayTable = PvGetPrinterDataBinary(hPrinter,
                                            REGVAL_TRAY_FORM_SIZE_PS40,
                                            REGVAL_TRAY_FORM_TABLE_PS40,
                                            &dwTableSize);

    if (pFormTrayTable == NULL)
        return NULL;

    //
    // Simple validation to make sure the information is valid
    // Old format contains the table size as the first field in table
    //

    if (dwTableSize != *pFormTrayTable)
    {
        ERR(("Corrupted form-to-tray assignment table!\n"));
        SetLastError(ERROR_INVALID_DATA);

        MemFree(pFormTrayTable);
        return NULL;
    }

    //
    // Convert the old format form-to-tray assignment table to new format
    //  OLD                     NEW
    //  Tray Name               Tray Name
    //  Form Name               Form Name
    //  Printer Form
    //  IsDefaultTray
    //

    //
    // The first WCHAR hold the size of the table
    //

    dwTableSize -= sizeof(WCHAR);
    ptstrOld = pFormTrayTable + 1;
    ptstrEnd = ptstrOld + (dwTableSize / sizeof(WCHAR) - 1);

    //
    // Figuring out the size of new table, the last entry in the table
    // is always a NUL so add the count for it here first
    //

    dwNewTableSize = 1;

    while (ptstrOld < ptstrEnd && *ptstrOld != NUL)
    {
        ptstrSave = ptstrOld;
        ptstrOld += _tcslen(ptstrOld) + 1;
        ptstrOld += _tcslen(ptstrOld) + 1;

        //
        // New format contain only TrayName and FormName
        //

        dwNewTableSize += (DWORD)(ptstrOld - ptstrSave);

        //
        // Skip printer form and IsDefaultTray flag
        //

        ptstrOld += _tcslen(ptstrOld) + 2;
    }

    dwNewTableSize *= sizeof(WCHAR);

    if ((ptstrOld != ptstrEnd) ||
        (*ptstrOld != NUL) ||
        (ptstrNewTable = MemAlloc(dwNewTableSize)) == NULL)
    {
        ERR(( "Couldn't convert form-to-tray assignment table.\n"));
        MemFree(pFormTrayTable);
        return NULL;
    }

    //
    // The first WCHAR contains the table size
    //

    ptstrOld = pFormTrayTable + 1;
    ptstrNew = ptstrNewTable;

    while (*ptstrOld != NUL)
    {
        //
        // Copy slot name, form name
        //

        ptstrSave = ptstrOld;
        ptstrOld += _tcslen(ptstrOld) + 1;
        ptstrOld += _tcslen(ptstrOld) + 1;

        CopyMemory(ptstrNew, ptstrSave, (ptstrOld - ptstrSave) * sizeof(WCHAR));
        ptstrNew += (ptstrOld - ptstrSave);

        //
        // skip printer form and IsDefaultTray flag
        //

        ptstrOld += _tcslen(ptstrOld) + 2;
    }

    //
    // The last WCHAR is a NUL-terminator
    //

    *ptstrNew = NUL;

    if (pdwSize)
        *pdwSize = dwNewTableSize;

    MemFree(pFormTrayTable);

    ASSERT(BVerifyMultiSZPair(ptstrNewTable, dwNewTableSize));
    return(ptstrNewTable);
}



#ifndef KERNEL_MODE

BOOL
BSaveAsOldVersionFormTrayTable(
    IN HANDLE           hPrinter,
    IN FORM_TRAY_TABLE  pFormTrayTable,
    IN DWORD            dwSize
    )

/*++

Routine Description:

    Save form-to-tray assignment table in NT 4.0 compatible format

Arguments:

    hPrinter - Handle to the current printer
    pFormTrayTable - Points to new format form-tray table
    dwSize - Size of form-tray table to be saved, in bytes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwOldTableSize;
    PTSTR   ptstrNew, ptstrOld, ptstrOldTable;
    BOOL    bResult;

    //
    // Find out how much memory to allocate for old format table
    // Old format table has size as its very first character
    //

    ASSERT((dwSize % sizeof(TCHAR)) == 0 && dwSize >= sizeof(TCHAR));
    dwOldTableSize = dwSize + sizeof(WCHAR);
    ptstrNew = pFormTrayTable;

    while (*ptstrNew != NUL)
    {
        //
        // Skip tray name and form name
        //

        ptstrNew += _tcslen(ptstrNew) + 1;
        ptstrNew += _tcslen(ptstrNew) + 1;

        //
        // Old format has two extra characters per entry
        //  one for the empty PrinterForm field
        //  another for IsDefaultTray flag
        //

        dwOldTableSize += 2 * sizeof(TCHAR);
    }

    if ((ptstrOldTable = MemAlloc(dwOldTableSize)) == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return FALSE;
    }

    //
    // Convert new format table to old format
    // Be careful about the IsDefaultTray flag
    //

    ptstrNew = pFormTrayTable;
    ptstrOld = ptstrOldTable;
    *ptstrOld++ = (TCHAR) dwOldTableSize;

    while (*ptstrNew != NUL)
    {
        //
        // Copy slot name and form name
        //

        FINDFORMTRAY    FindData;
        DWORD           dwCount;
        PTSTR           ptstrTrayName, ptstrFormName;

        ptstrTrayName = ptstrNew;
        ptstrNew += _tcslen(ptstrNew) + 1;
        ptstrFormName = ptstrNew;
        ptstrNew += _tcslen(ptstrNew) + 1;

        CopyMemory(ptstrOld, ptstrTrayName, (ptstrNew - ptstrTrayName) * sizeof(TCHAR));
        ptstrOld += (ptstrNew - ptstrTrayName);

        //
        // Set PrinterForm field to NUL
        //

        *ptstrOld++ = NUL;

        //
        // Set IsDefaultTray flag appropriately
        //

        dwCount = 0;
        RESET_FINDFORMTRAY(pFormTrayTable, &FindData);

        while (BSearchFormTrayTable(pFormTrayTable, NULL, ptstrFormName, &FindData))
            dwCount++;

        *ptstrOld++ = (dwCount == 1) ? TRUE : FALSE;
    }

    //
    // The last character is a NUL-terminator
    //

    *ptstrOld = NUL;

    bResult = BSetPrinterDataBinary(
                        hPrinter,
                        REGVAL_TRAY_FORM_SIZE_PS40,
                        REGVAL_TRAY_FORM_TABLE_PS40,
                        ptstrOldTable,
                        dwOldTableSize);

    MemFree(ptstrOldTable);
    return bResult;
}

#endif // !KERNEL_MODE



BOOL
BGetDevmodeSettingForOEM(
    IN  PDEVMODE    pdm,
    IN  DWORD       dwIndex,
    OUT PVOID       pOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )

/*++

Routine Description:

    Function to provide OEM plugins access to driver private devmode settings

Arguments:

    pdm - Points to the devmode to be access
    dwIndex - Predefined index to specify which devmode the caller is interested in
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Returns the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAPPSDEVMODEFIELD(index, field) \
        { index, offsetof(PSDRVEXTRA, field), sizeof(pdmPrivate->field) }

{
    PPSDRVEXTRA pdmPrivate;
    INT         i;

    static const struct {

        DWORD   dwIndex;
        DWORD   dwOffset;
        DWORD   dwSize;

    } aIndexMap[]  = {

        MAPPSDEVMODEFIELD(OEMGDS_PSDM_FLAGS, dwFlags),
        MAPPSDEVMODEFIELD(OEMGDS_PSDM_DIALECT, iDialect),
        MAPPSDEVMODEFIELD(OEMGDS_PSDM_TTDLFMT, iTTDLFmt),
        MAPPSDEVMODEFIELD(OEMGDS_PSDM_NUP, iLayout),
        MAPPSDEVMODEFIELD(OEMGDS_PSDM_PSLEVEL, iPSLevel),
        MAPPSDEVMODEFIELD(OEMGDS_PSDM_CUSTOMSIZE, csdata),

        { 0, 0, 0 }
    };

    pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);
    i = 0;

    while (aIndexMap[i].dwSize != 0)
    {
        if (aIndexMap[i].dwIndex == dwIndex)
        {
            *pcbNeeded = aIndexMap[i].dwSize;

            if (cbSize < aIndexMap[i].dwSize || pOutput == NULL)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }

            CopyMemory(pOutput, (PBYTE) pdmPrivate + aIndexMap[i].dwOffset, aIndexMap[i].dwSize);
            return TRUE;
        }

        i++;
    }

    WARNING(("Unknown pscript devmode index: %d\n", dwIndex));
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
BConvertPrinterPropertiesData(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData,
    IN PVOID            pvSrcData,
    IN DWORD            dwSrcSize
    )

/*++

Routine Description:

    Convert an older or newer version PRINTERDATA structure to current version

Arguments:

    hPrinter - Handle to the current printer
    pRawData - Points to raw printer description data
    pPrinterData - Points to destination buffer
    pvSrcData - Points to source data to be converted
    dwSrcSize - Size of the source data in bytes

Return Value:

    TRUE if conversion was successful, FALSE otherwise

Note:

    This function is called after the library function has already
    done a generic conversion.

--*/

{
    PPS4_PRINTERDATA    pSrc = pvSrcData;
    PPPDDATA            pPpdData;

    //
    // Check if the source PRINTERDATA was from NT4 PS driver
    //

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    if (dwSrcSize != sizeof(PS4_PRINTERDATA) ||
        dwSrcSize != pSrc->wSize ||
        pSrc->wDriverVersion != PSDRIVER_VERSION_400 ||
        pSrc->wChecksum != pPpdData->dwNt4Checksum)
    {
        return FALSE;
    }

    //
    // Convert PS4 feature/option selections to PS4 format
    //

    VConvertOptSelectArray(pRawData,
                           pPrinterData->aOptions,
                           MAX_PRINTER_OPTIONS,
                           pSrc->options,
                           64,
                           MODE_PRINTER_STICKY);

    return TRUE;
}



VOID
VUpdatePrivatePrinterData(
    IN HANDLE           hPrinter,
    IN OUT PPRINTERDATA pPrinterData,
    IN DWORD            dwMode,
    IN PUIINFO          pUIInfo,
    IN POPTSELECT       pCombineOptions
    )

/*++

Routine Description:

    Update the Registry with the keyword/value pairs
    of PRINTERDATA's fixed fields.

Arguments:

    hPrinter - Handle to the current printer
    pPrinterData - Points to PRINTERDATA
    dwMode - MODE_READ/MODE_WRITE

Return Value:

    None

--*/

{
    DWORD dwValue, dwMinFreeMem;

    #ifdef KERNEL_MODE

    ASSERT(dwMode == MODE_READ);

    #endif

    //
    // read/write PRINTERDATA fields from/to registry
    //

    if (dwMode == MODE_READ)
    {
        if (BGetPrinterDataDWord(hPrinter, REGVAL_FREEMEM, &dwValue))
        {
            //
            // REGVAL_FREEMEM is in unit of Kbyte, we need to convert it to byte.
            // Also make sure the value is not less than the minimum value we required.
            //

            dwMinFreeMem = pUIInfo->dwLangLevel < 2 ? MIN_FREEMEM_L1: MIN_FREEMEM_L2;

            pPrinterData->dwFreeMem = max(dwValue * KBYTES, dwMinFreeMem);
        }

        if (BGetPrinterDataDWord(hPrinter, REGVAL_JOBTIMEOUT, &dwValue))
        {
            pPrinterData->dwJobTimeout = dwValue;
        }

        if (BGetPrinterDataDWord(hPrinter, REGVAL_PROTOCOL, &dwValue))
        {
            pPrinterData->wProtocol = (WORD)dwValue;

            if (pPrinterData->wProtocol != PROTOCOL_ASCII &&
                pPrinterData->wProtocol != PROTOCOL_BCP &&
                pPrinterData->wProtocol != PROTOCOL_TBCP &&
                pPrinterData->wProtocol != PROTOCOL_BINARY)
            {
                pPrinterData->wProtocol = PROTOCOL_ASCII;
            }
        }
    }

    #ifndef KERNEL_MODE

    else
    {
       ASSERT(dwMode == MODE_WRITE);

       //
       // Remember to convert byte to Kbyte for REGVAL_FREEMEM
       //

       (VOID) BSetPrinterDataDWord(hPrinter, REGVAL_FREEMEM, pPrinterData->dwFreeMem / KBYTES);
       (VOID) BSetPrinterDataDWord(hPrinter, REGVAL_JOBTIMEOUT, pPrinterData->dwJobTimeout);
       (VOID) BSetPrinterDataDWord(hPrinter, REGVAL_PROTOCOL, (DWORD)pPrinterData->wProtocol);
    }

    #endif // !KERNEL_MODE
}


VOID
VDefaultDevmodeFormFields(
    PUIINFO     pUIInfo,
    PDEVMODE    pDevmode,
    BOOL        bMetric
    )

/*++

Routine Description:

    Initialized the form-related devmode fields with their default values

Arguments:

    pUIInfo - Points for UIINFO
    pDevmode - Points to the DEVMODE whose form-related fields are to be initialized
    bMetric - Specifies whether the system is running in metric mode

Return Value:

    NONE

--*/

{
    ASSERT(pUIInfo);

    if (!(bMetric && (pUIInfo->dwFlags & FLAG_A4_SIZE_EXISTS)) &&
        !(!bMetric && (pUIInfo->dwFlags & FLAG_LETTER_SIZE_EXISTS)))
    {
        PFEATURE    pFeature;
        PPAGESIZE   pPageSize;
        PCWSTR      pDisplayName;

        //
        // A4 or Letter not available. Use the printer's default paper size.
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE)) &&
            (pPageSize = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex)) &&
            (pDisplayName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pPageSize->GenericOption.loDisplayName)))
        {
            CopyString(pDevmode->dmFormName, pDisplayName, CCHFORMNAME);
            pDevmode->dmPaperSize = (short)(pPageSize->dwPaperSizeID);
            pDevmode->dmPaperWidth =  (short)(pPageSize->szPaperSize.cx / DEVMODE_PAPER_UNIT);
            pDevmode->dmPaperLength = (short)(pPageSize->szPaperSize.cy / DEVMODE_PAPER_UNIT);

            //
            // PPD parser always assigns custom paper size values to dwPaperSizeID (see ppdparse.c), including for
            // standard page sizes, so we need to use dmPaperSize/dmPaperWidth in devmode instead of dmPaperSize.
            //

            pDevmode->dmFields |= (DM_FORMNAME | DM_PAPERWIDTH | DM_PAPERLENGTH);
            pDevmode->dmFields &= ~DM_PAPERSIZE;

            //
            // return when we succeeded, otherwise we will fall into the default A4 or Letter case
            //

            return;
        }
        else
        {
            ERR(("Failed to get default paper size from PPD\n"));
        }
    }

    if (bMetric)
    {
        CopyString(pDevmode->dmFormName, A4_FORMNAME, CCHFORMNAME);
        pDevmode->dmPaperSize = DMPAPER_A4;
        pDevmode->dmPaperWidth = 2100;      // 210mm measured in 0.1mm units
        pDevmode->dmPaperLength = 2970;     // 297mm
    }
    else
    {
        CopyString(pDevmode->dmFormName, LETTER_FORMNAME, CCHFORMNAME);
        pDevmode->dmPaperSize = DMPAPER_LETTER;
        pDevmode->dmPaperWidth = 2159;      // 8.5"
        pDevmode->dmPaperLength = 2794;     // 11"
    }

    pDevmode->dmFields &= ~(DM_PAPERWIDTH | DM_PAPERLENGTH);
    pDevmode->dmFields |= (DM_PAPERSIZE | DM_FORMNAME);
}


#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

typedef struct _VMERRMSGIDTBL
{
    LANGID  lgid;   // Language ID
    DWORD   resid;  // VM error handler resource ID
}
VMERRMSGIDTBL, *PVMERRMSGIDTBL;

VMERRMSGIDTBL VMErrMsgIDTbl[] =
{
    //  Lang. ID            Res. ID

    {   LANG_CHINESE,       0                           },  // Chinense: use sub table below
    {   LANG_DANISH,        PSPROC_vmerr_Danish_ps      },  // Danish      Adobe bug#342407
    {   LANG_DUTCH,         PSPROC_vmerr_Dutch_ps       },  // Dutch
    {   LANG_FINNISH,       PSPROC_vmerr_Finnish_ps     },  // Finnish     Adobe bug#342407
    {   LANG_FRENCH,        PSPROC_vmerr_French_ps      },  // French
    {   LANG_GERMAN,        PSPROC_vmerr_German_ps      },  // German
    {   LANG_ITALIAN,       PSPROC_vmerr_Italian_ps     },  // Italian
    {   LANG_JAPANESE,      PSPROC_vmerr_Japanese_ps    },  // Japanese
    {   LANG_KOREAN,        PSPROC_vmerr_Korean_ps      },  // Korean
    {   LANG_NORWEGIAN,     PSPROC_vmerr_Norwegian_ps   },  // Norwegian   Adobe bug#342407
    {   LANG_PORTUGUESE,    PSPROC_vmerr_Portuguese_ps  },  // Portuguese
    {   LANG_SPANISH,       PSPROC_vmerr_Spanish_ps     },  // Spanish
    {   LANG_SWEDISH,       PSPROC_vmerr_Swedish_ps     },  // Swedish

    {   0,      0   }   // Stopper. Don't remove this.
};

VMERRMSGIDTBL VMErrMsgIDTbl2[] =
{
    //  Sub lang. ID                    Res. ID

    {   SUBLANG_CHINESE_TRADITIONAL,    PSPROC_vmerr_TraditionalChinese_ps  },  // Taiwan
    {   SUBLANG_CHINESE_SIMPLIFIED,     PSPROC_vmerr_SimplifiedChinese_ps   },  // PRC
    {   SUBLANG_CHINESE_HONGKONG,       PSPROC_vmerr_TraditionalChinese_ps  },  // Hong Kong
    {   SUBLANG_CHINESE_SINGAPORE,      PSPROC_vmerr_SimplifiedChinese_ps   },  // Singapore

    {   0,      0   }   // Stopper. Don't remove this.
};

DWORD
DWGetVMErrorMessageID(
    VOID
    )
/*++

Routine Description:

    Get the VM Error message ID calculated from the current user's locale.

Arguments:

    None

Return Value:

    The VM Error message ID.

--*/

{
    LANGID  lgid;
    WORD    wPrim, wSub;
    DWORD   dwVMErrorMessageID;
    PVMERRMSGIDTBL pTbl, pTbl2;

    dwVMErrorMessageID = 0;

    lgid = GetSystemDefaultLangID();

    wPrim = PRIMARYLANGID(lgid);

    for (pTbl = VMErrMsgIDTbl; pTbl->lgid && !dwVMErrorMessageID; pTbl++)
    {
        if (pTbl->lgid == wPrim)
        {
            if (pTbl->resid)
            {
                dwVMErrorMessageID = pTbl->resid;
                break;
            }
            else
            {
                wSub = SUBLANGID(lgid);

                for (pTbl2 = VMErrMsgIDTbl2; pTbl2->lgid; pTbl2++)
                {
                    if (pTbl2->lgid == wSub)
                    {
                        dwVMErrorMessageID = pTbl2->resid;
                        break;
                    }
                }
            }
        }
    }

    return dwVMErrorMessageID;
}

#endif // !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ps\getdata.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    getdata.c

Abstract:

    PostScript helper functions for OEM plugins

        HGetGlobalAttribute
        HGetFeatureAttribute
        HGetOptionAttribute
        HEnumFeaturesOrOptions

Author:

    Feng Yue (fengy)

    8/24/2000 fengy Completed with support of both PPD and driver features.
    5/22/2000 fengy Created it with function framework.

--*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"

//
// PS driver's helper functions for OEM plugins
//

//
// global attribute names
//

const CHAR kstrCenterReg[]     = "CenterRegistered";
const CHAR kstrColorDevice[]   = "ColorDevice";
const CHAR kstrExtensions[]    = "Extensions";
const CHAR kstrFileVersion[]   = "FileVersion";
const CHAR kstrFreeVM[]        = "FreeVM";
const CHAR kstrLSOrientation[] = "LandscapeOrientation";
const CHAR kstrLangEncoding[]  = "LanguageEncoding";
const CHAR kstrLangLevel[]     = "LanguageLevel";
const CHAR kstrNickName[]      = "NickName";
const CHAR kstrPPDAdobe[]      = "PPD-Adobe";
const CHAR kstrPrintError[]    = "PrintPSErrors";
const CHAR kstrProduct[]       = "Product";
const CHAR kstrProtocols[]     = "Protocols";
const CHAR kstrPSVersion[]     = "PSVersion";
const CHAR kstrJobTimeout[]    = "SuggestedJobTimeout";
const CHAR kstrWaitTimeout[]   = "SuggestedWaitTimeout";
const CHAR kstrThroughput[]    = "Throughput";
const CHAR kstrTTRasterizer[]  = "TTRasterizer";

//
// feature attribute names
//

const CHAR kstrDisplayName[]   = "DisplayName";
const CHAR kstrDefOption[]     = "DefaultOption";
const CHAR kstrOpenUIType[]    = "OpenUIType";
const CHAR kstrOpenGroupType[] = "OpenGroupType";
const CHAR kstrOrderDepValue[] = "OrderDependencyValue";
const CHAR kstrOrderDepSect[]  = "OrderDependencySection";

//
// option keyword names, option attribute names
//

const CHAR kstrInvocation[]    = "Invocation";
const CHAR kstrInputSlot[]     = "InputSlot";
const CHAR kstrReqPageRgn[]    = "RequiresPageRegion";
const CHAR kstrOutputBin[]     = "OutputBin";
const CHAR kstrOutOrderRev[]   = "OutputOrderReversed";
const CHAR kstrPageSize[]      = "PageSize";
const CHAR kstrPaperDim[]      = "PaperDimension";
const CHAR kstrImgArea[]       = "ImageableArea";
const CHAR kstrCustomPS[]      = "CustomPageSize";
const CHAR kstrParamCustomPS[] = "ParamCustomPageSize";
const CHAR kstrHWMargins[]     = "HWMargins";
const CHAR kstrMaxMWidth[]     = "MaxMediaWidth";
const CHAR kstrMaxMHeight[]    = "MaxMediaHeight";
const CHAR kstrInstalledMem[]  = "InstalledMemory";
const CHAR kstrVMOption[]      = "VMOption";
const CHAR kstrFCacheSize[]    = "FCacheSize";

//
// enumeration of data region where an attribute is stored
//

typedef enum _EATTRIBUTE_DATAREGION {

    kADR_UIINFO,    // attribute is stored in UIINFO structure
    kADR_PPDDATA,   // attribute is stored in PPDDATA structure

} EATTRIBUTE_DATAREGION;


/*++

Routine Name:

    HGetSingleData

Routine Description:

    copy source data to specified output buffer and set the output data type

Arguments:

    pSrcData - pointer to source data buffer
    dwSrcDataType - source data type
    cbSrcSize - source data buffer size in bytes
    pdwOutDataType - pointer to DWORD to store output data type
    pbOutData - pointer to output data buffer
    cbOutSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough

Last Error:

    None

--*/
HRESULT
HGetSingleData(
    IN  PVOID       pSrcData,
    IN  DWORD       dwSrcDataType,
    IN  DWORD       cbSrcSize,
    OUT PDWORD      pdwOutDataType,
    OUT PBYTE       pbOutData,
    IN  DWORD       cbOutSize,
    OUT PDWORD      pcbNeeded
    )
{
    //
    // Either pSrcData is NULL and cbSrcSize is 0,
    // or pSrcData is non-NULL and cbSrcSize is non-0.
    //

    ASSERT((pSrcData != NULL) || (cbSrcSize == 0));
    ASSERT((cbSrcSize != 0) || (pSrcData == NULL));

    if (pdwOutDataType)
    {
        *pdwOutDataType = dwSrcDataType;
    }

    if (pcbNeeded)
    {
        *pcbNeeded = cbSrcSize;
    }

    if (cbSrcSize)
    {
        //
        // We do have data for output.
        //

        if (!pbOutData || cbOutSize < cbSrcSize)
        {
            return E_OUTOFMEMORY;
        }

        CopyMemory(pbOutData, pSrcData, cbSrcSize);
    }

    return S_OK;
}


/*++

Routine Name:

    HGetGABool

Routine Description:

    get global boolean attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute Get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if the global attribute is not recognized

    S_OK
    E_OUTOFMEMORY   see function HGetSingleData

Last Error:

    None

--*/
HRESULT
HGetGABool(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _GA_BOOL_ENTRY {

        PCSTR                   pszAttributeName;  // attribute name
        EATTRIBUTE_DATAREGION   eADR;              // in UIINFO or PPDDATA
        DWORD                   cbOffset;          // byte offset to the DWORD data
        DWORD                   dwFlagBit;         // bit flag in the DWORD

    } GA_BOOL_ENTRY, *PGA_BOOL_ENTRY;

    static const GA_BOOL_ENTRY  kGABoolTable[] =
    {
        {kstrCenterReg,   kADR_PPDDATA, offsetof(PPDDATA, dwCustomSizeFlags), CUSTOMSIZE_CENTERREG},
        {kstrColorDevice, kADR_UIINFO,  offsetof(UIINFO, dwFlags),            FLAG_COLOR_DEVICE},
        {kstrPrintError,  kADR_PPDDATA, offsetof(PPDDATA, dwFlags),           PPDFLAG_PRINTPSERROR},
    };

    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    DWORD    cIndex;
    DWORD    cTableEntry = sizeof(kGABoolTable) / sizeof(GA_BOOL_ENTRY);
    PGA_BOOL_ENTRY pEntry;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    pEntry = (PGA_BOOL_ENTRY)(&kGABoolTable[0]);

    for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
    {
        if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
            (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
        {
            //
            // attribute name matches
            //

            DWORD dwValue;
            BOOL  bValue;

            if (pEntry->eADR == kADR_UIINFO)
            {
                dwValue = *((PDWORD)((PBYTE)pUIInfo + pEntry->cbOffset));
            }
            else if (pEntry->eADR == kADR_PPDDATA)
            {
                dwValue = *((PDWORD)((PBYTE)pPpdData + pEntry->cbOffset));
            }
            else
            {
                //
                // This shouldn't happen. It's here to catch our coding error.
                //

                RIP(("HGetGABool: unknown eADR %d\n", pEntry->eADR));
                return E_FAIL;
            }

            //
            // map the bit flag to boolean value
            //

            bValue = (dwValue & pEntry->dwFlagBit) ? TRUE : FALSE;

            return HGetSingleData((PVOID)&bValue, kADT_BOOL, sizeof(BOOL),
                                  pdwDataType, pbData, cbSize, pcbNeeded);
        }
    }

    //
    // can't find the attribute
    //
    // This shouldn't happen. It's here to catch our coding error.
    //

    RIP(("HGetGABool: unknown attribute %s\n", pszAttribute));
    return E_INVALIDARG;
}


/*++

Routine Name:

    HGetGAInvocation

Routine Description:

    get global invocation attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute Get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if the global attribute is not recognized

    S_OK
    E_OUTOFMEMORY   see function HGetSingleData

Last Error:

    None

--*/
HRESULT
HGetGAInvocation(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _GA_INVOC_ENTRY {

        PCSTR                   pszAttributeName;  // attribute name
        EATTRIBUTE_DATAREGION   eADR;              // in UIINFO or PPDDATA
        DWORD                   cbOffset;          // byte offset to INVOCATION structure

    } GA_INVOC_ENTRY, *PGA_INVOC_ENTRY;

    static const GA_INVOC_ENTRY  kGAInvocTable[] =
    {
        {kstrProduct,   kADR_PPDDATA, offsetof(PPDDATA, Product)},
        {kstrPSVersion, kADR_PPDDATA, offsetof(PPDDATA, PSVersion)},
    };

    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    DWORD    cIndex;
    DWORD    cTableEntry = sizeof(kGAInvocTable) / sizeof(GA_INVOC_ENTRY);
    PGA_INVOC_ENTRY pEntry;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    pEntry = (PGA_INVOC_ENTRY)(&kGAInvocTable[0]);

    for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
    {
        if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
            (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
        {
            //
            // attribute name matches
            //

            PINVOCATION pInvoc;

            if (pEntry->eADR == kADR_UIINFO)
            {
                pInvoc = (PINVOCATION)((PBYTE)pUIInfo + pEntry->cbOffset);
            }
            else if (pEntry->eADR == kADR_PPDDATA)
            {
                pInvoc = (PINVOCATION)((PBYTE)pPpdData + pEntry->cbOffset);
            }
            else
            {
                //
                // This shouldn't happen. It's here to catch our coding error.
                //

                RIP(("HGetGAInvocation: unknown eADR %d\n", pEntry->eADR));
                return E_FAIL;
            }

            return HGetSingleData(OFFSET_TO_POINTER(pInfoHeader, pInvoc->loOffset),
                                  kADT_BINARY, pInvoc->dwCount,
                                  pdwDataType, pbData, cbSize, pcbNeeded);
        }
    }

    //
    // can't find the attribute
    //
    // This shouldn't happen. It's here to catch our coding error.
    //

    RIP(("HGetGAInvocation: unknown attribute %s\n", pszAttribute));
    return E_INVALIDARG;
}


/*++

Routine Name:

    HGetGAString

Routine Description:

    get global ASCII string attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute Get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough

Last Error:

    None

--*/
HRESULT
HGetGAString(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _GA_STRING_ENTRY {

        PCSTR                   pszAttributeName;  // attribute name
        EATTRIBUTE_DATAREGION   eADR;              // in UIINFO or PPDDATA
        DWORD                   cbOffset;          // byte offset to the DWORD data
        BOOL                    bCheckDWord;       // TRUE to check the whole DWORD
                                                   // FALSE to check a bit in the DWORD
                                                   // (If bCheckDWord is TRUE, table look
                                                   // up will stop when first match is found.)
        BOOL                    bCheckBitSet;      // TRUE to check if the bit is set
                                                   // FALSE to check if the bit is cleared
                                                   // (this is ignored if bCheckDWord is TRUE)
        DWORD                   dwFlag;            // flag value
        PCSTR                   pszValue;          // registered value string

    } GA_STRING_ENTRY, *PGA_STRING_ENTRY;

    static const GA_STRING_ENTRY  kGAStringTable[] =
    {
        {kstrExtensions,    kADR_PPDDATA, offsetof(PPDDATA, dwExtensions),  FALSE, TRUE,  LANGEXT_DPS,        "DPS"},
        {kstrExtensions,    kADR_PPDDATA, offsetof(PPDDATA, dwExtensions),  FALSE, TRUE,  LANGEXT_CMYK,       "CMYK"},
        {kstrExtensions,    kADR_PPDDATA, offsetof(PPDDATA, dwExtensions),  FALSE, TRUE,  LANGEXT_COMPOSITE,  "Composite"},
        {kstrExtensions,    kADR_PPDDATA, offsetof(PPDDATA, dwExtensions),  FALSE, TRUE,  LANGEXT_FILESYSTEM, "FileSystem"},
        {kstrLSOrientation, kADR_UIINFO,  offsetof(UIINFO, dwFlags),        FALSE, TRUE,  FLAG_ROTATE90,      "Plus90"},
        {kstrLSOrientation, kADR_UIINFO,  offsetof(UIINFO, dwFlags),        FALSE, FALSE, FLAG_ROTATE90,      "Minus90"},
        {kstrLangEncoding,  kADR_UIINFO,  offsetof(UIINFO, dwLangEncoding), TRUE,  FALSE, LANGENC_ISOLATIN1,  "ISOLatin1"},
        {kstrLangEncoding,  kADR_UIINFO,  offsetof(UIINFO, dwLangEncoding), TRUE,  FALSE, LANGENC_UNICODE,    "Unicode"},
        {kstrLangEncoding,  kADR_UIINFO,  offsetof(UIINFO, dwLangEncoding), TRUE,  FALSE, LANGENC_JIS83_RKSJ, "JIS83-RKSJ"},
        {kstrLangEncoding,  kADR_UIINFO,  offsetof(UIINFO, dwLangEncoding), TRUE,  FALSE, LANGENC_NONE,       "None"},
        {kstrProtocols,     kADR_UIINFO,  offsetof(UIINFO, dwProtocols),    FALSE, TRUE,  PROTOCOL_BCP,       "BCP"},
        {kstrProtocols,     kADR_UIINFO,  offsetof(UIINFO, dwProtocols),    FALSE, TRUE,  PROTOCOL_PJL,       "PJL"},
        {kstrProtocols,     kADR_UIINFO,  offsetof(UIINFO, dwProtocols),    FALSE, TRUE,  PROTOCOL_TBCP,      "TBCP"},
        {kstrProtocols,     kADR_UIINFO,  offsetof(UIINFO, dwProtocols),    FALSE, TRUE,  PROTOCOL_SIC,       "SIC"},
        {kstrTTRasterizer,  kADR_UIINFO,  offsetof(UIINFO, dwTTRasterizer), TRUE,  FALSE, TTRAS_NONE,         "None"},
        {kstrTTRasterizer,  kADR_UIINFO,  offsetof(UIINFO, dwTTRasterizer), TRUE,  FALSE, TTRAS_ACCEPT68K,    "Accept68K"},
        {kstrTTRasterizer,  kADR_UIINFO,  offsetof(UIINFO, dwTTRasterizer), TRUE,  FALSE, TTRAS_TYPE42,       "Type42"},
        {kstrTTRasterizer,  kADR_UIINFO,  offsetof(UIINFO, dwTTRasterizer), TRUE,  FALSE, TTRAS_TRUEIMAGE,    "TrueImage"},
    };

    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    PGA_STRING_ENTRY pEntry;
    DWORD    cTableEntry = sizeof(kGAStringTable) / sizeof(GA_STRING_ENTRY);
    PSTR     pCurrentOut;
    DWORD    cbNeeded, cIndex;
    INT      cbRemain;

    if (pdwDataType)
    {
        *pdwDataType = kADT_ASCII;
    }

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    pCurrentOut = (PSTR)pbData;
    cbNeeded = 0;
    cbRemain = (INT)cbSize;

    pEntry = (PGA_STRING_ENTRY)(&kGAStringTable[0]);

    for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
    {
        if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
            (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
        {
            //
            // attribute name matches
            //

            DWORD dwValue;
            BOOL  bMatch;

            if (pEntry->eADR == kADR_UIINFO)
            {
                dwValue = *((PDWORD)((PBYTE)pUIInfo + pEntry->cbOffset));
            }
            else if (pEntry->eADR == kADR_PPDDATA)
            {
                dwValue = *((PDWORD)((PBYTE)pPpdData + pEntry->cbOffset));
            }
            else
            {
                //
                // This shouldn't happen. It's here to catch our coding error.
                //

                RIP(("HGetGAString: unknown eADR %d\n", pEntry->eADR));
                return E_FAIL;
            }

            if (pEntry->bCheckDWord)
            {
                //
                // check the whole DWORD
                //

                bMatch = (dwValue == pEntry->dwFlag) ? TRUE : FALSE;
            }
            else
            {
                BOOL bBitIsSet;

                //
                // check the one bit in the DWORD
                //

                bBitIsSet = (dwValue & pEntry->dwFlag) ? TRUE : FALSE;

                bMatch = (bBitIsSet == pEntry->bCheckBitSet ) ? TRUE : FALSE;
            }

            if (bMatch)
            {
                DWORD cbNameSize;

                //
                // count in the NUL delimiter
                //

                cbNameSize = strlen(pEntry->pszValue) + 1;

                if (pCurrentOut && cbRemain >= (INT)cbNameSize)
                {
                    CopyMemory(pCurrentOut, pEntry->pszValue, cbNameSize);
                    pCurrentOut += cbNameSize;
                }

                cbRemain -= cbNameSize;
                cbNeeded += cbNameSize;

                if (pEntry->bCheckDWord)
                {
                    //
                    // stop table look up when first match is found if we are
                    // checking the whole DWORD instead of bits in the DWORD.
                    //

                    break;
                }
            }
        }
    }

    //
    // remember the the last NUL terminator for the MULTI_SZ output string
    //

    cbRemain--;
    cbNeeded++;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCurrentOut || cbRemain < 0)
    {
        return E_OUTOFMEMORY;
    }

    *pCurrentOut = NUL;

    return S_OK;
}


/*++

Routine Name:

    HGetGADWord

Routine Description:

    get global DWORD attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute Get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if the global attribute is not recognized

    S_OK
    E_OUTOFMEMORY   see function HGetSingleData

Last Error:

    None

--*/
HRESULT
HGetGADWord(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _GA_DWORD_ENTRY {

        PCSTR                   pszAttributeName;  // attribute name
        EATTRIBUTE_DATAREGION   eADR;              // in UIINFO or PPDDATA
        DWORD                   cbOffset;          // byte offset to the DWORD data

    } GA_DWORD_ENTRY, *PGA_DWORD_ENTRY;

    static const GA_DWORD_ENTRY kGADWordTable[] =
    {
        {kstrFileVersion, kADR_PPDDATA, offsetof(PPDDATA, dwPpdFilever)},
        {kstrFreeVM,      kADR_UIINFO,  offsetof(UIINFO, dwFreeMem)},
        {kstrLangLevel,   kADR_UIINFO,  offsetof(UIINFO, dwLangLevel)},
        {kstrPPDAdobe,    kADR_UIINFO,  offsetof(UIINFO, dwSpecVersion)},
        {kstrJobTimeout,  kADR_UIINFO,  offsetof(UIINFO, dwJobTimeout)},
        {kstrWaitTimeout, kADR_UIINFO,  offsetof(UIINFO, dwWaitTimeout)},
        {kstrThroughput,  kADR_UIINFO,  offsetof(UIINFO, dwPrintRate)},
    };

    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    DWORD    cIndex;
    DWORD    cTableEntry = sizeof(kGADWordTable) / sizeof(GA_DWORD_ENTRY);
    PGA_DWORD_ENTRY pEntry;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    pEntry = (PGA_DWORD_ENTRY)(&kGADWordTable[0]);

    for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
    {
        if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
            (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
        {
            //
            // attribute name matches
            //

            DWORD  dwValue;

            if (pEntry->eADR == kADR_UIINFO)
            {
                dwValue = *((PDWORD)((PBYTE)pUIInfo + pEntry->cbOffset));
            }
            else if (pEntry->eADR == kADR_PPDDATA)
            {
                dwValue = *((PDWORD)((PBYTE)pPpdData + pEntry->cbOffset));
            }
            else
            {
                //
                // This shouldn't happen. It's here to catch our coding error.
                //

                RIP(("HGetGADWord: unknown eADR %d\n", pEntry->eADR));
                return E_FAIL;
            }

            return HGetSingleData((PVOID)&dwValue, kADT_DWORD, sizeof(DWORD),
                                  pdwDataType, pbData, cbSize, pcbNeeded);
        }
    }

    //
    // can't find the attribute
    //
    // This shouldn't happen. It's here to catch our coding error.
    //

    RIP(("HGetGADWord: unknown attribute %s\n", pszAttribute));
    return E_INVALIDARG;
}


/*++

Routine Name:

    HGetGAUnicode

Routine Description:

    get global Unicode string attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute Get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if the global attribute is not recognized

    S_OK
    E_OUTOFMEMORY   see function HGetSingleData

Last Error:

    None

--*/
HRESULT
HGetGAUnicode(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _GA_UNICODE_ENTRY {

        PCSTR                   pszAttributeName;  // attribute name
        EATTRIBUTE_DATAREGION   eADR;              // in UIINFO or PPDDATA
        DWORD                   cbOffset;          // byte offset to DWORD specifying
                                                   // offset to the UNICODE string

    } GA_UNICODE_ENTRY, *PGA_UNICODE_ENTRY;

    static const GA_UNICODE_ENTRY  kGAUnicodeTable[] =
    {
        {kstrNickName, kADR_UIINFO, offsetof(UIINFO, loNickName)},
    };

    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    DWORD    cIndex;
    DWORD    cTableEntry = sizeof(kGAUnicodeTable) / sizeof(GA_UNICODE_ENTRY);
    PGA_UNICODE_ENTRY pEntry;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    pEntry = (PGA_UNICODE_ENTRY)(&kGAUnicodeTable[0]);

    for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
    {
        if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
            (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
        {
            //
            // attribute name matches
            //

            PTSTR  ptstrString;
            DWORD  cbOffset;

            if (pEntry->eADR == kADR_UIINFO)
            {
                cbOffset = *((PDWORD)((PBYTE)pUIInfo + pEntry->cbOffset));
            }
            else if (pEntry->eADR == kADR_PPDDATA)
            {
                cbOffset = *((PDWORD)((PBYTE)pPpdData + pEntry->cbOffset));
            }
            else
            {
                //
                // This shouldn't happen. It's here to catch our coding error.
                //

                RIP(("HGetGAUnicode: unknown eADR %d\n", pEntry->eADR));
                return E_FAIL;
            }

            ptstrString = OFFSET_TO_POINTER(pInfoHeader, cbOffset);

            if (ptstrString == NULL)
            {
                return E_FAIL;
            }

            return HGetSingleData((PVOID)ptstrString, kADT_UNICODE, SIZE_OF_STRING(ptstrString),
                                  pdwDataType, pbData, cbSize, pcbNeeded);
        }
    }

    //
    // can't find the attribute
    //
    // This shouldn't happen. It's here to catch our coding error.
    //

    RIP(("HGetGAUnicode: unknown attribute %s\n", pszAttribute));
    return E_INVALIDARG;
}


/*++

Routine Name:

    HGetGlobalAttribute

Routine Description:

    get PPD global attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if the global attribute name is not recognized

Last Error:

    None

--*/
HRESULT
HGetGlobalAttribute(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef HRESULT (*_HGET_GA_PROC)(
        IN  PINFOHEADER,
        IN  DWORD,
        IN  PCSTR,
        OUT PDWORD,
        OUT PBYTE,
        IN  DWORD,
        OUT PDWORD);

    typedef struct _GA_PROCESS_ENTRY {

        PCSTR          pszAttributeName;   // attribute name
        _HGET_GA_PROC  pfnGetGAProc;       // attribute handling proc

    } GA_PROCESS_ENTRY, *PGA_PROCESS_ENTRY;

    static const GA_PROCESS_ENTRY kGAProcTable[] =
    {
        {kstrCenterReg,     HGetGABool},
        {kstrColorDevice,   HGetGABool},
        {kstrExtensions,    HGetGAString},
        {kstrFileVersion,   HGetGADWord},
        {kstrFreeVM,        HGetGADWord},
        {kstrLSOrientation, HGetGAString},
        {kstrLangEncoding,  HGetGAString},
        {kstrLangLevel,     HGetGADWord},
        {kstrNickName,      HGetGAUnicode},
        {kstrPPDAdobe,      HGetGADWord},
        {kstrPrintError,    HGetGABool},
        {kstrProduct,       HGetGAInvocation},
        {kstrProtocols,     HGetGAString},
        {kstrPSVersion,     HGetGAInvocation},
        {kstrJobTimeout,    HGetGADWord},
        {kstrWaitTimeout,   HGetGADWord},
        {kstrThroughput,    HGetGADWord},
        {kstrTTRasterizer,  HGetGAString},
    };

    DWORD cIndex;
    DWORD cTableEntry = sizeof(kGAProcTable) / sizeof(GA_PROCESS_ENTRY);
    PGA_PROCESS_ENTRY pEntry;

    if (!pszAttribute)
    {
        //
        // Client is asking for the full list of supported global attribute names
        //

        PSTR  pCurrentOut;
        DWORD cbNeeded;
        INT   cbRemain;

        if (pdwDataType)
        {
            *pdwDataType = kADT_ASCII;
        }

        pCurrentOut = (PSTR)pbData;
        cbNeeded = 0;
        cbRemain = (INT)cbSize;

        pEntry = (PGA_PROCESS_ENTRY)(&kGAProcTable[0]);

        for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
        {
            DWORD cbNameSize;

            //
            // count in the NUL between attribute keywords
            //

            cbNameSize = strlen(pEntry->pszAttributeName) + 1;

            if (pCurrentOut && cbRemain >= (INT)cbNameSize)
            {
                CopyMemory(pCurrentOut, pEntry->pszAttributeName, cbNameSize);
                pCurrentOut += cbNameSize;
            }

            cbRemain -= cbNameSize;
            cbNeeded += cbNameSize;
        }

        //
        // remember the last NUL terminator for the MULTI_SZ output string
        //

        cbRemain--;
        cbNeeded++;

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pCurrentOut || cbRemain < 0)
        {
            return E_OUTOFMEMORY;
        }

        *pCurrentOut = NUL;

        return S_OK;
    }

    //
    // Client does provide the global attribute name
    //

    pEntry = (PGA_PROCESS_ENTRY)(&kGAProcTable[0]);

    for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
    {
        if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
            (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
        {
            //
            // attribute name matches
            //

            ASSERT(pEntry->pfnGetGAProc);

            return (pEntry->pfnGetGAProc)(pInfoHeader,
                                          dwFlags,
                                          pszAttribute,
                                          pdwDataType,
                                          pbData,
                                          cbSize,
                                          pcbNeeded);
        }
    }

    TERSE(("HGetGlobalAttribute: unknown global attribute %s\n", pszAttribute));
    return E_INVALIDARG;
}


/*++

Routine Name:

    PGetOrderDepNode

Routine Description:

    get the ORDERDEPEND strucutre associated with the specific feature/option

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    pPpdData - pointer to driver's PPDDATA structure
    dwFeatureIndex - feature index
    dwOptionIndex - option index (this could be OPTION_INDEX_ANY)

Return Value:

    pointer to the ORDERDEPEND structure if succeeds
    NULL otherwise

Last Error:

    None

--*/
PORDERDEPEND
PGetOrderDepNode(
    IN  PINFOHEADER pInfoHeader,
    IN  PPPDDATA    pPpdData,
    IN  DWORD       dwFeatureIndex,
    IN  DWORD       dwOptionIndex
    )
{
    PORDERDEPEND  pOrder;
    DWORD         cIndex;

    pOrder = (PORDERDEPEND)OFFSET_TO_POINTER(&(pInfoHeader->RawData),
                                             pPpdData->OrderDeps.loOffset);

    ASSERT(pOrder != NULL || pPpdData->OrderDeps.dwCount == 0);

    if (pOrder == NULL)
    {
        return NULL;
    }

    for (cIndex = 0; cIndex < pPpdData->OrderDeps.dwCount; cIndex++, pOrder++)
    {
        if (pOrder->dwSection == SECTION_UNASSIGNED)
            continue;

        if (pOrder->dwFeatureIndex == dwFeatureIndex &&
            pOrder->dwOptionIndex == dwOptionIndex)
        {
            return pOrder;
        }
    }

    return NULL;
}


/*++

Routine Name:

    HGetOrderDepSection

Routine Description:

    get order dependency section name

Arguments:

    pOrder - pointer to the ORDERDEPEND structure
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK
    E_OUTOFMEMORY   see function HGetSingleData

Last Error:

    None

--*/
HRESULT
HGetOrderDepSection(
    IN  PORDERDEPEND  pOrder,
    OUT PDWORD        pdwDataType,
    OUT PBYTE         pbData,
    IN  DWORD         cbSize,
    OUT PDWORD        pcbNeeded
    )
{
    static const CHAR kpstrSections[][20] =
    {
        "DocumentSetup",
        "PageSetup",
        "Prolog",
        "ExitServer",
        "JCLSetup",
        "AnySetup"
    };

    DWORD  dwSectIndex;

    ASSERT(pOrder);

    switch (pOrder->dwPPDSection)
    {
    case SECTION_DOCSETUP:

        dwSectIndex = 0;
        break;

    case SECTION_PAGESETUP:

        dwSectIndex = 1;
        break;

    case SECTION_PROLOG:

        dwSectIndex = 2;
        break;

    case SECTION_EXITSERVER:

        dwSectIndex = 3;
        break;

    case SECTION_JCLSETUP:

        dwSectIndex = 4;
        break;

    case SECTION_ANYSETUP:
    default:

        dwSectIndex = 5;
        break;
    }

    return HGetSingleData((PVOID)kpstrSections[dwSectIndex], kADT_ASCII,
                          strlen(kpstrSections[dwSectIndex]) + 1,
                          pdwDataType, pbData, cbSize, pcbNeeded);
}


/*++

Routine Name:

    HGetFeatureAttribute

Routine Description:

    get PPD feature attribute

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute get operation
    pszFeatureKeyword - PPD feature keyword name
    pszAttribute - name of the feature attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if feature keyword name or attribute name is not recognized

Last Error:

    None

--*/
HRESULT
HGetFeatureAttribute(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszFeatureKeyword,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _FA_ENTRY {

        PCSTR   pszAttributeName;    // feature attribute name
        BOOL    bNeedOrderDepNode;   // TRUE if the attribute only exist
                                     // when the feature has an *OrderDependency
                                     // entry in PPD, FALSE otherwise.

    } FA_ENTRY, *PFA_ENTRY;

    static const FA_ENTRY  kFATable[] =
    {
        {kstrDisplayName,   FALSE},
        {kstrDefOption,     FALSE},
        {kstrOpenUIType,    FALSE},
        {kstrOpenGroupType, FALSE},
        {kstrOrderDepValue, TRUE},
        {kstrOrderDepSect,  TRUE},
    };

    PUIINFO      pUIInfo;
    PPPDDATA     pPpdData;
    PFEATURE     pFeature;
    PORDERDEPEND pOrder;
    DWORD        dwFeatureIndex;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    if (!pszFeatureKeyword ||
        (pFeature = PGetNamedFeature(pUIInfo, pszFeatureKeyword, &dwFeatureIndex)) == NULL)
    {
        ERR(("HGetFeatureAttribute: invalid feature\n"));
        return E_INVALIDARG;
    }

    pOrder = PGetOrderDepNode(pInfoHeader, pPpdData, dwFeatureIndex, OPTION_INDEX_ANY);

    if (!pszAttribute)
    {
        //
        // Client is asking for the full list of supported feature attribute names
        //

        PFA_ENTRY pEntry;
        DWORD     cIndex;
        DWORD     cTableEntry = sizeof(kFATable) / sizeof(FA_ENTRY);
        PSTR      pCurrentOut;
        DWORD     cbNeeded;
        INT       cbRemain;

        if (pdwDataType)
        {
            *pdwDataType = kADT_ASCII;
        }

        pCurrentOut = (PSTR)pbData;
        cbNeeded = 0;
        cbRemain = (INT)cbSize;


        pEntry = (PFA_ENTRY)(&kFATable[0]);

        for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
        {
            DWORD  cbNameSize;

            //
            // If the attribute only exist when the feature has an *OrderDependency entry in PPD,
            // but we didn't find the feature's pOrder node, skip it.
            //

            if (pEntry->bNeedOrderDepNode && !pOrder)
                continue;

            //
            // count in the NUL between attribute keywords
            //

            cbNameSize = strlen(pEntry->pszAttributeName) + 1;

            if (pCurrentOut && cbRemain >= (INT)cbNameSize)
            {
                CopyMemory(pCurrentOut, pEntry->pszAttributeName, cbNameSize);
                pCurrentOut += cbNameSize;
            }

            cbRemain -= cbNameSize;
            cbNeeded += cbNameSize;
        }

        //
        // remember the last NUL terminator for the MULTI_SZ output string
        //

        cbRemain--;
        cbNeeded++;

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pCurrentOut || cbRemain < 0)
        {
            return E_OUTOFMEMORY;
        }

        *pCurrentOut = NUL;

        return S_OK;
    }

    //
    // Client does provide the feature attribute name
    //

    if ((*pszAttribute == kstrDisplayName[0]) &&
        (strcmp(pszAttribute, kstrDisplayName) == EQUAL_STRING))
    {
        PTSTR  ptstrDispName;

        ptstrDispName = OFFSET_TO_POINTER(pInfoHeader, pFeature->loDisplayName);

        if (ptstrDispName == NULL)
        {
            return E_FAIL;
        }

        return HGetSingleData((PVOID)ptstrDispName, kADT_UNICODE, SIZE_OF_STRING(ptstrDispName),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrDefOption[0]) &&
             (strcmp(pszAttribute, kstrDefOption) == EQUAL_STRING))
    {
        POPTION  pOption;
        PSTR     pstrKeywordName;

        pOption = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex);

        if (!pOption)
        {
            ERR(("HGetFeatureAttribute: can't find default option. Use the first one.\n"));
            pOption = PGetIndexedOption(pUIInfo, pFeature, 0);
            if (!pOption)
            {
                return E_FAIL;
            }
        }

        pstrKeywordName = OFFSET_TO_POINTER(pInfoHeader, pOption->loKeywordName);

        return HGetSingleData((PVOID)pstrKeywordName, kADT_ASCII, strlen(pstrKeywordName) + 1,
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrOpenUIType[0]) &&
             (strcmp(pszAttribute, kstrOpenUIType) == EQUAL_STRING))
    {
        static const CHAR pstrUITypes[][10] =
        {
            "PickOne",
            "PickMany",
            "Boolean"
        };

        DWORD  dwType = pFeature->dwUIType;

        if (dwType > UITYPE_BOOLEAN)
        {
            RIP(("HGetFeatureAttribute: invalid UIType %d\n", dwType));
            dwType = 0;
        }

        return HGetSingleData((PVOID)pstrUITypes[dwType], kADT_ASCII,
                              strlen(pstrUITypes[dwType]) + 1,
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrOpenGroupType[0]) &&
             (strcmp(pszAttribute, kstrOpenGroupType) == EQUAL_STRING))
    {
        static const CHAR pstrGroupTypes[][30] =
        {
            "InstallableOptions",
            ""
        };

        DWORD  dwType;

        dwType = (pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY) ? 0 : 1;

        return HGetSingleData((PVOID)pstrGroupTypes[dwType], kADT_ASCII,
                              strlen(pstrGroupTypes[dwType]) + 1,
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrOrderDepValue[0]) &&
             (strcmp(pszAttribute, kstrOrderDepValue) == EQUAL_STRING))
    {
        if (!pOrder)
        {
            TERSE(("HGetFeatureAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        return HGetSingleData((PVOID)&(pOrder->lOrder), kADT_LONG, sizeof(LONG),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrOrderDepSect[0]) &&
             (strcmp(pszAttribute, kstrOrderDepSect) == EQUAL_STRING))
    {
        if (!pOrder)
        {
            TERSE(("HGetFeatureAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        return HGetOrderDepSection(pOrder, pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else
    {
        TERSE(("HGetFeatureAttribute: unknown feature attribute %s\n", pszAttribute));
        return E_INVALIDARG;
    }
}


/*++

Routine Name:

    HGetOptionAttribute

Routine Description:

    get option attribute of a PPD feature

Arguments:

    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the attribute get operation
    pszFeatureKeyword - PPD feature keyword name
    pszOptionKeyword - option keyword name of the PPD feature
    pszAttribute - name of the feature attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if feature keyword name, or option keyword name,
                    or attribute name is not recognized

Last Error:

    None

--*/
HRESULT
HGetOptionAttribute(
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszFeatureKeyword,
    IN  PCSTR       pszOptionKeyword,
    IN  PCSTR       pszAttribute,
    OUT PDWORD      pdwDataType,
    OUT PBYTE       pbData,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    typedef struct _OA_ENTRY {

        PCSTR   pszFeatureKeyword;   // feature keyword name
                                     // (NULL for non-feature specific attributes)
        PCSTR   pszOptionKeyword;    // option keyword name
                                     // (NULL for non-option specific attributes)
        PCSTR   pszAttributeName;    // option attribute name (this field must be
                                     // unique across the table)
        BOOL    bNeedOrderDepNode;   // TRUE if the attribute only exist
                                     // when the option has an *OrderDependency
                                     // entry in PPD, FALSE otherwise.
        BOOL    bSpecialHandle;      // TRUE if the attribute needs special handling.
                                     // If TRUE, following table fields are not used.
        DWORD   dwDataType;          // data type of the attribute value
        DWORD   cbNeeded;            // byte count of the attribute value
        DWORD   cbOffset;            // byte offset to the attribute value, starting
                                     // from the beginning of OPTION structure

    } OA_ENTRY, *POA_ENTRY;

    static const OA_ENTRY  kOATable[] =
    {
        {NULL,             NULL,         kstrDisplayName,   FALSE, TRUE,  0, 0, 0},
        {NULL,             NULL,         kstrInvocation,    FALSE, TRUE,  0, 0, 0},
        {NULL,             NULL,         kstrOrderDepValue, TRUE,  TRUE,  0, 0, 0},
        {NULL,             NULL,         kstrOrderDepSect,  TRUE,  TRUE,  0, 0, 0},
        {kstrInputSlot,    NULL,         kstrReqPageRgn,    FALSE, TRUE,  0, 0, 0},
        {kstrOutputBin,    NULL,         kstrOutOrderRev,   FALSE, FALSE, kADT_BOOL,  sizeof(BOOL),  offsetof(OUTPUTBIN, bOutputOrderReversed)},
        {kstrPageSize,     NULL,         kstrPaperDim,      FALSE, FALSE, kADT_SIZE,  sizeof(SIZE),  offsetof(PAGESIZE, szPaperSize)},
        {kstrPageSize,     NULL,         kstrImgArea,       FALSE, TRUE,  0, 0, 0},
        {kstrPageSize,     kstrCustomPS, kstrParamCustomPS, FALSE, TRUE,  0, 0, 0},
        {kstrPageSize,     kstrCustomPS, kstrHWMargins,     FALSE, FALSE, kADT_RECT,  sizeof(RECT),  offsetof(PAGESIZE, rcImgArea)},
        {kstrPageSize,     kstrCustomPS, kstrMaxMWidth,     FALSE, FALSE, kADT_DWORD, sizeof(DWORD), offsetof(PAGESIZE, szPaperSize) + offsetof(SIZE, cx)},
        {kstrPageSize,     kstrCustomPS, kstrMaxMHeight,    FALSE, FALSE, kADT_DWORD, sizeof(DWORD), offsetof(PAGESIZE, szPaperSize) + offsetof(SIZE, cy)},
        {kstrInstalledMem, NULL,         kstrVMOption,      FALSE, FALSE, kADT_DWORD, sizeof(DWORD), offsetof(MEMOPTION, dwInstalledMem)},
        {kstrInstalledMem, NULL,         kstrFCacheSize,    FALSE, FALSE, kADT_DWORD, sizeof(DWORD), offsetof(MEMOPTION, dwFreeFontMem)},
    };

    PUIINFO      pUIInfo;
    PPPDDATA     pPpdData;
    PFEATURE     pFeature;
    POPTION      pOption;
    PORDERDEPEND pOrder;
    DWORD        dwFeatureIndex, dwOptionIndex, cIndex;
    DWORD        cTableEntry = sizeof(kOATable) / sizeof(OA_ENTRY);
    POA_ENTRY    pEntry;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    if (!pszFeatureKeyword ||
        (pFeature = PGetNamedFeature(pUIInfo, pszFeatureKeyword, &dwFeatureIndex)) == NULL)
    {
        ERR(("HGetOptionAttribute: invalid feature\n"));
        return E_INVALIDARG;
    }

    if (!pszOptionKeyword ||
        (pOption = PGetNamedOption(pUIInfo, pFeature, pszOptionKeyword, &dwOptionIndex)) == NULL)
    {
        ERR(("HGetOptionAttribute: invalid option\n"));
        return E_INVALIDARG;
    }

    pOrder = PGetOrderDepNode(pInfoHeader, pPpdData, dwFeatureIndex, dwOptionIndex);

    if (!pszAttribute)
    {
        //
        // Client is asking for the full list of supported option attribute names
        //

        PSTR  pCurrentOut;
        DWORD cbNeeded;
        INT   cbRemain;

        if (pdwDataType)
        {
            *pdwDataType = kADT_ASCII;
        }

        pCurrentOut = (PSTR)pbData;
        cbNeeded = 0;
        cbRemain = (INT)cbSize;

        pEntry = (POA_ENTRY)(&kOATable[0]);

        for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
        {
            DWORD cbNameSize;

            //
            // If the attribute is specific to a certain feature, check the feature keyword match.
            //

            if (pEntry->pszFeatureKeyword &&
                (strcmp(pEntry->pszFeatureKeyword, pszFeatureKeyword) != EQUAL_STRING))
                continue;

            //
            // If the attribute is specific to a certain option, check the option keyword match.
            //

            if (pEntry->pszOptionKeyword &&
                (strcmp(pEntry->pszOptionKeyword, pszOptionKeyword) != EQUAL_STRING))
                continue;

            //
            // special case: For PageSize's CustomPageSize option, we need to skip attributes
            // that are only available to PageSize's all non-CustomPageSize options.
            //

            if (pEntry->pszFeatureKeyword &&
                !pEntry->pszOptionKeyword &&
                (pFeature->dwFeatureID == GID_PAGESIZE) &&
                (((PPAGESIZE)pOption)->dwPaperSizeID == DMPAPER_CUSTOMSIZE))
                continue;

            //
            // If the attribute only exist when the option has an *OrderDependency entry in PPD,
            // but we didn't find the option's pOrder node, skip it.
            //

            if (pEntry->bNeedOrderDepNode && !pOrder)
                continue;

            //
            // count in the NUL between attribute keywords
            //

            cbNameSize = strlen(pEntry->pszAttributeName) + 1;

            if (pCurrentOut && cbRemain >= (INT)cbNameSize)
            {
                CopyMemory(pCurrentOut, pEntry->pszAttributeName, cbNameSize);
                pCurrentOut += cbNameSize;
            }

            cbRemain -= cbNameSize;
            cbNeeded += cbNameSize;
        }

        //
        // remember the last NUL terminator for the MULTI_SZ output string.
        //

        cbRemain--;
        cbNeeded++;

        if (pcbNeeded)
        {
            *pcbNeeded = cbNeeded;
        }

        if (!pCurrentOut || cbRemain < 0)
        {
            return E_OUTOFMEMORY;
        }

        *pCurrentOut = NUL;

        return S_OK;
    }

    //
    // Client does provide the option attribute name
    //

    //
    // First handle a few special cases (bSpecialHandle == TRUE in the table).
    // Generic case handling is in the last else-part.
    //

    if ((*pszAttribute == kstrDisplayName[0]) &&
        (strcmp(pszAttribute, kstrDisplayName) == EQUAL_STRING))
    {
        //
        // "DisplayName"
        //

        PTSTR  ptstrDispName;

        ptstrDispName = OFFSET_TO_POINTER(pInfoHeader, pOption->loDisplayName);

        if (ptstrDispName == NULL)
        {
            return E_FAIL;
        }

        return HGetSingleData((PVOID)ptstrDispName, kADT_UNICODE, SIZE_OF_STRING(ptstrDispName),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrInvocation[0]) &&
             (strcmp(pszAttribute, kstrInvocation) == EQUAL_STRING))
    {
        //
        // "Invocation"
        //

        return HGetSingleData(OFFSET_TO_POINTER(pInfoHeader, pOption->Invocation.loOffset),
                              kADT_BINARY, pOption->Invocation.dwCount,
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrOrderDepValue[0]) &&
             (strcmp(pszAttribute, kstrOrderDepValue) == EQUAL_STRING))
    {
        //
        // "OrderDependencyValue"
        //

        if (!pOrder)
        {
            TERSE(("HGetOptionAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        return HGetSingleData((PVOID)&(pOrder->lOrder), kADT_LONG, sizeof(LONG),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrOrderDepSect[0]) &&
             (strcmp(pszAttribute, kstrOrderDepSect) == EQUAL_STRING))
    {
        //
        // "OrderDependencySection"
        //

        if (!pOrder)
        {
            TERSE(("HGetOptionAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        return HGetOrderDepSection(pOrder, pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrReqPageRgn[0]) &&
             (strcmp(pszAttribute, kstrReqPageRgn) == EQUAL_STRING))
    {
        //
        // "RequiresPageRegion"
        //

        PINPUTSLOT pInputSlot = (PINPUTSLOT)pOption;
        BOOL       bValue;

        //
        // This attribute is only available to *InputSlot options, excluding the first
        // one "*UseFormTrayTable", which is synthesized by PPD parser.
        //

        if (pFeature->dwFeatureID != GID_INPUTSLOT ||
            (dwOptionIndex == 0 && pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE))
        {
            TERSE(("HGetOptionAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        bValue = (pInputSlot->dwFlags & INPUTSLOT_REQ_PAGERGN) ? TRUE : FALSE;

        return HGetSingleData((PVOID)&bValue, kADT_BOOL, sizeof(BOOL),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrImgArea[0]) &&
             (strcmp(pszAttribute, kstrImgArea) == EQUAL_STRING))
    {
        //
        // "ImageableArea"
        //

        PPAGESIZE  pPageSize = (PPAGESIZE)pOption;
        RECT       rcImgArea;

        //
        // This attribute is only available to *PageSize options, excluding CustomPageSize option.
        //

        if (pFeature->dwFeatureID != GID_PAGESIZE || pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
        {
            TERSE(("HGetOptionAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        //
        // convert GDI coordinate system back to PS coordinate system
        // (see VPackPrinterFeatures() case GID_PAGESIZE)
        //

        rcImgArea.left = pPageSize->rcImgArea.left;
        rcImgArea.right = pPageSize->rcImgArea.right;
        rcImgArea.top = pPageSize->szPaperSize.cy - pPageSize->rcImgArea.top;
        rcImgArea.bottom = pPageSize->szPaperSize.cy - pPageSize->rcImgArea.bottom;

        return HGetSingleData((PVOID)&rcImgArea, kADT_RECT, sizeof(RECT),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else if ((*pszAttribute == kstrParamCustomPS[0]) &&
             (strcmp(pszAttribute, kstrParamCustomPS) == EQUAL_STRING))
    {
        //
        // "ParamCustomPageSize"
        //

        PPAGESIZE  pPageSize = (PPAGESIZE)pOption;

        //
        // This attribute is only available to *PageSize feature's CustomPageSize option.
        //

        if (pFeature->dwFeatureID != GID_PAGESIZE || pPageSize->dwPaperSizeID != DMPAPER_CUSTOMSIZE)
        {
            TERSE(("HGetOptionAttribute: attribute %s not available\n", pszAttribute));
            return E_INVALIDARG;
        }

        return HGetSingleData((PVOID)(pPpdData->CustomSizeParams),
                              kADT_CUSTOMSIZEPARAMS, sizeof(pPpdData->CustomSizeParams),
                              pdwDataType, pbData, cbSize, pcbNeeded);
    }
    else
    {
        //
        // generic case handling
        //

        pEntry = (POA_ENTRY)(&kOATable[0]);

        for (cIndex = 0; cIndex < cTableEntry; cIndex++, pEntry++)
        {
             //
             // skip any entry that has already been specially handled
             //

             if (pEntry->bSpecialHandle)
                 continue;

             ASSERT(pEntry->bNeedOrderDepNode == FALSE);

             if ((*pszAttribute == *(pEntry->pszAttributeName)) &&
                 (strcmp(pszAttribute, pEntry->pszAttributeName) == EQUAL_STRING))
             {
                 //
                 // Attribute name matches. We still need to verify feature/option keyword match.
                 //

                 if (pEntry->pszFeatureKeyword &&
                     strcmp(pEntry->pszFeatureKeyword, pszFeatureKeyword) != EQUAL_STRING)
                 {
                     TERSE(("HGetOptionAttribute: feature keyword mismatch for attribute %s\n", pszAttribute));
                     return E_INVALIDARG;
                 }

                 if (pEntry->pszOptionKeyword &&
                    (strcmp(pEntry->pszOptionKeyword, pszOptionKeyword) != EQUAL_STRING))
                 {
                     TERSE(("HGetOptionAttribute: option keyword mismatch for attribute %s\n", pszAttribute));
                     return E_INVALIDARG;
                 }

                 //
                 // special case: For PageSize's CustomPageSize option, we need to skip attributes
                 // that are only available to PageSize's all non-CustomPageSize options.
                 //

                 if (pEntry->pszFeatureKeyword &&
                     !pEntry->pszOptionKeyword &&
                     (pFeature->dwFeatureID == GID_PAGESIZE) &&
                     (((PPAGESIZE)pOption)->dwPaperSizeID == DMPAPER_CUSTOMSIZE))
                     continue;

                 return HGetSingleData((PVOID)((PBYTE)pOption + pEntry->cbOffset),
                                       pEntry->dwDataType, pEntry->cbNeeded,
                                       pdwDataType, pbData, cbSize, pcbNeeded);
             }
        }

        TERSE(("HGetOptionAttribute: unknown option attribute %s\n", pszAttribute));
        return E_INVALIDARG;
    }
}


/*++

Routine Name:

    BIsSupported_PSF

Routine Description:

    determine if the PS driver synthesized feature is supported or not

Arguments:

    pszFeature - name of the PS driver synthesized feature
    pUIInfo - pointer to driver's UIINFO structure
    pPpdData - pointer to driver's PPDDATA structure
    bEMFSpooling - whether spooler EMF spooling is enabled or not

Return Value:

    TRUE if the feature is currently supported
    FALSE otherwise

Last Error:

    None

--*/
BOOL
BIsSupported_PSF(
    IN  PCSTR    pszFeature,
    IN  PUIINFO  pUIInfo,
    IN  PPPDDATA pPpdData,
    IN  BOOL     bEMFSpooling
    )
{
    #ifdef WINNT_40

    //
    // On NT4, bEMFSpooling should always be FALSE.
    //

    ASSERT(!bEMFSpooling);

    #endif // WINNT_40

    //
    // Note that the first character is always the % prefix.
    //

    if ((pszFeature[1] == kstrPSFAddEuro[1]) &&
        (strcmp(pszFeature, kstrPSFAddEuro) == EQUAL_STRING))
    {
        //
        // AddEuro is only supported for Level 2+ printers.
        //

        return(pUIInfo->dwLangLevel >= 2);
    }
    else if ((pszFeature[1] == kstrPSFEMF[1]) &&
             (strcmp(pszFeature, kstrPSFEMF) == EQUAL_STRING))
    {
        //
        // Driver EMF is always supported on NT4, and only supported
        // when spooler EMF is enabled on Win2K+.
        //

        #ifndef WINNT_40

        return bEMFSpooling;

        #else

        return TRUE;

        #endif  // !WINNT_40
    }
    else if ((pszFeature[1] == kstrPSFNegative[1]) &&
             (strcmp(pszFeature, kstrPSFNegative) == EQUAL_STRING))
    {
        //
        // Negative is only supported for b/w printers.
        //

        return(IS_COLOR_DEVICE(pUIInfo) ? FALSE : TRUE);
    }
    else if ((pszFeature[1] == kstrPSFPageOrder[1]) &&
             (strcmp(pszFeature, kstrPSFPageOrder) == EQUAL_STRING))
    {
        //
        // PageOrder is not supported on NT4, and is only supported
        // when spooler EMF is enabled on Win2K+.
        //

        return bEMFSpooling;
    }
    else
    {
        return TRUE;
    }
}


/*++

Routine Name:

    HEnumFeaturesOrOptions

Routine Description:

    enumerate the feature or option keyword name list

Arguments:

    hPrinter - printer handle
    pInfoHeader - pointer to driver's INFOHEADER structure
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name. This should be NULL
                        for feature enumeration and non-NULL for
                        option enumeration.
    pmszOutputList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if for option enumeration, feature keyword name is
                    not recognized
    E_NOTIMPL       if being called to enumerate options of PS driver
                    synthesized feature that is not currently supported or
                    whose options are not enumerable
    E_FAIL          if other internal failures are encountered

Last Error:

    None

--*/
HRESULT
HEnumFeaturesOrOptions(
    IN  HANDLE      hPrinter,
    IN  PINFOHEADER pInfoHeader,
    IN  DWORD       dwFlags,
    IN  PCSTR       pszFeatureKeyword,
    OUT PSTR        pmszOutputList,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )
{
    PUIINFO  pUIInfo;
    PPPDDATA pPpdData;
    PFEATURE pFeature;
    POPTION  pOption;
    DWORD    cIndex, cPPDFeaturesOrOptions;
    BOOL     bEnumFeatures, bEnumPPDOptions;
    PSTR     pCurrentOut;
    DWORD    cbNeeded;
    INT      cbRemain;
    BOOL     bEMFSpooling;
    PPSFEATURE_ENTRY pEntry;

    pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHeader);
    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHeader);

    ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pUIInfo == NULL || pPpdData == NULL)
    {
        return E_FAIL;
    }

    pCurrentOut = pmszOutputList;
    cbNeeded = 0;
    cbRemain = (INT)cbSize;

    bEnumFeatures = pszFeatureKeyword ? FALSE : TRUE;
    bEnumPPDOptions = TRUE;

    if (bEnumFeatures)
    {
        //
        // Enumerate driver synthersized features first.
        //

        VGetSpoolerEmfCaps(hPrinter, NULL, &bEMFSpooling, 0, NULL);

        pEntry = (PPSFEATURE_ENTRY)(&kPSFeatureTable[0]);

        while (pEntry->pszPSFeatureName)
        {
            if (BIsSupported_PSF(pEntry->pszPSFeatureName, pUIInfo, pPpdData, bEMFSpooling))
            {
                DWORD cbNameLen;

                cbNameLen = strlen(pEntry->pszPSFeatureName) + 1;

                if (pCurrentOut && cbRemain >= (INT)cbNameLen)
                {
                    CopyMemory(pCurrentOut, pEntry->pszPSFeatureName, cbNameLen);
                    pCurrentOut += cbNameLen;
                }

                cbRemain -= cbNameLen;
                cbNeeded += cbNameLen;
            }

            pEntry++;
        }
    }
    else
    {
        if (*pszFeatureKeyword == PSFEATURE_PREFIX)
        {
            bEnumPPDOptions = FALSE;

            VGetSpoolerEmfCaps(hPrinter, NULL, &bEMFSpooling, 0, NULL);

            if (!BIsSupported_PSF(pszFeatureKeyword, pUIInfo, pPpdData, bEMFSpooling))
            {
                WARNING(("HEnumFeaturesOrOptions: feature %s is not supported\n", pszFeatureKeyword));
                return E_NOTIMPL;
            }
        }
    }

    if (bEnumFeatures)
    {
        cPPDFeaturesOrOptions = pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures;

        pFeature = OFFSET_TO_POINTER(pInfoHeader, pUIInfo->loFeatureList);

        ASSERT(cPPDFeaturesOrOptions == 0 || pFeature != NULL);
        
        if (pFeature == NULL)
        {
            return E_FAIL;
        }
    }
    else if (bEnumPPDOptions)
    {
        DWORD dwFeatureIndex;

        pFeature = PGetNamedFeature(pUIInfo, pszFeatureKeyword, &dwFeatureIndex);

        if (!pFeature)
        {
            ERR(("HEnumFeaturesOrOptions: unrecognized feature %s\n", pszFeatureKeyword));
            return E_INVALIDARG;
        }

        cPPDFeaturesOrOptions = pFeature->Options.dwCount;

        pOption = OFFSET_TO_POINTER(pInfoHeader, pFeature->Options.loOffset);

        ASSERT(cPPDFeaturesOrOptions == 0 || pOption != NULL);
        
        if (pOption == NULL)
        {
            return E_FAIL;
        }
    }
    else
    {
        //
        // Enum driver synthersized feature's options.
        //

        pEntry = (PPSFEATURE_ENTRY)(&kPSFeatureTable[0]);

        while (pEntry->pszPSFeatureName)
        {
            if ((*pszFeatureKeyword == *(pEntry->pszPSFeatureName)) &&
                strcmp(pszFeatureKeyword, pEntry->pszPSFeatureName) == EQUAL_STRING)
            {
                if (!pEntry->bEnumerableOptions)
                {
                    //
                    // This driver feature doesn't support option enumeration.
                    //

                    WARNING(("HEnumFeaturesOrOptions: enum options not supported for %s\n", pszFeatureKeyword));
                    return E_NOTIMPL;
                }

                if (pEntry->bBooleanOptions)
                {
                    //
                    // This driver feature has True/False boolean options.
                    //

                    DWORD  cbKwdTrueSize, cbKwdFalseSize;

                    cbKwdTrueSize = strlen(kstrKwdTrue) + 1;
                    cbKwdFalseSize = strlen(kstrKwdFalse) + 1;

                    if (pCurrentOut && (cbRemain >= (INT)(cbKwdTrueSize + cbKwdFalseSize)))
                    {
                        CopyMemory(pCurrentOut, kstrKwdTrue, cbKwdTrueSize);
                        pCurrentOut += cbKwdTrueSize;

                        CopyMemory(pCurrentOut, kstrKwdFalse, cbKwdFalseSize);
                        pCurrentOut += cbKwdFalseSize;
                    }

                    cbRemain -= (cbKwdTrueSize + cbKwdFalseSize);
                    cbNeeded += cbKwdTrueSize + cbKwdFalseSize;
                }
                else
                {
                    //
                    // This driver feature needs special handler to enumerate its options.
                    //

                    if (pEntry->pfnPSProc)
                    {
                        DWORD cbPSFOptionsSize;
                        BOOL  bResult;

                        bResult = (pEntry->pfnPSProc)(hPrinter,
                                                      pUIInfo,
                                                      pPpdData,
                                                      NULL,
                                                      NULL,
                                                      pszFeatureKeyword,
                                                      NULL,
                                                      pCurrentOut,
                                                      cbRemain,
                                                      &cbPSFOptionsSize,
                                                      PSFPROC_ENUMOPTION_MODE);

                        if (bResult)
                        {
                            pCurrentOut += cbPSFOptionsSize;
                        }
                        else
                        {
                            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                            {
                                ERR(("HEnumFeaturesOrOptions: enum options failed for %s\n", pszFeatureKeyword));
                                return E_FAIL;
                            }
                        }

                        cbRemain -= cbPSFOptionsSize;
                        cbNeeded += cbPSFOptionsSize;
                    }
                    else
                    {
                        RIP(("HEnumFeaturesOrOptions: %%-feature handle is NULL for %s\n", pszFeatureKeyword));
                        return E_FAIL;
                    }
                }

                break;
            }

            pEntry++;
        }

        if (pEntry->pszPSFeatureName == NULL)
        {
            ERR(("HEnumFeaturesOrOptions: unrecognized feature %s\n", pszFeatureKeyword));
            return E_INVALIDARG;
        }

        cPPDFeaturesOrOptions = 0;
    }

    for (cIndex = 0; cIndex < cPPDFeaturesOrOptions; cIndex++)
    {
        //
        // Now enumerate PPD features/options.
        //

        PSTR  pszKeyword;
        DWORD cbKeySize;

        if (bEnumFeatures)
        {
            pszKeyword = OFFSET_TO_POINTER(pInfoHeader, pFeature->loKeywordName);
        }
        else
        {
            pszKeyword = OFFSET_TO_POINTER(pInfoHeader, pOption->loKeywordName);
        }

        if (pszKeyword == NULL)
        {
            ASSERT(pszKeyword != NULL);
            return E_FAIL;
        }

        //
        // count in the NUL character between feature/option keywords
        //

        cbKeySize = strlen(pszKeyword) + 1;

        if (pCurrentOut && cbRemain >= (INT)cbKeySize)
        {
            CopyMemory(pCurrentOut, pszKeyword, cbKeySize);
            pCurrentOut += cbKeySize;
        }

        cbRemain -= cbKeySize;
        cbNeeded += cbKeySize;

        if (bEnumFeatures)
        {
            pFeature++;
        }
        else
        {
            pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
        }
    }

    //
    // remember the last NUL terminator for the MULTI_SZ output string
    //

    cbRemain--;
    cbNeeded++;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCurrentOut || cbRemain < 0)
    {
        return E_OUTOFMEMORY;
    }

    *pCurrentOut = NUL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ttformat.h ===
/*
 *    Adobe Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    TTformat.h -defines data structure to access TTF and TTC
 *
 *
 * $Header:
*/

#ifndef _H_TTFORMAT
#define _H_TTFORMAT 
/*
 * Macros for accessing little-endian data
 */
#ifdef MAC_ENV

#define MOTOROLALONG(a)  a
#define MOTOROLAINT(a)   a
#define MOTOROLASLONG(a) a
#define MOTOROLASINT(a)  a

#else /* Windows */

/*
 * NOTE: These must be used with valid variables or memory addresses.
 * No constants are allowed!
 */
#define MOTOROLALONG(a)     (unsigned long)(((unsigned long)*((unsigned char *)&a) << 24) \
                             + ((unsigned long)*(((unsigned char *)&a) + 1) << 16) \
                             + ((unsigned long)*(((unsigned char *)&a) + 2) << 8)  \
                             + ((unsigned long)*(((unsigned char *)&a) + 3)))

#define MOTOROLAINT(a)      (unsigned short)(((unsigned short)*((unsigned char *)&a) << 8) \
                             + (unsigned short)*(((unsigned char *)&a) + 1))

#define MOTOROLASLONG(a)    ((signed long)MOTOROLALONG(a))

#define MOTOROLASINT(a)     ((signed short)MOTOROLAINT(a))

#endif / * Windows */

/*
 * General definitions for TrueType
 */

/*
 * TrueType font table names
 */
#define CFF_TABLE   (*(unsigned long*)"CFF ")
#define GSUB_TABLE  (*(unsigned long*)"GSUB")
#define OS2_TABLE   (*(unsigned long*)"OS/2")
#define CMAP_TABLE  (*(unsigned long*)"cmap")
#define GLYF_TABLE  (*(unsigned long*)"glyf")
#define HEAD_TABLE  (*(unsigned long*)"head")
#define HHEA_TABLE  (*(unsigned long*)"hhea")
#define LOCA_TABLE  (*(unsigned long*)"loca")
#define MAXP_TABLE  (*(unsigned long*)"maxp")
#define MORT_TABLE  (*(unsigned long*)"mort")
#define NAME_TABLE  (*(unsigned long*)"name")
#define POST_TABLE  (*(unsigned long*)"post")
#define TTCF_TABLE  (*(unsigned long*)"ttcf")
#define VHEA_TABLE  (*(unsigned long*)"vhea")
#define VMTX_TABLE  (*(unsigned long*)"vmtx")
#define CVT_TABLE   (*(unsigned long*)"cvt ")
#define FPGM_TABLE  (*(unsigned long*)"fpgm")
#define HMTX_TABLE    (*(unsigned long*)"hmtx")
#define PREP_TABLE    (*(unsigned long*)"prep")



//Begin Constants to read NAME Table
#define TYPE42NAME_PS             6
#define TYPE42NAME_MENU           1

#define TYPE42PLATFORM_WINDOWS    3
#define PLATFORM_APPLE              1

#define TYPE42ENCODING_UGL        4
#define TYPE42ENCODING_NONUGL     0
#define TYPE42ENCODING_CONTINUOUS 0
#define WINDOWS_UNICODE_ENCODING    1
#define APPLE_ROMAN_ENCODING        0

#define WINDOWS_LANG_ENGLISH        0x0409
#define APPLE_LANG_ENGLISH          0
//End Constants to read NAME Table


typedef struct tagTTCFHEADER {
    unsigned long ulTTCTag;   // "ttcf" tag
    unsigned long version;    // This is actually FIXED32 - see TTC doc
    unsigned long cDirectory; // num of directories in this TTC File
} TTCFHEADER;

typedef struct tagNAMEHEADER
{
  unsigned short formatSelector;
  unsigned short recordNumber;
  unsigned short stringOffsets;
} NAMEHEADER;

typedef struct tagNAMERECORD {
    unsigned short platformID;
    unsigned short encodingID;
    unsigned short languageID;
    unsigned short nameID;
    unsigned short length;
    unsigned short offset;
} NAMERECORD;


typedef struct {
    unsigned long  version;
    unsigned short numTables;
    unsigned short searchRange;
    unsigned short entrySelector;
    unsigned short rangeshift;
} TableDirectoryStruct;


typedef struct tagTableEntryStruct {
    unsigned long tag;
    unsigned long checkSum;
    unsigned long offset;
    unsigned long length;
} TableEntryStruct;


#define MACSTYLE_BOLD_PRESENT 0x01
#define MACSTYLE_ITALIC_PRESENT 0x02

#endif //_H_TTFORMAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\parsett.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    ParseTT.h - Parse a TTF file, "cmap", "vhtx", ...
 *
 *
 * $Header:
 */

#ifndef _H_PARSETT
#define _H_PARSETT

/*===============================================================================*
 * Include files used by this interface                                                                                                               *
 *===============================================================================*/
 // may defs are there in UFOt42.H - don't want to repeat here
#include "UFOT42.h"


/*===============================================================================*
 * Theory of Operation                                                                                                                                  *
 *===============================================================================*/
/*
   This file defines a functions to parse TTF file's tables - "cmap", "vhtx", ...
*/

// Here are the identifiers used with the interface routines defined in ParseTT.c.

// IDs used with GetGlyphIDEx:
#define GGIEX_HINT_INIT         0
#define GGIEX_HINT_GET          1
#define GGIEX_HINT_INIT_AND_GET 2

// Here are the interface routines defined in ParseTT.c.

unsigned long
GetGlyphID(
    UFOStruct       *pUFO,
    long            unicode,
    long            localcode
);

unsigned long
GetGlyphIDEx(
    UFOStruct       *pUFO,
    long            unicode,
    long            localcode,
    short           *pSubTable,
    unsigned long   *pOffset,
    int             hint
);

#if 0
//
// Replaced to the #else clause to fix #277035 and #277063.
// Not removed in case when we need this back for different platforms.
//

UFLErrCode
GetCharWidthFromTTF(
    UFOStruct       *pUFO,
    unsigned short  gi,
    long            *pWidth,
    long            *pEm,
    long            *pAscent,
    UFLBool         *bUseDef,
    UFLBool         bGetDefault
);

#else

UFLErrCode
GetMetrics2FromTTF(
    UFOStruct       *pUFO,
    unsigned short  gi,
    long            *pem,
    long            *pw1y,
    long            *pvx,
    long            *pvy,
    long            *ptsb,
    UFLBool         *bUseDef,
    UFLBool         bGetDefault,
    long            *pvasc
    );

#endif

unsigned long
GetNumGlyphs(
    UFOStruct       *pUFO
);

long
GetOS2FSType(
    UFOStruct       *pUFO
);

UFLBool
BIsTTCFont(
    unsigned long ulTag
);

unsigned short
GetFontIndexInTTC(
    UFOStruct        *pUFO
);

unsigned long
GetOffsetToTableDirInTTC(
    UFOStruct        *pUFO,
    unsigned short   fontIndex
);



char *
GetGlyphName(
    UFOStruct       *pUFO,
    unsigned long   lgi,
    char            *pszHint,
    UFLBool         *bGoodName      // GoodName
);

UFLBool
BHasGoodPostTable(
    UFOStruct           *pUFO
);

short int
CreateXUIDArray(
    UFOStruct       *pUFO,
    unsigned long   *pXuid
);

#endif // _H_PARSETT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflerr.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLErr.h -- List of UFL errors
 *
 *
 * $Header:
 */

#ifndef _H_UFLErr
#define _H_UFLErr

typedef enum  {
    kNoErr = 0,

    /* Beginning of the known error codes */

    kErrInvalidArg,
    kErrInvalidHandle,
    kErrInvalidFontType,
    kErrInvalidState,
    kErrInvalidParam,
    kErrOutOfMemory,
    kErrBadTable,
    kErrCreateFontHeader,
    kErrAddCharString,
    kErrReadFile,
    kErrGetGlyphOutline,
    kErrOutput,
    kErrDownloadProcset,
    kErrGetFontData,
    kErrProcessCFF,
    kErrOSFunctionFailed,
    kErrOutOfBoundary,
    kErrXCFCall,

    /* This is the last known error code. Add any before this. */
    kErrNotImplement = 0x1000,

    /* End of the known error codes */

    /* This is the last resort error code. Don't add any after this. */
    kErrUnknown
} UFLErrors;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflmath.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLMath
 *
 *
 * $Header:
 */

#ifndef _H_UFLMath
#define _H_UFLMath

 /*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/

#include "UFLCnfig.h"
#ifndef _H_UFLTypes
#include "UFLTypes.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Floating point arithmathics */
#ifdef WIN32KERNEL

    typedef FLOATOBJ UFLFLOATOBJ;
    typedef PFLOATOBJ PUFLFLOATOBJ;

    #define   UFLFLOATOBJ_SetFloat(pf,f)       FLOATOBJ_SetFloat((pf),(f))
    #define   UFLFLOATOBJ_SetLong(pf,l)       FLOATOBJ_SetLong((pf),(l))

    #define   UFLFLOATOBJ_GetFloat(pf)         FLOATOBJ_GetFloat((pf))
    #define   UFLFLOATOBJ_GetLong(pf)         FLOATOBJ_GetLong((pf))

    #define   UFLFLOATOBJ_AddFloat(pf,f)       FLOATOBJ_AddFloat((pf),(f))
    #define   UFLFLOATOBJ_AddLong(pf,l)       FLOATOBJ_AddLong((pf),(l))
    #define   UFLFLOATOBJ_Add(pf,pf1)          FLOATOBJ_Add((pf),(pf1))

    #define   UFLFLOATOBJ_SubFloat(pf,f)       FLOATOBJ_SubFloat((pf),(f))
    #define   UFLFLOATOBJ_SubLong(pf,l)        FLOATOBJ_SubLong((pf),(l))
    #define   UFLFLOATOBJ_Sub(pf,pf1)           FLOATOBJ_Sub((pf),(pf1))

    #define   UFLFLOATOBJ_MulFloat(pf,f)       FLOATOBJ_MulFloat((pf),(f))
    #define   UFLFLOATOBJ_MulLong(pf,l)        FLOATOBJ_MulLong((pf),(l))
    #define   UFLFLOATOBJ_Mul(pf,pf1)          FLOATOBJ_Mul((pf),(pf1))

    #define   UFLFLOATOBJ_DivFloat(pf,f)       FLOATOBJ_DivFloat((pf),(f))
    #define   UFLFLOATOBJ_DivLong(pf,l)        FLOATOBJ_DivLong((pf),(l))
    #define   UFLFLOATOBJ_Div(pf,pf1)          FLOATOBJ_Div((pf),(pf1))

    #define   UFLFLOATOBJ_Neg(pf)              FLOATOBJ_Neg((pf))

    #define   UFLFLOATOBJ_EqualLong(pf,l)          FLOATOBJ_EqualLong((pf),(l))
    #define   UFLFLOATOBJ_GreaterThanLong(pf,l)    FLOATOBJ_GreaterThanLong((pf),(l))
    #define   UFLFLOATOBJ_LessThanLong(pf,l)       FLOATOBJ_LessThanLong((pf),(l))

    #define   UFLFLOATOBJ_Equal(pf,pf1)            FLOATOBJ_Equal((pf),(pf1))
    #define   UFLFLOATOBJ_GreaterThan(pf,pf1)      FLOATOBJ_GreaterThan((pf),(pf1))
    #define   UFLFLOATOBJ_LessThan(pf,pf1)         FLOATOBJ_LessThan((pf),(pf1))

#else

    // any platform that has support for floats in the kernel

    typedef float UFLFLOATOBJ;
    typedef float *PUFLFLOATOBJ;

    #define   UFLFLOATOBJ_SetFloat(pf,f)       {*(pf) = (float)(f);           }
    #define   UFLFLOATOBJ_SetLong(pf,l)        {*(pf) = (float)(l);    }

    #define   UFLFLOATOBJ_GetFloat(pf)         *((unsigned long *)pf)
    #define   UFLFLOATOBJ_GetLong(pf)          (long)*(pf)

    #define   UFLFLOATOBJ_AddFloat(pf,f)       {*(pf) += (float)(f);            }
    #define   UFLFLOATOBJ_AddLong(pf,l)        {*(pf) += (long)(l);    }
    #define   UFLFLOATOBJ_Add(pf,pf1)          {*(pf) += *(pf1);       }

    #define   UFLFLOATOBJ_SubFloat(pf,f)       {*(pf) -= (float)(f);            }
    #define   UFLFLOATOBJ_SubLong(pf,l)        {*(pf) -= (long)(l);    }
    #define   UFLFLOATOBJ_Sub(pf,pf1)          {*(pf) -= *(pf1);       }

    #define   UFLFLOATOBJ_MulFloat(pf,f)       {*(pf) *= (float)(f);     }
    #define   UFLFLOATOBJ_MulLong(pf,l)        {*(pf) *= (long)(l);    }
    #define   UFLFLOATOBJ_Mul(pf,pf1)          {*(pf) *= *(pf1);       }

    #define   UFLFLOATOBJ_DivFloat(pf,f)       {*(pf) /= (float)(f);            }
    #define   UFLFLOATOBJ_DivLong(pf,l)        {*(pf) /= (long)(l);    }
    #define   UFLFLOATOBJ_Div(pf,pf1)          {*(pf) /= *(pf1);       }

    #define   UFLFLOATOBJ_Neg(pf)              {*(pf) = -*(pf);        }

    #define   UFLFLOATOBJ_EqualLong(pf,l)          (*(pf) == (float)(l))
    #define   UFLFLOATOBJ_GreaterThanLong(pf,l)    (*(pf) >  (float)(l))
    #define   UFLFLOATOBJ_LessThanLong(pf,l)       (*(pf) <  (float)(l))

    #define   UFLFLOATOBJ_Equal(pf,pf1)            (*(pf) == *(pf1))
    #define   UFLFLOATOBJ_GreaterThan(pf,pf1)      (*(pf) >  *(pf1))
    #define   UFLFLOATOBJ_LessThan(pf,pf1)         (*(pf) <  *(pf1))

#endif /* WIN32KERNEL */

    /* UFLFixed macros */
#define UFLFixedMant( x )         ( ((UFLSepFixed*)&x)->mant )
#define UFLFixedFraction( x )     ( ((UFLSepFixed*)&x)->frac )

#define UFLTruncFixedToShort( x )      (short)( (x) >> 16 )
#define UFLRoundFixedToShort( x )     (short)( ((x) + 0x08000) >> 16 )
#define UFLCeilingFixedToShort( x )        (short)( ((x) + 0x0ffff) >> 16 )
#define UFLShortToFixed( x )               ( ((UFLFixed)(x)) << 16 )
#define UFLTruncFixed( x )                  ( (x) & 0xffff0000 )

#define UFLFixedOne                    (UFLFixed)0x00010000

#define UFLRoundFixed( x )              (((x) + 0x08000) & 0xffff0000)

UFLFixed UFLFltToFix(float x);
UFLFixed UFLFixedDiv( UFLFixed a, UFLFixed b );
UFLFixed UFLFixedMul( UFLFixed a, UFLFixed b );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflmem.h ===
/*
 *    Adobe Graphics Manager
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLMem -- UFL Memory APIs.
 *
 *
 * $Header:
 */

#ifndef _H_UFLMem
#define _H_UFLMem

/*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/
#include "UFLCnfig.h"
#include "UFLTypes.h"
#include "UFLClien.h"

/*===============================================================================*
 * Theory of Operation                                                           *
 *===============================================================================*/

/*
 *        These are the memory allocation, deletion, etc... routines used by UFL.
 *        All memory blocks are allocated at the given size plus the size of 1
 *        unsigned long.  The current size of the block is then stored in the first
 *        unsigned long in the block.  The address of the block plus the first unsigned long
 *        is returned to the caller.
*/


#ifdef __cplusplus
extern "C" {
#endif

/* The Metrowerks 68k Mac compiler expects functions to return
   pointers in A0 instead of D0.  This pragma tells it they are in D0.
*/
#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_D0
#endif

//
// NOTE: Memory allocated by UFLNewPtr is zero-initialized.
//

#ifdef KERNEL_MODE

#include "lib.h"

PVOID UFLEXPORT
KMNewPtr(
    PVOID   p,
    ULONG   ulSize
    );

VOID UFLEXPORT
KMDeletePtr(
    PVOID   p
    );


#define UFLNewPtr(mem, size)    KMNewPtr(MemAllocZ(sizeof(ULONG_PTR) + (size)), (size))
#define UFLDeletePtr(mem, ptr)  KMDeletePtr(ptr)
#define UFLmemcpy(mem, dest, source, size)     CopyMemory(dest, source, size)

#else // !KERNEL_MODE

void *UFLEXPORT UFLNewPtr(
    const UFLMemObj *mem,
    unsigned long   size
    );

void UFLEXPORT UFLDeletePtr(
    const UFLMemObj *mem,
    void            *ptr
    );

void UFLEXPORT UFLmemcpy(
    const UFLMemObj *mem,
    void *destination,
    void *source,
    unsigned long size
    );

#endif // !KERNEL_MODE

void UFLEXPORT UFLmemset(
    const UFLMemObj *mem,
    void *destination,
    unsigned int value,
    unsigned long size
    );

unsigned long UFLMemSize(
    void *ptr
    );

UFLBool UFLEnlargePtr(
    const UFLMemObj *mem,
    void            **ptrAddr,
    unsigned long   newSize,
    UFLBool         bCopy
    );

/* undo the Metrowerks pragma.    */
#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_A0
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflpriv.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLPriv.h -- UFL Private data structure
 *
 *
 * $Header:
 */

#ifndef _H_Priv
#define _H_Priv

/*============================================================================*
 * Include files used by this interface                                       *
 *============================================================================*/

#include "UFLCnfig.h"
#include "UFLTypes.h"
#include "UFLStrm.h"

#ifdef __cplusplus
extern "C" {
#endif

/* The Metrowerks 68k Mac compiler expects functions to return pointers in A0
 * instead of D0. This pragma tells it they are in D0.
 */
#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_D0
#endif


/*============================================================================*
 * Constants                                                                  *
 *============================================================================*/

#define kLineEnd     '\n'
#define kWinLineEnd  '\r'        /* Windows only */

/*============================================================================*
 * UFLStruct                                                                  *
 * The UFLStruct is created by UFLInit. It will contain all of the            *
 * information that is needed for all fonts. This includes a memory object,   *
 * callback procedures for the client to provide needed functionality, and    *
 * printer device characteristics.                                            *
 *                                                                            *
 *============================================================================*/

typedef struct {
    UFLBool         bDLGlyphTracking;
    UFLMemObj       mem;
    UFLFontProcs    fontProcs;
    UFLOutputDevice outDev;
    UFLHANDLE       hOut;
} UFLStruct;


#define ISLEVEL1(pUFObj)     (pUFObj->pUFL->outDev.lPSLevel == kPSLevel1)
#define GETPSVERSION(pUFObj) (pUFObj->pUFL->outDev.lPSVersion)
#define GETMAXGLYPHS(pUFObj) (ISLEVEL1(pUFObj) ? 256 : 128)

#define GETTTFONTDATA(pUFO,ulTable,cbOffset,pvBuffer,cbData, index) \
    ((pUFO)->pUFL->fontProcs.pfGetTTFontData((pUFO)->hClientData, \
                                                (ulTable), (cbOffset), \
                                                (pvBuffer), (cbData), (index)))

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflps.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLFPS.h  --  PostScript Procset
 *
 *
 * $Header:
 */

#ifndef _H_UFLFPS
#define _H_UFLFPS

enum {
    kT1Header,
    kT3Header,
    kCFFHeader,
    kT42Header,
    kCMap_FF,
    kCMap_90msp
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflclien.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLClient  --  Universal Font Library Client Callback APIs
 *
 *
 * $Header:
 */

#ifndef _H_UFLClient
#define _H_UFLClient

/*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/
#include "UFLTypes.h"

/*===============================================================================*
 * Theory of Operation                                                           *
 *===============================================================================*/

/*

  This file specifies the font callback functions that a client needs to provided in order for it to use UFL.

*/

#ifdef __cplusplus
extern "C" {
#endif

/*===============================================================================*
 * Constants                                                                     *
 *===============================================================================*/
/* Type 1 outline constants */
/* returns from NextOutlineSegment */
enum    {
    kUFLOutlineIterDone,
    kUFLOutlineIterBeginGlyph,
    kUFLOutlineIterMoveTo,
    kUFLOutlineIterLineTo,
    kUFLOutlineIterCurveTo,
    kUFLOutlineIterClose,
    kUFLOutlineIterEndGlyph,
    kUFLOutlineIterErr
};

//
// Extra information for support of vertical propoertional font
// Fix #287084, #309104, and #309482
//
#define kUFLVPFPlatformID9x      0
#define kUFLVPFPlatformIDNT      1
#define kUFLVPFPlatformID2K      2

#define kUFLVPFSkewElement2      2
#define kUFLVPFSkewElement3      3

#define kUFLVPFTangent12         ".21255656"
#define kUFLVPFTangent18         ".3249197"
#define kUFLVPFTangent20         ".36397023"

/*===========================================================================
GetGlyphBmp -- Retrieves a bitmap for the glyph specified by the given
               character and font.  The given font is specified within UFL's
               client private data handle.
    handle (in)    -- Handle of client private data.
    glyphID (in)   -- Specifies the character value of the glyph to retrieve.
    bmp (out) -- Points to buffer pointer that has the bitmap for the glyph.
    xWidth, yWidth (out) -- Points to the buffer that receives the character width.
    bbox (out) -- Points to 4 UFLFixed that received the glyph bbox.

  If the function succeeds, it returns 1, otherwise, it return 0.
==============================================================================*/
typedef char (UFLCALLBACK *UFLGetGlyphBmp)(
    UFLHANDLE  handle,
    UFLGlyphID glyphID,
    UFLGlyphMap **bmp,
    UFLFixed    *xWidth,
    UFLFixed    *yWidth,
    UFLFixed    *bbox
    );

/*===========================================================================
DeleteGlyphBmp -- Delete the glyph bitmap data space.
    handle (in)    -- Handle of client private data.

==============================================================================*/

typedef void (UFLCALLBACK *UFLDeleteGlyphBmp)(
    UFLHANDLE handle
    );

/*==============================================================================
CreateGlyphOutlineIter -- Create an OutlineIter for the glyph specified by the given
               character and font.  The given font is specified within UFL's
               client private data handle. To get an outline of a glyph, UFL first creates
               an OutlineIter with CreateOutlineIter.    If this succeeds (return != 0) UFL
               then proceed to call NextOutlineSegment.  This will step through the
               line and curve segments in the character outlines for the given strike
               array in the given font. See more info in CoolType.h.

    handle (in)    -- Handle of client private data.
    glyphID (in)   -- Specifies the character value of the glyph to retrieve.
    xWidth, yWidth, xSB, ySB (out) -- sbw values

If the function succeeds, it returns 1, otherwise, it returns 0.

==============================================================================*/

typedef char (UFLCALLBACK *UFLCreateGlyphOutlineIter)(
    UFLHANDLE  handle,
    UFLGlyphID glyphID,
    UFLFixed   *xWidth,
    UFLFixed   *yWidth,
    UFLFixed   *xSB,
    UFLFixed   *ySB,
    UFLBool    *bYAxisNegative //added to allow client to specify glyph orientation
    );

/*==============================================================================
NextOutlineSegment -- Retrieve the next outline segment
    handle (in)    -- Handle of client private data.
    p0, p1, p2 (out) - Points of the outline segment.

    return -- Outline constant defined above.
==============================================================================*/

typedef long (UFLCALLBACK *UFLNextOutlineSegment)(
    UFLHANDLE       handle,
    UFLFixedPoint   *p0,
    UFLFixedPoint   *p1,
    UFLFixedPoint   *p2
    );

/*==============================================================================
DeleteGlyphOutlineIter -- Terminate the glyph OutlineIter process.
    handle (in)    -- Handle of client private data.

==============================================================================*/

typedef void (UFLCALLBACK* UFLDeleteGlyphOutlineIter)(
    UFLHANDLE handle
    );



/*===========================================================================
GetTTFontData -- Get the SFNT table of a TT font.
    handle (in)    --  Handle of client private data.
    ulTable (in)   --  Specifies the name of a font metric table from which the
                       font data is to be retrieved. This parameter can identify
                       one of the metric tables documented in the TrueType.  If
                       this parameter is NULL, the information is retrieved
                       starting at the beginning of the font file.
    cbOffset (in)  --  Specifies the offset from the beginning of the font metric
                       table to the location where the function should begin
                       retrieving information. If this parameter is zero, the
                       information is retrieved starting at the beginning of the
                       table specified by the table parameter. If this value is
                       greater than or equal to the size of the table, an error
                       occurs.
    pvBuffer (in/out) -- Points to a buffer to receive the font information. If
                       this parameter is NULL, the function returns the size of
                       the buffer required for the font data.
    cbData (in)    --  Specifies the length, in bytes, of the information to be
                       retrieved. If this parameter is zero, the function returns
                       the size of the data specified in the table parameter.
    index (in)     --  The FontIndex number for a TTC file. This index is ignored
                       when ulTable is 0 (reading from start of file, not font)

     returns -- If pvBuffer is NULL, the function returns the size of
                the buffer required for the font data.  If the table does
                not exist, the function returns 0.
==============================================================================*/

typedef unsigned long (UFLCALLBACK *UFLGetTTFontData)(
    UFLHANDLE     handle,       /* Handle of client's private data */
    unsigned long ulTable,    /* metric table to query */
    unsigned long cbOffset,     /* offset into table being queried */
    void          *pvBuffer,    /* address of buffer for returned data  */
    unsigned long cbData,       /* length of data to query */
    unsigned short index        /* Font Index in a TTC file */
    );


/*===========================================================================
UFLGetCIDMap -- Get the CIDMap for building a CIDFont with non-ientity CIDMap
    handle (in)       --  Handle of client private data.
    pCIDMap (in/out) --  Points to a buffer to receive the CIDMap data - It must be a
                       well formatted PostScript string in ASCII format
                       (e.g., "200 string", (12345), <01020a0b>,..)
                       If this parameter is NULL, the function returns the size of
                       the buffer required .
    cbData (in)       --  Specifies the length, in bytes, of the information to be
                       retrieved. If this parameter is zero, the function returns
                       the size of the CIDMap

    returns -- If pCIDMap is NULL, the function returns the size of
               the buffer required for CIDMap data. If the client has no
               CIDMap, the function returns 0.
==============================================================================*/

typedef unsigned long (UFLCALLBACK *UFLGetCIDMap)(
    UFLHANDLE       handle,       /* Handle of client's private data */
    char            *pCIDMap,     /* address of buffer for returned data  */
    unsigned long   cbData        /* length of buffer pCIDMap in bytes */
    );


/*===========================================================================
UFLGetGlyphID -- Get the GlyphID from local-code or unicode infomation.
    handle  (in)       --  Handle of client private (font) data.
    unicode (in)       --  Unicode to look for
    localcode (in)     --  code point in the current font's language
    returns -- If the Glyph Index in this font
==============================================================================*/

typedef unsigned long (UFLCALLBACK *UFLGetGlyphID)(
    UFLHANDLE       handle,       /* Handle of client's private data */
    unsigned short  unicode,      /* unicode value */
    unsigned short  localcode     /* code value in current font's language */
    );


/*==============================================================================
UFLGetRotatedGIDs -- Get the rotated GlyphIDs
    handle (in)        --  Handle of client private (font) data.
    pGIDs (in/out)     --  Points to a buffer to receive the rotated (or
                           unrotated, if bFlag is nil) glyph IDs.
                           If null, returns the number of rotated glyph IDs only.
    nCount (in)        --  Number of GIDs stored to the array pointed to by
                           pGIDs (thus, valid only when pGIDs is valid).
    bFlag (in)         --  nil if unrotated (in TrueType definition) glyph IDs
                           are expected.
    returns            --  Number of rotated glyph IDs. -1 if failed.
================================================================================*/

typedef long (UFLCALLBACK *UFLGetRotatedGIDs)(
    UFLHANDLE       handle,       /* Handle of client's private data */
    unsigned long   *pGIDs,       /* address of buffer for returned data */
    long            nCount,       /* number of GIDs stored to pGIDs */
    UFLBool         bFlag         /* nil or non-nil */
    );


/*==============================================================================
UFLGetRotatedGSUBs -- Get the rotated GlyphID's substitutions
    handle (in)     -- Handle of client private (font) data.
    pGIDs (in/out)  -- Pointer to a buffer to recieve the substitution glyph IDs.
                       Horizotal glyph IDs are already stored and its number is
                       nCount. It's the caller's responsibility to guarantee that
                       the buffer is big enough to store both H and V glyphs.
    nCount (in)     -- Number of horizontal GIDs stored from the beginning of the
                       buffer pointed to by pGIDs.
    returns         -- Number of the substitution GIDs found.
================================================================================*/

typedef long (UFLCALLBACK *UFLGetRotatedGSUBs)(
    UFLHANDLE       handle,       /* Handle of client's private data */
    unsigned long   *pGIDs,       /* address of buffer for returned data */
    long            nCount        /* number of GIDs stored to pGIDs */
    );


/*==============================================================================
UFLAddFontInfo -- Adds more key/value pairs to FontInfo dict
    handle (in)   --  Handle of client private (font) data.
    returns       --  A pointer to a PS string composed of key/value pairs
                      which will be added to the FontInfo dictionary.
================================================================================*/

typedef unsigned long * (UFLCALLBACK *UFLAddFontInfo)(
    UFLHANDLE       handle,       /* Handle of client's private data */
    char            *buffer,
    int             bufLen
    );


/*==============================================================================
UFLHostFontHandler -- HostFont request hander
================================================================================*/

typedef char (UFLCALLBACK *UFLHostFontHandler)(
    unsigned int    req,            /* HostFont request number      */
    UFLHANDLE       hHostFont,      /* hostfontdata handle          */
    void*           pvObj,          /* pointer to an object         */
    unsigned long*  pvObjSize,      /* size of object               */
    UFLHANDLE       hClientData,    /* Client's private data handle */
    DWORD           dwHint          /* a hint value                 */
    );


/******************************************
    Structure To Hold Callback Functions
*******************************************/
/* UFLFontProcs - contains all the client font information callback functions */
typedef struct _t_UFLFontProcs {
    /* TrueType font downloades as T3 support functions */
    UFLGetGlyphBmp      pfGetGlyphBmp;
    UFLDeleteGlyphBmp   pfDeleteGlyphBmp;

    /* TrueType font downloaded as T1 support functions */
    UFLCreateGlyphOutlineIter  pfCreateGlyphOutlineIter;
    UFLNextOutlineSegment      pfNextOutlineSegment;
    UFLDeleteGlyphOutlineIter  pfDeleteGlyphOutlineIter;

    /* TrueType font downloaded as T42 support function */
    UFLGetTTFontData    pfGetTTFontData;
    UFLGetCIDMap        pfGetCIDMap;
    UFLGetGlyphID       pfGetGlyphID;
    UFLGetRotatedGIDs   pfGetRotatedGIDs;
    UFLGetRotatedGSUBs  pfGetRotatedGSUBs;
    UFLAddFontInfo      pfAddFontInfo;

    /* HostFont support */
    UFLHostFontHandler  pfHostFontUFLHandler;
} UFLFontProcs;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufl.h ===
/*
 *    Adobe Universal Font Libary
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFL -- UFL APIs.
 *
 *
 *
 * $Header:
 */

#ifndef _H_UFL
#define _H_UFL

/*=============================================================================*
 * Include files used by this interface                                        *
 *=============================================================================*/
#include "UFLTypes.h"
#include "UFLClien.h"

/*=============================================================================*

                            Theory of Operation

Universal Font Library allows its client to download a font incrementally or a
font subset. It has the following functionalities.

1. Depending on the downloading type, UFL requests its client to download a
   procset in order for it to create a font.

2. The type of font downloading that UFL currently supports are:

Font Type      Method       DownLoad Type                Comment
=============================================================================
TrueType       Subset       Unhinted Outline Font T1.
TrueType       Subset       Hinted Bitmap Font T3.
TrueType       Subset       Type 42                      Only works on 2013+.
TrueType       Subset       CID
TrueTypeOpen   Subset       Type 1                       Use XCF
TrueTypeOpen   Subset       Type 2                       Use XCF
TrueTypeOpen   Subset       CID                          Use XCF

3. UFL only supports glyph index string.

4. For CFF font, it determines SEAC characters and downloads required
   characters.

5. It keeps track of glyphs that have been downloaded in a font.

6. Provides VM usage of a downloaded font to the client.

7. UFL does not know how to rendering a font.  If the client wishes to download
   a TT font as a T1 or T3 font, then the client needs to provide callback
   functions that UFL uses to get the outline or bitmap of a character.


The following functions are not part of UFL.

1. Memory management: UFL does not check for VM, allocates VM usage, or takes
   care of save/restore level.  Instead, a client can request the amount of VM
   needed for an incremental download request. UFL also returns the amount of
   VM usage for the request.

2. Font managements: UFL does not keep track of the fonts that have been
   downloaded. Its client keeps this information so DSC %%IncludeFont and
   %%DocumentNeededFont should be generated by the client.

3. UFL does not do anything else with the base font that it has created: it
   does not flip to match the platform's x and y directions, it does not apply
   synthetic emboldening or obliquing, and it does not scale the font.


In order to use the UFL, the following sequences need to be performed.

1. Initialize the library by calling UFLInit().

2. Create a Universal Font Object (UFO) by calling UFLNewFont(). The UFO is an
   opaque object that does the real work in a font downloading process.

3. Download a base font (a font with only .notdef character) or a font subset
   by calling UFLDownloadIncr().

4. To add more CharStrings into an already downloaded font, a client would call
   the same UFLDownloadIncr().

5. Once a font is no longer needed, delete the font in the printer by calling
   UFLUndefineFont() and delete its UFO object by calling UFLDeleteFont().

6. Terminate the library by calling UFLCleanUp()

===============================================================================*/


/*=============================================================================*
 * Constants                                                                   *
 *=============================================================================*/

/* this string is shared among all T1/T3/T42 downloading */
extern const char *gnotdefArray;
extern const char *Notdef;
extern const char *Hyphen;
extern const char *Minus;
extern const char *SftHyphen;
extern const char *UFLSpace;
extern const char *Bullet;
extern const char *nilStr;


/*=============================================================================*
 * Scalar Types                                                                *
 *=============================================================================*/

#ifdef __cplusplus
extern "C" {
#endif


/*
 * The Metrowerks 68k Mac compiler expects functions to return pointers in A0
 * instead of D0. This pragma tells it they are in D0.
 */
#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_D0
#endif


/*
 * If the fontIndex in UFLFontDataInfo is set to Unknown, UFL will try to find
 * it in TTC In the later case, client shoudl provide either UniqueNameA or
 * UniqueNameW.
 */
#define  FONTINDEX_UNKNOWN      0xFFFF

typedef struct _t_UFLXUID {
    unsigned long    sSize;     /* Number of longs in the XUID array */
    unsigned long    *pXUID;
} UFLXUID;


/*
 * FontData info. If the font is a TT font and we want to access some data
 * from the TT file, we use this structure - it is common for T1/T3/T42 - it's
 * part of info provided in the UFLRequest structure by client.
 */
typedef struct _t_UFLFontDataInfo {
    unsigned long       maxGlyphs;         /* # of glyphs in this PS font to create */

    /* This may be initialized by UFL even though the client may provide it. */
    unsigned long       cNumGlyphs;        /* # of glyphs in this TT font file: we may use only part of them. */

    /* stuff to handle TTC - provided by client */
    char                *pUniqueNameA;     /* an ANSI string to uniquely identify this font in a TTC */
    unsigned short      *pUniqueNameW;     /* a Unicode string to uniquely identify this font */

    /* stuff to handle TTC - UFL may initialize this using UniqueName provided by client. */
    unsigned long       offsetToTableDir ; /* offset to the TableDirectory - non-zero in TTC files */

    UFLXUID             xuid;              /* number of longs in the XUID array and the XUID array */
    unsigned short      fontIndex ;        /* font index in a TTC file */
    char                reserved[2];       /* make this structure's size as multiple of DWORD */
} UFLFontDataInfo;


typedef struct tagUFLCMapInfo {
    char        CMapName[32];    /* Our names are limited to 30 chars. */
    short int   CMapVersion;     /* This is an integer. See CMAP doc. */
    short int   CMapType;

    char        Registry[20];    /* Ours are limited to 20 chars. */
    char        Ordering[20];    /* Ours are limited to 20 chars. */
    short int   Supplement;

    char        reserved[2];     /* make this structure's size as multiple of DWORD */
} UFLCMapInfo;


/*
 * UFL TT Font infos. If the font is a TT font downloaded as Type 42, then this
 * structure needs to be provided in the UFLRequest structure.
 */
typedef struct _t_UFLTTFontInfo {
    UFLFontDataInfo     fData;
    unsigned short int  bUseIdentityCMap;   /* If this is non-zero, CMap, CIDCount, BUpdateCIDMap are ignored. */
    UFLCMapInfo         CMap;               /* used only if bUseIdentityCMap is 0. */
    unsigned short int  CIDCount;           /* (max) number of glyphs */
    unsigned short int  bUpdateCIDMap;      /* initialize/update CIDMap when non-zero */
    char                CIDFontName[256];   /* used when the font is a FE CID font */
    char                reserved[2];        /* make this structure's size as multiple of DWORD */
} UFLTTFontInfo;


/*
 * UFLTTT1FontInfo structure. If the font is a TT font downloaded as type 1,
 * then this structure needs to  be provided in the UFLRequest structure.
 */
typedef struct _t_UFLTTT1FontInfo {
    UFLFontDataInfo     fData;
    UFLBool             bEExec;           /* To be used when download a TT as a type 1 font. */
    UFLFixedMatrix      matrix;           /* font matrix that the TT font is rendering */
    long                lNumNT4SymGlyphs; /* NT4 use only: number of symbol glyphs */
} UFLTTT1FontInfo;


/*
 * UFLTTT3FontInfo structure. If the font is a TT font downloaded as type 3,
 * then this structure needs to  be provided in the UFLRequest structure.
 */
typedef struct _t_UFLTTT3FontInfo {
    UFLFontDataInfo     fData;
    unsigned long       cbMaxGlyphs;      /* Size of the largest glyphs */
    UFLFixedMatrix      matrix;           /* Font matrix that the TT font is rendering. */
    UFLFixed            bbox[4];
    long                lNumNT4SymGlyphs; /* NT4 use only: number of symbol glyphs */
} UFLTTT3FontInfo;


/*===============================================================================*
 * UFL CFF Infos                                                                 *
 *===============================================================================*/

/* uniqueIDMethod options */
enum {
    kKeepUID,       /* Define UID with the one in the font. */
    kUndefineUID,   /* Don't define UID in the font */
    kUserID         /* Replace UID with the one in StreamerOpts */
};


/* Subroutine flattening options:  */
enum {
    kKeepSubrs,     /* Keep all subroutines intact */
    kFlattenSubrs   /* Flatten/unwind all the subroutines */
};

typedef struct _t_UFLCFFReadBuf {
    unsigned long cbBuf;
    unsigned char *pBuf;
} UFLCFFReadBuf;

typedef struct _t_UFLCFFFontInfo {
    unsigned long       uniqueID;
    UFLFontDataInfo     fData;                  /* need to use some of the data here intelligently */

    unsigned long       fontLength;             /* Size of 'CFF ' table */
    void PTR_PREFIX     **ppFontData;           /* pointer to 'CFF ' table pointer. Nil if read from the file. */

    unsigned short int  maxBlockSize;           /* max data size that client's stream output function can handle
                                                   at a time. XCF requires this info optionally. */

    unsigned short int  uniqueIDMethod:2,       /* UniqueID method */
                        subrFlatten:1,          /* Flatten subrs */
                        usePSName:1,            /* Use correct PostScript Name for the downloaded characters */
                        useSpecialEncoding:1,   /* Use special encoding */
                        escDownloadFace:1,      /* set when requested thru Esc(DOWNLOADFACE) */
                        type1:1;                /* set when the font is a Type 1 font. */

    char                baseName[256];          /* used to create a PS name with prefix */

    UFLCFFReadBuf       readBuf;                /* 'CFF ' table read buffer object: used if ppFontData is nil. */
} UFLCFFFontInfo;


/*
 * Extra information for support of vertical proportional font
 * Fix #287084, #309104, and #309482
 */
typedef struct _t_UFLVPFInfo {
    int             nPlatformID;                /* 0:9x 1:NT4 2:W2K                 */
    int             nSkewElement;               /* 2:9x 3:NT4/W2K                   */
    char*           pszTangentTheta;            /* tan(18deg):9x/NT4 tan(20deg):W2K */
} UFLVPFInfo;




typedef struct _t_UFLRequest {
    UFLDownloadType lDownloadFormat;            /* Client request download method.  */

    UFLHANDLE       hFontInfo;                  /* Special info based on Download font format. For example,
                                                   if the downloaded font is a true type font then this would
                                                   point to a UFLTTFontInfo data structure. */

    char            *pszFontName;               /* font name */

    UFLHANDLE       hData;                      /* Client's private data. When UFL calls the client's callback
                                                   routine, it returns this handle to the client. */

    short           subfontNumber;              /* subfont number of this font */

    long            useMyGlyphName;             /* If 1, use the glyph names passed in by client */
    char            *pszEncodeName;             /* Font encoding. If this field is NULL, then creat a font
                                                   with names UFL likes. */
    unsigned char   *pEncodeNameList;           /* Fix bug #274008 */
    unsigned short  *pwCommonEncode;
    unsigned short  *pwExtendEncode;
    unsigned char   *pMacGlyphNameList;         /* mac Glyph Names */

    UFLVPFInfo      vpfinfo;                    /* Fix bug #287084, #309104, and #309482 */
    UFLHANDLE       hHostFontData;              /* %hostfont% support */

    UFLBool         bPatchQXPCFFCID;            /* Fix bug #341904 */
} UFLRequest;



/*
 * A structure to pass information between Client and UFL for incremental
 * downloading.
 */
typedef struct _t_UFLGlyphsInfo {
    short int       sCount;           /* number of Glyphs in pGlyphIndices */
    UFLGlyphID      *pGlyphIndices;   /* list of Glyphs IDs */
    unsigned short  *pCharIndex;      /* corresponding Character-codes/indices in this font */
    unsigned char   **ppGlyphNames;   /* corresponding Glyphs Names */
    unsigned short  *pCode;           /* corresponding Unicode or Script-Code points */
    char            reserved[2];      /* make this structure's size as multiple of DWORD */
}UFLGlyphsInfo;


/*
 * Prefix and the font instance name generator macros using it. These prefix
 * are used when downloading an OpenType font (cheifly to tell Distiller its
 * real font name).
 */
#define CFFPREFIX   "ADBCFF+"

/* Fix for #507985: need to use different prefixes for H and V (9x only) */
#define CFFPREFIX_H "ADBCFA+"
#define CFFPREFIX_V "ADBCFB+"


#define CREATE_ADCFXX_FONTNAME(fmtfn, dest, cchDest, num, basename) \
    (fmtfn)((dest), (cchDest), "ADCF%c%c+%s", \
                        (char)((((num)&0x00F0)>>4)+'A'), \
                        (char)((((num)&0x000F)   )+'A'), \
                        (basename))

#define CREATE_ADXXXX_FONTNAME(fmtfn, dest, cchDest, num, basename) \
    (fmtfn)((dest), (cchDest), "AD%c%c%c%c+%s", \
                        (char)((((num)&0xF000)>>12)+'A'), \
                        (char)((((num)&0x0F00)>> 8)+'A'), \
                        (char)((((num)&0x00F0)>> 4)+'A'), \
                        (char)((((num)&0x000F)    )+'A'), \
                        (basename))


/*
 * %hostfont% support
 */
typedef enum
{
    HOSTFONT_UFLREQUEST_GET_NAME,
    HOSTFONT_UFLREQUEST_IS_ALLOWED,
    HOSTFONT_UFLREQUEST_SET_CURRENTNAME,
} HOSTFONT_UFLREQUEST;

/*
 * Special definition to work around %hostfont% RIP bug #388111
 * Change the value to 0 when the bug is fixed.
 */
#define HOSTFONT_REQUIRE_VMTX 1


/*=============================================================================
                                UFLInit

    Initialize UFL library. Typically, a client would call UFLInit at the
    beginning of a session.  It calls UFLTerminate to end a session.

    bDLGlyphTracking (in) -- TRUE if UFL keeps track of downloaded glyphs
    pMemObj (in)          -- points to UFLMemObj structure. UFL uses this
                             object to allocate and free memory.
    pFontProcs (in)       -- points to the data structure that contains the
                             font related callback functions.
    pStdProcs (in)        -- points to the data structure that contains the
                             standard library callback functions.
                             THIS IS CURRENTLY NOT USED.
    pOutDev (in)          -- points to printer specific data.

    If the function succeeds, it returns a handle to the client. If it fails,
    it returns nil.
===============================================================================*/

UFLHANDLE
UFLInit(
    const UFLBool           bDLGlyphTracking,
    const UFLMemObj         *pMemObj,
    const UFLFontProcs      *pFontProcs,
    const UFLOutputDevice   *pOutDev
    );


/*=============================================================================
                            UFLCleanUp

    Terminate a UFL session.

    handle (in) -- UFL handle that is obtained when UFLInit is called.

===============================================================================*/

void
UFLCleanUp(
    UFLHANDLE handle
    );


/*=============================================================================
                            UFLNewFont

    Initialize a font and validate a UFL request. This function needs to be
    called before a client makes a call to any other font handling APIs.
    If the request is valid, the function sets up the font global data structure.

    session (in)  -- UFL handle that is obtained when UFLInit is called.
    pRequest (in) -- points to the UFLRequest data structure.

    returns -- Handle to data stored for this font, or nil if unsuccessful

===============================================================================*/

UFO
UFLNewFont(
    const UFLHANDLE     session,
    const UFLRequest*   pRequest
    );


/*=============================================================================
                            UFLTestRestricted

===============================================================================*/

UFLBool
bUFLTestRestricted(
    const UFLHANDLE     h,
    const UFLRequest    *pRequest
    );


/*=============================================================================
                            UFLVMNeeded

    Get a guestimate of VM needed for a download request.

    aFont (in)      -- UFL handle that is obtained when UFLBeginFont is called.
    pGlyphs (in)    -- pointer to a UFLGlyphsInfo - has all the information
                       about this updating, including:
                       Number of glyphs to be output
                       List of output glyphs, each glyph is 2 bytes long
                       List of glyph names.  This list can be NULL. If this is
                       the case, UFL uses the name defined in the font
                       A list of indices to be used to index the ppGlyphNames list.
                       A List of Unicode or Script-code points
                       ... and ... depends on the extension to UFLGlyphsInfo
                       structure ....
    pVMNeeded (out) -- Amount of VM needed.
    pFCNeeded (out) -- Amount of FC needed.

    returns:
    noErr or error code if unsuccessful

===============================================================================*/

UFLErrCode
UFLVMNeeded(
    const UFO           aFont,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    );



/*=============================================================================
                            UFLDownloadIncr

    Downloads a font incrementally. The first time this is called for a
    particular font, it will create a base font, and download a set of
    requested characters. Subsequent calls on the same font will download
    additional characters.

    aFont (in)     -- UFL handle that is obtained when UFLBeginFont is called.
    pGlyphs (in)   -- pointer to a UFLGlyphsInfo - has all the information
                      about this updating, including:
                      Number of glyphs to be output
                      List of output glyphs, each glyph is 2 bytes long
                      List of glyph names.  This list can be NULL. If this is
                      the case, UFL uses the name defined in the font
                      A list of indices to be used to index the ppGlyphNames list.
                      A List of Unicode or Script-code points
                      ... and ... depends on the extension to UFLGlyphsInfo
                      structure ....
    pVMUsage (out) -- pointer to the amount of VM used by this request.

    returns:
    noErr or error code if unsuccessful

===============================================================================*/

UFLErrCode
UFLDownloadIncr(
    const UFO           aFont,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    );


/*=============================================================================
                            UFLDeleteFont

    Delete UFL internal data. UFL does not output any PostScript to delete
    the font on the printer since this has to do with how its client manages
    printer resources.

    aFont (in) -- UFL handle that is obtained when UFLBeginFont is called.

===============================================================================*/

void
UFLDeleteFont(
    UFO aFont
    );


/*===========================================================================
                            UFLUndefineFont

    Undefine a font on the printer.

    aFont (in) -- UFL handle that is obtained when UFLBeginFont is called.

    returns:
    noErr or error code if unsuccessful

==============================================================================*/

UFLErrCode
UFLUndefineFont(
    const UFO aFont
    );


/*=============================================================================
                            UFLCopyFont

    Copy a font on the printer - with new Encoding vector

    aFont (in) -- UFL handle to a UFObj created earlier
    request    -- has pszFontName, new hData, and new Encoding for this copy.

    returns:
    Handle to data stored for this font, or nil if unsuccessful.

===============================================================================*/

UFO
UFLCopyFont(
    const UFO   h,
    const UFLRequest* pRequest
    );


/*=============================================================================
                            UFLGIDsToCIDs

    This function can only be used with a CID CFF font. It is used to obtain
    CIDs from a list of GIDs.

    aFont (in)   -- UFL handle that is obtained when UFLBeginFont is called.
    cGlyphs (in) -- Number of glyhs (GIDs) to be converted.
    pGIDs  (in)  -- GID list.
    pCIDs  (out) -- Result CIDs.

    returns:
    noErr or error code if unsuccessful

===============================================================================*/

UFLErrCode
UFLGIDsToCIDs(
    const UFO        aFont,
    const short      cGlyphs,
    const UFLGlyphID *pGIDs,
    unsigned short   *pCIDs
    );


/* undo the Metrowerks pragma. */
#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_A0
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflvm.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLVM.h
 *
 *
 * $Header:
 */

 
#ifndef _H_UFLVM
#define _H_UFLVM

// Guestimate factor for a font VM Usage.
#define    VMRESERVED(x)	(((x) * 12) / 10)
#define    VMT42RESERVED(x) (((x) * 15) / 10)

/* VM Guestimation for type 1 */
#define kVMTTT1Header    10000
#define kVMTTT1Char      500

/* Type 3 */
#define kVMTTT3Header 15000        // synthetic Type 3 header vm usage
#define kVMTTT3Char   100          // synthetic Type 3 character vm usage

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflstd.h ===
/*
 *    Adobe Graphics Manager
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLStd -- UFL C Standard APIs.
 *
 *
 * $Header:
 */

#ifndef _H_UFLStd
#define _H_UFLStd

#ifdef WIN32KERNEL

    //
    // Definitions for NT Kernel mode driver.
    //
    #define UFLmemsetShort  memset
    #define UFLstrlen       strlen
    #define UFLstrcmp       strcmp
    #define UFLstrcmpW      _tcscmp

    int UFLsprintf(char *buf, size_t cchDest, const char *fmtstr, ...);
    long UFLstrtol (const char *nptr, char **endptr, int ibase);

    #define KStringCchCopyA(d,l,s)  strcpy(d,s)

#else // !WIN32KERNEL

    //
    // Definitions for NT/9x User mode driver.
    //
    #include <memory.h>
    #include <stdio.h>
    #include <string.h>

    #define UFLmemsetShort  memset
    #define UFLstrlen       strlen
    #define UFLstrcmp       strcmp

    #define UFLsprintf      StringCchPrintfA
    #define UFLstrtol       strtol

    #define KStringCchCopyA(d,l,s)  StringCchCopyA(d,l,s)

    //
    // We need a strcmp function that is aware of Unicode on Unicode savvy
    // platform or application.
    //
#ifdef UNICODE

    #include <tchar.h>
    #define UFLstrcmpW      _tcscmp
    #include <strsafe.h>

#else

    /* Although UFLstrcmpW is defined as strcmpW and strcmpW is defined in  */
    /* UFLSPROC.C, it is not prototyped anywhere. We prototype it here so   */
    /* we can avoid a "strcmpW() not defined" error in PARSETT.C            */
    /* jfu: 8-13-97 */
    int strcmpW ( unsigned short *str1, unsigned short *str2 );
    #define UFLstrcmpW      strcmpW

    /* _ltoa() and _ultoa() are specific to NT and Win32, but unix and mac  */
    /* environments define these in UFLSPROC.C, so prototype them here.     */
    /* jfu: 8-13-97 */
    char *_ltoa( long val, char *str, int radix );
    char *_ultoa( unsigned long val, char *str, int radix );

#endif // UNICODE

#endif // WIN32KERNEL

/*
    This is NOT a full implementation of "sprintf" as found
    in the C runtime library. Specifically, the only form of
    format specification allowed is %type, where "type" can
    be one of the following characters:

    d   int             signed decimal integer
    l   long            signed decimal integer
    ld  long            signed decimal integer
    lu  unsigned long   unsigned decimal integer
    u   unsigned int    unsigned decimal integer
    s   char*           character string
    c   char            character
    x,X unsigned long   hex number (emits at least two digits, uppercase)
    b   UFLBool         boolean (true or false)
    f   long            24.8 fixed-pointed number

    Normally, you should use UFLsprintf.  Use this function
    only when you want to sprintf with %f in the form of 24.8 fixed point
    number.  Currently, it is only used in UFOt42 module.
*/

int UFLsprintfEx(char *buf, size_t cchDest, const char *fmtstr, ...);

//
// Count of characters
//
#define CCHOF(x) (sizeof(x)/sizeof(*(x)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufltypes.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLTypes -- UFL basic type definitions
 *
 *
 * $Header:
 */

#ifndef _H_UFLTypes
#define _H_UFLTypes

/*=============================================================================*
 * Include files used by this interface                                        *
 *=============================================================================*/
#include <stdlib.h>
#include "UFLCnfig.h"

/*=============================================================================*
 * Constants                                                                   *
 *=============================================================================*/
#ifndef nil
#define nil 0
#endif

/*=============================================================================*
 * Scalar Types                                                                *
 *=============================================================================*/

#ifdef __cplusplus
extern "C" {
#endif


typedef void*           UFLHANDLE;
typedef UFLHANDLE       UFO;
typedef unsigned long   UFLsize_t;
typedef char            UFLBool;
typedef long            UFLFixed;


#if SWAPBITS == 0
typedef struct  {
    short           mant;
    unsigned short  frac;
} UFLSepFixed;
#else
typedef struct  {
    unsigned short  frac;
    short           mant;
} UFLSepFixed;
#endif


typedef struct _t_UFLFixedMatrix {
    UFLFixed    a;
    UFLFixed    b;
    UFLFixed    c;
    UFLFixed    d;
    UFLFixed    e;
    UFLFixed    f;
} UFLFixedMatrix;

/*
 * UFLFixedPoint structure -- specifies the x- and y-coordinates of a point.
 * The coordinates are expressed as 32-bit fixed point numbers.
 */
typedef struct _t_UFLFixedPoint {
    UFLFixed x;    /* Specifies a width or x-coordinate.   */
    UFLFixed y;    /* Specifies a height or y-coordinate.  */
} UFLFixedPoint;


/*
 * UFLSize structure -- contains information about the size or location of an
 * object specified as two 32-bit values.
 */
typedef struct _t_UFLSize {
    long  cx;   /* Specifies a width or x-coordinate. */
    long  cy;   /* Specifies a height or y-coordinate.*/
} UFLSize;


typedef unsigned short UFLErrCode;

typedef void*   (UFLCALLBACK *UFLMemAlloc)(UFLsize_t size, void* userData);
typedef void    (UFLCALLBACK *UFLMemFree )(void* ptr, void* userData);
typedef void    (UFLCALLBACK *UFLMemCopy )(void* dest, void* source, UFLsize_t size, void* userData);
typedef void    (UFLCALLBACK *UFLMemSet  )(void* dest, unsigned int value, UFLsize_t size, void* userData);

typedef unsigned long UFLGlyphID;   /* The HIWord is client data, LOWORD is the GID - usable by UFL. */

typedef struct _t_UFLMemObj {
    UFLMemAlloc alloc;
    UFLMemFree  free;
    UFLMemCopy  copy;
    UFLMemSet   set;
    void*       userData;
} UFLMemObj;


/*
 * UFL output stream object
 */
typedef struct _t_UFLStream UFLStream;

typedef void (*UFLPutProc) (
    UFLStream*  thisStream,
    long        selector,
    void*       data,
    UFLsize_t*  len
    );

typedef char (UFLCALLBACK *UFLDownloadProcset) (
    UFLStream*      thisStream,
    unsigned long   procsetID
    );

typedef struct _t_UFLStream {
    UFLPutProc          put;
    UFLDownloadProcset  pfDownloadProcset;
} UFLStream;


/*
 * Notes about kUFLStreamPut and KUFLStreamPutBinary
 *
 * kUFLStreamPut
 * Data is already converted to the correct format. The stream does not need
 * to convert the data to the transmission protocol format.
 *
 * kUFLStreamPutBinary
 * Data is in binary format. The stream needs to convert the data to BCP/TBCP
 * if necessary.
 */
enum {
    kUFLStreamGet,
    kUFLStreamPut,
    kUFLStreamPutBinary,
    kUFLStreamSeek
};


typedef enum {
    kPSLevel1 = 1,
    kPSLevel2,
    kPSLevel3
} PostScriptLevel;


/* UFLOutputDevice - contains output device features */
typedef struct _t_UFLOutputDevice {
    long                lPSLevel;     /* PostScript level                               */
    long                lPSVersion;   /* Printer version number                         */
    unsigned long       bAscii;       /* TRUE -> Output ASCII, FALSE => Output Binary   */
    UFLStream           *pstream;     /* Stream to output PostScript.                   */
} UFLOutputDevice;


/* Download type */
typedef enum {
    kNilDLType = 0,           /* Invalid download type                                          */

    kPSOutline,               /* PostScript Outline Font                                        */
    kPSBitmap,                /* PostScript Bitmap                                              */

    kPSCID,                   /* PS Font, Use CID font, format 0                                */
    kCFF,                     /* CFF type 1 Font                                                */
    kCFFCID_H,                /* CFF CID font, Horizontal                                       */
    kCFFCID_V,                /* CFF CID font, Vertical                                         */
    kCFFCID_Resource,         /* CFF CIDFont resource only, no composefont                      */

    kTTType0,                 /* TT Font, Use type 0                                            */
    kTTType1,                 /* TT Font, Use type 1                                            */
    kTTType3,                 /* TT Font, Use type 3-only                                       */
    kTTType332,               /* TT Font, Use type 3/32 combo                                   */
    kTTType42,                /* TT Font, Use type 42                                           */
    kTTType42CID_H,           /* TT Font, Use CID/42 font, Horizontal                           */
    kTTType42CID_V,           /* TT Font, Use CID/42 font, Vertical                             */
    kTTType42CID_Resource_H,  /* TT Font, Download the CIDFont Resource only, don't composefont */
    kTTType42CID_Resource_V   /* TT Font, Download the CIDFont Resource only, don't composefont */
} UFLDownloadType;


#define IS_TYPE42CID(lFormat) \
            (  (lFormat) == kTTType42CID_H          \
            || (lFormat) == kTTType42CID_V          \
            || (lFormat) == kTTType42CID_Resource_H \
            || (lFormat) == kTTType42CID_Resource_V )


#define IS_TYPE42CID_H(lFormat) \
            (  (lFormat) == kTTType42CID_H          \
            || (lFormat) == kTTType42CID_Resource_H )

#define IS_TYPE42CID_V(lFormat) \
            (  (lFormat) == kTTType42CID_V          \
            || (lFormat) == kTTType42CID_Resource_V )

/* GOODNAME: We download FE CFF font as CID0 font. */
#define IS_CFFCID(lFormat) \
            (  (lFormat) == kCFFCID_H \
            || (lFormat) == kCFFCID_V )

/* We build a CID-keyed font for 42CID_H and 42CID_V. */
#define IS_TYPE42CID_KEYEDFONT(lFormat) \
            (  (lFormat) == kTTType42CID_H \
            || (lFormat) == kTTType42CID_V )

/* We only build a CIDFont Resource for 42CID_Resource. */
#define IS_TYPE42CIDFONT_RESOURCE(lFormat)  \
            (  (lFormat) == kTTType42CID_Resource_H \
            || (lFormat) == kTTType42CID_Resource_V )

#ifndef min
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#endif

typedef struct _t_UFLGlyphMap {
    long    xOrigin;    /* number of pixels from xMin of bitmap to character x origin */
    long    yOrigin;    /* number of pixels from yMin of bitmap to character y origin */
    long    byteWidth;  /* bytes per scan line in the "bits" array */
    long    height;     /* number of scan lines in the "bits" array */
    char    bits[1];    /* bits of glyph image */
} UFLGlyphMap;



#ifdef __cplusplus
}
#endif


#endif    /* ifndef _H_UFLTypes */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufocff.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFOCFF.h -- Universal Font Object to be used w/ CFF font.
 *
 *
 * $Header:
 */

#ifndef _H_UFOCFF
#define _H_UFOCFF

/*
 * Special postfix, CDevProc, and guestimation value for Metrics2 size
 * used when printing on %hostfont% RIP with bug #388111.
 */
#define HFPOSTFIX		"-hf"
#define HFCIDCDEVPROC	"{pop 4 index add}bind"
#define HFVMM2SZ		20 /* About 4% of kVMTTT1Char; this, too, is a guestmation value. */


/*============================================================================*
 * Include files used by this interface                                       *
 *============================================================================*/
#include "UFO.h"
#include "xcf_pub.h"

typedef struct tagCFFFontStruct {
    XFhandle        hFont;
    UFLCFFFontInfo  info;
    UFLCFFReadBuf   *pReadBuf;
} CFFFontStruct;


UFOStruct*
CFFFontInit(
    const UFLMemObj*  pMem,
    const UFLStruct*  pUFL,
    const UFLRequest* pRequest,
    UFLBool*          pTestRestricted
    );


UFLErrCode
CFFCreateBaseFont(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    char                *pHostFontName
    );


UFLErrCode
CFFGIDsToCIDs(
    const CFFFontStruct*   pFont,
    const short            cGlyphs,
    const UFLGlyphID*      pGIDs,
    unsigned short*        pCIDs
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\uflstrm.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLStrm.h -- UFL Output Stream
 *
 *
 * $Header:
 */

#ifndef _H_UFLStrm
#define _H_UFLStrm

/*===============================================================================*
 * Include files used by this interface                                                                                                            *
 *===============================================================================*/
#include "UFL.h"

/*===============================================================================*
 * Theory of Operation                                                                                                                                   *
 *===============================================================================*/
/*
    UFL Output stream buffers and output data in different format such as eexec encrypt data format, and ASCIIHex.

*/

/*===============================================================================*
 * Constants/Macros                                                                                                                                              *
 *===============================================================================*/
#ifdef MAC_ENV
 /* Place Mac Macros here.... !!! MAC - Check its correctness!!! */
#define GET_HIBYTE(c)   (((c) & 0x00FF) >> 8)
#define GET_LOBYTE(c)   ((c) & 0xFF00)
#else
 /* Windows/Intel Macros */
#define GET_HIBYTE(c)   (((c) & 0xFF00) >> 8)
#define GET_LOBYTE(c)   ((c) & 0x00FF)
#endif

/*===============================================================================*
 * Scalar Types                                                                                                                                             *
 *===============================================================================*/


/*==================================================================================================*
 *    UFLOutStream                                                                                                                                                                             *    
 *==================================================================================================*/

typedef struct UFLOutStream {
    const UFLMemObj    *pMem;
    const UFLStream    *pStream;
    UFLBool            flOutputAscii;
    unsigned long      lAddEOL;
} UFLOutStream;

/* Public methods */
UFLHANDLE StrmInit( 
    const UFLMemObj *pMem, 
    const UFLStream *stream, 
    const UFLBool   outputAscii 
    );

void StrmCleanUp( 
    const UFLHANDLE h 
    );

UFLErrCode StrmPutBytes ( 
    const UFLHANDLE h, 
    const char      *data, 
    const UFLsize_t    len, 
    const UFLBool   bAscii 
    );

UFLErrCode StrmPutAsciiHex( 
    const UFLHANDLE h, 
    const char      *data, 
    const unsigned long len 
    );

UFLErrCode 
StrmPutWordAsciiHex( 
    const UFLHANDLE h, 
    const unsigned short wData
    );

UFLErrCode StrmPutAscii85( 
    const UFLHANDLE h, 
    const char      *data,  
    const unsigned long len 
    );

UFLErrCode StrmPutString( 
    const UFLHANDLE h, 
    const char      *data 
    );

UFLErrCode StrmPutStringBinary( 
    const UFLHANDLE h, 
    const char      *data, 
    const unsigned long len 
    );

UFLErrCode StrmPutInt( 
    const UFLHANDLE h, 
    const long int  i 
    );

UFLErrCode StrmPutFixed( 
    const UFLHANDLE h, 
    const UFLFixed  f 
    );

UFLErrCode StrmPutStringEOL( 
    const UFLHANDLE h, 
    const char      *data 
    );

UFLErrCode StrmPutMatrix( 
    const UFLHANDLE h, 
    const UFLFixedMatrix *matrix, 
    const UFLBool skipEF 
    );

#define             StrmCanOutputBinary( h )                    ( ( ((UFLOutStream *)h)->flOutputAscii ) ? 0 : 1)

/* Private methods */
UFLErrCode Output85( 
    const UFLHANDLE h, 
    unsigned long   inWord, 
    short           nBytes 
    );

static void Fixed2CString( 
    UFLFixed f, 
    char     *s, 
    short    precision, 
    char     skipTrailSpace 
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufo.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFO -- Universal Font Object
 *
 *
 * $Header:
 */

#ifndef _H_UFO
#define _H_UFO

/*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/
#include "UFL.h"
#include "UFLPriv.h"
#include "goodname.h"

#ifdef __cplusplus
extern "C" {
#endif

/*===============================================================================*
 * Theory of Operation                                                           *
 *===============================================================================*/
/*
 * This file defines the Universal Font Object.
 */

/*===============================================================================*
 * Constants                                                                     *
 *===============================================================================*/

/*===============================================================================*
 * Macros                                                                        *
 *===============================================================================*/
#define  MAX_GLYPHNAME_LEN            256

#define IS_GLYPH_SENT(arr, i)         ((arr)[((i)>>3)] & (1 << ((i)&7)))
#define SET_GLYPH_SENT_STATUS(arr, i) (arr)[((i)>>3)] |= (1 << ((i)&7))
#define GLYPH_SENT_BUFSIZE(n)         ( ((n) + 7) / 8 )

/*===============================================================================*
 * Scalar Types                                                                  *
 *===============================================================================*/

/* Font state */
typedef enum {
    kFontCreated,           /* The font object is created, but has not initialized.    */

    kFontInit,              /* The font object is initialized and is valid to be used. */
    kFontInit2,             /* Still requre to create its font instance.               */
    kFontHeaderDownloaded,  /* The font object downloaded an empty font header.        */

    kFontHasChars,          /* Font has chars in it.                                   */
    kFontFullDownloaded     /* The font object downloaded a full font.                 */
} UFLFontState;

/* Misc Flags for UFOStruct.dwFlags */
#define     UFO_HasFontInfo     0x00000001L
#define     UFO_HasG2UDict      0x00000002L
#define     UFO_HasXUID         0x00000004L
#define		UFO_HostFontAble    0x00000008L // %hostfont% support

//
// %hostfont% support
//
#define HOSTFONT_IS_VALID_UFO(pUFO)         (((pUFO)->hHostFontData) && ((pUFO)->dwFlags & UFO_HostFontAble))
#define HOSTFONT_IS_VALID_UFO_HFDH(pUFO)	((pUFO)->hHostFontData)
#define HOSTFONT_VALIDATE_UFO(pUFO)  		((pUFO)->dwFlags |=  UFO_HostFontAble)
#define HOSTFONT_INVALIDATE_UFO(pUFO)      	((pUFO)->dwFlags &= ~UFO_HostFontAble)

#define HOSTFONT_GETNAME(pUFO, ppName, psize, sfindex) \
    (UFLBool)(pUFO)->pUFL->fontProcs.pfHostFontUFLHandler(HOSTFONT_UFLREQUEST_GET_NAME, \
                                                            (pUFO)->hHostFontData, \
                                                            (ppName), (psize), \
                                                            (pUFO)->hClientData, (sfindex))

#define HOSTFONT_ISALLOWED(pUFO, pName) \
    (UFLBool)(pUFO)->pUFL->fontProcs.pfHostFontUFLHandler(HOSTFONT_UFLREQUEST_IS_ALLOWED, \
                                                            (pUFO)->hHostFontData, \
                                                            (pName), NULL, \
                                                            NULL, 0)

#define HOSTFONT_SAVE_CURRENTNAME(pUFO, pName) \
    (UFLBool)(pUFO)->pUFL->fontProcs.pfHostFontUFLHandler(HOSTFONT_UFLREQUEST_SET_CURRENTNAME, \
                                                            (pUFO)->hHostFontData, \
                                                            (pName), NULL, \
                                                            NULL, 0)


/*===============================================================================*
 * Classes defined in this interface                                             *
 *===============================================================================*/

typedef struct t_UFOStruct UFOStruct;

typedef UFLErrCode (UFLCALLBACK *pfnUFODownloadIncr)(
    const UFOStruct     *aFont,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage   /* Type 32 FontCache tracking */
    );

typedef UFLErrCode (UFLCALLBACK *pfnUFOVMNeeded)(
    const UFOStruct     *aFont,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded  /* Type 32 FontCache tracking */
    );


typedef UFLErrCode (UFLCALLBACK *pfnUFOUndefineFont)(
    const UFOStruct *pFont
);

typedef void (UFLCALLBACK *pfnUFOCleanUp)(
    UFOStruct *pFont
);

typedef UFOStruct * (UFLCALLBACK *pfnUFOCopy)(
    const UFOStruct *pFont,
    const UFLRequest* pRequest
);



/*
 * This is the base font class.
 * Subclasses for each type of font is derived from this.
 */

/*
 * A common, sharable structure to be used with TT-as-T1/T3/T42 or CFF.
 * Notice that it saves a bunch of pointers just a comvenient way to access
 * data and a common structure for functions such as GetGlyphName() and
 * GETFONTDATA().
 */
typedef UFLHANDLE  UFOHandle;  /* a void Pointer */

typedef struct t_AFontStruct {
    unsigned long   refCount;           /* reference counter of this structure */

    UFOHandle       hFont;              /* a pointer to a font dependent structure */

    UFLXUID         Xuid;               /* XUID array: copied from client or created from TTF file */

    unsigned char   *pDownloadedGlyphs; /* list of downloaded glyphs for hFont */
    unsigned char   *pVMGlyphs;         /* list of downloaded glyphs, used to calculate VM usage */
    unsigned char   *pCodeGlyphs;       /* list of glyphs used to update Code Points in FontInfo */

    void            *pTTpost;           /* pointer to 'post' table for Speed */
    unsigned long   dwTTPostSize;       /* size of 'post' table */

    unsigned short  gotTables:1,
                    hascmap:1,
                    hasmort:1,
                    hasGSUB:1,
                    hasPSNameStr:1,
                    hasTTData:1,
                    knownROS:1,
                    hasvmtx:1,          /* fix #358889 */
                    unused:8;

    int             info;               /* DIST_SYSFONT_INFO_* bits */

    /*
     * Stuff used for GoodName
     */

    /* 'cmap' table data */
    unsigned long   cmapTBSize;
    void            *pTTcmap;
    TTcmapFormat    cmapFormat;
    TTcmap2Stuff    cmap2;              /* convenient pointers/numbers */
    TTcmap4Stuff    cmap4;              /* convenient pointers/numbers */

    /* 'mort' table data */
    unsigned long   mortTBSize;
    void            *pTTmort;
    TTmortStuff     mortStuff;          /* convenient pointers/numbers */

    /* 'GSUB' table data */
    unsigned long   gsubTBSize;
    void            *pTTGSUB;
    TTGSUBStuff     GSUBStuff;          /* convenient pointers/numbers */

    /* a global string - to put unusual glyph-name in it. */
    char     gGlyphName[MAX_GLYPHNAME_LEN];
} AFontStruct;

/*
 * Macros for managing AFontStruct
 */
#define AFONT_AddRef(pDLGlyphs)    ((pDLGlyphs)->refCount++)
#define AFONT_Release(pDLGlyphs)   ((pDLGlyphs)->refCount--)
#define AFONT_RefCount(pDLGlyphs)  ((pDLGlyphs)->refCount)


/*
 * Universal Font Object class definition
 */
typedef struct t_UFOStruct {
    int                     ufoType;            /* font object type */
    UFLDownloadType         lDownloadFormat;    /* download format type */
    UFLFontState            flState;            /* flag used to keep track the state of the font. */
    UFLHANDLE               hClientData;        /* UFL Client private data (pointer to SUBFONT structure) */
    long                    lProcsetResID;      /* resource ID of the required procset */
    unsigned long           dwFlags;            /* misc flags: has FontInfo, AddGlyphName2Unicode... */
    const UFLMemObj         *pMem;              /* UFL memory function pointer */
    const UFLStruct         *pUFL;              /* UFL common object pointer */

    /*
     * Data that is sharable among several instances
     */
    AFontStruct             *pAFont;            /* a font with a list of downloaded glyphs */

    /*
     * Data unique to the current font
     * A copy of a UFObj has a different name/encoding.
     */
    char                    *pszFontName;       /* font name */
    unsigned long           subfontNumber;      /* subfont number of this font */
    long                    useMyGlyphName;     /* If 1, use the glyph names passed in by client. */
    char                    *pszEncodeName;     /* font encoding. If nil, then creat a font with names UFL likes. */
    unsigned char           *pUpdatedEncoding;  /* bits in Encoding Vector with correct name set */
    unsigned char           *pEncodeNameList;   /* Fix bug 274008 */
    unsigned short          *pwCommonEncode;    /* common encode list */
    unsigned short          *pwExtendEncode;    /* extended encode list */
    unsigned char           *pMacGlyphNameList; /* Mac glyph name list */
    const UFLFontDataInfo   *pFData;            /* a pointer for access convenience */

    /*
     * Miscellenious
     */
    long                    lNumNT4SymGlyphs;   /* Fix a GDI symbol font bug */
    UFLVPFInfo              vpfinfo;            /* Fix bug #287084, #309104, and #309482 */
    UFLBool                 bPatchQXPCFFCID;    /* Fix bug #341904 */

    /*
     * %hostfont% support
     */
    UFLHANDLE               hHostFontData;      /* %hostfont% data handle */

    /*
     * UFO object type dependent methods
     */
    pfnUFODownloadIncr      pfnDownloadIncr;    /* incremental download function pointer */
    pfnUFOVMNeeded          pfnVMNeeded;        /* VM check function pointer */
    pfnUFOUndefineFont      pfnUndefineFont;    /* font undefine function pointer */
    pfnUFOCleanUp           pfnCleanUp;         /* object cleanup function pointer */
    pfnUFOCopy              pfnCopy;            /* object copy function pointer */
} UFOStruct;


/*
 * Number of glyphs in this font file - check against it for bounds.
 */
#define UFO_NUM_GLYPHS(pUFObj)  ((pUFObj)->pFData->cNumGlyphs)

/*
 * Special font initialization status check
 */
#define UFO_FONT_INIT2(pUFObj)  ((pUFObj)->flState == kFontInit2)


/*
 * Constant values for UFOStruct.ufoType
 */
#define UFO_CFF     0
#define UFO_TYPE1   1
#define UFO_TYPE42  2
#define UFO_TYPE3   3


/*
 * UFO Function prototypes
 */
UFLBool
bUFOTestRestricted(
    const UFLMemObj *pMem,
    const UFLStruct *pSession,
    const UFLRequest *pRequest
    );


UFOStruct * UFOInit(
    const UFLMemObj *pMem,
    const UFLStruct *pSession,
    const UFLRequest *pRequest
    );


UFLErrCode UFODownloadIncr(
    const UFOStruct     *aFont,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage   /* T32 FontCache tracking */
    );


UFLErrCode UFOVMNeeded(
    const UFOStruct     *aFont,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCUsage   /* T32 FontCache tracking */
    );


UFLErrCode UFOUndefineFont(
    const UFOStruct *pFont
    );


void UFOInitData(
    UFOStruct           *pUFO,
    int                 ufoType,
    const UFLMemObj     *pMem,
    const UFLStruct     *pSession,
    const UFLRequest    *pRequest,
    pfnUFODownloadIncr  pfnDownloadIncr,
    pfnUFOVMNeeded      pfnVMNeeded,
    pfnUFOUndefineFont  pfnUndefineFont,
    pfnUFOCleanUp       pfnCleanUp,
    pfnUFOCopy          pfnCopy
    );


void UFOCleanUpData(
    UFOStruct *pUFO
    );


void UFOCleanUp(
    UFOStruct *aFont
    );


UFOStruct *
UFOCopyFont(
    const UFOStruct *aFont,
    const UFLRequest* pRequest
    );


UFLErrCode
UFOGIDsToCIDs(
    const UFOStruct  *aFont,
    const short      cGlyphs,
    const UFLGlyphID *pGIDs,
    unsigned short   *pCIDs
    );


/* fix bug 274008 & GoodName */
UFLBool
FindGlyphName(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    short               i,
    unsigned short      wIndex,
    char                **pGoodName
    );


UFLBool
ValidGlyphName(
    const UFLGlyphsInfo *pGlyphs,
    short               i,
    unsigned short      wIndex,
    char                *pGoodName
    );


UFLErrCode
UpdateEncodingVector(
    UFOStruct           *pUFO,
    const UFLGlyphsInfo *pGlyphs,
    short int           sStart,
    short int           sEnd
    );


UFLErrCode
UpdateCodeInfo(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    UFLBool             bT3T32Font     // GoodName
    );


UFLErrCode
ReEncodePSFont(
    const UFOStruct *pUFO,
    const char      *pszNewFontName,
    const char      *pszNewEncodingName
    );


UFLErrCode
NewFont(
    UFOStruct       *pUFO,
    unsigned long   dwSize,
    const long      cGlyphs
    );


void
vDeleteFont(
    UFOStruct   *pUFO
    );


UFOStruct *
CopyFont(
    const UFOStruct *pUFO,
    const UFLRequest* pRequest
    );


void
VSetNumGlyphs(
    UFOStruct     *pUFO,
    unsigned long cNumGlyphs
    );


/* GoodName */
unsigned short
GetTablesFromTTFont(
    UFOStruct     *pUFObj
    );


/* GoodName */
unsigned short
ParseTTTablesForUnicode(
    UFOStruct       *pUFObj,
    unsigned short  gid,
    unsigned short  *pUV,
    unsigned short  wSize,
    TTparseFlag     ParseFlag
    );


UFLBool
CheckGlyphName(
    UFOStruct       *pUFObj,
    unsigned char   *pszName
    );


UFLBool
HostFontValidateUFO(
    UFOStruct   *pUFObj,
    char        **ppHostFontName
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufottt1.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFOttt1.h - TrueType downloaded as type 1 implementation.
 *
 *
 * $Header:
 */

#ifndef _H_UFOTTT1
#define _H_UFOTTT1


/*===============================================================================*
 * Include files used by this interface                                                                                                               *
 *===============================================================================*/
#include "UFO.h"


/*===============================================================================*
 * Theory of Operation                                                                                                                                  *
 *===============================================================================*/
/* 
   TrueType downloaded as type 1 implementation (Unhinted outline font).
*/

/*===============================================================================*
 * Constants                                                                                                                                              *
 *===============================================================================*/


/*===============================================================================*
 * Scalar Types                                                                                                                                             *
 *===============================================================================*/

/* CSBufStruct uses to buffer and encrypt CharString */

typedef struct {
        char*           pBuf;

        char*           pPos;       //  points to current position within buffer.

        char*           pEnd ;

        unsigned long   ulSize;

        UFLMemObj*      pMemObj;                                /* Memory object */

}  CSBufStruct;

/* Public functions */
/* These three functions should have "static" in front...  --jfu */
static CSBufStruct*    CSBufInit( const UFLMemObj *pMem );
static void            CSBufCleanUp( CSBufStruct *h );
static UFLErrCode       CSBufAddNumber( CSBufStruct *h, long dw );

#define CSBufBuffer( h )               (((CSBufStruct *)h)->pBuf)
#define CSBufRewind( h )               (((CSBufStruct *)h)->pPos = ((CSBufStruct *)h)->pBuf)
#define CSBufCurrentSize( h)           (((CSBufStruct *)h)->pEnd - ((CSBufStruct *)h)->pBuf) /* Return the current availability size of the CharString Buffer */
#define CSBufCurrentLen( h )           (((CSBufStruct *)h)->pPos - ((CSBufStruct *)h)->pBuf) /* Return the current usage of the CharString buffer */
#define CSBufAddChar( h, c )           ( *(((CSBufStruct *)h)->pPos)++ = c ) 

#define CSBufFreeLen( h )              (((CSBufStruct *)h)->pEnd - ((CSBufStruct *)h)->pPos) /* The left room usable in the CharString buffer */

#ifdef DEBUG_ENGLISH
void                    CSBufAddString( CSBufStruct *h, char* str );
void                    CSBufAddFixed( CSBufStruct *h, UFLFixed f );
#endif

/*==================================================================================================*
 *    UFOTTT1Font    - type 1                                                                                                                                                                   *    
 *==================================================================================================*/

typedef struct {

    /* TT1 Data starts from here */

    CSBufStruct         *pCSBuf;                        /* CharString buffer */

    UFLTTT1FontInfo     info;                           /* True Type Font info. */

    unsigned short      eexecKey;
} TTT1FontStruct;

UFOStruct *TTT1FontInit( const UFLMemObj *pMem, const UFLStruct *pUFL, const UFLRequest *pRequest );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufottt3.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFOttt3.h - PostScript type 3 implementation for a TrueType font.
 *
 *
 * $Header:
 */

#ifndef _H_UFOTTT3
#define _H_UFOTTT3

/*===============================================================================*
 * Include files used by this interface                                                                                                               *
 *===============================================================================*/
#include "UFO.h"

/*===============================================================================*
 * Theory of Operation                                                                                                                                  *
 *===============================================================================*/
/* 
   This file defines the PostScript type 3 implementation for a TrueType font (Hinted bitmap font).
*/

/*==================================================================================================*
 *    TTT3FontStruct                                                                                                                                                                              *    
 *==================================================================================================*/

typedef struct  {

     /* TT3 Data starts from here */
    unsigned long   cbMaxGlyphs;        /* Size of the the largest glyph */

    UFLTTT3FontInfo info;               /* True Type Font info.  */

} TTT3FontStruct;

UFOStruct *TTT3FontInit( 
    const UFLMemObj *pMem, 
    const UFLStruct *pUFL, 
    const UFLRequest *pRequest 
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\config\intelnt\uflcnfig.h ===
/*
 *	Font Translation Library
 *
 *	Copyright (c) 1995 Adobe Systems Inc.
 *	All Rights Reserved
 *
 *	UFLConfig.h
 *
 *		Intel Windows NT version of UFLConfig
 *
 * $Header: $
 */

#ifndef _H_UFLConfig
#define _H_UFLConfig

#define WIN_ENV	1
#define HAS_SEMAPHORES	1
#define SWAPBITS 1


/* Include user mode header files */
#include <windef.h>

#define UFLEXPORT
#define UFLEXPORTPTR UFLEXPORT
#define UFLCALLBACK UFLEXPORT
#define UFLCALLBACKDECL UFLEXPORT

#define huge
#define PTR_PREFIX

/* We share CIDFont0/2 on W2K. */
#define UFL_CIDFONT_SHARED 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\api\ufot42.h ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLT42.h - PostScript Type 42 Font helper routines.
 *
 *
 * $Header:
 */

#ifndef _H_UFLT42
#define _H_UFLT42

/*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/
#include "UFO.h"


/*===============================================================================*
 * Theory of Operation                                                           *
 *===============================================================================*/

/*
 * This file defines a class for Type 42.
 */

#define BUMP2BYTE(a)        (a % 2) ? (a + 1) : (a)
#define BUMP4BYTE(a)        (a % 4) ? (a + (4 - (a % 4))) : (a)

#define THIRTYTWOK          (1024L * 32L - 820L - 4L)
#define SIXTYFOURK          ((long)(2 * THIRTYTWOK))

#define NUM_16KSTR          640 // Assumes a TT font is no more than 10MBytes = (640*32K)
#define MINIMALNUMBERTABLES 9
#define SFNT_STRINGSIZE     0x3FFE
#define kT42Factor          ((float)1.2)
#define NUM_CIDSUFFIX       4

extern char *gcidSuffix[NUM_CIDSUFFIX];


/*
 * Define 32K-1, maximal number a CIDMap can handle - see 2ps.bug 3431.
 * End at 00 so next CMap can say <7F00> <7FFF> 0.
 *
 * The Number 0x7F00 is hard coded in CMaps WinCharSetFFFF_H2 and
 * WinCharSetFFFF_V2, so don't change it without changing the CMaps
 * in CMap_FF.ps first.
 */
#define  NUM_32K_1    0x7F00


typedef struct tagMaxPTableStruct {
    unsigned long     version;
    unsigned short    numGlyphs;
    unsigned short    maxPoints;
    unsigned short    maxContours;
    unsigned short    maxCompositePoints;
    unsigned short    maxCompositeContours;
    unsigned short    maxZones;
    unsigned short    maxTwilightPoints;
    unsigned short    maxStorage;
    unsigned short    maxFunctionDefs;
    unsigned short    maxInstructionDefs;
    unsigned short    maxStackElements;
    unsigned short    maxSizeOfInstructions;
    unsigned short    maxComponentElements;
    unsigned short    maxComponentDepth;
} MaxPTableStruct;


typedef struct tagOS2TableStruct {
    unsigned short    version;
    short             xAvgCharWidth;
    unsigned short    usWeightClass;
    unsigned short    usWidthClass;
    short             fsType;
    short             ySubscriptXSize;
    short             ySubscriptYSize;
    short             ySubscriptXOffset;
    short             ySubscriptYOffset;
    short             ySuperscriptXSize;
    short             ySuperscriptYSize;
    short             ySuperscriptXOffset;
    short             ySuperscriptYOffset;
    short             yStrikeoutSize;
    short             yStrikeoutPosition;
    short             sFamilyClass;
    char              panaose[10];

    /*
     * Note about unicodeRange.
     * This is spec'ed to be an array of 4 long words. I have declared it to
     * be an array of 16 bytes simply to avoid endian dependencies. But the
     * spec lists active ranges according to bit number. These bit numbers are
     * as though it was an array of big endian longs so...
     *
     * bit 0    -> lowest bit of first long word (lowest bit of 4th byte)
     * bit 31   -> highest bit of first long word (highest bit of first byte)
     * bit 32   -> lowest bit of second long word (lowest bit of 8th byte)
     * etc...
     */

    unsigned char     unicodeRange[16];
    char              achVendID[4];
    unsigned short    fsSelection;
    unsigned short    usFirstCharIndex;
    unsigned short    usLastCharIndex;
    unsigned short    sTypeoAscender;
    unsigned short    sTypeoDescender;
    unsigned short    sTypoLineGap;
    unsigned short    usWinAscent;
    unsigned short    usWinDescent;

    /*
     * Microsoft documentation claims that there is a uICodePageRange at the
     * end of the record, but I have never seen 'OS/2' table that contains one.
     */
    /* unsigned char     uICodePageRange[8]; */

} UFLOS2Table;


typedef struct tagPOSTHEADER {
    unsigned long   format;         /* 0x00010000 for 1.0, 0x00020000 for 2.0, and so on... */
    unsigned long   italicAngle;
    short int       underlinePosition;
    short int       underlineThickness;
    unsigned long   isFixedPitch;
    unsigned long   minMemType42;
    unsigned long   maxMemType42;
    unsigned long   minMemType1;
    unsigned long   maxMemType1;
} POSTHEADER;


#define    POST_FORMAT_10    0x00010000
#define    POST_FORMAT_20    0x00020000
#define    POST_FORMAT_25    0x00020500
#define    POST_FORMAT_30    0x00030000


typedef struct tagType42HeaderStruct {
    long  tableVersionNumber;
    long  fontRevision;
    long  checkSumAdjustment;
    long  magicNumber;
    short flags;
    short unitsPerEm;
    char  timeCreated[8];
    char  timeModified[8];
    short xMin;
    short yMin;
    short xMax;
    short yMax;
    short macStyle;
    short lowestRecPPEM;
    short fontDirectionHint;
    short indexToLocFormat;
    short glyfDataFormat;
} Type42HeaderStruct;


typedef struct tagGITableStruct {
    short glyphIndices[255];    /* This will change to a pointer for FE fonts */
    short n;                    /* maximal OID for this charset: 0 to n-1 */
} GITableStruct;


/* for Composite Characters */
#define MINUS_ONE                -1
#define ARG_1_AND_2_ARE_WORDS    0x0001
#define ARGS_ARE_XY_VALUES       0x0002
#define ROUND_XY_TO_GRID         0x0004
#define WE_HAVE_A_SCALE          0x0008
#define MORE_COMPONENTS          0x0020
#define WE_HAVE_AN_X_AND_Y_SCALE 0x0040
#define WE_HAVE_A_TWO_BY_TWO     0x0080
#define WE_HAVE_INSTRUCTIONS     0x0100
#define USE_MY_METRICS           0x0200


typedef struct tagT42FontStruct {
    unsigned long       minSfntSize;
    unsigned long       averageGlyphSize;
    UFLTTFontInfo       info;
    unsigned char       *pHeader;
    unsigned char       *pMinSfnt;
    unsigned long       *pStringLength;
    void                *pLocaTable;
    Type42HeaderStruct  headTable;          // This is not initialized to nil/zero
    short               cOtherTables;
    unsigned short      numRotatedGlyphIDs;
    long                *pRotatedGlyphIDs;  // GID's need to be rotated for CJK-Vertical fonts
} T42FontStruct;


/*
 * Public function prototype
 */

UFOStruct *
T42FontInit(
    const UFLMemObj     *pMem,
    const UFLStruct     *pUFL,
    const UFLRequest    *pRequest
    );

UFLErrCode
T42CreateBaseFont(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    UFLBool             bFullFont,
    char                *pHostFontName
    );

#endif // _H_UFLT42
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\config\kintelnt\uflcnfig.h ===
/*
 *	Font Translation Library
 *
 *	Copyright (c) 1995 Adobe Systems Inc.
 *	All Rights Reserved
 *
 *	UFLConfig.h
 *
 *		Intel Windows NT Kernel version of UFLConfig
 *
 * $Header: $
 */

#ifndef _H_UFLConfig
#define _H_UFLConfig

#define WIN_ENV	1
#define HAS_SEMAPHORES	1
#define SWAPBITS 1
#define WIN32KERNEL	1

/* Include kernel mode header files */
//#define WINNT	1
//#define UNICODE	1
//#define KERNEL_MODE 1
//#define _X86_ 1

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>

//#define UFLEXPORT __cdecl
#define UFLEXPORT 
#define UFLEXPORTPTR UFLEXPORT
#define UFLCALLBACK UFLEXPORT
#define UFLCALLBACKDECL UFLEXPORT

#define huge
#define PTR_PREFIX

/* We share CIDFont0/2 on NT4. */
#define UFL_CIDFONT_SHARED 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\goodname.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    GOODNAME.C
 *
 *
 * $Header:
 */


/*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/
#include "UFLPriv.h"
#include "UFLMem.h"
#include "UFLMath.h"
#include "UFLStd.h"
#include "UFLErr.h"
#include "UFLPS.h"
#include "ParseTT.h"
#include "UFLVm.h"
#include "ufot42.h"
#include "goodname.h"
#include "ttformat.h"


/* ------------------------------------------------------------- */
static void GetTTcmap2Stuff(
    void         *pTTcmap,
    TTcmap2Stuff *p2
    )
{
    if (pTTcmap == NULL)
        return;
    p2->pByte = (unsigned char *) pTTcmap;
    /* subHeaderKeys[256] starts at fourth WORD */
    p2->subHeaderKeys = (unsigned short *) (p2->pByte + 6);
    p2->subHeaders = (PTTcmap2SH)(p2->pByte + 6 + 2 * 256);
}

static void GetTTcmap4Stuff(
    void         *pTTcmap,
    TTcmap4Stuff *p4
    )
{
    unsigned short    *pWord;          /* a pointer in WORD format */
    if (pTTcmap == NULL)
        return;
    /* a convenient pointer */
    pWord = (unsigned short *)pTTcmap;
    /* fourth WORD is segCount X 2 */
    p4->segCount = (MOTOROLAINT(pWord[3]))/2;
    p4->endCode         = pWord + 7;
    p4->startCode       = pWord + 7 + p4->segCount * 1 + 1;
    p4->idDelta         = pWord + 7 + p4->segCount * 2 + 1;
    p4->idRangeOffset   = pWord + 7 + p4->segCount * 3 + 1;
    p4->glyphIdArray    = pWord + 7 + p4->segCount * 4 + 1;
}

static void GetTTmortStuff(
    void        *pTTmort,  /* mort table data */
    TTmortStuff *p
    )
{
    unsigned short *pWord;          /* a pointer in WORD format */

    if (pTTmort == NULL)
        return;
    /* a convenient pointer */
    pWord = (unsigned short *)pTTmort;
    /* 34th Word is the second Unit16 in the BinSrchHeader */
    p->nEntries = MOTOROLAINT(pWord[34]);
    /* LookupSingle starts at 77th byte - 38th Word */
    p->pGlyphSet = pWord + 38 ;
}

/* ------------------------------------------------------------- */
static void GetTTGSUBStuff(
    void        *pTTGSUB,  /* GSUB table data */
    TTGSUBStuff *p
    )
{
    unsigned short  *pWord;          /* a pointer in WORD format */
    unsigned short  offSet;

    if (pTTGSUB == NULL)
        return;
    /* a convenient pointer */
    pWord = (unsigned short *)pTTGSUB;
    /* fourth WORD is offset to LooupList */
    offSet = MOTOROLAINT(pWord[4]);
    p->pLookupList = (unsigned short *)((unsigned char *)pTTGSUB + offSet);
    p->lookupCount = MOTOROLAINT(p->pLookupList[0] );
}

/* ------------------------------------------------------------- */
/* This function is responsible for cmap, mort and GSUB */
unsigned short GetTablesFromTTFont(
    UFOStruct     *pUFObj
    )
{
    unsigned short  retVal = 0;
    unsigned long   dwSize, dwOffset, dwcmapSize;
    unsigned short  wData[4];
    unsigned short  numSubTables, index;
    PSubTableEntry  pTableEntry = NULL;
    unsigned long   cmapOffset;
    UFLBool         foundUnicodeCmap = 0;
    unsigned short  platformID, encodingID, format;
    AFontStruct     *pAFont;
    unsigned long   length;

    if (pUFObj == NULL)
        return 0;
    pAFont = pUFObj->pAFont;
    if (pAFont == NULL)
        return 0;

    /* Check if the cmap/mort/GSUB data is already in pTTFData */
    if (pAFont->gotTables)
        return 1;

    /* setup booleans - so we don't have to look into data for correctness */
    pAFont->hascmap = 0;
    pAFont->hasmort = 0;
    pAFont->hasGSUB = 0;
    pAFont->gsubTBSize = 0;
    pAFont->cmapTBSize = 0;
    pAFont->mortTBSize = 0;
    pAFont->gotTables = 1;

    /* Get cmap table */
    dwSize= GETTTFONTDATA(pUFObj,
        CMAP_TABLE,
        0,
        (void *) wData,
        4,
        pUFObj->pFData->fontIndex);

    if (dwSize==0 || dwSize==0xFFFFFFFFL)
    {
        goto exit0;     // no SubHeader !!!
    }

    /* usually 2 or 3 subTables */
    numSubTables = MOTOROLAINT(wData[1]);

    pTableEntry = UFLNewPtr(pUFObj->pMem, numSubTables * sizeof(SubTableEntry));

    if (pTableEntry == NULL)
        goto exit0;

    /**********************/
    /* Get cmap subtables */
    /**********************/
    dwSize= GETTTFONTDATA(pUFObj,
        CMAP_TABLE,
        4,                    // skip header
        (void *) pTableEntry,
        numSubTables * sizeof(SubTableEntry),
        pUFObj->pFData->fontIndex);

    if (dwSize==0 || dwSize==0xFFFFFFFFL)
    {
        goto exit0;          // no SubHeader !!!
    }

    /* We Prefer Unicode Encoding: PlatForm=3, Encoding = 1
     * Since the subtable entries are sorted by PlatformID and then EncodingID,
     * our searching is reallyg this order:
     * Mac:J->CT->K->CS, Win:Uni->J->CS->CT->K and we will stop if found Win:Uni
     * or the last one found (in the list) will be used.
     */
    foundUnicodeCmap = 0;
    cmapOffset = 0;
    for (index = 0; index < numSubTables && !foundUnicodeCmap; index++)
    {
        platformID = MOTOROLAINT((pTableEntry + index)->platformID);
        encodingID = MOTOROLAINT((pTableEntry + index)->encodingID);
        dwOffset   = MOTOROLALONG((pTableEntry + index)->offset);
        if (platformID != 3)
            continue;

        /* Get cmap subtable's format - first USHORT at Table->offset */
        dwSize= GETTTFONTDATA(pUFObj,
            CMAP_TABLE,
            dwOffset,
            (void *) &(wData[0]),
            4,
            pUFObj->pFData->fontIndex);

        if (dwSize == 0 || dwSize == 0xFFFFFFFF)
            continue;
        format = MOTOROLAINT(wData[0]);
        length = MOTOROLAINT(wData[1]);
        /* we only parse format 2 or 4 for now */
        if (format != 2 && format !=4)
            continue;

        switch(encodingID)
        {
        case 1:
            if (format == 2)
                pAFont->cmapFormat = DTT_Win_UNICODE_cmap2;
            else /* must be 4 */
                pAFont->cmapFormat = DTT_Win_UNICODE_cmap4;
            cmapOffset = dwOffset;
            dwcmapSize = length;
            foundUnicodeCmap = 1;
            break;
        case 2:
            if (format == 2)
                pAFont->cmapFormat = DTT_Win_J_cmap2;
            else /* must be 4 */
                pAFont->cmapFormat = DTT_Win_J_cmap4;
            cmapOffset = dwOffset;
            dwcmapSize = length;
            break;
        case 3:
            /* PRC- TTF docs says Big5, but Win95CT's minglu.ttc is Big5, has encodingdID=4 */
            if (format == 2)
                pAFont->cmapFormat = DTT_Win_CS_cmap2;
            else /* must be 4 */
                pAFont->cmapFormat = DTT_Win_CS_cmap4;
            cmapOffset = dwOffset;
            dwcmapSize = length;
            break;
        case 4:
            /* MingLi.ttc on Win95CT has EncodiingID 4 even though TTF Doc says should be 3 */
            if (format == 2)
                pAFont->cmapFormat = DTT_Win_CT_cmap2;
            else /* must be 4 */
                pAFont->cmapFormat = DTT_Win_CT_cmap4;
            cmapOffset = dwOffset;
            dwcmapSize = length;
            break;
        case 5:
            if (format == 2)
                pAFont->cmapFormat = DTT_Win_K_cmap2;
            else /* must be 4 */
                pAFont->cmapFormat = DTT_Win_K_cmap4;
            cmapOffset = dwOffset;
            dwcmapSize = length;
            break;
        default:
            break;
        }
    }

    if (cmapOffset == 0)
        goto exit0;

     /* Some TTFs have bad dwcmapSize (wData[1]), so far only Dfgihi7.ttc
     * (see bug 289106) has 4 bytes more than dwcmapSize.
     * Since we don't want to inspect the tables' relationships to get
     * the real length at this late stage (1-14-99), we just read
     * in 8 bytes more.
     * If these 8 bytes are not used, it doesn't hurt any one.
     * If they are use as in dfgihi.ttc, we fix 289106 */
     dwcmapSize += 8;

    /* next buffer is global cache - not freed per job */
    pAFont->pTTcmap = UFLNewPtr(pUFObj->pMem, dwcmapSize );
    if (pAFont->pTTcmap == NULL)
        goto exit0;

    /* Get this cmap subtable data */
    dwSize= GETTTFONTDATA(pUFObj,
        CMAP_TABLE,
        cmapOffset,
        (void *) pAFont->pTTcmap,
        dwcmapSize,
        pUFObj->pFData->fontIndex);

    if (dwSize > 0 && dwSize < 0xFFFFFFFF)
    {
        pAFont->hascmap = 1;
        pAFont->cmapTBSize = dwcmapSize;

        /* Set the convenient pointers */
        if (TTcmap_IS_FORMAT2(pAFont->cmapFormat))
            GetTTcmap2Stuff(pAFont->pTTcmap, &(pAFont->cmap2) );
        else /* must be 4 */
            GetTTcmap4Stuff(pAFont->pTTcmap, &(pAFont->cmap4) );
        retVal = 1; /* finally success */
    }
    else
    {
        goto exit0;
    }

    /* Continue to get GSUB and mort only if we have Unicode/CJK cmap */
    if (retVal == 0)
        goto exit0;

    /**********************/
    /*   get mort table   */
    /**********************/
    dwSize= GETTTFONTDATA(pUFObj,
        MORT_TABLE,
        0,
        NULL,       /* use NULL to ask for size first */
        0,
        pUFObj->pFData->fontIndex);

    if (dwSize > mort_HEADERSIZE && dwSize < 0xFFFFFFFF)
    {
        /* Has "mort" in this font  - it is Optional */
        /* next buffer is global cache - not freed per job */
        pAFont->pTTmort = UFLNewPtr(pUFObj->pMem, dwSize );
        if (pAFont->pTTmort != NULL)
        {
            /* Get the mort table data */
            dwSize= GETTTFONTDATA(pUFObj,
                MORT_TABLE,
                0,
                (void *) pAFont->pTTmort,
                dwSize,
                pUFObj->pFData->fontIndex);

            if (dwSize > mort_HEADERSIZE && dwSize < 0xFFFFFFFF)
            {
                pAFont->hasmort = 1;
                pAFont->mortTBSize = dwSize;
                /* Set the convenient pointers */
                GetTTmortStuff(pAFont->pTTmort, &(pAFont->mortStuff) );
            }
        }
    }

    /**********************/
    /*   get GSUB table   */
    /**********************/
    dwSize= GETTTFONTDATA(pUFObj,
        GSUB_TABLE,
        0,
        NULL,       /* use NULL to ask for size first */
        0,
        pUFObj->pFData->fontIndex);

    if (dwSize > GSUB_HEADERSIZE && dwSize < 0xFFFFFFFF)
    {
        /* Has "GSUB" in this font  - it is Optional */
        /* next buffer is global cache - not freed per job */
        pAFont->pTTGSUB = UFLNewPtr(pUFObj->pMem, dwSize );
        if (pAFont->pTTGSUB != NULL)
        {
            /* Get the GSUB table data */
            dwSize= GETTTFONTDATA(pUFObj,
                GSUB_TABLE,
                0,
                (void *) pAFont->pTTGSUB,
                dwSize,
                pUFObj->pFData->fontIndex);

            if (dwSize > GSUB_HEADERSIZE && dwSize < 0xFFFFFFFF)
            {
                pAFont->hasGSUB = 1;
                pAFont->gsubTBSize = dwSize;
                /* Set the convenient pointers */
                GetTTGSUBStuff(pAFont->pTTGSUB, &(pAFont->GSUBStuff) );
            }
        }
    }

exit0:
    if (pTableEntry)
        UFLDeletePtr(pUFObj->pMem, pTableEntry);

    return retVal;
}

static unsigned short ParseTTcmap2(
    TTcmap2Stuff    *p2 ,      /* all convenient pointers are here */
    unsigned char   *pTTCMAPEnd,
    unsigned short  gid
    )
{
    unsigned short  codeVal;
    unsigned short  index;
    unsigned short  subHdrKey;
    PTTcmap2SH      pSubHeader;
    unsigned short  highByte, first, count, byteOffset, id;
    short           delta;
    unsigned short  *pTemp;

    /* This function parses cmap Format 2: High-byte mapping through table
       Win 3-(1/2/3/4/5)-2
     */
    codeVal = 0;

    if (((unsigned char *)(p2->subHeaderKeys) < (unsigned char *)(p2->pByte)) ||
        ((unsigned char *)(p2->subHeaderKeys + 256) > pTTCMAPEnd))
        return codeVal;

    /* Search subHeaders one by one:
      subHeader 0 is special: it is used for single-byte character codes,
      Other highByte mapped to subHeader 0 should be ignored
    */
    for (highByte = 0; highByte<256; highByte++)
    {
        subHdrKey = MOTOROLAINT(p2->subHeaderKeys[highByte]);
        if (highByte != 0 && subHdrKey == 0 )
            continue;

        pSubHeader = p2->subHeaders + (subHdrKey / 8);

        if (((unsigned char *)(pSubHeader) < (unsigned char *)(p2->pByte)) ||
		    ((unsigned char *)(pSubHeader + 1) > pTTCMAPEnd))
		    continue;

        first = MOTOROLAINT(pSubHeader->firstCode);
        count = MOTOROLAINT(pSubHeader->entryCount);
        delta = MOTOROLAINT(pSubHeader->idDelta);
        byteOffset = MOTOROLAINT(pSubHeader->idRangeOffset);

        /* How to use idRangeOffset? The document says:
         "The value of the idRangeOffset is the number of bytes
         past the actual location of the idRangeOffset word where
         the glyphIndexArray element corresponding to firstCode appears"
         *
         Parsing cmap == parsing these words carefully (trial-and-error)!
         Offset to idRangeOffset is 524 + subHdrKey - now we know why subHdrKey is i*8 */
        byteOffset += 524 + subHdrKey ;

        for (index = 0; index < count; index++)
        {
            pTemp = (unsigned short *) (p2->pByte + byteOffset + 2 * index);
            if (((unsigned char *)pTemp < (unsigned char *)(p2->pByte)) ||
	            ((unsigned char *)pTemp > pTTCMAPEnd))
		        continue;

            id = *(pTemp);
            id = MOTOROLAINT(id);
            if (id == 0)
                continue;
            id += delta ;
            if (id == gid)
            {
                codeVal = (highByte << 8) + index + first ;
                return codeVal;
            }
        }
    }

    return codeVal;
}

static unsigned short ParseTTcmap4(
    TTcmap4Stuff      *p4 ,      /* all convenient pointers are here */
    unsigned char     *pTTCMAP,
    unsigned char     *pTTCMAPEnd,
    unsigned short    gid
    )
{
    unsigned short    codeVal;
    long              index, j, k, rangeNum;
    unsigned short    gidStart, gidEnd;
    unsigned short    n1, n2;

    /* This function parses cmap Format 4: Segment mapping to delta values
       Win 3-(1/2/3/4/5)-4
     */
    codeVal = 0;
    if (((unsigned char *)(p4->idRangeOffset) < pTTCMAP) ||
       ((unsigned char *)(p4->idRangeOffset + p4->segCount) > pTTCMAPEnd))
        return codeVal;
    if (((unsigned char *)(p4->startCode) < pTTCMAP) ||
       ((unsigned char *)(p4->startCode + p4->segCount) > pTTCMAPEnd))
        return codeVal;
    if (((unsigned char *)(p4->idDelta) < pTTCMAP) ||
       ((unsigned char *)(p4->idDelta + p4->segCount) > pTTCMAPEnd))
        return codeVal;
    if (((unsigned char *)(p4->endCode) < pTTCMAP) ||
       ((unsigned char *)(p4->endCode + p4->segCount) > pTTCMAPEnd))
        return codeVal;

    /* Search for segments with idRangeOffset[i] =0 */
    for (index = 0; index <= (long)p4->segCount; index++)
    {
        if (p4->idRangeOffset[index] != 0)
            continue;

        gidStart = MOTOROLAINT(p4->idDelta[index]) + MOTOROLAINT(p4->startCode[index]);
        gidEnd = MOTOROLAINT(p4->idDelta[index]) + MOTOROLAINT(p4->endCode[index]);

        if (gidStart <= gid &&
            gidEnd >= gid)
        {
            codeVal = gid - MOTOROLAINT(p4->idDelta[index]);
            return codeVal;
        }
    }

    /* Still not found, Search for segments with idRangeOffset[i] !=0 */
    for (index = 0; index <= (long)p4->segCount; index++)
    {
        if (p4->idRangeOffset[index] == 0)
            continue;

        n1 = MOTOROLAINT(p4->startCode[index]);
        n2 = MOTOROLAINT(p4->endCode[index]);
        rangeNum = n2 - n1;
        /* check for End of cmap - fix bug 261628 */
        if (n1 == 0xFFFF)
            break;
        /* check for Bad cmap */
        if (n1 > n2)
            break;

        /* have to check one-by-one */
        for (j = 0; j <= rangeNum; j++)
        {
            /* Word index to glyphIDArray */
            k = j + MOTOROLAINT(p4->idRangeOffset[index]) / 2 - p4->segCount + index ;
            gidStart = MOTOROLAINT(p4->glyphIdArray[k]);

            if (gidStart != 0)
            {
                gidStart += MOTOROLAINT(p4->idDelta[index]);
                if (gidStart == gid)
                {
                    codeVal = MOTOROLAINT(p4->startCode[index]) + (unsigned short)j;
                    return codeVal;
                }
            }
        }
    }

    return codeVal;
}

static unsigned short ParseTTcmapForUnicode(
    AFontStruct     *pAFont,
    unsigned short  gid,
    unsigned short  *pUV,
    unsigned short  wSize
    )
{
    unsigned short     codeVal;
    unsigned char      *pTTCMAPEnd;

    pTTCMAPEnd = ((unsigned char *)pAFont->pTTcmap) + pAFont->cmapTBSize;

    /* Find code point for the glyph id by reversing cmap */
    if (TTcmap_IS_FORMAT2(pAFont->cmapFormat))
        codeVal = ParseTTcmap2(&(pAFont->cmap2), pTTCMAPEnd, gid);
    else /* must be 4 */
        codeVal = ParseTTcmap4(&(pAFont->cmap4), pAFont->pTTcmap, pTTCMAPEnd, gid);

    if (codeVal == 0)
        return 0;

    /* found corresponding code - convert to Unicode if code is not Unicode*/
    *pUV = codeVal;
    return 1;
}

/* ------------------------------------------------------------------ */
/* Coverage Table:
CoverageFormat1 table: Individual glyph indices
Type    Name        Description
uint16 CoverageFormat Format identifier format = 1
uint16 GlyphCount Number of glyphs in the GlyphArray
GlyphID GlyphArray[GlyphCount] Array of GlyphIDs  in numerical order

CoverageFormat2 table: Range of glyphs
Type    Name    Description
uint16 CoverageFormat Format identifier format = 2
uint16 RangeCount Number of RangeRecords
struct RangeRecord[RangeCount] Array of glyph ranges  ordered by Start GlyphID

RangeRecord
Type    Name    Description
GlyphID Start   First GlyphID in the range
GlyphID End     Last GlyphID in the range
uint16  StartCoverageIndex Coverage Index of first GlyphID in range
*/
/* A lcoal function to enumerate/parse Coverage table used in GSUB:
 * gid0          - starting point for next covered Gid;
 *        it is also used as state variable, 0 at beginning.
 * gidInput      - one gid Covered >= gid; 0xFFFF when there is no such gid
 * coverageIndex - Coverage Index for gidIn
 * return: true if there are more glyphs covered
 */
static UFLBool EnumTTCoverage(
    void           *pCoverage,     /* Coverage table */
    unsigned char  *pTTGSUBEnd,
    unsigned short gid0,           /* start */
    unsigned short *gidInput,      /* gid covered */
    unsigned short *coverageIndex  /* corresponding Index */
    )
{
    unsigned short *pWord;
    unsigned short cFormat, gCount, gid;
    unsigned short *pGid;
    long           index;

    if (pCoverage == NULL || gid0 == 0xFFFF)
        return 0;

	// pCoverage is a good pointer, it has been checked begore calling this function
    pWord = (unsigned short *) pCoverage;
    cFormat = MOTOROLAINT(pWord[0]);
    gCount = MOTOROLAINT(pWord[1]); /* count of Glyph or ranGes */
    pGid = (unsigned short *)((unsigned char *)pCoverage + 4);

    /* find next gid >= gid0 -- Coverage is ordered! */
    if (cFormat == 1)
    {
        // Fixed bug #516519
        if ((unsigned char *)(pGid + gCount) > pTTGSUBEnd)
            goto Done;

        /* List format, pGid points to GlyphArray and coverageIndex starts from 0 */
        for (index = 0; index < (long)gCount; index++ )
        {
            gid = MOTOROLAINT(pGid[index]);
            if (gid >= gid0)
            {
                *gidInput = gid;
                *coverageIndex = (unsigned short)index;
                return 1;
            }
        }
    }
    else if (cFormat == 2)
    {
        /* Range format, pGid points to first RangeRecord */
        unsigned short  gidStart, gidEnd, startCoverageIndex;

        // Fixed bug #516519
        if ((unsigned char *)(pGid + gCount*3) > pTTGSUBEnd)
            goto Done;

        for (index = 0; index < (long)gCount; index++ )
        {
            gidStart = MOTOROLAINT(pGid[0]);
            gidEnd = MOTOROLAINT(pGid[1]);
            startCoverageIndex = MOTOROLAINT(pGid[2]);
            /* first if gid0==0 */
            if (gid0 == 0)
            {
                if ( index == 0 )
                {
                    *gidInput = gidStart;
                    *coverageIndex = startCoverageIndex;
                    return 1;
                }
            }
            /* find the first range that covers gid0 */
            else if (gid0 >= gidStart && gid0 <= gidEnd )
            {
                *gidInput = gid0;
                *coverageIndex = startCoverageIndex + gid0 - gidStart;
                return 1;
            }
            pGid += 3; /* Each RangeRecord is 3 ASUns16 */
        }
    }
    /* else don't know or new format */
Done:
    *gidInput = 0xFFFF;
    *coverageIndex = 0xFFFF;
    return 0;
}


/* ------------------------------------------------------------------ */
/* SingleSubstitution Table
SingleSubstFormat1 subtable: Calculated output glyph indices
Type    Name        Description
uint16  SubstFormat Format identifier-format = 1
Offset  Coverage    Offset to Coverage table-from beginning of substitution table
int16   DeltaGlyphID Add to original GlyphID to get substitute GlyphID

SingleSubstFormat2 subtable: Specified output glyph indices
Type    Name        Description
uint16  SubstFormat Format identifier-format = 2
Offset  Coverage    Offset to Coverage table-from beginning of Substitution table
uint16  GlyphCount  Number of GlyphIDs in the Substitute array
GlyphID Substitute[GlyphCount] Array of substitute GlyphIDs
  -ordered by Coverage Index
*/
 /* A local function to parse Substitution Table Format 1
  * have to linear search - we are doing reverse mapping from
  * the substitutedGID to original gid
  */
static unsigned short ParseTTSubstTable_1(
    void            *pSubstTable,  /* Subst table data */
    unsigned char   *pTTGSUBEnd,
    unsigned short  gid,           /* Given GID */
    unsigned short  *pRSubGid      /* Reverse Substitution */
    )
{
    unsigned short  *pTable;
    void            *pCoverage;
    unsigned short  substFormat;
    unsigned short  offSet;
    unsigned short  gidIn, coverageIndex;

    // pTable is a good pointer, it has been checked begore calling this function
    pTable = (unsigned short *)(pSubstTable);

    /* pTable points to either SingleSubstFormat1 or SingleSubstFormat2 */
    substFormat = MOTOROLAINT(pTable[0]);
    offSet = MOTOROLAINT(pTable[1]);
    pCoverage = (void *) ((unsigned char *)pSubstTable + offSet );

    // Fixed bug #516519. 
    // Check to make sure pConverage is good. It is used in function EnumTTCoverage
    if (((unsigned char *)pCoverage < (unsigned char *)pSubstTable) ||
        ((unsigned char *)pCoverage + 3*sizeof(unsigned short)) > pTTGSUBEnd)
    {
        return 0;            
    }

    if (substFormat == 1 )
    {
        unsigned short delta = MOTOROLAINT(pTable[2]);
        gidIn = 0;
        coverageIndex = 0;
        while (EnumTTCoverage(pCoverage, pTTGSUBEnd, gidIn, &gidIn, &coverageIndex) )
        {
            if (gid == gidIn + delta)
            {
                /* gidIn may be substituted by gid in the PS file, return the reverseSubstituiton */
                *pRSubGid = gidIn;
                return 1;
            }
            gidIn++;  /* For EnumTTCoverage() */
        }
        return 0;
    }
    else if (substFormat == 2 )
    {
        unsigned short count, gidSub;
        count = MOTOROLAINT(pTable[2]);
        gidIn = 0;
        coverageIndex = 0;
        while (EnumTTCoverage(pCoverage, pTTGSUBEnd, gidIn, &gidIn, &coverageIndex) )
        {
            if (coverageIndex < count)
            {
                gidSub = MOTOROLAINT(pTable[ 3 + coverageIndex]);
                if (gid == gidSub)
                {
                    /* gidIn may be substituted by gid in the PS file, return the reverseSubstituiton */
                    *pRSubGid = gidIn;
                    return 1;
                }
            }
            gidIn++;  /* For EnumTTCoverage() */
        }
        return 0;
    }
    /* else unknow or not found */
    return 0;
}


/* ------------------------------------------------------------------ */
/*
  AlternateSubstFormat1 subtable: Alternative output glyphs
Type    Name        Description
uint16  SubstFormat Format identifier-format = 1
Offset  Coverage    Offset to Coverage table-from beginning of Substitution table
uint16 AlternateSetCount Number of AlternateSet tables
Offset AlternateSet[AlternateSetCount] Array of offsets to AlternateSet tables
 -from beginning of Substitution table-ordered by Coverage Index

  AlternateSet table
Type    Name        Description
uint16  GlyphCount   Number of GlyphIDs in the Alternate array
GlyphID Alternate[GlyphCount] Array of alternate GlyphIDs-in arbitrary order
*/
 /* A local function to parse Substitution Table Format 1
  * have to linear search - we are doing reverse mapping from
  * the substitutedGID to original gid
  */
static unsigned short ParseTTSubstTable_3(
    void            *pSubstTable,  /* Subst table data */
    unsigned char   *pTTGSUBEnd,
    unsigned short  gid,           /* Given GID */
    unsigned short  *pRSubGid      /* Reverse Substitution */
    )
{
    unsigned short  *pTable;
    void            *pCoverage;
    unsigned short  substFormat;
    unsigned short  offSet, altCount;
    unsigned short  gidIn, coverageIndex;
    unsigned short  *pAlt;

    // pTable is a good pointer, it has been checked begore calling this function
    pTable = (unsigned short *)(pSubstTable);
    /* pTable points to AlternateSubstFormat1 */
    substFormat = MOTOROLAINT(pTable[0]);
    offSet = MOTOROLAINT(pTable[1]);
    pCoverage = (void *) ((unsigned char *)pSubstTable + offSet );

    // Fixed bug #516519
    // Check to make sure pConverage is good. It is used in function EnumTTCoverage
    if (((unsigned char *)pCoverage < (unsigned char *)pSubstTable) ||
        ((unsigned char *)pCoverage + 3*sizeof(unsigned short)) > pTTGSUBEnd)
    {
        return 0;            
    }

    altCount = MOTOROLAINT(pTable[2]);
    if (substFormat == 1 )
    {
        unsigned short index, gCount, gidAlt;
        gidIn = 0;
        coverageIndex = 0;
        while (EnumTTCoverage(pCoverage, pTTGSUBEnd, gidIn, &gidIn, &coverageIndex) )
        {
            if (coverageIndex < altCount)
            {
                /* For each gidIn, we have an array of alternates */
                offSet = MOTOROLAINT(pTable[3 + coverageIndex] );
                pAlt = (unsigned short *) ((unsigned char *)pSubstTable + offSet );
                gCount = MOTOROLAINT(pAlt[0]);
                for (index = 0; index < gCount; index++)
                {
                    gidAlt = MOTOROLAINT(pAlt[1 + index]);
                    if (gidAlt == gid)
                    {
                        /* gidIn may be substituted by gid in the PS file, return the reverseSubstituiton */
                        *pRSubGid = gidIn;
                        return 1;
                    }
                }
            }
            gidIn++;  /* For EnumTTCoverage() */
        }
        return 0;
    }
    /* else unknow or not found */
    return 0;
}

/* ------------------------------------------------------------------ */
/* Function to parse GSUB table. Since we only want the substituted glyph index
 * to parse cmap for Unicode information, we don't have to look at
 * ScriptList/FeatureList. For LookUpTypes, we only check 1-1 substitution:
 * -Single- replace one glyph with another ,and
 * -Alternate- replace one glyph with one of many glyphs
 * Ignore Multple/Ligature/Context - are they for a text layout only???
 *
GSUB Header (Offset = uint16)
Type Name Description
fixed32 Version Version of the GSUB table
  initially set to 0x00010000
Offset ScriptList Offset to ScriptList table
  from beginning of GSUB table
Offset FeatureList Offset to FeatureList table
  from beginning of GSUB table
Offset LookupList Offset to LookupList table
  from beginning of GSUB table

Lookup List:
Type   Name        Description
uint16 LookupCount Number of lookups in this table
Offset Lookup[LookupCount] Array of offsets to Lookup tables
         from beginning of LookupList (first lookup is Lookup index = 0)

Lookup Table
Type   Name    Description
uint16 LookupType Different enumerations for GSUB
uint16 LookupFlag Lookup qualifiers
uint16 SubTableCount Number of SubTables for this lookup
Offset SubTable[SubTableCount] Array of offsets to SubTables
        from beginning of Lookup table
*/

static unsigned short ParseTTGSUBForSubGid(
    void             *pTTGSUB,   /* GSUB table data */
    unsigned long    gsubTBSize,
    TTGSUBStuff      *p,
    unsigned short   gid,        /* Given GID */
    unsigned short   *pRSubGid   /* Reverse Substitution */
    )
{
    unsigned short  lookupType;
    unsigned short  subTableCount;
    long            i, j;
    unsigned short  offSet;
    unsigned short  *pTable;
    void            *pSubstTable;
    unsigned char   *pTTGSUBEnd;

    if (pTTGSUB == NULL || gid == 0 || p == NULL )
        return 0;

    // Fixed bug #516519. 
    // Check to see if pointer p and lookup array are whthin GSUB table
    pTTGSUBEnd = (unsigned char *)pTTGSUB + gsubTBSize;
    if (((unsigned char *)p < (unsigned char *)pTTGSUB) ||
        ((unsigned char *)p + sizeof(unsigned short) * p->lookupCount) > pTTGSUBEnd)
    {
        return 0;
    }

    /* GSUB must be good - should check for pTTFData->hasGSUB first  */

    /* now look through the lookup tables one by one */
    for (i = 0; i < (long)p->lookupCount; i++)
    {
        offSet = MOTOROLAINT(p->pLookupList[1 + i]); /* skip lookupCount */
        pTable = (unsigned short *)((unsigned char *)p->pLookupList + offSet);

        // Fixed bug #516519. 
        // check to see if the offset is within the gsub table.
        // Add 3 to make sure we can get pTable[0],pTable[1],pTable[2] (see code right below)
        if (((unsigned char *)pTable < (unsigned char *)pTTGSUB) ||
            ((unsigned char *)(pTable + 3) > pTTGSUBEnd))
        {
            continue;            
        }

        lookupType = MOTOROLAINT(pTable[0]);
        subTableCount = MOTOROLAINT(pTable[2]);
        
        // Fixed bug #516519
        if ((unsigned char *)(pTable + subTableCount + 3) > pTTGSUBEnd)
        {
            continue;            
        }

        /* Only parse Type Single(1) and Alternate(3) tables */
        if (lookupType == 1 )
        {
            for (j = 0; j < (long)subTableCount; j++)
            {
                offSet = MOTOROLAINT(pTable[3 + j]);
                pSubstTable = (void *) ((unsigned char *)pTable + offSet );
                
                // Fixed bug #516519.
                // add 6 bytes (3*sizeof(ushort)) to make sure we can get Table[0..2]
                // Please see ParseTTSubstTable_1
                if (((unsigned char *)pSubstTable < (unsigned char*)pTTGSUB) ||
                    (((unsigned char *)pSubstTable + 3*sizeof(unsigned short)) > pTTGSUBEnd))
                {
                    continue;            
                }

                if (ParseTTSubstTable_1(pSubstTable, pTTGSUBEnd, gid, pRSubGid) )
                    return 1;
            }
        }
        else if (lookupType == 3)
        {
            for (j = 0; j < (long) subTableCount; j++)
            {
                offSet = MOTOROLAINT(pTable[3 + j]);
                pSubstTable = (void *) ((unsigned char *)pTable + offSet );

                // Fixed bug #516519
                if (((unsigned char *)pSubstTable < (unsigned char *) pTTGSUB) ||
                    (((unsigned char *)pSubstTable + 3*sizeof(unsigned short)) > pTTGSUBEnd))
                {
                    continue;            
                }

                if (ParseTTSubstTable_3(pSubstTable, pTTGSUBEnd, gid, pRSubGid) )
                    return 1;
            }
        }
        /* else - ignore other Substitutions */
    }
    /* not found */
    return 0;
}


/* ------------------------------------------------------------------ */
/* Function to parse mort table. We recognize only a very specific
 implementation of 'mort' as used/understood by GDI:
Name        Contents
(constants) 0x000100000000000100000001
Uint32      length1 Length of the whole table - 8
(constants) 0x000300010003000000000001FFFFFFFF
(constants) 0x0003000100000000FFFFFFFE00080000
(constants) 0x0000000000000000
Uint16      length2 Length of the whole table - 0x38
(constants) 0x8004000000010006
BinSrchHeader binSrchHeader Binary Search Header
LookupSingle entries[n] Actual lookup entries, sorted by glyph index

BinSrchHeader
Type    Name        Contents
Uint16 entrySize    Size in bytes of a lookup entry (set to 4)
Uint16 nEntries     Number of lookup entries to be searched
Uint16 searchRange  entrySize * (largest power of 2 less than or equal to nEntries)
Uint16 entrySelector log2 of (largest power of 2 less than or equal to nEntries)
Uint16 rangeShift   entrySize * (nEntries - largest power of 2 less than or equal to nEntries)

LookupSingle
Type    Name        Contents
GlyphID glyphid1    The glyph index for the horizontal shape
GlyphID glyphid2    The glyph index for the vertical shape
The last lookup entry must be a sentinel with glyphid1=glyphid2=0xFFFF.
*/
static unsigned short ParseTTmortForSubGid(
    void             *pTTmort,  /* mort table data */
    unsigned long    mortTBSize,
    TTmortStuff      *p,        /* all convenient pointers are here */
    unsigned short   gid,       /* Given GID */
    unsigned short   *pRSubGid  /* Reverse Substitution */
    )
{
    unsigned short   gid1, gid2;
    long             i;

    if (pTTmort == NULL || gid == 0 || p == NULL)
        return 0;

    // Fixed bug #516519. 
    // Check to see if pointer p and lookup array are whthin MORT table
    if (((unsigned char *)p < (unsigned char *)pTTmort) ||
        ((unsigned char *)p + sizeof(unsigned short) * 2 * p->nEntries) > ((unsigned char *)pTTmort + mortTBSize))
    {
        return 0;
    }

    /* mort must be good - should check for pTTFData->hasmort first  */

    /* Search for gid - we do linear search because 'mort'
     table is usually for vertical substitution and we want the
     original Horizontal gid for a given Vertical gid
    */
    for (i = 0; i <= (long) p->nEntries; i++)
    {
        gid1 = MOTOROLAINT(p->pGlyphSet[i * 2]);
        gid2 = MOTOROLAINT(p->pGlyphSet[i * 2 + 1]);

        if (gid1 == 0xFFFF && gid2 == 0xFFFF)
            break;

        if (gid2 == gid)
        {
            *pRSubGid = gid1;
            return 1;
        }
    }
    /* not found */
    return 0;
}

/* ------------------------------------------------------------------ */
unsigned short ParseTTTablesForUnicode(
    UFOStruct       *pUFObj,
    unsigned short  gid,
    unsigned short  *pUV,
    unsigned short  wSize,
    TTparseFlag     ParseFlag
    )
{
    AFontStruct     *pAFont;
    unsigned short  retVal = 0;
    unsigned short  gidSave;
    unsigned short  i;

    *pUV = 0;
    if (pUFObj == NULL)
        return 0;
    pAFont = pUFObj->pAFont;
    if (pAFont == NULL)
        return 0;

    /* This function only get at most 1 UV for a glyph ID */
    if (pUV == NULL)
        return 1;

    if (!GetTablesFromTTFont(pUFObj))
        return 0;

    /* This function depends on good cmap format:
       Platform=3, Encoding=1/2/3/4/5, Format=4 */
    if (pAFont->pTTcmap == NULL ||
        pAFont->hascmap == 0 ||
        gid == 0 )
        return 0;

    /* if DTT_parseCmapOnly flag is set, means that
    /* we need unicode only. do not need char code */
    if ((ParseFlag == DTT_parseCmapOnly) &&
        (!TTcmap_IS_UNICODE(pAFont->cmapFormat)))
        return 0;

    if ((ParseFlag == DTT_parseCmapOnly) ||
        (ParseFlag == DTT_parseAllTables))
    {
        retVal = ParseTTcmapForUnicode(pAFont, gid, pUV, wSize);
    }
    if ((retVal == 0) && (pAFont->hasmort || pAFont->hasGSUB) &&
        ((ParseFlag == DTT_parseMoreGSUBOnly) ||
        (ParseFlag == DTT_parseAllTables)))
    {
        unsigned short revSubGid;
        unsigned short hasSub;

        /* Still not found, try GSUB table */
        if (retVal == 0 && pAFont->hasGSUB )
        {
            gidSave = gid;
            for (i = 0; i < 10; i++)  // Loop Max 10 times.
            {
                hasSub = ParseTTGSUBForSubGid(pAFont->pTTGSUB, pAFont->gsubTBSize, &(pAFont->GSUBStuff), gid, &revSubGid);
                if (hasSub)
                {
                    retVal = ParseTTcmapForUnicode(pAFont, revSubGid, pUV, wSize);
                    if (retVal != 0)
                        break;
                    else
                        gid = revSubGid;
                }
                else
                    break;
            }
            gid = gidSave;
        }

        /* try mort table for substitution (reverse searching) */
        if (retVal == 0 && pAFont->hasmort)
        {
            hasSub = ParseTTmortForSubGid(pAFont->pTTmort, pAFont->mortTBSize, &(pAFont->mortStuff), gid, &revSubGid);
            if (hasSub)
            {
                retVal = ParseTTcmapForUnicode(pAFont, revSubGid, pUV, wSize);
            }
        }
    }
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\parsett.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    ParseTT.c
 *
 *
 * $Header:
 */


/*=============================================================================*
 * Include files used by this interface                                        *
 *=============================================================================*/
#include "UFLPriv.h"
#include "ParseTT.h"
#include "UFOT42.h"
#include "UFLMem.h"
#include "UFLMath.h"
#include "UFLStd.h"
#include "UFLErr.h"
#include "UFLPS.h"
#include "ttformat.h"


/******************************************************************************

                            'cmap' table defintion
                            - from TTF format spec -

This table defines the mapping of character codes to the glyph index values
used in the font. It may contain more than one subtable, in order to support
more than one character encoding scheme. Character codes that do not correspond
to any glyph in the font should be mapped to glyph index 0. The glyph at this
location must be a special glyph representing a missing character.

The table header indicates the character encodings for which subtables are
present. Each subtable is in one of four possible formats and begins with a
format code indicating the format used.

The platform ID and platform-specific encoding ID are used to specify the
subtable; this means that each platform ID/platform-specific encoding ID pair
may only appear once in the cmap table. Each subtable can specify a different
character encoding. (See the 'name' table section). The entries must be sorted
first by platform ID and then by platform-specific encoding ID.

When building a Unicode font for Windows, the platform ID should be 3 and the
encoding ID should be 1. When building a symbol font for Windows, the platform
ID should be 3 and the encoding ID should be 0. When building a font that will
be used on the Macintosh, the platform ID should be 1 and the encoding ID
should be 0.

All Microsoft Unicode encodings (Platform ID = 3, Encoding ID = 1) must use
Format 4 for their 'cmap' subtable. Microsoft strongly recommends using a
Unicode 'cmap' for all fonts. However, some other encodings that appear in
current fonts follow:

    Platform ID     Encoding ID     Description
    1               0               Mac
    3               0               Symbol
    3               1               Unicode
    3               2               ShiftJIS
    3               3               Big5
    3               4               PRC
    3               5               Wansung
    3               6               Johab

The Character To Glyph Index Mapping Table is organized as follows:

    Type    Description
    USHORT  Table version number (0).
    USHORT  Number of encoding tables, n.

This is followed by an entry for each of the n encoding table specifying the
particular encoding, and the offset to the actual subtable:

    Type    Description

    USHORT  Platform ID.
    USHORT  Platform-specific encoding ID.
    ULONG   Byte offset from beginning of table to the subtable for this
            encoding.


Format 0: Byte encoding table
===============================================================================
This is the Apple standard character to glyph index mapping table.

    Type    Name                Description
    USHORT  format              Format number is set to 0.
    USHORT  length              This is the length in bytes of the subtable.
    USHORT  version             Version number (starts at 0).
    BYTE    glyphIdArray[256]   An array that maps character codes to glyph index
                                values.

This is a simple 1 to 1 mapping of character codes to glyph indices. The glyph
set is limited to 256. Note that if this format is used to index into a larger
glyph set, only the first 256 glyphs will be accessible.


Format 2: High-byte mapping through table
===============================================================================
This subtable is useful for the national character code standards used for
Japanese, Chinese, and Korean characters. These code standards use a mixed
8/16-bit encoding, in which certain byte values signal the first byte of a
2-byte character (but these values are also legal as the second byte of a
2-byte character). Character codes are always 1-byte. The glyph set is limited
to 256. In addition, even for the 2-byte characters, the mapping of character
codes to glyph index values depends heavily on the first byte. Consequently,
the table begins with an array that maps the first byte to a 4-word subHeader.
For 2-byte character codes, the subHeader is used to map the second byte's
value through a subArray, as described below. When processing mixed 8/16-bit
text, subHeader 0 is special: it is used for single-byte character codes.
When subHeader zero is used, a second byte is not needed; the single byte
value is mapped through the subArray.

    Type    Name                Description
    USHORT  format              Format number is set to 2.
    USHORT  length              Length in bytes.
    USHORT  version             Version number (starts at 0)
    USHORT  subHeaderKeys[256]  Array that maps high bytes to subHeaders:
                                value is subHeader index * 8.
    4 words struct subHeaders[] Variable-length array of subHeader structures.
    4 words-struct subHeaders[]
    USHORT  glyphIndexArray[ ]  Variable-length array containing subarrays used
                                for mapping the low byte of 2-byte characters.

A subHeader is structured as follows:

    Type    Name            Description
    USHORT  firstCode       First valid low byte for this subHeader.
    USHORT  entryCount      Number of valid low bytes for this subHeader.
    SHORT   idDelta         See text below.
    USHORT  idRangeOffset   See text below.

The firstCode and entryCount values specify a subrange that begins at firstCode
and has a length equal to the value of entryCount. This subrange stays within
the 0 255 range of the byte being mapped. Bytes outside of this subrange are
mapped to glyph index 0 (missing glyph).The offset of the byte within this
subrange is then used as index into a corresponding subarray of
glyphIndexArray. This subarray is also of length entryCount. The value of the
idRangeOffset is the number of bytes past the actual location of the
idRangeOffset word where the glyphIndexArray element corresponding to firstCode
appears.

Finally, if the value obtained from the subarray is not 0 (which indicates the
missing glyph), you should add idDelta to it in order to get the glyphIndex.
The value idDelta permits the same subarray to be used for several different
subheaders. The idDelta arithmetic is modulo 65536.


Format 4: Segment mapping to delta values
=====================================================
This is the Microsoft standard character to glyph index mapping table.
This format is used when the character codes for the characters represented by
a font fall into several contiguous ranges, possibly with holes in some or all
of the ranges (that is, some of the codes in a range may not have a
representation in the font). The format-dependent data is divided into three
parts, which must occur in the following order:

    1.  A four-word header gives parameters for an optimized search of the
        segment list;

    2.  Four parallel arrays describe the segments (one segment for each
        contiguous range of codes);

    3.  A variable-length array of glyph IDs (unsigned words).


    Type    Name                    Description
    USHORT  format                  Format number is set to 4.
    USHORT  length                  Length in bytes.
    USHORT  version                 Version number (starts at 0).
    USHORT  segCountX2              2 x segCount.
    USHORT  searchRange             2 x (2**floor(log2(segCount)))
    USHORT  entrySelector           log2(searchRange/2)
    USHORT  rangeShift              2 x segCount - searchRange
    USHORT  endCount[segCount]      End characterCode for each segment,
                                    last = 0xFFFF.
    USHORT  reservedPad             Set to 0.
    USHORT  startCount[segCount]    Start character code for each segment.
    USHORT  idDelta[segCount]       Delta for all character codes in segment.
    USHORT  idRangeOffset[segCount] Offsets into glyphIdArray or 0
    USHORT  glyphIdArray[ ]         Glyph index array (arbitrary length)

The number of segments is specified by segCount, which is not explicitly in the
header; however, all of the header parameters are derived from it. The
searchRange value is twice the largest power of 2 that is less than or equal to
segCount. For example, if segCount=39, we have the following:

    segCountX2      78
    searchRange     64      (2 * largest power of 2  39)
    entrySelector   5       log2(32)
    rangeShift      14      2 x 39 - 64

Each segment is described by a startCode and endCode, along with an idDelta
and an idRangeOffset, which are used for mapping the character codes in the
segment. The segments are sorted in order of increasing endCode values, and the
segment values are specified in four parallel arrays. You search for the first
endCode that is greater than or equal to the character code you want to map. If
the corresponding startCode is less than or equal to the character code, then
you use the corresponding idDelta and idRangeOffset to map the character code
to a glyph index (otherwise, the missingGlyph is returned). For the search to
terminate, the final endCode value must be 0xFFFF. This segment need not
contain any valid mappings. (It can just map the single character code 0xFFFF
to missingGlyph). However, the segment must be present. If the idRangeOffset
value for the segment is not 0, the mapping of character codes relies on
glyphIdArray. The character code offset from startCode is added to the
idRangeOffset value. This sum is used as an offset from the current location
within idRangeOffset itself to index out the correct glyphIdArray value. This
obscure indexing trick works because glyphIdArray immediately follows
idRangeOffset in the font file. The C expression that yields the glyph index
is:

    *(idRangeOffset[i]/2 + (c - startCount[i]) + &idRangeOffset[i])

The value c  is the character code in question, and i  is the segment index in
which c appears. If the value obtained from the indexing operation is not 0
(which indicates missingGlyph), idDelta[i] is added to it to get the glyph
index. The idDelta arithmetic is modulo 65536.
If the idRangeOffset is 0, the idDelta value is added directly to the character
code offset (i.e. idDelta[i] + c) to get the corresponding glyph index. Again,
the idDelta arithmetic is modulo 65536.

As an example, the variant part of the table to map characters 10-20, 30-90,
and 100-153 onto a contiguous range of glyph indices may look like this:

    segCountX2:     8
    searchRange:    8
    entrySelector:  4
    rangeShift:     0
    endCode:        20      90      153     0xFFFF
    reservedPad:    0
    startCode:      10      30      100     0xFFFF
    idDelta:        -9      -18     -27     1
    idRangeOffset:  0       0       0       0

This table performs the following mappings:

    10 -> 10 - 9 = 1
    20 -> 20 - 9 = 11
    30 -> 30 - 18 = 12
    90 -> 90 - 18 = 72
    ...and so on.

Note that the delta values could be reworked so as to reorder the segments.


Format 6: Trimmed table mapping
===============================================================================
    Type    Name                        Description
    USHORT  format                      Format number is set to 6.
    USHORT  length                      Length in bytes.
    USHORT  version                     Version number (starts at 0)
    USHORT  firstCode                   First character code of subrange.
    USHORT  entryCount                  Number of character codes in subrange.
    USHORT  glyphIdArray [entryCount]   Array of glyph index values for
                                        character codes in the range.

The firstCode and entryCount values specify a subrange (beginning at firstCode,
length = entryCount) within the range of possible character codes. Codes
outside of this subrange are mapped to glyph index 0. The offset of the code
(from the first code) within this subrange is used as index to the
glyphIdArray, which provides the glyph index value.

*******************************************************************************/

/******************************************************************************
 *                          TTC Header Table
 *
 * TAG      TTCTag                          TrueType Collection ID string:
 *                                          'ttcf'
 * FIXED32  Version                         Version of the TTC Header table
 *                                          (initially 0x00010000)
 * ULONG    Directory Count                 Number of Table Directories in TTC
 * ULONG    TableDirectory[DirectoryCount]  Array of offsets to Table Directories
 *                                          from file begin
 ******************************************************************************/

/*
 * NameID=3 is for unique Name such as "MonoType:Times New Roman:1990" which
 * will be used to identify correct Font in a TTC file.
 */
#define NAMEID_FACENAME  3
#define MAC_PLATFORM     1
#define MS_PLATFORM      3

/*
 * PostScript names indexed by Machintosh as used in TTF 'post' table format 1,
 * 2, 2.5.
 */
/* gMacGlyphName has been move to a resource. */

/*
 * size of the standard Mac-GlyphName table
 */
#define  MAX_MACINDEX   258

/*
 * Read Format 0 Subtable : Byte encoding table
 */
unsigned long ReadCMapFormat0(
    UFOStruct       *pUFO,
    unsigned long   dwOffset,
    long            code
    )
{
    unsigned long   gi, dwSize, dwGlyphIDOffset;
    unsigned short  length;
    unsigned short  wData[4]; /* read max 4 bytes each time */
    unsigned char   cData[2]; /* read max 2 bytes each time */

    gi = 0 ; /* Assume it's missing. */

    dwSize = GETTTFONTDATA(pUFO,
                            CMAP_TABLE, dwOffset,
                            wData, 4L,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    length = MOTOROLAINT(wData[1]);

    if ((code > 0xFF) || (code > ((long) length - 6)))
        return 0; /* code is out of range! */


    dwGlyphIDOffset = dwOffset + 6 + code ;

    dwSize = GETTTFONTDATA(pUFO,
                            CMAP_TABLE, dwGlyphIDOffset,
                            cData, 2L,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    gi = (unsigned long)(cData[0]);

    return gi;
}


/*
 * Read Format 2 Subtable : High-byte mapping through table
 */
unsigned long ReadCMapFormat2(
    UFOStruct       *pUFO,
    unsigned long   dwOffset,
    long            code
    )
{
    unsigned long   gi, dwSize, dwGlyphIDOffset;
    unsigned short  firstCode, entryCount, idRangeOffset;
    short           subHeaderIndex, idDelta;
    unsigned short  hiByte, loByte;
    unsigned short  wData[10]; /* Read max 20 bytes each time. */

    gi = 0 ; /* Assume it's missing. */

    if (code < 0x100)
    {
        /* Special: use SubHeader 0. */
        loByte = (short) code;     // Fixed bug 367732
        hiByte = 0;
        subHeaderIndex = -1; /* So 8 + subHeaderIndex*8 =0 ==> SunHeader 0... */
    }
    else
    {
        loByte = (short) GET_LOBYTE(code);
        hiByte = (short) GET_HIBYTE(code);

        /* Get the subHeaderIndex from subHeaderKeys[hiByte]. */
        dwSize = GETTTFONTDATA(pUFO,
                                CMAP_TABLE, dwOffset + 6 + 2 * hiByte,
                                wData, 2L,
                                pUFO->pFData->fontIndex);
        subHeaderIndex = MOTOROLAINT(wData[0]) / 8;
    }

    dwSize = GETTTFONTDATA(pUFO,
                            CMAP_TABLE, dwOffset + 6 + 2 * 256 + 8 + subHeaderIndex * 8,
                            wData, 8L,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    firstCode       = MOTOROLAINT(wData[0]);
    entryCount      = MOTOROLAINT(wData[1]);
    idDelta         = (short)MOTOROLAINT(wData[2]);
    idRangeOffset   = MOTOROLAINT(wData[3]);

    if ((loByte >= firstCode) && ((loByte-firstCode) <= entryCount))
    {
        /*
         * The document says:
         * "The value of the idRangeOffset is the number of bytes past the
         * actual location of the idRangeOffset word where the glyphIndexArray
         * element corresponding to firstCode appears."
         */

        dwGlyphIDOffset = dwOffset + 6 + 2 * 256 + 8 + subHeaderIndex * 8
                            + 8 + idRangeOffset + (loByte - firstCode) * 2;

        dwSize = GETTTFONTDATA(pUFO,
                                CMAP_TABLE, dwGlyphIDOffset,
                                wData, 2L,
                                pUFO->pFData->fontIndex);

        gi = MOTOROLAINT(wData[0]);

        if (gi != 0)
            gi = (unsigned long)((long)gi + (long)idDelta);
    }
    else
        gi = 0;

    return gi;
}


/*
 * Read format 4 cmap : Segment mapping to delta values
 */
unsigned long ReadCMapFormat4(
    UFOStruct       *pUFO,
    unsigned long   dwOffset,
    long            code
    )
{
    /*
     * These numbers start from the current SubTable for current segment i and
     * TotalSeg = segs.
     */
    #define  OFFSET_ENDCOUNT(segs,  i) (long)(14 +((long)i) * 2)
    #define  OFFSET_STARTCOUNT(segs,i) (long)(14 + ((long)segs) * 2 + 2 + ((long)i) * 2)
    #define  OFFSET_IDDELTA(segs,   i) (long)(14 + ((long)segs) * 2 + 2 + ((long)segs) * 2 \
                                        + ((long)i) * 2)
    #define  OFFSET_IDRANGE(segs,   i) (long)(14 + ((long)segs) * 2 + 2 + ((long)segs) * 2 \
                                        + ((long)segs) * 2 + ((long)i) * 2)

    unsigned long   gi, dwSize, dwGlyphIDOffset;
    unsigned short  segStartCode, segEndCode, segRangeOffset, nSegments, wData[10], i;
    short           segDelta;

    /*
     * Read number of Segments.
     */
    dwSize = GETTTFONTDATA(pUFO,
                            CMAP_TABLE, dwOffset + 6,
                            wData, 2L,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    nSegments = MOTOROLAINT(wData[0]) / 2;

    gi = 0; /* Assume it's missing. */

    for (i = 0; i < nSegments; i++)
    {
        /*
         * Find the least segEndCode >= code.
         */
        dwSize = GETTTFONTDATA(pUFO,
                                CMAP_TABLE, dwOffset + OFFSET_ENDCOUNT(nSegments, i),
                                wData, 2L, /* Read 2 bytes = endCount[segCount] */
                                pUFO->pFData->fontIndex);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            break; /* No more endCount[i] */

        segEndCode = MOTOROLAINT(wData[0]);

        if (segEndCode == 0xFFFFL)
            break; /* No more endCount[i]. 0xFFFF is the end mark. */

        if ((long)segEndCode < code)
            continue; /* Not in this segment. Move to the next. */

        /*
         * The code may be in this segment. Get the start code and make sure
         * of it.
         */
        dwSize = GETTTFONTDATA(pUFO,
                                CMAP_TABLE, dwOffset + OFFSET_STARTCOUNT(nSegments, i),
                                wData, 2L,
                                pUFO->pFData->fontIndex);
        if (dwSize == 0)
        {
            /*
             * Something is wrong. Ignore this segment and move to the next.
             */
            continue;
        }

        segStartCode = MOTOROLAINT(wData[0]);

        if ((long)segStartCode <= code)
        {
            /*
             * The code is in this segment. Get the idDelta and idRangeOffset.
             */
            dwSize = GETTTFONTDATA(pUFO,
                                    CMAP_TABLE, dwOffset + OFFSET_IDDELTA(nSegments, i),
                                    wData, 2L,
                                    pUFO->pFData->fontIndex);

            segDelta = (short)MOTOROLAINT(wData[0]); /* mode 65536 */

            dwSize = GETTTFONTDATA(pUFO,
                                    CMAP_TABLE, dwOffset + OFFSET_IDRANGE(nSegments, i),
                                    wData, 2L,
                                    pUFO->pFData->fontIndex);

            segRangeOffset = MOTOROLAINT(wData[0]);

            if (segRangeOffset != 0)
            {
                dwGlyphIDOffset = dwOffset
                                    + OFFSET_IDRANGE(nSegments, i)
                                    + (code - segStartCode) * 2
                                    + segRangeOffset; /* obscure indexing trick */

                dwSize = GETTTFONTDATA(pUFO,
                                        CMAP_TABLE, dwGlyphIDOffset,
                                        wData, 2L,
                                        pUFO->pFData->fontIndex);

                gi = MOTOROLAINT(wData[0]);

                if (gi != 0)
                    gi = (unsigned long)((long)gi + (long)segDelta);
            }
            else
                gi = (unsigned long)((long)code + (long)segDelta);

            gi %= 65536;

            /*
             * We got it, so break from this FOR loop and return to the
             * caller.
             */
            break;
        }
    }

    return gi;
}


/*
 * Read Format 6: Trimmed table mapping
 */
unsigned long ReadCMapFormat6(
    UFOStruct       *pUFO,
    unsigned long   dwOffset,
    long            code
    )
{
    unsigned long   gi, dwSize, dwGlyphIDOffset;
    unsigned short  firstCode, entryCount;
    unsigned short  wData[10]; /* Read max 20 bytes each time. */

    gi = 0; /* Assume it's missing. */

    dwSize = GETTTFONTDATA(pUFO,
                            CMAP_TABLE, dwOffset,
                            wData, 10L, /* Format 6 header */
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0; /* No header */

    firstCode  = MOTOROLAINT(wData[3]);
    entryCount = MOTOROLAINT(wData[4]);

    if ((code >= (long)firstCode) && ((code - (long)firstCode) <= (long)entryCount))
    {
        dwGlyphIDOffset = dwOffset + 10 + (code-firstCode) * 2;

        dwSize = GETTTFONTDATA(pUFO,
                                CMAP_TABLE, dwGlyphIDOffset,
                                wData, 2L,
                                pUFO->pFData->fontIndex);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            return 0;

        gi = MOTOROLAINT(wData[0]);
    }

    return gi;
}


unsigned long
GetGlyphID(
    UFOStruct   *pUFO,
    long        unicode,
    long        localcode
    )
{
    unsigned long gi;

    gi = GetGlyphIDEx(pUFO,
                        unicode, localcode,
                        nil, nil,
                        GGIEX_HINT_INIT_AND_GET);

    return gi;
}


/*
 ******************************************************************************
 *                              GetGlyphIDEx
 *
 *                      How to use this function
 *
 * You first call this function with hint GGIEX_HINT_INIT and without any
 * Unicode and local code info. On return the function gives the caller the
 * sub table number and the offset to the table. Then you call this function
 * any times you want with hint GGIEX_HINT_GET and Unicode and local code and
 * supplied sub table number and the offset. Or, you can call this function
 * with hint GGIEX_HINT_INIT_AND_GET and Unicode and local code, which is
 * defined as the GetGlyphID function for convenience. The differece of the
 * calls with hint GGIEX_HINT_INIT then GGIEX_HINT_GET and the call with hint
 * GGIEX_HINT_INIT_AND_GET is that the former is efficent than the latter if
 * you need to get multiple glyph IDs. Note that when you call this function
 * with hint GGIEX_HINT_INIT then GGIEX_HINT_GET, you *MUST* supply the same
 * UFO object through the calls.
 *
 * This function takes a unicode and a local code and returns the Glyph-Index
 * for that unicode if UNICODE-Cmap subtable is found for that local code else.
 * As an example, "period-like symbol" Japanese half-width katakana has unicode
 * FF61 and (Win/Mac) Shift-JIS local code "0x00A1". An TTF file may contain
 * only Shift-JIS based cmap, so we can still get the GID from "0xA1".
 * We prefer to use the Unicode cmap-sub table, then the local ones as defined
 * in the array preSubTable[].
 *
 * Here is eight possible PlatformID/EncodingID combinations in our preferred
 * order (for Windows).
 *
 * 3    1    Unicode         : Primary one
 * 3    2    ShiftJIS
 * 3    3    Big5
 * 3    4    PRC
 * 3    5    Wansung
 * 3    6    Johab
 * 3    0    Symbol          : Don't care much
 * 1    0    Mac standard
 *
 ******************************************************************************/

#define CMAP_UNICODE    0
#define CMAP_SHIFTJIS   1
#define CMAP_BIG5       2
#define CMAP_PRC        3
#define CMAP_WANSUNG    4
#define CMAP_JOHAB      5
#define CMAP_SYMBOL     6
#define CMAP_MAC        7

#define CMAP_NUM_ENC    8

static short preSubTable[CMAP_NUM_ENC] = {
    CMAP_UNICODE,
    CMAP_SHIFTJIS,
    CMAP_BIG5,
    CMAP_PRC,
    CMAP_WANSUNG,
    CMAP_JOHAB,
    CMAP_SYMBOL,
    CMAP_MAC,
};

/* PlatformID 3/EncodingID x to CMapID */
static short pfID3EncIDTable[CMAP_NUM_ENC - 1] = {
                    /* Encoding ID  */
    CMAP_SYMBOL,    /*      0       */
    CMAP_UNICODE,   /*      1       */
    CMAP_SHIFTJIS,  /*      2       */
    CMAP_BIG5,      /*      3       */
    CMAP_PRC,       /*      4       */
    CMAP_WANSUNG,   /*      5       */
    CMAP_JOHAB,     /*      6       */
};

unsigned long
GetGlyphIDEx(
    UFOStruct       *pUFO,
    long            unicode,
    long            localcode,
    short           *pSubTable,
    unsigned long   *pOffset,
    int             hint
    )
{
    short           subTable;
    unsigned long   offset;

    unsigned long   gi;
    unsigned long   dwSize;
    unsigned short  version, numEncodings, platformID, encodingID, format, i;

    unsigned long   lData[20];
    unsigned short  wData[20]; /* Only first 10 bytes of 'cmap' table required. */

    unsigned long   dwOffset[CMAP_NUM_ENC]; /* offset to #CMAP_NUM_ENC possible subtables */

    if (hint != GGIEX_HINT_GET)
    {
        /*
         * Be sure hint is either GGIEX_HINT_INIT or GGIEX_HINT_INIT_AND_GET.
         */

        subTable = -1;
        offset   =  0;

        if (pSubTable)
            *pSubTable = subTable;
        if (pOffset)
            *pOffset = offset;

        /*
         * First 4 bytes in 'cmap' table has the platform and format information
         * unsigned short    Table version number (0).
         * unsigned short    Number of encoding tables, n.
         */
        dwSize = GETTTFONTDATA(pUFO,
                                CMAP_TABLE, 0L,
                                wData, 4L,
                                pUFO->pFData->fontIndex);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            return 0;

        version = MOTOROLAINT(wData[0]);
        if (version != 0)
            return 0; /* We support only version zero currently. */

        for (i = 0; i < CMAP_NUM_ENC; i++)
            dwOffset[i] = 0;

        numEncodings = MOTOROLAINT(wData[1]);

        for (i = 0; i < numEncodings; i++)
        {
            GETTTFONTDATA(pUFO,
                            CMAP_TABLE, i * 8 + 4,
                            wData, 8L,
                            pUFO->pFData->fontIndex);

            platformID = MOTOROLAINT(wData[0]);
            encodingID = MOTOROLAINT(wData[1]);

            if (platformID == 3)
            {
                if ((encodingID >= 0) && (encodingID <= 6))
                {
                    GETTTFONTDATA(pUFO,
                                    CMAP_TABLE, i * 8 + 4,
                                    lData, 8L,
                                    pUFO->pFData->fontIndex);

                    dwOffset[pfID3EncIDTable[encodingID]] = MOTOROLALONG(lData[1]);
                }
            }

            if (platformID == 1)
            {
                if (encodingID == 0)
                {
                    GETTTFONTDATA(pUFO,
                                    CMAP_TABLE, i * 8 + 4,
                                    lData, 8L,
                                    pUFO->pFData->fontIndex);

                    dwOffset[CMAP_MAC] = MOTOROLALONG(lData[1]); /* 7 is for Mac Standard. */
                }
            }
        }

        /*
         * Get the preferred SubTable and its offset based on the preference
         * array.
         */
        for (i = 0; i < CMAP_NUM_ENC; i++)
        {
            if (dwOffset[preSubTable[i]] > 0 && dwOffset[preSubTable[i]] < 0xFFFFFFFFL)
            {
                subTable = preSubTable[i];
                offset   = dwOffset[subTable];
                break;
            }
        }
    }
    else
    {
        /*
         * GGIEX_HINT_GET
         */
        subTable = pSubTable ? *pSubTable : -1;
        offset   = pOffset   ? *pOffset   :  0;
    }

    if (hint == GGIEX_HINT_INIT)
    {
        if (pSubTable)
            *pSubTable = subTable;
        if (pOffset)
            *pOffset = offset;

        return 0;
    }

    /*
     * The following code is executed when the hint is either GGIEX_HINT_GET
     * or GGIEX_HINT_INIT_AND_GET.
     */

    gi = 0;

    if (0 <= subTable)
    {
        long code = (subTable == CMAP_UNICODE) ? unicode : localcode;

        /*
         * Determine if the format of the encoding is one we can handle.
         */
        GETTTFONTDATA(pUFO,
                        CMAP_TABLE, offset,
                        wData, 8L,
                        pUFO->pFData->fontIndex);

        format = MOTOROLAINT(wData[0]);

        switch (format)
        {
        case 4:
            /*
             * Format 4: Segment mapping to delta values (MS standard format)
             * Get the glyphID using unicode or localcode.
             */
            gi = ReadCMapFormat4(pUFO, offset, code);
            break;

        case 0:
            /*
             * Format 0: Byte encoding table
             * Only used for small fonts - or only first 256 chars accessible.
             * We really don't care for this guy for CJK, but for completeness.
             */
            gi = ReadCMapFormat0(pUFO, offset, code);
            break;

        case 2:
            /*
             * Format 2: High-byte mapping through table
             * THIS format SHOULD use localcode - because the sigle byte chars
             * are in the subHeader 0. But some font may mess up the standard
             * as always.
             */
            gi = ReadCMapFormat2(pUFO, offset, code);
            break;

        case 6:
            /*
             * Format 6: Trimmed table mapping
             * Get the glyphID using unicode or localcode.
             */
            gi = ReadCMapFormat6(pUFO, offset, code);
            break;

        default:
            break;
        }
    }

    return(gi);
}


/*
 ******************************************************************************

                                'vmtx' table
                        - Vertical Metrics Table Format -

The overall structure of the vertical metrics table consists of two arrays
shown below:

the vMetrics array followed by an array of top side bearings. This table does
not have a header, but does require that the number of glyphs included in the
two arrays equals the total number of glyphs in the font. The number of
entries in the vMetrics array is determined by the value of the
numOfLongVerMetrics field of the vertical header table. The vMetrics array
contains two values for each entry. These are the advance height and the top
sidebearing for each glyph included in the array. In monospaced fonts, such as
Courier or Kanji, all glyphs have the same advance height. If the font is
monospaced, only one entry need be in the first array, but that one entry is
required. The format of an entry in the vertical metrics array is given below.

    Type    Name            Description
    USHORT  advanceHeight   The advance height of the glyph. Unsigned integer
                            in FUnits
    SHORT   topSideBearing  The top sidebearing of the glyph. Signed integer
                            in FUnits.

The second array is optional and generally is used for a run of monospaced
glyphs in the font. Only one such run is allowed per font, and it must be
located at the end of the font. This array contains the top sidebearings of
glyphs not represented in the first array, and all the glyphs in this array
must have the same advance height as the last entry in the vMetrics array. All
entries in this array are therefore monospaced. The number of entries in this
array is calculated by subtracting the value of numOfLongVerMetrics from the
number of glyphs in the font. The sum of glyphs represented in the first array
plus the glyphs represented in the second array therefore equals the number of
glyphs in the font. The format of the top sidebearing array is given below.

    Type    Name                Description
    SHORT   topSideBearing[]    The top sidebearing of the glyph. Signed
                                integer in FUnits.

*******************************************************************************/

/*
** Old comment
** GetCharWidthFromTTF was replaced to GetMetrics2FromTTF in order to fix
** #277035 and #277063. (See old history of this code in SourceSafe to see
** what GetCharWidthFromTTF code was doing.)
** More old comment
** Modified this procedure to fix bug 287084.  Bug fix 277035 and 277063 works
** for NT but not for W95.  See vantive report for 287084.
*/

/*
 * New comment
 *
 * Table search order for vertical metrics on Windows.
 *
 * 1. First look for 'vhea' table (only on NT).
 * 2. If 'vhea' table is missing, look for 'OS/2' table.
 * 3. If 'OS/2' table is missing neither, then look for 'hhea' table.
 *
 * When 'OS/2' or 'hhea' table is found, Windows uses its horizontal ascender
 * and descender values as vertical's. Note that according to Microsoft Win 9x
 * doesn't care of 'vhea' table.
 *
 * In the code below we look for the tables differently: look for 'OS/2' table
 * first, then 'hhea' table. Then we look for 'vhea' on NT but ignore it on 9x.
 * Although we ignore 'vhea' table on 9x, we still use metrics in 'vmtx' table
 * on both NT and 9x.
 */

UFLErrCode
GetMetrics2FromTTF(
    UFOStruct       *pUFO,
    unsigned short  gi,
    long            *pem,
    long            *pw1y,
    long            *pvx,
    long            *pvy,
    long            *ptsb,
    UFLBool         *bUseDef,
    UFLBool         bGetDefault,
    long            *pvasc
    )
{
    unsigned short  wData[48]; /* 'hhea' and 'vhea' are 36 bytes long. 'OS/2 is either 78 or 86 bytes. */
    unsigned long   dwSize, dwOffset;
    long            em, lAscent, lDescent, lNumLongVM, AdvanceHeight, lAscent2, lDescent2;
    UFLBool         bSkiphhea = 1;

    /*
     * Get EM of this font. Getting first 22 bytes from 'head' table is enough.
     */
    dwSize = GETTTFONTDATA(pUFO,
                            HEAD_TABLE, 0L,
                            wData, 22L,
                            pUFO->pFData->fontIndex);

    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
    {
        /*
         * 'head' is a required table so that em has to be avaiable. This is
         * merely divide by 0 proof, wild guess value.
         */
        em = 256;
    }
    else
    {
        /* 9th unsigned short is the font design unit. */
        em = (long)MOTOROLAINT(wData[9]);
    }

    *pem = em;

    /*
     * Get vx and vy, descent and ascent, of Metrics2.
     *
     * WCC - Bug 303030 - For Win9x, we want to try 'OS/2' table first, then
     * 'vhea' table. Refer to #287084 too for additional info.
     *
     * We don't care of ulCodePageRange values added at the end of version 1 of
     * 'OS/2' table so that specify version 0's length 78 instead of 86. This
     * prevents to failure of 'OS/2' table access.
     */
    dwSize = GETTTFONTDATA(pUFO,
                            OS2_TABLE, 0L,
                            wData, 78L,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
    {
        bSkiphhea = 0; /* Failed to get info from 'OS/2' table. Use 'hhea' table then. */
    }
    else
    {
        /*
         * Our investigation shows that 9x and NT/W2K use different ascender
         * and descender values in 'OS/2' table. 9x uses sTypoAscender and
         * sTypoDescender values. On the other hand, NT4 and W2K use
         * usWinAscent and usWinDescent. There are acutally some CJK TrueType
         * fonts which have different sTypoAscender/Descender and
         * usWinAscent/Descent values.
         *
         * Note that this function is also called to get metrics data for
         * OpenType font to fix bug #366539, and the fix revealed that we
         * need to use sTypoAscender/descender values from 'OS/2' table.
         */
        if ((pUFO->vpfinfo.nPlatformID == kUFLVPFPlatformID9x) || (pUFO->ufoType == UFO_CFF))
        {
            lAscent  = (long)MOTOROLASINT(wData[34]); /* sTypoAscender  */
            lDescent = (long)MOTOROLASINT(wData[35]); /* sTypoDescender */
        }
        else /* TTF and NT4/W2K */
        {
            lAscent  = (long)MOTOROLASINT(wData[37]); /* usWinAscent */
            lDescent = (long)MOTOROLASINT(wData[38]); /* usWinDecent */
        }

        if (lDescent < 0)
            lDescent = -lDescent;
    }

    dwSize = GETTTFONTDATA(pUFO,
                           HHEA_TABLE, 0L,
                           wData, 36L,
                           pUFO->pFData->fontIndex);

    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
    {
        /*
         * Talisman - 'hhea' is a required table.
         */
        lDescent2 = (long)em / 8; /* This is a wild guess value. */
        lAscent2  = (long)(em - lDescent2);
    }
    else
    {
        lAscent2  = (long)MOTOROLASINT(wData[2]);
        lDescent2 = (long)MOTOROLASINT(wData[3]);

        if (lDescent2 < 0)
            lDescent2 = -lDescent2;
    }

    if (!bSkiphhea)
    {
        /* Failed to get ascent and descent values from 'OS/2' table, so use these. */
        lAscent  = lAscent2;
        lDescent = lDescent2;
    }

    /*
     * Up to here we got initial default values.
     */

    *bUseDef    = 1;
    *pvx        = lDescent;
    *pvy        = lAscent;
    *pw1y       = em;
    *ptsb       = 0;

    /*
     * Win 9x doesn't care of 'vhea' and so are NT/W2K (see bug #316067 and
     * #277035). But we get ascender value of 'vhea' anyway in order to adjust
     * the 'full-width glyph layout policy' difference between GDI and
     * %hostfont%-RIP (#384736).
     */

    dwSize = GETTTFONTDATA(pUFO,
                           VHEA_TABLE, 0L,
                           wData, 36L,
                           pUFO->pFData->fontIndex);
    if ((dwSize != 0) && (dwSize != 0xFFFFFFFFL))
    {
        lAscent2  = (long)MOTOROLASINT(wData[2]);
    }
    else
    {
        /*
         * When the font doesn't have 'vhea', we need to adjust the policy
         * difference in a different way; using 'GDI' CDevProc instead of
         * adjusted matrix. To cause that, return to the caller with same
         * vy and vasc values.
         */
        lAscent2 = lAscent;

        /*
         * Without 'vhea' table 'vmtx' table doesn't make sense.
         * Return as though only default values are requested.
         */
        bGetDefault = 1;
    }

    *pvasc = lAscent2;

    /*
     * Return when only default values are required.
     */

    if (bGetDefault)
        return kNoErr;


    /*
     * Get AdvanceHeight and TopSideBearing of each glyph from 'vmtx' table.
     */
    lNumLongVM = (long)MOTOROLAINT(wData[17]); // From 'vhea' table

    if ((!bGetDefault) && ((long) gi < lNumLongVM))
    {
        /*
         * gi is in the 1st array: each entry is 4 bytes long.
         */
        dwOffset = 4 * ((unsigned long)gi);
        dwSize   = GETTTFONTDATA(pUFO,
                                    VMTX_TABLE, dwOffset,
                                    wData, 4L,
                                    pUFO->pFData->fontIndex);

        if ((dwSize != 0) && (dwSize != 0xFFFFFFFFL))
        {
            *pw1y = (long)MOTOROLAINT(wData[0]);    /* AdvanceHeight  */
            *ptsb = (long)MOTOROLASINT(wData[1]);   /* TopSideBearing */
            *bUseDef = 0;
        }
    }
    else
    {
        /*
         * gi is in the 2nd array: find width from the last entry in the 1st
         * array first, then TopSideBearing in the 2nd array.
         */
        dwOffset = 4 * (lNumLongVM - 1);
        dwSize   = GETTTFONTDATA(pUFO,
                                    VMTX_TABLE, dwOffset,
                                    wData, 4L,
                                    pUFO->pFData->fontIndex);

        if ((dwSize != 0) && (dwSize != 0xFFFFFFFFL))
        {
            AdvanceHeight   = (long)MOTOROLAINT(wData[0]);
            dwOffset        = (4 * lNumLongVM) + (2 * (gi - lNumLongVM));
            dwSize          = GETTTFONTDATA(pUFO,
                                            VMTX_TABLE, dwOffset,
                                            wData, 2L,
                                            pUFO->pFData->fontIndex);

            if ((dwSize != 0) && (dwSize != 0xFFFFFFFFL))
            {
                *pw1y       = AdvanceHeight;
                *ptsb       = (long)MOTOROLASINT(wData[0]); /* TopSideBearing */
                *bUseDef    = 0;
            }
        }
    }

    return kNoErr;
}


unsigned long
GetNumGlyphs(
    UFOStruct *pUFO
    )
{
    MaxPTableStruct MaxPTable;
    unsigned long   dwSize;

    /* Get the size of the 'maxp' table. */
    dwSize = GETTTFONTDATA(pUFO,
                            MAXP_TABLE, 0L,
                            nil, 0L,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    // Fixed 516508. case 1
    if (dwSize > sizeof(MaxPTable))
        dwSize = sizeof(MaxPTable);

    dwSize = GETTTFONTDATA(pUFO,
                            MAXP_TABLE, 0L,
                            &MaxPTable, dwSize,
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    return MOTOROLAINT(MaxPTable.numGlyphs);;
}


/*
 * Returns the fsType value from the OS/2 table. If the OS/2 table isn't
 * defined then -1 is returned.
 */
long GetOS2FSType(UFOStruct *pUFO)
{
    UFLOS2Table     os2Tbl;
    unsigned long   dwSize;

    dwSize = GETTTFONTDATA(pUFO,
                            OS2_TABLE, 0L,
                            &os2Tbl, sizeof (UFLOS2Table),
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return -1;


    return MOTOROLAINT(os2Tbl.fsType);
}


/*
 * TTC File related functions
 */
UFLBool
BIsTTCFont(
    unsigned long ulTag
    )
{
    return (ulTag == TTCF_TABLE);
}


unsigned short
GetFontIndexInTTC(
    UFOStruct *pUFO
    )

/*++

Routine Description:

    Find the fontIndex from pUFO->UniqueNameA/W. The return value is the font
    index or FONTINDEX_UNKNOWN.

--*/

{
    TTCFHEADER      ttcfHeader;
    unsigned long   dwSize;
    unsigned short  i, j, k, sTemp;
    unsigned long   lData;
    unsigned short  wData[3];
    unsigned long   offsetToTableDir;
    unsigned long   ulOffsetToName, ulLengthName;
    unsigned long   cNumFonts;
    unsigned short  cNumNameRecords;
    unsigned short  fontIndex;
    NAMERECORD      *pNameRecord = nil;
    unsigned char   *pName = nil;

    dwSize = GETTTFONTDATA(pUFO,
                            nil, 0L,
                            &ttcfHeader, sizeof (ttcfHeader),
                            0);
    if (!BIsTTCFont(*((unsigned long *)((char *)&ttcfHeader))))
    {
        /* This is not a TTC file, so return font index 0. */
        return 0;
    }

    fontIndex = FONTINDEX_UNKNOWN;

    dwSize = sizeof (NAMERECORD);

    pNameRecord = (NAMERECORD *)UFLNewPtr(pUFO->pMem, dwSize);
    if (pNameRecord == nil)
        return fontIndex;

    cNumFonts = (unsigned long)MOTOROLALONG(ttcfHeader.cDirectory);

    for (i = 0; i < cNumFonts; i++)
    {
        /*
         * Get offset to the ith tableDir first: a long at 4 * i right after
         * ttcfHeader.
         */
        dwSize = GETTTFONTDATA(pUFO,
                                nil, sizeof (ttcfHeader) + i * 4,
                                &lData, sizeof (lData),
                                0);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            continue;

        offsetToTableDir = MOTOROLALONG(lData);

        /*
         * Get 'name' table record for i-th font in this TTC. Find number of
         * NameRecords and offset to String storage: use 3 shorts.
         */
        dwSize = GETTTFONTDATA(pUFO,
                                NAME_TABLE, 0L,
                                wData, 3 * sizeof (short),
                                i);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            continue;

        cNumNameRecords = MOTOROLAINT(wData[1]);
        ulOffsetToName  = (unsigned long)MOTOROLAINT(wData[2]);

        /*
         * Look into the NameRecords: Search for both platform: MS-Platform,
         * Mac-Platform.
         */
        for (k = 0; k < cNumNameRecords; k++)
        {
            dwSize = GETTTFONTDATA(pUFO,
                                    NAME_TABLE, 3 * sizeof (short) + k * sizeof (NAMERECORD),
                                    pNameRecord,  sizeof (NAMERECORD),
                                    i);
            if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
                continue;

            /* We are looking for particular NameID record. */
            if (MOTOROLAINT(pNameRecord->nameID) != NAMEID_FACENAME)
                continue;

            /* We only read MS or Mac Platform. */
            if ((MOTOROLAINT(pNameRecord->platformID) != MS_PLATFORM)
                && (MOTOROLAINT(pNameRecord->platformID) != MAC_PLATFORM))
                continue;

            /* Get the "unique identifier" string. */
            ulLengthName = MOTOROLAINT(pNameRecord->length);

            /*
             * This is in a loop, so pName maybe allocated already.
             * Free it first.
             */
            if (pName)
            {
                UFLDeletePtr(pUFO->pMem, pName);
                pName = nil;
            }

            dwSize = ulLengthName + 4 ; // add two 00 at the end.

            pName = (unsigned char *)UFLNewPtr(pUFO->pMem, dwSize);

            if (pName == nil)
            {
                /* Allocation failed. */
                break;
            }

            dwSize = GETTTFONTDATA(pUFO,
                                    NAME_TABLE, ulOffsetToName + MOTOROLAINT(pNameRecord->offset),
                                    pName, ulLengthName,
                                    i);
            if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
                continue;

            /*
             * Note that OS/2 and Windows both require that all name strings
             * be defined in Unicode. !!!BUT!!! Macintosh fonts require single
             * byte strings!
             */
            if ((MOTOROLAINT(pNameRecord->platformID) == MS_PLATFORM)
                && pUFO->pFData->pUniqueNameW)
            {
                /*
                 * For Windows EncodingID must be 0 or 1: both are in Unicode.
                 * So, do Unicode comparison - pUniqueNameW is not in Motorola
                 * format on Windows. So Convert pName to Motorola format.
                 */
                j = 0;

                while (sTemp = *(((unsigned short *)pName) + j), sTemp != 0)
                {
                    *(((unsigned short *)pName) + j) = MOTOROLAINT(sTemp);
                    j++;
                }

                if (UFLstrcmpW((unsigned short *)(pUFO->pFData->pUniqueNameW),
                                (unsigned short *)pName) == 0)
                {
                    fontIndex = i;
                    break;
                }
            }

            if ((MOTOROLAINT(pNameRecord->platformID) == MAC_PLATFORM)
                && pUFO->pFData->pUniqueNameA)
            {
                /* Do single Byte-string comparison. */
                if  (UFLstrcmp(pUFO->pFData->pUniqueNameA, (char *)pName) == 0)
                {
                    fontIndex = i;
                    break;
                }

            }

        }  /* for k from 0 to numRecords in this font's name table */

        /* If find one, break out of the loop. */
        if (fontIndex != FONTINDEX_UNKNOWN)
            break;

    }  /* for i = 0 to numFonts */

    if (pName != nil)
        UFLDeletePtr(pUFO->pMem, pName);

    if (pNameRecord != nil)
        UFLDeletePtr(pUFO->pMem, pNameRecord);

    return fontIndex;
}


unsigned long
GetOffsetToTableDirInTTC(
    UFOStruct        *pUFO,
    unsigned short   fontIndex
    )
{
    unsigned long   dwSize;
    TTCFHEADER      ttcfHeader;
    unsigned long   lData;
    unsigned long   offsetToTableDir;

    dwSize = GETTTFONTDATA(pUFO,
                            nil, 0L,
                            &ttcfHeader, sizeof (ttcfHeader),
                            0);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    if (!BIsTTCFont( *((unsigned long *)((char *)&ttcfHeader))))
    {
        /* Not TTC file: offsetToTableDir is at 0. */
        return 0;
    }

    /*
     * Get offset to the tableDir: a long at 4 * FontIndex right after
     * ttcfHeader.
     */
    dwSize = GETTTFONTDATA(pUFO,
                            nil, sizeof (ttcfHeader) + fontIndex * 4,
                            &lData, sizeof (lData),
                            0);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    offsetToTableDir = MOTOROLALONG(lData);

    return offsetToTableDir;
}


char *
GetGlyphName(
    UFOStruct       *pUFO,
    unsigned long   lGid,
    char            *pszHint,
    UFLBool         *bGoodName /* GoodName */
    )

/*++

Routine Description:
    Function to parse 'post' table to figure out PostScript name for Glyph
    lGid.

    IF found a name
        return the pointer to name (NULL terminated)
    ELSE
        return the passed in pszHint

   Note: The returned pointer is Global, either gMacGlyphName[x] or gGlyphName.

--*/
{
    POSTHEADER      *ppostHeader;
    unsigned long   dwSize, dwNumGlyph, j;
    char            *pszName;
    char            cOffset;
    long            newIndex = 0, lOffset;
    short           i;
    unsigned short  sIndex = 0;
    unsigned char   *pUSChar;
    unsigned short  *pUSShort;
    unsigned long   dwNumGlyphInPostTb;
    char            **gMacGlyphNames;

    // Fixed bug #516515
    char            *gGlyphName;
    gGlyphName = pUFO->pAFont->gGlyphName;

    *bGoodName = 0; /* GoodName */

    gMacGlyphNames = (char **)(pUFO->pMacGlyphNameList);

    /*
     * Initialize to a reasonable name.
     */
    if ((pszHint == nil) || (*pszHint == '\0'))
    {
        // UFLsprintf(gGlyphName, "G%x", lGid);
        UFLsprintf(gGlyphName, CCHOF(pUFO->pAFont->gGlyphName), "g%d", lGid);
        pszName = gGlyphName;
    }
    else
        pszName = pszHint;

    if (pUFO->lNumNT4SymGlyphs)
        return pszName;

    /* GoodName */
    if (lGid == 0)
    {
        UFLsprintf(gGlyphName, CCHOF(pUFO->pAFont->gGlyphName), ".notdef");
        *bGoodName = 1;
        return gGlyphName;
    }

    /*
     * For Speed, we save the postTable now - about 5K of data per font.
     */
    if (pUFO->pAFont->pTTpost == nil)
    {
        dwSize = GETTTFONTDATA(pUFO,
                                POST_TABLE, 0L,
                                nil, 0L,
                                pUFO->pFData->fontIndex);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            return pszName;

        pUFO->pAFont->dwTTPostSize  = dwSize;
        pUFO->pAFont->pTTpost       = (void *)UFLNewPtr(pUFO->pMem, dwSize);

        if (pUFO->pAFont->pTTpost)
        {
            dwSize = GETTTFONTDATA(pUFO,
                                    POST_TABLE, 0L,
                                    pUFO->pAFont->pTTpost, dwSize,
                                    pUFO->pFData->fontIndex);
            if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
                return pszName;
        }
        else
           return pszName;
    }

    /*
     * Get the 'post' table record to figure out the format.
     */
    ppostHeader = pUFO->pAFont->pTTpost;

    /* A convenient byte pointer */
    pUSChar = (unsigned char *)pUFO->pAFont->pTTpost;

    pUSShort = (unsigned short *)(pUSChar + sizeof(POSTHEADER));
    dwNumGlyphInPostTb = (unsigned long)MOTOROLAINT(*pUSShort);

    dwNumGlyph = pUFO->pFData->cNumGlyphs;
    if (dwNumGlyph == 0)
        dwNumGlyph = GetNumGlyphs(pUFO);

    /*
     * To protect against bad Glyph-IDs
     */
    if (lGid >= dwNumGlyph)
        return pszName;

    switch (MOTOROLALONG(ppostHeader->format))
    {
    case POST_FORMAT_10: /* Standard MacIndex fomat */

        if (lGid < MAX_MACINDEX )
        {
            if (gMacGlyphNames)
            {
                pszName    = gMacGlyphNames[lGid];
                *bGoodName = 1; /* GoodName */
            }
        }
        break;

    case POST_FORMAT_20: /* Mac-Index Plus additional Pascal strings */

        if (lGid <= dwNumGlyph)
        {
            /*
             * Use lGid to get the index to the Mac standard names.
             */
            lOffset     = sizeof (POSTHEADER) + sizeof(short) + sizeof(short) * lGid;
            pUSShort    = (unsigned short *)(pUSChar + lOffset);

            sIndex      = pUSShort[0];
            sIndex      = MOTOROLAINT(sIndex);

            if ((sIndex == 0) && (lGid > 0))
            {
                /*
                 * Handle specila case. If there is no entry in 'post'
                 * table for this glyph index, using Glyph ID as the name.
                 * Fix Adobe Bug 233027.
                 */
            }
            else if (sIndex < MAX_MACINDEX)
            {
                if (gMacGlyphNames)
                {
                    pszName    = gMacGlyphNames[sIndex];
                    *bGoodName = 1; /* GoodName */
                }
            }
            /*
             * Add condition (dwNumGlyphInPostTb == dwNumGlyph) to work around
             * the problem in TT font marigold.
             */
            else if ((sIndex < 32768) && (dwNumGlyphInPostTb == dwNumGlyph))
            {
                /* 32768 to 64K is reserved for future use */
                newIndex = (long)sIndex - (long)MAX_MACINDEX;

                lOffset = sizeof(POSTHEADER) + sizeof(short) + sizeof(short)* dwNumGlyph ;
                i = 0;
                j = lOffset;

                while (j < pUFO->pAFont->dwTTPostSize)
                {
                    cOffset = pUSChar[j];

                    /*
                     * Bad 'post' table could have an 0-length pascal string,
                     * don't stuck here.
                     */
                    if (cOffset == (char)0)
                        break;

                    if ((j + (short)((unsigned char) cOffset) + 1) >= pUFO->pAFont->dwTTPostSize)
                        break;

                    if (i >= newIndex)
                        break;

                    j += (long)((unsigned char)cOffset) + 1;
                    i++;
                }

                /*
                 * Found it.
                 */
                if (i == newIndex)
                {
                    // For #516515: cOffset is one byte, the buffer size of the
                    // gGlyphName is 256. So, it is safe to copy here.
                    UFLmemcpy((const UFLMemObj* )pUFO->pMem,
                                (void *) gGlyphName,
                                (void *)(pUSChar + j + 1),
                                (UFLsize_t)cOffset);

                    *(gGlyphName + ((unsigned char)cOffset)) = '\0';

                    pszName    = gGlyphName;
                    *bGoodName = 1; /* GoodName */
                }
            }
        }

        break;

#if 0
    case POST_FORMAT_25: /* Re-ordered Mac-Index */

        /*
         * Use lGid to get the index to the Mac standard names.
         */
        if (lGid >= MAX_MACINDEX )
            break;

        cOffset = pUSChar[sizeof(POSTHEADER) + lGid];

        /*
         * DCR -- confirm format 2.5 with a Mac font.
         */
        newIndex = (long)lGid + (long)cOffset;

        if ((sIndex == 0) && (lGid > 0))
        {
            /*
             * Handle specila case. If there is no entry in 'post' table for
             * this glyph index, using Glyph ID as the name.
             * Fix Adobe Bug 233027.
             */
        }
        else if (newIndex < MAX_MACINDEX )
        {
            if (gMacGlyphNames)
            {
                pszName    = gMacGlyphNames[newIndex];
                *bGoodName = 1; /* GoodName */
            }
        }
        break;
#endif

    case POST_FORMAT_30: /* No name at all */

        /*
         * Do we want to add 'cmap' reverse parsing?
         * It would be very expensive!!
         */
        break;

    default:
        break;
    }

    return pszName;
}


UFLBool
BHasGoodPostTable(
    UFOStruct   *pUFO
    )

/*++

Routine Description:

    Function to check if good 'post' table is available or not.
    As of to day, only format 1.0, 2.0, 2.5 are considered good - we can get
    "good GlyphNames" from it.

--*/

{
    POSTHEADER      postHeader;
    unsigned long   dwSize;
    long            lFormat;

    /*
     * Get the 'post' table record to figure out the format.
     */
    dwSize = GETTTFONTDATA(pUFO,
                            POST_TABLE, 0L,
                            &postHeader, sizeof (POSTHEADER),
                            pUFO->pFData->fontIndex);
    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0;

    lFormat = MOTOROLALONG(postHeader.format);

    if ((lFormat == POST_FORMAT_10)
        || (lFormat == POST_FORMAT_20)
        || (lFormat == POST_FORMAT_25))
        return 1;

    return 0;
}


short int
CreateXUIDArray(
    UFOStruct       *pUFO,
    unsigned long   *pXuid
    )

/*++

Routine Description:

    Creates a xuid array in pXuid for this UFO.
    It's format is [44 checkSUM]. 44 is a new XUID identifier given by
    TDoweling 2/10/99. The checkSUM is a cumulation of all the entry in
    TableEntry. We do this to fix bug 287085.

    If pXuid is null, return the "number of long"s needed in pXuid pointer.

--*/
{
    short int       num   = 0;
    unsigned long   ulSum = 0;


    /* The first number is 44. */
    if (pXuid)
        *pXuid = 44;
    num++;

    if (pXuid)
    {
        TableDirectoryStruct    tableDir;
        TableEntryStruct        tableEntry;
        unsigned long           dwSize;
        unsigned short int      i;

        /* Get the TableDirectory from the TTC/TTF file. */
        dwSize = GETTTFONTDATA(pUFO,
                                nil, pUFO->pFData->offsetToTableDir,
                                &tableDir, sizeof tableDir,
                                pUFO->pFData->fontIndex);
        if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
            return 0;

        for (i = 0; i < MOTOROLAINT(tableDir.numTables); i++)
        {
            /*
             * Get each TableEntry which are right after Directory in TTC/TTF file.
             */
            dwSize = GETTTFONTDATA(pUFO,
                                    nil, pUFO->pFData->offsetToTableDir
                                            + sizeof (TableDirectoryStruct)
                                            + (i * sizeof (TableEntryStruct)),
                                    &tableEntry, sizeof tableEntry,
                                    pUFO->pFData->fontIndex);
            if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
                return 0;

            ulSum += (unsigned long)tableEntry.tag;
            ulSum += (unsigned long)tableEntry.checkSum;
            ulSum += (unsigned long)tableEntry.offset;
            ulSum += (unsigned long)tableEntry.length;
        }
    }

    if (pXuid)
        *(pXuid + 1) = ulSum;
    num++;

    return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\uflsproc.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLSProc.h
 *
 *  This file contents standard C procedure implementation.
 *
 *
 * $Header:
 */

#include "UFLCnfig.h"
#include "UFLTypes.h"
#include "UFLStd.h"

#ifdef UNIX
#include <sys/varargs.h>
#include <assert.h>
#else
    #ifdef MAC_ENV
        #include <assert.h>
    #endif
    #include <stdarg.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

int strcmpW( unsigned short *str1, unsigned short *str2 )
{
    int retVal = 0;

    if( str1 == NULL || str2 == NULL )
        retVal = (int)(str1 - str2);

    else
    {
        while( *str1 != 0 && *str2 != 0 && *str1 == *str2 )
        {
            str1++;
            str2++;
        }

        retVal = *str1 - *str2;
    }

    return retVal;
}

/* Digit characters used for converting numbers to ASCII */

const char DigitString[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
#define HexDigit(n)    DigitString[(n) & 0x0F]


int
UFLvsprintf(
    char    *buf,
    size_t  cchDest,
    const char *fmtstr,
    va_list arglist
    )

/*++

Routine Description:

    Takes a pointer to an argument list, then formats and writes
    the given data to the memory pointed to by buffer.

Arguments:

    buf     Storage location for output
    cchDest size (in chars) of the destination buffer
    fmtstr  Format specification
    arglist Pointer to list of arguments

Return Value:

    Return the number of characters written, not including
    the terminating null character, or a negative value if
    an output error occurs.

[Note:]

    This is NOT a full implementation of "vsprintf" as found
    in the C runtime library. Specifically, the only form of
    format specification allowed is %type, where "type" can
    be one of the following characters:

    d   int     signed decimal integer
    l   long    signed decimal integer
    ld  long    signed decimal integer
    lu  unsigned long   unsigned decimal integer
    u   unsigned int  unsigned decimal integer
    s   char*   character string
    c   char    character
    x,X unsigned long   hex number (emits at least two digits, uppercase)
    b   UFLBool    boolean (true or false)
    f   long    24.8 fixed-pointed number

--*/

{
    char *ptr, *ptrEnd;
    char achTmp[36];    // for _ltoa/_ultoa use

    if (buf == 0 || cchDest == 0 || fmtstr == 0)
        return 0;

    ptr = buf;
    ptrEnd = ptr + cchDest;

    while (*fmtstr != '\0')
    {
        if (*fmtstr != '%')
        {

            /* Normal character */

            *ptr++ = *fmtstr++;
        }
        else
        {

            /* Format specification */

            switch (*++fmtstr) {

            case 'd':       /* signed decimal integer */

                _ltoa((long) va_arg(arglist, int), achTmp, 10);
                KStringCchCopyA(ptr, ptrEnd - ptr, achTmp);
                ptr += UFLstrlen(ptr);
                break;

            case 'l':       /* signed decimal integer */

                if (*++fmtstr != '\0')
                {
                   if (*fmtstr == 'u')
                   {
                      _ultoa(va_arg(arglist, unsigned long), achTmp, 10);
                      KStringCchCopyA(ptr, ptrEnd - ptr, achTmp);
                      ptr += UFLstrlen(ptr);
                      break;
                   }
                   else if (*fmtstr == 'd')
                   {
                      _ltoa((long) va_arg(arglist, long), achTmp, 10);
                      KStringCchCopyA(ptr, ptrEnd - ptr, achTmp);
                      ptr += UFLstrlen(ptr);
                      break;
                   }
                }
                /* Default to unsigned long */
                _ltoa(va_arg(arglist, long), achTmp, 10);
                KStringCchCopyA(ptr, ptrEnd - ptr, achTmp);
                ptr += UFLstrlen(ptr);
                fmtstr--;
                break;

            case 'u':       /* unsigned decimal integer */

                _ultoa((unsigned long)va_arg(arglist, unsigned int), achTmp, 10);
                KStringCchCopyA(ptr, ptrEnd - ptr, achTmp);
                ptr += UFLstrlen(ptr);
                break;

            case 's':       /* character string  */

                {
                    char *s = va_arg(arglist, char *);

                    while (*s)
                    {
                        *ptr++ = *s++;

                        if (ptr >= ptrEnd)
                        {
                            break;
                        }
                    }
                }
                break;

            case 'c':       /* character */

                *ptr++ = va_arg(arglist, char);
                break;

            case 'x':
            case 'X':       /* hexdecimal number */

                {
                    unsigned long   ul = va_arg(arglist, unsigned long);
                    int     ndigits = 8;

                    while (ndigits > 2 && ((ul >> (ndigits-1)*4) & 0xf) == 0)
                        ndigits--;

                    while (ndigits-- > 0)
                    {
                        *ptr++ = HexDigit(ul >> ndigits*4);

                        if (ptr >= ptrEnd)
                        {
                            break;
                        }
                    }
                }
                break;

            case 'b':       /* boolean */

                KStringCchCopyA(ptr, ptrEnd - ptr, (va_arg(arglist, UFLBool)) ? "true" : "false");
                ptr += UFLstrlen(ptr);
                break;

            case 'f':       /* 24.8 fixed-pointed number */

                {
                    long    l = va_arg(arglist, long);
                    unsigned long   ul, scale;

                    /* sign character */

                    if (l < 0)
                    {
                        *ptr++ = '-';

                        if (ptr >= ptrEnd)
                        {
                            break;
                        }

                        ul = -l;
                    } else
                        ul = l;

                    // integer portion

                    _ultoa(ul >> 8, achTmp, 10);
                    KStringCchCopyA(ptr, ptrEnd - ptr, achTmp);
                    ptr += UFLstrlen(ptr);

                    if (ptr >= ptrEnd)
                    {
                        break;
                    }

                    // fraction

                    ul &= 0xff;
                    if (ul != 0)
                    {

                        // We output a maximum of 3 digits after the
                        // decimal point, but we'll compute to the 5th
                        // decimal point and round it to 3rd.

                        ul = ((ul*100000 >> 8) + 50) / 100;
                        scale = 100;

                        *ptr++ = '.';
                        do {
                            if (ptr >= ptrEnd)
                            {
                                break;
                            }

                            *ptr++ = (char) (ul/scale + '0');
                            ul %= scale;
                            scale /= 10;
                        } while (scale != 0 && ul != 0) ;
                    }
                }
                break;

            default:
                if (*fmtstr != '\0')
                    *ptr++ = *fmtstr;
                else
                {
                    fmtstr--;
                }
                break;
            }

            /* Skip the type characterr  */

            fmtstr++;
        }

        //
        // If we are beyond the end of dest buffer,
        // we need to go back so the dest buffer will
        // be null terminated.
        //
        if (ptr >= ptrEnd)
        {
            ptr = ptrEnd - 1;
            break;
        }
    }

    *ptr = '\0';
    return (int)(ptr - buf);
}

/*
    This is NOT a full implementation of "sprintf" as found
    in the C runtime library. Specifically, the only form of
    format specification allowed is %type, where "type" can
    be one of the following characters:

    d   int     signed decimal integer
    l   long    signed decimal integer
    ld  long    signed decimal integer
    lu  unsigned long   unsigned decimal integer
    u   unsigned int  unsigned decimal integer
    s   char*   character string
    c   char    character
    x,X unsigned long   hex number (emits at least two digits, uppercase)
    b   UFLBool    boolean (true or false)
    f   long    24.8 fixed-pointed number

    Normally, you should use UFLsprintf.  Use this function
    only when you want to sprintf with %f in the form of 24.8 fixed point
    number.

*/
int
UFLsprintfEx(
    char    *buf,
    size_t  cchDest,
    const char    *fmtstr,
    ...
    )
{
    va_list arglist;
    int     retval;

    va_start(arglist, fmtstr);
    retval = UFLvsprintf(buf, cchDest, fmtstr, arglist);
    va_end(arglist);

    return retval;
}


/****************************************************************************/

#if defined(UNIX) || defined(MAC_ENV)   /* Define needed functions */

/****************************************************************************/

char *_ltoa( long val, char *str, int radix )
{
    /* This is the only supported radix: */
    assert( radix == 10 );

    sprintf( str, "%ld", val );
    return str;
}

char *_ultoa( unsigned long val, char *str, int radix )
{
    /* This is the only supported radix: */
    assert( radix == 10 );

    sprintf( str, "%lu", val );
    return str;
}

#endif

/****************************************************************************/

#ifdef WIN32KERNEL

/****************************************************************************/

#include <stdio.h>

int
UFLsprintf(
    char    *buf,
    size_t  cchDest,
    const char    *fmtstr,
    ...
    )
{
    va_list arglist;
    int     retval;

    va_start(arglist, fmtstr);
    retval = vsprintf(buf, fmtstr, arglist);
    va_end(arglist);

    return retval;
}


/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then strtol/strtoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               strtol -- LONG_MAX or LONG_MIN
*               strtoul -- ULONG_MAX
*               strtol/strtoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/

/* flag values */
#include <limits.h>
#include <errno.h>

#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

static unsigned long UFLstrtolx (
        const char *nptr,
        const char **endptr,
        int ibase,
        int flags
        )
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while ( isspace((int)(unsigned char)c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( isdigit((int)(unsigned char)c) )
                        digval = c - '0';
                else if ( isalpha((int)(unsigned char)c) )
                        digval = toupper(c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                errno = ERANGE;
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}

long UFLstrtol (
        const char *nptr,
        char **endptr,
        int ibase
        )
{
    return (long) UFLstrtolx(nptr, endptr, ibase, 0);

}

#endif  // ifdef WIN32KERNEL


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\uflmem.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLMem.c
 *
 *        These are the memory allocation, deletion, etc... routines used by UFL.
 *        All memory blocks are allocated at the given size plus the size of 1
 *        unsigned long.  The current size of the block is then stored in the first
 *        unsigned long in the block.  The address of the block plus the first unsigned long
 *        is returned to the caller.
 *
 * $Header:
 */

#include "UFLCnfig.h"
#ifdef MAC_ENV
#include <Memory.h>
#endif

#include "UFLMem.h"
#include "UFLStd.h"

#ifdef KERNEL_MODE

PVOID UFLEXPORT
KMNewPtr(
    PVOID   p,
    ULONG   ulSize
    )

{
    if (p != NULL)
    {
        *((PULONG) p) = ulSize;
        return (PBYTE) p + sizeof(ULONG_PTR);
    }
    else
        return NULL;
}

VOID UFLEXPORT
KMDeletePtr(
    PVOID   p
    )

{
    if (p != NULL)
        MemFree((PBYTE) p - sizeof(ULONG_PTR));
}

#else // !KERNEL_MODE

#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_D0
#endif

/* Global static variable */
void *UFLEXPORT
UFLNewPtr(
    const UFLMemObj *mem,
    unsigned long   size
    )
{

    unsigned long*    p = (unsigned long*)(*mem->alloc)((UFLsize_t) (size + sizeof(ULONG_PTR)), mem->userData );
    if ( p == (unsigned long*)nil )
        return nil;

    // Memory allocated by UFLNewPtr is zero-initalized.

    *p = size;
    UFLmemset(mem, (void*)((char *)p + sizeof(ULONG_PTR)), 0, size);

    return (void*)((char *)p + sizeof(ULONG_PTR));

}

void UFLEXPORT
UFLDeletePtr(
    const UFLMemObj *mem,
    void            *ptr
    )
{
    if ( ptr != nil )
        (*mem->free)( (void*)( ((unsigned char*)ptr) - sizeof(ULONG_PTR) ), mem->userData );
}

#if defined(MAC_ENV) && defined(__MWERKS__) && !defined(powerc)
#pragma pointers_in_A0
#endif

#ifdef MAC_ENV
// on the Macintosh, memcpy is frequently not well implemented because
// most applications call BlockMove instead.

void UFLEXPORT
UFLmemcpy(
    const UFLMemObj *mem,
    void          *destination,
    void          *source,
    unsigned long size
    )
{
    if ( (((unsigned long)source) & 3) || (((long)destination) & 3) )
        BlockMove( source, destination, size );

    else    {

        unsigned long    *src = (unsigned long*)source;
        unsigned long    *dst = (unsigned long*)destination;
        unsigned char    *srcb, *dstb;
        long    count = (size >> 2) + 1;

        while ( --count )
            *dst++ = *src++;

        count = (size & 3);
        if ( count != 0 )    {
            srcb = (unsigned char*)src;
            dstb = (unsigned char*)dst;
            ++count;
            while ( --count )
                *dstb++ = *srcb++;
        }
    }

}

#else

void UFLEXPORT
UFLmemcpy(
    const UFLMemObj *mem,
    void *destination,
    void *source,
    unsigned long size
    )
{
    if ( destination != nil  && source != nil)
        (*mem->copy)( (void*)destination, (void*)source, (UFLsize_t) size , mem->userData );

//   don't want to use this because size parameter is system dependend
//   allow the client to chose whichever way.
    // Warning!!! be carefull of platforms on which size_t is a 2 byte integer
    //memcpy( destination, source, (size_t)size );
}

#endif // !MAC_ENV

#endif // !KERNEL_MODE

void UFLEXPORT
UFLmemset(
    const UFLMemObj *mem,
    void *destination,
    unsigned int value,
    unsigned long size
    )
{
    if ( destination != nil )
        (*mem->set)( (void*)destination, value ,  size , mem->userData );

//   don't want to use this because size parameter is system dependend
//   allow the client to chose whichever way.
//    memset( destination, value, (UFLsize_t)size );

}

unsigned long
UFLMemSize(
    void *ptr
    )
{
    return *(unsigned long *) ((unsigned char *)ptr - sizeof(ULONG_PTR));
}

UFLBool
UFLEnlargePtr(
    const UFLMemObj *mem,
    void            **ptrAddr,
    unsigned long   newSize,
    UFLBool         bCopy
    )
{
    unsigned long    oldSize =  *(unsigned long *) ((unsigned char *)(*ptrAddr) - sizeof(ULONG_PTR));
    void *newBuf;

    newBuf = UFLNewPtr( mem, newSize );
    if ( newBuf == nil )
        return 0;
    if ( bCopy )
        UFLmemcpy( mem, newBuf, *ptrAddr, (unsigned long)min(oldSize, newSize) );
    UFLDeletePtr( mem, *ptrAddr );
    *ptrAddr = newBuf;

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\ufo.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFO.c - Universal Font Object
 *
 *
 * $Header:
 */

#include "UFO.h"
#include "UFLMem.h"
#include "UFLErr.h"
#include "UFLStd.h"
#include "UFOCff.h"
#include "UFOTTT1.h"
#include "UFOTTT3.h"
#include "UFOT42.h"
#include "ParseTT.h"

/*
 * Private default methods used by UFO base class
 */
UFLErrCode
UFODefaultVMNeeded(
    const UFOStruct     *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    )
{
    return kErrInvalidFontType;
}


UFLErrCode
UFODefaultUndefineFont(
    const UFOStruct *pUFObj
    )
{
    return kErrInvalidFontType;
}


void
UFODefaultCleanUp(
    UFOStruct *pUFObj
    )
{
}


UFLErrCode
UFODefaultDownloadIncr(
    const UFOStruct     *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    )
{
    return kErrInvalidFontType;
}


UFOStruct *
UFODefaultCopy(
    UFOStruct *pUFObj
    )
{
    return nil;
}


/*
 * Public methods
 */
void
UFOInitData(
    UFOStruct           *pUFObj,
    int                 ufoType,
    const UFLMemObj     *pMem,
    const UFLStruct     *pSession,
    const UFLRequest    *pRequest,
    pfnUFODownloadIncr  pfnDownloadIncr,
    pfnUFOVMNeeded      pfnVMNeeded,
    pfnUFOUndefineFont  pfnUndefineFont,
    pfnUFOCleanUp       pfnCleanUp,
    pfnUFOCopy          pfnCopy
    )
{
    short sNameLen   = 0;
    short sEncodeLen = 0;

    /*
     * Initialize basic fields
     */
    pUFObj->ufoType             = ufoType;
    pUFObj->flState             = kFontCreated;
    pUFObj->lProcsetResID       = 0;        /* resource ID of the required procset    */
    pUFObj->dwFlags             = 0;
    pUFObj->pMem                = pMem;
    pUFObj->pUFL                = pSession; /* the session handle returned by FTLInit */

    pUFObj->pAFont              = nil;

    pUFObj->pUpdatedEncoding    = nil;

    pUFObj->pFData              = nil;
    pUFObj->lNumNT4SymGlyphs    = 0;


    /*
     * Handle request data.
     */

    pUFObj->lDownloadFormat = pRequest->lDownloadFormat;
    pUFObj->hClientData     = pRequest->hData;
    pUFObj->subfontNumber   = pRequest->subfontNumber;

    /*
     * Allocate a buffer to hold both FontName and EncodeName. This will be
     * freed in UFOCleanUpData().
     */
    pUFObj->pszFontName   = nil;
    pUFObj->pszEncodeName = nil;

    if ((pRequest->pszFontName == nil) || (pRequest->pszFontName[0] == '\0'))
        return;

    sNameLen = UFLstrlen(pRequest->pszFontName) + 1; /* Add extra 1 for NULL. */

    if (pRequest->pszEncodeName)
        sEncodeLen = UFLstrlen(pRequest->pszEncodeName) + 1; /* Add extra 1 for NULL. */

    pUFObj->pszFontName = (char *)UFLNewPtr(pUFObj->pMem, sNameLen + sEncodeLen);

    if (pUFObj->pszFontName != nil)
    {
        StringCchCopyA(pUFObj->pszFontName, sNameLen / sizeof(char), pRequest->pszFontName);

        if (pRequest->pszEncodeName)
        {
            pUFObj->pszEncodeName = pUFObj->pszFontName + sNameLen;
            StringCchCopyA(pUFObj->pszEncodeName, sEncodeLen / sizeof(char), pRequest->pszEncodeName);
        }
    }

    /*
     * If this flag is set to 1, then UFL will use the name passed in without
     * parsing 'post' table.
     */
    pUFObj->useMyGlyphName = pRequest->useMyGlyphName;

    /*
     * The buffer that contains MacGlyphNameList are locked all the time.
     * The containt in that buffer will not be changed. So, we do'nt need to
     * copy the data to the private UFL buffer.
     */
    if (pRequest->pMacGlyphNameList)
        pUFObj->pMacGlyphNameList = pRequest->pMacGlyphNameList;
    else
        pUFObj->pMacGlyphNameList = nil;

    /* Fix bug 274008 */
    if (pRequest->pEncodeNameList
        && pRequest->pwCommonEncode
        && pRequest->pwExtendEncode)
    {
        /*
         * The glyph handles are in ANSI codepage order or other standard
         * codepage order (1250, 1251, ... 1257). The buffer that contains
         * EncodeNameList and CommonEncode are locked all the time.
         * The containt in that buffer will not be changed. So, we do'nt need
         * to copy the data to the private UFL buffer.
         */
        pUFObj->pEncodeNameList = pRequest->pEncodeNameList;
        pUFObj->pwCommonEncode  = pRequest->pwCommonEncode;
        pUFObj->pwExtendEncode  = pRequest->pwExtendEncode;
    }
    else
    {
        pUFObj->pEncodeNameList = nil;
        pUFObj->pwCommonEncode  = nil;
        pUFObj->pwExtendEncode  = nil;
    }

    /* Fix #387084, #309104, and #309482. */
    pUFObj->vpfinfo = pRequest->vpfinfo;

    /* %hostfont% support */
    pUFObj->hHostFontData = pRequest->hHostFontData;

    if (HOSTFONT_IS_VALID_UFO_HFDH(pUFObj))
        HOSTFONT_VALIDATE_UFO(pUFObj);

    /* Fix #341904 */
    pUFObj->bPatchQXPCFFCID = pRequest->bPatchQXPCFFCID;


    /*
     * Initialize method pointers.
     */
    if (pfnDownloadIncr == nil)
        pUFObj->pfnDownloadIncr = (pfnUFODownloadIncr)UFODefaultDownloadIncr;
    else
        pUFObj->pfnDownloadIncr = pfnDownloadIncr;

    if (pfnVMNeeded == nil)
        pUFObj->pfnVMNeeded = (pfnUFOVMNeeded)UFODefaultVMNeeded;
    else
        pUFObj->pfnVMNeeded = pfnVMNeeded;

    if (pfnUndefineFont == nil)
        pUFObj->pfnUndefineFont = (pfnUFOUndefineFont)UFODefaultUndefineFont;
    else
        pUFObj->pfnUndefineFont = pfnUndefineFont;

    if (pfnCleanUp == nil)
        pUFObj->pfnCleanUp = (pfnUFOCleanUp)UFODefaultCleanUp;
    else
        pUFObj->pfnCleanUp = pfnCleanUp;

    if (pfnCopy == nil)
        pUFObj->pfnCopy = (pfnUFOCopy)UFODefaultCopy;
    else
        pUFObj->pfnCopy = pfnCopy;
}


void UFOCleanUpData(
    UFOStruct *pUFObj
    )
{
    /* Free data that is NOT shared  */
    if (pUFObj->pszFontName)
    {
        UFLDeletePtr(pUFObj->pMem, pUFObj->pszFontName);
        pUFObj->pszFontName = nil;
    }

    if (pUFObj->pUpdatedEncoding)
    {
        UFLDeletePtr(pUFObj->pMem, pUFObj->pUpdatedEncoding);
        pUFObj->pUpdatedEncoding = nil;
    }
}


UFLBool
bUFOTestRestricted(
    const UFLMemObj *pMem,
    const UFLStruct *pSession,
    const UFLRequest *pRequest
    )
{
    UFLBool   bRetVal = 0;
    UFOStruct *pUFObj = CFFFontInit(pMem, pSession, pRequest, &bRetVal);

    if (pUFObj)
        UFOCleanUp(pUFObj);

    return bRetVal;
}


UFOStruct *
UFOInit(
    const UFLMemObj *pMem,
    const UFLStruct *pSession,
    const UFLRequest *pRequest
    )
{
    UFOStruct *pUFObj = nil;

    switch (pRequest->lDownloadFormat)
    {
    case kCFF:
    case kCFFCID_H:
    case kCFFCID_V:
        if (!bUFOTestRestricted(pMem, pSession, pRequest))
            pUFObj = CFFFontInit(pMem, pSession, pRequest, nil);
    break;

    case kTTType1:          /* TT Font in Type 1 format  */
        pUFObj = TTT1FontInit(pMem, pSession, pRequest);
    break;

    case kTTType3:          /* TT Font in Type 3 format   */
    case kTTType332:        /* TT Font in Type 3/32 combo */
        pUFObj = TTT3FontInit(pMem, pSession, pRequest);
    break;

    case kTTType42:                 /* TT Font in Type 42 format       */
    case kTTType42CID_H:            /* TT Font in CID Type 42 format H */
    case kTTType42CID_V:            /* TT Font in CID Type 42 format V */
    case kTTType42CID_Resource_H:   /* TT Font: create CIDFont Resource only, no composefont */
    case kTTType42CID_Resource_V:   /* TT Font: create CIDFont Resource only, no composefont */
        pUFObj = T42FontInit(pMem, pSession, pRequest);
    break;

    default:
        pUFObj = nil;
    }

    return pUFObj;
}


void
UFOCleanUp(
    UFOStruct *pUFObj
    )
{
    /* Free data that is NOT shared. */
    UFOCleanUpData(pUFObj);

    /* Free data that is Shared: decrease refCount or really free buffers. */
    vDeleteFont(pUFObj);

    /* Finally Free the UFOStruct itself. */
    UFLDeletePtr(pUFObj->pMem, pUFObj);
}


UFLErrCode
UFODownloadIncr(
    const UFOStruct     *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    )
{
    return pUFObj->pfnDownloadIncr(pUFObj, pGlyphs, pVMUsage, pFCUsage);
}


UFLErrCode
UFOVMNeeded(
    const UFOStruct     *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    )
{
    return pUFObj->pfnVMNeeded(pUFObj, pGlyphs, pVMNeeded, pFCNeeded);
}


UFLErrCode
UFOUndefineFont(
    const UFOStruct *pUFObj
    )
{
    return pUFObj->pfnUndefineFont(pUFObj);
}


UFOStruct *
UFOCopyFont(
    const UFOStruct *pUFObj,
    const UFLRequest* pRequest
    )
{
    return pUFObj->pfnCopy(pUFObj, pRequest);
}


UFLErrCode
UFOGIDsToCIDs(
    const UFOStruct    *pUFO,
    const short        cGlyphs,
    const UFLGlyphID   *pGIDs,
    unsigned short     *pCIDs
    )
{
    CFFFontStruct   *pFont = (CFFFontStruct *)pUFO->pAFont->hFont;
    UFLErrCode      retVal = kErrInvalidFontType;

    if ((pUFO->lDownloadFormat == kCFFCID_H) || (pUFO->lDownloadFormat == kCFFCID_V))
        retVal = CFFGIDsToCIDs(pFont, cGlyphs, pGIDs, pCIDs);

    return retVal;
}


UFLBool
FindGlyphName(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    short               i,           /* ANSI index  */
    unsigned short      wIndex,      /* Glyph Index */
    char                **pGoodName
    )

/*++

    return value: 0 -- Can not find a good glyph name, using /Gxxxx.
                       xxxx is a glyph id or predefined number(00-FF).
                  1 -- Find a good glyph name
--*/

{
    char    *pHintName = nil;
    UFLBool bGoodName  = 0;  /* GoodName */


    if (pUFObj->useMyGlyphName && pGlyphs->ppGlyphNames)
        pHintName = (char *)pGlyphs->ppGlyphNames[i];

    if (pUFObj->useMyGlyphName && pHintName != nil)
        *pGoodName = pHintName;

    /*
     * Fix bug 274008 Get CharName from pre-defined table. This is only for
     * DownloadFace.
     */
    else if (pUFObj->pEncodeNameList && (i < 256))
    {
        /* Fix bug 274008 */
        char **pIndexTable = (char **)(pUFObj->pEncodeNameList);

        if (i < 128)
            *pGoodName = pIndexTable[pUFObj->pwCommonEncode[i]];
        else
            *pGoodName = pIndexTable[pUFObj->pwExtendEncode[i - 128]];

        bGoodName = 1; /* GoodName */
    }
    else
    {
        /* GoodName */
        *pGoodName = GetGlyphName(pUFObj, wIndex, pHintName, &bGoodName);

        if (!bGoodName && !(pGlyphs->pCode && pGlyphs->pCode[i]))
        {
            unsigned short unicode;

            /*
             * If GDI passes UV to the driver, we will use /gDDDDD as name and
             * add a hint to G2Udict. Otherwise, Parse CMAP table for unicode.
             */
            if (ParseTTTablesForUnicode(pUFObj, wIndex, &unicode, 1, DTT_parseCmapOnly))
            {
                // Fixed bug #516516. Now the buffer size is MAX_GLYPHNAME_LEN (256)
                char    *gGlyphName = pUFObj->pAFont->gGlyphName;

                UFLsprintf(gGlyphName, CCHOF(pUFObj->pAFont->gGlyphName), "uni%04X", unicode);
                *pGoodName = gGlyphName;
                bGoodName = 1;
            }
        }
    }

    return bGoodName; /* GoodName */
}


/*
 * this function actually generates some PostScript that updates endocing
 * vector for entries from sStart to sEnd - 1.
 */
UFLErrCode
UpdateEncodingVector(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    short int           sStart,
    short int           sEnd
    )
{
    const static char encodingBegin[] = " findfont /Encoding get";
    const static char encodingEnd[]   = "pop";

    UFLHANDLE       stream = pUFObj->pUFL->hOut;
    UFLErrCode      retVal = kNoErr;
    short           i;

    /*
     * both start and end must be in the range of 0 to sCount.
     */
    if ((sStart < 0) || (sEnd > pGlyphs->sCount) || (sStart >= sEnd))
        return kErrInvalidArg;

    retVal = StrmPutString(stream, "/");
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, pUFObj->pszFontName);
    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, encodingBegin);

    for (i = sStart; (retVal == kNoErr) && (i < sEnd); ++i)
    {
        if ((0 == pUFObj->pUFL->bDLGlyphTracking)
            || (pGlyphs->pCharIndex == nil)
            || !IS_GLYPH_SENT(pUFObj->pUpdatedEncoding, pGlyphs->pCharIndex[i]))
        {
            char            *pGoodName;
            char            buf[16];
            unsigned short  wIndex = (unsigned short)(pGlyphs->pGlyphIndices[i] & 0x0000FFFF);  /* LOWord is the GID. */

            FindGlyphName(pUFObj, pGlyphs, i, wIndex, &pGoodName);

            if (pGlyphs->pCharIndex)
                UFLsprintf(buf, CCHOF(buf), "dup %d /", pGlyphs->pCharIndex[i]);
            else
                UFLsprintf(buf, CCHOF(buf), "dup %d /", i);

            retVal = StrmPutString(stream, buf);
            if (retVal == kNoErr)
                retVal = StrmPutString(stream, pGoodName);
            if (retVal == kNoErr)
                retVal = StrmPutStringEOL(stream, " put");

            if ((retVal == kNoErr) && pGlyphs->pCharIndex)
                SET_GLYPH_SENT_STATUS(pUFObj->pUpdatedEncoding, pGlyphs->pCharIndex[i]);
        }
    }

    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, encodingEnd);

    return retVal;
}


UFLErrCode
UpdateCodeInfo(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    UFLBool             bT3T32Font
    )
{
    UFLHANDLE       stream       = pUFObj->pUFL->hOut;
    UFLGlyphID      *glyphs      = pGlyphs->pGlyphIndices;
    UFLErrCode      retVal       = kNoErr;
    UFLBool         bHeaderSent  = 0;   /* GoodName */
    UFLBool         bUniCodeCmap = 0;
    UFLBool         bCheckCmap   = 0;
    char            glyphNameID[64], strmbuf[256];
    short           i;

    if (GetTablesFromTTFont(pUFObj))
        bUniCodeCmap = TTcmap_IS_UNICODE(pUFObj->pAFont->cmapFormat);

    if ((pGlyphs->pCode && bUniCodeCmap) || (pGlyphs->pCode == NULL))
        bCheckCmap = 1;

    if (pGlyphs->pCode)
        bUniCodeCmap = 1;

    for (i = 0; (retVal == kNoErr) && (i < pGlyphs->sCount); ++i)
    {
        unsigned short unicode = 0;   /* GoodName */
        unsigned short wIndex  = (unsigned short)(glyphs[i] & 0x0000FFFF); /* LOWord is the GlyphID. */

        if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
            continue;

        if (IS_GLYPH_SENT( pUFObj->pAFont->pCodeGlyphs, wIndex))
            continue;

        if (IS_TYPE42CID(pUFObj->lDownloadFormat) || IS_CFFCID(pUFObj->lDownloadFormat))
        {
            UFLsprintf(glyphNameID, CCHOF(glyphNameID), "%d ", wIndex);

            if (pGlyphs->pCode && pGlyphs->pCode[i])
                unicode = pGlyphs->pCode[i];
            else if (bCheckCmap)
                ParseTTTablesForUnicode(pUFObj,
                                        wIndex, &unicode,
                                        1, DTT_parseAllTables);
        }
        else
        {
            char *pGoodName;

            FindGlyphName(pUFObj, pGlyphs, i, wIndex, &pGoodName);

            UFLsprintf(glyphNameID, CCHOF(glyphNameID), "/%s ", pGoodName);

            if (pGlyphs->pCode && pGlyphs->pCode[i])
                unicode = pGlyphs->pCode[i];
            else if (bCheckCmap)
            {
                if (bUniCodeCmap)
                    ParseTTTablesForUnicode(pUFObj,
                                            wIndex, &unicode,
                                            1, DTT_parseMoreGSUBOnly);
                else
                    ParseTTTablesForUnicode(pUFObj,
                                            wIndex, &unicode,
                                            1, DTT_parseAllTables);
            }
        }

        if (unicode && !bHeaderSent)
        {
            bHeaderSent = 1;

            /*
             * Output "/FontName /Font" or "/CIDFontResource /CIDFont"
             */
            if (IS_TYPE42CID(pUFObj->lDownloadFormat))
            {
                /*
                 * If CID-keyed font, then append "CID" to the CIDFont name.
                 */
                if (IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat))
                {
                    T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
                    UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s%s", pFont->info.CIDFontName, gcidSuffix[0]);
                }
                else
                {
                    UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s", pUFObj->pszFontName);
                }

                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, strmbuf);

                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, " /CIDFont");
            }
            else if (IS_CFFCID(pUFObj->lDownloadFormat))
            {
                CFFFontStruct *pFont = (CFFFontStruct *)pUFObj->pAFont->hFont;

                if (pFont->info.type1)
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s", pFont->info.baseName);
                else
                {
                    /* Reuse vifinfo.nPlatformID to fix #507985. */
                    if (pUFObj->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
                    {
                        if (pUFObj->lDownloadFormat == kCFFCID_H)
                            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s", CFFPREFIX_H, pFont->info.baseName);
                        else
                            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s", CFFPREFIX_V, pFont->info.baseName);
                    }
                    else
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s", CFFPREFIX, pFont->info.baseName);
                }

                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, strmbuf);

                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, " /CIDFont");
            }
            else
            {
                if (bT3T32Font)   /* GoodName */
                    StrmPutStringEOL(stream, "Is2016andT32? not {");

                UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s", pUFObj->pszFontName);
                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, strmbuf);

                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, " /Font");
            }

            if (kNoErr == retVal)
            {
                if (bUniCodeCmap)
                    retVal = StrmPutStringEOL(stream, " G2UBegin");
                else
                {
                    retVal = StrmPutStringEOL(stream, " G2CCBegin");
                    if (pUFObj && pUFObj->pAFont)
                    {
                       if (TTcmap_IS_J_CMAP(pUFObj->pAFont->cmapFormat))
                          retVal = StrmPutStringEOL(stream, "/WinCharSet 128 def");
                       else if (TTcmap_IS_CS_CMAP(pUFObj->pAFont->cmapFormat))
                          retVal = StrmPutStringEOL(stream, "/WinCharSet 134 def");
                       else if (TTcmap_IS_CT_CMAP(pUFObj->pAFont->cmapFormat))
                          retVal = StrmPutStringEOL(stream, "/WinCharSet 136 def");
                       else if (TTcmap_IS_K_CMAP(pUFObj->pAFont->cmapFormat))
                          retVal = StrmPutStringEOL(stream, "/WinCharSet 129 def");
                    }
                }
            }
        }

        if (unicode)
        {
            if (retVal == kNoErr)
                retVal = StrmPutString(stream, glyphNameID);

            /*
             * support only one CodePoint per glyph.
             */
            UFLsprintf(strmbuf, CCHOF(strmbuf), "<%04X> def", unicode);
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);

            SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pCodeGlyphs, wIndex);
        }
    }

    if ((kNoErr == retVal) && bHeaderSent)
    {
        retVal = StrmPutStringEOL(stream, "G2UEnd"); /* end for UV or CC */

        if (bT3T32Font)  /* GoodName */
            StrmPutStringEOL(stream, "} if");
    }

    return retVal;
}


UFLErrCode
ReEncodePSFont(
    const UFOStruct *pUFObj,
    const char      *pszNewFontName,
    const char      *pszNewEncodingName
    )
{
    const static char copyFontBegin[]   = " findfont dup maxlength dict begin "
                                          "{1 index /FID ne {def} {pop pop} ifelse} forall";
    const static char copyFontEnd[]     = " currentdict end definefont pop";

    UFLHANDLE       stream = pUFObj->pUFL->hOut;
    UFLErrCode      retVal = kNoErr;

    retVal = StrmPutString(stream, "/");
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, pszNewFontName);

    if (kNoErr == retVal)
        retVal = StrmPutString(stream, "/");

    if (kNoErr == retVal)
        retVal = StrmPutString(stream, pUFObj->pszFontName);

    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, copyFontBegin);

    /*
     * Put a new encoding vectory here.
     */
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, "/Encoding ");

    if (kNoErr == retVal)
    {
        if (pszNewEncodingName == nil)
            retVal = StrmPutString(stream, gnotdefArray);
        else
            retVal = StrmPutString(stream, pszNewEncodingName);
    }

    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, " def");

    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, copyFontEnd);

    return retVal;
}


UFLErrCode
RecomposefontCIDFont(
    const UFOStruct *pUFOSrc,
          UFOStruct *pUFObj
    )
{
    char        *pHostFontName;
    UFLErrCode  retVal;

    HostFontValidateUFO(pUFObj, &pHostFontName);

    if (IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat))
        retVal = T42CreateBaseFont(pUFObj, nil, nil, 0, pHostFontName);
    else
        retVal = CFFCreateBaseFont(pUFObj, nil, nil, pHostFontName);

    return retVal;
}


UFLErrCode
NewFont(
    UFOStruct       *pUFObj,
    unsigned long   dwSize,
    const long      cGlyphs
    )
{
    UFLErrCode retVal = kNoErr;

    if (pUFObj->pAFont == nil)
    {
        retVal = kErrOutOfMemory;

        pUFObj->pAFont = (AFontStruct*)(UFOHandle)UFLNewPtr(pUFObj->pMem, sizeof (AFontStruct));

        if (pUFObj->pAFont)
        {
            pUFObj->pAFont->hFont = (UFOHandle)UFLNewPtr(pUFObj->pMem, dwSize);

            if (pUFObj->pAFont->hFont)
            {
                /*
                 * Allocate the space for both pDownloadedGlyphs, pVMGlyphs and
                 * pCodeGlyphs at the same time.
                 */
                pUFObj->pAFont->pDownloadedGlyphs =
                    (unsigned char*)UFLNewPtr(pUFObj->pMem, GLYPH_SENT_BUFSIZE(cGlyphs) * 3);

                if (pUFObj->pAFont->pDownloadedGlyphs != nil)
                {
                    retVal = kNoErr;

                    /*
                     * Initialize this array - currently nothing is downloaded.
                     */
                    pUFObj->pAFont->pVMGlyphs =
                        (unsigned char*)pUFObj->pAFont->pDownloadedGlyphs + GLYPH_SENT_BUFSIZE(cGlyphs);

                    pUFObj->pAFont->pCodeGlyphs =
                        (unsigned char*)(unsigned char*)pUFObj->pAFont->pVMGlyphs + GLYPH_SENT_BUFSIZE(cGlyphs);
                }
                else
                {
                    UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->hFont);
                    UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont);
                    pUFObj->pAFont = nil;
                }
            }
            else
            {
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont);
                pUFObj->pAFont = nil;
            }
        }
    }

    if (pUFObj->pAFont != nil)
        AFONT_AddRef(pUFObj->pAFont);

    return retVal;
}


void
vDeleteFont(
    UFOStruct *pUFObj
    )
{
    if (pUFObj->pAFont != nil)
    {
        /*
         * Decrease RefCount.
         */
        AFONT_Release(pUFObj->pAFont);

        if (AFONT_RefCount(pUFObj->pAFont) == 0)
        {
            /*
             * Free format (Type1/3/42/cff) dependent shared data.
             */
            pUFObj->pfnCleanUp(pUFObj);

            /*
             * Free Common shared data.
             */
            if (pUFObj->pAFont->hFont)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->hFont);

            if (pUFObj->pAFont->Xuid.pXUID)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->Xuid.pXUID);

            if (pUFObj->pAFont->pDownloadedGlyphs)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->pDownloadedGlyphs);

            if (pUFObj->pAFont->pTTpost)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->pTTpost);

            /* GOODNAME */
            if (pUFObj->pAFont->pTTcmap && pUFObj->pAFont->hascmap)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->pTTcmap);

            if (pUFObj->pAFont->pTTmort && pUFObj->pAFont->hasmort)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->pTTmort);

            if (pUFObj->pAFont->pTTGSUB && pUFObj->pAFont->hasGSUB)
                UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont->pTTGSUB);
            /* GOODNAME */

            UFLDeletePtr(pUFObj->pMem, pUFObj->pAFont);
            pUFObj->pAFont = nil;
        }
    }
}


UFOStruct *
CopyFont(
    const UFOStruct *pUFObjFrom,
    const UFLRequest* pRequest
    )
{
    UFLErrCode  retVal              = kNoErr;
    short       sNameLen            = 0;
    short       sEncodeLen          = 0;
    const char  *pszNewFontName     = pRequest->pszFontName;
    const char  *pszNewEncodingName = pRequest->pszEncodeName;
    long        fontStructSize, maxGlyphs;
    UFOStruct   *pUFObjTo;

    /*
     * cannot/shouldnot copy a font if it is not created yet - prevent
     * "courier" in the way.
     */
    if (pUFObjFrom->flState < kFontHeaderDownloaded)
        return nil;

    if ((pszNewFontName == nil) || (pszNewFontName[0] == '\0'))
        return nil;

    /*
     * Determine downloaded font type.
     */
    switch (pUFObjFrom->ufoType)
    {
    case UFO_CFF:
        fontStructSize  = sizeof (CFFFontStruct);
        maxGlyphs       = ((CFFFontStruct *)pUFObjFrom->pAFont->hFont)->info.fData.maxGlyphs;
        break;

    case UFO_TYPE1:
        fontStructSize  = sizeof (TTT1FontStruct);
        maxGlyphs       = ((TTT1FontStruct *)pUFObjFrom->pAFont->hFont)->info.fData.maxGlyphs;
        break;

    case UFO_TYPE42:
        fontStructSize  = sizeof (T42FontStruct);
        maxGlyphs       = ((T42FontStruct *)pUFObjFrom->pAFont->hFont)->info.fData.maxGlyphs;
        break;

    case UFO_TYPE3:
        fontStructSize  = sizeof (TTT3FontStruct);
        maxGlyphs       = ((TTT3FontStruct *)pUFObjFrom->pAFont->hFont)->info.fData.maxGlyphs;
        break;

    default:
        return nil;
    }

    /*
     * Allocate memory for the UFOStruct, and...
     */
    pUFObjTo = (UFOStruct *)UFLNewPtr(pUFObjFrom->pMem, sizeof (UFOStruct));

    if (pUFObjTo == 0)
        return nil;

    /*
     * ...do a shallow copy on UFOStruct level.
     */
    memcpy(pUFObjTo, pUFObjFrom, sizeof (UFOStruct));

    /*
     * This NewFont does AddRef only.
     */
    if (NewFont(pUFObjTo, fontStructSize, maxGlyphs) != kNoErr)
    {
        /* This vDeleteFont does Release only. */
        vDeleteFont(pUFObjTo);

        UFLDeletePtr(pUFObjTo->pMem, pUFObjTo);

        return nil;
    }

    /*
     * Now allocate for non-shared data.
     */

    pUFObjTo->pszFontName      = nil;
    pUFObjTo->pszEncodeName    = nil;
    pUFObjTo->pUpdatedEncoding = nil;

    /*
     * Allocate a buffer to hold both FontName and EncodeName. They will be
     * freed in UFOCleanUpData().
     */
    sNameLen = UFLstrlen(pszNewFontName) + 1; /* Extra 1 for NULL. */

    if (pszNewEncodingName)
        sEncodeLen = UFLstrlen(pszNewEncodingName) + 1;

    pUFObjTo->pszFontName = (char *)UFLNewPtr(pUFObjTo->pMem, sNameLen + sEncodeLen);

    if (pUFObjTo->pszFontName != nil)
    {
        StringCchCopyA(pUFObjTo->pszFontName, sNameLen / sizeof(char), pszNewFontName);

        if (pszNewEncodingName)
        {
            pUFObjTo->pszEncodeName = pUFObjTo->pszFontName + sNameLen;
            StringCchCopyA(pUFObjTo->pszEncodeName, sEncodeLen / sizeof(char), pszNewEncodingName);
        }
    }

    /* pszFontName should be ready/allocated - if not, cannot continue. */

    if ((pUFObjTo->pszFontName == nil) || (pUFObjTo->pszFontName[0] == '\0'))
    {
        /* This vDeleteFont does Release only. */
        vDeleteFont(pUFObjTo);

        UFLDeletePtr(pUFObjTo->pMem, pUFObjTo->pszFontName);
        UFLDeletePtr(pUFObjTo->pMem, pUFObjTo);

        return nil;
    }

    /*
     * BUT we need different EncodingVector for this newNamed copy if we need
     * to update it.
     */
    if ((pUFObjTo->pszEncodeName == nil) || (pUFObjTo->pszEncodeName[0] == '\0'))
    {
        pUFObjTo->pUpdatedEncoding = (unsigned char *)UFLNewPtr(pUFObjTo->pMem, GLYPH_SENT_BUFSIZE(256));
    }
    else
    {
        /* The encoding is supplied and so are the glyph/char names later. */
        pUFObjTo->pUpdatedEncoding = nil;
    }

    /*
     * Client's private data should be non-shared.
     */
    pUFObjTo->hClientData = pRequest->hData;

    /*
     * Setup Type 42 and CFF CID specific non-shared data.
     */
    if (IS_TYPE42CID_KEYEDFONT(pRequest->lDownloadFormat)
        || IS_CFFCID(pRequest->lDownloadFormat))
    {
        pUFObjTo->lDownloadFormat = pRequest->lDownloadFormat;

        if (IS_CFFCID(pRequest->lDownloadFormat))
        {
            /*
             * Need one more deeper level copy.
             */
            CFFFontStruct *pFont = (CFFFontStruct *)UFLNewPtr(pUFObjTo->pMem, sizeof (CFFFontStruct));

            if (pFont)
            {
                /*
                 * Copy from the From CFFFontStruct object. This is a shared
                 * object.
                 */
                *pFont = *((CFFFontStruct *)pUFObjFrom->pAFont->hFont);

                /*
                 * Initialization of UFLCFFFontInfo.ppFontData field is
                 * necessary. Note that on this request only,
                 UFLRequest.hFontInfo has the value for the field.
                 */
                pFont->info.ppFontData = (void PTR_PREFIX **)pRequest->hFontInfo;

                /*
                 * Set this object to its UFO object.
                 */
                pUFObjTo->pAFont->hFont = (UFOHandle)pFont;
            }
            else
            {
                /* This vDeleteFont does Release only. */
                vDeleteFont(pUFObjTo);

                if (pFont)
                    UFLDeletePtr(pUFObjTo->pMem, pFont);

                if (pUFObjTo->pszEncodeName)
                    UFLDeletePtr(pUFObjTo->pMem, pUFObjTo->pszEncodeName);

                UFLDeletePtr(pUFObjTo->pMem, pUFObjTo->pszFontName);
                UFLDeletePtr(pUFObjTo->pMem, pUFObjTo);

                return nil;
            }
        }

        /*
         * Put this UFO object into a special font initialization state
         * kFontInit2.
         */
        pUFObjTo->flState = kFontInit2;
    }

    /*
     * Reencode the font, or re-composefont a CID-keyed font in different
     * writing direction.
     */
    if (IS_TYPE42CID_KEYEDFONT(pRequest->lDownloadFormat)
        || IS_CFFCID(pRequest->lDownloadFormat))
        retVal = RecomposefontCIDFont(pUFObjFrom, pUFObjTo);
    else
        retVal = ReEncodePSFont(pUFObjFrom, pUFObjTo->pszFontName, pUFObjTo->pszEncodeName);

    if (kNoErr != retVal)
    {
        /* This vDeleteFont does Release only. */
        vDeleteFont(pUFObjTo);

        if (IS_CFFCID(pRequest->lDownloadFormat))
            UFLDeletePtr(pUFObjTo->pMem, pUFObjTo->pAFont->hFont);

        if (pUFObjTo->pUpdatedEncoding)
            UFLDeletePtr(pUFObjTo->pMem, pUFObjTo->pUpdatedEncoding);

        UFLDeletePtr(pUFObjTo->pMem, pUFObjTo->pszFontName);
        UFLDeletePtr(pUFObjTo->pMem, pUFObjTo);

        pUFObjTo = nil;
    }

    return pUFObjTo;
}


void
VSetNumGlyphs(
    UFOStruct *pUFO,
    unsigned long cNumGlyphs
    )
{
    TTT1FontStruct *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;

    pFont->info.fData.cNumGlyphs = cNumGlyphs;

    return;
}


/* Fix bug 274008 */
UFLBool
ValidGlyphName(
    const UFLGlyphsInfo *pGlyphs,
    short               i,           /* ANSI index  */
    unsigned short      wIndex,      /* Glyph Index */
    char                *pGoodName
    )
{
    UFLGlyphID *glyphs = pGlyphs->pGlyphIndices;

    if (i < pGlyphs->sCount)
    {
        if (UFLstrcmp(pGoodName, Notdef) == 0)
        {
            if (wIndex != (unsigned short)(glyphs[0] & 0x0000FFFF))
                return 0;
        }
        else if (UFLstrcmp(pGoodName, UFLSpace) == 0)
        {
            if (wIndex != (unsigned short)(glyphs[0x20] & 0x0000FFFF))
                return 0;
        }
        else if (UFLstrcmp(pGoodName, Hyphen) == 0)
        {
            if (wIndex != (unsigned short)(glyphs[0x2d] & 0x0000FFFF))
                return 0;
        }
        else if (UFLstrcmp(pGoodName, Bullet) == 0)
        {
            if (wIndex != (unsigned short)(glyphs[0x95] & 0x0000FFFF))
                return 0;
        }
    }
    return true;
}


UFLBool
HostFontValidateUFO(
    UFOStruct   *pUFObj,
    char        **ppHostFontName
    )
{
    /*
     * Check %hostfont% status.
     * %hostfont% printing is allowed when its PostScript font name
     * (PlatformID x/NameID 6) string in 'name' table is available.
     */
    UFLBool         bResult = 0;
    unsigned long   ulSize;

    if (ppHostFontName == nil)
    {
        HOSTFONT_INVALIDATE_UFO(pUFObj);
        return 0;
    }

    if (HOSTFONT_IS_VALID_UFO_HFDH(pUFObj))
    {
        if (pUFObj->ufoType == UFO_TYPE42)
            bResult = HOSTFONT_GETNAME(pUFObj, ppHostFontName, &ulSize, pUFObj->pFData->fontIndex);
        else
            bResult = HOSTFONT_GETNAME(pUFObj, ppHostFontName, &ulSize, 0);

        if (bResult)
            bResult = HOSTFONT_ISALLOWED(pUFObj, *ppHostFontName);

        if (bResult)
        {
            HOSTFONT_SAVE_CURRENTNAME(pUFObj, *ppHostFontName);
            HOSTFONT_VALIDATE_UFO(pUFObj);
        }
        else
        {
            HOSTFONT_SAVE_CURRENTNAME(pUFObj, *ppHostFontName);
            HOSTFONT_INVALIDATE_UFO(pUFObj);
        }
    }
    else
        HOSTFONT_INVALIDATE_UFO(pUFObj);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\ufl.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFL.c
 *
 * $Header: $
 */


#include "UFL.h"
#include "UFLMem.h"
#include "UFLStd.h"
#include "UFLPriv.h"
#include "UFLErr.h"
#include "UFO.h"


/*
 * Global constant strings
 * These strings are shared among all T1/T3/T42 downloading.
 */
const char *gnotdefArray    = " 256 array 0 1 255 {1 index exch /.notdef put} for ";
const char *Notdef          = ".notdef";
const char *Hyphen          = "hyphen";
const char *Minus           = "minus";
const char *SftHyphen       = "sfthyphen";
const char *UFLSpace        = "space";
const char *Bullet          = "bullet";
const char *nilStr          = "\0\0";


/*
 * UFL function implementations
 */

UFLHANDLE
UFLInit(
    const UFLBool           bDLGlyphTracking,
    const UFLMemObj         *pMemObj,
    const UFLFontProcs      *pFontProcs,
    const UFLOutputDevice   *pOutDev
    )
{
    UFLStruct *pUFL;

    if ((pMemObj == 0) || (pFontProcs == 0) || (pOutDev == 0))
        return 0;

    pUFL = (UFLStruct *)UFLNewPtr(pMemObj, sizeof (*pUFL));

    if (pUFL)
    {
        pUFL->bDLGlyphTracking = bDLGlyphTracking;
        pUFL->mem              = *pMemObj;
        pUFL->fontProcs        = *pFontProcs;
        pUFL->outDev           = *pOutDev;
        pUFL->hOut             = StrmInit(&pUFL->mem,
                                            pUFL->outDev.pstream,
                                            (const UFLBool)pOutDev->bAscii);

        if (!pUFL->hOut)
        {
            UFLDeletePtr(pMemObj, pUFL);
            pUFL = 0;
        }
    }

    return (UFLHANDLE)pUFL;
}



void
UFLCleanUp(
    UFLHANDLE h
    )
{
    UFLStruct *pUFL = (UFLStruct *)h;

    StrmCleanUp(pUFL->hOut);
    UFLDeletePtr(&pUFL->mem, h);
}



UFLBool
bUFLTestRestricted(
    const UFLHANDLE  h,
    const UFLRequest *pRequest
    )
{
    UFLStruct *pUFL = (UFLStruct *)h;

    if (pUFL == 0)
        return 0;

    return bUFOTestRestricted(&pUFL->mem, pUFL, pRequest);
}



UFO
UFLNewFont(
    const UFLHANDLE  h,
    const UFLRequest *pRequest
    )
{
    UFLStruct *pUFL = (UFLStruct *)h;

    if (pUFL == 0)
        return 0;

    return UFOInit(&pUFL->mem, pUFL, pRequest);
}



/*===========================================================================
                                UFLDownloadIncr

    Downloads a font incrementally. The first time this is called for a
    particular font, it will create a base font, and download a set of
    requested characters. Subsequent calls on the same font will download
    additional characters.
==============================================================================*/

UFLErrCode
UFLDownloadIncr(
    const UFO           h,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    )
{
    if (h == 0)
        return kErrInvalidHandle;

    return UFODownloadIncr((UFOStruct *)h, pGlyphs, pVMUsage, pFCUsage);
}



/*===========================================================================
                            UFLVMNeeded

    Get a guestimate of VM needed for a download request.
==============================================================================*/

UFLErrCode
UFLVMNeeded(
    const UFO            h,
    const UFLGlyphsInfo  *pGlyphs,
    unsigned long        *pVMNeeded,
    unsigned long        *pFCNeeded
    )
{
    if (h == 0)
        return kErrInvalidHandle;

    return UFOVMNeeded((UFOStruct *)h, pGlyphs, pVMNeeded, pFCNeeded);
}



void
UFLDeleteFont(
    UFO h
    )
{
    if (h == 0)
        return;

    UFOCleanUp((UFOStruct *)h);
}



UFLErrCode
UFLUndefineFont(
    const UFO h
    )
{
    if (h == 0)
        return kErrInvalidHandle;

    return UFOUndefineFont((UFOStruct *)h);
}



UFO
UFLCopyFont(
    const UFO           h,
    const UFLRequest*   pRequest
    )
{
    if (h == 0)
        return NULL;

    return UFOCopyFont((UFOStruct *)h, pRequest);
}



/*===========================================================================
                            UFLGIDsToCIDs

    This function can only be used with a CID CFF font. It is used to
    obtain CIDs from a list of GIDs.
==============================================================================*/

UFLErrCode
UFLGIDsToCIDs(
    const UFO           aCFFFont,
    const short         cGlyphs,
    const UFLGlyphID    *pGIDs,
    unsigned short      *pCIDs
    )
{
    if (aCFFFont == 0)
        return kErrInvalidHandle;

    return UFOGIDsToCIDs((UFOStruct *) aCFFFont, cGlyphs, pGIDs, pCIDs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\uflstrm.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLStrm.c
 *
 *        UTL Output Stream Implementation
 *
 *
 * $Header:
 */

/* -------------------------------------------------------------------------
     Header Includes
  --------------------------------------------------------------------------- */
#include "UFLCnfig.h"
#include "UFLPriv.h"
#include "UFLMem.h"
#include "UFLErr.h"
#include "UFLStrm.h"
#include "UFLStd.h"

/* ---------------------------------------------------------------------------
     Constants
 --------------------------------------------------------------------------- */
#define kEOLSpacing  60

/* ---------------------------------------------------------------------------
     Global Variables
 --------------------------------------------------------------------------- */
static char fHexBytes[16] = { '0', '1', '2', '3',
                            '4', '5', '6', '7',
                            '8', '9', 'a', 'b',
                            'c', 'd', 'e', 'f' };


/* ---------------------------------------------------------------------------
     Implementation
 --------------------------------------------------------------------------- */

 /* ---------------------------------------------------------------------------
    Function UFLOutStream

    Constructor of the object.

--------------------------------------------------------------------------- */


UFLHANDLE
StrmInit(
    const UFLMemObj *pMem,
    const UFLStream *stream,
    const UFLBool   outputAscii
    )
{
    UFLOutStream    *pOut;

    pOut = (UFLOutStream *)UFLNewPtr( pMem, sizeof(UFLOutStream) );
    if ( pOut )
    {
        pOut->pMem = pMem;
        pOut->pStream = stream;
        pOut->flOutputAscii = outputAscii;
        pOut->lAddEOL = 0;
    }

    return (UFLHANDLE)pOut;
}

void
StrmCleanUp(
    UFLHANDLE h
    )
{
    UFLDeletePtr( ((UFLOutStream *)h)->pMem, h );
}

UFLErrCode
StrmPutBytes (
    const UFLHANDLE h,
    const char      *data,
    const UFLsize_t    len,
    const UFLBool   bAscii
    )
{
    UFLsize_t cb =  len;
    long     selector;
    UFLOutStream *pOut = (UFLOutStream *)h;

    /* If we can output binary data then simply send out the data */
    if ( StrmCanOutputBinary(h) )
        selector = kUFLStreamPut;
    else                        /* otherwise, if the data is binary, request the stream to convert the data to the transport protocol */
        selector = ( bAscii ) ? kUFLStreamPut : kUFLStreamPutBinary;

    pOut->pStream->put( (UFLStream*)pOut->pStream, selector, (void*)data, &cb );
    if ( cb != (unsigned int)len )
        return kErrOutput;
    else return kNoErr;
}

UFLErrCode
StrmPutAsciiHex(
    const UFLHANDLE h,
    const char      *data,
    const unsigned long len
    )
{
    unsigned long   byteCount = 0;
    unsigned char   *c = (unsigned char*)data, tmp, put[2];
    UFLErrCode      retVal = kNoErr;
    UFLOutStream    *pOut = (UFLOutStream *)h;
    char          nullStr[] = "\0\0";  // An empty/Null string.

    while ( byteCount < len )
    {
        tmp = *c++;
        put[0] = fHexBytes[(tmp >> 4) & 0x0f];
        put[1] = fHexBytes[tmp & 0x0f];

        if ( (retVal = StrmPutBytes( h, (const char*)put, 2, 1 ) ) != kNoErr )
        {
            break;
        }

        pOut->lAddEOL += 2;
        if ( pOut->lAddEOL == kEOLSpacing )
        {
            if ( (retVal = StrmPutStringEOL( h, nullStr )) != kNoErr )
            {
                break;
            }
        }
        ++byteCount;
    }
    return retVal;
}


UFLErrCode
StrmPutWordAsciiHex(
    const UFLHANDLE h,
    const unsigned short wData
    )
{
    unsigned char   tmp, put[5];
    UFLErrCode      retVal;
    UFLOutStream    *pOut = (UFLOutStream *)h;

    StrmPutString(h, "<");

    tmp = (unsigned char) GET_HIBYTE(wData);
    put[0] = fHexBytes[(tmp >> 4) & 0x0f];
    put[1] = fHexBytes[tmp & 0x0f];

    tmp = (unsigned char) GET_LOBYTE(wData);
    put[2] = fHexBytes[(tmp >> 4) & 0x0f];
    put[3] = fHexBytes[tmp & 0x0f];

    retVal = StrmPutBytes( h, (const char*)put, 4, 1 ); //last 1 == use ASCII format

    StrmPutString(h, ">");

    return retVal;
}


UFLErrCode
StrmPutString(
    const UFLHANDLE h,
    const char      *s
    )
{
    if ( s )
    {
        if ( *s )
            return StrmPutBytes( h, s, UFLstrlen(s), 1 );
        else
            return kNoErr;
    }
    else return kErrInvalidParam;
}

UFLErrCode
StrmPutStringEOL(
    const UFLHANDLE h,
    const char      *s
    )
{
    UFLErrCode retVal = kNoErr;
#ifdef WIN_ENV
    static char c[2] = { kWinLineEnd, kLineEnd };
#else
    static char c[1] = { kLineEnd };
#endif

    if ( s == nil )
        return kErrInvalidParam;

    if ( *s )
        retVal = StrmPutString( h, s );

    if ( retVal == kNoErr ) {
        ((UFLOutStream *)h)->lAddEOL = 0;                /* Initialize number of bytes in a line to 0 */
#ifdef WIN_ENV
        retVal = StrmPutBytes( h, c, 2, 1 );             /* lfcr that the user sees        */
#else
        retVal = StrmPutBytes( h, c, 1, 1 );
#endif
    }

    return retVal;
}

UFLErrCode
StrmPutStringBinary(
    const UFLHANDLE h,
    const char      *data,
    const unsigned long len
    )
{
    char          buf[128], c;
    char          *pSrc, *pDest;
    short         maxBuf, bufSize;
    unsigned long count;
    UFLErrCode    retVal = kNoErr;

    if ( data == nil || len == 0 )
        return kNoErr;

    pSrc = (char*) data;
    maxBuf = sizeof( buf );
    count = (unsigned long) len;
    while ( count && retVal == kNoErr )
    {
        /* copy data to temp buffer */
        for ( pDest = (char*)buf, bufSize = 0; count && bufSize < maxBuf -1; )
        {
            c = *pSrc++;
            if ( ( c == '('  ) ||  ( c == ')'  ) ||    ( c == '\\' )  ) { /*  escape of those characters */
                *pDest++ = '\\' ;                                         /*    by preceding '\' */
                bufSize++;
            }
            *pDest++ = c;              /* Add the byte itself */
            bufSize++;
            count--;
        }

        /* Send the escape data */
        if ( bufSize )
            retVal = StrmPutBytes( h, buf, bufSize, 0 );
    }
    return retVal;
}

UFLErrCode
StrmPutInt(
    const UFLHANDLE h,
    const long int  i
    )
{
    char is[11]; /* One bigger than format */

    UFLsprintf((char *)is, CCHOF(is), "%ld", i);
    return StrmPutString( h, is );
}

static long convFract[] =
    {
    65536L,
    6553L,
    655L,
    66L,
    6L
    };

/* Convert a Fixed to a c string */
static void Fixed2CString(
    UFLFixed f,
    char     *s,
    short    precision,
    char     skipTrailSpace
    )
{
    char u[12];
    char *t;
    short v;
    char sign;
    long fracPrec = (precision <= 4) ? convFract[precision] : 0L;

    if ((sign = f < 0) != 0)
        f = -f;

    /* If f started out as fixedMax or -fixedMax, the precision adjustment puts it
            out of bounds.  Reset it correctly. */
    if (f >= 0x7FFF7FFF)
        f =(UFLFixed)0x7fffffff;
    else
        f += (fracPrec + 1) >> 1;

    v = (short)(f >> 16);
    f &= 0x0000ffff;
    if (sign && (v || f >= fracPrec))
        *s++ = '-';

    t = u;
    do
    {
        *t++ = v % 10 + '0';
        v /= 10;
    } while (v);

    for (; t > u;)
        *s++ = *--t;

    if (f >= fracPrec)
    {
        *s++ = '.';
        for (v = precision; v-- && f;)
        {
            f = (f << 3) + (f << 1);
            *s++ = (char)((f >> 16) + '0');
            f &= 0x0000ffff;
        }
        for (; *--s == '0';)
            ;
        if (*s != '.')
            s++;
    }
    if ( !skipTrailSpace )
        *s++ = ' ';
    *s = '\0';
}


UFLErrCode
StrmPutFixed(
    const UFLHANDLE h,
    const UFLFixed  fixed
    )
{
    char    str[32];

    Fixed2CString( fixed, str, 4, 0 );
    return StrmPutString( h, str );
}


UFLErrCode
StrmPutMatrix(
    const UFLHANDLE      h,
    const UFLFixedMatrix *matrix,
    const UFLBool        skipEF
    )
{
    UFLErrCode    retVal;

    retVal = StrmPutString( h, "[" );
    if ( retVal == kNoErr )
        retVal = StrmPutFixed( h, matrix->a );
    if ( retVal == kNoErr )
        retVal = StrmPutFixed( h, matrix->b );
    if ( retVal == kNoErr )
        retVal = StrmPutFixed( h, matrix->c );
    if ( retVal == kNoErr )
        retVal = StrmPutFixed( h, matrix->d );

    if ( 0 == skipEF )
    {
        if ( retVal == kNoErr )
            retVal = StrmPutFixed( h, matrix->e );
        if ( retVal == kNoErr )
            retVal = StrmPutFixed( h, matrix->f );
    }

    if ( retVal == kNoErr )
        retVal = StrmPutString( h, "] " );

    return retVal;
}

UFLErrCode
StrmPutAscii85(
    const UFLHANDLE h,
    const char      *data,
    const unsigned long len
    )
{
    char    *cptr;
    short   bCount;
    unsigned long val;
    UFLErrCode    retVal = kNoErr;
    UFLOutStream  *pOut = (UFLOutStream *)h;
    unsigned long i;

    /* encode the initial 4-tuples */
    cptr   = (char *)data;
    val   = 0UL;
    bCount = 0;
    pOut->lAddEOL = 0;
    for ( i = 0; retVal == kNoErr && i < len; i++ )
    {
        val <<=  8;
        val |= (unsigned char)*cptr++;
        if ( bCount == 3 )
        {
            retVal = Output85( h, val, 5 );
            val = 0UL;
            bCount = 0;
        }
        else
        {
            bCount ++;
        }
    }

    /* now do the last partial 4-tuple -- if there is one */
    /* see the Red Book spec for the rules on how this is done */
    if ( retVal == kNoErr && bCount > 0 )
    {
        short dex;
        short rem = 4 - bCount;  /* count the remaining bytes */

        for ( dex = 0; dex < rem; dex ++ )  /* shift left for each of them */
            val <<= 8;      /* (equivalent to adding in ZERO's)*/
        retVal = Output85( h, val, (short)(bCount + 1) );  /* output only meaningful bytes + 1 */
    }

    return retVal;
}

UFLErrCode
Output85(
    const UFLHANDLE h,
    unsigned long   inWord,
    short           nBytes
    )
{
    UFLErrCode    retVal = kNoErr;
    unsigned char outChar;
    UFLOutStream *pOut = (UFLOutStream *)h;
    char          nullStr[] = "\0\0";  // An empty/Null string.

    if ( (inWord == 0UL) && (nBytes == 5) )
    {
        outChar = 'z';
        StrmPutBytes( h, (const char*)&outChar, 1, 1 );
        pOut->lAddEOL++;
    }
    else
    {
        unsigned long power;
        short count;

        power = 52200625UL;       // 85 ^     4
        for ( count = 0; retVal == kNoErr && count < nBytes; count ++)
        {
            outChar = (unsigned char)( (unsigned long)(inWord / power) + (unsigned long)'!' );
            retVal = StrmPutBytes( h, (const char*)&outChar, 1, 1 );
            pOut->lAddEOL++;
            if ( count < 4 )
            {
                inWord %= power;
                power /=  85;
            }
        }
    }
    if ( pOut->lAddEOL >= kEOLSpacing )
    {
        retVal = StrmPutStringEOL( h, nullStr );
    }

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\ufottt1.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFOttt1.c
 *
 *
 * $Header:
 */

/* -------------------------------------------------------------------------
     Header Includes
  --------------------------------------------------------------------------- */
#include "UFOTTT1.h"
#include "UFLMem.h"
#include "UFLErr.h"
#include "UFLPriv.h"
#include "UFLStd.h"
#include "UFLMath.h"
#include "ParseTT.h"
#include "UFLVm.h"

#if UNIX
#include <sys/varargs.h>
#else
#include <stdarg.h>
#endif

/* ---------------------------------------------------------------------------
     Constant
 --------------------------------------------------------------------------- */

#define kEExecKey  55665
#define kCSKey     4330

/**************************************************************************************
TYPE 1 commands for use with CharString().  The high word contains the
number of operands on the stack, and the loword contains the encoding
of the command.  For two byte commands the LSB of the low word contains
12 decimal and the MSB of the low word contains the second byte of the
code.  See Chapter 6 of the Black Book for further details.
***************************************************************************************/
#define kT1cscStartChar         0xFFFFFFFF      /* dummy command to signal start of character definition. */

/*
    y dy hstem(1).  Declares the vertical range of a horizontal stem zone b/w the y coordinates y and y+dy,
    where y is relative to the y coordinate of the left sidebearing point.
*/
#define kT1cscHStem             0x00020001

/*
    x dx vstem(3). Declares the horizontal range of a vertical stem zone b/w the x coordinates x and x+dx,
    where x is relative to the x coordinate of the left sidebearing point.
*/
#define kT1cscVStem             0x00020003

/*
    dy vmoveto(4). For vertical moveto.  This is equivalent to 0 dy rmoveto.
*/
#define kT1cscVMoveTo           0x00010004

/*
    dx dy rlineto(5). Behaves like rlineto in the PostScript language.
*/
#define kT1cscRLineTo           0x00020005

/*
    dx hlineto(6). For horizontal lineto.  Equivalent to dx 0 rlineto.
*/
#define kT1cscHLineTo           0x00010006

/*
    dy vlineto(7). For vertical lineto.  Equivalent to 0 dy rlineto.
*/
#define kT1cscVLineTo           0x00010007

/*
    dx1 dy1 dx2 dy2 dx3 dy3 rrcurveto(8). For relative rcuveto.
    The arguments to the command are relative to each other.
    Equivalent to dx1 dy1 (dx1+ dx2) (dy1 + dy2) (dx1+ dx2 + dx3) (dy1 + dy2 + dy3) rcurveto.
*/
#define kT1cscRRCurveTo         0x00060008

/*
    closepath(9).  Close a subpath.
*/
#define kT1cscClosePath         0x00000009

/*
    sbx sby wx wy sbw (12 7).  Sets the left sidebearing point to (sbx, sby) and sets
    the character width vetor to (wx, wy) in character space.
*/
#define kT1cscSBW               0x0004070C

/*
    sbx wx hsbw (13).  Sets the left sidebearing point at (sbx, 0) and sets the
    character width vector to (wx, 0) in character space.
*/
#define kT1cscHSBW              0x0002000D

/*
    endchar(14). Finishes a charstring outline definition and
    must be the last command in a character's outline.
*/
#define kT1cscEndChar           0x0000000E

/*
    dx dy rmoveto(15). Behaves like rmoveto in PostScript.
*/
#define kT1cscRMoveTo           0x00020015

/*
    dx hmoveto(22).    For horizontal moveto.  Equivalent to dx 0 rmoveto.
*/
#define kT1cscHMoveTo           0x00010016

/*
    dy1 dx2 dy2 dx3 vhcurveto(30). For vertical-horizontal curveto.
    Equivalent to 0 dy1 dx2 dy2 dx3 0 rrcureveto.
*/
#define kT1cscVHCurveTo         0x0004001E

/*
    dx1 dx2 dy2 dy3 hvcurveto(31). For horizontal-vertical curveto.
    Equivalent to dx1 0 dx2 dy2 0 dy3 rrcurveto.
*/
#define kT1cscHVCurveTo         0x0004001F

/***********************************************************************
 CS Data buffer size
************************************************************************/
#define kCSBufInitSize  1024    /* Initial size of TTT1CSBuf */
#define kCSGrow         512     /* Amount to grow CharString buffer */

/* ---------------------------------------------------------------------------
     Global variables
 --------------------------------------------------------------------------- */

/* The 4 random number that is output at the beginning of a charstring.  See blackbook. */
static unsigned char randomBytes[] = { 71, 36, 181, 202 };


/* ---------------------------------------------------------------------------
     Macros
 --------------------------------------------------------------------------- */

/* ---------------------------------------------------------------------------
     Implementation
 --------------------------------------------------------------------------- */
UFLErrCode CharString( TTT1FontStruct *pFont, unsigned long cmd, ...);

/************************************** CSBuf Implementation **********************************************/
static CSBufStruct *
CSBufInit(
    const UFLMemObj *pMem
    )
{
    CSBufStruct *p;

    p = (CSBufStruct *)UFLNewPtr( pMem, sizeof( *p ) );
    if ( p )
    {
    p->pBuf = (char*) UFLNewPtr( pMem, kCSBufInitSize );
    if ( p->pBuf )
    {
        p->ulSize = kCSBufInitSize;
        p->pEnd = p->pBuf + kCSBufInitSize;
        p->pPos = p->pBuf;
        p->pMemObj = (UFLMemObj *)pMem;
    }
    else
    {
        UFLDeletePtr( pMem, p );
        p = 0;
    }
    }

    return p;
}

static void
CSBufCleanUp(
    CSBufStruct *h
    )
{
    if ( h )
    {
    if ( h->pBuf )
    {
        UFLDeletePtr( h->pMemObj, h->pBuf );
        h->pBuf = 0;
    }
    UFLDeletePtr( h->pMemObj, h );
    }
}

/***************************************************************************
 *
 *                          CSBufGrowBuffer
 *
 *    Function:  Grows the currently allocated CharString buffer by
 *                      kCSGrow bytes.
 *
 ***************************************************************************/

static UFLBool
CSBufGrowBuffer(
    CSBufStruct *h
    )
{
    UFLBool    retVal;

    unsigned long len = (unsigned long)CSBufCurrentLen( h );

    retVal = UFLEnlargePtr( h->pMemObj, (void**)&h->pBuf, (unsigned long)(CSBufCurrentSize( h ) + kCSGrow), 1 );
    if ( retVal )
    {
    h->ulSize += kCSGrow;
    h->pEnd = h->pBuf + h->ulSize;
    h->pPos = h->pBuf + len;
    }
    return retVal;
}

/****************************************************************
*
*                           CSBufCheckSize
*
*     Function:   Check to see if the current size of the
*        buffer can fit the len bytes data, if not, grow the
*        buffer
*
**************************************************************/
static UFLBool
CSBufCheckSize(
    CSBufStruct         *h,
    const unsigned long len
    )
{
    UFLBool retVal = 1;

    while ( retVal && ((unsigned long)CSBufFreeLen( h ) < len) )
    {
    retVal = CSBufGrowBuffer( h );
    }

    return retVal;
}

/****************************************************************
*
*                           CSBufAddNumber
*
*     Function:   Converts a long int into the Type 1 representation of
*                 numbers (described in Chapter 6 of the Black Book.)
*                 The basic idea is they have a few special ranges
*                 where they can represent the long in < 4 bytes and
*                 store a long + prefix for everything else.
*
*                 The if statements show the range of numbers and the
*                 body of the if statements compute the representation
*                 for that range.  The formulas were derived by reversing
*                 the formulas given in the book (which tells how to convert
*                 an encoded number back to a long.)  As an example take the
*                 108 <= dw <= 1131 range.  The derivation is as follows:
*
*                 dw = ((v - 247) * 256) + w + 108.  Find v,w given dw.
*                 dw - 108 = ((v - 247) * 256) + w
*                 v - 247 = (dw - 108) / 256
*                 *** v = 247 + (dw - 108) / 256 ***
*                 *** w = (dw - 108) % 256       ***
*
*                 The rest of the derivations are no harder than this one.
*
*
**************************************************************/

static UFLErrCode
CSBufAddNumber(
    CSBufStruct *h,
    long        dw
    )
{
    dw  = UFLTruncFixedToShort( dw );  /* Truncate fraction */


    /* Make sure buffer has room  */
    if (CSBufCheckSize(h, 5) == 0 )
    {
    return kErrOutOfMemory;
    }

    /* Encode number based on its value  */
    if (-107 <= dw && dw <= 107)
    CSBufAddChar( h, (char)(dw + 139) );
    else if (108 <= dw && dw <= 1131)
    {
    dw -= 108;
    CSBufAddChar( h, (char)((dw >> 8) + 247) );
    CSBufAddChar( h, (char)(dw) );                       /* Just the low byte */
    } /* end else */
    else if (-1131 <= dw && dw <= -108)
    {
    dw += 108;
    CSBufAddChar( h, (char)((-dw >> 8) + 251) );
    CSBufAddChar( h, (char)(-dw) );                       /* Just the low byte */
    } /* end else if */
    else
    {
    CSBufAddChar( h, (char)255 );
    CSBufAddChar( h, (char)(dw >> 24) );
    CSBufAddChar( h, (char)(dw >> 16) );
    CSBufAddChar( h, (char)(dw >> 8) );
    CSBufAddChar( h, (char)(dw) );
    } /* end else */

    return kNoErr;
}

static void
Encrypt(
    const unsigned char *inBuf,
    const unsigned char *outBuf,
    long                inLen,
    long                *outLen,
    unsigned short      *key
    )
{
    register unsigned char cipher;
    register unsigned char *plainSource = (unsigned char *)inBuf;
    register unsigned char *cipherDest = (unsigned char *)outBuf;
    register unsigned short R = *key;

    *outLen = inLen;
    while ( --inLen >= 0 )
    {
    cipher = (*plainSource++ ^ (unsigned char)(R >> 8));
    R = (unsigned short)(((unsigned short)cipher + R) * 52845 + 22719);
    *cipherDest++ = cipher;
    } /* end while */
    *key = R;
} /* end Encrypt() */

static UFLErrCode
EExec(
    UFLHANDLE      stream,
    unsigned char  *inBuf,
    UFLsize_t         inLen,
    unsigned short *pEExecKey
    )
{
    unsigned char buff[128];         /* Temporary buffer for output data */
    UFLsize_t bytesLeft, bytesEncrypt, maxEncrypt;
    long bytesOut;
    unsigned char* pb;
    UFLErrCode    retVal = kNoErr;

    pb = inBuf;
    bytesLeft = inLen;

    maxEncrypt = sizeof(buff);
    while ( bytesLeft > 0 )
    {
    bytesEncrypt = min( bytesLeft, maxEncrypt ) ;
    Encrypt( pb, buff, bytesEncrypt, &bytesOut, pEExecKey );
    pb += bytesEncrypt;
    bytesLeft -= bytesEncrypt;
    retVal = StrmPutAsciiHex( stream, (const char*)buff, bytesOut );

    if ( retVal != kNoErr )
        break;
    }

    return retVal;
}

/*
*                            BeginEExec
*
*    Function: Signals that we wish to start generating the eexec
*              portion of the Type 1 font.  The first four bytes of
*              a Type 1 font must be randomly generated and satisfy
*              two constraints which basically ensure that they do
*              not generate whitespace or hexadecimal characters.
*              For more details read Chapter 7 of the Black Book.
*/
static UFLErrCode
BeginEExec(
    UFOStruct *pUFO
    )
{
    UFLErrCode      retVal;
    UFLHANDLE       stream = pUFO->pUFL->hOut;
    char            nilStr[] = "\0\0";  // An empty/nil string.
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;

    retVal = StrmPutStringEOL( stream, nilStr );

    if ( kNoErr == retVal )
    {
    if ( pFont->info.bEExec )
    {
        StrmPutStringEOL( stream, "currentfile eexec" );

        if ( kNoErr == retVal )
        pFont->eexecKey = (unsigned short)kEExecKey;

        if ( kNoErr == retVal )
        retVal = EExec( stream, randomBytes, 4, &pFont->eexecKey );
    }
    else
    {
        StrmPutStringEOL( stream, "systemdict begin" );
    }
    }

    return retVal;
}


/***************************************************************************
*
*                          EndEExec
*
*    Function: Signals the client is done generating the eexec portion
*              of a Type 1 font.  The function tells eexec function in printer
*              that eexec data are over by sending 512 zeroes at the end.
*
*
***************************************************************************/

static UFLErrCode
EndEExec(
    UFOStruct     *pUFO
    )
{
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;
    static char *closeStr = "mark currentfile closefile ";
    UFLErrCode retVal = kNoErr;
    UFLHANDLE    stream = pUFO->pUFL->hOut;
    short i;

    if ( !pFont->info.bEExec )
    {
    retVal = StrmPutStringEOL( stream, "end" );
    }
    else
    {
    retVal = EExec( stream, (unsigned char*)closeStr, UFLstrlen( closeStr ), &pFont->eexecKey );

    for ( i = 0; i < 8 && retVal == kNoErr; i++ )
        retVal = StrmPutStringEOL( stream, "0000000000000000000000000000000000000000000000000000000000000000" );

    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, "cleartomark" );
    }
    return retVal;
}

static UFLErrCode
PutLine(
    UFOStruct      *pUFO,
    char           *line
    )
{
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;
    UFLErrCode retVal;
#ifdef WIN_ENV
    static char c[2] = { kWinLineEnd, kLineEnd };
#else
    static char c[1] = { kLineEnd };
#endif

    if ( 0 == pFont->info.bEExec )
    retVal = StrmPutStringEOL( pUFO->pUFL->hOut, line );
    else
    {
    /* MWCWP1 doesn't like the implicit cast from char* to unsigned char*  --jfu */
    retVal = EExec( pUFO->pUFL->hOut, (unsigned char*) line, UFLstrlen( line ), &pFont->eexecKey );
    if ( retVal == kNoErr )
#ifdef WIN_ENV
        retVal = EExec( pUFO->pUFL->hOut, c, 2, &pFont->eexecKey );
#else
            /* MWCWP1 doesn't like the implicit cast from char* to unsigned char*  --jfu */
        retVal = EExec( pUFO->pUFL->hOut, (unsigned char*) c, 1, &pFont->eexecKey );
#endif
    }

    return retVal;
}


/***************************************************************************
 *
 *                          DownloadFontHeader
 *
 *
 *    Function: Download an empty font. After this action, glyphs
 *        can be added to the font.
 *
***************************************************************************/
static UFLErrCode
DownloadFontHeader(
    UFOStruct   *pUFO
    )
{
    UFLErrCode  retVal;
    char        buf[128];
    UFLHANDLE   stream;
    char        **pp;
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;

    const static char *lenIV = "/lenIV -1 def";

    const static char *type1Hdr[] =
    {
       "/PaintType 0 def",
        "/FontType 1 def",
        "/FontBBox { 0 0 0 0 } def",   /* Assuming that the font does not use the seac command, see black book page 13 */
        "AddFontInfoBegin",            /* Goodname */
        "AddFontInfo",
        "AddFontInfoEnd",
        "currentdict",
        "end",
        ""
    };

    /* Private dict definition */
    const static char *privateDict[] =
    {
        "dup /Private 7 dict dup begin",
        "/BlueValues [] def",
        "/MinFeature {16 16} def",
        "/password 5839 def",
        "/ND {def} def",
        "/NP {put} def",
        ""
    };

    const static char *rdDef[] =
    {
        "/RD {string currentfile exch readstring pop} def\n",
        "/RD {string currentfile exch readhexstring pop} def\n"
    } ;


    if ( pUFO->flState != kFontInit )
    return kErrInvalidState;

    stream = pUFO->pUFL->hOut;
    retVal = StrmPutStringEOL( stream, "11 dict begin" );
    if ( kNoErr == retVal )
    {
    UFLsprintf( buf, CCHOF(buf), "/FontName /%s def", pUFO->pszFontName );
    retVal = StrmPutStringEOL( stream, buf );
    }

    /* Put font matrix */
    if ( kNoErr == retVal )
    {
    retVal = StrmPutString( stream, "/FontMatrix " );
    if ( kNoErr == retVal )
        retVal = StrmPutString( stream, "[1 " );
    if ( kNoErr == retVal )
        retVal = StrmPutFixed( stream, pFont->info.matrix.a );
    if ( kNoErr == retVal )
        retVal = StrmPutString( stream, "div 0 0 1 " );
    if ( kNoErr == retVal )
        retVal = StrmPutFixed( stream, pFont->info.matrix.d );
    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, "div 0 0 ] def" );

    }

    /* Put font encoding */
    if ( kNoErr == retVal )
    retVal = StrmPutString( stream, "/Encoding " );
    if ( kNoErr == retVal )
    {
    if ( pUFO->pszEncodeName == 0 )
        retVal = StrmPutString( stream, gnotdefArray );
    else
        retVal = StrmPutString( stream, pUFO->pszEncodeName );
    }
    if ( retVal == kNoErr )
    retVal = StrmPutStringEOL( stream, " def" );

    /* Put type1 header */
    for ( pp = (char **)type1Hdr; **pp && retVal == kNoErr; pp++ )
    retVal = StrmPutStringEOL( stream, *pp );

    /* Goodname */
    pUFO->dwFlags |= UFO_HasFontInfo;
    pUFO->dwFlags |= UFO_HasG2UDict;

    /* Put the systemdict on top of the dict stack ( this is what 'eexec' does ).*/
    if ( kNoErr == retVal )
    {
    BeginEExec( pUFO );
    }


    for ( pp = (char**)privateDict; **pp && retVal == kNoErr; pp++ )
    {
    retVal = PutLine( pUFO, *pp );
    }

    /* Define lenIV = -1 which means no extra byte and no encryption. */
    if ( 0 == pFont->info.bEExec )
    retVal = StrmPutStringEOL( stream, lenIV );

    /* Define RD base on the output format */
    if ( 0 == pFont->info.bEExec )
    PutLine( pUFO, ( StrmCanOutputBinary( stream ) ) ? (char *)rdDef[0] : (char *)rdDef[1] );
    else
    {
    PutLine( pUFO, (char *)rdDef[0] );
    }

    /* Define the CharString dict */
    UFLsprintf( buf, CCHOF(buf), "2 index /CharStrings %d dict dup begin", pFont->info.fData.maxGlyphs );
    PutLine( pUFO, buf );

    return retVal;
}


static UFLErrCode
DownloadFontFooter(
    UFOStruct  *pUFO
    )
{
    UFLErrCode retVal;
    UFLHANDLE  stream = pUFO->pUFL->hOut;
    char       **eftr;
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;

    /* Finish up the encrypted portion */
    static char *encryptFtr[] =
    {
        "end",
        "end",
        "put",
        "put",
        "dup /FontName get exch definefont pop",
        ""
    };


    retVal = kNoErr;
    for ( eftr = encryptFtr; **eftr && retVal == kNoErr; eftr++ )
    {
    retVal = PutLine( pUFO, *eftr );
    }

    if ( retVal == kNoErr )
    retVal = EndEExec( pUFO );

    return retVal;
}

static UFLErrCode
DownloadCharString(
    UFOStruct       *pUFO,
    const char      *glyphName
    )
{
    char            buf[128];
    UFLErrCode      retVal;
    UFLHANDLE       stream;
    unsigned long   bufLen;
    UFLsize_t       len = 0;
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;

    retVal = kNoErr;
    stream = pUFO->pUFL->hOut;

    bufLen = (unsigned long)CSBufCurrentLen( pFont->pCSBuf );

    //
    // Note that for user-mode driver, UFLsprintf() returns HRESULT.
    //
    #ifdef WIN32KERNEL
    len = UFLsprintf( buf, CCHOF(buf), "/%s %ld RD ", glyphName, bufLen );
    #else  // !WIN32KERNEL
    if (SUCCEEDED(UFLsprintf( buf, CCHOF(buf), "/%s %ld RD ", glyphName, bufLen )))
    {
        len = strlen(buf);
    }
    #endif

    if ( pFont->info.bEExec )
    retVal = EExec( stream, (unsigned char*)buf, len, &pFont->eexecKey );
    else
    {
    // Fix Adobe Bug #233904: PS error when TBCP
    // Do not send 0D 0A after RD.
    if (StrmCanOutputBinary( stream ))
    {
        retVal = StrmPutString( stream, (const char*)buf );
    }
    else
    {
        retVal = StrmPutStringEOL( stream, (const char*)buf );
    }
    }

    if ( kNoErr == retVal )
    {
    if ( pFont->info.bEExec )
    {
        retVal = EExec( stream, (unsigned char*)pFont->pCSBuf->pBuf, (UFLsize_t) bufLen, &pFont->eexecKey );
        if ( kNoErr == retVal )
        retVal = EExec( stream, (unsigned char*)" ND ", (UFLsize_t) 4, &pFont->eexecKey );
    }
    else
    {
        if ( StrmCanOutputBinary( stream ) )
        retVal = StrmPutBytes( stream, (const char*)pFont->pCSBuf->pBuf, (UFLsize_t) bufLen, 0 );
        else
        retVal = StrmPutAsciiHex( stream, (const char*)pFont->pCSBuf->pBuf, bufLen );

        if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, (const char*)" ND " );
    }
    }

    return retVal;
}


static UFLErrCode
DefineNotDefCharString(
    UFOStruct   *pUFO
    )
{
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;
    UFLErrCode retVal = kNoErr;

    retVal = CharString( pFont, kT1cscStartChar );

    if ( kNoErr == retVal )
    retVal = CharString( pFont, kT1cscSBW, 0L, 0L, 0L, 0L );    /* make the origin stay the same */

    if ( kNoErr == retVal )
    retVal = CharString( pFont, kT1cscEndChar );

    if ( kNoErr == retVal )
    retVal = DownloadCharString( pUFO, ".notdef"  );

    return retVal;

}

static UFLErrCode
BeginCharString(
    TTT1FontStruct *pFont
    )
{
    if ( pFont->info.bEExec )
    {
    /* Output 4 random number as defined in the black book */
    unsigned char* rb = randomBytes;
    short i;

    if ( 0 == CSBufCheckSize( pFont->pCSBuf, 4 ) )
    {
        return kErrOutOfMemory;
    }
    else
    {
        for ( i = 0; i < 4; i++, rb++ )
        CSBufAddChar( pFont->pCSBuf, *rb );
    }
    }
    return kNoErr;
}

static UFLErrCode
EndCharString(
    TTT1FontStruct *pFont
    )
{
    if ( pFont->info.bEExec )
    {
    unsigned long len = (unsigned long)CSBufCurrentLen( pFont->pCSBuf );
         unsigned short key = kCSKey;

        /* MWCWP1 doesn't like the implicit casts from char* to const unsigned char*  --jfu */
    Encrypt( (const unsigned char*) CSBufBuffer( pFont->pCSBuf ),
         (const unsigned char*) CSBufBuffer( pFont->pCSBuf ),
         (long)len, (long*)&len, &key );
    }

    return kNoErr;
}

/***************************************************************************
 *
 *                          AddGlyph
 *
 *
 *    Function: Adds a single glyph to the font by calling the client
 *        outline callback routine.
 *
***************************************************************************/
static UFLErrCode
AddGlyph(
    UFOStruct      *pUFO,
    UFLGlyphID     glyph,
    const char     *glyphName
    )
{
    UFLErrCode       retVal = kNoErr;
    UFLFixedPoint    pt[3], currentPoint;
    UFLFixed         xWidth, yWidth, xSB, ySB;
    UFLFontProcs     *pFontProcs;
    TTT1FontStruct   *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;
    UFLBool           bYAxisNegative = 1;
    //this flag determines whether the char string's Yaxis grows in
    //positive(lower left) or negative(upper left) direction from the origin.
    //For w95 ufoenc.CreateGlyphOutlineIter(), bYAxisNegative = 0
    //Font wNT40/50, ufoenc.CreateGlyphoutlineIter(), bYAxisNegative = 1;
    //ang 11/17/97
    long              lArgs[6];


    pFontProcs = (UFLFontProcs *)&pUFO->pUFL->fontProcs;

    /* Whatever is in glyph, pass back to client */
    if ( pFontProcs->pfCreateGlyphOutlineIter( pUFO->hClientData, glyph, &xWidth, &yWidth, &xSB, &ySB, &bYAxisNegative ) )
    {
    UFLBool    cont = 1;
    do{
        switch ( pFontProcs->pfNextOutlineSegment( pUFO->hClientData, &pt[0], &pt[1], &pt[2] ) )
        {
        case kUFLOutlineIterDone:
        default:
        if ( pFontProcs->pfDeleteGlyphOutlineIter )
            pFontProcs->pfDeleteGlyphOutlineIter( pUFO->hClientData );
        cont = 0;
        break;

        case kUFLOutlineIterBeginGlyph:
        /* Signal start of character definition */
        retVal = CharString( pFont, kT1cscStartChar );
        if ( retVal == kNoErr )
        {
            /* Output the sidebearing and width information.   */
            retVal = CharString( pFont, kT1cscSBW, UFLTruncFixed(xSB), UFLTruncFixed(ySB),
                     UFLTruncFixed(xWidth), UFLTruncFixed(yWidth) );
            /* Initialize the current point to be the origin */
            currentPoint.x = xSB;
            currentPoint.y = ySB;
        }
        break;

        case kUFLOutlineIterEndGlyph:
        break;

        case kUFLOutlineIterMoveTo:
        if (bYAxisNegative)
        {
            retVal = CharString( pFont, kT1cscRMoveTo,
              UFLTruncFixed(pt[0].x - currentPoint.x),
              UFLTruncFixed(currentPoint.y - pt[0].y));
        }
        else
        {
// In NT, do Truncate AFTER subtract. In Win95, do truncate BEFORE subtract.
            retVal = CharString( pFont, kT1cscRMoveTo,
              UFLTruncFixed(pt[0].x) - UFLTruncFixed(currentPoint.x),
              UFLTruncFixed(pt[0].y) - UFLTruncFixed(currentPoint.y));
        }

        /* Remember last point so we can generate relative commands  */
        currentPoint = pt[0];
        break;

        case kUFLOutlineIterLineTo:
        if (bYAxisNegative)
        {
            retVal = CharString( pFont, kT1cscRLineTo,
                  UFLTruncFixed(pt[0].x - currentPoint.x),
                  UFLTruncFixed(currentPoint.y - pt[0].y));
        }
        else
        {
// In NT, do Truncate AFTER subtract. In Win95, do truncate BEFORE subtract.
            retVal = CharString( pFont, kT1cscRLineTo,
                  UFLTruncFixed(pt[0].x) - UFLTruncFixed(currentPoint.x),
                  UFLTruncFixed(pt[0].y) - UFLTruncFixed(currentPoint.y));
        }
        currentPoint = pt[0];
        break;

        case kUFLOutlineIterCurveTo:
        /* Convert points so that they match with rrcurveto arguments */
        if (bYAxisNegative)
        {
            retVal = CharString( pFont, kT1cscRRCurveTo,
                UFLTruncFixed( pt[0].x - currentPoint.x ),
                UFLTruncFixed( currentPoint.y  - pt[0].y ),
                UFLTruncFixed(pt[1].x - pt[0].x),
                UFLTruncFixed(pt[0].y - pt[1].y),
                UFLTruncFixed(pt[2].x - pt[1].x),
                UFLTruncFixed(pt[1].y - pt[2].y) );
        }
        else
        {
// In NT, do Truncate AFTER subtract. In Win95, do truncate BEFORE subtract.
            lArgs[0] = UFLTruncFixed( pt[0].x);
            lArgs[0] -= UFLTruncFixed(currentPoint.x );
            lArgs[1] = UFLTruncFixed( pt[0].y);
            lArgs[1] -= UFLTruncFixed(currentPoint.y);
            lArgs[2] = UFLTruncFixed(pt[1].x);
            lArgs[2] -= UFLTruncFixed(pt[0].x);
            lArgs[3] = UFLTruncFixed(pt[1].y);
            lArgs[3] -= UFLTruncFixed(pt[0].y);
            lArgs[4] = UFLTruncFixed(pt[2].x);
            lArgs[4] -= UFLTruncFixed(pt[1].x);
            lArgs[5] = UFLTruncFixed(pt[2].y);
            lArgs[5] -= UFLTruncFixed(pt[1].y) ;
            retVal = CharString( pFont, kT1cscRRCurveTo,
                lArgs[0], lArgs[1], lArgs[2], lArgs[3], lArgs[4], lArgs[5] );
        }
        currentPoint = pt[2];
        break;

        case kUFLOutlineIterClose:
        {
        retVal = CharString( pFont, kT1cscClosePath );
        break;
        }
        }    /* switch() */

        if ( cont && retVal != kNoErr )
        cont = 0;

    } while ( cont );

    if ( retVal == kNoErr )
        retVal = CharString( pFont, kT1cscEndChar );

    if ( retVal == kNoErr )
    {
        retVal = DownloadCharString( pUFO, glyphName );
    }
    }
    else retVal = kErrGetGlyphOutline;

    return retVal;
}


static UFLErrCode
DownloadAddGlyphHeader(
    UFOStruct   *pUFO
    )
{
    unsigned char   buf[256];
    UFLErrCode      retVal;
    UFLHANDLE       stream;
    char            **hdr;
    TTT1FontStruct  *pFont = (TTT1FontStruct *) pUFO->pAFont->hFont;
    const static char *encryptHdrU[] =
    {
        "findfont dup",
        "/Private get begin",
        "/CharStrings get begin",
        ""
    };

    retVal = kNoErr;
    stream = pUFO->pUFL->hOut;

    retVal = BeginEExec( pUFO );

    if ( kNoErr == retVal )
    {
        UFLsize_t  len = 0;

        //
        // Note that for user-mode driver, UFLsprintf() returns HRESULT.
        //
        #ifdef WIN32KERNEL
        len = UFLsprintf( (char*)buf, CCHOF(buf), "/%s ", pUFO->pszFontName );
        #else  // !WIN32KERNEL
        if (SUCCEEDED(UFLsprintf( (char*)buf, CCHOF(buf), "/%s ", pUFO->pszFontName )))
        {
            len = strlen(buf);
        }
        #endif

        if ( pFont->info.bEExec )
            retVal = EExec( stream, buf, len, &pFont->eexecKey );
        else
            retVal = StrmPutStringEOL( stream, (const char*)buf );
    }

    for ( hdr = (char**)encryptHdrU; retVal == kNoErr && **hdr; hdr++ )
    {
    if ( pFont->info.bEExec )
        retVal = EExec( stream, (unsigned char*)*hdr, UFLstrlen(*hdr), &pFont->eexecKey );
    else
        retVal = StrmPutStringEOL( stream, (const char*)*hdr );
    }

    return retVal;
}

static UFLErrCode
DownloadAddGlyphFooter(
    UFOStruct *pUFO
    )
{
    UFLErrCode  retVal;
    static char *addGlyphFtr = "end end";

    retVal = PutLine( pUFO, addGlyphFtr );
    if ( kNoErr == retVal )
    retVal = EndEExec( pUFO );

    return retVal;
}


/***************************************************************************
*
*                               CharString
*
*    Function:  Translates symbolic Type 1 character commands into
*               their encoded, encrypted equivalent.  The list of
*               available commands is defined in the constant section.
*                They are used by passing the command constant followed
*                by the long  arguments required by the function.
*
*               Example: CharString(lppd, kT1cscRMoveTo, lx, ly);
*
*               To make a character definition use kT1cscStartChar, followed
*               by all of the Type 1 character commands, and ending with
*               kT1cscEndChar.  The buffer contains the CharString
*               encrypted/encoded representation.  Given the length and the
*               properly encrypted data, the caller has enough information
*               to generate PS code that will add the character to a font
*               definition.  For more detail see Chapters 2 and 6 in the
*               Black Book.
*
***************************************************************************/
UFLErrCode
CharString(
    TTT1FontStruct *pFont,
    unsigned long  cmd,
    ...
    )
{
    va_list         arglist;
    long            args[10];
    unsigned short  argCount, i, j;
    UFLErrCode      retVal = kNoErr;

    switch ( cmd )
    {
    case kT1cscStartChar:
    {
    /* Allocate the buffer  */
    CSBufRewind( pFont->pCSBuf );
    return BeginCharString( pFont );
    }

    default:
    /* get the variable arguments */
    va_start(arglist, cmd);
    j = ((unsigned short)(cmd >> 16)) & 0xffff;

    for (i=0; i<j; i++)
    {
        args[i] = va_arg(arglist, long);
    }
    va_end(arglist);

    /* Attempt to optimize the command  */
    switch ( cmd ) {
        case kT1cscSBW:
        /* This can be reduced to an HSBW if the Y components are zero */
        if ( args[1] || args[3] )
            break;
        args[1] = args[2];
        cmd = kT1cscHSBW;
        break;

        case kT1cscRMoveTo:
        /* This can be reduced to a horizontal or vertical
           movement if one of the components is zero.
        */
        if ( 0 == args[1] )
        {
            cmd = kT1cscHMoveTo;
        }
        else if ( 0 == args[0] )
        {
            args[0] = args[1];
            cmd = kT1cscVMoveTo;
        }
        break;

        case kT1cscRLineTo:
        /* This can be reduced to a horizontal or vertical
           line if one of the components is zero.
        */
        if ( 0 == args[1] )
        {
            cmd = kT1cscHLineTo;
        }
        else if ( 0 == args[0] )
        {
            args[0] = args[1];
            cmd = kT1cscVLineTo;
        }
        break;

        case kT1cscRRCurveTo:
           /*
           This can be reduced to a simpler curve operator if the tangents
           at the endpoints of the Bezier are horizontal or vertical
           */
        if ( 0 == args[1] && 0 == args[4] )
        {
            args[1] = args[2];
            args[2] = args[3];
            args[3] = args[5];
            cmd = kT1cscHVCurveTo;
        }
        else if ( 0 == args[0] && 0 == args[5] )
        {
            args[0] = args[1];
            args[1] = args[2];
            args[2] = args[3];
            args[3] = args[4];
            cmd = kT1cscVHCurveTo;
        }
        break;
    }  /* switch (cmd) */

    /* arg count stored in HIWORD */
    argCount = ((unsigned short) (((long) (cmd) >> 16) & 0x0000FFFF));

    /*
    If buffer isn't big enough to hold this command expand buffer first.
    Exit if we can't grow buffer.
    Note: The formula (wArgCount * 5 + 2) assumes the worst case size
        requirement for the current command (all arguments stored
        as full longs and a two byte command).
    */
    if ( 0 == CSBufCheckSize( pFont->pCSBuf, (unsigned long)( argCount * 5 + 2 ) ) )
    {
        retVal = kErrOutOfMemory;
    }
    else
    {
        /* Push the numbers onto the stack  */
        i = 0;
        while ( retVal == kNoErr && argCount-- )
        {
        retVal = CSBufAddNumber( pFont->pCSBuf, args[i++] );
        }
    }

    /* Push the command onto the stack */
    if ( kNoErr == retVal )
    {
        char c = (char)    (cmd & 0x000000FF);

        CSBufAddChar( pFont->pCSBuf, c );
        if ( 12 == c )
        {   /* two byte command */
        CSBufAddChar( pFont->pCSBuf, (char) ((cmd >> 8) & 0x000000FF) );
        }

        /* If this isn't the end of a character definition return success  */
        if ( kT1cscEndChar == cmd )
        {
        /* We have finished the character: encrypt it if necessary */
        retVal = EndCharString( pFont );
        }
    }

    }  /* switch (cmd) */

    return retVal;
}


/***********************************
    Public Functions
 ***********************************/

void
TTT1FontCleanUp(
    UFOStruct      *pUFObj
    )
{
    TTT1FontStruct *pFont;

    if (pUFObj->pAFont == nil)
    return;

    pFont = (TTT1FontStruct *) pUFObj->pAFont->hFont;

    if ( pFont )
    {
    if ( pFont->pCSBuf != nil )
    {
        CSBufCleanUp( pFont->pCSBuf );
    }

    pFont->pCSBuf = nil;

    }

}


UFLErrCode
TTT1VMNeeded(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    )
{
    UFLErrCode      retVal = kNoErr;
    short           i;
    unsigned long   totalGlyphs;
    TTT1FontStruct  *pFont;
    unsigned short  wIndex;

    if (pUFObj->flState < kFontInit)
        return (kErrInvalidState);

    if ( pFCNeeded )
    *pFCNeeded = 0;

    pFont = (TTT1FontStruct *) pUFObj->pAFont->hFont;

    if (pGlyphs == nil || pGlyphs->pGlyphIndices == nil || pVMNeeded == nil)
    return kErrInvalidParam;

    totalGlyphs = 0;

    /* Scan the list, check what characters that we have downloaded */
    if ( pUFObj->pUFL->bDLGlyphTracking && pGlyphs->pCharIndex)
    {
    UFLmemcpy( (const UFLMemObj* ) pUFObj->pMem,
        pUFObj->pAFont->pVMGlyphs,
        pUFObj->pAFont->pDownloadedGlyphs,
        (UFLsize_t) (GLYPH_SENT_BUFSIZE( pFont->info.fData.cNumGlyphs)));
    for ( i = 0; i < pGlyphs->sCount; i++ )
    {
        /* use glyphIndex to track - fix bug when we do T0/T1 */
        wIndex = (unsigned short) pGlyphs->pGlyphIndices[i] & 0x0000FFFF; /* LOWord is the real GID */
        if (wIndex >= UFO_NUM_GLYPHS(pUFObj) )
        continue;

        if ( !IS_GLYPH_SENT( pUFObj->pAFont->pVMGlyphs, wIndex ) )
        {
        SET_GLYPH_SENT_STATUS( pUFObj->pAFont->pVMGlyphs, wIndex );
        totalGlyphs++;
        }
    }
    }
    else
    totalGlyphs = pGlyphs->sCount;

    if ( pUFObj->flState == kFontInit )
    *pVMNeeded = kVMTTT1Header;
    else
    *pVMNeeded = 0;

    *pVMNeeded += totalGlyphs * kVMTTT1Char;

    *pVMNeeded = VMRESERVED( *pVMNeeded );

    return kNoErr;
}

/***************************************************************************
 *
 *                          DownloadIncrFont
 *
 *
 *    Function: Adds all of the characters from pGlyphs that aren't already
 *              downloaded for the TrueType font.
 *
 *  Note: pCharIndex is used to track which char(in this font) is downloaded or not
 *        It can be nil if client doesn't wish to track - e.g. Escape(DownloadFace)
 *        It has no relationship with ppGlyphNames.
 *        E.g., ppGlyphNames[0]="/A", pCharIndex[0]=6, pGlyphIndices[0]=1000: means
 *        To download glyphID 1000 as Char-named "/A" and Also, remember the 6th-char is downloaded
 *
 *        ppGlphNames is optional - if not provided, UFL will parse "post" table to find from GlyphID
 *        - it it is provided, we may use it as a "hint" for the glyphName - use it if parse failed.
 *
***************************************************************************/

#pragma optimize("", off)

UFLErrCode
TTT1FontDownloadIncr(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long           *pFCUsage
    )
{
    UFLGlyphID      *glyphs;
    short           i, hasCharToAdd;
    short           hasCharToEncode;
    UFLErrCode      retVal;
    char            *pGoodName;
    unsigned short  wIndex;
    UFLBool         bGoodName;      // GoodName
    char            pGlyphName[32]; // GoodName

    if (pUFObj->flState < kFontInit)
        return (kErrInvalidState);

    if ( pFCUsage )
    *pFCUsage = 0;

    if ( pGlyphs == nil || pGlyphs->pGlyphIndices == nil)
       return kErrInvalidParam;

    /* We don't support download full font */
    if ( pGlyphs->sCount == -1 )
    return kErrNotImplement;

    retVal = kNoErr;

    glyphs = pGlyphs->pGlyphIndices;

    hasCharToAdd = 1; // Assume has some char to add
    hasCharToEncode = 0;
    /* If AddChar - First check if there is any chars to Add! */
    if (pUFObj->flState == kFontHasChars &&
    pUFObj->pUFL->bDLGlyphTracking != 0 &&
    pGlyphs->pCharIndex != nil)
    {
    hasCharToAdd = 0;  /* if asked to AddChar and totrack, check if there is any to add */
    for ( i = 0; i < pGlyphs->sCount; i++ )
    {
        /* use glyphIndex to track - fix bug when we do T0/T1 */
        wIndex = (unsigned short) glyphs[i] & 0x0000FFFF; /* LOWord is the real GID */

        if (wIndex >= UFO_NUM_GLYPHS(pUFObj) )
        continue;

            if (!IS_GLYPH_SENT( pUFObj->pAFont->pDownloadedGlyphs, wIndex ))
        {
        hasCharToAdd = 1;
        break;
        }
            if (!IS_GLYPH_SENT( pUFObj->pUpdatedEncoding, pGlyphs->pCharIndex[i] ))
                hasCharToEncode = 1;
    }
    }

    if (hasCharToAdd==0)
    {
        // This code is to fix bug 288988.
        if (hasCharToEncode)
             UpdateEncodingVector(pUFObj, pGlyphs, 0, pGlyphs->sCount);
    if (pVMUsage) *pVMUsage = 0 ;
    return retVal;  /* no error, no VM used */
    }

    /* Download the font header if this is the first time we download the font */
    if ( pUFObj->flState == kFontInit )
    {
    retVal = DownloadFontHeader( pUFObj );
    if ( pVMUsage )
        *pVMUsage = kVMTTT1Header;
    }
    else
    {
    retVal = DownloadAddGlyphHeader( pUFObj );
    if ( pVMUsage )
        *pVMUsage = 0;
    }

     /* Every font must have a .notdef character!  */
    if ( kNoErr == retVal && pUFObj->flState == kFontInit )
    {
    retVal = DefineNotDefCharString( pUFObj );
    if ( kNoErr == retVal && pVMUsage )
        *pVMUsage += kVMTTT1Char;
    }

   /* Download the new glyphs */
   if(retVal == kNoErr)
   {
      // Skip the ones don't exist.  Don't stop when there's error
      for ( i = 0; i < pGlyphs->sCount; ++i)
      {
         /* use glyphIndex to track - fix bug when we do T0/T1 */
         wIndex = (unsigned short) glyphs[i] & 0x0000FFFF; /* LOWord is the real GID */
         if (wIndex >= UFO_NUM_GLYPHS(pUFObj) )
            continue;

         if ( 0 == pUFObj->pUFL->bDLGlyphTracking ||
            pGlyphs->pCharIndex == nil ||      // DownloadFace
            pUFObj->pEncodeNameList ||         // DownloadFace
            !IS_GLYPH_SENT( pUFObj->pAFont->pDownloadedGlyphs, wIndex ) )
         {
            // GoodName
            pGoodName = pGlyphName;
            bGoodName = FindGlyphName(pUFObj, pGlyphs, i, wIndex, &pGoodName);

            // Fix bug 274008  Check Glyph Name only for DownloadFace.
            if (pUFObj->pEncodeNameList)
            {
                if ((UFLstrcmp( pGoodName, Hyphen ) == 0) && (i == 45))
                {
                    // Add /minus to CharString
                    //if ( kNoErr == retVal )
                        retVal = AddGlyph( pUFObj, glyphs[i], Minus);
                }
                if ((UFLstrcmp( pGoodName, Hyphen ) == 0) && (i == 173))
                {
                    // Add /sfthyphen to CharString
                    //if ( kNoErr == retVal )
                        retVal = AddGlyph( pUFObj, glyphs[i], SftHyphen);
                }

                if (!ValidGlyphName(pGlyphs, i, wIndex, pGoodName))
                    continue;
                // Send only one ".notdef"
                if ((UFLstrcmp( pGoodName, Notdef ) == 0) &&
                    (wIndex == (unsigned short) (glyphs[0] & 0x0000FFFF)) &&
                    IS_GLYPH_SENT( pUFObj->pAFont->pDownloadedGlyphs, wIndex ))
                    continue;
            }

            //if ( kNoErr == retVal )
            retVal = AddGlyph( pUFObj, glyphs[i], pGoodName);

            if ( kNoErr == retVal )
            {
               SET_GLYPH_SENT_STATUS( pUFObj->pAFont->pDownloadedGlyphs, wIndex );
               if (bGoodName)    // GoodName
                   SET_GLYPH_SENT_STATUS( pUFObj->pAFont->pCodeGlyphs, wIndex );

               if ( pVMUsage )
                  *pVMUsage += kVMTTT1Char;
            }
         }
      }
   }

   /* Always download font footer and update encoding vector regardless of
      retVal.  This is because passthrough code may try to use this font */
    retVal = ( pUFObj->flState == kFontInit ) ? DownloadFontFooter( pUFObj ) : DownloadAddGlyphFooter( pUFObj );

   /* update Encoding vector with the good names if necessary*/
    UpdateEncodingVector(pUFObj, pGlyphs, 0, pGlyphs->sCount);

    /* GoodName  */
    /* Update the FontInfo with Unicode information. */
    if ((kNoErr == retVal) && (pGlyphs->sCount > 0) &&
        (pUFObj->dwFlags & UFO_HasG2UDict) &&
        (pUFObj->pUFL->outDev.lPSLevel >= kPSLevel2) &&  // Don't do this for level1 printers
        !(pUFObj->lNumNT4SymGlyphs))
    {
        /* Check pUFObj->pAFont->pCodeGlyphs to see if we really need to update it. */
        for ( i = 0; i < pGlyphs->sCount; i++ )
        {
            wIndex = (unsigned short) glyphs[i] & 0x0000FFFF; /* LOWord is the real GID. */
            if (wIndex >= UFO_NUM_GLYPHS(pUFObj) )
                continue;

            if (!IS_GLYPH_SENT( pUFObj->pAFont->pCodeGlyphs, wIndex ) )
            {
                // Found at least one not updated, do it (once) for all.
                retVal = UpdateCodeInfo(pUFObj, pGlyphs, 0);
                break;
            }
        }
    }

    if ( kNoErr == retVal )
    {
    pUFObj->flState = kFontHasChars;
    }

    if ( pVMUsage )
    *pVMUsage = VMRESERVED( *pVMUsage );

    return retVal;

}

#pragma optimize("", on)

/* Send PS code to undefine fonts: /UDF should be defined properly by client
* to something like:
    /UDF
    {
    IsLevel2
    {undefinefont}
    { pop }ifelse
    } bind def
*/
UFLErrCode
TTT1UndefineFont(
    UFOStruct *pUFObj
)
{
    UFLErrCode retVal = kNoErr;
    char buf[128];
    UFLHANDLE stream;

    if (pUFObj->flState < kFontHeaderDownloaded) return retVal;

    stream = pUFObj->pUFL->hOut;
    UFLsprintf( buf, CCHOF(buf), "/%s UDF", pUFObj->pszFontName );
    retVal = StrmPutStringEOL( stream, buf );

    return retVal;
}


UFOStruct *
TTT1FontInit(
    const UFLMemObj  *pMem,
    const UFLStruct  *pUFL,
    const UFLRequest *pRequest
    )
{
    TTT1FontStruct  *pFont = nil;
    UFLTTT1FontInfo *pInfo;
    UFOStruct       *pUFObj;
    long             maxGlyphs;

    /* MWCWP1 doesn't like the implicit cast from void* to UFOStruct*  --jfu */
    pUFObj = (UFOStruct*) UFLNewPtr( pMem, sizeof( UFOStruct ) );
    if (pUFObj == 0)
      return 0;

    /* Initialize data */
    UFOInitData(pUFObj, UFO_TYPE1, pMem, pUFL, pRequest,
      (pfnUFODownloadIncr)  TTT1FontDownloadIncr,
      (pfnUFOVMNeeded)      TTT1VMNeeded,
      (pfnUFOUndefineFont)  TTT1UndefineFont,
      (pfnUFOCleanUp)       TTT1FontCleanUp,
      (pfnUFOCopy)          CopyFont );

    /* pszFontName should be ready/allocated - if not FontName, cannot continue */
    if (pUFObj->pszFontName == nil || pUFObj->pszFontName[0] == '\0')
    {
      UFLDeletePtr(pMem, pUFObj);
      return nil;
    }

    pInfo = (UFLTTT1FontInfo *)pRequest->hFontInfo;

    maxGlyphs = pInfo->fData.cNumGlyphs;

    /* a convenience pointer used in GetNumGlyph() - must be set now*/
    pUFObj->pFData = &(pInfo->fData); /* Temporary assignment !! */
    if (maxGlyphs == 0)
      maxGlyphs = GetNumGlyphs( pUFObj );

    /*
     * On NT4 a non-zero value will be set to pInfo->lNumNT4SymGlyphs for
     * symbolic TrueType font with platformID 3/encodingID 0. If it's set, it
     * is the real maxGlyphs value.
     */
    pUFObj->lNumNT4SymGlyphs = pInfo->lNumNT4SymGlyphs;

    if (pUFObj->lNumNT4SymGlyphs)
        maxGlyphs = pInfo->lNumNT4SymGlyphs;

    /*
     * We now use Glyph Index to track which glyph is downloaded, so use
     * maxGlyphs.
     */
    if ( NewFont(pUFObj, sizeof(TTT1FontStruct),  maxGlyphs) == kNoErr )
    {
        pFont = (TTT1FontStruct*) pUFObj->pAFont->hFont;

        pFont->info = *pInfo;

        /* a convenience pointer */
        pUFObj->pFData = &(pFont->info.fData);

        /*
         * Get ready to find out correct glyphNames from "post" table - set
         * correct pUFO->pFData->fontIndex and offsetToTableDir.
         */
        if ( pFont->info.fData.fontIndex == FONTINDEX_UNKNOWN )
            pFont->info.fData.fontIndex = GetFontIndexInTTC(pUFObj);

        /* Get num of Glyphs in this TT file if not set yet */
        if (pFont->info.fData.cNumGlyphs == 0)
            pFont->info.fData.cNumGlyphs = maxGlyphs;

        if (pFont->pCSBuf == nil)
            pFont->pCSBuf = CSBufInit( pMem );

        if (pFont->pCSBuf == nil)
        {
            vDeleteFont( pUFObj );
            UFLDeletePtr( pUFObj->pMem, pUFObj );
            return nil;
        }

        if ( pUFObj->pUpdatedEncoding == 0 )
        {
            pUFObj->pUpdatedEncoding = (unsigned char *)UFLNewPtr( pMem, GLYPH_SENT_BUFSIZE(256) );
        }

        if ( pUFObj->pUpdatedEncoding != 0 )  /* completed initialization */
            pUFObj->flState = kFontInit;
    }

    return pUFObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\ufocff.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFOCFF.c - Compact Font Format Object
 *
 ******************************************************************************
 *
 * Note about SUBSET_PREFIX and more comment for VRT2_FEATURE_DISABLED
 *
 * When we donwload a font, its /FontName or /CIDFontName can be any name we
 * want. If the name folows the following format:
 *     SUBSET_PREFIX+RealFontName
 * where SUBSET_PREFIX is a string consited of six characters, each of them is
 * either 'a' ~ 'p' or 'A' ~ 'P', then Distiller4 takes RealFontName part as
 * the font's real name. e.g. abcdef+Helvetica -> Distiller4 realizes that this
 * this font's real font name is Helvetica.
 * We, Adobe Windows Driver Group, decided to go for it (bug #291934). At the
 * same time, we also deciced to remve the code for 'vrt2' feature incapable
 * CJK OpenType font, that is, remove #ifdef/#endif with VRT2_FEATURE_DISABLED
 * because virtually any CJK OpenType fonts are supposed to have 'vrt2'
 * feature. Otherwise vertical version of such CJK OpenType font can't be
 * supported (by ATM or CoolType). Thus, there will be no #ifdef/#endif section
 * with VRT2_FEATURE_DISABLED keyword in this code and the sentence "But, just
 * in case, ....at compile time." in the following note is now obsolite.
 * You can retrieve the removed code from the version 16 or below of this file
 * in SourceSafe if you want.
 *
 * --- This note is now obsolete. ---------------------------------------------
 *
 * Note about 'vrt2' feature and VRT2_FEATURE_DISABLED
 *
 * OTF-based fonts will only have their "@" capability enabled if they have a
 * 'vrt2' feature in their 'GSUB' table; otherwise only horizontal typographic
 * rendering is enabled. When the 'vrt2' feature exists in a font, the font
 * vendor claims that all of the glyphs for the @ variant of the font should be
 * rotated before display / print. Thus, on neither NT4 nor W2K, the PostScript
 * driver doesn't even have to call GlyhAttrs to find out which @ glyphs are
 * rotated; they all are. But, just in case, the logic for rotating @ glyphs is
 * also provided and it will be enabled when VRT2_FEATURE_DISABLED flag is set
 * at compile time.
 *-----------------------------------------------------------------------------
 *
 * $Header:
 */

#include "UFLMem.h"
#include "UFLErr.h"
#include "UFLPriv.h"
#include "UFLVm.h"
#include "UFLStd.h"
#include "UFLMath.h"
#include "UFLPS.h"
#include "ParseTT.h"
#include "UFOCff.h"
#include "UFOt42.h"
#include "ttformat.h"


#ifdef UNIX
#include <sys/varargs.h>
#include <assert.h>
#else
        #ifdef MAC_ENV
        #include <assert.h>
        #endif
        #include <stdarg.h>
#endif

static unsigned char *pSubrNames[4] = {
    (unsigned char*) "F0Subr",
    (unsigned char*) "F1Subr",
    (unsigned char*) "F2Subr",
    (unsigned char*) "HSSubr"
};

#define  VER_WO_OTHERSUBRS      51


/*
 * Maximum known supplement number. This number is used to decide whether
 * GlyphName2Unicode table should be downloaded.
 */
#define ADOBE_JAPAN1_MAXKNOWN   4
#define ADOBE_KOREA1_MAXKNOWN   1
#define ADOBE_GB1_MAXKNOWN      2
#define ADOBE_CNS1_MAXKNOWN     0

/*
 * Macro to check whether they are known ordering and supplement.
 */
#define KNOWN_OS(o, on, s, max)  (!UFLstrcmp((o), (on)) && ((0 <= (s)) && ((s) < (max))))


/******************************************************************************
 *
 *                              Callback Functions
 *
 ******************************************************************************/

static unsigned long int
AllocateMem(
    void PTR_PREFIX *PTR_PREFIX *hndl,
    unsigned long int           size,
    void PTR_PREFIX             *clientHook
    )
{
    UFOStruct *pUFO = (UFOStruct *)clientHook;

    if ((size == 0) && (*hndl == nil))
       return 1;

    if (size == 0)
    {
        UFLDeletePtr(pUFO->pMem, *hndl);
       *hndl = nil;
        return 1;
    }

    if (*hndl == nil)
    {
        *hndl = UFLNewPtr(pUFO->pMem, size);

        return (unsigned long int)(ULONG_PTR)*hndl;
    }
    else
    {
        return (unsigned long int)UFLEnlargePtr(pUFO->pMem, (void **)hndl, size, 1);
    }

    return 1;
}


/* We do not support seeking for this function. */
static int
PutBytesAtPos(
    unsigned char PTR_PREFIX *pData,
    long int                 position,
    unsigned short int       length,
    void PTR_PREFIX          *clientHook
    )
{
    if (position >= 0)
    {
        return 0;
    }

    if (length > 0)
    {
        UFOStruct *pUFO = (UFOStruct *)clientHook;

        if (kNoErr == StrmPutBytes(pUFO->pUFL->hOut,
                                    (const char *)pData,
                                    (UFLsize_t)length,
                                    (const UFLBool)StrmCanOutputBinary(pUFO->pUFL->hOut)))
        {
            return 0;
        }
    }

    return 1;
}


static int
GetBytesFromPos(
    unsigned char PTR_PREFIX * PTR_PREFIX *ppData,
    long int           position,
    unsigned short int length,
    void PTR_PREFIX    *clientHook
    )
{
    UFOStruct     *pUFO  = (UFOStruct *)clientHook;
    CFFFontStruct *pFont = (CFFFontStruct *)pUFO->pAFont->hFont;
    int           retVal = 0;  /* Set retVal to failure. */

    /*
     * Check to see if the client passes us a whole cff table.
     */
    if (pFont->info.ppFontData)
    {
        /*
         * Get the data from the table by ourself.
         */
        if ((unsigned long int)(position + length) <= pFont->info.fontLength)
        {
            *ppData = (unsigned char PTR_PREFIX *)*pFont->info.ppFontData + position;

            retVal = 1;
        }
    }
    else
    {
        UFLCFFReadBuf *pReadBuf = pFont->pReadBuf;

        if (0 == pReadBuf->cbBuf)
        {
            pReadBuf->pBuf = (unsigned char PTR_PREFIX *)UFLNewPtr(pUFO->pMem, length);

            if (pReadBuf->pBuf)
                pReadBuf->cbBuf = length;
            else
                return 0;
        }
        else if (pReadBuf->cbBuf < length)
        {
            UFLEnlargePtr(pUFO->pMem, (void **)&pReadBuf->pBuf, length, 0);
            pReadBuf->cbBuf = length;
        }

        /*
         * Fall back to read from callback function.
         */
        retVal = (int)GETTTFONTDATA(pUFO,
                                    CFF_TABLE,
                                    position,
                                    pReadBuf->pBuf,
                                    length,
                                    pFont->info.fData.fontIndex);

        *ppData = (unsigned char PTR_PREFIX *)pReadBuf->pBuf;
    }

    return retVal;
}


/******************************************************************************
 *
 *                              Private Functions
 *
 ******************************************************************************/

static void *
SetMemory(
    void                *dest,
    int                 c,
    unsigned short int  count
    )
{
    return UFLmemsetShort(dest, c, (size_t) count);
}


static unsigned short int
StringLength(
    const char PTR_PREFIX *string
    )
{
    return (unsigned short int)UFLstrlen(string);
}


static void
MemCpy(
     void PTR_PREFIX        *dest,
     const void PTR_PREFIX  *src,
     unsigned short int     count
     )
{
    memcpy(dest, (void*)src, (size_t)count);
}


static int
AsciiToInt(
    const char* string
    )
{
    return atoi(string);
}


static long
StringToLong(
    const char  *nptr,
    char        **endptr,
    int         base
    )
{
    return UFLstrtol(nptr, endptr, base);
}


static int
StrCmp(
    const char PTR_PREFIX *string1,
    const char PTR_PREFIX *string2
    )
{
    return UFLstrcmp(string1, string2);
}


static int
GetCharName(
    XFhandle           handle,
    void               *client,
    XCFGlyphID         glyphID,
    char PTR_PREFIX    *charName,
    unsigned short int length
    )
{
    if (client)
    {
        /*
         * Copy the charname by ourself because the name string returned from
         * XCF is not NULL terminated.
         */
        unsigned short int i;

        /* UFLsprintf((char*)client, "%s", charName); */

        for (i = 0; i < length; i++)
            *((char *)client)++ = *charName++;

        *((char *)client) = '\0';

        return XCF_Ok;
    }

    return XCF_InternalError;
}


static int
GIDToCID(
    XFhandle           handle,
    void PTR_PREFIX    *client,
    XCFGlyphID         glyphID,
    unsigned short int cid
    )
{
    if (client)
    {
        unsigned short int *pCid = (unsigned short int *)client;
        *pCid = cid;
        return XCF_Ok;
    }

    return XCF_InternalError;
}


static void
getFSType(
    XFhandle        h,
    long PTR_PREFIX *pfsType,
    void PTR_PREFIX *clientHook
    )
{
    UFOStruct* pUFO;
    long       fsType;

    if (!pfsType)
        return;

    *pfsType = -1; /* "Don't put FSType" by default. */

    if (!(pUFO = (UFOStruct*)clientHook))
        return;

    fsType = GetOS2FSType(pUFO);

    if(0 <= fsType)
        *pfsType = fsType;
}


/* GOODNAME */
static void
isKnownROS(XFhandle h,
           long PTR_PREFIX  *pknownROS,
           char PTR_PREFIX  *R,
           Card16           lenR,
           char PTR_PREFIX  *O,
           Card16           lenO,
           long             S,
           void PTR_PREFIX  *clientHook
           )
{
    UFOStruct *pUFO;

    if (!pknownROS)
        return;

    *pknownROS = 0;

    if (!(pUFO = (UFOStruct*)clientHook))
        return;

    if ((lenR < 32) && (lenO < 32))
    {
        char Registry[32], Ordering[32];
        int  i;

        for (i = 0; i < (int) lenR; i++)
            Registry[i] = (char) R[i];

        Registry[lenR] = '\0';

        for (i = 0; i < (int)lenO; i++)
            Ordering[i] = (char) O[i];

        Ordering[lenO] = '\0';

        if (!UFLstrcmp(Registry, "Adobe"))
        {
            if (   KNOWN_OS(Ordering, "Japan1", S, ADOBE_JAPAN1_MAXKNOWN)
                || KNOWN_OS(Ordering, "Korea1", S, ADOBE_KOREA1_MAXKNOWN)
                || KNOWN_OS(Ordering, "GB1",    S, ADOBE_GB1_MAXKNOWN   )
                || KNOWN_OS(Ordering, "CNS1",   S, ADOBE_CNS1_MAXKNOWN  ))
            {
                *pknownROS = 1;
            }
        }
    }

    if (*pknownROS)
        pUFO->pAFont->knownROS = 1;
    else
    {
        pUFO->pAFont->knownROS = 0;
        pUFO->dwFlags |= UFO_HasG2UDict;
    }
}


int
printfError(
    const char *format, ...
    )
{
    va_list arglist;
    int     retval = 0;
    char    buf[512];

    va_start(arglist, format);
    if (SUCCEEDED(StringCchVPrintfA(buf, CCHOF(buf), format, arglist)))
    {
        retval = strlen(buf);
    }
    va_end(arglist);
    return retval;
}


enum XCF_Result
CFFInitFont(
    UFOStruct       *pUFO,
    CFFFontStruct   *pFont
    )
{
    XCF_CallbackStruct callbacks = {0};
    XCF_ClientOptions  options   = {0};

    char fontName[256];

    /*
     * Initialize XCF_CallbackStruct object.
     */

    /* Stream output functions */
    callbacks.putBytes          = PutBytesAtPos;
    callbacks.putBytesHook      = (void PTR_PREFIX *)pUFO;
    callbacks.outputPos         = (XCF_OutputPosFunc)nil;
    callbacks.outputPosHook     = (void PTR_PREFIX *)0;
    callbacks.getBytes          = GetBytesFromPos;
    callbacks.getBytesHook      = (void PTR_PREFIX *)pUFO;
    callbacks.allocate          = AllocateMem;
    callbacks.allocateHook      = (void PTR_PREFIX *)pUFO;
    callbacks.pFont             = 0;
    callbacks.fontLength        = 0;

    /* C Standard library functions */
    callbacks.strlen            = (XCF_strlen)StringLength;
    callbacks.memcpy            = (XCF_memcpy)MemCpy;
    callbacks.memset            = (XCF_memset)SetMemory;
    callbacks.xcfSprintf        = (XCF_sprintf)UFLsprintf;
    callbacks.printfError       = (XCF_printfError)printfError;
    callbacks.atoi              = (XCF_atoi)AsciiToInt;
    callbacks.strtol            = (XCF_strtol)StringToLong;
    callbacks.atof              = (XCF_atof)nil; /* not required */
    callbacks.strcmp            = (XCF_strcmp)StrCmp;

    /* Glyph ID functions */
    callbacks.gidToCharName     = (XCF_GIDToCharName)GetCharName;
    callbacks.gidToCID          = (XCF_GIDToCID)GIDToCID;
    callbacks.getCharStr        = (XCF_GetCharString)nil;
    callbacks.getCharStrHook    = (void PTR_PREFIX *)nil;
    callbacks.getFSType         = (XCF_GetFSType)getFSType;
    callbacks.getFSTypeHook     = (void PTR_PREFIX *)pUFO;

    /* GOODNAME */
    callbacks.isKnownROS        = (XCF_IsKnownROS)isKnownROS;
    callbacks.isKnownROSHook    = (void PTR_PREFIX *)pUFO;

    /*
     * Initialize XCF_ClientOptions object.
     */

    options.fontIndex           = 0;                            /* font index w/i a CFF font set */
    options.uniqueIDMethod      = pFont->info.uniqueIDMethod;   /* UniqueID method */
    options.uniqueID            = pFont->info.uniqueID;
    options.subrFlatten         = (pFont->info.subrFlatten == kFlattenSubrs) ? XCF_FLATTEN_SUBRS : XCF_KEEP_SUBRS; /* Flatten subrs */
//   lenIV = -1 will fail on some clones bug 354368
//    options.lenIV               = (pUFO->pUFL->outDev.lPSLevel > kPSLevel1)  ? (unsigned int)-1 : 4;
    options.lenIV               = 0;
    options.hexEncoding         = StrmCanOutputBinary(pUFO->pUFL->hOut)      ? 0 : 1;
    options.eexecEncryption     = (pUFO->pUFL->outDev.lPSLevel > kPSLevel1)  ? 0 : 1;
    options.outputCharstrType   = 1; /* (pUFO->pUFL->outDev.lPSLevel > kPSLevel2) ? 2 : 1 */
    options.maxBlockSize        = pFont->info.maxBlockSize;

    /*
     * XCF_ClientOptions.dlOptions initialization
     */
    if (pFont->info.usePSName)
        options.dlOptions.notdefEncoding = 1;
    else
        options.dlOptions.notdefEncoding = 0;

    options.dlOptions.useSpecialEncoding = (pFont->info.useSpecialEncoding) ? 1 : 0;
    options.dlOptions.encodeName         = (unsigned char PTR_PREFIX *)pUFO->pszEncodeName;

    if (pFont->info.escDownloadFace)
        options.dlOptions.fontName = (unsigned char PTR_PREFIX *)pUFO->pszFontName;
    else
    {
        if (pFont->info.type1)
        {
            if (pUFO->subfontNumber < 0x100)
                CREATE_ADCFXX_FONTNAME(UFLsprintf, fontName, CCHOF(fontName),
                                        pUFO->subfontNumber, pFont->info.baseName);
            else
                CREATE_ADXXXX_FONTNAME(UFLsprintf, fontName, CCHOF(fontName),
                                        pUFO->subfontNumber, pFont->info.baseName);
        }
        else
        {
            /* Reuse vifinfo.nPlatformID to fix #507985. */
            if (pUFO->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
            {
                if (pUFO->lDownloadFormat == kCFFCID_H)
                    UFLsprintf(fontName, CCHOF(fontName), "%s%s", CFFPREFIX_H, pFont->info.baseName);
                else
                    UFLsprintf(fontName, CCHOF(fontName), "%s%s", CFFPREFIX_V, pFont->info.baseName);
            }
            else
                UFLsprintf(fontName, CCHOF(fontName), "%s%s", CFFPREFIX, pFont->info.baseName);
        }

        options.dlOptions.fontName = (unsigned char PTR_PREFIX *)fontName;
    }

    options.dlOptions.otherSubrNames =
        (pUFO->pUFL->outDev.lPSVersion >= VER_WO_OTHERSUBRS)
            ? 0 : (unsigned char PTR_PREFIX * PTR_PREFIX *)pSubrNames;

    return XCF_Init(&pFont->hFont, &callbacks, &options);
}


/******************************************************************************
 *
 *                              Public Functions
 *
 ******************************************************************************/

void
CFFFontCleanUp(
    UFOStruct   *pUFObj
    )
{
    CFFFontStruct *pFont;
    UFLCFFReadBuf *pReadBuf;

    if (pUFObj->pAFont == nil)
        return;

    pFont = (CFFFontStruct *)pUFObj->pAFont->hFont;

    if (pFont == nil)
        return;

    if (pFont->hFont)
    {
        XCF_CleanUp(&pFont->hFont);
        pFont->hFont = nil;
    }

    pReadBuf = pFont->pReadBuf;

    if (pReadBuf->pBuf)
    {
        UFLDeletePtr(pUFObj->pMem, pReadBuf->pBuf);
        pReadBuf->pBuf = nil;
    }
}


UFLErrCode
CFFUpdateEncodingVector1(
    UFOStruct           *pUFO,
    const UFLGlyphsInfo *pGlyphs,
    const short         cGlyphs,
    const UFLGlyphID    *pGlyphIndices
    )
{
    CFFFontStruct   *pFont  = (CFFFontStruct *)pUFO->pAFont->hFont;
    UFLHANDLE       stream  = pUFO->pUFL->hOut;
    UFLErrCode      retCode = kNoErr;
    char            strmbuf[256];
    short           i;

    /* Sanity checks */
    if (0 == cGlyphs)
        return kNoErr;

    if ((0 == pFont) || (0 == pGlyphIndices))
        return kErrInvalidParam;

    /*
     * Do '/FontName findfont /Encoding get'.
     */
    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s findfont /Encoding get", pUFO->pszFontName);
    retCode = StrmPutStringEOL(stream, strmbuf);

    for (i = 0; (retCode == kNoErr) && (i < cGlyphs) && *pGlyphIndices; i++, pGlyphIndices++)
    {
        UFLsprintf(strmbuf, CCHOF(strmbuf), "dup %d /", i);
        retCode = StrmPutString(stream, strmbuf);

        if (retCode == kNoErr)
        {
            XCF_GlyphIDsToCharNames(pFont->hFont,
                                    1,
                                    (XCFGlyphID PTR_PREFIX *)pGlyphIndices, /* list of glyphIDs */
                                    strmbuf,
                                    sizeof(strmbuf));
            retCode = StrmPutString(stream, strmbuf);
        }

        if (retCode == kNoErr)
            retCode = StrmPutStringEOL(stream, " put");
    }

    StrmPutStringEOL(stream, "pop");

    return retCode;
}


UFLErrCode
CFFUpdateEncodingVector(
    UFOStruct            *pUFO,
    const short          cGlyphs,
    const UFLGlyphID     *pGlyphIndices,
    const unsigned short *pGlyphNameIndex
    )
{
    CFFFontStruct           *pFont  = (CFFFontStruct *)pUFO->pAFont->hFont;
    UFLHANDLE               stream  = pUFO->pUFL->hOut;
    UFLErrCode              retCode = kNoErr;
    const UFLGlyphID        *pGlyphIndices2 = pGlyphIndices;
    const unsigned short    *pGlyphNameIndex2 = pGlyphNameIndex;
    char                    strmbuf[256];
    short                   i;

    /* Sanity checks */
    if (0 == cGlyphs)
        return kNoErr;

    if ((0 == pFont) || (0 == pGlyphNameIndex) || (0 == pGlyphIndices))
        return kErrInvalidParam;

    /*
     * Do we really need to update?
     */
    for (i = 0; i < cGlyphs; i++, pGlyphNameIndex2++, pGlyphIndices2++)
    {
        if ((*pGlyphNameIndex2 > 0) && (*pGlyphNameIndex2 <= 255))
        {
            if (!IS_GLYPH_SENT(pUFO->pUpdatedEncoding, *pGlyphNameIndex2))
                break;
        }
    }

    if (cGlyphs <= i)
        return kNoErr;

    /*
     * Do '/FontName findfont /Encoding get'.
     */
    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s findfont /Encoding get", pUFO->pszFontName);
    retCode = StrmPutStringEOL(stream, strmbuf);

    for (i = 0; (retCode == kNoErr) && (i < cGlyphs); i++, pGlyphNameIndex++, pGlyphIndices++)
    {
        if ((*pGlyphNameIndex > 0) && (*pGlyphNameIndex <= 255))
        {
            if (!IS_GLYPH_SENT(pUFO->pUpdatedEncoding, *pGlyphNameIndex))
            {
                /*
                 * Do "dup index /Charactername put."
                 */
                UFLsprintf(strmbuf, CCHOF(strmbuf), "dup %d /", *pGlyphNameIndex);
                retCode =  StrmPutString(stream, strmbuf);

                if (kNoErr == retCode)
                {
                    if (XCF_Ok == XCF_GlyphIDsToCharNames(pFont->hFont,
                                                          1,
                                                          (XCFGlyphID PTR_PREFIX *)pGlyphIndices, /* list of glyphIDs */
                                                          strmbuf,
                                                          sizeof(strmbuf)))
                    {
                        retCode = StrmPutString(stream, strmbuf);
                    }
                    else
                        retCode = kErrUnknown;
                }

                if (kNoErr == retCode)
                    retCode = StrmPutStringEOL(stream, " put");

                if (kNoErr == retCode)
                    SET_GLYPH_SENT_STATUS(pUFO->pUpdatedEncoding, *pGlyphNameIndex);
            }
        }
    }

    StrmPutStringEOL(stream, "pop");

    return retCode;
}


UFLErrCode
CFFCreateBaseFont(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    char                *pHostFontName
    )
{
    CFFFontStruct   *pFont  = (CFFFontStruct *)pUFObj->pAFont->hFont;
    UFLHANDLE       stream  = pUFObj->pUFL->hOut;
    UFLErrCode      retCode = kNoErr;
    char            strmbuf[512];

    /* Sanity checks */
    if (pUFObj->flState < kFontInit)
        return kErrInvalidState;

    if ((pFont == nil) || (pFont->hFont == nil))
        return kErrInvalidHandle;

    /*
     * Download procsets.
     */
    switch (pUFObj->lDownloadFormat)
    {
    case kCFF:
        if (pUFObj->pUFL->outDev.lPSVersion <= VER_WO_OTHERSUBRS)
        {
            /*
             * Only download the required OtherSubr procset if the printer
             * version is less than 51 and we have not download anything.
             */
            if (pUFObj->pUFL->outDev.pstream->pfDownloadProcset == 0)
                return kErrDownloadProcset;

            if (!pUFObj->pUFL->outDev.pstream->pfDownloadProcset(pUFObj->pUFL->outDev.pstream, kCFFHeader))
                return kErrDownloadProcset;
        }
        break;

    case kCFFCID_H:
    case kCFFCID_V:
        if (!pUFObj->pUFL->outDev.pstream->pfDownloadProcset(pUFObj->pUFL->outDev.pstream, kCMap_FF))
            return kErrDownloadProcset;

        if (pUFObj->bPatchQXPCFFCID)
        {
            if (!pUFObj->pUFL->outDev.pstream->pfDownloadProcset(pUFObj->pUFL->outDev.pstream, kCMap_90msp))
                return kErrDownloadProcset;
        }
    }

    /*
     * Donwload the font's dictionary and the glyph data.
     */
    if (!UFO_FONT_INIT2(pUFObj))
    {
        enum XCF_Result status;

        /*
         * Fixed bug 366539. hasvmtx is used to determine whether to call the
         * CFFUpdateMetrics2 function later.
         */
        unsigned long tblSize = GETTTFONTDATA(pUFObj,
                                                VMTX_TABLE, 0L,
                                                nil, 0L,
                                                pFont->info.fData.fontIndex);

        pUFObj->pAFont->hasvmtx = tblSize ? 1 : 0;


        if (!HOSTFONT_IS_VALID_UFO(pUFObj))
        {
            status = XCF_DownloadFontIncr(pFont->hFont,
                                          pGlyphs->sCount,
                                          pGlyphs->pGlyphIndices,
                                          (pGlyphs->pCharIndex == 0)
                                          ? nil
                                          : (unsigned char PTR_PREFIX * PTR_PREFIX *)pGlyphs->ppGlyphNames,
                                          pVMUsage);

            if (XCF_Ok != status)
                retCode = kErrXCFCall;
        }
    }


    /*
     * %hostfont% support
     * When this is a %hostfont% emit %%IncludeResource DSC comment prior to
     * create the font.
     */
    if ((kNoErr == retCode) && HOSTFONT_IS_VALID_UFO(pUFObj) && !UFO_FONT_INIT2(pUFObj))
    {
        UFLsprintf(strmbuf, CCHOF(strmbuf), "\n%%%%IncludeResource: %s %s",
                    (pUFObj->lDownloadFormat == kCFF) ? "font" : "CIDFont",
                    pHostFontName);

        if (kNoErr == retCode)
        retCode = StrmPutStringEOL(stream, strmbuf);
    }

    if ((kNoErr == retCode) && IS_CFFCID(pUFObj->lDownloadFormat))
    {
        /*
         * Instanciate Identity-H or -V CMap.
         *
         * When 'vrt2' feature is enabled (and which is default for OTF based
         * CJKV fonts), simply compose Identity-V CMap and the CIDFont
         * downloaded suffice.
         */
        if (pUFObj->lDownloadFormat == kCFFCID_H)
        {
            retCode = StrmPutStringEOL(stream, "CMAP-WinCharSetFFFF-H");

            /* Special for Quark */
            if ((kNoErr == retCode) && pUFObj->bPatchQXPCFFCID)
                retCode = StrmPutStringEOL(stream, "CMAP-90msp-RKSJ-H");
        }
        else
        {
            retCode = StrmPutStringEOL(stream, "CMAP-WinCharSetFFFF-V");

            /* Special for Quark */
            if ((kNoErr == retCode) && pUFObj->bPatchQXPCFFCID)
                retCode = StrmPutStringEOL(stream, "CMAP-90msp-RKSJ-H CMAP-90msp-RKSJ-QV");
        }

        if (kNoErr == retCode)
        {
            /*
             * Create the CID-Keyed font.
             */
            UFLBool bRequire_vmtx = pUFObj->pAFont->hasvmtx && HOSTFONT_REQUIRE_VMTX;

            if (pUFObj->lDownloadFormat == kCFFCID_H)
                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /WinCharSetFFFF-H", pUFObj->pszFontName);
            else
                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /WinCharSetFFFF-V", pUFObj->pszFontName);
            if (kNoErr == retCode)
                retCode = StrmPutStringEOL(stream, strmbuf);

            if (!HOSTFONT_IS_VALID_UFO(pUFObj))
            {
                /* Reuse vifinfo.nPlatformID to fix #507985. */
                if (pUFObj->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
                {
                    if (pUFObj->lDownloadFormat == kCFFCID_H)
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "[/%s%s] composefont pop", CFFPREFIX_H, pFont->info.baseName);
                    else
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "[/%s%s] composefont pop", CFFPREFIX_V, pFont->info.baseName);
                }
                else
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "[/%s%s] composefont pop", CFFPREFIX, pFont->info.baseName);
            }
            else if (!bRequire_vmtx)
                UFLsprintf(strmbuf, CCHOF(strmbuf), "[/%s] composefont pop", pHostFontName);
            else
            {
                if (UFL_CIDFONT_SHARED)
                {
                    if (!UFO_FONT_INIT2(pUFObj))
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s %s /%s hfMkCIDFont",
                                   pHostFontName, HFPOSTFIX, HFCIDCDEVPROC, pHostFontName);
                    else
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "[/%s%s] composefont pop", pHostFontName, HFPOSTFIX);
                }
                else
                {
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s%s %s /%s hfMkCIDFont",
                               pHostFontName, HFPOSTFIX,
                               (pUFObj->lDownloadFormat == kCFFCID_H) ? "h" : "v",
                               HFCIDCDEVPROC, pHostFontName);
                }
            }

            if (kNoErr == retCode)
                retCode = StrmPutStringEOL(stream, strmbuf);

            /*
             * Special for Quark
             */
            if ((kNoErr == retCode) && pUFObj->bPatchQXPCFFCID)
            {
                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%sQ", pUFObj->pszFontName);
                retCode = StrmPutString(stream, strmbuf);

                if (pUFObj->lDownloadFormat == kCFFCID_H)
                {
                    if (!HOSTFONT_IS_VALID_UFO(pUFObj))
                    {
                        /* Reuse vifinfo.nPlatformID to fix #507985. */
                        if (pUFObj->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-H [/%s%s] composefont pop",
                                       CFFPREFIX_H, pFont->info.baseName);
                        else
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-H [/%s%s] composefont pop",
                                       CFFPREFIX, pFont->info.baseName);
                    }
                    else if (!bRequire_vmtx)
                    {
                        UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-H [/%s] composefont pop",
                                   pHostFontName);
                    }
                    else
                    {
                        if (UFL_CIDFONT_SHARED)
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-H [/%s%s] composefont pop",
                                       pHostFontName, HFPOSTFIX);
                        else
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-H [/%s%s%s] composefont pop",
                                       pHostFontName, HFPOSTFIX, "h");
                    }

                }
                else
                {
                    /* Added 'dup dup' for bug 346287. */
                    if (!HOSTFONT_IS_VALID_UFO(pUFObj))
                    {
                        /* Reuse vifinfo.nPlatformID to fix #507985. */
                        if (pUFObj->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-QV [/%s%s dup dup] composefont pop",
                                       CFFPREFIX_V, pFont->info.baseName);
                        else
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-QV [/%s%s dup dup] composefont pop",
                                       CFFPREFIX, pFont->info.baseName);
                    }
                    else if (!bRequire_vmtx)
                    {
                        UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-QV [/%s dup dup] composefont pop",
                                   pHostFontName);
                    }
                    else
                    {
                        if (UFL_CIDFONT_SHARED)
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-QV [/%s%s dup dup] composefont pop",
                                       pHostFontName, HFPOSTFIX);
                        else
                            UFLsprintf(strmbuf, CCHOF(strmbuf), " /90msp-RKSJ-QV [/%s%s%s dup dup] composefont pop",
                                       pHostFontName, HFPOSTFIX, "v");
                    }
                }

                if (kNoErr == retCode)
                    retCode = StrmPutStringEOL(stream, strmbuf);
            }
        }
    }
    else if ((kNoErr == retCode) && HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * Redefine the font using the already existing OpenType host font with
         * a unique name so that we can reencode its encoding vector freely. We
         * don't want empty CharStrings so that we give false to hfRedefFont.
         */
        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s false /%s hfRedefFont",
                    pUFObj->pszFontName, pHostFontName);
        if (kNoErr == retCode)
            retCode = StrmPutStringEOL(stream, strmbuf);
    }

    /*
     * Change the font state. (skip kFontHeaderDownloaded state.)
     */
    if (kNoErr == retCode)
        pUFObj->flState = kFontHasChars;

    return retCode;
}


UFLErrCode
CFFAddChars(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage
    )
{
    CFFFontStruct   *pFont  = (CFFFontStruct *)pUFObj->pAFont->hFont;
    UFLErrCode      retCode = kNoErr;

    /* Sanity checks */
    if (pUFObj->flState < kFontHeaderDownloaded)
        return kErrInvalidState;

    if ((pFont == nil) || (pFont->hFont == nil))
        return kErrInvalidHandle;

    /*
     * Download the glyphs.
     */
    if (!HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        enum XCF_Result status;

        status = XCF_DownloadFontIncr(pFont->hFont,
                                        pGlyphs->sCount,
                                        pGlyphs->pGlyphIndices,
                                        (pGlyphs->pCharIndex == 0)
                                        ? nil
                                        : (unsigned char PTR_PREFIX * PTR_PREFIX *)pGlyphs->ppGlyphNames,
                                        pVMUsage);

        if (XCF_Ok != status)
            retCode = kErrXCFCall;
    }

    /*
     * Change the font state.
     */
    if (kNoErr == retCode)
        pUFObj->flState = kFontHasChars;

    return retCode;
}


UFLErrCode
CFFUpdateMetrics2(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    char                *pHostFontName
    )
{
    UFLErrCode          retVal = kNoErr;
    CFFFontStruct       *pFont = (CFFFontStruct *)pUFObj->pAFont->hFont;
    UFLHANDLE           stream = pUFObj->pUFL->hOut;
    char                strmbuf[256];
    unsigned short      wIndex;
    UFLBool             bRequire_vmtx = pUFObj->pAFont->hasvmtx && HOSTFONT_REQUIRE_VMTX;

    if ((!HOSTFONT_IS_VALID_UFO(pUFObj) || bRequire_vmtx) && (pGlyphs->sCount > 0))
    {
        UFLGlyphID      *glyphs = pGlyphs->pGlyphIndices;
        unsigned short  i;
        unsigned short  *pCIDs = (unsigned short*)UFLNewPtr(pUFObj->pMem, pGlyphs->sCount * sizeof (unsigned short));

        if (pCIDs)
            retVal = CFFGIDsToCIDs(pFont, pGlyphs->sCount, glyphs, pCIDs);
        else
            retVal = kErrOutOfMemory;

        if (kNoErr != retVal)
        {
            if (pCIDs)
                UFLDeletePtr(pUFObj->pMem, pCIDs);
            return retVal;
        }

        /*
         * Check pUFObj->pAFont->pCodeGlyphs to see if we really need to update
         * it.
         */
        for (i = 0; i < (unsigned short) pGlyphs->sCount; i++)
        {
            unsigned short wIndex = (unsigned short)(glyphs[i] & 0x0000FFFF); /* LOWord is the real GID. */

            if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
                continue;

            if (!IS_GLYPH_SENT(pUFObj->pAFont->pDownloadedGlyphs, wIndex))
            {
                long    em, w1y, vx, vy, tsb, vasc;
                UFLBool bUseDef;

                GetMetrics2FromTTF(pUFObj, wIndex, &em, &w1y, &vx, &vy, &tsb, &bUseDef, 0, &vasc);

                UFLsprintf(strmbuf, CCHOF(strmbuf), "%ld [0 %ld %ld %ld] ", (long)pCIDs[i], -w1y, vx, tsb);
                retVal = StrmPutString(stream, strmbuf);

                if (!HOSTFONT_IS_VALID_UFO(pUFObj))
                {
                    /* Reuse vifinfo.nPlatformID to fix #507985. */
                    if (pUFObj->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
                    {
                        if (pUFObj->lDownloadFormat == kCFFCID_H)
                            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s T0AddCFFMtx2", CFFPREFIX_H, pFont->info.baseName);
                        else
                            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s T0AddCFFMtx2", CFFPREFIX_V, pFont->info.baseName);
                    }
                    else
                        UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s%s T0AddCFFMtx2", CFFPREFIX, pFont->info.baseName);
                }
                else
                {
                    if (UFL_CIDFONT_SHARED)
                        UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s%s T0AddCFFMtx2", pHostFontName, HFPOSTFIX);
                    else
                        UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s%s%s T0AddCFFMtx2",
                                   pHostFontName, HFPOSTFIX,
                                   (pUFObj->lDownloadFormat == kCFFCID_H) ? "h" : "v");
                }

                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);

                if (kNoErr == retVal)
                    SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pDownloadedGlyphs, wIndex);
             }
        }

        UFLDeletePtr(pUFObj->pMem, pCIDs);
    }

    return retVal;
}


UFLErrCode
CFFReencode(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    char                *pHostFontName
    )
{
    CFFFontStruct   *pFont  = (CFFFontStruct *)pUFObj->pAFont->hFont;
    UFLErrCode      retCode = kNoErr;

    /* Sanity checks */
    if (pUFObj->flState < kFontHeaderDownloaded)
        return kErrInvalidState;

    if ((pFont == nil) || (pFont->hFont == nil))
        return kErrInvalidHandle;

    /*
     * Reencode the encoding vector and define good glyph names.
     */
    if (kNoErr == retCode)
    {
        if (pFont->info.usePSName)
        {
            if (pGlyphs->pCharIndex == 0)
                retCode = CFFUpdateEncodingVector1(
                            (UFOStruct *)pUFObj,
                            pGlyphs,
                            pGlyphs->sCount,
                            pGlyphs->pGlyphIndices);
            else
                retCode = CFFUpdateEncodingVector(
                            (UFOStruct *)pUFObj,
                            pGlyphs->sCount,
                            pGlyphs->pGlyphIndices,
                            pGlyphs->pCharIndex);
        }

        /*
         * Adobe Bug #366539 and #388111: Download Metrics2 for vertical writing
         *
         * Note: to remember the glyphs downloaded for Metrics2 we use
         * pUFObj->pAFont->pDownloadedGlyphs. There is another bitmap data,
         * pUFObj->pAFont->pCodeGlyphs, to remember the glyphs downloaded
         * for GoodGlyphName. They must be used independently. Do not use
         * pDownloadedGlyphs for GoodGlyphName and pCodeGlyphs for Metrics2.
         */
        if ((kNoErr == retCode) && IS_CFFCID(pUFObj->lDownloadFormat))
        {
            retCode = CFFUpdateMetrics2(pUFObj, pGlyphs, pHostFontName);
        }

        /*
         * GOODNAME
         */
        if ((kNoErr == retCode)
            && (pGlyphs->sCount > 0)
            && (pUFObj->dwFlags & UFO_HasG2UDict)
            && (IS_CFFCID(pUFObj->lDownloadFormat))
            && !(pUFObj->pAFont->knownROS))
        {
            UFLGlyphID      *glyphs = pGlyphs->pGlyphIndices;
            unsigned short  i;

            /*
             * Check pUFObj->pAFont->pCodeGlyphs to see if we really need to
             * update it.
             */
            for (i = 0; i < (unsigned short) pGlyphs->sCount; i++)
            {
                unsigned short wIndex = (unsigned short)(glyphs[i] & 0x0000FFFF); /* LOWord is the real GID. */

                if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
                    continue;

                if (!IS_GLYPH_SENT(pUFObj->pAFont->pCodeGlyphs, wIndex))
                {
                    /*
                     * Found at least one not updated. Do it (once) for all.
                     */
                    retCode = UpdateCodeInfo(pUFObj, pGlyphs, 0);
                    break;
                }
            }
        }
    }

    return retCode;
}


UFLErrCode
CFFFontDownloadIncr(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    )
{
    CFFFontStruct   *pFont          = (CFFFontStruct *)pUFObj->pAFont->hFont;
    UFLErrCode      retCode         = kNoErr;
    char            *pHostFontName  = nil;

    if (pFCUsage)
        *pFCUsage = 0;

    /*
     * Sanity checks.
     */
    if ((pGlyphs == nil) || (pGlyphs->pGlyphIndices == nil) || (pGlyphs->sCount == 0))
        return kErrInvalidParam;

    /*
     * No need to download if the full font has already been downloaded.
     */
    if (pUFObj->flState == kFontFullDownloaded)
        return kNoErr;

    /*
     * Check %hostfont% status prior to download anything.
     */
    HostFontValidateUFO(pUFObj, &pHostFontName);

    if (pUFObj->flState == kFontInit)
    {
        /*
         * Create a base font (and the glyphs) if it has not been done yet.
         */
        retCode = CFFCreateBaseFont(pUFObj, pGlyphs, pVMUsage, pHostFontName);

        if (kNoErr == retCode)
            retCode = CFFReencode(pUFObj, pGlyphs, pVMUsage, pHostFontName);
    }
    else
    {
        /*
         * Download the glyphs.
         */
        retCode = CFFAddChars(pUFObj, pGlyphs, pVMUsage);

        if (kNoErr == retCode)
            retCode = CFFReencode(pUFObj, pGlyphs, pVMUsage, pHostFontName);
    }

    return retCode;
}


UFLErrCode
CFFVMNeeded(
    const UFOStruct     *pUFO,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    )
{
    CFFFontStruct   *pFont = (CFFFontStruct *)pUFO->pAFont->hFont;
    enum XCF_Result status;
    unsigned short  cDLGlyphs;

    if (pVMNeeded)
        *pVMNeeded = 0;

    if (pFCNeeded)
        *pFCNeeded = 0;

    if ((pFont == nil) || (pFont->hFont == nil))
        return kErrInvalidHandle;

    status = XCF_CountDownloadGlyphs(pFont->hFont,
                                        pGlyphs->sCount,
                                        (XCFGlyphID *)pGlyphs->pGlyphIndices,
                                        &cDLGlyphs);

    if (XCF_Ok != status)
        return kErrUnknown;

    if (!HOSTFONT_IS_VALID_UFO(pUFO))
    {
        if (pVMNeeded)
            *pVMNeeded = cDLGlyphs * kVMTTT1Char;

        if (pUFO->flState == kFontInit)
        {
            if (pVMNeeded)
                *pVMNeeded += kVMTTT1Header;
        }
    }
    else
    {
        unsigned long tblSize = GETTTFONTDATA(pUFO,
                                              VMTX_TABLE, 0L,
                                              nil, 0L,
                                              pFont->info.fData.fontIndex);

        if (tblSize && HOSTFONT_REQUIRE_VMTX)
        {
            if (pVMNeeded)
                *pVMNeeded = cDLGlyphs * HFVMM2SZ;
        }
    }

    return kNoErr;
}


UFLErrCode
CFFUndefineFont(
    UFOStruct   *pUFO
    )
{
    CFFFontStruct *pFont = (CFFFontStruct *)pUFO->pAFont->hFont;
    UFLHANDLE     stream = pUFO->pUFL->hOut;
    UFLErrCode    retVal = kNoErr;
    char          strmbuf[256];

    if ((pFont == nil) || (pFont->hFont == nil))
        return kErrInvalidHandle;

    if (pUFO->flState == kFontInit)
        return retVal;

    if ((pUFO->lDownloadFormat == kCFFCID_H) || (pUFO->lDownloadFormat == kCFFCID_V))
    {
        /* Reuse vifinfo.nPlatformID to fix #507985. */
        if (pUFO->vpfinfo.nPlatformID == kUFLVPFPlatformID9x)
        {
            if (pUFO->lDownloadFormat == kCFFCID_H)
                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /CIDFont UDR", CFFPREFIX_H, pFont->info.baseName);
            else
                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /CIDFont UDR", CFFPREFIX_V, pFont->info.baseName);
        }
        else
            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /CIDFont UDR", CFFPREFIX, pFont->info.baseName);

        retVal = StrmPutStringEOL(stream, strmbuf);
    }

    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s UDF", pUFO->pszFontName);
    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, strmbuf);

    return retVal;
}


UFLErrCode
CFFGIDsToCIDs(
    const CFFFontStruct  *pFont,
    const short          cGlyphs,
    const UFLGlyphID     *pGIDs,
    unsigned short       *pCIDs
    )
{
    unsigned short int  *pCurCIDs = (unsigned short int *)pCIDs;
    UFLGlyphID          *pCurGIDs = (UFLGlyphID *)pGIDs;
    UFLErrCode          retCode   = kNoErr;
    enum XCF_Result     status;
    short               i;

    for (i = 0; i < cGlyphs; i++)
    {
        status = XCF_GlyphIDsToCIDs(pFont->hFont,
                                    1,
                                    (XCFGlyphID PTR_PREFIX *)pCurGIDs++, /* list of glyphIDs */
                                    pCurCIDs++);

        if (XCF_Ok != status)
        {
            retCode = kErrUnknown;
            break;
        }
    }

    return retCode;
}


UFOStruct *
CFFFontInit(
    const UFLMemObj  *pMem,
    const UFLStruct  *pUFL,
    const UFLRequest *pRequest,
    UFLBool          *pTestRestricted
    )
{
    enum XCF_Result  status  = XCF_InternalError;
    CFFFontStruct    *pFont  = nil;
    UFOStruct        *pUFObj = (UFOStruct*)UFLNewPtr(pMem, sizeof (UFOStruct));
    UFLCFFFontInfo   *pInfo;

    if (pUFObj == 0)
        return nil;

    /* Initialize data. */
    UFOInitData(pUFObj, UFO_CFF, pMem, pUFL, pRequest,
                (pfnUFODownloadIncr)  CFFFontDownloadIncr,
                (pfnUFOVMNeeded)      CFFVMNeeded,
                (pfnUFOUndefineFont)  CFFUndefineFont,
                (pfnUFOCleanUp)       CFFFontCleanUp,
                (pfnUFOCopy)          CopyFont);

    /*
     * pszFontName should be ready/allocated. If not, cannot continue.
     */
    if ((pUFObj->pszFontName == nil) || (pUFObj->pszFontName[0] == '\0'))
    {
        UFLDeletePtr(pMem, pUFObj);
        return nil;
    }

    pInfo = (UFLCFFFontInfo *)pRequest->hFontInfo;

    if (NewFont(pUFObj, sizeof(CFFFontStruct), pInfo->fData.maxGlyphs) == kNoErr)
    {
        pFont = (CFFFontStruct *)pUFObj->pAFont->hFont;

        pFont->info = *pInfo;

        pFont->pReadBuf = &pFont->info.readBuf;

        /* a convenient pointer */
        pUFObj->pFData = &(pFont->info.fData);

        pFont->info.fData.cNumGlyphs = GetNumGlyphs(pUFObj);

        if (pUFObj->pUpdatedEncoding == 0)
            pUFObj->pUpdatedEncoding = (unsigned char *)UFLNewPtr(pMem, GLYPH_SENT_BUFSIZE(256));

        pFont->hFont = 0;

        status = CFFInitFont(pUFObj, pFont);
    }

    if ((XCF_Ok != status) || (pFont == nil) || (pFont->hFont == 0))
    {
        vDeleteFont(pUFObj);
        UFLDeletePtr(pUFObj->pMem, pUFObj);
        return nil;
    }
    else
    {
        if (pTestRestricted)
        {
            unsigned char uc;
            unsigned short int us;

            XCF_SubsetRestrictions(pFont->hFont, &uc, &us);

            *pTestRestricted = (BOOL)uc;
        }
        else
            status = XCF_ProcessCFF(pFont->hFont);

        if (XCF_Ok == status)
            pUFObj->flState = kFontInit;
        else
        {
            vDeleteFont(pUFObj);
            UFLDeletePtr(pUFObj->pMem, pUFObj);
            return nil;
        }
    }

    return pUFObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\ufot42.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFOT42.c
 *
 *
 * $Header:
 */


/*===============================================================================*
 * Include files used by this interface                                          *
 *===============================================================================*/
#include "UFLPriv.h"
#include "UFOT42.h"
#include "UFLMem.h"
#include "UFLMath.h"
#include "UFLStd.h"
#include "UFLErr.h"
#include "UFLPS.h"
#include "ParseTT.h"
#include "UFLVm.h"
#include "ttformat.h"


/*
 * Private function prototypes
 */
UFLErrCode
T42VMNeeded(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    );

UFLErrCode
T42FontDownloadIncr(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    );

UFLErrCode
T42UndefineFont(
    UFOStruct           *pUFObj
    );

UFLErrCode
DefaultGetRotatedGIDs(
    UFOStruct           *pUFObj,
    T42FontStruct       *pFont,
    UFLFontProcs        *pFontProcs
    );

static unsigned long
GetLenByScanLoca(
    void PTR_PREFIX     *locationTable,
    unsigned short      wGlyfIndex,
    unsigned long       cNumGlyphs,
    int                 iLongFormat
    );


/*=============================================================================

                         TrueType Table Description

    cmap - This table defines the mapping of character codes to the glyph index
           values used in the font. It may contain more than one subtable, in
           order to support more than one character encoding scheme. Character
           codes that do not correspond to any glyph in the font should be
           mapped to glyph index 0. The glyph at this location must be a
           special glyph representing a missing character.

    cvt - This table contains a list of values that can be referenced by
          instructions. They can be used, among other things, to control
          characteristics for different glyphs.

    fpgm - This table is similar to the CVT Program, except that it is only run
           once, when the font is first used. It is used only for FDEFs and
           IDEFs. Thus the CVT Program need not contain function definitions.
           However, the CVT Program may redefine existing FDEFs or IDEFs.
           FDEFS - Functional defs.  IDEFs - Intruction defs.

    glyf - This table contains information that describes the glyphs in the font.

    head - This table gives global information about the font.
            Table version number 0x00010000 for version 1.0.
            FIXED           fontRevision        Set by font manufacturer.
            ULONG           checkSumAdjustment  To compute:  set it to 0, sum
                                                the entire font as ULONG, then
                                                store 0xB1B0AFBA - sum.
            ULONG           magicNumber         Set to 0x5F0F3CF5.
            USHORT          flags               Bit 0 - baseline for font at y=0
                                                Bit 1 - left sidebearing at x=0
                                                Bit 2 - instructions may depend
                                                        on point size
                                                Bit 3 - force ppem to integer
                                                        values for all internal
                                                        scaler math; may use
                                                        fractional ppem sizes
                                                        if this bit is clear
            USHORT          unitsPerEm          Valid range is from 16 to 16384
            longDateTime    created             International date (8-byte field).
            longDateTime    modified            International date (8-byte field).
            FWORD           xMin                For all glyph bounding boxes.
            FWORD           yMin                For all glyph bounding boxes.
            FWORD           xMax                For all glyph bounding boxes.
            FWORD           yMax                For all glyph bounding boxes.
            USHORT          macStyle            Bit 0 bold (if set to 1)
                                                Bit 1 italic (if set to 1)
                                                Bits 2-15 reserved (set to 0).
            USHORT          lowestRecPPEM       Smallest readable size in pixels.
            SHORT           fontDirectionHint   0  Fully mixed directional glyphs
                                                1  Only strongly left to right
                                                2  Like 1 but also contains neutrals1
                                                -1 Only strongly right to left
                                                -2 Like -1 but also contains neutrals.
            SHORT           indexToLocFormat    0 for short offsets, 1 for long.
            SHORT           glyphDataFormat     0 for current format.

    hhea - This table contains information for horizontal layout.
            Type    Name                    Description
            FIXED   Table version number    0x00010000 for version 1.0.
            FWORD   Ascender                Typographic ascent.
            FWORD   Descender               Typographic descent.
            FWORD   LineGap                 Typographic line gap. Negative
                                            LineGap values are treated as zero
                                            in Windows 3.1, System 6, and System 7.
            UFWORD  advanceWidthMax         Maximum advance width value in hmtx table.
            FWORD   minLeftSideBearing      Minimum left sidebearing value in hmtx table.
            FWORD   minRightSideBearing     Minimum right sidebearing value.
                                            Calculated as Min(aw - lsb - (xMax - xMin)).
            FWORD   xMaxExtent              Max(lsb + (xMax - xMin)).
            SHORT   caretSlopeRise          Used to calculate the slope of the
                                            cursor (rise/run); 1 for vertical.
            SHORT   caretSlopeRun           0 for vertical.
            SHORT   (reserved)              set to 0
            SHORT   (reserved)              set to 0
            SHORT   (reserved)              set to 0
            SHORT   (reserved)              set to 0
            SHORT   (reserved)              set to 0
            SHORT   metricDataFormat        0 for current format.
            USHORT  numberOfHMetrics        Number of hMetric entries in hmtx
                                            table; may be smaller than the total
                                            number of glyphs in the font.

    hmtx - Horizontal metrics

    loca - The indexToLoc table stores the offsets to the locations of the
           glyphs in the font, relative to the beginning of the glyphData
           table. In order to compute the length of the last glyph element,
           there is an extra entry after the last valid index. By definition,
           index zero points to the missing character, which is the character
           that appears if a character is not found in the font. The missing
           character is commonly represented by a blank box or a space. If the
           font does not contain an outline for the missing character, then the
           first and second offsets should have the same value. This also
           applies to any other character without an outline, such as the space
           character. Most routines will look at the 'maxp' table to determine
           the number of glyphs in the font, but the value in the loca table
           should agree. There are two versions of this table, the short and
           the long. The version is specified in the indexToLocFormat entry in
           the head' table.

    maxp - This table establishes the memory requirements for this font.
            Type    Name    Description
            Fixed   Table version number    0x00010000 for version 1.0.
            USHORT  numGlyphs               The number of glyphs in the font.
            USHORT  maxPoints               Maximum points in a non-composite glyph.
            USHORT  maxContours             Maximum contours in a non-composite glyph.
            USHORT  maxCompositePoints      Maximum points in a composite glyph.
            USHORT  maxCompositeContours    Maximum contours in a composite glyph.
            USHORT  maxZones                1 if instructions do not use the twilight zone (Z0)
                                            2 if instructions do use Z0
                                            This should be set to 2 in most cases.
            USHORT  maxTwilightPoints       Maximum points used in Z0.
            USHORT  maxStorage              Number of Storage Area locations.
            USHORT  maxFunctionDefs         Number of FDEFs.
            USHORT  maxInstructionDefs      Number of IDEFs.
            USHORT  maxStackElements        Maximum stack depth2.
            USHORT  maxSizeOfInstructions   Maximum byte count for glyph instructions.
            USHORT  maxComponentElements    Maximum number of components
                                            referenced at "top level" for any
                                            composite glyph.
            USHORT  maxComponentDepth       Maximum levels of recursion; 1 for
                                            simple components.

    prep - The Control Value Program consists of a set of TrueType instructions
           that will be executed whenever the font or point size or
           transformation matrix change and before each glyph is interpreted.
           Any instruction is legal in the CVT Program but since no glyph is
           associated with it, instructions intended to move points within a
           particular glyph outline cannot be used in the CVT Program. The name
           'prep' is anachronistic.

===============================================================================*/


static char *RequiredTables_default[MINIMALNUMBERTABLES] = {
    "cvt ",
    "fpgm",     /* This table is missing from many fonts. */
    "glyf",
    "head",
    "hhea",
    "hmtx",
    "loca",
    "maxp",
    "prep"
};

static char *RequiredTables_2015[MINIMALNUMBERTABLES] = {
    "cvt ",
    "fpgm",     /* This table is missing from many fonts. */
    "glyf",
    "head",
    "hhea",
    "hmtx",
//  "loca",     /* This huge table is Not needed on 2015 Pritners. */
    "maxp",
    "prep",

    /* This must be the last (dummy) entry. Don't add anything after this. */
    "zzzz"
};

char *gcidSuffix[NUM_CIDSUFFIX] = {
    "CID",
    "CIDR",
    "CID32K",
    "CID32KR"
};

static char* RDString = " RDS ";    /* Fix bug Adobe #233904 */


typedef struct {
    long  startU;
    long  endU;
    long  startL;
    long  endL;
} CODERANGE;

typedef struct {
   short          sMaxCount;    // Maximum number of glyphs
   short          sCount;       // Number of glyps we're holding
   unsigned short *pGlyphs;     // Pointer to array of glyph indices.
} COMPOSITEGLYPHS;


#if 1

static CODERANGE gHalfWidthChars[] = {
    {0x0020, 0x007E, 0x20, 0x7E},   /* CJK ASCII chars                                               */
    {0xFF60, 0xFF9F, 0x20, 0x5F},   /* 0x20 to 0x5F is made up to make the localcode range the size. */
    {0xFFA0, 0xFFDF, 0xA0, 0xDF},   /* HalfWidth J-Katakana and K-Hangul (see Unicode Book P.383)    */
    {0, 0, 0, 0}                    /* terminator                                                    */
    };

#else

/*
 * This could be more accurite than the one above. But we don't use this until
 * it becomes really necessary.
 */
static CODERANGE gHalfWidthChars[] = {
    {0x0020, 0x007E, 0x20, 0x7E},   /* ASCII (0x20-0x7E)                */
    {0xFF61, 0xFF9F, 0xA1, 0xDF},   /* Half-width Katakana (0xA1-0xDF)  */
    {0xFFA0, 0xFFDC, 0x40, 0x7C},   /* HalfWidth jamo (0x40-0x7C)       */
    {0, 0, 0, 0}                    /* terminator                       */
    };

#endif


#define  NUM_HALFWIDTHCHARS \
        ((short) (gHalfWidthChars[0].endL - gHalfWidthChars[0].startL + 1) + \
             (gHalfWidthChars[1].endL - gHalfWidthChars[1].startL + 1) + \
             (gHalfWidthChars[2].endL - gHalfWidthChars[2].startL + 1) + \
             (gHalfWidthChars[3].endL - gHalfWidthChars[3].startL + 1) + 1 )


/*
 * CIDSysInfo "(Adobe) (WinCharSetFFFF) 0" is registered for Win95 driver. Re-use it here.
 */
static UFLCMapInfo  CMapInfo_FF_H  = {"WinCharSetFFFF-H",  1, 0, "Adobe", "WinCharSetFFFF", 0};
static UFLCMapInfo  CMapInfo_FF_V  = {"WinCharSetFFFF-V",  1, 1, "Adobe", "WinCharSetFFFF", 0};
static UFLCMapInfo  CMapInfo_FF_H2 = {"WinCharSetFFFF-H2", 1, 0, "Adobe", "WinCharSetFFFF", 0};
static UFLCMapInfo  CMapInfo_FF_V2 = {"WinCharSetFFFF-V2", 1, 1, "Adobe", "WinCharSetFFFF", 0};

#define CIDSUFFIX       0
#define CIDSUFFIX_R     1
#define CIDSUFFIX_32K   2
#define CIDSUFFIX_32KR  3


/* Magic Baseline Numbers: */
#define TT_BASELINE_X  "0.15"
#define TT_BASELINE_Y  "0.85"


/*
 * Function implementations
 */

void
T42FontCleanUp(
    UFOStruct *pUFObj
    )
{
    T42FontStruct *pFont;

    if (pUFObj->pAFont == nil)
        return;

    pFont = (T42FontStruct *)pUFObj->pAFont->hFont;

    if (pFont == nil)
        return;

    if (pFont->pHeader != nil)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pHeader);
        pFont->pHeader = nil;
    }

    if (pFont->pMinSfnt != nil)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pMinSfnt);
        pFont->pMinSfnt = nil;
    }

    if (pFont->pStringLength != nil)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pStringLength);
        pFont->pStringLength = nil;
    }

    if (pFont->pLocaTable != nil)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pLocaTable);
        pFont->pLocaTable = nil;
    }

    if (pFont->pRotatedGlyphIDs != nil)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pRotatedGlyphIDs);
        pFont->pRotatedGlyphIDs = nil;
    }
}


unsigned long
GetFontTable(
    UFOStruct     *pUFObj,
    unsigned long tableName,
    unsigned char *pTable,
    unsigned long bufferSize    // Fixed bug 516514
    )
{
    T42FontStruct   *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long   tableSize;

    /* Get the size of the table. */
    tableSize = GETTTFONTDATA(pUFObj,
                                tableName, 0L,
                                nil, 0L,
                                pFont->info.fData.fontIndex);

    /* Read the table in. */
    if (pTable && tableSize)
    {
        // Fixed bug 516514. make sure the buffer is big enough
        if (tableSize > bufferSize)
            tableSize = bufferSize;

        tableSize = GETTTFONTDATA(pUFObj,
                                    tableName, 0L,
                                    pTable, tableSize,
                                    pFont->info.fData.fontIndex);

        /*
         * Special hack to fix #185003 and #308981
         * Avoid useless maxSizeOfInstructions check in TrueType rasterizer by
         * setting the highest value. maxSizeOfInstructions field in 'maxp'
         * table is at byte offset 26 and 27.
         */
        if (tableName == MAXP_TABLE)
            pTable[26] = pTable[27] = 0xff;
    }

    return tableSize;
}


void *
GetSfntTable(
     unsigned char *sfnt,
     unsigned long tableName
     )
{
    TableDirectoryStruct *pTableDirectory = (TableDirectoryStruct *)sfnt;
    TableEntryStruct     *pTableEntry     = (TableEntryStruct *)((char *)pTableDirectory
                                                + sizeof (TableDirectoryStruct));
    unsigned short i = 0;

    while (i < MOTOROLAINT(pTableDirectory->numTables))
    {
        if (pTableEntry->tag == tableName)
        {
            break;
        }
        else
        {
            pTableEntry = (TableEntryStruct *)((char *)pTableEntry + sizeof (TableEntryStruct));
            i++;
        }
    }

    if (i < MOTOROLAINT(pTableDirectory->numTables))
    {
        if (pTableEntry->offset)
            return (void *)(sfnt + MOTOROLALONG(pTableEntry->offset));
    }

    return nil;
}


unsigned long
GetTableSize(
    UFOStruct     *pUFObj,
    unsigned char *pHeader,
    unsigned long tableName
    )

/*++

Routine Description:
    This function returns the size of a table within this In-Memory-Version
    pHeader if it is present - If Not present, read-in from the orginal font
    header - we need this because 'loca' won't be in pHeader for CID/42, but
    we need its size!.

--*/

{
    TableDirectoryStruct *pTableDirectory = (TableDirectoryStruct *)pHeader;
    TableEntryStruct     *pTableEntry     = (TableEntryStruct *)((char *)pTableDirectory
                                                + sizeof (TableDirectoryStruct));
    T42FontStruct        *pFont           = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned short       i;

    for (i = 0; i < MOTOROLAINT(pTableDirectory->numTables); i++)
    {
        if (pTableEntry->tag == tableName)
            break;
        else
            pTableEntry = (TableEntryStruct *)((char *)pTableEntry + sizeof (TableEntryStruct));
    }

    //
    // 'loca' table can be 0 length in 'sfnts': just get it from the font.
    // Bug 229911 ang 9/12/97
    //
    if ((i < MOTOROLAINT(pTableDirectory->numTables))
        && ((unsigned long)MOTOROLALONG(pTableEntry->length) > 0))
    {
        return ((unsigned long)MOTOROLALONG(pTableEntry->length));
    }
    else
    {
        //
        // We don't have this table in pHeader. So find out the size from
        // orignal font file.
        //
        return GETTTFONTDATA(pUFObj,
                                tableName, 0L,
                                nil, 0L,
                                pFont->info.fData.fontIndex);
    }
}


unsigned long
GetGlyphTableSize(
    UFOStruct *pUFObj
    )
{
    T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;

    return GetTableSize(pUFObj, pFont->pHeader, GLYF_TABLE);
}


unsigned long
GetTableDirectory(
    UFOStruct            *pUFObj,
    TableDirectoryStruct *pTableDir
    )
{
    T42FontStruct  *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long  size   = sizeof (TableDirectoryStruct);

    if (pTableDir == 0)
        return size;  /* Return the size only. */

    /*
     * TTCHeader or TableDirectoryStruct starts from the beginning of the font
     * file.
     */
    size = GETTTFONTDATA(pUFObj,
                            nil, 0L,
                            pTableDir, sizeof (TableDirectoryStruct),
                            0);

    /*
     * Check if this is a TTC file - only uses first 4 bytes of pTableDIR.
     */
    if (BIsTTCFont(*((unsigned long *)((char *)pTableDir))))
    {
        /* Parse TTCHeader to get correct offsetToTableDir from fontIndex. */
        size = pFont->info.fData.offsetToTableDir
             = GetOffsetToTableDirInTTC(pUFObj, pFont->info.fData.fontIndex);

        if (size > 0)
        {
            /* Now get the correct TableDirectory from the TTC file. */
            size = GETTTFONTDATA(pUFObj,
                                    nil, pFont->info.fData.offsetToTableDir,
                                    pTableDir, sizeof (TableDirectoryStruct),
                                    pFont->info.fData.fontIndex);
        }
    }

    /*
     * Do some basic check - better fail than crash. NumTables must be
     * reasonable.
     */
    if ((MOTOROLAINT(pTableDir->numTables) < 3)
        || (MOTOROLAINT(pTableDir->numTables) > 50))
    {
        return 0;
    }

    return size;
}


unsigned long
GetTableEntry(
    UFOStruct            *pUFObj,
    TableEntryStruct     *pTableEntry,
    TableDirectoryStruct *pTableDir
    )
{
    T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long size;

    if (pTableDir == 0)
        return 0;  /* We need the TableDirectoryStruct to get the entry. */

    size = MOTOROLAINT(pTableDir->numTables) * sizeof (TableEntryStruct);

    if (pTableEntry == 0)
        return size;  /* Return the size only. */

    /* TableEntryStruct starts right after the TableDirectory. */
    size = GETTTFONTDATA(pUFObj,
                            nil, pFont->info.fData.offsetToTableDir + sizeof (TableDirectoryStruct),
                            pTableEntry, size,
                            pFont->info.fData.fontIndex);

    return size;
}


unsigned long
GetFontHeaderSize(
    UFOStruct *pUFObj
    )
{
    TableDirectoryStruct    tableDir;
    unsigned long           size;

    /* Need to fill in tableDir for GetTableEntry(). */
    size = GetTableDirectory(pUFObj, &tableDir);

    if (size != 0)
        size += GetTableEntry(pUFObj, 0, &tableDir);  /* Get size only. */

    return size;
}


UFLErrCode
GetFontHeader(
    UFOStruct     *pUFObj,
    unsigned char *pHeader
    )
{
    unsigned char*          tempHeader = pHeader;
    TableDirectoryStruct*   pTableDir  = (TableDirectoryStruct *)tempHeader;
    unsigned long           size       = GetTableDirectory(pUFObj, pTableDir);

    tempHeader += size;  /* Move past table directory. */

    size = GetTableEntry(pUFObj, (TableEntryStruct *)tempHeader, pTableDir);

    return kNoErr;
}


unsigned long
GetNumGlyphsInGlyphTable(
    UFOStruct *pUFO
    )
{
    unsigned long              dwSize;
    Type42HeaderStruct         headTable;
    short                      indexToLocFormat;
    unsigned long              numGlyphs, realNumGlyphs;
    unsigned long              locaSize;
    unsigned long PTR_PREFIX   *pLoca;
    unsigned long              i;

    /* Get numGlyphs - 4th and 5th byte in 'maxp' table. See MaxPTableStruct. */
    numGlyphs = GetNumGlyphs(pUFO);

    if (numGlyphs == 0)
        return 0; /* We don't understand this format. */

    /*
     * Get indexToLocFormat.
     * Because of unknown reason the compiler claims that the size of
     * Type42HeaderStruct (or its object) is 56 rather than 54 so that we
     * cannot get the contents of 'head' table by single GETTTFONTDATA call.
     * Instead, we call the function twice, once to get the size of 'head'
     * table and then to get its contents.
     */
    dwSize = GETTTFONTDATA(pUFO,
                            HEAD_TABLE, 0L,
                            nil, 0L,
                            pUFO->pFData->fontIndex);

    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0; /* No 'head' table. This should never happen. */

    // Fixed bug 516508. case 2
    if (dwSize > sizeof(Type42HeaderStruct))
        dwSize = sizeof(Type42HeaderStruct);

    dwSize = GETTTFONTDATA(pUFO,
                            HEAD_TABLE, 0L,
                            &headTable, dwSize,
                            pUFO->pFData->fontIndex);

    if ((dwSize == 0) || (dwSize == 0xFFFFFFFFL))
        return 0; /* Still something is wrong. */

    indexToLocFormat = MOTOROLAINT(headTable.indexToLocFormat);

    /*
     * Allocate a buffer to hold 'loca' table and read it into memory.
     */
    locaSize = (numGlyphs + 1) * (indexToLocFormat ? 4 : 2);

    pLoca = UFLNewPtr(pUFO->pMem, locaSize);

    if (pLoca)
    {
        dwSize = GETTTFONTDATA(pUFO,
                                LOCA_TABLE, 0L,
                                pLoca, locaSize,
                                pUFO->pFData->fontIndex);
    }
    else
        dwSize = 0;

    /*
     * Get real number of glyphs.
     */
    realNumGlyphs = 0;

    if (pLoca && (dwSize != 0) && (dwSize != 0xFFFFFFFFL))
    {
        /* Assume good until find otherwise. */

        if (indexToLocFormat)
        {
            unsigned long dwLoca, dwLocaNext;
            unsigned long PTR_PREFIX *pLongLoca;

            pLongLoca = (unsigned long PTR_PREFIX *)pLoca;

            for (i = 0; i < numGlyphs; i++)
            {
                dwLoca     = MOTOROLALONG(pLongLoca[i]);
                dwLocaNext = MOTOROLALONG(pLongLoca[i + 1]);

                /* Check for 0 and duplicate. */
                if ((dwLoca != 0) && (dwLoca != dwLocaNext))
                {
                    realNumGlyphs++;
                }
            }
        }
        else
        {
            unsigned short wLoca, wLocaNext;
            unsigned short PTR_PREFIX *pShortLoca;

            pShortLoca = (unsigned short PTR_PREFIX *)pLoca;

            for (i = 0; i < numGlyphs; i++)
            {
                wLoca     = MOTOROLAINT(pShortLoca[i]);
                wLocaNext = MOTOROLAINT(pShortLoca[i + 1]);

                /* Check for 0 and duplicate. */
                if ((wLoca != 0) && (wLoca != wLocaNext))
                {
                    realNumGlyphs++;
                }
            }
        }
   }

   if (pLoca)
        UFLDeletePtr(pUFO->pMem, pLoca);

   return realNumGlyphs;
}


void
GetAverageGlyphSize(
    UFOStruct     *pUFObj
    )
{
    T42FontStruct  *pFont        = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long  glyfTableSize = GetGlyphTableSize(pUFObj);
    unsigned long  cGlyphs;

    if (UFO_NUM_GLYPHS(pUFObj) == 0)
        pFont->info.fData.cNumGlyphs = GetNumGlyphs(pUFObj);

    cGlyphs = GetNumGlyphsInGlyphTable(pUFObj);

    if ((UFO_NUM_GLYPHS(pUFObj) != 0) && (cGlyphs != 0))
        pFont->averageGlyphSize = glyfTableSize / cGlyphs;
    else
        pFont->averageGlyphSize = 0;
}


#pragma optimize("", off)

//
// fix Whistler bug 251303: prevent overrun of the tablesPresent array
//
#define PRESENT_TABLE_ENTRIES MINIMALNUMBERTABLES+2

unsigned long
GenerateMinimalSfnt(
    UFOStruct*    pUFObj,
    char**        requiredTables,
    UFLBool       bFullFont
    )
{
    unsigned long           tablesPresent[PRESENT_TABLE_ENTRIES];
    UFLBool                 hasloca;

    T42FontStruct           *pFont;
    TableDirectoryStruct    *pTableDir;
    TableEntryStruct        *pTableEntry;
    unsigned char huge      *pCurrentMinSfnt;

    unsigned short          currentTable, numberOfTables, numberOfRealTables;
    unsigned long           size;

    TableEntryStruct        *pGlyphTableEntry;
    unsigned char           *glyfData;

    TableEntryStruct        tableEntry;
    unsigned long           tableSize;

    unsigned short          i;


    //
    // Bug fix 229911: ang 9/12/97
    // Check if RequiredTables has 'loca'. If not, remember to add 0-length one
    // as the last entry.
    //
    hasloca = 0;

    for (i = 0; i < MINIMALNUMBERTABLES; i++)
    {
        if (UFLstrcmp(requiredTables[i],  "loca") == 0)
            hasloca = 1;

        tablesPresent[i] = (unsigned long)0xFFFFFFFF;
    }

    //
    // Initialize the additional entries
    //
    for (i = MINIMALNUMBERTABLES ; i < PRESENT_TABLE_ENTRIES ; i++)
    {
        tablesPresent[i] = (unsigned long)0xFFFFFFFF;
    }

    //
    // Set up the primary pointers.
    //
    pFont           = (T42FontStruct *)pUFObj->pAFont->hFont;
    pTableDir       = (TableDirectoryStruct *)pFont->pHeader;
    pTableEntry     = (TableEntryStruct *)((char *)(pFont->pHeader) + sizeof (TableDirectoryStruct));
    pCurrentMinSfnt = (unsigned char huge *)pFont->pMinSfnt;

    //
    // Determine how many tables are actually present in pHeader (not in the
    // original TTF!).
    //
    numberOfTables = 0;

    for (i = 0; i < MINIMALNUMBERTABLES; i++)
    {
        if (GetTableSize(pUFObj, pFont->pHeader, *(unsigned long *)(requiredTables[i])))
        {
            tablesPresent[numberOfTables] = *(unsigned long *)requiredTables[i];
            ++numberOfTables;
        }
    }

    //
    // Add extra entry if necessary.
    //
    if (!bFullFont)
        numberOfTables += 1;  // for 'gdir' table entry as the T42 indication

    if (!hasloca)
        numberOfTables += 1;  // for 0-length 'loca' table entry

    //
    // size will have the required size for the minimum 'sfnts' at the end.
    //
    size = sizeof (TableDirectoryStruct) + sizeof (TableEntryStruct) * numberOfTables;

    //
    // Initialize the table directory.
    //
    if (pFont->pMinSfnt)
    {
        TableDirectoryStruct    tableDir;
        unsigned long           dwVersion = 1;

        tableDir.version       = MOTOROLAINT(dwVersion);
        tableDir.numTables     =
        tableDir.searchRange   =
        tableDir.entrySelector =
        tableDir.rangeshift    =
        tableDir.numTables     = MOTOROLAINT(numberOfTables);

        UFLmemcpy((const UFLMemObj *)pUFObj->pMem,
                    pCurrentMinSfnt,
                    &tableDir,
                    sizeof (TableDirectoryStruct));

        pCurrentMinSfnt += sizeof (TableDirectoryStruct);
    }

    //
    // Initialize the table entries. Initialization of 'glyf' table entry will
    // be done later in order to make sure to put it at the end of the minimum
    // 'sfnts'.
    //
    // Note that we do linear search to find a table directory entry. This is
    // becasue some TT fonts don't have sorted table directory so that we can't
    // do binary search. (This is a fix for #310998.)
    //
    pGlyphTableEntry   = nil;
    glyfData           = nil;
    numberOfRealTables = MOTOROLAINT(pTableDir->numTables);

    for (currentTable = 0; currentTable < numberOfTables; currentTable++)
    {
        TableEntryStruct *pEntry = pTableEntry;

        for (i = 0; i < numberOfRealTables; i++)
        {
            if (tablesPresent[currentTable] == pEntry->tag)
            {
                if (pFont->pMinSfnt)
                {
                    if (pEntry->tag == GLYF_TABLE)
                    {
                        glyfData = pCurrentMinSfnt;
                    }
                    else
                    {
                        tableEntry.tag      = pEntry->tag;
                        tableEntry.checkSum = pEntry->checkSum;
                        tableEntry.offset   = MOTOROLALONG(size);
                        tableEntry.length   = pEntry->length;

                        UFLmemcpy((const UFLMemObj *)pUFObj->pMem,
                                    pCurrentMinSfnt,
                                    &tableEntry,
                                    sizeof (TableEntryStruct));
                    }

                    pCurrentMinSfnt += sizeof (TableEntryStruct);
                }

                if (pEntry->tag == GLYF_TABLE)
                {
                    pGlyphTableEntry = pEntry;
                }
                else
                {
                    tableSize  = MOTOROLALONG(pEntry->length);
                    size      += BUMP4BYTE(tableSize);
                }

                break;
            }

            pEntry = (TableEntryStruct *)((char *)pEntry + sizeof (TableEntryStruct));
        }
    }

    //
    // Update 'glyf' table entry lastly.
    //
    if (glyfData && pGlyphTableEntry && pFont->pMinSfnt)
    {
        tableEntry.tag      = pGlyphTableEntry->tag;
        tableEntry.checkSum = pGlyphTableEntry->checkSum;
        tableEntry.offset   = MOTOROLALONG(size);
        tableEntry.length   = pGlyphTableEntry->length;

        UFLmemcpy((const UFLMemObj *)pUFObj->pMem,
                    glyfData,
                    &tableEntry,
                    sizeof (TableEntryStruct));
    }

    if (pGlyphTableEntry && bFullFont)
    {
        tableSize = MOTOROLALONG(pGlyphTableEntry->length);
        size += BUMP4BYTE(tableSize);
    }

    //
    // Special 'gdir' and 'loca' table entry handling.
    //
    if (!bFullFont && pFont->pMinSfnt)
    {
        tableEntry.tag      = *(unsigned long *)"gdir";
        tableEntry.checkSum = 0;
        tableEntry.offset   = 0;
        tableEntry.length   = 0;

        UFLmemcpy((const UFLMemObj *)pUFObj->pMem,
                    pCurrentMinSfnt,
                    &tableEntry,
                    (long)sizeof (TableEntryStruct));

        pCurrentMinSfnt += sizeof (TableEntryStruct);
    }

    if (!hasloca && pFont->pMinSfnt)
    {
        tableEntry.tag      = LOCA_TABLE;
        tableEntry.checkSum = 0;
        tableEntry.offset   = 0;
        tableEntry.length   = 0;

        UFLmemcpy((const UFLMemObj *)pUFObj->pMem,
                    pCurrentMinSfnt,
                    &tableEntry,
                    (long)sizeof (TableEntryStruct));

        pCurrentMinSfnt += sizeof (TableEntryStruct);
    }

    //
    // Copy the required tables after the entries.
    //
    if (pFont->pMinSfnt)
    {
        unsigned long bytesRemaining;

        pTableEntry = (TableEntryStruct *)((char *)pFont->pMinSfnt + sizeof (TableDirectoryStruct));

        if (!bFullFont)
            --numberOfTables; // Because there is no 'gdir' table.

        if (!hasloca)
            --numberOfTables; // Because we treat 'loca' table as 0-length.

        for (i = 0; i < (unsigned short)numberOfTables; i++)
        {
            if (tablesPresent[i] != GLYF_TABLE)
            {
                bytesRemaining = MOTOROLALONG(pTableEntry->length);
                bytesRemaining = BUMP4BYTE(bytesRemaining);

                // Fixed bug 516514
                GetFontTable(pUFObj, tablesPresent[i], pCurrentMinSfnt, bytesRemaining);

                pCurrentMinSfnt += bytesRemaining;
            }

            pTableEntry = (TableEntryStruct *)((char *)pTableEntry + sizeof (TableEntryStruct));
        }

        //
        // Copy 'glyf' table lastly.
        //
        if (bFullFont)
        {
            bytesRemaining = MOTOROLALONG(pGlyphTableEntry->length);
            bytesRemaining = BUMP4BYTE(bytesRemaining);

            // Fixed bug 516514
            GetFontTable(pUFObj, GLYF_TABLE, pCurrentMinSfnt, bytesRemaining);
        }
    }

    return size;
}

#pragma optimize("", on)


UFLErrCode
GetMinSfnt(
    UFOStruct     *pUFObj,
    UFLBool       bFullFont
    )
{
    T42FontStruct   *pFont           = (T42FontStruct *)pUFObj->pAFont->hFont;
    char            **requiredTables = RequiredTables_default;
    UFLErrCode      retVal           = kNoErr;

    //
    // IF CID Type 42, then we are sure we can omit the huge 'loca' table
    // because Send-TT-as-CID/Type42 is only supported on 2015 or above
    // printers.
    //
    if (IS_TYPE42CID(pUFObj->lDownloadFormat))
    {
        requiredTables = RequiredTables_2015;
    }

    if (pFont->pMinSfnt == 0)
    {
        unsigned long  headerSize, sfntSize;

        /* Get the size of the portion of the Type font we need. */
        headerSize = GetFontHeaderSize(pUFObj);

        if (headerSize == 0)
            return kErrOutOfMemory; /* Some thing wrong when getting header. */

        if ((pFont->pHeader = (unsigned char *)UFLNewPtr(pUFObj->pMem, headerSize)) == nil)
            return kErrOutOfMemory;

        GetFontHeader(pUFObj, pFont->pHeader);

        /* Calculate minimal /sfnts size for Incr or full download. */
        sfntSize = GenerateMinimalSfnt(pUFObj, requiredTables, bFullFont);

        if ((pFont->pMinSfnt = (unsigned char *)UFLNewPtr(pUFObj->pMem, sfntSize)) == nil)
        {
            UFLDeletePtr(pUFObj->pMem, pFont->pHeader);
            pFont->pHeader = nil;

            return kErrOutOfMemory;
        }

        /* Creates our sfnt - minSfnt. We then work on this minSfnt. */
        GenerateMinimalSfnt(pUFObj, requiredTables, bFullFont);

        if (retVal == kNoErr)
            pFont->minSfntSize = sfntSize;
    }

    return retVal;
}


unsigned long
GetNextLowestOffset(
    TableEntryStruct *pTableEntry,
    TableEntryStruct **ppCurrentTable,
    short            numTables,
    unsigned long    leastOffset
    )
{
    unsigned long lowestFound = 0xFFFFFFFFL;
    short i;

    for (i = 0; i < numTables; ++i)
    {
        if (((unsigned long)MOTOROLALONG(pTableEntry->offset) > leastOffset)
            && ((unsigned long)MOTOROLALONG(pTableEntry->offset) < lowestFound))
        {
            lowestFound = (unsigned long)MOTOROLALONG(pTableEntry->offset);
            *ppCurrentTable = pTableEntry;
        }

        pTableEntry = (TableEntryStruct *)((char *)pTableEntry + sizeof (TableEntryStruct));
    }

    return lowestFound;
}


unsigned long
GetBestGlyfBreak(
    UFOStruct     *pUFObj,
    unsigned char *sfnt,
    unsigned long upperLimit,
    UFLBool       longGlyfs
    )
{
    unsigned long  retVal       = 0xFFFFFFFFL;
    unsigned long  dwGlyphStart = 0xFFFFFFFFL;
    unsigned long  dwTableSize;
    unsigned short numGlyphs;
    unsigned short i;

    /* Get the size of loca table. */
    dwTableSize = GetTableSize(pUFObj, sfnt, LOCA_TABLE);

    if (0 == dwTableSize)
        return retVal;

    if (longGlyfs)
    {
        unsigned long PTR_PREFIX *locationTable =
                    (unsigned long PTR_PREFIX *)GetSfntTable(sfnt, LOCA_TABLE);

        if (locationTable)
        {
            numGlyphs = (unsigned short)(dwTableSize / sizeof (unsigned long));

            for (i = 0; i < numGlyphs; i++)
            {
                if (MOTOROLALONG(*locationTable) > upperLimit)
                {
                    retVal = dwGlyphStart ;
                    break;
                }
                else
                {
                    if ((MOTOROLALONG(*locationTable) & 0x03L) == 0)
                    {
                        /* Remember "good" guy. */
                        dwGlyphStart = MOTOROLALONG(*locationTable);
                    }
                    locationTable++;
                }
            }
        }
    }
    else
    {
        short PTR_PREFIX* locationTable =
                    (short PTR_PREFIX*)GetSfntTable(sfnt, LOCA_TABLE);

        if (locationTable)
        {
            numGlyphs = (unsigned short)(dwTableSize / sizeof (unsigned short));
            upperLimit /= 2;

            for (i = 0; i  < numGlyphs; i++)
            {
                if ((unsigned long)(MOTOROLAINT(*locationTable)) >= upperLimit)
                {
                    retVal = dwGlyphStart;
                    break;
                }
                else
                {
                    if ((MOTOROLAINT(*locationTable) & 0x01) == 0)
                    {
                        /* Remember "good" guy. */
                        dwGlyphStart =
                            (unsigned long)(2L * (unsigned short)MOTOROLAINT(*locationTable));
                    }
                    locationTable++;
                }
            }
        }
    }

    return retVal;
}


UFLErrCode
CalculateStringLength(
    UFOStruct     *pUFObj,
    T42FontStruct *pFont,
    unsigned long  tableSize
    )
{
    unsigned long *stringLength    = pFont->pStringLength;
    unsigned long *maxStringLength = stringLength + tableSize;

    if (pFont->minSfntSize >= THIRTYTWOK)
    {
        unsigned long glyphTableStart   = 0L;
        unsigned long nextOffset        = 0L; /* Offset for the current point       */
        unsigned long prevOffset        = 0L; /* Offset for the previous breakpoint */

        TableEntryStruct     *pTableEntry = (TableEntryStruct *)(pFont->pMinSfnt + sizeof (TableDirectoryStruct));
        TableDirectoryStruct *pTableDir   = (TableDirectoryStruct *)pFont->pMinSfnt;
        TableEntryStruct     *pCurrentTable;

        do
        {
            nextOffset = GetNextLowestOffset(pTableEntry,
                                                &pCurrentTable,
                                                (short)MOTOROLAINT(pTableDir->numTables),
                                                nextOffset);

            if (nextOffset == (unsigned long)0xFFFFFFFF)
            {
                /* No more data. */
                break ;
            }

            if ((nextOffset + MOTOROLALONG(pCurrentTable->length) - prevOffset) > THIRTYTWOK)
            {
                /*
                 * Total size is more that 64K.
                 */

                unsigned long dwNewPoint; /* Offset from the beginning of glyph table */

                if (pCurrentTable->tag == GLYF_TABLE)
                {
                    // DCR -- to improve perfomance, don't need this for Incr downloading.

                    /*
                     * If we stopped just on 'glyf' table, get the break points
                     * to be inside the table but between two glyphs.
                     */
                    glyphTableStart = nextOffset;  /* Next segment starts here. */

                    dwNewPoint = 0L;

                    while (1)
                    {
                        dwNewPoint = GetBestGlyfBreak(pUFObj, pFont->pMinSfnt,
                                                        prevOffset + THIRTYTWOK - glyphTableStart,
                                                        (UFLBool)(pFont->headTable.indexToLocFormat ? 1 : 0));

                        if (dwNewPoint == 0xFFFFFFFF)
                        {
                            /* No next point. */
                            break;
                        }
                        else
                        {
                            nextOffset = glyphTableStart + dwNewPoint;
                            prevOffset = nextOffset;    /* New segment starts here. */

                            *stringLength = nextOffset; /* Save this breakpoint. */
                            stringLength++;             /* Next breakpoint goes there. */

                            if (stringLength >= maxStringLength)
                                return kErrOutOfBoundary;
                        }
                    }
                }
                else
                {
                    /* Save the break point at Table Boundry. */
                    prevOffset = nextOffset;    /* New segment starts here. */

                    *stringLength = nextOffset; /* Save this breakpoint. */
                    stringLength++;             /* Next breakpoint goes there. */

                    if (stringLength >= maxStringLength)
                        return kErrOutOfBoundary;

                    /*
                     * Break the single table at 64K boundry -- regardless
                     * what TT Spec says.
                     */

                    /* Tried on a 2016.102 printer. It works. 10-11-1995 */
                    glyphTableStart = nextOffset;  /* Next segment starts here */

                    dwNewPoint = 0L;

                    while (1)
                    {
                        /*
                         * We use 64K here becasue we only break a table when
                         * ABSOLUTELY necessary >64K.
                         */
                        dwNewPoint += SIXTYFOURK;

                        if (dwNewPoint > MOTOROLALONG(pCurrentTable->length))
                        {
                            /* No next point. */
                            break;
                        }
                        else
                        {
                            nextOffset = glyphTableStart + dwNewPoint;
                            prevOffset = nextOffset;    /* New segment starts here. */

                            *stringLength = nextOffset;
                            stringLength++;             /* Next breakpoint goes there. */

                            if (stringLength >= maxStringLength)
                                return kErrOutOfBoundary;
                        }
                    }
                }
            }
        } while (1);
    }

    *stringLength = pFont->minSfntSize + 1; /* Always close the breakpoints list. */
    stringLength++;

    if (stringLength >= maxStringLength)
        return kErrOutOfBoundary;

    *stringLength = 0; /* Always close the breakpoints list with 0!!! */

    return kNoErr;
}


UFLErrCode
FillInHeadTable(
    UFOStruct     *pUFObj
    )
{
    T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;

    // Fixed bug 516514
    if (GetFontTable(pUFObj, HEAD_TABLE, (unsigned char *)&pFont->headTable,
        sizeof(Type42HeaderStruct)) == 0)
        return kErrBadTable;
    // else
    //    return kNoErr;


    // WCC 5/14/98 convert all motorola bytes.
    pFont->headTable.tableVersionNumber = MOTOROLALONG(pFont->headTable.tableVersionNumber);
    pFont->headTable.fontRevision       = MOTOROLALONG(pFont->headTable.fontRevision);
    pFont->headTable.checkSumAdjustment = MOTOROLALONG(pFont->headTable.checkSumAdjustment);
    pFont->headTable.magicNumber        = MOTOROLALONG(pFont->headTable.magicNumber);
    pFont->headTable.flags              = MOTOROLAINT(pFont->headTable.flags);
    pFont->headTable.unitsPerEm         = MOTOROLAINT(pFont->headTable.unitsPerEm);

    // Need to convert timeCreated and timeModified.
    pFont->headTable.xMin               = MOTOROLAINT(pFont->headTable.xMin);
    pFont->headTable.yMin               = MOTOROLAINT(pFont->headTable.yMin);
    pFont->headTable.xMax               = MOTOROLAINT(pFont->headTable.xMax);
    pFont->headTable.yMax               = MOTOROLAINT(pFont->headTable.yMax);

    pFont->headTable.macStyle          = MOTOROLAINT(pFont->headTable.macStyle);
    pFont->headTable.lowestRecPPEM     = MOTOROLAINT(pFont->headTable.lowestRecPPEM);
    pFont->headTable.fontDirectionHint = MOTOROLAINT(pFont->headTable.fontDirectionHint);
    pFont->headTable.indexToLocFormat  = MOTOROLAINT(pFont->headTable.indexToLocFormat);
    pFont->headTable.glyfDataFormat    = MOTOROLAINT(pFont->headTable.glyfDataFormat);

    return kNoErr;
}


short
PSSendSfntsBinary(
    UFOStruct   *pUFObj
    )
{
    T42FontStruct   *pFont      = (T42FontStruct *)pUFObj->pAFont->hFont;
    char huge       *glyphs     = (char huge *)pFont->pMinSfnt;
    unsigned long   minSfntSize = pFont->minSfntSize;
    unsigned long   *breakHere  = pFont->pStringLength;
    unsigned long   dwLen       = *breakHere;
    UFLHANDLE       stream      = pUFObj->pUFL->hOut;
    short           nSubStr     = 1;
    short           i           = 0;

    if (dwLen > minSfntSize)
    {
        /* There's only 1 string. */
        dwLen--;

        StrmPutInt(stream,      dwLen + 1);
        StrmPutString(stream,   RDString);
        StrmPutBytes(stream,    glyphs, (UFLsize_t)dwLen, 0);
        StrmPutString(stream,   "0");

        return nSubStr;  /* It is 1 -- only one string. */
    }

    StrmPutInt(stream,      dwLen + 1);
    StrmPutString(stream,   RDString);
    StrmPutBytes(stream,    glyphs, (UFLsize_t)dwLen, 0);
    StrmPutString(stream,   "0");

    glyphs = glyphs + dwLen;

    while (breakHere[i] <= minSfntSize)
    {
        dwLen = breakHere[i + 1] - breakHere[i];

        if (breakHere[i + 1] > minSfntSize)
            dwLen--;

        StrmPutInt(stream,          dwLen + 1);
        StrmPutString(stream,       RDString);
        StrmPutBytes(stream,        glyphs, (UFLsize_t)dwLen, 0);
        StrmPutStringEOL(stream,    "0");

        glyphs = glyphs+dwLen;

        i++;
        nSubStr++;
    }

    return nSubStr;
}


short
PSSendSfntsAsciiHex(
    UFOStruct   *pUFObj
    )
{
    T42FontStruct   *pFont      = (T42FontStruct *)pUFObj->pAFont->hFont;
    char huge       *glyphs     = (char huge *)pFont->pMinSfnt;
    unsigned long   minSfntSize = pFont->minSfntSize;
    unsigned long   *breakHere  = pFont->pStringLength;
    unsigned long   dwBreak     = *breakHere - 1;
    UFLHANDLE       stream      = pUFObj->pUFL->hOut;
    short           bytesSent   = 1;
    short           nSubStr     = 1;
    unsigned long   i;

    StrmPutString(stream, "<");

    for (i = 0; i < minSfntSize; i++)
    {
        StrmPutAsciiHex(stream, glyphs, 1);

        ++glyphs;
        ++bytesSent;

        if (i == dwBreak)
        {
            if (dwBreak != minSfntSize)
            {
                StrmPutStringEOL(stream, "00>");

                bytesSent = 1;
                StrmPutString(stream, "<");
            }

            dwBreak = *(++breakHere) - 1 ;
            nSubStr++;
        }

        /*
         * We already have a control (stream->Out->AddEOL) when to add a EOL.
         *
         * if (!(bytesSent % 40))
         * {
         *   StrmPutStringEOL(stream, nilStr);
         *   bytesSent = 1;
         * }
         */
    }

    StrmPutString(stream, "00>");

    return nSubStr;
}


UFLErrCode
CalcBestGlyfTableBreaks(
    UFOStruct     *pUFObj,
    unsigned long upperLimit,
    unsigned long tableSize
    )
{
    T42FontStruct  *pFont           = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long  *stringLength    = pFont->pStringLength;
    unsigned long  *maxStringLength = stringLength + tableSize;

    unsigned long  prevOffset       = 0L;          /* Offset for the previous breakpoint */
    unsigned long  nextOffset       = 0xFFFFFFFFL; /* Offset for the current point       */

    unsigned long  glyfTableSize    = GetTableSize(pUFObj, pFont->pHeader, GLYF_TABLE);
    unsigned long  locaTableSize    = GetTableSize(pUFObj, pFont->pHeader, LOCA_TABLE);

    *stringLength = 0L;     /* Start with offset 0. */
    stringLength++;

    if (glyfTableSize > upperLimit)
    {
        unsigned short numGlyphs;
        unsigned short i; /* 'loca' table entries counter */

        if (pFont->headTable.indexToLocFormat)
        {
            /* long offsets */
            unsigned long PTR_PREFIX *locationTable = (unsigned long PTR_PREFIX *)pFont->pLocaTable;

            numGlyphs = (unsigned short)(locaTableSize / sizeof (unsigned long));

            for (i = 0; i < numGlyphs; i++)
            {
                unsigned long dwTmp = MOTOROLALONG(*locationTable);

                if ((dwTmp > (prevOffset + upperLimit))
                        && (nextOffset != prevOffset))
                {
                    *stringLength = nextOffset;
                    stringLength++;

                    if (stringLength >= maxStringLength)
                        return kErrOutOfBoundary;

                    prevOffset = nextOffset;
                }
                else
                {
                    if ((dwTmp & 0x03L) ==  0)
                        nextOffset = dwTmp;

                    locationTable++;
                }
            }
        }
        else
        {
            unsigned short PTR_PREFIX *locationTable = (unsigned short PTR_PREFIX *)pFont->pLocaTable;

            numGlyphs = (unsigned short)(locaTableSize / sizeof (unsigned short));

            for (i = 0; i < numGlyphs; i++)
            {
                unsigned short iTmp = MOTOROLAINT(*locationTable);

                if (((2L * (unsigned long)iTmp) > (prevOffset + upperLimit))
                        && (nextOffset != prevOffset))
                {
                    *stringLength = nextOffset;
                    stringLength++;

                    if (stringLength >= maxStringLength)
                        return kErrOutOfBoundary;

                    prevOffset = nextOffset;
                }
                else
                {
                    if ((iTmp & 0x01) == 0)
                        nextOffset = 2L * (unsigned long)iTmp;

                    locationTable++;
                }
            }
        }
    }

    *stringLength = glyfTableSize; /* Close the breakpoints list. */
    stringLength++;

    if (stringLength >= maxStringLength)
        return kErrOutOfBoundary;

    *stringLength = 0; /* Always close the breakpoints list with 0!!! */

    return kNoErr;
}


UFLErrCode
GenerateGlyphStorageExt(
    UFOStruct     *pUFObj,
    unsigned long tableSize
    )
{
    T42FontStruct   *pFont        = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long   *stringLength = pFont->pStringLength;
    unsigned long   upperLimit    = SFNT_STRINGSIZE; /* 0x3FFE */
    UFLHANDLE       stream        = pUFObj->pUFL->hOut;
    UFLErrCode      retVal;
    short           i;

    retVal = CalcBestGlyfTableBreaks(pUFObj, upperLimit, tableSize);
    if (retVal != kNoErr)
        return retVal;

    /*
     * Send down the array of Glyph strings.
     */

    retVal = StrmPutStringEOL(stream, nilStr);
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, "[");

    for (i = 1; (retVal == kNoErr) && (stringLength[i] != 0); i++)
    {
        unsigned long  stringSize;

#if 0
        //
        // For Chinese Font SongTi, the very last stringLength is incorrect:
        // glyfSize = 7068416, but the last glyf breaks at 6890292.
        // That means the very last glyf is 178124 - this is impossible.
        // Either GDI is not returning correct number or our function
        // GetTableSize() is wrong. Untill we fix our problem or get a better
        // build of Win95, this is a temp fix. ?????. 10-12-95
        //
        if (stringLength[i] > stringLength[i-1] + 0xFFFF)
            stringSize = (unsigned long)0x3FFF;  // 16K. This is a bogus entry anyway.
        else
#endif
            stringSize = stringLength[i] - stringLength[i-1];

        if (kNoErr == retVal)
            retVal = StrmPutInt(stream, stringSize + 1);

        if (retVal == kNoErr)
        {
            if (i % 13 == 0)
                retVal = StrmPutStringEOL(stream, nilStr);
            else
                retVal = StrmPutString(stream, " ");
        }
    }

    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, "] AllocGlyphStorage");

    return retVal;

}


unsigned short
GetTableDirectoryOffset(
    T42FontStruct *pFont,
    unsigned long tableName
    )
{
    TableDirectoryStruct* tableDirectory = (TableDirectoryStruct *)pFont->pMinSfnt;
    TableEntryStruct*     tableEntry     = (TableEntryStruct *)((char *)tableDirectory
                                                + sizeof (TableDirectoryStruct));
    unsigned short        offset         = sizeof (TableDirectoryStruct);
    unsigned short        i              = 0;

    while (i < MOTOROLAINT(tableDirectory->numTables))
    {
        if (tableEntry->tag == tableName)
            break;
        else
        {
            tableEntry = (TableEntryStruct *)((char *)tableEntry + sizeof (TableEntryStruct));
            offset += sizeof (TableEntryStruct);
            i++;
        }
    }
    return offset;
}


/* Sorting and Searching functions for an array of longs */

// Function to compare longs
static short
CompareLong(
    const long x,
    const long y
    )
{
    if (x == y)
        return 0;
    else if (x < y)
        return -1;
    else
        return 1;
}

// Function to swap pointers to longs
static void
SwapLong(
    long *a,
    long *b
    )
{
    if (a != b)
    {
        long tmp = *a;
        *a = *b;
        *b = tmp;
    }
}


/* This is a tailored version of shortsort. Works only for array of longs. */
static void
ShortsortLong(
    char            *lo,
    char            *hi,
    unsigned short  width,
    short (*comp)(const long, const long)
    )
{
    while (hi > lo)
    {
        char *max = lo;
        char *p;

        for (p = lo + width; p <= hi; p += width)
        {
            if (comp(*(long *)p, *(long *)max) > 0)
                max = p;
        }

        SwapLong((long *)max, (long *)hi);

        hi -= width;
    }
}


/* Function to Sort the array between lo and hi (inclusive) */
void
QsortLong(
    char*           base,
    unsigned short  num,
    unsigned short  width,
    short (*comp)(const long, const long)
    )
{
    char            *lo, *hi;       /* ends of sub-array currently sorting        */
    char            *mid;           /* points to middle of subarray               */
    char            *loguy, *higuy; /* traveling pointers for partition step      */
    unsigned short  size;           /* size of the sub-array                      */
    short           stkptr;         /* stack for saving sub-array to be processed */
    char            *lostk[16], *histk[16];

    /* Testing shows that this is a good value.   */
    const unsigned short CUTOFF0 = 8;

    /*
     * Note: the number of stack entries required is no more than
     * 1 + log2(size), so 16 is sufficient for any array with <=64K elems.
     */
    if ((num < 2) || (width == 0))
        return;  /* Nothing to do. */

    stkptr = 0;  /* Initialize stack. */

    lo = (char *)base;
    hi = (char *)base + width * (num - 1);  /* Initialize limits. */

    /*
     * This entry point is for pseudo-recursion calling: setting lo and hi and
     * jumping to here is like recursion, but stkptr is prserved, locals aren't,
     * so we preserve stuff on the stack.
     */
sort_recurse:

    size = (unsigned short)((hi - lo) / width + 1); /* Number of el's to sort */

    if (size <= CUTOFF0)
    {
        ShortsortLong(lo, hi, width, comp);
    }
    else
    {
        mid = lo + (size / 2) * width;     /* Find middle element. */
        SwapLong((long *)mid, (long *)lo); /* Wwap it to beginning of array. */

        loguy = lo;
        higuy = hi + width;

        /*
         * Note that higuy decreases and loguy increases on every iteration,
         * so loop must terminate.
         */
        while(1)
        {
            do
            {
                loguy += width;
            } while (loguy <= hi && comp(*(long *)loguy, *(long *)lo) <= 0);

            do
            {
                higuy -= width;
            } while (higuy > lo && comp(*(long *)higuy, *(long *)lo) >= 0);

            if (higuy < loguy)
                break;

            SwapLong((long *)loguy, (long *)higuy);
        }

        SwapLong((long *)lo, (long *)higuy); /* Put partition element in place. */

        if ((higuy - 1 - lo) >= (hi - loguy))
        {
            if ((lo + width) < higuy)
            {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr; /* Save big recursion for later. */
            }

            if (loguy < hi)
            {
                lo = loguy;
                goto sort_recurse; /* Do small recursion. */
            }
        }
        else
        {
            if (loguy < hi)
            {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr; /* Save big recursion for later. */
            }

            if ((lo + width) < higuy)
            {
                hi = higuy - width;
                goto sort_recurse; /* Do small recursion. */
            }
        }
    }

    /*
     * We have sorted the array, except for any pending sorts on the stack.
     * Check if there are any, and do them.
     */
    --stkptr;

    if (stkptr >= 0)
    {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto sort_recurse; /* Pop subarray from stack. */
    }
    else
        return; /* All subarrays done. */
}


/* This is a tailored version of the CRT bsearch(). */
void *
BsearchLong (
    const long     key,
    const char     *base,
    unsigned short num,
    unsigned short width,
    short (*compare)(const long, const long)
    )
{
    char *lo = (char *)base;
    char *hi = (char *)base + (num - 1) * width;

    while (lo <= hi)
    {
        unsigned short half;

        if (half = (num / 2))
        {
            short   result;
            char    *mid = lo + (num & 1 ? half : (half - 1)) * width;

            if (!(result = (*compare)(key, *(long *)mid)))
                return mid;
            else if (result < 0)
            {
                hi  = mid - width;
                num = num & 1 ? half : half - 1;
            }
            else
            {
                lo  = mid + width;
                num = half;
            }
        }
        else if (num)
            return ((*compare)((long)key, *(long *)lo) ? nil : lo);
        else
            break;
    }

    return nil;
}


UFLErrCode
DefaultGetRotatedGIDs(
    UFOStruct     *pUFObj,
    T42FontStruct *pFont,
    UFLFontProcs  *pFontProcs
    )
{
    UFLErrCode      retVal = kNoErr;
    unsigned short  num    = 0; // Remember the number of GIDs.
    long            *pFoundGID;
    short           subTable;
    unsigned long   offset;
    short           i;

    /*
     * Don't forget to double the size. We expect extra GIDs coming from 'GSUB'
     * or 'mort' table.
     */
    pFont->pRotatedGlyphIDs = (long *)UFLNewPtr(pUFObj->pMem, (NUM_HALFWIDTHCHARS + 1) * sizeof (long) * 2);
    if (!pFont->pRotatedGlyphIDs)
        return kErrOutOfMemory;

    /*
     * To scan through TTF's 'cmap' table to fingure out the glyph ids for all
     * characters in the range for romans and single byte chars.
     */
    if (!pFontProcs->pfGetGlyphID)
        GetGlyphIDEx(pUFObj, 0, 0, &subTable, &offset, GGIEX_HINT_INIT);

    pFoundGID = pFont->pRotatedGlyphIDs;

    for (i = 0;
         (gHalfWidthChars[i].startU != gHalfWidthChars[i].endU)
          && (gHalfWidthChars[i].startU != 0);
         i++)
    {
        long unicode, localcode;

        for (unicode = gHalfWidthChars[i].startU, localcode = gHalfWidthChars[i].startL;
             unicode <= gHalfWidthChars[i].endU;
             unicode++, localcode++)
        {
            unsigned long gi;

            if (pFontProcs->pfGetGlyphID)
                gi = pFontProcs->pfGetGlyphID(pUFObj->hClientData,
                                                (unsigned short)unicode,
                                                (unsigned short)localcode);
            else
                gi = GetGlyphIDEx(pUFObj, unicode, localcode,
                                    &subTable, &offset, GGIEX_HINT_GET);

            if (gi > (unsigned long)UFO_NUM_GLYPHS(pUFObj))
                gi = 0;

            if (gi != 0)
            {
                *pFoundGID = (long)gi;
                pFoundGID++;
                num++;
            }
            else
            {
                //
                // We will have to treat all Half-width single characters as
                // "space" because we don't want to place a Double-Byte
                // /.notdef as rotated.
                //
            }
        }
    }

    if (pFontProcs->pfGetRotatedGSUBs) // Fix #316070
    {
        // OK to trancate long to unsigned short.
        num += (unsigned short)pFontProcs->pfGetRotatedGSUBs(
                                                pUFObj->hClientData,
                                                pFont->pRotatedGlyphIDs,
                                                num);
    }

    pFont->numRotatedGlyphIDs = num;

    //
    // Now, sort the array so that we can search quicker later.
    //
    QsortLong((char *)(pFont->pRotatedGlyphIDs),
                pFont->numRotatedGlyphIDs,
                4,
                CompareLong);

    return retVal;
}


UFLErrCode
T42GetRotatedGIDs(
    UFOStruct     *pUFObj,
    T42FontStruct *pFont
    )
{
    UFLFontProcs *pFontProcs = (UFLFontProcs *)&(pUFObj->pUFL->fontProcs);

    /* Assume this first in order to fall back to the default logic. */
    UFLErrCode retVal = kErrOSFunctionFailed;

    pFont->numRotatedGlyphIDs = 0;

    if (pFontProcs->pfGetRotatedGIDs)
    {
        long nGlyphs = pFontProcs->pfGetRotatedGIDs(pUFObj->hClientData, nil, 0, nil);

        if (nGlyphs > 0)
        {
            pFont->pRotatedGlyphIDs = (long *)UFLNewPtr(pUFObj->pMem, (nGlyphs + 1) * sizeof (long));

            if (pFont->pRotatedGlyphIDs)
            {
                pFontProcs->pfGetRotatedGIDs(pUFObj->hClientData, pFont->pRotatedGlyphIDs, nGlyphs, nil);
                pFont->numRotatedGlyphIDs = (unsigned short)nGlyphs;
                retVal = kNoErr;
            }
            else
                retVal = kErrOutOfMemory;
        }
        else
            retVal = (nGlyphs == 0) ? kNoErr: kErrOSFunctionFailed;
    }

    if (retVal == kErrOSFunctionFailed)
    {
        /*
         * Default logic: scan TTF's cmap to get GIDs for CJK half-width chars.
         */
        retVal = DefaultGetRotatedGIDs(pUFObj, pFont, pFontProcs);
    }

    return retVal;
}


UFLBool
IsDoubleByteGI(
    unsigned short  gi,
    long            *pGlyphIDs,
    short           length
    )
{
    void   *index;

    // Return True if gi is NOT in the pGlyphIDs - index==nil.
    index = BsearchLong((long)gi, (char *)pGlyphIDs, length, 4, CompareLong);

    return ((index == nil) ? 1 : 0);
}


/*============================================================================*
 *                 Begin Code to support more than 32K glyphs                 *
 *============================================================================*/

/******************************************************************************
 *
 *                            T42SendCMapWinCharSetFFFF_V
 *
 *   Make a vertical CMap based on known Rotated Glyph-indices (1 Byte chars).
 *   Create a CMapType 1 CMap. Since this CMap is different for different font,
 *   the CMapName is passed in by caller as lpNewCmap. The resulting CMap uses
 *   2 or 4(lGlyphs>32K) CMaps: e.g.
 *
 *   [/TT31c1db0t0cid /TT31c1db0t0cidR]
 *   or
 *   [/TT31c1db0t0cid /TT31c1db0t0cidR /TT31c1db0t0cid32K /MSTT31c1db0t0cid32KR]
 *
 ******************************************************************************/

UFLErrCode
T42SendCMapWinCharSetFFFF_V(
    UFOStruct       *pUFObj,
    long            *pRotatedGID,
    short           wLength,
    UFLCMapInfo     *pCMap,
    char            *pNewCmap,
    unsigned long   lGlyphs,
    UFLHANDLE       stream,
    char            *strmbuf,
    size_t          cchstrmbuf
    )
{
    short           nCount, nCount32K, nLen, i, j;
    unsigned short  wPrev, wCurr;
    UFLErrCode      retVal;
    UFLBool         bCMapV2 = (pCMap == &CMapInfo_FF_V2) ? 1 : 0;

    UFLsprintf(strmbuf, cchstrmbuf,
                "/CIDInit /ProcSet findresource begin "
                "12 dict begin begincmap /%s usecmap",
                pCMap->CMapName);
    retVal = StrmPutStringEOL(stream, strmbuf);

    /*
     * Create CIDSystemInfo unique for this font. Since this CMap will refer to
     * more than one font, the CIDSystmInfo is going to be an array.
     */
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "/CIDSystemInfo [3 dict dup begin");

    UFLsprintf(strmbuf, cchstrmbuf, "/Registry (%s) def", pCMap->Registry);
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, strmbuf);

    UFLsprintf(strmbuf, cchstrmbuf, "/Ordering (%s) def", pNewCmap);
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, strmbuf);

    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "/Supplement 0 def");

    if (lGlyphs <= NUM_32K_1)
        UFLsprintf(strmbuf, cchstrmbuf, "end dup] def");
    else
        UFLsprintf(strmbuf, cchstrmbuf, "end dup dup dup] def");
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, strmbuf);

    UFLsprintf(strmbuf, cchstrmbuf, "/CMapName /%s def", pNewCmap);
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, strmbuf);

    /* Fix /CIDInit /ProcSet bug: need "/WMode 1 def" explicitly. */
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "/WMode 1 def");

    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "0 beginusematrix [0 1 -1 0 0 0] endusematrix");

    if ((retVal == kNoErr) && bCMapV2)
        retVal = StrmPutStringEOL(stream, "2 beginusematrix [0 1 -1 0 0 0] endusematrix");

    /* Skip to emit begin~endcidrange if there is no rotated GIDs. */
    if (wLength == 0)
        goto SENDCMAPFFFF_V_ENDCMAP;

    /*
     * Count how many different Glyph-indices are there in pRotatedGID.
     * It must be sorted and there may be duplicates so that we count only
     * unique GIDs.
     */
    wPrev = (unsigned short)*pRotatedGID;
    nCount = nCount32K = 0;

    if (wPrev > NUM_32K_1)
        nCount32K++;
    else
        nCount++;

    for (i = 0; i < wLength; i++)
    {
        wCurr = (unsigned short)*(pRotatedGID + i);
        if (wPrev == wCurr)
            continue;
        else
        {
            wPrev = wCurr;
            if (wPrev > NUM_32K_1)
                nCount32K++;
            else
                nCount++;
        }
    }

    /*
     * Emit 0 to 32K rotated GIDs to font number 1.
     */
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "1 usefont");

    if (100 < nCount)
        UFLsprintf(strmbuf, cchstrmbuf, "100 begincidrange");
    else
        UFLsprintf(strmbuf, cchstrmbuf, "%d begincidrange", nCount);

    wPrev = (unsigned short)*(pRotatedGID);

    if (retVal == kNoErr)
    {
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);
        if (kNoErr == retVal)
            retVal = StrmPutWordAsciiHex(stream, wPrev);
        if (kNoErr == retVal)
            retVal = StrmPutWordAsciiHex(stream, wPrev);

        UFLsprintf(strmbuf, cchstrmbuf, "%u", wPrev);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);
    }

    nLen = 1;
    for (i = 1; i < wLength; i++)
    {
        wCurr = (unsigned short)*(pRotatedGID + i);

        /*
         * This potion is for 0 to 32K glyphs - the pRotatedGID are sorted,
         * so we can just break out of the loop here.
         */
        if (wCurr > NUM_32K_1)
            break;

        if (wPrev == wCurr)
            continue;
        else
        {
            wPrev = wCurr;
            nLen++;
        }

        if (retVal == kNoErr)
        {
            if (kNoErr == retVal)
                retVal = StrmPutWordAsciiHex(stream, wPrev);
            if (kNoErr == retVal)
                retVal = StrmPutWordAsciiHex(stream, wPrev);

            UFLsprintf(strmbuf, cchstrmbuf, "%u", wPrev);
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }

        if (nLen % 100 == 0)
        {
            if (nCount - nLen > 100)
                UFLsprintf(strmbuf, cchstrmbuf, "endcidrange\n100 begincidrange");
            else if (nCount - nLen > 0)
                UFLsprintf(strmbuf, cchstrmbuf, "endcidrange\n%d begincidrange", nCount - nLen);
            else
                UFLsprintf(strmbuf, cchstrmbuf, " ");
        }
        else
            continue; /* Do next record. */

        if (retVal == kNoErr)
            retVal = StrmPutStringEOL(stream, strmbuf);
    }

    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "endcidrange");

    /*
     * Emit 32K+ GIDs.
     */
    if (NUM_32K_1 < lGlyphs)
    {
        /*
         * Build two more re-mappings using CMAP-WinCharSetFFFF-V2, which is
         * created from CMAP-WinCharSetFFFF-H2 specifying 32K+ glyphs as
         * font number 1. (See the definition of CMAP-WinCharSetFFFF-H2 in
         * CMap_FF.ps.) Since font number 1 is already used for 0 to 32K
         * rotated GIDs above,  we need to redefine the range for 32K+
         * unrotated GIDs as font number 2, *then* define the range for 32K+
         * rotated GIDs as font number 3. (Here is the font array we are
         * assuming: [000, 000R, 00032K, 00032KR])
         *
         * Note also that when this is a %hostfont% font (bCMapV2 is 0), we
         * don't need to use CMAP-WinCharSetFFFF-V2 but CMAP-WinCharSetFFFF-V
         * instead. But we still need to emit 32K+ glyph cidrange here.
         * In this case, we don't send '3 usefont' so that the cidrange lines
         * are emitted as continuation for font number 1.
         */

        if (bCMapV2)
        {
            /*
             * Emit font number 2 range.
             */
            if (retVal == kNoErr)
                retVal = StrmPutStringEOL(stream, "2 usefont");

            nCount = (int)((long)lGlyphs - (long)NUM_32K_1 + 0xFE) / 0xFF;

            UFLsprintf(strmbuf, cchstrmbuf, "%d begincidrange", nCount);
            if (retVal == kNoErr)
                retVal = StrmPutStringEOL(stream, strmbuf);

            /*
             * We assume NUM_32K_1 ends at 00 (such as 0xFF00, or 0xFE00...).
             */
            for (i = 0; i < nCount; i++)
            {
                wPrev = (unsigned short) (i * 0x100 + (long)NUM_32K_1);

                if (kNoErr == retVal)
                    retVal = StrmPutWordAsciiHex(stream, wPrev);
                if (kNoErr == retVal)
                    retVal = StrmPutWordAsciiHex(stream, (unsigned short)(wPrev + 0xFF));

                UFLsprintf(strmbuf, cchstrmbuf, "%u", (unsigned short)(i * 0x100));
                if (retVal == kNoErr)
                    retVal = StrmPutStringEOL(stream, strmbuf);
            }

            if (retVal == kNoErr)
                retVal = StrmPutStringEOL(stream, "endcidrange");
        }

        if (0 < nCount32K)
        {
            /*
             * Emit rotated GIDs of font number 3 or 1 if not using
             * '2' version of VCMap (which means this is a %hostfont%
             * font that has 32K+ glyphs.)
             */
            if ((retVal == kNoErr) && bCMapV2)
                retVal = StrmPutStringEOL(stream, "3 usefont");

            wPrev = (unsigned short)*pRotatedGID;

            for (j = 0; j < wLength; j++)
            {
                wCurr = (unsigned short)*(pRotatedGID + j);
                wPrev = wCurr;

                if (wPrev > NUM_32K_1)
                    break; /* Found the start point. */
            }

            if (100 < nCount32K)
                UFLsprintf(strmbuf, cchstrmbuf, "100 begincidrange");
            else
                UFLsprintf(strmbuf, cchstrmbuf, "%d begincidrange", nCount32K);

            if (retVal == kNoErr)
            {
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);
                if (kNoErr == retVal)
                    retVal = StrmPutWordAsciiHex(stream, wPrev);
                if (kNoErr == retVal)
                    retVal = StrmPutWordAsciiHex(stream, wPrev);

                UFLsprintf(strmbuf, cchstrmbuf, "%u", bCMapV2 ? wPrev - NUM_32K_1 : wPrev);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);
            }

            nLen = 1;
            for (i = j; i < wLength; i++)
            {
                wCurr = (unsigned short)*(pRotatedGID + i);

                if (wPrev == wCurr)
                    continue;
                else
                {
                    wPrev = wCurr;
                    nLen++;
                }

                if (retVal == kNoErr)
                {
                    if (kNoErr == retVal)
                        retVal = StrmPutWordAsciiHex(stream, wPrev);
                    if (kNoErr == retVal)
                        retVal = StrmPutWordAsciiHex(stream, wPrev);

                    UFLsprintf(strmbuf, cchstrmbuf, "%u", bCMapV2 ? wPrev - NUM_32K_1 : wPrev);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);
                }

                if (nLen % 100 == 0)
                {
                    if (100 < nCount - nLen)
                        UFLsprintf(strmbuf, cchstrmbuf, "endcidrange 100 begincidrange");
                    else if (0 < nCount - nLen)
                        UFLsprintf(strmbuf, cchstrmbuf, "endcidrange %d begincidrange", nCount-nLen);
                    else
                        UFLsprintf(strmbuf, cchstrmbuf, " ");
                }
                else
                    continue; /* Do next record. */

                if (retVal == kNoErr)
                   retVal = StrmPutStringEOL(stream, strmbuf);
            }

            if (retVal == kNoErr)
                retVal = StrmPutStringEOL(stream, "endcidrange");

            /* End of additional 32K+ CMap code. */
        }
    }

SENDCMAPFFFF_V_ENDCMAP:

    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, "endcmap CMapName currentdict "
                                            "/CMap defineresource pop end end");

    return retVal;
}

/*============================================================================*
 *                   End Code To Support More Than 32K Glyphs                 *
 *============================================================================*/


long
AdjBBox(
    long    value,
    UFLBool lowerleft
    )
{
   if (lowerleft)
   {
      if (value > 0)
         return (value - 1);
      else if (value < 0)
         return (value + 1);
      else
         return (value);
   }
   else
   {
      if (value > 0)
         return (value + 1);
      if (value < 0)
         return (value - 1);
      else
         return (value);
   }
}


UFLErrCode
T42CreateBaseFont(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    UFLBool             bFullFont,
    char                *pHostFontName
    )
{
    T42FontStruct   *pFont          = (T42FontStruct *)pUFObj->pAFont->hFont;
    UFLFontProcs    *pFontProcs     = (UFLFontProcs *)&(pUFObj->pUFL->fontProcs);
    UFLHANDLE       stream          = pUFObj->pUFL->hOut;
    UFLErrCode      retVal          = kNoErr;
    unsigned long   cidCount, tableSize, tableSize1, sizeUsed;
    UFLCMapInfo     *pCMap;
    char            strmbuf[256];


    /* Sanity check */
    if (pFont == nil)
        return kErrInvalidHandle;

    /*
     * Download procsets.
     */
    if (pUFObj->pUFL->outDev.pstream->pfDownloadProcset == 0)
        return kErrDownloadProcset;

    if (!pUFObj->pUFL->outDev.pstream->pfDownloadProcset(pUFObj->pUFL->outDev.pstream, kT42Header))
        return kErrDownloadProcset;

    if (IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat))
    {
        if (!pUFObj->pUFL->outDev.pstream->pfDownloadProcset(pUFObj->pUFL->outDev.pstream, kCMap_FF))
            return kErrDownloadProcset;
    }


    /*
     * There is a bumpy road ahead when kFontInit2 state.
     */
    if (UFO_FONT_INIT2(pUFObj))
        goto T42CreateBaseFont_FontInit2_1;


    /*
     * Generate the minimal sfnt.
     */
    retVal = GetMinSfnt(pUFObj, bFullFont);

    if (kNoErr == retVal)
        retVal = FillInHeadTable(pUFObj);

    if (kNoErr == retVal)
        pFont->info.fData.cNumGlyphs = GetNumGlyphs(pUFObj);

    if (kNoErr == retVal)
    {
        tableSize = GetTableSize(pUFObj, pFont->pMinSfnt, LOCA_TABLE);

        if (tableSize)
        {
            /*
             * The following code includes fix for #317027 and #316096: load
             * 'loca' table and set the extra glyph offset entry if it's
             * missing and the delta from the last glyph offset is less than
             * 4K for safety.
             */
            unsigned long expectedTableSize = pFont->info.fData.cNumGlyphs + 1;

            expectedTableSize *= pFont->headTable.indexToLocFormat ? 4 : 2;

            // Fixed bug 516514
            if (expectedTableSize > tableSize)
            {
                sizeUsed = expectedTableSize;
                pFont->pLocaTable = UFLNewPtr(pUFObj->pMem, expectedTableSize);
            }
            else
            {
                sizeUsed = tableSize;
                pFont->pLocaTable = UFLNewPtr(pUFObj->pMem, tableSize);
            }

            if (pFont->pLocaTable)
            {
                if (GetFontTable(pUFObj, LOCA_TABLE, (unsigned char *)pFont->pLocaTable, sizeUsed) == 0)
                {
                    retVal = kErrGetFontData;
                }
                else if (expectedTableSize > tableSize)
                {
                    unsigned long  glyfTableSize = GetTableSize(pUFObj, pFont->pMinSfnt, GLYF_TABLE);
                    unsigned char  *pTable, *pExtraEntry;
                    unsigned long  lastValidOffset;

                    pTable = (unsigned char *)pFont->pLocaTable;

                    if (pFont->headTable.indexToLocFormat)
                    {
                        unsigned long *pLastEntry =
                            (unsigned long *)(pTable + (pFont->info.fData.cNumGlyphs - 1) * 4);

                        lastValidOffset = MOTOROLALONG(*pLastEntry);

                        if (glyfTableSize - lastValidOffset < 4097)
                        {
                            pExtraEntry = (unsigned char *)(pLastEntry + 1);

                            *pExtraEntry++ = (unsigned char)((glyfTableSize & 0xFF000000) >> 24);
                            *pExtraEntry++ = (unsigned char)((glyfTableSize & 0x00FF0000) >> 16);
                            *pExtraEntry++ = (unsigned char)((glyfTableSize & 0x0000FF00) >>  8);
                            *pExtraEntry   = (unsigned char)((glyfTableSize & 0x000000FF));
                        }
                    }
                    else
                    {
                        unsigned short *pLastEntry =
                            (unsigned short *)(pTable + (pFont->info.fData.cNumGlyphs - 1) * 2);

                        lastValidOffset = MOTOROLAINT(*pLastEntry);

                        if (glyfTableSize - lastValidOffset < 4097)
                        {
                            pExtraEntry = (unsigned char *)(pLastEntry + 1);

                            *pExtraEntry++ = (unsigned char)((glyfTableSize & 0x0000FF00) >>  8);
                            *pExtraEntry   = (unsigned char)((glyfTableSize & 0x000000FF));
                        }
                    }
                }
            }
            else
                retVal = kErrOutOfMemory;
        }
        else
            retVal = kErrGetFontData;
    }

    if (kNoErr == retVal)
    {
        /* Fix blue screen bug 278017. */
        tableSize = pFont->minSfntSize; /* instead of GetGlyphTableSize(pUFObj) */

        if (!bFullFont)
            tableSize += GetGlyphTableSize(pUFObj);

        if (((tableSize / SFNT_STRINGSIZE) * 5 / 4) > NUM_16KSTR)
            tableSize = (tableSize / SFNT_STRINGSIZE) * 5 / 4;
        else
            tableSize = NUM_16KSTR;

        tableSize1 = tableSize + 1;

        pFont->pStringLength =
            (unsigned long *)UFLNewPtr(pUFObj->pMem, tableSize1 * sizeof(unsigned long));

        if (pFont->pStringLength)
            retVal = CalculateStringLength(pUFObj, pFont,  tableSize1);
        else
            retVal = kErrOutOfMemory;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // /sfnts initialization is done. Actual downloading begins here.
    //
    //////////////////////////////////////////////////////////////////////////

    /*
     * Send out left upper right lower values.
     */
    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        // Fixed bug #516915
        if (0 == pFont->headTable.unitsPerEm)
            retVal = kErrGetFontData;
        else
        {
            /*
             * The first four values are the font bounding box. We convert all
             * floats into 24.8 fixed values. Make sure the bounding box doesn't
             * get truncated down to a smaller area.
             */
            UFLsprintfEx(strmbuf, CCHOF(strmbuf), "%f %f %f %f",
                (AdjBBox((long)pFont->headTable.xMin, 1) << 8) / (long)pFont->headTable.unitsPerEm,
                (AdjBBox((long)pFont->headTable.yMin, 1) << 8) / (long)pFont->headTable.unitsPerEm,
                (AdjBBox((long)pFont->headTable.xMax, 0) << 8) / (long)pFont->headTable.unitsPerEm,
                (AdjBBox((long)pFont->headTable.yMax, 0) << 8) / (long)pFont->headTable.unitsPerEm);

            retVal = StrmPutStringEOL(pUFObj->pUFL->hOut, strmbuf);
        }
    }

    /*
     * Send out encoding name.
     */
    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * Always emit Encoding array filled with /.notdef (due to bug fix
         * #273021).
         */
        retVal = StrmPutString(stream, gnotdefArray);
    }

    /*
     * Send out font name.
     */
    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * If CID-keyed font, then append "CID" to the CIDFont name so that
         * CID_Resource is also consisted of the original fontName.
         */
        if (IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat))
            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s", pFont->info.CIDFontName, gcidSuffix[0]);
        else
            UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s", pUFObj->pszFontName);

        retVal = StrmPutStringEOL(stream, strmbuf);
    }


    /*
     * First landing place when kFontInit2 state.
     */
T42CreateBaseFont_FontInit2_1:


    /*
     * Setup for CID-keyed-font or CIDFont-Resource downloading.
     */
    if ((kNoErr == retVal) && IS_TYPE42CID(pUFObj->lDownloadFormat))
    {
        //
        // hasvmtx is used to determine whether to call the AddT42vmtxEntry
        // function later.
        //
        unsigned long tblSize = GETTTFONTDATA(pUFObj,
                                                VMTX_TABLE, 0L,
                                                nil, 0L,
                                                pFont->info.fData.fontIndex);

        pUFObj->pAFont->hasvmtx = tblSize ? 1 : 0;

        if (pFont->info.bUseIdentityCMap)
        {
            UFLBool bUseCMap2 = 0;
            cidCount = UFO_NUM_GLYPHS(pUFObj);

            /*
             * Use '2' version of CMap if the number of glyphs are greater
             * than 32K *and* this is not a %hostfont% font.
             */
            if((NUM_32K_1 < cidCount) && !HOSTFONT_IS_VALID_UFO(pUFObj))
                bUseCMap2 = 1;

            if (IS_TYPE42CID_H(pUFObj->lDownloadFormat))
                pCMap = bUseCMap2 ? &CMapInfo_FF_H2 : &CMapInfo_FF_H;
            else
                pCMap = bUseCMap2 ? &CMapInfo_FF_V2 : &CMapInfo_FF_V;
        }
        else
        {
            cidCount = pFont->info.CIDCount;

            /* If CMap is provided, use it. */
            pCMap = &(pFont->info.CMap);
        }
    }


    /*
     * Need one more warp when kFontInit2 state.
     */
    if (UFO_FONT_INIT2(pUFObj))
        goto T42CreateBaseFont_FontInit2_2;


    /*
     * Begin font dictionary download.
     */

    if ((kNoErr == retVal)
        && IS_TYPE42CID(pUFObj->lDownloadFormat)
        && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * If downloading CID Type 42, add CIDSysInfo, CIDCount, CIDMap, and
         * CDevProc.
         */

        /* Registry, Ordering, and Suppliment */
        UFLsprintf(strmbuf, CCHOF(strmbuf),
                    "(%s) (%s) %d",
                    pCMap->Registry, pCMap->Ordering, pCMap->Supplement);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);

        /* CIDCount */
        UFLsprintf(strmbuf, CCHOF(strmbuf), "%lu", min(cidCount, (long)NUM_32K_1));
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);

        /* CIDMap */
        if (pFontProcs->pfGetCIDMap
            && (tableSize = pFontProcs->pfGetCIDMap(pUFObj->hClientData, nil, 0)))
        {
            char* pCIDMap = UFLNewPtr(pUFObj->pMem, tableSize);

            if (pCIDMap)
            {
                tableSize = pFontProcs->pfGetCIDMap(pUFObj->hClientData, pCIDMap, tableSize);

                /* The pCIDMap is already ASCII, so just send it using PutBytes(). */
                if (kNoErr == retVal)
                    StrmPutBytes(stream, pCIDMap, (UFLsize_t) tableSize, 1);

                UFLDeletePtr(pUFObj->pMem, pCIDMap);
            }
        }
        else
        {
            /*
             * IDStr creates an Identity string.
             * WCC - IDStrNull creates a strings which maps all CIDs to GID 0.
             * Bug #260864. Use IDStrNull for Character Code mode.
             */
            if (pFont->info.bUpdateCIDMap)
               UFLsprintf(strmbuf, CCHOF(strmbuf), "%lu IDStrNull", min(cidCount - 1, (long)NUM_32K_1));
            else
               UFLsprintf(strmbuf, CCHOF(strmbuf), "%lu IDStr",     min(cidCount - 1, (long)NUM_32K_1));

            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }

        /*
         * CDevProc
         *
         * Further investigation due to #351487 led us to download Metrics2
         * array with TopSideBearing/EM as vy for EVERY glyph and generate
         * the following metrics in CDevProc:
         *
         *  W1x = 0
         *  W1y = -AdvancedHeight / EM
         *  vx  = descender / EM
         *  vy  = ury + TopSideBearing / EM
         *
         * According to this, the CDevProc became very simple like this:
         *
         *  {pop 4 index add}
         *
         * On the other hand, if the TrueType font doesn't have 'vmtx' table,
         * then the driver never download Metrics2 for any glyph at all and
         * the following CDevProc is use instead:
         *
         *  {5 {pop} repeat 0 -1 descender/em ascender/em}
         *
         * This is an agreement between the driver and %hostfont% teams to
         * make the inks from %hostfont% RIP and non %hostfont% RIP match.
         * (...but this is not actually the same CDevProc %hostfont% RIP
         * uses. Ascender and descender values %hostfont% RIP uses are the
         * ones from 'vhea' or 'hhea'. Whereas, ascender and descender values
         * the driver uses to generate this CDevProc are from 'OS/2' or 'hhea'.
         * A font, almost always, has 'OS/2' and 'hhea', hence the CDevProc
         * downloaded by the driver and the one generated by %hostfont% RIP
         * aren't same normally.)
         *
         * Other bug numbers related with this problem are 277035, 277063,
         * 303540, and 309104.
         */
        {
            if (pUFObj->pAFont->hasvmtx)
            {
                UFLsprintf(strmbuf, CCHOF(strmbuf), "{pop 4 index add}bind");
            }
            else
            {
                long    em, w1y, vx, vy, tsb, vasc;
                UFLBool bUseDef;

                GetMetrics2FromTTF(pUFObj, 0, &em, &w1y, &vx, &vy, &tsb, &bUseDef, 1, &vasc);

                UFLsprintf(strmbuf, CCHOF(strmbuf),
                           "{5{pop}repeat 0 -1 %ld %ld div %ld %ld div}bind",
                            vx, em, vy, em);
            }

            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }

        UFLsprintf(strmbuf, CCHOF(strmbuf), "CIDT42Begin");
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);
    }
    else if (!HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /* Plain Type 42 format */
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, "Type42DictBegin");
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // Either Type42DictBegin or CIDT42Begin has just emitted.
    // Begin downloading /sfnts array
    //
    //////////////////////////////////////////////////////////////////////////

    if (!HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        if (kNoErr == retVal)
            retVal = StrmPutString(stream, "[");

        if (kNoErr == retVal)
        {
            /* Remember Number of strings of all otherTables sent. */
            if (StrmCanOutputBinary(stream))
                pFont->cOtherTables = PSSendSfntsBinary(pUFObj);
            else
                pFont->cOtherTables = PSSendSfntsAsciiHex(pUFObj);
        }

        if ((kNoErr == retVal) && !bFullFont)
            retVal = GenerateGlyphStorageExt(pUFObj, tableSize1);

        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, "]def ");
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // /sfnts array downloading completed. Then emit extra info, such as
    // FontInfo, FSType, and XUID.
    //
    //////////////////////////////////////////////////////////////////////////


    if ((kNoErr == retVal) && !bFullFont && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /* Invoke procedure to prepare for 2015 incremental downloading. */
        retVal = StrmPutInt(stream, GetTableDirectoryOffset(pFont, LOCA_TABLE));

        if (kNoErr == retVal)
            retVal = StrmPutString(stream, " ");
        if (kNoErr == retVal)
            retVal = StrmPutInt(stream, GetTableDirectoryOffset(pFont, GLYF_TABLE));
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, " ");

        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, "PrepFor2015");
    }

    /*
     * Add FontInfo dict if 'post' table is not good as of today. We only need
     * this info in FontInfo dict.
     */
    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        retVal = StrmPutStringEOL(stream, "AddFontInfoBegin");
        pUFObj->dwFlags |= UFO_HasFontInfo;
    }

    /*
     * GoodName
     * Ignore to test whether this font has good 'post' table and always emit
     * AddFontInfo to include glyph name to Unicode mapping.
     */
    // if (!BHasGoodPostTable(pUFObj))
    // {
        if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
        {
            UFLsprintf(strmbuf, CCHOF(strmbuf), "AddFontInfo");

            if (kNoErr == retVal)
            {
                retVal = StrmPutStringEOL(stream, strmbuf);
                pUFObj->dwFlags |= UFO_HasG2UDict;
            }
        }
    // }

    /*
     * Add more font properties to FontInfo of the current dict.
     */
    if ((kNoErr == retVal)
        && pFontProcs->pfAddFontInfo
        && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        char *pBuffer;
        int  bufLen = 1000;

        pBuffer = UFLNewPtr(pUFObj->pMem, bufLen);

        if (pBuffer)
        {
            pFontProcs->pfAddFontInfo(pUFObj->hClientData, pBuffer, bufLen);
            retVal = StrmPutStringEOL(stream, pBuffer);

            UFLDeletePtr(pUFObj->pMem, pBuffer);
        }

        pBuffer = nil;
    }

    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /* Fixing bug 284250. Add /FSType to FontInfoDict. */
        long  fsType;

        if ((fsType = GetOS2FSType(pUFObj)) == -1)
            fsType = 4;

        UFLsprintf(strmbuf, CCHOF(strmbuf), "/FSType %ld def", fsType);
        retVal = StrmPutStringEOL(stream, strmbuf);
    }

    /*
     * End FontInfo.
     */
    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
        retVal = StrmPutStringEOL(stream, "AddFontInfoEnd");

    /*
     * Optionally add XUID.
     */
    if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        unsigned long sSize = pUFObj->pAFont->Xuid.sSize;

        if (sSize)
        {
            unsigned long *pXUID = pUFObj->pAFont->Xuid.pXUID;

            retVal = StrmPutString(stream, "[");

            while (sSize)
            {
                UFLsprintf(strmbuf, CCHOF(strmbuf), "16#%x ", *pXUID);
                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, strmbuf);

                pXUID++;
                sSize--;
            }

            UFLsprintf(strmbuf, CCHOF(strmbuf), "] AddXUID");
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }
    }

    /*
     * End font dictionary download.
     */
    if (IS_TYPE42CID(pUFObj->lDownloadFormat) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /* End CID Type 42 CIDFont resource creation. */
        if (kNoErr == retVal)
        {
            UFLsprintf(strmbuf, CCHOF(strmbuf), "CIDT42End");
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }
    }
    else if (!HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /* End plain Type 42 font creation. */
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, "Type42DictEnd");
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // End downloading with Type42DictEnd or CIDT42End.
    //
    // When the font is a Roman TrueType font, a ready-to-use, Type 42 font
    // has been defined.
    //
    // When the font is a CJK TrueType font, a CIDFont resource has been
    // defined. But it's just a CIDFont and we still need to perform extra
    // work in order to define a CID-Keyed font, which is:
    //
    // 1. Define a CMap with rotated GlyphIDs if this is a vertical font.
    // 2. Do composefont with the CIDFont and the CMap(s).
    //
    //////////////////////////////////////////////////////////////////////////


    /*
     * Final landing place when kFontInit2 state.
     */
T42CreateBaseFont_FontInit2_2:


    /*
     * At this point, a CIDFont resource is created. If the request is to
     * do kTTType42CID_Resource, we are done.
     */
    if ((kNoErr == retVal) && IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat))
    {
        /*
         * Instantiate the CMap resource if do composefont - notice a convention
         * used here: CMAP-cmapname is used to instantiate cmapname.
         * See CMap_FF.ps as an example.
         */
        if (kNoErr == retVal)
        {
            UFLsprintf(strmbuf, CCHOF(strmbuf), "CMAP-%s", pCMap->CMapName);
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }

        /*
         * Now we can construct CID-keyed font from the CIDFont reosurce and CMap.
         *
         * e.g. /TT3782053888t0 /WinCharSetFFFF-H [/TT3782053888t0cid] composefont pop
         *
         * !!!BUT!!!, if there are more than 32K glyphs (like some Korean TT Fonts),
         * we need to make copies of the CIDFont Resource and make use of more than
         * one CMap - it's ugly, but it's the only way to do it. PPeng, 11-12-1996
         */
        if (pUFObj->lDownloadFormat == kTTType42CID_H)
        {
            /*
             * Horizontal
             * We need 1 or 2 CIDFonts when downloading it by ourselves.
             * But, when this font is available as %hostfont%, we can simple
             * composefont it without any trick.
             */

            if (!HOSTFONT_IS_VALID_UFO(pUFObj))
            {
                if (cidCount <= NUM_32K_1)
                {
                    /*
                     * We create a CID-keyed font using only one CIDFont.
                     */
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /%s [/%s%s] composefont pop",
                                pUFObj->pszFontName,
                                pCMap->CMapName,
                                pFont->info.CIDFontName, gcidSuffix[0]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);
                }
                else
                {
                    /*
                     * We create a CID-keyed font using two CIDFonts.
                     * Make a copy of the CIDFont so we can access 32K+ glyphs.
                     *
                     * But, when this is a %hostfont% font, we don't need to
                     * create a copy. Simply do composefont.
                     */
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "%lu dup 1 sub %lu IDStr2 /%s%s /%s%s T42CIDCP32K",
                                cidCount - (long)NUM_32K_1, (long)NUM_32K_1,
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32K],
                                pFont->info.CIDFontName, gcidSuffix[0]);
                    if (kNoErr == retVal)
                        retVal = StrmPutString(stream, strmbuf);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /%s [/%s%s ",
                                pUFObj->pszFontName, pCMap->CMapName,
                                pFont->info.CIDFontName, gcidSuffix[0]);
                    if (kNoErr == retVal)
                        retVal = StrmPutString(stream, strmbuf);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s] composefont pop",
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32K]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);
                }
            }
            else
            {
                /*
                 * %hostfont% support
                 * Simply composefont this %hostfont% font with
                 * %%IncludeResource DSC comment.
                 */
                UFLsprintf(strmbuf, CCHOF(strmbuf), "%%%%IncludeResource: CIDFont %s",
                            pHostFontName);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);

                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /%s [/%s] composefont pop",
                            pUFObj->pszFontName,
                            pCMap->CMapName,
                            pHostFontName);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);
            }
        }
        else
        {
            /*
             * Vertical
             * We need 2 or 4 CIDFonts when downloading it by ourselves.
             * But, when this font is available as %hostfont%, we can simple
             * composefont it without any trick.
             */

            /*
             * Prior to composefont, instanciate a veritcal CMap and rearrange
             * it with rotated glyph IDs.
             */
            char *newCMapName;
            DWORD cbCMapNameSize;

            cbCMapNameSize = UFLstrlen(pCMap->CMapName)
                             + UFLstrlen(pFont->info.CIDFontName)
                             + 1;

            newCMapName = (char*)UFLNewPtr(pUFObj->pMem, cbCMapNameSize);
            if (newCMapName)
                UFLsprintf(newCMapName, cbCMapNameSize / sizeof(char),
                           "%s%s",
                           pCMap->CMapName, pFont->info.CIDFontName);
            else
                retVal = kErrOutOfMemory;

            /* Get rotated glyph IDs. */
            if (kNoErr == retVal)
                retVal = T42GetRotatedGIDs(pUFObj, pFont);

            if (kNoErr == retVal)
                retVal = T42SendCMapWinCharSetFFFF_V(pUFObj, pFont->pRotatedGlyphIDs,
                                                        (short)(pFont->numRotatedGlyphIDs),
                                                        pCMap, newCMapName, cidCount,
                                                        stream, strmbuf, CCHOF(strmbuf));

            if (!HOSTFONT_IS_VALID_UFO(pUFObj))
            {
                if (cidCount <= NUM_32K_1)
                {
                    /*
                     * We need 2 CIDFonts.
                     * Make a copy of the CIDFont so we can access rotated
                     * glyphs.
                     */
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /%s%s T42CIDCPR",
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_R],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);

                    /* Now create a CID-Keyed Font using the two CIDFonts. */
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /%s [/%s%s /%s%s] composefont pop",
                                pUFObj->pszFontName,
                                newCMapName,
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_R]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);
                }
                else
                {
                    /*
                     * We need 4 CIDFonts.
                     * Make copies of the CIDFont so we can access 32K+ glyphs.
                     */
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "%lu dup 1 sub %lu IDStr2 /%s%s /%s%s T42CIDCP32K",
                                cidCount - (long)NUM_32K_1, (long)NUM_32K_1,
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32K],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /%s%s T42CIDCPR",
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_R],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /%s%s T42CIDCPR",
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32KR],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32K]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);

                    /*
                     * Now create a CID-Keyed Font using the four CIDFonts.
                     */
                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /%s [/%s%s ",
                                pUFObj->pszFontName, newCMapName,
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX]);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /%s%s /%s%s] composefont pop",
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_R],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32K],
                                pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32KR] );
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);
                }
            }
            else
            {
                /*
                 * %hostfont% support
                 * CIDMap bug has to be fixed on HostFont capable RIP. No need
                 * to split glyphs in multiple CIDFonts even if the numbers of
                 * the glyphs are greater than 32K.
                 */

                UFLsprintf(strmbuf, CCHOF(strmbuf), "%%%%IncludeResource: CIDFont %s", pHostFontName);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);

                /*
                 * Fix 384736: GDI and %hostfont%-RIP get ascender and
                 * descender values from different tables; GDI gets them from
                 * 'OS/2' or 'hhea' vs. %hostfont%-RIP gets them from 'vhea' or
                 * 'hhea'. This causes the output on the screen and ink from
                 * %hostfont%-RIP different. To adjust 'the policy difference'
                 * with three types of real-world CJK TrueType fonts -
                 *   1) the good, which has 'vhea' and 'vmtx', and ascender and
                 *      descender values are consistent throughout 'OS/2',
                 *      'vhea', and 'hhea' tables.
                 *   2) the bad, which doesn't have 'vhea' and/or 'vmtx' tables.
                 *   3) the ugry, which has 'vhea' and/or 'vmtx' tables but
                 *      their ascender and descender values are inconsistent
                 *      throughout 'OS/2', 'vhea', and 'hhea' tables.
                 * - the driver needs to change glyph metrics by installing
                 * either special CDevProc for 3 or adjusted FontMatrix for 2.
                 */
                {
                    long    em, w1y, vx, vy, tsb, vasc;
                    UFLBool bUseDef;

                    UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s ", pHostFontName, gcidSuffix[CIDSUFFIX]);

                    if (kNoErr == retVal)
                        retVal = StrmPutString(stream, strmbuf);

                    GetMetrics2FromTTF(pUFObj, 0, &em, &w1y, &vx, &vy, &tsb, &bUseDef, 1, &vasc);

                    if (pUFObj->pAFont->hasvmtx && (vy != vasc))
                    {
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "%ld %ld sub %ld div", vy, vasc, em);
                    }
                    else if (!pUFObj->pAFont->hasvmtx)
                    {
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "{5{pop}repeat 0 -1 %ld %ld div %ld %ld div}bind", vx, em, vy, em);
                    }
                    else
                    {
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "true");
                    }

                    if (kNoErr == retVal)
                        retVal = StrmPutString(stream, strmbuf);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), " /%s hfDef42CID", pHostFontName);
                }

                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);

                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /%s hfDefRT42CID",
                            pUFObj->pszFontName, gcidSuffix[CIDSUFFIX_R],
                            pHostFontName);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);

                UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /%s [/%s%s /%s%s] composefont pop",
                           pUFObj->pszFontName,
                           newCMapName,
                           pHostFontName, gcidSuffix[CIDSUFFIX],
                           pUFObj->pszFontName, gcidSuffix[CIDSUFFIX_R]);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);
            }

            if (newCMapName)
                UFLDeletePtr(pUFObj->pMem, newCMapName);
        }
    }
    else if (HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * %hostfont% support
         * Redefine the font using the already existing TrueType host font with
         * a unque name so that we can reencode its encoding vector freely. We
         * want empty CharStrings so that we give true to hfRedefFont.
         */
        UFLsprintf(strmbuf, CCHOF(strmbuf), "\n%%%%IncludeResource: font %s", pHostFontName);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);

        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s true /%s hfRedefFont", pUFObj->pszFontName, pHostFontName);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // The TrueType font has been Downloaded and defined. Cleanup mess.
    //
    //////////////////////////////////////////////////////////////////////////

    if ((kNoErr == retVal) && bFullFont)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pStringLength);
        pFont->pStringLength = nil;
    }

    if (pFont->pMinSfnt)
    {
        UFLDeletePtr(pUFObj->pMem, pFont->pMinSfnt);
        pFont->pMinSfnt = nil;
    }

    /*
     * Free buffers allocated when error occurred. (bug #293130)
     */
    if (kNoErr != retVal)
    {
       if (pFont->pHeader != nil)
          UFLDeletePtr(pUFObj->pMem, pFont->pHeader);
       pFont->pHeader = nil;

       if (pFont->pStringLength != nil)
          UFLDeletePtr(pUFObj->pMem, pFont->pStringLength);
       pFont->pStringLength = nil;

       if (pFont->pLocaTable != nil)
          UFLDeletePtr(pUFObj->pMem, pFont->pLocaTable);
       pFont->pLocaTable = nil;

       if (pFont->pRotatedGlyphIDs != nil)
          UFLDeletePtr(pUFObj->pMem, pFont->pRotatedGlyphIDs);
       pFont->pRotatedGlyphIDs = nil;
    }

    /*
     * Change the font state.
     */
    if (kNoErr == retVal)
    {
        if (pUFObj->flState == kFontInit2)
        {
            /* This is a duplicate so that it should have char(s). */
            pUFObj->flState = kFontHasChars;
        }
        else
            pUFObj->flState = kFontHeaderDownloaded;
    }

    return retVal;
}


/*=============================================================================*
 *                      PutT42Char and its sub functions                       *
 *=============================================================================*/

UFLErrCode
T42UpdateCIDMap(
    UFOStruct       *pUFObj,
    unsigned short  wGlyfIndex,
    unsigned short  cid,
    char            *cidFontName,
    UFLHANDLE       stream,
    char            *strmbuf,
    size_t          cchstrmbuf
    )
{
    UFLErrCode    retVal = kNoErr;

    /* (2 * cid) is the BYTE-index in CIDMap. */
    UFLsprintf(strmbuf, cchstrmbuf, "%ld ", (long)(2 * cid));
    retVal = StrmPutString(stream, strmbuf);

    if (retVal == kNoErr)
        retVal = StrmPutWordAsciiHex(stream, wGlyfIndex);

    UFLsprintf(strmbuf, cchstrmbuf, " /%s UpdateCIDMap", cidFontName);
    if (retVal == kNoErr)
        retVal = StrmPutStringEOL(stream, strmbuf);

    return retVal;
}


UFLErrCode
AddT42vmtxEntry(
    UFOStruct       *pUFObj,
    unsigned short  wGlyfIndex,
    unsigned short  cid,
    char            *cidFontName,
    UFLHANDLE       stream,
    char            *strmbuf,
    size_t          cchstrmbuf
    )
{
    T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    UFLErrCode    retVal = kNoErr;
    long          em, w1y, vx, vy, tsb, vasc;
    UFLBool       bUseDef;

    /*
     * Add vertical metrics array Metrics2 for every glyph regardless of
     * writing mode (Fix #351487) if its 'vmtx' exists.
     *
     * The elements of Metrics2 array should basically look like this:
     *
     *  [0  -AdvanceHeight/EM   Descender/EM   Ascender/EM]
     *
     * But, to support both fixed and proportional fonts universally we set
     * TopSideBearing/EM as vy instead and add ury to it in CDevProc. So the
     * array now looks like this:
     *
     *  [0  -AdvanceHeight/EM  Descender/EM  TopSideBearing/EM]
     *
     * In CDevProc TopSideBearing/EM and ury are added to get real vy value
     * for the glyph. See the code emitting /CDevProc in the T42CreateBaseFont
     * function above for the details.
     */

    if (pUFObj->pAFont->hasvmtx)
    {
        GetMetrics2FromTTF(pUFObj, wGlyfIndex, &em, &w1y, &vx, &vy, &tsb, &bUseDef, 0, &vasc);

        UFLsprintf(strmbuf, cchstrmbuf,
                   "%ld [0 %ld %ld div %ld %ld div %ld %ld div] /%s T0AddT42Mtx2",
                   (long)cid, -w1y, em, vx, em, tsb, em, cidFontName);

        retVal = StrmPutStringEOL(stream, strmbuf);
    }

    return retVal;
}


unsigned short
GetCIDAndCIDFontName(
    UFOStruct       *pUFObj,
    unsigned short  wGid,
    char            *cidFontName,
    size_t          cchFontName
    )

/*++

Routine Description:
    Retunrs cid - a number and the cidFontName.

--*/

{
    T42FontStruct   *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned short  cid    = 0;

    if (IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat))
    {
        /*
         * For CID-Keyed font, we control the CIDFont name.
         */
        if (pFont->info.bUseIdentityCMap && (wGid > NUM_32K_1))
        {
            /*
             * 32K+ glyphs are re-mapped to the 32K CIDFont.
             */
            UFLsprintf(cidFontName, cchFontName, "%s%s",
                        pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX_32K]);

            cid = (unsigned short)((long)wGid-(long)NUM_32K_1);
        }
        else
        {
            UFLsprintf(cidFontName, cchFontName, "%s%s", pFont->info.CIDFontName, gcidSuffix[CIDSUFFIX]);

            cid = wGid;
        }
    }
    else
    {
        UFLsprintf(cidFontName, cchFontName, "%s", pUFObj->pszFontName);

        /*
         * Don't know how to assign a CID. Return zero.
         */
    }

    return cid;
}


UFLErrCode
PutT42Char(
    UFOStruct       *pUFObj,
    unsigned short  wGlyfIndex,
    unsigned short  wCid,
    COMPOSITEGLYPHS *pCompGlyphs,
    char            *strmbuf,
    size_t          cchstrmbuf
    )
{
    T42FontStruct  *pFont       = (T42FontStruct *)pUFObj->pAFont->hFont;
    unsigned long  *glyphRanges = pFont->pStringLength;
    UFLHANDLE      stream       = pUFObj->pUFL->hOut;
    UFLErrCode     retVal       = kNoErr;
    UFLBool        bMoreComp    = 0;

    unsigned short cid, i, wIndex, wCompFlags;
    unsigned long  glyphOffset, glyphLength;
    char           *pGlyph;
    char           *pCompTmp;
    char           cidFontName[64];

    if (wGlyfIndex > UFO_NUM_GLYPHS(pUFObj))
    {
        /*
         * If the requested glyph is out of range, pretend it is downloaded
         * without error.
         */
        return kNoErr;
    }

    /* indexToLocFormat contains 0 for short offsets and 1 for long. */
    if (pFont->headTable.indexToLocFormat)
    {
        unsigned long PTR_PREFIX *locationTable = (unsigned long PTR_PREFIX *)pFont->pLocaTable;

        /*
         * Bad font protection: some fonts have bad 'loca' data for a few
         * glyphs. These bad glyphs will be treated as /.notdef.
         */
        // if (MOTOROLALONG(locationTable[wGlyfIndex + 1]) < MOTOROLALONG(locationTable[wGlyfIndex]))
        //    return kNoErr;

        /* Get the offset to the glyph from the beginning of the glyf table. */
        glyphOffset = MOTOROLALONG(locationTable[wGlyfIndex]);

        if ((MOTOROLALONG(locationTable[wGlyfIndex + 1]) < MOTOROLALONG(locationTable[wGlyfIndex]))
            || ((MOTOROLALONG(locationTable[wGlyfIndex + 1]) - MOTOROLALONG(locationTable[wGlyfIndex])) > 16384L))
        {
            glyphLength = GetLenByScanLoca(locationTable,
                                            wGlyfIndex,
                                            UFO_NUM_GLYPHS(pUFObj),
                                            pFont->headTable.indexToLocFormat);
        }
        else
        {
            glyphLength = (unsigned long)MOTOROLALONG(locationTable[wGlyfIndex + 1]) - glyphOffset;
        }
    }
    else
    {
        unsigned short PTR_PREFIX *locationTable = (unsigned short PTR_PREFIX*)pFont->pLocaTable;

        /*
         * Bad font protection: some fonts have bad 'loca' data for a few
         * glyphs. These bad glyphs will be treated as /.notdef.
         * /
        // if (MOTOROLAINT(locationTable[wGlyfIndex + 1]) < MOTOROLAINT(locationTable[wGlyfIndex]))
        //    return kNoErr;

        /* Get the offset to the glyph from the beginning of the glyf table. */
        glyphOffset = (unsigned long)MOTOROLAINT(locationTable[wGlyfIndex]) * 2;

        if ((MOTOROLAINT(locationTable[wGlyfIndex + 1]) < MOTOROLAINT(locationTable[wGlyfIndex]))
            || ((MOTOROLAINT(locationTable[wGlyfIndex + 1]) - MOTOROLAINT(locationTable[wGlyfIndex])) > 16384))
        {
            glyphLength = GetLenByScanLoca(locationTable,
                                            wGlyfIndex,
                                            UFO_NUM_GLYPHS(pUFObj),
                                            pFont->headTable.indexToLocFormat);
        }
        else
        {
            glyphLength = (unsigned long)MOTOROLAINT(locationTable[wGlyfIndex + 1]) * 2 - glyphOffset;
        }
    }

    /*
     * GlyphIndices that have no glyph description point to the same offset.
     * So, GlyphLength becomes 0. Handle these as special cases for 2015 and
     * pre-2015.
     */
    if (!glyphLength)
    {
        /* Send parameters for /AddT42Char procedure. */
        retVal = StrmPutStringEOL(stream, nilStr);

        /*
         * Locate /sfnts string number in which the glyph occurs and offset of
         * the glyph in "that" string.
         */
        for (i = 1; glyphRanges[i] != 0; i++)
        {
            if (glyphOffset < glyphRanges[i])
            {
                i--;  /* Gives the "actual" string index (as opposed to string number). */
                break;
            }
        }

        /*
         * Send index of /sfnts string in which this glyph belongs. Check if a
         * valid index i was found.
         */
        if (glyphRanges[i] == 0)
        {
            /*
             * Oops, this should not have happened. But it will with Monotype
             * Sorts or any font whose last few glyphs are not defined.
             * Roll back i to point to glyph index 0, the bullet character.
             * Anyway, it does not matter where this glyph (with no description)
             * points to, really. Only 2015 needs a real entry in /GlyphDirectory,
             * even for glyphs with no description, ie, the entry:
             * /GlyphIndex  < >  def  in the dict /GlyphDirectory.
             */
            i = 0;
            glyphOffset = 0;
        }

        retVal = StrmPutInt(stream, pFont->cOtherTables + i);
        if (kNoErr == retVal)
            retVal = StrmPutString(stream, " ");

        /* Send offset of the glyph in the particular /sfnts string. */
        if (kNoErr == retVal)
            retVal = StrmPutInt(stream, glyphOffset - glyphRanges[i]);
        if (kNoErr == retVal)
            retVal = StrmPutString(stream, " ");

        /* Send the glyph index. */
        if (kNoErr == retVal)
            retVal = StrmPutInt(stream, wGlyfIndex);

        if (kNoErr == retVal)
            retVal = StrmPutString(stream, " <> ");

        if (IS_TYPE42CID(pUFObj->lDownloadFormat))
        {
            cid = GetCIDAndCIDFontName(pUFObj, wGlyfIndex, cidFontName, CCHOF(cidFontName));

            UFLsprintf(strmbuf, cchstrmbuf, "/%s T0AddT42Char ", cidFontName);
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);

            if (!pFont->info.bUseIdentityCMap)
                cid = wCid;

            AddT42vmtxEntry(pUFObj, wGlyfIndex, wCid, cidFontName, stream, strmbuf, cchstrmbuf);

            if (pFont->info.bUpdateCIDMap)
                T42UpdateCIDMap(pUFObj, wGlyfIndex, wCid, cidFontName, stream, strmbuf, cchstrmbuf);
        }
        else
        {
            UFLsprintf(strmbuf, cchstrmbuf, "/%s AddT42Char ", pUFObj->pszFontName);
            if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);
        }

        return retVal;
    }  /* if ( !glyphLength )  */


    /*
     * Get the physical glyph data to lpGlyph.
     */
    pGlyph = (char *)UFLNewPtr(pUFObj->pMem, glyphLength);

    if (pGlyph == nil)
        retVal = kErrOutOfMemory;

    if (0 == GETTTFONTDATA(pUFObj,
                            GLYF_TABLE, glyphOffset,
                            pGlyph, glyphLength,
                            pFont->info.fData.fontIndex))
    {
        retVal = kErrGetFontData;
    }

    /*
     * Handle Composite Characters.
     */
    if ((kNoErr == retVal) && (*((short *)pGlyph) == MINUS_ONE))
    {
        pCompTmp  = pGlyph;
        pCompTmp += 10; /* Move to beginning of glyph description. */

        do
        {
            wCompFlags = MOTOROLAINT(*((unsigned short *)pCompTmp));
            wIndex     = MOTOROLAINT(((unsigned short *)pCompTmp)[1]);

            /*
             * Download the first "component" glyph of this composite
             * character.
             */
            if ((wIndex < UFO_NUM_GLYPHS(pUFObj))
                 && !IS_GLYPH_SENT( pUFObj->pAFont->pDownloadedGlyphs, wIndex))
            {
                if (pFont->info.bUseIdentityCMap)
                {
                    if (wIndex > NUM_32K_1)
                    {
                        /* 32K+ glyphs are re-mapped to the 32K CIDFont. */
                        cid = (unsigned short)((long)wIndex - (long)NUM_32K_1);
                    }
                    else
                    {
                        cid = wIndex;
                    }
                }
                else
                    cid = 0; /* Don't know the wCid. */

                retVal = PutT42Char(pUFObj, wIndex, cid, pCompGlyphs, strmbuf, cchstrmbuf);

                if (retVal == kNoErr)
                {
                    SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pDownloadedGlyphs, wIndex);

                    /*
                     * If we ran out of space to keep track of the composite
                     * componets then allocate more space.
                     */
                    if ((pCompGlyphs->sCount >= pCompGlyphs->sMaxCount)
                        && (pCompGlyphs->pGlyphs != nil))
                    {
                        short sEnlargeSize = pCompGlyphs->sMaxCount + 50;

                        if (UFLEnlargePtr(pUFObj->pMem,
                                            (void **)&pCompGlyphs->pGlyphs,
                                            (sEnlargeSize * sizeof (unsigned short)), 1))
                        {
                            pCompGlyphs->sMaxCount = sEnlargeSize;
                        }
                        else
                        {
                            /*
                             * For some reason we can't get more space.
                             * Then just don't do this at all.
                             */
                            UFLDeletePtr(pUFObj->pMem, pCompGlyphs->pGlyphs);

                            pCompGlyphs->pGlyphs = nil;
                            pCompGlyphs->sCount = pCompGlyphs->sMaxCount = 0;
                        }
                    }

                    /*
                     * Remember which composite glyph componet we downloaded.
                     */
                    if (pCompGlyphs->pGlyphs)
                    {
                        *(pCompGlyphs->pGlyphs + pCompGlyphs->sCount) = wIndex;
                        pCompGlyphs->sCount++;
                    }
                }
            }

            /*
             * Check for other components in this composite character.
             */
            if ((kNoErr == retVal) && (wCompFlags & MORE_COMPONENTS))
            {
                bMoreComp = 1;

                /*
                 * Find out how far we need to advance lpCompTmp to get to next
                 * component of the composite character.
                 */
                if (wCompFlags & ARG_1_AND_2_ARE_WORDS)
                    pCompTmp += 8;
                else
                    pCompTmp += 6;

                /*
                 * Check what kind of scaling is done on the glyph component.
                 */
                if (wCompFlags & WE_HAVE_A_SCALE)
                {
                    pCompTmp += 2;
                }
                else
                {
                    if (wCompFlags & WE_HAVE_AN_X_AND_Y_SCALE)
                    {
                        pCompTmp += 4;
                    }
                    else
                    {
                        if (wCompFlags & WE_HAVE_A_TWO_BY_TWO)
                            pCompTmp += 8;
                    }
                }
            }
            else
            {
                bMoreComp = 0;
            }

        } while (bMoreComp && (kNoErr == retVal)); /* do~while loop */
    } /* If composite character */

    /*
     * Locate /sfnts string number in which the glyph occurs and offset of
     * the glyph in "that" string.
     */
    if (kNoErr == retVal)
    {
        i = 1;
        while (glyphRanges[i] != 0)
        {
            if (glyphOffset < glyphRanges[i])
            {
                i--; /* Gives the "actual" string index (as opposed to string number). */
                break;
            }
            i++; /* Go to the next string and check if Glyph belongs there. */
        }
    }

    /* Send index of /sfnts string in which this glyph belongs. */
    if (kNoErr == retVal)
        retVal = StrmPutInt(stream, pFont->cOtherTables + i);
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, " ");

    /* Send offset of the glyph in the particular /sfnts string. */
    if (kNoErr == retVal)
        retVal = StrmPutInt(stream, glyphOffset-glyphRanges[i]);
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, " ");

    /* Send the glyph index. */
    if (kNoErr == retVal)
        retVal = StrmPutInt(stream, wGlyfIndex);
    if (kNoErr == retVal)
        retVal = StrmPutString(stream, " ");


    /* Download the glyph in binary (or) AsciiHex format. */
    if (kNoErr == retVal)
    {
        if (StrmCanOutputBinary(stream))
        {
            retVal = StrmPutInt(stream, glyphLength);

            if (kNoErr == retVal)
                retVal = StrmPutString(stream, RDString);
            if (kNoErr == retVal)
                retVal = StrmPutBytes(stream, pGlyph, (UFLsize_t)glyphLength, 0);
        }
        else
        {
            retVal = StrmPutString(stream, "<");

            if (kNoErr == retVal)
                retVal = StrmPutAsciiHex(stream, pGlyph, glyphLength);
            if (kNoErr == retVal)
                retVal = StrmPutString(stream, ">");
        }
    }

    if (IS_TYPE42CID(pUFObj->lDownloadFormat))
    {
        cid = GetCIDAndCIDFontName(pUFObj, wGlyfIndex, cidFontName, CCHOF(cidFontName));

        UFLsprintf(strmbuf, cchstrmbuf, "/%s T0AddT42Char ", cidFontName);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);

        if (!pFont->info.bUseIdentityCMap)
            cid = wCid;

        AddT42vmtxEntry(pUFObj, wGlyfIndex, cid, cidFontName, stream, strmbuf, cchstrmbuf);

        if (pFont->info.bUpdateCIDMap)
            T42UpdateCIDMap(pUFObj, wGlyfIndex, wCid, cidFontName, stream, strmbuf, cchstrmbuf);

    }
    else
    {
        UFLsprintf(strmbuf, cchstrmbuf, "/%s AddT42Char ", pUFObj->pszFontName);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, strmbuf);
    }

    if (pGlyph)
    {
        UFLDeletePtr(pUFObj->pMem, pGlyph);
        pGlyph = nil;
    }

    return retVal;
}


UFLErrCode
T42AddChars(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs
    )
{
    UFLHANDLE       stream      = pUFObj->pUFL->hOut;
    UFLErrCode      retVal      = kNoErr;
    unsigned short  cid         = 0;
    short           totalGlyphs = 0;

    unsigned short  wIndex;
    UFLGlyphID      *glyphs;
    COMPOSITEGLYPHS compGlyphs;
    char            strmbuf[128];
    short           i;

    /*
     * Save a copy of Downloaded glpyh list. This is used to update CharStrings
     * later.
     */
    UFLmemcpy((const UFLMemObj*)pUFObj->pMem,
              pUFObj->pAFont->pVMGlyphs,
              pUFObj->pAFont->pDownloadedGlyphs,
              (UFLsize_t)(GLYPH_SENT_BUFSIZE(UFO_NUM_GLYPHS(pUFObj))));

    /*
     * Keep track of composite glyphs that might of been downloaded.
     */
    compGlyphs.sMaxCount = pGlyphs->sCount * 2;
    compGlyphs.sCount    = 0;

    /*
     * Update the charstring uses GoodNames only if the Encoding vector is nil.
     */
    if(pUFObj->pszEncodeName == nil)
        compGlyphs.pGlyphs = nil;
    else
        compGlyphs.pGlyphs = (unsigned short *)UFLNewPtr(pUFObj->pMem,
                                                         compGlyphs.sMaxCount * sizeof (unsigned short));

    if (compGlyphs.pGlyphs == nil)
        compGlyphs.sMaxCount = 0;

    /*
     * The main loop for downloading the glyphs of the given string.
     */
    glyphs = pGlyphs->pGlyphIndices;

    for (i = 0; kNoErr == retVal && i < pGlyphs->sCount; i++)
    {
        /* LOWord is the real GID. */
        wIndex = (unsigned short)(glyphs[i] & 0x0000FFFF);

        if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
            continue;

        if (!IS_GLYPH_SENT(pUFObj->pAFont->pDownloadedGlyphs, wIndex))
        {
            if (pGlyphs->pCharIndex)
                cid = pGlyphs->pCharIndex[i];

            if (!HOSTFONT_IS_VALID_UFO(pUFObj))
                retVal = PutT42Char(pUFObj, wIndex, cid, &compGlyphs, strmbuf, CCHOF(strmbuf));

            SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pDownloadedGlyphs, wIndex);
            totalGlyphs++;
        }
    }

    /*
     * Make sure that .notdef is sent.
     */
    if ((kNoErr == retVal) && (pUFObj->flState >= kFontInit))
    {
        if (!IS_GLYPH_SENT(pUFObj->pAFont->pDownloadedGlyphs, 0))
        {
            cid = 0; /* Don't know its CID. */

            if (!HOSTFONT_IS_VALID_UFO(pUFObj))
                retVal = PutT42Char(pUFObj, 0x0000, cid, &compGlyphs, strmbuf, CCHOF(strmbuf));

            if (kNoErr == retVal)
            {
                SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pDownloadedGlyphs, 0);
                totalGlyphs++;
            }
        }
    }

    /*
     * Update the charstring uses GoodNames if the Encoding vector is nil.
     */
    if ((kNoErr == retVal) && (pUFObj->pszEncodeName == nil) && (totalGlyphs > 0))
    {
        /*
         * Begin CharStirng re-encoding.
         */

        UFLBool  bAddCompGlyphAlternate = 0;
        UFLBool  bGoodName;
        char     *pGoodName;

        retVal = StrmPutString(stream, "/");
        if (kNoErr == retVal)
            retVal = StrmPutString(stream, pUFObj->pszFontName);
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, " findfont /CharStrings get begin");

        /*
         * If we ran out of space in keeping with Composite Glyph Component,
         * then add composite component to Encoding the long way.
         */
        if (!compGlyphs.pGlyphs)
        {
            bAddCompGlyphAlternate = 1;
            compGlyphs.sCount = compGlyphs.sMaxCount =0;
        }

        /*
         * Update the CharStrings with all of the newly added Glyphs.
         * First go through the Main Glyph Index arrays.
         */
        for (i = 0; (kNoErr == retVal) && (i < (pGlyphs->sCount + compGlyphs.sCount)); i++)
        {
            /*
             * Get glyph index from either the regular glyphs list or the
             * composite list. LOWord is the read GID in either case.
             */

            if (i < pGlyphs->sCount)
                wIndex = (unsigned short)(glyphs[i] & 0x0000FFFF);
            else
                wIndex = (unsigned short)(compGlyphs.pGlyphs[i - pGlyphs->sCount] & 0x0000FFFF);

            if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
                continue;

            if ((0 == pUFObj->pUFL->bDLGlyphTracking)
                || (pGlyphs->pCharIndex == nil)    // DownloadFace
                || (pUFObj->pEncodeNameList)       // DownloadFace
                || !IS_GLYPH_SENT(pUFObj->pAFont->pVMGlyphs, wIndex))
            {
                bGoodName = FindGlyphName(pUFObj, pGlyphs, i, wIndex, &pGoodName);

                /* Fix bug 274008: check Glyph Name only for DownloadFace. */
                if (pUFObj->pEncodeNameList)
                {
                    if ((UFLstrcmp(pGoodName, Hyphen) == 0) && (i == 45))
                    {
                        /* Add /minus to CharString. */
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s %d def", Minus, wIndex);
                        if (kNoErr == retVal)
                            retVal = StrmPutStringEOL(stream, strmbuf);
                    }

                    if ((UFLstrcmp(pGoodName, Hyphen) == 0) && (i == 173))
                    {
                        /* Add /sfthyphen to CharString. */
                        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s %d def", SftHyphen, wIndex);
                        if (kNoErr == retVal)
                            retVal = StrmPutStringEOL(stream, strmbuf);
                    }

                    if (!ValidGlyphName(pGlyphs, i, wIndex, pGoodName))
                        continue;

                    /* Send only one ".notdef". */
                    if ((UFLstrcmp(pGoodName, Notdef) == 0)
                        && (wIndex == (unsigned short)(glyphs[0] & 0x0000FFFF))
                        && IS_GLYPH_SENT(pUFObj->pAFont->pVMGlyphs, wIndex))
                        continue;
                }

                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, "/");
                if (kNoErr == retVal)
                    retVal = StrmPutString(stream, pGoodName);

                UFLsprintf(strmbuf, CCHOF(strmbuf), " %d def", wIndex);
                if (kNoErr == retVal)
                    retVal = StrmPutStringEOL(stream, strmbuf);

                SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pVMGlyphs, wIndex);

                if (bGoodName)
                    SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pCodeGlyphs, wIndex);
            }
        }

        /*
         * Do composite font this way only if we ran out of space.
         */
        if (bAddCompGlyphAlternate)
        {
            /*
             * Now go through all VMGlyphs to see if there is any glyph are
             * downloaded as part of Composite glyph above. - fix bug 217228.
             * PPeng, 6-12-1997
             */
            for (wIndex = 0;
                 (kNoErr == retVal) && (wIndex < UFO_NUM_GLYPHS(pUFObj));
                 wIndex++)
            {
                if ((0 == pUFObj->pUFL->bDLGlyphTracking)
                    /* || (pGlyphs->pCharIndex == nil) */
                    || (IS_GLYPH_SENT(pUFObj->pAFont->pDownloadedGlyphs, wIndex)
                    && !IS_GLYPH_SENT(pUFObj->pAFont->pVMGlyphs, wIndex)))
                {
                    /*
                     * For composite glyphs, always try to use its good name.
                     */
                    pGoodName = GetGlyphName(pUFObj,
                                             (unsigned long)wIndex,
                                             nil,
                                             &bGoodName);

                    retVal = StrmPutString(stream, "/");

                    if (kNoErr == retVal)
                        retVal = StrmPutString(stream, pGoodName);

                    UFLsprintf(strmbuf, CCHOF(strmbuf), " %d def", wIndex);
                    if (kNoErr == retVal)
                        retVal = StrmPutStringEOL(stream, strmbuf);

                    SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pVMGlyphs, wIndex);
                }
            }
        }

        /*
         * End CharStirng re-encoding.
         */
        if (kNoErr == retVal)
            retVal = StrmPutStringEOL(stream, "end");
    }

    /*
     * Update the Encoding vector if we use GoodNames.
     */
    if ((kNoErr == retVal) && (pUFObj->pszEncodeName == nil) && (pGlyphs->sCount > 0))
    {
        /*
         * Check pUFObj->pUpdatedEncoding to see if we really need to update it.
         */
        for (i = 0; i < pGlyphs->sCount; i++)
        {
            if ((0 == pUFObj->pUFL->bDLGlyphTracking)
                || (pGlyphs->pCharIndex == nil) // DownloadFace
                || (pUFObj->pEncodeNameList)    // DownloadFace
                || !IS_GLYPH_SENT(pUFObj->pUpdatedEncoding, pGlyphs->pCharIndex[i]))
            {
                /* Found at least one not updated, do it (once) for all. */
                retVal = UpdateEncodingVector(pUFObj, pGlyphs, 0, pGlyphs->sCount);
                break;
            }
        }
    }

    /*
     * Update the FontInfo with Unicode information.
     */
    if ((kNoErr == retVal)
        && (pGlyphs->sCount > 0)
        && (pUFObj->dwFlags & UFO_HasG2UDict)
        && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * Check pUFObj->pAFont->pCodeGlyphs to see if we really need to update
         * it.
         */
        for (i = 0; i < pGlyphs->sCount; i++)
        {
            /* LOWord is the real GID. */
            wIndex = (unsigned short)(glyphs[i] & 0x0000FFFF);

            if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
                continue;

            if (!IS_GLYPH_SENT(pUFObj->pAFont->pCodeGlyphs, wIndex))
            {
                /* Found at least one not updated, do it (once) for all. */
                retVal = UpdateCodeInfo(pUFObj, pGlyphs, 0);
                break;
            }
        }
    }

    if (compGlyphs.pGlyphs)
    {
        UFLDeletePtr(pUFObj->pMem, compGlyphs.pGlyphs);
        compGlyphs.pGlyphs = nil;
    }

    /*
     * Downloading glyph(s) is done. Change the font state.
     */
    if (kNoErr ==retVal)
        pUFObj->flState = kFontHasChars;

    return retVal;
}


UFLErrCode
T42VMNeeded(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    )
{
    T42FontStruct   *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    UFLErrCode      retVal = kNoErr;
    unsigned long   vmUsed = 0;
    UFLBool         bFullFont;
    UFLGlyphID      *glyphs;

    if (pUFObj->flState < kFontInit)
        return kErrInvalidState;

    if ((pGlyphs == nil) || (pGlyphs->pGlyphIndices == nil) || (pVMNeeded == nil))
        return kErrInvalidParam;

    *pVMNeeded = 0;

    if (pFCNeeded)
        *pFCNeeded = 0;

    glyphs = pGlyphs->pGlyphIndices;

    bFullFont = (pGlyphs->sCount == -1) ? 1 : 0;

    if ((0 == pFont->minSfntSize) || (pFont->pHeader == nil))
        retVal = GetMinSfnt(pUFObj, bFullFont);

    if (kNoErr == retVal)
    {
        unsigned long totalGlyphs = 0;

        /*
         * Scan the list, check what characters that we have downloaded.
         */
        if (!bFullFont)
        {
            short i;

            UFLmemcpy((const UFLMemObj *)pUFObj->pMem,
                        pUFObj->pAFont->pVMGlyphs,
                        pUFObj->pAFont->pDownloadedGlyphs,
                        (UFLsize_t)(GLYPH_SENT_BUFSIZE(UFO_NUM_GLYPHS(pUFObj))));

            for (i = 0; i < pGlyphs->sCount; i++)
            {
                /* LOWord is the real GID. */
                unsigned short wIndex = (unsigned short)(glyphs[i] & 0x0000FFFF);

                if (wIndex >= UFO_NUM_GLYPHS(pUFObj))
                    continue;

                if (!IS_GLYPH_SENT( pUFObj->pAFont->pVMGlyphs, wIndex))
                {
                    SET_GLYPH_SENT_STATUS(pUFObj->pAFont->pVMGlyphs, wIndex);
                    totalGlyphs++;
                }
            }
        }
        else
        {
            totalGlyphs = UFO_NUM_GLYPHS(pUFObj);
        }

        /*
         * Start with the size of the minimal sfnt if the header has not been
         * sent yet.
         */
        if (pUFObj->flState < kFontHeaderDownloaded)
        {
            vmUsed = pFont->minSfntSize;
        }

        /*
         * If incremental downloading and there are glyphs to check, add these
         * to total VMUsage of each glyph is the average size of each glyph in
         * the glyf table.
         */
        if (bFullFont == 0)
        {
            if (GETPSVERSION(pUFObj) < 2015)
            {
                /*
                 * For pre2015 printers, we need to pre-allocate VM for all
                 * Glyphs. The VM for whole font is allocated when the Header
                 * is Sent.
                 */
                if (pUFObj->flState < kFontHeaderDownloaded)
                {
                    vmUsed += GetGlyphTableSize(pUFObj);
                }
                else
                {
                    /*
                     * After header is sent on pre-2015 printer, no more VM
                     * allocation for adding chars, so set to 0 -- VM for both
                     * Header and Glyph table are allocate already!
                     */
                    vmUsed = 0;
                }
            }
            else
            {
                if (glyphs != nil)
                {
                    /* Check if this has been calculated yet. */
                    if (pFont->averageGlyphSize == 0)
                        GetAverageGlyphSize(pUFObj);

                    /* If this is still zero, there's a problem with the sfnt. */
                    if (pFont->averageGlyphSize == 0)
                        retVal = kErrBadTable;
                    else
                        vmUsed += totalGlyphs * pFont->averageGlyphSize;

                    /*
                     * Fix bug 256940: make it compatible with 95 driver.
                     * jjia 7/2/98
                     */
                    if ((IS_TYPE42CID(pUFObj->lDownloadFormat))
                        && (pUFObj->flState < kFontHeaderDownloaded))
                    {
                        vmUsed += (UFO_NUM_GLYPHS(pUFObj)) * 2;
                    }
                }
            }
        }

        if ((kNoErr == retVal) && !HOSTFONT_IS_VALID_UFO(pUFObj))
            *pVMNeeded = VMT42RESERVED(vmUsed);
    }

    return retVal;
}


#if 0

/*
 * Currently this function is not called from any place.
 */

UFLErrCode
DownloadFullFont(
    UFOStruct *pUFObj
    )
{
    UFLErrCode retVal = kNoErr;

    /*
     * Can only download full font if no header has been downloaded before.
     * The only possible state that meets this requirement is kFontInit.
     */
    if (pUFObj->flState != kFontInit)
        return kErrInvalidState;

    /* Create and download the full font. */
    retVal = T42CreateBaseFont(pUFObj, nil, nil, 1);

    if (retVal == kNoErr)
        pUFObj->flState = kFontFullDownloaded;

    return retVal;
}

#endif


/******************************************************************************
 *
 *                          T42FontDownloadIncr
 *
 *    Function: Adds all of the characters from pGlyphs that aren't already
 *              downloaded for the TrueType font.
 *
 ******************************************************************************/

UFLErrCode
T42FontDownloadIncr(
    UFOStruct           *pUFObj,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    )
{
    UFLErrCode  retVal          = kNoErr;
    char        *pHostFontName  = nil;

    if (pFCUsage)
        *pFCUsage = 0;

    /*
     * Sanity checks.
     */
    if (pUFObj->flState < kFontInit)
        return kErrInvalidState;

    if ((pGlyphs == nil) || (pGlyphs->pGlyphIndices == nil) || (pGlyphs->sCount == 0))
       return kErrInvalidParam;

    /*
     * No need to download if the full font has already been downloaded.
     */
    if (pUFObj->flState == kFontFullDownloaded)
        return kNoErr;

    /*
     * Check %hostfont% status prior to download anything.
     */
    HostFontValidateUFO(pUFObj, &pHostFontName);

    /*
     * Check the VM usage - before sending the Header. On Pre-2015 printers,
     * VMUsage is 0 after the header is downloaded (pre-allocate).
     */
    if (!HOSTFONT_IS_VALID_UFO(pUFObj))
        retVal = T42VMNeeded(pUFObj, pGlyphs, pVMUsage, nil); /* nil for pFCUsage */

    /*
     * Create a base font if it has not been done yet.
     */
    if (pUFObj->flState == kFontInit)
        retVal = T42CreateBaseFont(pUFObj, pGlyphs, pVMUsage, 0, pHostFontName);

    /*
     * Download the glyphs.
     */
    if (kNoErr == retVal)
        retVal = T42AddChars(pUFObj, pGlyphs);

    return retVal;
}


UFLErrCode
T42UndefineFont(
    UFOStruct   *pUFObj
    )

/*++

Routine Description:
    Send PS code to undefine fonts: /UDF and /UDR should be defined properly
    by client to something like:

    /UDF
    {
      IsLevel2
      {undefinefont}
      { pop }ifelse
    } bind def
    /UDR
    {
      IsLevel2
      {undefineresource}
      { pop pop }ifelse
    } bind def

--*/

{
    T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;
    UFLErrCode    retVal = kNoErr;
    UFLHANDLE     stream = pUFObj->pUFL->hOut;
    char          strmbuf[256];
    short int     i;

    if (pUFObj->flState < kFontHeaderDownloaded)
        return retVal;

    /*
     * If the font is a Type 42 CID-keyed font, then undefine its CIDFont
     * resources first. (We don't care to leave its CMaps in VM.)
     * But if the font is created on a HostFont system, no need to undefine the
     * resources since we didn't donwload them.
     */
    if (IS_TYPE42CID_KEYEDFONT(pUFObj->lDownloadFormat) && !HOSTFONT_IS_VALID_UFO(pUFObj))
    {
        /*
         * Undefine CIDFont resources: there are 4 possible CIDFonts.
         *
         * e.g. /TT37820t0CID, /TT37820t0CIDR, /TT37820t0CID32K, /TT37820t0CID32KR
         *
         * We can send "udefineresource" for all of them; the command is very
         * forgiving.
         */
        for (i = 0; i < NUM_CIDSUFFIX; i++)
        {
            UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s%s /CIDFont UDR", pUFObj->pszFontName, gcidSuffix[i]);
            if (kNoErr == retVal)
                retVal = StrmPutStringEOL(stream, strmbuf);
        }
    }

    /*
     * Undefine the font.
     */
    if (IS_TYPE42CIDFONT_RESOURCE(pUFObj->lDownloadFormat) && !HOSTFONT_IS_VALID_UFO(pUFObj))
        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s /CIDFont UDR", pUFObj->pszFontName);
    else
        UFLsprintf(strmbuf, CCHOF(strmbuf), "/%s UDF", pUFObj->pszFontName);

    if (kNoErr == retVal)
        retVal = StrmPutStringEOL(stream, strmbuf);

    return retVal;
}


UFOStruct *
T42FontInit(
    const UFLMemObj     *pMem,
    const UFLStruct     *pUFL,
    const UFLRequest    *pRequest
    )
{
    UFOStruct       *pUFObj = (UFOStruct *)UFLNewPtr(pMem, sizeof (UFOStruct));
    UFLTTFontInfo   *pInfo;
    long            maxGlyphs;

    if (pUFObj == nil)
      return nil;

    /* Initialize data. */
    UFOInitData(pUFObj, UFO_TYPE42, pMem, pUFL, pRequest,
                (pfnUFODownloadIncr)  T42FontDownloadIncr,
                (pfnUFOVMNeeded)      T42VMNeeded,
                (pfnUFOUndefineFont)  T42UndefineFont,
                (pfnUFOCleanUp)       T42FontCleanUp,
                (pfnUFOCopy)          CopyFont);

    /*
     * pszFontName should be allocated and initialized. If not, cannot continue.
     */
    if ((pUFObj->pszFontName == nil) || (pUFObj->pszFontName[0] == '\0'))
    {
      UFLDeletePtr(pMem, pUFObj);
      return nil;
    }

    pInfo = (UFLTTFontInfo*)pRequest->hFontInfo;

    maxGlyphs = pInfo->fData.cNumGlyphs;

    /*
     * A convenience pointer used in GetNumGlyph() - must be set now.
     */
    pUFObj->pFData = &(pInfo->fData); /* !!! Temporary assignment !!! */

    if (maxGlyphs == 0)
        maxGlyphs = GetNumGlyphs(pUFObj);

    if (NewFont(pUFObj, sizeof (T42FontStruct), maxGlyphs) == kNoErr)
    {
        unsigned long sSize;
        unsigned long *pXUID;
        T42FontStruct *pFont = (T42FontStruct *)pUFObj->pAFont->hFont;

        pFont->info = *pInfo;

        /*
         * A convenience pointer - set to the permanent one.
         */
        pUFObj->pFData = &(pFont->info.fData);  /* !!! Real assignment !!! */

        /*
         * Get ready to find out correct glyphNames from 'post' table -
         * set correct pFont->info.fData.fontIndex and offsetToTableDir.
         */
        if (pFont->info.fData.fontIndex == FONTINDEX_UNKNOWN)
            pFont->info.fData.fontIndex = GetFontIndexInTTC(pUFObj);

        /*
         * Get num of Glyphs in this TT file if not set yet.
         */
        if (pFont->info.fData.cNumGlyphs == 0)
            pFont->info.fData.cNumGlyphs = maxGlyphs;

        /*
         * Copy or Set XUID array to our UFLXUID structure.
         */
        sSize = pInfo->fData.xuid.sSize;

        if (sSize == 0)
        {
            /*
             * 'sSize == 0' means that UFL needs to figure out the XUID.
             */

            // Fixed bug 387970. We have to initialize offsetToTableDir to make
            // CreateXUIDArray work for ttc font.
            pFont->info.fData.offsetToTableDir =
                GetOffsetToTableDirInTTC(pUFObj, pFont->info.fData.fontIndex);

            sSize = CreateXUIDArray(pUFObj, nil);

            pXUID = (unsigned long *)UFLNewPtr(pUFObj->pMem,
                                                sSize * sizeof (unsigned long));

            if (pXUID)
                sSize = CreateXUIDArray(pUFObj, pXUID);
        }
        else
        {
            /*
             * The XUID is passed in by client - just copy it.
             */
            pXUID = (unsigned long *)UFLNewPtr(pUFObj->pMem,
                                                sSize * sizeof (unsigned long));


            if (pXUID)
            {
                UFLmemcpy(pUFObj->pMem,
                            pXUID, pInfo->fData.xuid.pXUID,
                            sSize * sizeof (unsigned long));
            }
        }

        if (sSize && pXUID)
        {
            pUFObj->pAFont->Xuid.sSize = sSize;
            pUFObj->pAFont->Xuid.pXUID = pXUID;
        }
        else if (pXUID)
            UFLDeletePtr(pUFObj->pMem, pXUID);

        /*
         * More initializations
         */
        pFont->cOtherTables     = 0;
        pFont->pHeader          = nil;
        pFont->pMinSfnt         = nil;
        pFont->pStringLength    = nil;
        pFont->pLocaTable       = nil;
        pFont->minSfntSize      = 0;
        pFont->averageGlyphSize = 0;
        pFont->pRotatedGlyphIDs = nil;

        pUFObj->pUpdatedEncoding = (unsigned char *)UFLNewPtr(pMem, GLYPH_SENT_BUFSIZE(256));

        if (pUFObj->pUpdatedEncoding != 0)
        {
            /*
             * Completed initialization. Change the state.
             */
            pUFObj->flState = kFontInit;
        }
    }

    return pUFObj;
}


static unsigned long
GetLenByScanLoca(
    void PTR_PREFIX *locationTable,
    unsigned short  wGlyfIndex,
    unsigned long   cNumGlyphs,
    int             iLongFormat
    )
{
    unsigned long GlyphLen        = 0;
    unsigned long nextGlyphOffset = 0xFFFFFFFF;
    unsigned long i;

    if (iLongFormat)
    {
        unsigned long PTR_PREFIX* locaTableL = locationTable;

        for (i = 0; i < cNumGlyphs; i++)
        {
            if ((MOTOROLALONG(locaTableL[i]) > MOTOROLALONG(locaTableL[wGlyfIndex]))
                 && (MOTOROLALONG(locaTableL[i]) < nextGlyphOffset))
            {
                nextGlyphOffset = MOTOROLALONG(locaTableL[i]);
            }
        }

        if (nextGlyphOffset != 0xFFFFFFFF)
            GlyphLen = nextGlyphOffset - MOTOROLALONG(locaTableL[wGlyfIndex]);
    }
    else
    {
        unsigned short PTR_PREFIX* locaTableS = locationTable;

        for (i = 0; i < cNumGlyphs; i++)
        {
            if ((MOTOROLAINT(locaTableS[i]) > MOTOROLAINT(locaTableS[wGlyfIndex]))
                 && (MOTOROLAINT(locaTableS[i]) < nextGlyphOffset))
            {
                nextGlyphOffset = MOTOROLAINT(locaTableS[i]);
            }
        }

        if (nextGlyphOffset != 0xFFFFFFFF)
            GlyphLen = (nextGlyphOffset - MOTOROLAINT(locaTableS[wGlyfIndex])) * 2;
    }

    return GlyphLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\fontutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    
    fntutil2.c

Abstract:

    Convert NT4.0 RLE to GLYPHSETDATA.
    Convert NT4.0 IFI to UFM

Environment:

    Win32 subsystem, Unidrv driver

Revision History:

    11-11-97 -eigos-
        Created it

    dd-mm-yy -author-
        description

--*/

#include        "precomp.h"

extern UINT guiCharsets[];
extern UINT guiCodePages[];

//
// Internal macros
//

#ifndef CP_ACP
#define CP_ACP 0
#endif//CP_ACP

#ifndef CP_OEMCP
#define CP_OEMCP 1
#endif//CP_OEMCP

//
// The number of charset table which is defiend in globals.c
//

#define NCHARSETS 14


ULONG
UlCharsetToCodePage(
    IN UINT uiCharSet)
{

    INT iI;

    if (uiCharSet == OEM_CHARSET)
    {
        return CP_OEMCP;
    }
    else if (uiCharSet == SYMBOL_CHARSET)
    {
        return CP_ACP;
    }
    else
    {
        for (iI = 0; iI < NCHARSETS; iI ++)
        {
            if (guiCharsets[iI] == uiCharSet)
            {
                return guiCodePages[iI];
            }
        }

        return CP_ACP;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\ufl\source\ufottt3.c ===
/*
 *    Adobe Universal Font Library
 *
 *    Copyright (c) 1996 Adobe Systems Inc.
 *    All Rights Reserved
 *
 *    UFLTTT3.cpp
 *
 *
 * $Header:
 */

/* -------------------------------------------------------------------------
     Header Includes
  --------------------------------------------------------------------------- */
#include "UFOTTT3.h"
#include "UFLPS.h"
#include "UFLMem.h"
#include "UFLErr.h"
#include "UFLPriv.h"
#include "UFLVm.h"
#include "UFLStd.h"
#include "UFLMath.h"
#include "ParseTT.h"

/* ---------------------------------------------------------------------------
     Constant
 --------------------------------------------------------------------------- */

/* ---------------------------------------------------------------------------
     Global variables
 --------------------------------------------------------------------------- */
extern const char *buildChar[];

/* ---------------------------------------------------------------------------
     Macros
 --------------------------------------------------------------------------- */

/* ---------------------------------------------------------------------------
     Implementation
 --------------------------------------------------------------------------- */


void
TTT3FontCleanUp(
    UFOStruct *pUFObj
    )
{
    /* no special data for T3 */
}


/***************************************************************************
 *
 *                          DownloadFontHeader
 *
 *
 *    Function: Download the font header. After this action, glyphs
 *        can be added to the font.
 *
***************************************************************************/

static UFLErrCode
DownloadFontHeader(
    UFOStruct       *pUFO
    )
{
    UFLErrCode      retVal;
    char            buf[128];
    UFLHANDLE       stream;
    UFLFontProcs    *pFontProcs;
    UFLFixedMatrix  matrix;
    char            nilStr[] = "\0\0";  // An empty/nil string.
    TTT3FontStruct  *pFont;
    UFLBool         bType3_32_Combo;

    bType3_32_Combo = ( pUFO->lDownloadFormat == kTTType332 );
    pFont = (TTT3FontStruct *) pUFO->pAFont->hFont;

    if ( pUFO->flState != kFontInit )
        return kErrInvalidState;

    stream = pUFO->pUFL->hOut;
    pFontProcs = (UFLFontProcs *)&pUFO->pUFL->fontProcs;

    /* Font Name */
    UFLsprintf( buf, CCHOF(buf), "/%s", pUFO->pszFontName );
    retVal = StrmPutStringEOL( stream, buf );

    /* Define Character metric for .notdef. */
    if ( kNoErr == retVal )
    {
        matrix.a = pFont->info.matrix.a;
        matrix.b = matrix.c = matrix.d = matrix.e = matrix.f = 0;
        retVal = StrmPutMatrix( stream, &matrix, 0 );
    }

    /* Encoding */
    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, nilStr );
    if ( kNoErr == retVal )
    {
        // Always emit Encoding array filled with /.notdef (due to bug fix
        // 273021). The encoding array is updated later when each glyph is
        // downloaded.
        retVal = StrmPutString( stream, gnotdefArray );
    }


    /* FontBBox */
    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, nilStr );
    if ( kNoErr == retVal )
    {
        matrix.a = pFont->info.bbox[0];
        matrix.b = pFont->info.bbox[1];
        matrix.c = pFont->info.bbox[2];
        matrix.d = pFont->info.bbox[3];
        matrix.e = 0;
        matrix.f = 0;
        retVal = StrmPutMatrix( stream, &matrix, 1 );
    }

    /* FontMatrix */
    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, nilStr );
    if ( kNoErr == retVal )
    {
        retVal = StrmPutString( stream, "[1 " );
        if ( kNoErr == retVal )
            retVal = StrmPutFixed( stream, pFont->info.matrix.a );
        if ( kNoErr == retVal )
            retVal = StrmPutString( stream, "div 0 0 -1 " );
        if ( kNoErr == retVal )
            retVal = StrmPutFixed( stream, pFont->info.matrix.d );
        if ( kNoErr == retVal )
            retVal = StrmPutStringEOL( stream, "div 0 0 ]" );
    }

    /* Type 32 Font Resource Name */
    if ( kNoErr == retVal )
    {
        UFLsprintf( buf, CCHOF(buf), "/__%s", pUFO->pszFontName );
        retVal = StrmPutStringEOL( stream, buf );
    }

    /* Define the font */
    if ( kNoErr == retVal )
    {
        if (bType3_32_Combo)
            retVal = StrmPutStringEOL( stream, "GreNewFont" );
        else
            retVal = StrmPutStringEOL( stream, "GreNewFontT3" );
    }

    /* Goodname */
    pUFO->dwFlags |= UFO_HasFontInfo;
    pUFO->dwFlags |= UFO_HasG2UDict;

    return retVal;
}

static UFLErrCode
OutputBitmap(
    UFOStruct       *pUFO,
    UFLGlyphMap     *bmp,
    long            cExtra0s
    )
{
    UFLErrCode  retVal = kNoErr;
    short       i;
    UFLHANDLE   stream;
    long        bitsPerLine;
    long        bitmapSize;
    UFLFontProcs *pFontProcs;
    char        nilStr[] = "\0\0";  // An empty/nil string.
    char        *pExtra0 = nil;
    TTT3FontStruct *pFont;

    pFont = (TTT3FontStruct *) pUFO->pAFont->hFont;

    stream = pUFO->pUFL->hOut;
    pFontProcs = (UFLFontProcs *)&pUFO->pUFL->fontProcs;

    if ( cExtra0s > 0)
       pExtra0  = (char *) UFLNewPtr( pUFO->pMem, cExtra0s );

    /* universal handling for all types of Type3 character representation:
          - < Hex data >              % If Level1 ASCII
          - ( Binary with \escapes )  % If Binary
          - <~ ASCII85 data  ~>       % If Level2 ASCII
    */
    bitsPerLine = (bmp->byteWidth + 7) >> 3;
    bitmapSize = bitsPerLine * bmp->height;

    /*********  Output Character bitmap data *************/
     if ( StrmCanOutputBinary(stream) )
     {
    /* If binary mode - output data into the string start string definition */
    retVal = StrmPutString( stream, "(" );
    if ( kNoErr == retVal )
    {
        retVal = StrmPutStringBinary( stream, bmp->bits, bitmapSize );
        if ( pExtra0 )
        retVal = StrmPutStringBinary( stream, pExtra0, cExtra0s );
    }

    if ( kNoErr == retVal )
        StrmPutStringEOL( stream, ")" );                    /* End string definition */
    }
    else if ( pUFO->pUFL->outDev.lPSLevel >= 2 && ( pExtra0 == nil ) ) /* Can't output 2 buffers for ASCII85 */
    {                                                           /* Level2 - use ASCII85 */
    retVal = StrmPutString( stream, "<~" );

    if ( kNoErr == retVal )
    {
        retVal = StrmPutAscii85( stream, bmp->bits, bitmapSize );
    }

    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, "~>" );          /* End ASCII85 string */
    }
    else
    {
                                /* Level 1 ASCII  - just send out in Hex */
    retVal = StrmPutString( stream, "<" );                  /* Start AsciiHex */

    /* Go line-by-line and output data so we can view the bitmap */
    for ( i = 0; kNoErr == retVal && i < bmp->height; i++ )
    {
        retVal = StrmPutAsciiHex( stream, bmp->bits + (i * bitsPerLine), bitsPerLine );

        if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, nilStr );
    }

    if (kNoErr == retVal && pExtra0)
    {
        for ( i = 0; kNoErr == retVal && i < cExtra0s/bitsPerLine; i++ )
        {
        retVal = StrmPutAsciiHex( stream, pExtra0, bitsPerLine ); // ALL are 0.
        }

        if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, nilStr );
    }


    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, ">" );    /* End AsciiHex */
    }  /* end of Hex encoding */

    if ( pExtra0 )
       UFLDeletePtr(pUFO->pMem, pExtra0);

    return retVal;
}


/***************************************************************************
 *
 *                          AddGlyph3
 *
 *
 *    Function: Generates the definition of a single character.  We currently
 *         use the imagemask operator to blast the character on the paper
 *         where the character shape is used as the mask to apply the current
 *         color through.  The format of a character definition is as
 *         follows (example is for 'A', ASCII 65d, 41h):
 *               /GlyphName                % Character encoding name
 *               [xInc yInc (0)             % X advance and Y advance of origin to
 *                                                % next char
 *               ulx uly lrx lry]            % bounding box of character (used by font
 *                                                % cache)
 *               /GlyphName          % Character encoding name
 *               {                   % begin proc that draws character
 *                 cx cy             % width and height of bitmap
 *                 true              % image must be inverted (black <=> white)
 *                 [1 0 0 1 tx ty]   % 2D transform to convert bitmap
 *                                   % coordinates to user coordinates
 *                 {<023F...>}       % bitmap data (hexadecimal format)
 *                 imagemask         % draw the character
 *               }                   % end of character draw proc
 *               /TT_Arial           % Font character should be added
 *               AddChar             % Helper function to define character
 *
***************************************************************************/
static UFLErrCode
AddGlyph3(
    UFOStruct       *pUFO,
    UFLGlyphID      glyph,
    unsigned short  cid,
    const char      *glyphName,
    unsigned long   *glyphSize
    )
{
    UFLErrCode        retVal = kNoErr;
    UFLGlyphMap*      bmp;
    UFLFixedMatrix    matrix;
    UFLFixed          bbox[4];
    UFLFixed          xWidth, yWidth;
    char              buf[128];
    UFLHANDLE         stream;
    UFLFontProcs      *pFontProcs;
    char              nilStr[] = "\0\0";  // An empty/nil string.
    long              cExtra0s = 0;
    TTT3FontStruct    *pFont;
    UFLBool           bType3_32_Combo;

    bType3_32_Combo = ( pUFO->lDownloadFormat == kTTType332 );

    pFont = (TTT3FontStruct *) pUFO->pAFont->hFont;

    stream = pUFO->pUFL->hOut;
    pFontProcs = (UFLFontProcs *)&pUFO->pUFL->fontProcs;
    *glyphSize = 0;

    /* Whatever is in glyph, pass back to client */
    if ( pFontProcs->pfGetGlyphBmp( pUFO->hClientData, glyph, &bmp, &xWidth, &yWidth, (UFLFixed*)bbox ) )
    {
        if ( kNoErr == retVal )
            retVal = StrmPutStringEOL( stream, nilStr );

        /* Output the CID */
        if ( kNoErr == retVal )
        {
            UFLsprintf( buf, CCHOF(buf), "%d", cid );
            retVal = StrmPutStringEOL( stream, buf );
        }

        /*  Send /GlyphName [type3 character BBox]*/
        if ( kNoErr == retVal )
        {
            UFLsprintf( buf, CCHOF(buf), "/%s ", glyphName );
            retVal = StrmPutString( stream, buf );
            /* Send type 3 character BBox. We need to truncated the floating point
               because of type 32 restriction.
            */
            matrix.a = xWidth;
            matrix.b = yWidth;
            matrix.c = UFLTruncFixed(bbox[0]);
            matrix.d = UFLTruncFixed(bbox[1]);
            matrix.e = UFLTruncFixed(bbox[2]);
            matrix.f = UFLTruncFixed(bbox[3]);
            retVal = StrmPutMatrix( stream, &matrix, 0 );

            cExtra0s =   ( (UFLRoundFixedToShort(matrix.e) - UFLRoundFixedToShort(matrix.c) + 7) >> 3 ) *
                 (  UFLRoundFixedToShort(matrix.f) - UFLRoundFixedToShort(matrix.d) )
                   - ( ((bmp->byteWidth + 7) >> 3) * bmp->height );
            if (cExtra0s < 0 ) cExtra0s = 0;
        }

        if ( kNoErr == retVal )
        {
            retVal = StrmPutStringEOL( stream, nilStr );
        }

        /* Send "/GlyphName [" */
        if ( kNoErr == retVal )
        {
            UFLsprintf( buf, CCHOF(buf), "/%s [", glyphName );
            retVal = StrmPutString( stream, buf );
        }

        /* Don't output non-marking glyphs! */
        if ( (kNoErr == retVal) && bmp->byteWidth && bmp->height )
        {
            /* Send rest of prefix to actual bitmap data : width height polarity matrix datasrc imagemask */
            UFLsprintf(buf, CCHOF(buf), "%ld %ld true ", bmp->byteWidth, bmp->height );        /* width, height, polarity */
            retVal = StrmPutString( stream, buf );
            /* Send [1 0 0 1 tx ty] - 2D transform to convert bitmap coordinate to user coordinate */
            if ( kNoErr == retVal )
            {
            matrix.a = UFLFixedOne;
            matrix.b = 0;
            matrix.c = 0;
            matrix.d = UFLFixedOne;
            matrix.e = UFLShortToFixed( bmp->xOrigin );
            matrix.f = UFLShortToFixed( bmp->yOrigin );
            retVal = StrmPutMatrix( stream, &matrix, 0 );
            if ( kNoErr == retVal )
                retVal = StrmPutString( stream, nilStr );
            }

            /* Send out place holder */
            if ( kNoErr == retVal )
            {
            UFLsprintf( buf, CCHOF(buf), " 0 0]" );
            retVal = StrmPutStringEOL( stream, buf );
            }

            /* Send the character bitmap */
            if ( kNoErr == retVal )
            {
            retVal = StrmPutString( stream, "[" );

            if ( kNoErr == retVal )
                retVal = OutputBitmap( pUFO, bmp, cExtra0s );

            if ( kNoErr == retVal )
                retVal = StrmPutStringEOL( stream, " ]" );

            //  Fix bug 246325. 7/13/98    jjia
            //  glyphsize = hight * bytewidth * safefactor
            //  *glyphSize = bmp->height * bmp->byteWidth;
            *glyphSize = bmp->height * ((bmp->byteWidth + 7) >> 3) * 2;
            }
        }
        else
        {
            /* Generate nil drawing procedure */
            retVal = StrmPutStringEOL( stream, "]" );
            if ( kNoErr == retVal )
            retVal = StrmPutStringEOL( stream, "[<>]" );
        }

        /* Send the Add character definition command */
        if ( kNoErr == retVal )
        {
            if (bType3_32_Combo)
                UFLsprintf( buf, CCHOF(buf), "/%s AddT3T32Char", pUFO->pszFontName );
            else
                UFLsprintf( buf, CCHOF(buf), "/%s AddT3Char", pUFO->pszFontName );

            retVal = StrmPutStringEOL( stream, buf );
        }

        /* Delete the bitmap if there is a client function for it */
        if ( pFontProcs->pfDeleteGlyphBmp )
            pFontProcs->pfDeleteGlyphBmp( pUFO->hClientData );

    }
    return retVal;
}



#pragma optimize("", off)

UFLErrCode
TTT3VMNeeded(
    UFOStruct           *pUFO,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMNeeded,
    unsigned long       *pFCNeeded
    )
{
    UFLErrCode      retVal = kNoErr;
    short           i;
    unsigned long   totalGlyphs;
    TTT3FontStruct  *pFont;
    DWORD           dwTotalGlyphsSize = 0;
    unsigned short  wIndex;

    if (pUFO->flState < kFontInit)
        return (kErrInvalidState);

    pFont = (TTT3FontStruct *) pUFO->pAFont->hFont;

    if (pGlyphs == nil || pGlyphs->pGlyphIndices == nil || pVMNeeded == nil)
       return kErrInvalidParam;

    totalGlyphs = 0;
    /* Scan the list, check what characters that we have downloaded */
    if ( pUFO->pUFL->bDLGlyphTracking && pGlyphs->pCharIndex)
    {

          UFLmemcpy((const UFLMemObj* ) pUFO->pMem,
          pUFO->pAFont->pVMGlyphs,
          pUFO->pAFont->pDownloadedGlyphs,
          (UFLsize_t) (GLYPH_SENT_BUFSIZE( pFont->info.fData.cNumGlyphs) ) );
        for ( i = 0; i < pGlyphs->sCount; i++ )
        {
            /* use glyphIndex to track - fix bug when we do T0/T3 */
            wIndex = (unsigned short) pGlyphs->pGlyphIndices[i] & 0x0000FFFF ; /* loWord is the GlyphID */
            if (wIndex >= UFO_NUM_GLYPHS(pUFO) )
                continue;

            if ( !IS_GLYPH_SENT( pUFO->pAFont->pVMGlyphs, wIndex) )
            {
                totalGlyphs++;
                SET_GLYPH_SENT_STATUS( pUFO->pAFont->pVMGlyphs, wIndex );
            }
        }
    }
    else
        totalGlyphs = pGlyphs->sCount;

    if ( pUFO->flState == kFontInit )
        *pVMNeeded = kVMTTT3Header;
    else
        *pVMNeeded = 0;

    /* VMNeeded = average size of a glyph * totalGlyphs */
    //  Fix bug 246325. 7/13/98    jjia
    //  dwTotalGlyphsSize = totalGlyphs * (pFont->cbMaxGlyphs / pFont->info.fData.maxGlyphs);
    dwTotalGlyphsSize = totalGlyphs * (pFont->cbMaxGlyphs * 2 / 3);

    if ( GETPSVERSION(pUFO) <= 2015 )
        *pVMNeeded += dwTotalGlyphsSize;

    *pVMNeeded = VMRESERVED( *pVMNeeded );
    /* swong: pFCNeeded for T32 FontCache tracking */
    *pFCNeeded = VMRESERVED(dwTotalGlyphsSize);

    return kNoErr;
}

#pragma optimize("", on)


/***************************************************************************
 *
 *                          DownloadIncrFont
 *
 *
 *    Function: Adds all of the characters from pGlyphs that aren't already
 *              downloaded for the TrueType font.
 *
 *  Note: pCharIndex is used to track which char(in this font) is downloaded or not
 *        It can be nil if client doesn't wish to track - e.g. Escape(DownloadFace)
 *        It has no relationship with ppGlyphNames.
 *        E.g., ppGlyphNames[0]="/A", pCharIndex[0]=6, pGlyphIndices[0]=1000: means
 *        To download glyphID 1000 as Char-named "/A" and Also, remember the 6th-char is downloaded
 *
***************************************************************************/
UFLErrCode
TTT3FontDownloadIncr(
    UFOStruct           *pUFO,
    const UFLGlyphsInfo *pGlyphs,
    unsigned long       *pVMUsage,
    unsigned long       *pFCUsage
    )
{
    UFLGlyphID     *glyphs;
    UFLErrCode     retVal;
    short          i;
    UFLBool        bDownloaded;
    unsigned long  glyphSize;
    char           *pGoodName;
    unsigned short cid;
    UFLBool        bType3_32_Combo;
    unsigned short wIndex;
    UFLBool        bGoodName;      // GoodName
    char           pGlyphName[32]; // GoodName

    bType3_32_Combo = ( pUFO->lDownloadFormat == kTTType332 );

    if ( pUFO->flState < kFontInit )
        return kErrInvalidState;

    if ( pGlyphs == nil ||
         pGlyphs->pGlyphIndices == nil ||
         pGlyphs->sCount == -1 )
        return kErrInvalidParam;

    if ( pUFO->pUFL->outDev.pstream->pfDownloadProcset == 0 )
        return kErrDownloadProcset;

    if ( !pUFO->pUFL->outDev.pstream->pfDownloadProcset(pUFO->pUFL->outDev.pstream, kT3Header) )
        return kErrDownloadProcset;

    retVal = kNoErr;
        ;
    /* Download the font header if this is the first time we download the font */
    if ( pUFO->flState == kFontInit )
    {
        retVal =  DownloadFontHeader( pUFO );
        if ( pVMUsage )
            *pVMUsage = kVMTTT3Header;
    }
    else if ( pVMUsage )
        *pVMUsage = 0;

    /* Initial FontCahce Usage */
    if ( pFCUsage )
        *pFCUsage = 0;

    /* Download the new glyphs */
    glyphs = pGlyphs->pGlyphIndices;
    bDownloaded = 0;

    for ( i = 0; retVal == kNoErr && i < pGlyphs->sCount; ++i)
    {
        /* use glyphIndex to track - fix bug when we do T0/T3 */
        wIndex = (unsigned short) glyphs[i] & 0x0000FFFF; /* LOWord is the real GID */
        if (wIndex >= UFO_NUM_GLYPHS(pUFO) )
            continue;

        if ( 0 == pUFO->pUFL->bDLGlyphTracking ||
            pGlyphs->pCharIndex == nil ||        // DownloadFace
            pUFO->pEncodeNameList  ||            // DownloadFace
            !IS_GLYPH_SENT( pUFO->pAFont->pDownloadedGlyphs, wIndex ) ||
            ((pGlyphs->pCharIndex != nil) &&
             !IS_GLYPH_SENT( pUFO->pUpdatedEncoding , pGlyphs->pCharIndex[i] )))
        {
            // GoodName
            pGoodName = pGlyphName;
            bGoodName = FindGlyphName(pUFO, pGlyphs, i, wIndex, &pGoodName);

            // Fix bug 274008  Check Glyph Name only for DownloadFace.
            if (pUFO->pEncodeNameList)
            {
                if ((UFLstrcmp( pGoodName, Hyphen ) == 0) && (i == 45))
                {
                    // Add /minus to CharStrings
                    if ( kNoErr == retVal )
                        retVal = AddGlyph3( pUFO, glyphs[i], cid, Minus, &glyphSize );
                }
                if ((UFLstrcmp( pGoodName, Hyphen ) == 0) && (i == 173))
                {
                    // Add /sfthyphen to CharStrings
                    if ( kNoErr == retVal )
                        retVal = AddGlyph3( pUFO, glyphs[i], cid, SftHyphen, &glyphSize );
                }
                if (!ValidGlyphName(pGlyphs, i, wIndex, pGoodName))
                    continue;
                // Send only one ".notdef"
                if ((UFLstrcmp( pGoodName, Notdef ) == 0) &&
                    (wIndex == (unsigned short) (glyphs[0] & 0x0000FFFF)) &&
                    IS_GLYPH_SENT( pUFO->pAFont->pDownloadedGlyphs, wIndex ))
                    continue;
            }

            if ( 0 == bDownloaded )
            {
                if (bType3_32_Combo)
                    StrmPutStringEOL( pUFO->pUFL->hOut, "T32RsrcBegin" );
                bDownloaded = 1;
            }

            if (pGlyphs->pCharIndex)
                cid = pGlyphs->pCharIndex[i];
            else
                cid = i;

            if ( kNoErr == retVal )
                retVal = AddGlyph3( pUFO, glyphs[i], cid, pGoodName, &glyphSize );

            if ( kNoErr == retVal )
            {
                SET_GLYPH_SENT_STATUS( pUFO->pAFont->pDownloadedGlyphs, wIndex );

                if (bGoodName)    // GoodName
                    SET_GLYPH_SENT_STATUS( pUFO->pAFont->pCodeGlyphs, wIndex );

                if (pGlyphs->pCharIndex)
                    SET_GLYPH_SENT_STATUS( pUFO->pUpdatedEncoding, cid );

                if ( GETPSVERSION(pUFO) <= 2015 )
                {
                    if ( pVMUsage )
                        *pVMUsage += glyphSize;
                }
                else
                {
                    /* if PS >= 2016, assume T32 and update FC tracking */
                    if ( pFCUsage && bType3_32_Combo )
                        *pFCUsage += glyphSize;
                }
            }
        }
    }

    if ( bDownloaded )
    {
        if (bType3_32_Combo)
            retVal = StrmPutStringEOL( pUFO->pUFL->hOut, "T32RsrcEnd" );

        /* GoodName  */
        /* Update the FontInfo with Unicode information. */
        if ((kNoErr == retVal) && (pGlyphs->sCount > 0) &&
            (pUFO->dwFlags & UFO_HasG2UDict) &&
            (pUFO->pUFL->outDev.lPSLevel >= kPSLevel2) &&  // Don't do this for level1 printers
            !(pUFO->lNumNT4SymGlyphs))
        {
            /* Check pUFObj->pAFont->pCodeGlyphs to see if we really need to update it. */
            for ( i = 0; i < pGlyphs->sCount; i++ )
            {
                wIndex = (unsigned short) glyphs[i] & 0x0000FFFF; /* LOWord is the real GID. */
                if (wIndex >= UFO_NUM_GLYPHS(pUFO) )
                    continue;

                if (!IS_GLYPH_SENT( pUFO->pAFont->pCodeGlyphs, wIndex ) )
                {
                    // Found at least one not updated, do it (once) for all.
                    retVal = UpdateCodeInfo(pUFO, pGlyphs, 1);
                    break;
                }
            }
        }

        if ( kNoErr == retVal )
        {
            pUFO->flState = kFontHasChars;
        }

        if ( pVMUsage )
            *pVMUsage = VMRESERVED( *pVMUsage );
        /* swong: pFCUsage for T32 FontCache tracking */
        if ( pFCUsage && bType3_32_Combo )
            *pFCUsage = VMRESERVED( *pFCUsage );
    }

    return retVal;
}


// Send PS code to undefine fonts: /UDF3 should be defined properly by client
// UDF3 should recover the FontCache used by Type32
UFLErrCode
TTT3UndefineFont(
    UFOStruct  *pUFO
)
{
    UFLErrCode retVal = kNoErr;
    char buf[128];
    UFLHANDLE stream;
    UFLBool         bType3_32_Combo;

    bType3_32_Combo = ( pUFO->lDownloadFormat == kTTType332 );

    if (pUFO->flState < kFontHeaderDownloaded) return retVal;

    stream = pUFO->pUFL->hOut;
    UFLsprintf( buf, CCHOF(buf), "/%s ", pUFO->pszFontName );
    retVal = StrmPutString( stream, buf );

    if (bType3_32_Combo)
        UFLsprintf( buf, CCHOF(buf), "/__%s UDF3", pUFO->pszFontName );
    else
        UFLsprintf( buf, CCHOF(buf), "UDF");

    if ( kNoErr == retVal )
        retVal = StrmPutStringEOL( stream, buf );

    return retVal;
}


UFOStruct *
TTT3FontInit(
    const UFLMemObj  *pMem,
    const UFLStruct  *pUFL,
    const UFLRequest *pRequest
    )
{
    UFOStruct         *pUFObj;
    TTT3FontStruct    *pFont;
    UFLTTT3FontInfo   *pInfo;
    long              maxGlyphs;

    /* MWCWP1 doesn't like the implicit cast from void* to UFOStruct*  --jfu */
    pUFObj = (UFOStruct*) UFLNewPtr( pMem, sizeof( UFOStruct ) );
    if (pUFObj == 0)
        return nil;

    /* Initialize data */
    UFOInitData(pUFObj, UFO_TYPE3, pMem, pUFL, pRequest,
        (pfnUFODownloadIncr)  TTT3FontDownloadIncr,
        (pfnUFOVMNeeded)      TTT3VMNeeded,
        (pfnUFOUndefineFont)  TTT3UndefineFont,
        (pfnUFOCleanUp)       TTT3FontCleanUp,
        (pfnUFOCopy)          CopyFont
        );


    /* pszFontName should be ready/allocated - if not FontName, cannot continue */
    if (pUFObj->pszFontName == nil || pUFObj->pszFontName[0] == '\0')
    {
        UFLDeletePtr(pMem, pUFObj);
        return nil;
    }

    pInfo = (UFLTTT3FontInfo *)pRequest->hFontInfo;
    maxGlyphs = pInfo->fData.cNumGlyphs;

    /* a convenience pointer used in GetNumGlyph() - must be set now*/
    pUFObj->pFData = &(pInfo->fData); /* Temporary assignment !! */
    if (maxGlyphs == 0)
        maxGlyphs = GetNumGlyphs( pUFObj );

    /*
     * On NT4 a non-zero value will be set to pInfo->lNumNT4SymGlyphs for
     * symbolic TrueType font with platformID 3/encodingID 0. If it's set, it
     * is the real maxGlyphs value.
     */
    pUFObj->lNumNT4SymGlyphs = pInfo->lNumNT4SymGlyphs;

    if (pUFObj->lNumNT4SymGlyphs)
        maxGlyphs = pInfo->lNumNT4SymGlyphs;

    /*
     * We now use Glyph Index to track which glyph is downloaded, so use
     * maxGlyphs.
     */
    if ( NewFont(pUFObj, sizeof(TTT3FontStruct), maxGlyphs) == kNoErr )
    {
        pFont = (TTT3FontStruct*) pUFObj->pAFont->hFont;

        pFont->info = *pInfo;

        /* a convenience pointer */
        pUFObj->pFData = &(pFont->info.fData);

        /*
         * Get ready to find out correct glyphNames from "post" table - set
         * correct pUFO->pFData->fontIndex and offsetToTableDir.
         */
        if ( pFont->info.fData.fontIndex == FONTINDEX_UNKNOWN )
            pFont->info.fData.fontIndex = GetFontIndexInTTC(pUFObj);

        /* Get num of Glyphs in this TT file if not set yet */
        if (pFont->info.fData.cNumGlyphs == 0)
            pFont->info.fData.cNumGlyphs = maxGlyphs;

        pFont->cbMaxGlyphs = pInfo->cbMaxGlyphs;

        if ( pUFObj->pUpdatedEncoding == 0 )
        {
            /* MWCWP1 doesn't like the implicit cast from void* to unsigned char*  --jfu */
            pUFObj->pUpdatedEncoding = (unsigned char*) UFLNewPtr( pMem, GLYPH_SENT_BUFSIZE(256) );
        }

        if ( pUFObj->pUpdatedEncoding != 0 )  /* completed initialization */
            pUFObj->flState = kFontInit;
    }

    return pUFObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\formtray.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    formtray.c

Abstract:

    Unidrv form-to-tray assignent

Environment:

    Windows NT printer drivers

Revision History:

    01/07/97 -amandan-
        Created it.

--*/

#include "lib.h"
#include "unilib.h"


FORM_TRAY_TABLE
PGetAndConvertOldVersionFormTrayTable(
    IN HANDLE   hPrinter,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Retrieve the old Unidrv form-to-tray assignment table from registry and
    convert it to the new format for the caller

Arguments:

    hPrinter - Handle to the printer object
    pdwSize - Returns the form-to-tray assignment table size

Return Value:

    Pointer to form-to-tray assignment table read from the registry
    NULL if there is an error

--*/
{

    PWSTR   pwstrNewTable;
    PWSTR   pwstrOld, pwstrEnd, pwstrNew;
    DWORD   dwTableSize, dwNewTableSize, dwTrayName, dwFormName;
    FORM_TRAY_TABLE pFormTrayTable;

    //
    // Read unidrv form-tray-assignment table, kludgy since unidrv
    // table does not include a size
    //

    if ((pFormTrayTable = PtstrGetPrinterDataString(hPrinter,
                                                  REGVAL_TRAYFORM_TABLE_RASDD,
                                                  &dwTableSize)) == NULL)
        return NULL;

    //
    // Convert the old format form-to-tray assignment table to new format
    // OLD                      NEW
    // Tray Name                Tray Name
    // Form Name                Form Name
    // SelectStr
    //

    pwstrOld = pFormTrayTable;
    pwstrEnd = pwstrOld + (dwTableSize / sizeof(WCHAR) - 1);

    //
    // Figuring out the size of new table,
    // the last field in the table must be a NUL so add count for it here first
    //

    dwNewTableSize = 1;

    while (pwstrOld < pwstrEnd && *pwstrOld != NUL)
    {
        dwTrayName = wcslen(pwstrOld) + 1;
        pwstrOld  += dwTrayName;
        dwFormName = wcslen(pwstrOld) + 1;
        pwstrOld  += dwFormName;

        //
        // New format contain only TrayName and FormName
        //

        dwNewTableSize += dwTrayName + dwFormName;

        //
        // Skip SelectStr
        //

        pwstrOld += wcslen(pwstrOld) + 1;

    }

    dwNewTableSize *= sizeof(WCHAR);

    if ((pwstrOld != pwstrEnd) ||
        (pwstrNewTable = MemAlloc(dwNewTableSize)) == NULL)
    {
        ERR(( "Couldn't convert form-to-tray assignment table.\n"));
        MemFree(pFormTrayTable);
        return FALSE;
    }

    pwstrOld = pFormTrayTable ;
    pwstrNew = pwstrNewTable;

    while (pwstrOld < pwstrEnd)
    {
        //
        // Copy slot name, form name
        //

        PWSTR   pwstrSave = pwstrOld;

        pwstrOld += wcslen(pwstrOld) + 1;
        pwstrOld += wcslen(pwstrOld) + 1;

        memcpy(pwstrNew, pwstrSave, (DWORD)(pwstrOld - pwstrSave) * sizeof(WCHAR));
        pwstrNew += (pwstrOld - pwstrSave);

        //
        // skip SelectStr
        //

        pwstrOld += wcslen(pwstrOld) + 1;

    }

    *pwstrNew = NUL;

    if (pdwSize)
        *pdwSize = dwNewTableSize;

    MemFree(pFormTrayTable);

    return(pwstrNewTable);
}



#ifndef KERNEL_MODE

BOOL
BSaveAsOldVersionFormTrayTable(
    IN HANDLE           hPrinter,
    IN FORM_TRAY_TABLE  pwstrTable,
    IN DWORD            dwTableSize
    )

/*++

Routine Description:

    Save form-to-tray assignment table in NT 4.0 compatible format

Arguments:

    hPrinter - Handle to the current printer
    pwstrTable - Points to new format form-tray table
    dwTableSize - Size of form-tray table to be saved, in bytes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwOldTableSize;
    PWSTR   pwstrNew, pwstrOld, pwstrOldTable;
    DWORD   dwStatus;

    //
    // Find out how much memory to allocate for old format table
    //

    ASSERT(dwTableSize % sizeof(WCHAR) == 0 && dwTableSize >= sizeof(WCHAR));
    pwstrNew = pwstrTable;
    dwOldTableSize = dwTableSize;

    while (*pwstrNew != NUL)
    {
        //
        // Skip tray name, form name
        //

        pwstrNew += wcslen(pwstrNew) + 1;

        //
        // If form name is "Not Available", NT4 drivers writes L"0" to
        // the buffer so we do the same.
        //

        if (*pwstrNew == NUL)
        {
            dwOldTableSize += sizeof(WCHAR);
            pwstrNew++;
        }
        else
            pwstrNew += wcslen(pwstrNew) + 1;

        //
        // Extra 2 characters per entry for SelectStr
        //

        dwOldTableSize += 2*sizeof(WCHAR);
    }

    if ((pwstrOldTable = MemAllocZ(dwOldTableSize)) == NULL)
    {
        ERR(( "Memory allocation failed\n"));
        return FALSE;
    }

    //
    // Copy the new tray, form to old format table
    //

    pwstrNew = pwstrTable;
    pwstrOld = pwstrOldTable;

    while (*pwstrNew != NUL)
    {
        //
        // Copy slot name, form name
        //

        PWSTR   pwstrSave = pwstrNew;

        pwstrNew += wcslen(pwstrNew) + 1;

        memcpy(pwstrOld, pwstrSave, (DWORD)(pwstrNew - pwstrSave) * sizeof(WCHAR));
        pwstrOld += (pwstrNew - pwstrSave);

        //
        // If form name is "Not Available", NT4 drivers writes L"0" to
        // the buffer so we do the same.
        //

         if (*pwstrNew == NUL)
        {
            *pwstrOld++ = L'0';
            *pwstrOld++ = NUL;
            pwstrNew++;
        }
        else
        {
            pwstrSave = pwstrNew;
            pwstrNew += wcslen(pwstrNew) + 1;
            memcpy(pwstrOld, pwstrSave, (DWORD)(pwstrNew - pwstrSave) * sizeof(WCHAR));
            pwstrOld += (pwstrNew - pwstrSave);
        }

        //
        // Set SelectStr to be NUL
        //

        *pwstrOld++ = L'0';
        *pwstrOld++ = NUL;
    }

    *pwstrOld = NUL;

    //
    // Save to registry under old key
    //

    dwStatus = SetPrinterData(hPrinter,
                              REGVAL_TRAYFORM_TABLE_RASDD,
                              REG_MULTI_SZ,
                              (PBYTE) pwstrOldTable,
                              dwOldTableSize);

    MemFree(pwstrOldTable);
    return (dwStatus == ERROR_SUCCESS);
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\fiutils.c ===
/****************************Module*Header******************************\
* Module Name: FIUTILS.C
*
* Module Descripton:
*      This file has utility functions that handle NT5 Unidrv font files.
*
* Warnings:
*
* Issues:
*
* Created:  11 November 1997
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "precomp.h"

//
// External functions
//

BOOL WINAPI GetPrinterDriverDirectoryW(LPWSTR, LPWSTR, DWORD, LPBYTE, DWORD, LPDWORD);
BOOL WINAPI GetPrinterW(HANDLE, DWORD, LPBYTE, DWORD, LPDWORD);;

//
// Internal data structures
//

//
// Structure used to remember which glyph set data's have been written to file
//

typedef struct _FI_GLYPHDATA {
    SHORT   sGlyphID;           // unique glyph ID
    WORD    wPadding;           // set to zero
    DWORD   gdPos;              // position of glyph data inside file
} FI_GLYPHDATA, *PFI_GLYPHDATA;

//
// The handle we pass out is a pointer to this structure
//

typedef  struct tagFI_FILE
{
    DWORD              dwSignature;            // Signature of data structure
    HANDLE             hPrinter;               // Handle of printer for using spooler funcs
    HANDLE             hHeap;                  // Handle to heap to use

    WCHAR              wchFileName[MAX_PATH];  // Name of font file

    HANDLE             hFile;                  // Handle of open file

    PUFF_FILEHEADER    pFileHdr;               // Pointer to file header
    PUFF_FONTDIRECTORY pFontDir;               // Pointer to font directory
    DWORD              dwCurPos;               // Current position of write in file

    DWORD              dwFlags;                // Miscellaneous flags

    //
    // The following are used only if read access is present
    //

    PBYTE              pView;                  // Pointer to view of file

    //
    // The following are used only if write access is present
    //

    PFI_GLYPHDATA      pGlyphData;             // Pointer to glyphs that have been written
    DWORD              nGlyphs;                // Number of glyphs written

} FI_FILE, *PFI_FILE;


//
// Internal functions
//

#ifdef KERNEL_MODE
HANDLE OpenFontFile(HANDLE, HANDLE, HANDLE, PWSTR);
#else
HANDLE OpenFontFile(HANDLE, HANDLE, PWSTR);
#endif
BOOL   WriteData(PFI_FILE, PDATA_HEADER);
void   Qsort(PUFF_FONTDIRECTORY, int, int);
void   Exchange(PUFF_FONTDIRECTORY, DWORD, DWORD);
BOOL   GetFontCartridgeFile(HANDLE, HANDLE);

#define FONT_INFO_SIGNATURE          'fnti'

#define FI_FLAG_READ             0x00000001
#define FI_FLAG_WRITE            0x00000002

#define IsValidFontInfo(pfi)         ((pfi) && (pfi)->dwSignature == FONT_INFO_SIGNATURE)

#ifdef KERNEL_MODE
#define ALLOC(hHeap, dwSize)         MemAlloc(dwSize)
#define FREE(hHeap, pBuf)            MemFree(pBuf)
#else
#define ALLOC(hHeap, dwSize)         HeapAlloc((hHeap), HEAP_ZERO_MEMORY, (dwSize))
#define FREE(hHeap, pBuf)            HeapFree((hHeap), 0, (pBuf))
#endif

/******************************************************************************
 * Functions that handle files that have been opened with read privileges
 ******************************************************************************/

/******************************************************************************
 *
 *                          FIOpenFontFile
 *
 *  Function:
 *       This function opens the font file associated with the specified printer
 *       for read access.
 *
 *  Arguments:
 *       hPrinter       - Handle identifying printer
 *       hHeap          - Handle of heap to use for memory allocations
 *       bCartridgeFile - Specifies if the font cartridge file is to be opened
 *                        or the currently installed fonts file
 *
 *  Returns:
 *       Handle to use in subsequent calls if successful, NULL otherwise
 *
 ******************************************************************************/

HANDLE
FIOpenFontFile(
    HANDLE  hPrinter,
#ifdef KERNEL_MODE
    HANDLE hdev,
#endif
    HANDLE  hHeap
    )
{
#ifdef KERNEL_MODE
    return OpenFontFile(hPrinter, hdev, hHeap, REGVAL_FONTFILENAME);
#else
    return OpenFontFile(hPrinter, hHeap, REGVAL_FONTFILENAME);
#endif
}


HANDLE
FIOpenCartridgeFile(
    HANDLE  hPrinter,
#ifdef KERNEL_MODE
    HANDLE hdev,
#endif
    HANDLE  hHeap
    )
{
#ifdef KERNEL_MODE
    return OpenFontFile(hPrinter, hdev, hHeap, REGVAL_CARTRIDGEFILENAME);
#else
    return OpenFontFile(hPrinter, hHeap, REGVAL_CARTRIDGEFILENAME);
#endif
}

HANDLE
OpenFontFile(
    HANDLE hPrinter,
#ifdef KERNEL_MODE
    HANDLE hdev,
#endif
    HANDLE hHeap,
    PWSTR  pwstrRegVal
    )
{
    FI_FILE  *pFIFile = NULL;
    DWORD    dwSize, dwStatus, dwType;
    BOOL     bRc = FALSE;

    //
    // Allocate FI_FILE structure
    //

    if (!(pFIFile = (FI_FILE *)ALLOC(hHeap, sizeof(FI_FILE))))
    {
        WARNING(("Could not allocate memory for opening Font File\n"));
        return NULL;
    }
    pFIFile->dwSignature = FONT_INFO_SIGNATURE;
    pFIFile->hPrinter = hPrinter;
    pFIFile->hHeap = hHeap;
    pFIFile->pView = NULL;
    pFIFile->dwFlags = 0;

    //
    // If we are opening the cartridge file, and we are on the client, get it
    // from the server
    //

    #ifndef KERNEL_MODE
    if (wcscmp(pwstrRegVal, REGVAL_CARTRIDGEFILENAME) == 0)
    {
        if (!BGetFontCartridgeFile(hPrinter, hHeap))
            goto EndOpenRead;
    }
    #endif

    //
    // Get the name of the font file - strip off the directory path as it may have the
    // server path - generate the local path instead
    //

    {
        WCHAR wchFileName[MAX_PATH];
        PWSTR pName;

        #ifdef KERNEL_MODE

        PDRIVER_INFO_3  pdi3;

        if (!(pdi3 = MyGetPrinterDriver(hPrinter, hdev, 3)))
            goto EndOpenRead;

        StringCchCopyW(pFIFile->wchFileName, CCHOF(pFIFile->wchFileName), pdi3->pDriverPath);

        MemFree(pdi3);

        //
        // We have something like "c:\nt\system32\spool\drivers\w32x86\3\unidrv.dll".
        // We need only till drivers, so we search backwards for the 3rd '\\'.
        //

        if (pName = wcsrchr(pFIFile->wchFileName, '\\'))
        {
            *pName = '\0';

            if (pName = wcsrchr(pFIFile->wchFileName, '\\'))
            {
                *pName = '\0';

                if (pName = wcsrchr(pFIFile->wchFileName, '\\'))
                    *pName = '\0';
            }
        }

        if (!pName)
            goto EndOpenRead;

        #else

        dwSize = sizeof(pFIFile->wchFileName);
        if (!GetPrinterDriverDirectoryW(NULL, NULL, 1, (PBYTE)pFIFile->wchFileName, dwSize, &dwSize))
            goto EndOpenRead;

        //
        // Get rid of the processor architecture part
        //

        if (pName = wcsrchr(pFIFile->wchFileName, '\\'))
            *pName = '\0';

        #endif

        //
        // Add "unifont"
        //

        StringCchCatW(pFIFile->wchFileName, CCHOF(pFIFile->wchFileName), FONTDIR);

        //
        // Get font file name from registry
        //

        dwSize = sizeof(wchFileName);
        dwStatus = GetPrinterData(hPrinter, pwstrRegVal, &dwType, (PBYTE)wchFileName, dwSize, &dwSize);

        if (dwStatus != ERROR_MORE_DATA && dwStatus != ERROR_SUCCESS)
            goto EndOpenRead;         // No font file is available

        //
        // Strip any directory prefix from the font filename
        //

        if (pName = wcsrchr(wchFileName, '\\'))
            pName++;
        else
            pName = wchFileName;

        StringCchCatW(pFIFile->wchFileName, CCHOF(pFIFile->wchFileName), pName);
    }

    //
    // Memory map the file
    //

    #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
    {
        PBYTE  pTemp = NULL;
        DWORD  dwSize;
        HANDLE hFile;

        hFile = MapFileIntoMemory(pFIFile->wchFileName, &pTemp, &dwSize);
        if (!pTemp)
        {
            goto EndOpenRead;
        }
        pFIFile->pView = ALLOC(hHeap, dwSize);
        if (pFIFile->pView)
        {
            memcpy(pFIFile->pView, pTemp, dwSize);
        }
        UnmapFileFromMemory((HFILEMAP)hFile);
    }
    #else
    pFIFile->hFile = MapFileIntoMemory(pFIFile->wchFileName, &pFIFile->pView, NULL);
    #endif

    if (!pFIFile->pView)
    {
        WARNING(("Err %ld, could not create view of profile %s\n",
            GetLastError(), pFIFile->wchFileName));
        goto EndOpenRead;
    }

    //
    // Check validity of font file
    //

    pFIFile->pFileHdr = (PUFF_FILEHEADER)pFIFile->pView;

    if (pFIFile->pFileHdr->dwSignature != UFF_FILE_MAGIC ||
        pFIFile->pFileHdr->dwVersion != UFF_VERSION_NUMBER ||
        pFIFile->pFileHdr->dwSize != sizeof(UFF_FILEHEADER))
    {
        WARNING(("Invalid font file %s\n", pFIFile->wchFileName));
        goto EndOpenRead;
    }

    //
    // Set other fields
    //

    if (pFIFile->pFileHdr->offFontDir)
    {
        pFIFile->pFontDir = (PUFF_FONTDIRECTORY)(pFIFile->pView + pFIFile->pFileHdr->offFontDir);
    }

    pFIFile->dwCurPos = 0;
    pFIFile->dwFlags = FI_FLAG_READ;
    pFIFile->pGlyphData = NULL;
    pFIFile->nGlyphs = 0;

    bRc = TRUE;

    EndOpenRead:

    if (!bRc)
    {
        FICloseFontFile((HANDLE)pFIFile);
        pFIFile = NULL;
    }

    return (HANDLE)pFIFile;
}


/******************************************************************************
 *
 *                          FICloseFontFile
 *
 *  Function:
 *       This function closes the given font file and frees all memory
 *       associated with it
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file to close
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

VOID
FICloseFontFile(
    HANDLE hFontFile
)
{
    FI_FILE  *pFIFile = (FI_FILE*)hFontFile;

    if (IsValidFontInfo(pFIFile))
    {
        if (pFIFile->dwFlags & FI_FLAG_READ)
        {
            //
            // Memory mapped file was opened, close it
            //

            if (pFIFile->pView)
            {
                #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
                FREE(pFIFile->hHeap, pFIFile->pView);
                #else
                UnmapFileFromMemory((HFILEMAP)pFIFile->hFile);
                #endif
            }
        }
        #ifndef KERNEL_MODE
        else
        {
            //
            // New file was created, free all allocated memory
            //

            if (pFIFile->pFileHdr)
            {
                FREE(pFIFile->hHeap, pFIFile->pFileHdr);
            }

            if (pFIFile->pFontDir)
            {
                FREE(pFIFile->hHeap, pFIFile->pFontDir);
            }

            if (pFIFile->hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(pFIFile->hFile);
            }

            if (pFIFile->pGlyphData)
            {
                FREE(pFIFile->hHeap, pFIFile->pGlyphData);
            }
        }
        #endif

        FREE(pFIFile->hHeap, pFIFile);
    }

    return;
}


/******************************************************************************
 *
 *                          FIGetNumFonts
 *
 *  Function:
 *       This function retrieves the number of fonts present in the given
 *       font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *
 *  Returns:
 *       Number of font present if successful, 0 otherwise
 *
 ******************************************************************************/

DWORD
FIGetNumFonts(
    HANDLE hFontFile
    )
{
    FI_FILE  *pFIFile = (FI_FILE*)hFontFile;

    return IsValidFontInfo(pFIFile) ? pFIFile->pFileHdr->nFonts : 0;
}


/******************************************************************************
 *
 *                          FIGetFontDir
 *
 *  Function:
 *       This function retrieves a pointer to the font directory of the
 *       given font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *
 *  Returns:
 *       Pointer to font directory if successful, NULL otherwise
 *
 ******************************************************************************/

PUFF_FONTDIRECTORY
FIGetFontDir(
    HANDLE hFontFile
    )
{
    FI_FILE  *pFIFile = (FI_FILE*)hFontFile;

    return IsValidFontInfo(pFIFile) ? pFIFile->pFontDir : NULL;
}


/******************************************************************************
 *
 *                          FIGetFontName
 *
 *  Function:
 *       This function retrieves a pointer to the name of the iFontIndex'th font
 *       in the given font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *       iFontIndex     - Index of the font whose name is to be retrieved
 *
 *  Returns:
 *       Pointer to font name if successful, NULL otherwise
 *
 ******************************************************************************/

PWSTR
FIGetFontName(
    HANDLE hFontFile,
    DWORD  iFontIndex
    )
{
    FI_FILE   *pFIFile = (FI_FILE*)hFontFile;
    PWSTR     pwstrFontName = NULL;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_READ))
    {
        if (iFontIndex < pFIFile->pFileHdr->nFonts)
        {
            pwstrFontName = (PWSTR)(pFIFile->pView + pFIFile->pFontDir[iFontIndex].offFontName);
        }
    }

    return pwstrFontName;
}


/******************************************************************************
 *
 *                          FIGetFontCartridgeName
 *
 *  Function:
 *       This function retrieves a pointer to the name of the iFontIndex'th font
 *       cartridge in the given font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *       iFontIndex     - Index of the font whose cartridge name is to be retrieved
 *
 *  Returns:
 *       Pointer to font cartridge name if present, NULL otherwise
 *
 ******************************************************************************/

PWSTR
FIGetFontCartridgeName(
    HANDLE hFontFile,
    DWORD  iFontIndex
    )
{
    FI_FILE    *pFIFile = (FI_FILE*)hFontFile;
    PWSTR      pwstrCartridgeName = NULL;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_READ))
    {
        if (iFontIndex < pFIFile->pFileHdr->nFonts)
        {
            pwstrCartridgeName = pFIFile->pFontDir[iFontIndex].offCartridgeName ?
                (PWSTR)(pFIFile->pView + pFIFile->pFontDir[iFontIndex].offCartridgeName) : NULL;
        }
    }

    return pwstrCartridgeName;
}


/******************************************************************************
 *
 *                          FIGetFontData
 *
 *  Function:
 *       This function retrieves a pointer to the font data for the
 *       iFontIndex'th font in the given font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *       iFontIndex     - Index of the font whose font data is to be retrieved
 *
 *  Returns:
 *       Pointer to font data if successful, NULL otherwise
 *
 ******************************************************************************/

PDATA_HEADER
FIGetFontData(
    HANDLE hFontFile,
    DWORD  iFontIndex
    )
{
    FI_FILE        *pFIFile = (FI_FILE*)hFontFile;
    PDATA_HEADER   pData = NULL;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_READ))
    {

        if (iFontIndex < pFIFile->pFileHdr->nFonts)
        {
            pData = (PDATA_HEADER)(pFIFile->pView + pFIFile->pFontDir[iFontIndex].offFontData);
        }
    }

    return pData;
}


/******************************************************************************
 *
 *                          FIGetGlyphData
 *
 *  Function:
 *       This function retrieves a pointer to the glyph data for the
 *       iFontIndex'th font in the given font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *       iFontIndex     - Index of the font whose glyph data is to be retrieved
 *
 *  Returns:
 *       Pointer to glyph data if successful, NULL otherwise
 *
 ******************************************************************************/

PDATA_HEADER
FIGetGlyphData(
    HANDLE hFontFile,
    DWORD  iFontIndex
    )
{
    FI_FILE        *pFIFile = (FI_FILE*)hFontFile;
    PDATA_HEADER   pData = NULL;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_READ))
    {
        if (iFontIndex < pFIFile->pFileHdr->nFonts)
        {
            pData = pFIFile->pFontDir[iFontIndex].offGlyphData ?
                (PDATA_HEADER)(pFIFile->pView + pFIFile->pFontDir[iFontIndex].offGlyphData) : NULL;
        }
    }

    return pData;
}


/******************************************************************************
 *
 *                          FIGetVarData
 *
 *  Function:
 *       This function retrieves a pointer to the variable data for the
 *       iFontIndex'th font in the given font file
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *       iFontIndex     - Index of the font whose variable data is to be retrieved
 *
 *  Returns:
 *       Pointer to variable data if present, NULL otherwise
 *
 ******************************************************************************/

PDATA_HEADER
FIGetVarData(
    HANDLE hFontFile,
    DWORD  iFontIndex
    )
{
    FI_FILE        *pFIFile = (FI_FILE*)hFontFile;
    PDATA_HEADER   pData = NULL;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_READ))
    {

        if (iFontIndex < pFIFile->pFileHdr->nFonts)
        {
            pData = pFIFile->pFontDir[iFontIndex].offVarData ?
                (PDATA_HEADER)(pFIFile->pView + pFIFile->pFontDir[iFontIndex].offVarData) : NULL;
        }
    }

    return pData;
}

#ifndef KERNEL_MODE

/******************************************************************************
 * Functions that handle files that have been opened with write privileges
 ******************************************************************************/

/******************************************************************************
 *
 *                          FICreateFontFile
 *
 *  Function:
 *       This function creates a new font file with only write access.
 *
 *  Arguments:
 *       hPrinter       - Handle identifying printer
 *       hHeap          - Handle of heap to use for memory allocations
 *
 *  Returns:
 *       Handle to use in subsequent calls if successful, NULL otherwise
 *
 ******************************************************************************/

HANDLE
FICreateFontFile(
    HANDLE  hPrinter,
    HANDLE  hHeap,
    DWORD   cFonts
    )
{
    FI_FILE  *pFIFile = NULL;
    PWSTR    pName, pstrGuid;
    DWORD    dwSize;
    UUID     guid;
    BOOL     bRc = FALSE;

    //
    // Allocate FI_FILE structure
    //

    if (!(pFIFile = (FI_FILE *)ALLOC(hHeap, sizeof(FI_FILE))))
    {
        WARNING(("Could not allocate memory for creating Font File\n"));
        return NULL;
    }
    pFIFile->dwSignature = FONT_INFO_SIGNATURE;
    pFIFile->hPrinter = hPrinter;
    pFIFile->hHeap = hHeap;

    //
    // Generate file name for font file
    //

    dwSize = sizeof(pFIFile->wchFileName);
    if (!GetPrinterDriverDirectoryW(NULL, NULL, 1, (PBYTE)pFIFile->wchFileName, dwSize, &dwSize))
    {
        WARNING(("Error getting printer driver directory"));
        goto EndCreateNew;
    }

    //
    // Get rid of the processor architecture part
    //

    if (pName = wcsrchr(pFIFile->wchFileName, '\\'))
        *pName = '\0';

    //
    // Add "unifont"
    //

    StringCchCatW(pFIFile->wchFileName, CCHOF(pFIFile->wchFileName), FONTDIR);

    //
    // Make sure the local directory is created
    //

    if ( ! CreateDirectory(pFIFile->wchFileName, NULL) )
    {
        WARNING(("Error creating directory %s", pFIFile->wchFileName));
        goto EndCreateNew;
    }

    if ((UuidCreate(&guid) != RPC_S_OK) ||
        (UuidToString(&guid, &pstrGuid) != RPC_S_OK))
    {
        WARNING(("Error getting a guid string\n"));
        goto EndCreateNew;
    }
    StringCchCatW(pFIFile->wchFileName, CCHOF(pFIFile->wchFileName), pstrGuid);
    StringCchCatW(pFIFile->wchFileName, CCHOF(pFIFile->wchFileName), L".UFF");

    RpcStringFree(&pstrGuid);

    pFIFile->hFile = CreateFile(pFIFile->wchFileName,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_FLAG_RANDOM_ACCESS | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                                NULL);

    if (pFIFile->hFile == INVALID_HANDLE_VALUE)
    {
        WARNING(("Error creating file %s", pFIFile->wchFileName));
        goto EndCreateNew;
    }


    //
    // Set other fields
    //

    pFIFile->dwFlags = FI_FLAG_WRITE;   // Give write access alone
    pFIFile->dwCurPos = 0;

    //
    // Allocate memory for remembering glyph datas that have been written.
    // Max memory needed is if each font has a different glyph data.
    //

    pFIFile->pGlyphData = (PFI_GLYPHDATA)ALLOC(hHeap, cFonts * sizeof(FI_GLYPHDATA));
    if (!pFIFile->pGlyphData)
    {
        WARNING(("Error allocating memory for tracking glyph data\n"));
        goto EndCreateNew;
    }
    pFIFile->nGlyphs = 0;

    //
    // Allocate memory for the file header and font directory
    //

    pFIFile->pFileHdr = (PUFF_FILEHEADER)ALLOC(hHeap, sizeof(UFF_FILEHEADER));
    pFIFile->pFontDir = (PUFF_FONTDIRECTORY)ALLOC(hHeap, cFonts * sizeof(UFF_FONTDIRECTORY));
    if (!pFIFile->pFileHdr || !pFIFile->pFontDir)
    {
        WARNING(("Error allocating memory for file header or font directory\n"));
        goto EndCreateNew;
    }

    //
    // Initialize file header
    //

    pFIFile->pFileHdr->dwSignature = UFF_FILE_MAGIC;
    pFIFile->pFileHdr->dwVersion   = UFF_VERSION_NUMBER;
    pFIFile->pFileHdr->dwSize      = sizeof(UFF_FILEHEADER);
    pFIFile->pFileHdr->nFonts      = cFonts;
    if (cFonts)
    {
        pFIFile->pFileHdr->offFontDir  = sizeof(UFF_FILEHEADER);
    }

    bRc = TRUE;

EndCreateNew:
    if (!bRc)
    {
        FICloseFontFile((HANDLE)pFIFile);
        pFIFile = NULL;
    }

    return (HANDLE)pFIFile;
}


/******************************************************************************
 *
 *                          FIWriteFileHeader
 *
 *  Function:
 *       This function seeks to the beginning of the file and writes the
 *       file header
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *
 *  Returns:
 *      TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
FIWriteFileHeader(
    HANDLE hFontFile
    )
{
    FI_FILE  *pFIFile = (FI_FILE*)hFontFile;
    DWORD     dwSize;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_WRITE))
    {
        if (pFIFile->dwCurPos != 0)
        {
            pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, 0, 0, FILE_BEGIN);
        }

        if (!WriteFile(pFIFile->hFile, (PVOID)pFIFile->pFileHdr, sizeof(UFF_FILEHEADER), &dwSize, NULL))
        {
            return FALSE;
        }
        pFIFile->dwCurPos += dwSize;
    }

    return TRUE;
}


/******************************************************************************
 *
 *                          FIWriteFontDirectory
 *
 *  Function:
 *       This function seeks to the right place in the file and writes the
 *       font directory. It sorts it by font ID if it is not already sorted.
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *
 *  Returns:
 *      TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
FIWriteFontDirectory(
    HANDLE hFontFile
    )
{
    FI_FILE  *pFIFile = (FI_FILE*)hFontFile;
    DWORD     dwSize;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_WRITE))
    {
        //
        // If there are no fonts, there is nothing to write
        //

        if (pFIFile->pFileHdr->offFontDir == 0)
            return TRUE;

        //
        // Seek to right place
        //

        if (pFIFile->dwCurPos != pFIFile->pFileHdr->offFontDir)
        {
            pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->pFileHdr->offFontDir, 0, FILE_BEGIN);
        }

        //
        // Sort the font directory
        //

        Qsort(pFIFile->pFontDir, (int)0, (int)pFIFile->pFileHdr->nFonts-1);
        pFIFile->pFileHdr->dwFlags |= FONT_DIR_SORTED;

        if (!WriteFile(pFIFile->hFile, (PVOID)pFIFile->pFontDir, pFIFile->pFileHdr->nFonts*sizeof(UFF_FONTDIRECTORY), &dwSize, NULL))
        {
            return FALSE;
        }
        pFIFile->dwCurPos += dwSize;

    }

    return TRUE;
}


/******************************************************************************
 *
 *                          FIAlignedSeek
 *
 *  Function:
 *       This function seeks forward by the specified amount and then some if
 *       required so you end up DWORD aligned
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file
 *       lSeekDist      - Amount to seek forward by
 *
 *  Returns:
 *       Handle to use in subsequent calls if successful, NULL otherwise
 *
 ******************************************************************************/

VOID
FIAlignedSeek(
    HANDLE hFontFile,
    DWORD  dwSeekDist
    )
{
    FI_FILE  *pFIFile = (FI_FILE*)hFontFile;

    if (IsValidFontInfo(pFIFile) && (pFIFile->dwFlags & FI_FLAG_WRITE))
    {
        pFIFile->dwCurPos += dwSeekDist;
        pFIFile->dwCurPos = (pFIFile->dwCurPos + 3) & ~3;      // DWORD align
        pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->dwCurPos, 0, FILE_BEGIN);
    }

    return;
}


/******************************************************************************
 *
 *                          FICopyFontRecord
 *
 *  Function:
 *       This function copies a font record including the directory entry,
 *       font meetrics, glyph data and variable data from one font file
 *       to another.
 *
 *  Arguments:
 *       hWriteFile     - Handle identifying font file to write into
 *       hReadFile      - Handle identifying font file to read from
 *       dwWrIndex      - Index of font to write into in write file
 *       dwRdIndex      - Index of font to read from in read file
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
FICopyFontRecord(
    HANDLE hWriteFile,
    HANDLE hReadFile,
    DWORD  dwWrIndex,
    DWORD  dwRdIndex
    )
{
    FI_FILE     *pFIWrFile = (FI_FILE*)hWriteFile;
    FI_FILE     *pFIRdFile = (FI_FILE*)hReadFile;
    PDATA_HEADER pData;
    PWSTR        pName;
    DWORD        dwSize;
    DWORD        j, gdPos;

    if (!IsValidFontInfo(pFIWrFile) ||
        !IsValidFontInfo(pFIRdFile) ||
        !(pFIWrFile->dwFlags & FI_FLAG_WRITE) ||
        !(pFIRdFile->dwFlags & FI_FLAG_READ))
    {
        return FALSE;
    }

    //
    // Copy the font directory entry
    //

    pFIWrFile->pFontDir[dwWrIndex].dwSignature = FONT_REC_SIG;
    pFIWrFile->pFontDir[dwWrIndex].wSize = (WORD)sizeof(UFF_FONTDIRECTORY);
    pFIWrFile->pFontDir[dwWrIndex].wFontID  = (WORD)dwWrIndex;
    pFIWrFile->pFontDir[dwWrIndex].sGlyphID = pFIRdFile->pFontDir[dwRdIndex].sGlyphID;
    pFIWrFile->pFontDir[dwWrIndex].wFlags   = pFIRdFile->pFontDir[dwRdIndex].wFlags;
    pFIWrFile->pFontDir[dwWrIndex].dwInstallerSig = pFIRdFile->pFontDir[dwRdIndex].dwInstallerSig;

    //
    // Write font name
    //

    pName = FIGetFontName(hReadFile, dwRdIndex);

    ASSERT(pName != NULL);          // Can't have NULL font name
    if (NULL == pName)
    {
        return FALSE;
    }

    pFIWrFile->pFontDir[dwWrIndex].offFontName = pFIWrFile->dwCurPos;
    if (!WriteFile(pFIWrFile->hFile, (PVOID)pName, (lstrlen(pName)+1) * sizeof(TCHAR), &dwSize, NULL))
    {
        WARNING(("Error writing font name\n"));
        return FALSE;
    }

    pFIWrFile->dwCurPos += dwSize;
    pFIWrFile->dwCurPos = (pFIWrFile->dwCurPos + 3) & ~3;
    pFIWrFile->dwCurPos = SetFilePointer(pFIWrFile->hFile, pFIWrFile->dwCurPos, 0, FILE_BEGIN);

    //
    // Write font cartridge name
    //

    pName = FIGetFontCartridgeName(hReadFile, dwRdIndex);

    if (pName == NULL)
    {
        pFIWrFile->pFontDir[dwRdIndex].offCartridgeName = 0;
    }
    else
    {
        pFIWrFile->pFontDir[dwWrIndex].offCartridgeName = pFIWrFile->dwCurPos;
        if (!WriteFile(pFIWrFile->hFile, (PVOID)pName, (lstrlen(pName)+1) * sizeof(TCHAR), &dwSize, NULL))
        {
            WARNING(("Error writing font cartridge name\n"));
            return FALSE;
        }
        pFIWrFile->dwCurPos += dwSize;
        pFIWrFile->dwCurPos = (pFIWrFile->dwCurPos + 3) & ~3;
        pFIWrFile->dwCurPos = SetFilePointer(pFIWrFile->hFile, pFIWrFile->dwCurPos, 0, FILE_BEGIN);
    }

    //
    // Write font data
    //

    pData = FIGetFontData(hReadFile, dwRdIndex);

    ASSERT(pData != NULL);          // Can't have NULL font data

    pFIWrFile->pFontDir[dwWrIndex].offFontData = pFIWrFile->dwCurPos;
    if (!WriteData(pFIWrFile, pData))
        return FALSE;

    //
    // Get glyph data from read file
    //

    pData = FIGetGlyphData(pFIRdFile, dwRdIndex);
    if (pData)
    {
        //
        // Check if it is already in write file
        //

        gdPos = 0;
        for (j=0; j<pFIWrFile->nGlyphs; j++)
        {
            if (pFIWrFile->pGlyphData[j].sGlyphID == pFIWrFile->pFontDir[dwWrIndex].sGlyphID)
            {
                gdPos = pFIWrFile->pGlyphData[j].gdPos;
            }
        }


        if (gdPos == 0)
        {
            //
            // Not there yet - add to set of glyph data's that have been
            // added to file, and write it into write file
            //

            pFIWrFile->pGlyphData[pFIWrFile->nGlyphs].sGlyphID = pFIWrFile->pFontDir[dwWrIndex].sGlyphID;
            pFIWrFile->pGlyphData[pFIWrFile->nGlyphs].gdPos = pFIWrFile->dwCurPos;
            pFIWrFile->nGlyphs++;


            pFIWrFile->pFontDir[dwWrIndex].offGlyphData = pFIWrFile->dwCurPos;
            if (!WriteData(pFIWrFile, pData))
                return FALSE;

            pFIWrFile->pFileHdr->nGlyphSets++;
        }
        else
        {
            //
            // Already in file, just update location
            //

            pFIWrFile->pFontDir[dwWrIndex].offGlyphData = gdPos;
        }
    }
    else
    {
        //
        // Glyph data not present
        //

        pFIWrFile->pFontDir[dwWrIndex].offGlyphData = 0;
    }

    //
    // Write var data
    //

    pData = FIGetVarData(pFIRdFile, dwRdIndex);
    if (pData)
    {
        pFIWrFile->pFontDir[dwWrIndex].offVarData = pFIWrFile->dwCurPos;
        if (!WriteData(pFIWrFile, pData))
            return FALSE;

        pFIWrFile->pFileHdr->nVarData++;
    }
    else
        pFIWrFile->pFontDir[dwWrIndex].offVarData = 0;

    return TRUE;
}


/******************************************************************************
 *
 *                          FIAddFontRecord
 *
 *  Function:
 *       This function adds a font record including the directory entry,
 *       font meetrics, glyph data and variable data
 *
 *  Arguments:
 *       hFontFile      - Handle identifying font file to write
 *       dwIndex        - Index of font to write
 *       pFntDat        - Information about font to add
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
FIAddFontRecord(
    HANDLE  hFontFile,
    DWORD   dwIndex,
    FNTDAT *pFntDat
    )
{
    FI_FILE     *pFIFile = (FI_FILE*)hFontFile;
    PDATA_HEADER pData;
    PWSTR        pName;
    DWORD        dwSize;
    DWORD        j, gdPos;

    if (!IsValidFontInfo(pFIFile) ||
        !(pFIFile->dwFlags & FI_FLAG_WRITE))
    {
        return FALSE;
    }

    //
    // Initialize the font directory entry
    //

    pFIFile->pFontDir[dwIndex].dwSignature = FONT_REC_SIG;
    pFIFile->pFontDir[dwIndex].wSize = sizeof(UFF_FONTDIRECTORY);
    pFIFile->pFontDir[dwIndex].wFontID = (WORD)dwIndex;
    pFIFile->pFontDir[dwIndex].sGlyphID = (short)pFntDat->fid.dsCTT.cBytes;
    pFIFile->pFontDir[dwIndex].wFlags = FONT_FL_SOFTFONT | FONT_FL_IFI | FONT_FL_GLYPHSET_RLE;
    pFIFile->pFontDir[dwIndex].dwInstallerSig = WINNT_INSTALLER_SIG;

    //
    // Write font name
    //

    pName = pFntDat->fid.dsIdentStr.pvData;

    ASSERT(pName != NULL);          // Can't have NULL font name

    pFIFile->pFontDir[dwIndex].offFontName = pFIFile->dwCurPos;
    if (!WriteFile(pFIFile->hFile, (PVOID)pName, (lstrlen(pName)+1) * sizeof(TCHAR), &dwSize, NULL))
    {
        WARNING(("Error writing font name\n"));
        return FALSE;
    }
    pFIFile->dwCurPos += dwSize;
    pFIFile->dwCurPos = (pFIFile->dwCurPos + 3) & ~3;
    pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->dwCurPos, 0, FILE_BEGIN);

    //
    // No font cartridge name
    //

    pFIFile->pFontDir[dwIndex].offCartridgeName = 0;

    //
    // Write font data
    //

    pFIFile->pFontDir[dwIndex].offFontData = pFIFile->dwCurPos;

    if ((dwSize = FIWriteFix(pFIFile->hFile, (WORD)dwIndex, &pFntDat->fid)) == 0)
    {
        WARNING(("Error writing fixed part of font data\n"));
        return FALSE;
    }
    pFIFile->dwCurPos += dwSize;
    pFIFile->dwCurPos = (pFIFile->dwCurPos + 3) & ~3;
    pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->dwCurPos, 0, FILE_BEGIN);

    //
    // Check if glyph data is already in new file
    //

    gdPos = 0;
    for (j=0; j<pFIFile->nGlyphs; j++)
    {
        if (pFIFile->pGlyphData[j].sGlyphID == pFIFile->pFontDir[dwIndex].sGlyphID)
        {
            gdPos = pFIFile->pGlyphData[j].gdPos;
            break;
        }
    }


    if (gdPos == 0)
    {
        HRSRC hrsrc;

        //
        // Get resource from our file
        //

        if (pFIFile->pFontDir[dwIndex].sGlyphID > 0)
        {
            hrsrc = FindResource(ghInstance, MAKEINTRESOURCE(pFIFile->pFontDir[dwIndex].sGlyphID), (LPWSTR)RC_TRANSTAB);

            if (!hrsrc)
            {
                WARNING(("Unable to find RLE resource %d in unidrvui\n", pFIFile->pFontDir[dwIndex].sGlyphID));
                return FALSE;
            }

            pData = (PDATA_HEADER)LockResource(LoadResource(ghInstance, hrsrc));
        }
        else
            pData = NULL;

        if (pData)
        {
            DATA_HEADER dh;

            dh.dwSignature = DATA_CTT_SIG;
            dh.wSize       = (WORD)sizeof(DATA_HEADER);
            dh.wDataID     = (WORD)pFIFile->pFontDir[dwIndex].sGlyphID;
            dh.dwDataSize  = SizeofResource(ghInstance, hrsrc);
            dh.dwReserved  = 0;

            pFIFile->pFontDir[dwIndex].offGlyphData = pFIFile->dwCurPos;

            if (!WriteFile(pFIFile->hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwSize, NULL) ||
                !WriteFile(pFIFile->hFile, (PVOID)pData, dh.dwDataSize, &dwSize, NULL))
            {
                WARNING(("Error writing glyph data to font file\n"));
                return FALSE;
            }

            //
            // Add to set of glyph data's that have been added to file
            //

            pFIFile->pGlyphData[pFIFile->nGlyphs].sGlyphID = pFIFile->pFontDir[dwIndex].sGlyphID;
            pFIFile->pGlyphData[pFIFile->nGlyphs].gdPos = pFIFile->dwCurPos;
            pFIFile->nGlyphs++;

            //
            // Increment number of glyph sets written
            //

            pFIFile->pFileHdr->nGlyphSets++;

            //
            // Update file position
            //

            pFIFile->dwCurPos += sizeof(DATA_HEADER) + dwSize;
            pFIFile->dwCurPos = (pFIFile->dwCurPos + 3) & ~3;
            pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->dwCurPos, 0, FILE_BEGIN);
        }
        else
        {
            pFIFile->pFontDir[dwIndex].offGlyphData = 0;
        }
    }
    else
    {
        //
        // Already in file, just update location
        //

        pFIFile->pFontDir[dwIndex].offGlyphData = gdPos;
    }

    //
    // Write var data
    //

    pFIFile->pFontDir[dwIndex].offVarData = pFIFile->dwCurPos;

    if (!pFntDat->pVarData)
    {
        dwSize = FIWriteVar(pFIFile->hFile, pFntDat->wchFileName);
    }
    else
    {
        dwSize = FIWriteRawVar(pFIFile->hFile, pFntDat->pVarData, pFntDat->dwSize);
    }

    if (dwSize == 0)
    {
        WARNING(("Error writing variable part of font data\n"));
        return FALSE;
    }

    pFIFile->dwCurPos += dwSize;
    pFIFile->dwCurPos = (pFIFile->dwCurPos + 3) & ~3;
    pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->dwCurPos, 0, FILE_BEGIN);

    return TRUE;
}


/******************************************************************************
 *
 *                          FIUpdateFontFile
 *
 *  Function:
 *       This function closes both files, and if bReplace, it deletes the current
 *       file,and sets the new file as the current font installer file in the
 *       registry. In !bReplace, it closes both files and deletes the new file.
 *
 *  Arguments:
 *       hCurFile       - Handle identifying current font file
 *       hNewFile       - Handle identifying new font file
 *       bReplace       - Whether the new file should replace the current file
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
FIUpdateFontFile(
    HANDLE hCurFile,
    HANDLE hNewFile,
    BOOL   bReplace
    )
{
    FI_FILE     *pFICurFile = (FI_FILE*)hCurFile;
    FI_FILE     *pFINewFile = (FI_FILE*)hNewFile;
    WCHAR        wchCurFileName[MAX_PATH];
    WCHAR        wchNewFileName[MAX_PATH];
    HANDLE       hPrinter;
    DWORD        dwSize;

    //
    // Validate pFINewFile
    // Validate pFINewFile->wchFileName is valid.
    // Validate pFINewFile->hPrinter is valid as well.
    //
    // IsValidFontInfo checks if pFI is not NULL and the signature is valid.
    //
    // pFICurFile could be NULL. In this case this is the first time to install soft fonts.
    //
    if ((pFICurFile && !IsValidFontInfo(pFICurFile)) ||
        (pFINewFile && !IsValidFontInfo(pFINewFile)))
    {
        return FALSE;
    }

    //
    // Initialize local variables
    //
    wchCurFileName[0] = '\0';
    wchNewFileName[0] = '\0';

    //
    // Remember name of the current & new files. We check for non-NULL value
    // because
    // this function can be called in a failure situation with bReplace set
    // to FALSE, and we need to handle all possible faillure cases.
    // If bReplace is TRUE, pFINewFile must be non NULL, so we get hPrinter
    // there
    //

    if (pFINewFile)
    {
        StringCchCopyW(wchNewFileName, CCHOF(wchNewFileName), pFINewFile->wchFileName);

        hPrinter = pFINewFile->hPrinter;
    }
    else
    {
        hPrinter = NULL;
    }


    if (pFICurFile)
    {
        StringCchCopyW(wchCurFileName, CCHOF(wchCurFileName), pFICurFile->wchFileName);
    }

    //
    // Close both files
    //

    FICloseFontFile(hCurFile);
    FICloseFontFile(hNewFile);

    if (bReplace)
    {
        //
        // Copy new file to current file
        //

        if (wchCurFileName[0])
        {
            if (CopyFile(wchNewFileName, wchCurFileName, FALSE))
            {
                //
                // Set printer data so client side caches get updated
                //

                dwSize = (lstrlen(wchCurFileName) + 1) * sizeof(TCHAR);
                if (hPrinter)
                {
                    SetPrinterData(hPrinter, REGVAL_FONTFILENAME, REG_SZ, (PBYTE)wchCurFileName, dwSize);
                }
            }
        }
        else
        {
            //
            // Set new file as font file and return (do not delete it!)
            //

            dwSize = (lstrlen(wchNewFileName) + 1) * sizeof(TCHAR);
            if (hPrinter)
            {
                SetPrinterData(hPrinter, REGVAL_FONTFILENAME, REG_SZ, (PBYTE)wchNewFileName, dwSize);
            }
            return TRUE;
        }
    }

    //
    // Delete the new file
    //

    if (wchNewFileName[0])
    {
        DeleteFile(wchNewFileName);
    }

    return TRUE;
}


/******************************************************************************
 *                      Internal helper functions
 ******************************************************************************/

BOOL
WriteData(
    PFI_FILE     pFIFile,
    PDATA_HEADER pData
    )
{
    DWORD dwSize;

    if (!WriteFile(pFIFile->hFile, (PVOID)pData, (DWORD)(pData->wSize + pData->dwDataSize), &dwSize, NULL))
        return FALSE;

    pFIFile->dwCurPos += dwSize;
    pFIFile->dwCurPos = (pFIFile->dwCurPos + 3) & ~3;
    pFIFile->dwCurPos = SetFilePointer(pFIFile->hFile, pFIFile->dwCurPos, 0, FILE_BEGIN);

    return TRUE;
}


/******************************************************************************
 *
 *                           Qsort
 *
 *  Function:
 *       This function sorts the given font directory array based on the
 *       wFontID field. It used quick sort.
 *
 *  Arguments:
 *       lpData         - Pointer to the font directory array to sort
 *       start          - Starting index of array
 *       end            - Ending index of array
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
Qsort(
    PUFF_FONTDIRECTORY lpData,
    int               start,
    int               end
    )
{
    int i, j;

    if (start < end) {
        i = start;
        j = end + 1;

        while (1) {
            while (i < j) {
                i++;
                if (lpData[i].wFontID >= lpData[start].wFontID)
                  break;
            }

            while(1) {
                j--;
                if (lpData[j].wFontID <= lpData[start].wFontID)
                  break;
            }

            if (i < j)
              Exchange(lpData, i, j);
            else
              break;
        }

        Exchange(lpData, start, j);
        Qsort(lpData, start, j-1);
        Qsort(lpData, j+1, end);
    }
}


/******************************************************************************
 *
 *                              Exchange
 *
 *  Function:
 *       This function exchanges two entries in the font directory array
 *
 *  Arguments:
 *       lpData         - Pointer to the font directory array
 *       i, j           - Indices of the two entries to exchange
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
Exchange(
    PUFF_FONTDIRECTORY lpData,
    DWORD i,
    DWORD j
    )
{
    UFF_FONTDIRECTORY fd;

    if ( i != j) {
        memcpy((LPSTR)&fd, (LPSTR)&lpData[i], sizeof(UFF_FONTDIRECTORY));
        memcpy((LPSTR)&lpData[i], (LPSTR)&lpData[j], sizeof(UFF_FONTDIRECTORY));
        memcpy((LPSTR)&lpData[j], (LPSTR)&fd, sizeof(UFF_FONTDIRECTORY));
    }
}

#endif // #ifndef KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\sources.inc ===
!IF 0

Copyright (c) 1996-1997  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

SOURCES=..\unilib.c   \
        ..\globals.c  \
        ..\fontutil.c \
        ..\formtray.c \
        ..\winres.c \
        ..\fiutils.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header for Universal printer driver

Environment:

    Windows NT printer drivers

Revision History:

    10/16/96 -eigos-
        Created it.
--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <lib.h>
#include <unilib.h>
#include <winddi.h>
#include <prntfont.h>

#include "fmoldfm.h"
#include "fontinst.h"
#include "unirc.h"
#include "rpc.h"
#include "winres.h"

#endif // !_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\globals.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:
    
    globals.c

Abstract:

    Global variables used by the Universal printer driver library

Environment:

    Win32 subsystem, Unidrv driver

Revision History:

    11-11-97 -eigos-
        Created it

    dd-mm-yy -author-
        description

--*/

#include        "precomp.h"

UINT guiCharsets[] = {
    ANSI_CHARSET,
    SHIFTJIS_CHARSET,
    HANGEUL_CHARSET,
    JOHAB_CHARSET,
    GB2312_CHARSET,
    CHINESEBIG5_CHARSET,
    HEBREW_CHARSET,
    ARABIC_CHARSET,
    GREEK_CHARSET,
    TURKISH_CHARSET,
    BALTIC_CHARSET,
    EASTEUROPE_CHARSET,
    RUSSIAN_CHARSET,
    THAI_CHARSET };

UINT guiCodePages[] ={
    1252,
    932,
    949,
    1361,
    936,
    950,
    1255,
    1256,
    1253,
    1254,
    1257,
    1250,
    1251,
    874 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\km\crtlib.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtlib.c

Abstract:

    This module has support some C run Time functions which are not
    supported in KM.

Environment:

    Win32 subsystem, Unidrv driver

Revision History:

    01/03/97 -ganeshp-
        Created it.

    dd-mm-yy -author-
        description

--*/
#include "precomp.h"



/*++

Routine Name:
    iDrvPrintfSafeA

Routine Description:
    This is a safer version of sprintf/iDrvPrintfA.

    It utilizes the StringCchPrintf in the
    strsafe.h library. sprintf returns the number of characters copied to the
    destination string, but StringCchPrintf doesn't. 

    Note: May not compile/work if WINNT_40 switch turned on. But since
    we are not supporting NT4 anymore, we should be ok.

Arguments:
    pszDest : Destination string.

    cchDest : Number of characters in the destination string. Since this is the ANSI version
              number of chars = num of bytes.
    pszFormat : e.g. "PP%d,%d"
    ...     : The variable list of arguments

Return Value:
    Negative : if some error encountered.
    Positive : Number of characters copied.
    0        : i.e. no character copied.

Author:
    -hsingh-    2/21/2002

Revision History:
    -hsingh-    2/21/2002 Created this function.

--*/
INT iDrvPrintfSafeA (
        IN        PCHAR pszDest,
        IN  CONST ULONG cchDest,
        IN  CONST PCHAR pszFormat,
        IN  ...)
{
    va_list args;
    INT     icchWritten = (INT)-1;


    va_start(args, pszFormat);

    icchWritten = iDrvVPrintfSafeA ( pszDest, cchDest, pszFormat, args); 

    va_end(args);

    return icchWritten;
}



/*++

Routine Name:
    iDrvPrintfSafeW

Routine Description:
    This is a safer version of sprintf/iDrvPrintfW.

    It utilizes the StringCchPrintf in the
    strsafe.h library. sprintf returns the number of characters copied to the
    destination string, but StringCchPrintf doesn't. 

    Note: May not compile/work if WINNT_40 switch turned on. But since 
    we are not supporting NT4 anymore, we should be ok.

Arguments:
    pszDest : Destination string.

    cchDest : Number of characters in the destination string. Since this is the UNICODE version
              the size of buffer is twice the number of characters. 
    pszFormat : e.g. "PP%d,%d"
    ...     : The variable list of arguments

Return Value:
    Negative : if some error encountered.
    Positive : Number of characters copied.
    0        : i.e. no character copied.

Author:
    -hsingh-    2/21/2002

Revision History:
    -hsingh-    2/21/2002 Created this function.

--*/
INT iDrvPrintfSafeW (
        IN        PWCHAR pszDest,
        IN  CONST ULONG  cchDest,
        IN  CONST PWCHAR pszFormat,
        IN  ...)
{
    va_list args;
    INT     icchWritten = (INT)-1;

    va_start(args, pszFormat);

    icchWritten = iDrvVPrintfSafeW (pszDest, cchDest, pszFormat, args);

    va_end(args);

    return icchWritten;
}


INT iDrvVPrintfSafeA (
        IN        PCHAR   pszDest,
        IN  CONST ULONG   cchDest,
        IN  CONST PCHAR   pszFormat,
        IN        va_list arglist)
{
    HRESULT hr          = S_FALSE;
    INT icchWritten     = (INT)-1;
    size_t cchRemaining = cchDest;

    //
    // Since return value is a signed integer, but cchDest is unsigned.
    // cchDest can be atmost MAX_ULONG but return can be atmost MAX_LONG.
    // So make sure that input buffer is not more than MAX_LONG (LONG is 
    // virtually same as INT)
    //
    if ( cchDest > (ULONG) MAX_LONG )
    {
        return icchWritten; 
    }

    hr = StringCchVPrintfExA (pszDest, cchDest, NULL, &cchRemaining, 0, pszFormat, arglist);
    if (SUCCEEDED (hr) )
    {
        //
        // Subtracting the number of characters remaining in the string
        // from the number of characters originally present give us the number
        // of characters written.
        //
        icchWritten = (INT)(cchDest - cchRemaining);
    }
    return icchWritten;
}


INT iDrvVPrintfSafeW (
        IN        PWCHAR pszDest,
        IN  CONST ULONG  cchDest,
        IN  CONST PWCHAR pszFormat,
        IN        va_list arglist)
{
    HRESULT hr          = S_FALSE;
    INT icchWritten     = (INT)-1;
    size_t cchRemaining = cchDest;
    //
    // Since return value is a signed integer, but cchDest is unsigned.
    // cchDest can be atmost MAX_ULONG but return can be atmost MAX_LONG.
    // So make sure that input buffer is not more than MAX_LONG (LONG is 
    // virtually same as INT)
    //
    if ( cchDest > (ULONG) MAX_LONG )
    {
        return icchWritten; 
    }

    hr = StringCchVPrintfExW (pszDest, cchDest, NULL, &cchRemaining, 0, pszFormat, arglist);

    if (SUCCEEDED (hr) )
    {
        //
        // Subtracting the number of characters remaining in the string
        // from the number of characters originally present give us the number
        // of characters written.
        //
        icchWritten = (INT)(cchDest - cchRemaining);
    }

    return icchWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\km\kmlib.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    
    unilib.c

Abstract:

    This string handling the KM code for Unidrv

Environment:

    Win32 subsystem, Unidrv driver

Revision History:

    11/12/96 -eigos-
        Created it.

    dd-mm-yy -author-
        description

--*/

#include "precomp.h"

DWORD
DwCopyStringToUnicodeString(
    IN  UINT  uiCodePage,
    IN  PSTR  pstrCharIn,
    OUT PWSTR pwstrCharOut,
    IN  INT   iwcOutSize)

{
    INT     iCharCountIn;
    INT     iRetVal;
    size_t  stStringLength;

    if ( NULL == pwstrCharOut )
    {
        return (DWORD)(-1);
    }

    iCharCountIn =  strlen(pstrCharIn) + 1;

    iRetVal = EngMultiByteToWideChar(uiCodePage,
                                     pwstrCharOut,
                                     iwcOutSize * sizeof(WCHAR),
                                     pstrCharIn,
                                     iCharCountIn);

    if ( -1 == iRetVal || 
        FAILED ( StringCchLengthW ( pwstrCharOut, iwcOutSize, &stStringLength ) ) )
    {
        pwstrCharOut[iwcOutSize-1] = TEXT('\0');
    }

    return (DWORD)iRetVal;

}

DWORD
DwCopyUnicodeStringToString(
    IN  UINT  uiCodePage,
    IN  PWSTR pwstrCharIn,
    OUT PSTR  pstrCharOut,
    IN  INT   icbOutSize)

{
    INT iCharCountIn;
    INT iRetVal;
    size_t  stStringLength;

    if ( NULL == pstrCharOut )
    {
        return (DWORD)(-1);
    }


    iCharCountIn =  wcslen(pwstrCharIn) + 1;

    iRetVal = EngWideCharToMultiByte(uiCodePage,
                                     pwstrCharIn,
                                     iCharCountIn * sizeof(WCHAR),
                                     pstrCharOut,
                                     icbOutSize);

    if ( -1 == iRetVal || 
        FAILED ( StringCchLengthA ( pstrCharOut, icbOutSize, &stStringLength ) ) )
    {
        pstrCharOut[icbOutSize-1] = '\0';
    }

    return (DWORD)iRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\winres.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    winres.c

Abstract:

    Functions used to read Windows .EXE/.DRV files to obtain the
    information contained within their resources.

Environment:

    Windows NT Unidrv driver

Revision History:

        dd-mm-yy -author-
                description

--*/

#include "precomp.h"


HANDLE
HLoadResourceDLL(
    WINRESDATA  *pWinResData,
    PWSTR       pwstrResDLL
)
/*++
Routine Description:
    This routine loads the resource DLL.

Arguments:
    pWinResData     Info about Resources
    pwstrResDLL     Unqualified resource DLL name



Return Value:
    Handle to the loaded DLL or NULL  for failure

Note:

    10/26/1998 -ganeshp-
        Created it.
--*/

{
    HANDLE  hModule = 0;
    PWSTR   pwstrQualResDllName = (pWinResData->wchDriverDir);
    PWSTR   pwstr;

    //
    // Make sure that resource DLL name is not qualified.
    //
    if (pwstr = wcsrchr( pwstrResDLL, TEXT('\\')))
        pwstrResDLL = pwstr + 1;

    //
    // Create the fully qualified Name for resource DLL name. We use
    // wchDriverDir buffer to create the fully qualified name and reset it.
    // Make sure we have enough space.
    //
    if ( (wcslen(pWinResData->wchDriverDir) + wcslen(pwstrResDLL) + 1) > MAX_PATH )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ERR(("HLoadResourceDLL:Length of wchDriverDir + pwstrResDLL longer than MAX_PATH.\n"));
        goto ErrorExit;

    }
    StringCchCatW(pwstrQualResDllName, CCHOF(pWinResData->wchDriverDir), pwstrResDLL);

    //
    // Now load the resource.
    //
    #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    //
    // For Kernel mode drivers
    //
    hModule = EngLoadModule(pwstrQualResDllName);

    #else

    //
    // For user mode drivers and UI module.
    //
    #ifdef WINNT_40 //NT 4.0
    hModule = LoadLibraryEx( pwstrQualResDllName, NULL,
                                       DONT_RESOLVE_DLL_REFERENCES );
    #else //NT 5.0
    hModule = LoadLibrary(pwstrQualResDllName);
    #endif

    #endif //defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    if (hModule == NULL)
    {
        ERR(("HLoadResourceDLL:Failed to load resource DLL '%ws': Error = %d\n",
             pwstrQualResDllName,
             GetLastError()));

        goto ErrorExit;
    }


    ErrorExit:
    //
    // Reset the pWinResData->wchDriverDir. Save a '\0' after last backslash.
    //
    *(pWinResData->pwstrLastBackSlash + 1) = NUL;
    return hModule;

}

BOOL
BInitWinResData(
    WINRESDATA  *pWinResData,
    PWSTR       pwstrDriverName,
    PUIINFO     pUIInfo
    )
/*++

Routine Description:

    This function opens the resource file name and init the resource table
    information and initialize the hModule in WINRESDATA

Arguments:
    pWinResData     - Pointer to WINRESDATA struct
    pwstrDriverName - Fully qualified name of the driver.
    pUIInfo         - Pointer to UI info.

Return Value:

    TRUE if successful, FALSE if there is an error
Note:

--*/

{
    PWSTR       pstr = NULL;
    BOOL        bRet = FALSE;
    DWORD       dwLen;
    PWSTR       pRootResDLLName;

    //
    // Always assume we are dealing with NT minidrivers
    //

    ZeroMemory(pWinResData, sizeof( WINRESDATA ));

    //
    // Check for fully qualified name. If the driver name is not fully qualified
    // then this function will fail.
    //

    if (pstr = wcsrchr( pwstrDriverName, TEXT('\\')) )
    {
        //
        // wcschr returns pointer to \. We need to add +1 include \ in the
        // driver name to be stored.
        //
        dwLen = (DWORD)((pstr - pwstrDriverName) + 1);

        //
        // Check if the Length of the driver name is less that MAX_PATH.
        //
        if ((dwLen + 1) > MAX_PATH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            ERR(("BInitWinResData:Invalid pwstrDriverName,longer than MAX_PATH.\n"));
            goto ErrorExit;
        }
        //
        // Copy the driver dir name in winresdata. No need to save NULL as
        // winresdata is zero initialised.
        //
        wcsncpy(pWinResData->wchDriverDir,pwstrDriverName, dwLen);

        //
        // Save the position of the last backslash.
        //
        pWinResData->pwstrLastBackSlash = pWinResData->wchDriverDir +
                                          wcslen(pWinResData->wchDriverDir) - 1;
    }
    else // Driver name is not qualified. Error.
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ERR(("BInitWinResData:Invalid pwstrDriverName,Not qualified.\n"));
        goto ErrorExit;
    }

    //
    // Load the root resource DLL
    //
    pRootResDLLName = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                        pUIInfo->loResourceName);

    if (pRootResDLLName == NULL)
    {
        //
        // This is OK since the GPD is not required to have the *ResourceDLL entry
        //
        // Already did ZeroMemory(pWinResData), no need to set hResDLLModule NULL here.
        //
        VERBOSE(("BInitWinResData: pRootResDLLName is NULL.\n"));
        goto OKExit;
    }

    pWinResData->hResDLLModule = HLoadResourceDLL(pWinResData, pRootResDLLName);

    //
    // Check for success
    //
    if (!pWinResData->hResDLLModule)
    {
        //
        // If GPD does specify *ResourceDLL but we can't load it, we will fail.
        //
        ERR(("BInitWinResData:Failed to load root resource DLL '%ws': Error = %d\n",
             pRootResDLLName,
             GetLastError()));

        goto ErrorExit;
    }

    OKExit:

    //
    // Success so save the UI info in Winresdata.
    //
    bRet = TRUE;
    pWinResData->pUIInfo = pUIInfo;

    ErrorExit:

    return bRet;
}


PWSTR
PGetResourceDLL(
    PUIINFO         pUIInfo,
    PQUALNAMEEX     pResQual
)
/*++
Routine Description:
    This routine gets the resouce handle from the handle array. If the DLL is
    not loaded then it loads it.

Arguments:
    pResQual        UI Info pointer
    pResQual        Pointer to qualified ID structure. It contains the info
                    about resource dll name and resource ID.



Return Value:
    Name of the resource DLL or NULL  for failure

Note:

    10/26/1998 -ganeshp-
        Created it.
--*/
{
    PFEATURE    pResFeature;
    POPTION     pResOption;
    PTSTR       ptstrResDllName = NULL;

    if (pUIInfo)
    {
        //
        // Go to the start of the feature list.
        //
        pResFeature = PGetIndexedFeature(pUIInfo, 0);

        if (pResFeature)
        {
            //
            // Add the feature ID to featuer pointer to get Resource feature.
            //
            pResFeature += pResQual->bFeatureID;

            if (pResOption = (PGetIndexedOption(pUIInfo, pResFeature, pResQual->bOptionID  & 0x7f)))
            {
                ptstrResDllName = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                    pResOption->loDisplayName);

                if (ptstrResDllName == NULL)
                {
                   SetLastError(ERROR_INVALID_PARAMETER);
                   ERR(("PGetResourceDLL:Resource DLL name is not specified\n"));
                }

            }
            else
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                ERR(("PGetResourceDLL:NULL resource option.\n"));
            }

        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            ERR(("PGetResourceDLL:NULL resource Feature.\n"));
        }

    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ERR(("PGetResourceDLL:NULL pUIInfo.\n"));

    }
    return ptstrResDllName;
}

HANDLE
HGetModuleHandle(
    WINRESDATA      *pWinResData,
    PQUALNAMEEX     pQualifiedID
)
/*++
Routine Description:
    This routine gets the resouce handle from the handle array. If the DLL is
    not loaded then it loads it.

Arguments:
    pWinResData     Info about Resources
    pQualifiedID    Pointer to qualified ID structure. It contains the info
                    about resource dll name and resource ID.



Return Value:
    Handle to the loaded DLL or NULL  for failure

Note:

    10/26/1998 -ganeshp-
        Created it.
--*/
{
    HANDLE  hModule = 0 ;
    PWSTR   pResDLLName;
    INT     iResDLLID;

    //
    // Only the low 7 bits of bOptionID are valid. So mask them.
    //
    iResDLLID   = (pQualifiedID->bOptionID & 0x7f);

    if (iResDLLID >= MAX_RESOURCE)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       ERR(("HGetModuleHandle:Res DLL ID (%d) larger than MAX_RESOURCE (%d).\n",
             iResDLLID, MAX_RESOURCE));
       return 0 ;
    }

    //
    // Check for predefined system paper names.
    //
    if ((*((PDWORD)pQualifiedID) & 0x7FFFFFFF) == RCID_DMPAPER_SYSTEM_NAME)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        ERR(("RCID_DMPAPER_SYSTEM_NAME  is not a valid qualified resource name.\n"));
        return 0 ;
    }

    //
    // Check for the root resource DLL.
    //
    if (pQualifiedID->bFeatureID == 0 && iResDLLID == 0)
    {
        hModule = pWinResData->hResDLLModule;
    }
    else
    {
        hModule = pWinResData->ahModule[iResDLLID];

        //
        // The module is not loaded so load it.
        //
        if (!hModule)
        {
                //
                // Get the resource DLL name form Qualified ID.
                //
                if (pResDLLName = PGetResourceDLL(pWinResData->pUIInfo,pQualifiedID) )
                {
                    hModule = HLoadResourceDLL(pWinResData,pResDLLName);

                    //
                    // If successful loading then save the values in handle array
                    // and increament the counter.
                    //
                    if (hModule)
                    {
                        pWinResData->ahModule[iResDLLID] = hModule;
                        pWinResData->cLoadedEntries++;
                    }

                }
                else
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                    ERR(("HGetModuleHandle:Can't find Resource DLL name in UIINFO.\n"));

                }


        }

    }

    return hModule;
}


BOOL
BGetWinRes(
    WINRESDATA  *pWinResData,
    PQUALNAMEEX pQualifiedID,
    INT         iType,
    RES_ELEM    *pRInfo
    )
/*++

Routine Description:

    Get Windows Resource Data for the caller

Arguments:
    pWinResData - Pointer to WINRESDATA struct
    iQualifiedName   - The fully qualified entry name
    iType   - Type of resource
    pRInfo  - Results info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT         iName;
    HANDLE      hModule;

    iName     = (INT)pQualifiedID->wResourceID;

    if (hModule = HGetModuleHandle(pWinResData, pQualifiedID))
    {
        //
        // Now Find the resource.
        //
        #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

        //
        // For Kernel mode drivers
        //
        pRInfo->pvResData = EngFindResource(
                                hModule,
                                iName,
                                iType,
                                &pRInfo->iResLen);


        #else

        //
        // For user mode drivers and UI module.
        //
        {
            HRSRC       hRes;
            HGLOBAL     hLoadRes;

            if( !(hRes = FindResource( hModule, (LPCTSTR)IntToPtr(iName), (LPCTSTR)IntToPtr(iType))) ||
                !(hLoadRes = LoadResource( hModule, hRes )) ||
                !(pRInfo->pvResData = LockResource(hLoadRes)) )
                    return  FALSE;

            pRInfo->iResLen = SizeofResource( hModule, hRes );
        }

        #endif //defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

        return(pRInfo->pvResData != NULL);


    }

    return  FALSE;
}


VOID
VWinResClose(
    WINRESDATA  *pWinResData
    )
/*++

Routine Description:

    This function frees the resources allocated with this module.  This
    includes any memory allocated and the file handle to the driver.

Arguments:
    pWinResData - Pointer to WINRESDATA struct

Return Value:

    None

--*/
{

    //
    // Free used resources.  Which resources are used has been recorded
    // in the Handle array field of the WINRESDATA structure passed in to us.
    // First free the root resource DLL and other DLLs.

    INT iI;

    #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    //
    // For Kernel mode drivers
    //
    if (pWinResData->hResDLLModule)
    {
        EngFreeModule(pWinResData->hResDLLModule);
    }

    for (iI = 0; iI < MAX_RESOURCE; iI++)
    {
        if(pWinResData->ahModule[iI])
            EngFreeModule(pWinResData->ahModule[iI]);
    }


    #else

    //
    // For user mode drivers and UI module.
    //

    if (pWinResData->hResDLLModule)
    {
        FreeLibrary(pWinResData->hResDLLModule);
    }

    for (iI = 0; iI < MAX_RESOURCE; iI++)
    {
        if(pWinResData->ahModule[iI])
            FreeLibrary(pWinResData->ahModule[iI]);
    }

    #endif //defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    //
    // Reinitialize with ZeroFill.
    //
    ZeroMemory(pWinResData, sizeof( WINRESDATA ));

    return;
}


INT
ILoadStringW (
    WINRESDATA  *pWinResData,
    INT         iID,
    PWSTR       wstrBuf,
    WORD        wBuf
    )
/*++

Routine Description:

    This function copies the requested resource name into the buffer provided
    and return the size of the resource string copied.

Arguments:

    pWinResData - Pointer to WINRESDATA struct
    iID         - Resource ID
    wstrBuf     - Buffer to receive name
    wBuf        - Size of the buffer in number of characters

Return Value:

    The number of characters of the resource string copied into wstrBuf

--*/
{
    //
    // The string resources are stored in groups of 16.  SO,  the
    // 4 LSBs of iID select which of the 16(entry name), while the remainder
    // select the group.
    // Each string resource contains a count byte followed by that
    // many bytes of data WITHOUT A NULL.  Entries that are missing
    // have a 0 count.
    //

    INT    iSize,iResID;
    BYTE   *pb;
    WCHAR  *pwch;
    RES_ELEM  RInfo;
    PQUALNAMEEX pQualifiedID;

    pQualifiedID = (PQUALNAMEEX)&iID;

    iResID = pQualifiedID->wResourceID;
    pQualifiedID->wResourceID = (pQualifiedID->wResourceID >> 4) + 1;

    //
    // Get entry name for resource
    //

    if( !BGetWinRes( pWinResData, (PQUALNAMEEX)&iID, WINRT_STRING, &RInfo ) ||
        wBuf < sizeof( WCHAR ) )
    {
        return  0;
    }

    //
    // Get the group ID
    //
    iResID &= 0xf;

    //
    // wBuf has some limit on sensible sizes.  For one, it should be
    // a multiple of sizeof( WCHAR ).  Secondly,  we want to put a 0
    // to terminate the string,  so add that in now.
    //

    wBuf-- ;

    pwch = RInfo.pvResData;

    while( --iResID >= 0 )
        pwch += 1 + *pwch;

    if( iSize = *pwch )
    {
        if( iSize > wBuf )
            iSize = wBuf;

        wstrBuf[ iSize ] = (WCHAR)0;
        iSize *= sizeof( WCHAR );
        memcpy( wstrBuf, ++pwch, iSize );

    }
    return  (iSize/sizeof( WCHAR ) );  // number of characters written
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\unilib.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    unilib.c

Abstract:

    This file handles the shared KM and UM code for Unidrv

Environment:

    Win32 subsystem, Unidrv driver

Revision History:

    02/04/97 -davidx-
        Devmode changes to support OEM plugins.

    10/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

#ifndef KERNEL_MODE
#include <winddiui.h>
#endif

#include <printoem.h>
#include "oemutil.h"
#include "gpd.h"

//
// Internal data structure
//

typedef  union {
    WORD  w;
    BYTE  b[2];
} UW;

typedef union {
    DWORD  dw;
    BYTE   b[4];
} UDW;

#if !defined(DEVSTUDIO) //  MDS doesn't need these


//
// Information about UniDriver private devmode
//

CONST DRIVER_DEVMODE_INFO gDriverDMInfo =
{
    UNIDRIVER_VERSION,      sizeof(UNIDRVEXTRA),
    UNIDRIVER_VERSION_500,  sizeof(UNIDRVEXTRA500),
    UNIDRIVER_VERSION_400,  sizeof(UNIDRVEXTRA400),
    UNIDRIVER_VERSION_351,  sizeof(UNIDRVEXTRA351),
};

CONST DWORD gdwDriverDMSignature = UNIDEVMODE_SIGNATURE;
CONST WORD  gwDriverVersion = UNIDRIVER_VERSION;


//
// Functions
//

BOOL
BInitDriverDefaultDevmode(
    OUT PDEVMODE        pdm,
    IN LPCTSTR          pDeviceName,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN BOOL             bMetric
    )

/*++

Routine Description:

    This function intializes the devmode with
    the UNIDRV default devmode

Arguments:

    pdm             pointer to Unidrv DEVMODE
    pDeviceName     pointer to device name
    pUIInfo         pointer to UIINFO
    pRawData        pointer to RAWBINARYDATA
    bMetric         indicates whether system is running in a metric country

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    This function should initialize both public devmode fields
    and driver private devmode fields. It's also assumed that
    output buffer has already been zero initialized by the caller.

--*/
{
    PDEVMODE     pdmPublic;
    PUNIDRVEXTRA pdmPrivate;
    PWSTR        pwstrFormName;
    PFEATURE     pFeature;
    PGPDDRIVERINFO pDriverInfo;

    pDriverInfo = GET_DRIVER_INFO_FROM_INFOHEADER(pUIInfo->pInfoHeader);

    pdmPublic = pdm;

    /*********************/
    /* PUBLIC DEVMODE    */
    /*********************/

    if (pDeviceName)
        CopyStringW(pdmPublic->dmDeviceName, pDeviceName, CCHDEVICENAME);

    pdmPublic->dmDriverVersion = UNIDRIVER_VERSION;
    pdmPublic->dmSpecVersion = DM_SPECVERSION;
    pdmPublic->dmSize = sizeof(DEVMODE);
    pdmPublic->dmDriverExtra = sizeof(UNIDRVEXTRA);

    pdmPublic->dmFields =
        DM_COPIES | DM_ORIENTATION | DM_PAPERSIZE | DM_COLLATE | DM_DITHERTYPE |
        DM_COLOR | DM_FORMNAME | DM_TTOPTION | DM_DEFAULTSOURCE |
        #ifndef WINNT_40
        DM_NUP |
        #endif
        DM_PRINTQUALITY;

    pdmPublic->dmOrientation = DMORIENT_PORTRAIT;
    pdmPublic->dmDuplex = DMDUP_SIMPLEX;
    pdmPublic->dmCollate = DMCOLLATE_TRUE;
    pdmPublic->dmMediaType = DMMEDIA_STANDARD;
    pdmPublic->dmTTOption = DMTT_SUBDEV;
    pdmPublic->dmColor = DMCOLOR_MONOCHROME;
    pdmPublic->dmDefaultSource = DMBIN_FORMSOURCE;
    pdmPublic->dmScale = 100;
    pdmPublic->dmCopies = 1;
    #ifndef WINNT_40
    pdmPublic->dmNup = DMNUP_SYSTEM;
    #endif

    //
    // We always set ICM off. The spooler will turn it on at install time
    // if there are color profiles installed with this printer
    //

    pdmPublic->dmICMMethod = DMICMMETHOD_NONE;
    pdmPublic->dmICMIntent = DMICM_CONTRAST;
    pdmPublic->dmDitherType = pUIInfo->defaultQuality + QUALITY_MACRO_START;

    if (pUIInfo->liBestQualitySettings == END_OF_LIST &&
        pUIInfo->liBetterQualitySettings == END_OF_LIST &&
        pUIInfo->liDraftQualitySettings == END_OF_LIST)
        pdmPublic->dmDitherType = QUALITY_MACRO_CUSTOM;

    #ifndef WINNT_40

    pdmPublic->dmFields |= (DM_ICMMETHOD | DM_ICMINTENT);

    #endif

    if (pDriverInfo && pDriverInfo->Globals.bTTFSEnabled == FALSE)
        pdmPublic->dmTTOption = DMTT_DOWNLOAD;

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION))
    {
        PRESOLUTION pRes;

        //
        // Use the default resolution specified in the PPD file
        //

        if (pRes = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex))
        {
            pdmPublic->dmPrintQuality = (short)pRes->iXdpi;
            pdmPublic->dmYResolution = (short)pRes->iYdpi;
        }
    }

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_DUPLEX))
    {
        PDUPLEX pDuplex;

        //
        // Use the default duplex option specified in the GPD file
        //

        pdmPublic->dmFields |= DM_DUPLEX;

        if (pDuplex = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex))
            pdmPublic->dmDuplex = (SHORT) pDuplex->dwDuplexID;
    }

    //
    // Always set DM_COLLATE flag since we can simulate it if the
    // device cannot.
    //

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_MEDIATYPE))
    {
        PMEDIATYPE pMediaType;

        //
        // Use the default media type specified in the PPD file
        //

        pdmPublic->dmFields |= DM_MEDIATYPE;

        if (pMediaType = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex))
            pdmPublic->dmMediaType = (SHORT)pMediaType->dwMediaTypeID;

    }


    if (pUIInfo->dwFlags & FLAG_COLOR_DEVICE)
    {
        if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_COLORMODE))
        {
            POPTION pColorMode;
            PCOLORMODEEX pColorModeEx;

            if ((pColorMode = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex)) &&
                (pColorModeEx = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pColorMode->loRenderOffset)) &&
                (pColorModeEx->bColor))
            {
                pdmPublic->dmColor = DMCOLOR_COLOR;
            }
        }

        pdmPublic->dmFields |= DM_COLOR;
    }

    //
    // Initialize form-related fields
    //

    VDefaultDevmodeFormFields(pUIInfo, pdmPublic, bMetric);


    /*********************/
    /* PRIVATE DEVMODE    */
    /*********************/

    //
    // Fill in the private portion of devmode
    //

    pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);
    pdmPrivate->wVer = UNIDRVEXTRA_VERSION ;
    pdmPrivate->wSize = sizeof(UNIDRVEXTRA);

    pdmPrivate->wOEMExtra = 0;
    ZeroMemory(pdmPrivate->wReserved, sizeof(pdmPrivate->wReserved));

    pdmPrivate->iLayout = ONE_UP;
    pdmPrivate->bReversePrint = FALSE;
    pdmPrivate->iQuality = pUIInfo->defaultQuality;

    //
    // Initialize default sFlags
    //

    if (pUIInfo->dwFlags & FLAG_FONT_DOWNLOADABLE)
        pdmPrivate->dwFlags &= DXF_DOWNLOADTT;

    pdmPrivate->dwSignature = UNIDEVMODE_SIGNATURE;
    pdmPrivate->dwChecksum32 = pRawData->dwChecksum32;
    pdmPrivate->dwOptions = pRawData->dwDocumentFeatures;

    InitDefaultOptions(pRawData,
                       pdmPrivate->aOptions,
                       MAX_PRINTER_OPTIONS,
                       MODE_DOCUMENT_STICKY);

    return TRUE;
}



VOID
VMergePublicDevmodeFields (
    PDEVMODE    pdmSrc,
    PDEVMODE    pdmDest,
    PUIINFO     pUIInfo,
    PRAWBINARYDATA pRawData
    )

/*++

Routine Description:
    This function merges the public devmode fields from SRC to DEST
    It is assumed that the devmode has been converted to the current
    version before this function is called

Arguments:

    pdmSrc          pointer to src DEVMODE
    pdmDest         pointer to destination DEVMODE
    pUIInfo         pointer to UIINFO
    pRawData        pointer to raw binary printer description data

Return Value:

    None

Note:

--*/

{
    PFEATURE pFeature;

    #ifndef WINNT_40
    if ( (pdmSrc->dmFields & DM_NUP) &&
         (pdmSrc->dmNup == DMNUP_SYSTEM ||
          pdmSrc->dmNup == DMNUP_ONEUP))
    {
        pdmDest->dmNup = pdmSrc->dmNup;
        pdmDest->dmFields |= DM_NUP;
    }
    #endif
    //
    // Copy dmDefaultSource field
    //

    if ( pdmSrc->dmFields & DM_DEFAULTSOURCE &&
         ((pdmSrc->dmDefaultSource >= DMBIN_FIRST &&
           pdmSrc->dmDefaultSource <= DMBIN_LAST) ||
          pdmSrc->dmDefaultSource >= DMBIN_USER))

    {
        pdmDest->dmDefaultSource = pdmSrc->dmDefaultSource;
        pdmDest->dmFields |= DM_DEFAULTSOURCE;
    }

    //
    // Copy the dmDitherType field
    //

    if ((pdmSrc->dmFields & DM_DITHERTYPE) &&
        ((pdmSrc->dmDitherType >= QUALITY_MACRO_START &&
          pdmSrc->dmDitherType < QUALITY_MACRO_END) ||
         (pdmSrc->dmDitherType <= HT_PATSIZE_MAX_INDEX)))
    {
        pdmDest->dmFields |= DM_DITHERTYPE;
        pdmDest->dmDitherType = pdmSrc->dmDitherType;

    }

    //
    // Copy dmOrientation field
    //

    if ((pdmSrc->dmFields & DM_ORIENTATION) &&
        (pdmSrc->dmOrientation == DMORIENT_PORTRAIT ||
         pdmSrc->dmOrientation == DMORIENT_LANDSCAPE))
    {
        pdmDest->dmFields |= DM_ORIENTATION;
        pdmDest->dmOrientation = pdmSrc->dmOrientation;
    }

    //
    // If both DM_PAPERLENGTH and DM_PAPERWIDTH are set, copy
    // dmPaperLength and dmPaperWidth fields. If DM_PAPERSIZE
    // is set, copy dmPaperSize field. Otherwise, if DM_FORMNAME
    // is set, copy dmFormName field.
    //

    //
    // If both DM_PAPERLENGTH and DM_PAPERWIDTH are set, copy
    // dmPaperLength and dmPaperWidth fields. If DM_PAPERSIZE
    // is set, copy dmPaperSize field. Otherwise, if DM_FORMNAME
    // is set, copy dmFormName field.
    //

    if ((pdmSrc->dmFields & DM_PAPERWIDTH) &&
        (pdmSrc->dmFields & DM_PAPERLENGTH) &&
        (pdmSrc->dmPaperWidth > 0) &&
        (pdmSrc->dmPaperLength > 0))
    {
        pdmDest->dmFields |= (DM_PAPERLENGTH | DM_PAPERWIDTH);
        pdmDest->dmFields &= ~(DM_PAPERSIZE | DM_FORMNAME);
        pdmDest->dmPaperWidth = pdmSrc->dmPaperWidth;
        pdmDest->dmPaperLength = pdmSrc->dmPaperLength;

    }
    else if (pdmSrc->dmFields & DM_PAPERSIZE)
    {
        pdmDest->dmFields |= DM_PAPERSIZE;
        pdmDest->dmFields &= ~(DM_PAPERLENGTH | DM_PAPERWIDTH | DM_FORMNAME);
        pdmDest->dmPaperSize = pdmSrc->dmPaperSize;

    }
    else if (pdmSrc->dmFields & DM_FORMNAME)
    {

        pdmDest->dmFields |= DM_FORMNAME;
        pdmDest->dmFields &= ~(DM_PAPERLENGTH | DM_PAPERWIDTH | DM_PAPERSIZE);
        CopyString(pdmDest->dmFormName, pdmSrc->dmFormName, CCHFORMNAME);
    }

    //
    // Copy dmScale field
    //

    if ((pdmSrc->dmFields & DM_SCALE) &&
        (pdmSrc->dmScale >= MIN_SCALE) &&
        (pdmSrc->dmScale <= MAX_SCALE))
    {
        //
        // Unidrv can't have DM_SCALE flag set for app compat reasons. That is
        // the same behavior we saw when testing other OEM PCL drivers.
        // (See bug #35241 for details.)
        //
        // pdmDest->dmFields |= DM_SCALE;
        //

        pdmDest->dmScale = pdmSrc->dmScale;
    }

    //
    // Copy dmCopies field
    //

    if ((pdmSrc->dmFields & DM_COPIES) &&
        (pdmSrc->dmCopies >= 1) &&
        (pdmSrc->dmCopies <= max(MAX_COPIES, (SHORT)pUIInfo->dwMaxCopies)))
    {
        pdmDest->dmFields |= DM_COPIES;
        pdmDest->dmCopies = pdmSrc->dmCopies;
    }


    if ((pdmSrc->dmFields & DM_COLOR) &&
        (pdmSrc->dmColor == DMCOLOR_COLOR ||
         pdmSrc->dmColor == DMCOLOR_MONOCHROME))
    {
        pdmDest->dmFields |= DM_COLOR;
        pdmDest->dmColor = pdmSrc->dmColor;
    }

    if ((pdmSrc->dmFields & DM_DUPLEX) &&
        (GET_PREDEFINED_FEATURE(pUIInfo, GID_DUPLEX) != NULL) &&
        (pdmSrc->dmDuplex == DMDUP_SIMPLEX ||
         pdmSrc->dmDuplex == DMDUP_HORIZONTAL ||
         pdmSrc->dmDuplex == DMDUP_VERTICAL))
    {
        pdmDest->dmFields |= DM_DUPLEX;
        pdmDest->dmDuplex = pdmSrc->dmDuplex;
    }

    if ((pdmSrc->dmFields & DM_COLLATE) &&
        (pdmSrc->dmCollate == DMCOLLATE_TRUE ||
         pdmSrc->dmCollate == DMCOLLATE_FALSE))
    {
        pdmDest->dmFields |= DM_COLLATE;
        pdmDest->dmCollate = pdmSrc->dmCollate;
    }

    //
    // Copy dmTTOption field
    //

    if (pdmSrc->dmFields & DM_TTOPTION &&
         (pdmSrc->dmTTOption == DMTT_BITMAP ||
          pdmSrc->dmTTOption == DMTT_DOWNLOAD ||
          pdmSrc->dmTTOption == DMTT_SUBDEV) )
    {
            pdmDest->dmTTOption = pdmSrc->dmTTOption;
            pdmDest->dmFields |= DM_TTOPTION;
    }


    if ((pdmSrc->dmFields & DM_ICMMETHOD) &&
        (pdmSrc->dmICMMethod == DMICMMETHOD_NONE ||
         pdmSrc->dmICMMethod == DMICMMETHOD_SYSTEM ||
         pdmSrc->dmICMMethod == DMICMMETHOD_DRIVER ||
         pdmSrc->dmICMMethod == DMICMMETHOD_DEVICE))
    {
        pdmDest->dmFields |= DM_ICMMETHOD;
        pdmDest->dmICMMethod = pdmSrc->dmICMMethod;
    }

    if ((pdmSrc->dmFields & DM_ICMINTENT) &&
        (pdmSrc->dmICMIntent == DMICM_SATURATE ||
         #ifndef WINNT_40
         pdmSrc->dmICMIntent == DMICM_COLORIMETRIC ||
         pdmSrc->dmICMIntent == DMICM_ABS_COLORIMETRIC ||
         #endif
         pdmSrc->dmICMIntent == DMICM_CONTRAST
         ))

    {
        pdmDest->dmFields |= DM_ICMINTENT;
        pdmDest->dmICMIntent = pdmSrc->dmICMIntent;
    }


    //
    // Resolution
    //

    if ((pdmSrc->dmFields & (DM_PRINTQUALITY|DM_YRESOLUTION)) &&
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_RESOLUTION)))
    {
        PRESOLUTION pRes;
        DWORD       dwIndex;
        INT         iXdpi, iYdpi;

        switch (pdmSrc->dmFields & (DM_PRINTQUALITY|DM_YRESOLUTION))
        {
        case DM_PRINTQUALITY:

            iXdpi = iYdpi = pdmSrc->dmPrintQuality;
            break;

        case DM_YRESOLUTION:

            iXdpi = iYdpi = pdmSrc->dmYResolution;
            break;

        default:

            iXdpi = pdmSrc->dmPrintQuality;
            iYdpi = pdmSrc->dmYResolution;
            break;
        }

        dwIndex = MapToDeviceOptIndex(pUIInfo->pInfoHeader, GID_RESOLUTION, iXdpi, iYdpi, NULL);

        if (pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex))
        {
            pdmDest->dmFields |= (DM_PRINTQUALITY|DM_YRESOLUTION);
            pdmDest->dmPrintQuality = GETQUALITY_X(pRes);
            pdmDest->dmYResolution = GETQUALITY_Y(pRes);
        }
    }

    //
    // Media type
    //

    if ((pdmSrc->dmFields & DM_MEDIATYPE) &&
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_MEDIATYPE)) &&
        (pdmSrc->dmMediaType == DMMEDIA_STANDARD ||
         pdmSrc->dmMediaType == DMMEDIA_TRANSPARENCY ||
         pdmSrc->dmMediaType == DMMEDIA_GLOSSY ||
         pdmSrc->dmMediaType >= DMMEDIA_USER) )
    {
        pdmDest->dmFields |= DM_MEDIATYPE;
        pdmDest->dmMediaType = pdmSrc->dmMediaType;
    }


}



BOOL
BMergeDriverDevmode(
    IN OUT PDEVMODE     pdmDest,
    IN PUIINFO          pUIInfo,
    IN PRAWBINARYDATA   pRawData,
    IN PDEVMODE         pdmSrc
    )

/*++

Routine Description:

    This function validates the source devmode and
    merge it with the destination devmode for UNIDRV

Arguments:

    pdmDest         pointer to destination Unidrv DEVMODE
    pUIInfo         pointer to UIINFO
    pRawData        pointer to RAWBINARYDATA
    pdmSrc          pointer to src DEVMODE

Return Value:

    TRUE if successful, FALSE if there is a fatal error

Note:

    This function should take care of both public devmode fields
    and driver private devmode fields. It can assume the input
    devmode has already been convert to the current size.

--*/
{

    PUNIDRVEXTRA pPrivDest, pPrivSrc;

    ASSERT(pdmDest != NULL &&
           pdmDest->dmSize == sizeof(DEVMODE) &&
           pdmDest->dmDriverExtra >= sizeof(UNIDRVEXTRA) &&
           pdmSrc != NULL &&
           pdmSrc->dmSize == sizeof(DEVMODE) &&
           pdmSrc->dmDriverExtra >= sizeof(UNIDRVEXTRA));

    /**********************************/
    /* TRANSFER PUBLIC DEVMODE FIELDS */
    /**********************************/

    VMergePublicDevmodeFields(pdmSrc, pdmDest, pUIInfo, pRawData);


    /***************************/
    /* GET PRIVATE DEVMODE     */
    /***************************/

    //
    // If the source devmode has a private portion, then check
    // to see if belongs to us. Copy the private portion to
    // the destination devmode if it does.
    //

    pPrivSrc = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmSrc);
    pPrivDest = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmDest);

    //
    // Validate private portion of input devmode
    // If it's not our private devmode, then return the default already in
    // privDest
    //

    if (pPrivSrc->dwSignature == UNIDEVMODE_SIGNATURE)
    {
        memcpy(pPrivDest, pPrivSrc, sizeof(UNIDRVEXTRA));

        if (pPrivDest->dwChecksum32 != pRawData->dwChecksum32)
        {
            WARNING(( "UNIDRV: Devmode checksum mismatch.\n"));

            pPrivDest->dwChecksum32 = pRawData->dwChecksum32;
            pPrivDest->dwOptions = pRawData->dwDocumentFeatures;

            InitDefaultOptions(pRawData,
                               pPrivDest->aOptions,
                               MAX_PRINTER_OPTIONS,
                               MODE_DOCUMENT_STICKY);

         }
    }

    return TRUE;
}

#endif  //  !defined(DEVSTUDIO)

//
// Alignment functions
//

WORD
DwAlign2(
    IN PBYTE pubData)
/*++

Routine Description:

    Converts a non-aligned, big endian (e.g. 80386) value and returns
    it as an integer,  with the correct byte alignment.

Arguments:

    pubData - a pointer to a data buffer to convert

Return Value:

    The converted value.

--*/
{
    static INT iType = 0;
    UW   Uw;


    if( iType == 0 )
    {
        //
        //   Need to determine byte/word relationships
        //

        Uw.b[ 0 ] = 0x01;
        Uw.b[ 1 ] = 0x02;

        iType = Uw.w == 0x0102 ? 1 : 2;
    }

    if( iType == 2 )
    {
        Uw.b[ 0 ] = *pubData++;
        Uw.b[ 1 ] = *pubData;
    }
    else
    {
        Uw.b[ 1 ] = *pubData++;
        Uw.b[ 0 ] = *pubData;
    }

    return  Uw.w;
}

DWORD
DwAlign4(
    IN PBYTE pubData)
{
    static INT iType = 0;
    UDW Udw;

    if( iType == 0 )
    {
        //
        //   Need to determine byte/word relationships
        //

        Udw.b[ 0 ] = 0x01;
        Udw.b[ 1 ] = 0x02;
        Udw.b[ 2 ] = 0x03;
        Udw.b[ 3 ] = 0x04;

        iType = Udw.dw == 0x01020304 ? 1 : 2;
    }

    if( iType == 2 )
    {
        Udw.b[ 0 ] = *pubData++;
        Udw.b[ 1 ] = *pubData++;
        Udw.b[ 2 ] = *pubData++;
        Udw.b[ 3 ] = *pubData;
    }
    else
    {
        Udw.b[ 3 ] = *pubData++;
        Udw.b[ 2 ] = *pubData++;
        Udw.b[ 1 ] = *pubData++;
        Udw.b[ 0 ] = *pubData;
    }

    return  Udw.dw;
}

#if !defined(DEVSTUDIO) //  Not necessary for MDS


BOOL
BGetDevmodeSettingForOEM(
    IN  PDEVMODE    pdm,
    IN  DWORD       dwIndex,
    OUT PVOID       pOutput,
    IN  DWORD       cbSize,
    OUT PDWORD      pcbNeeded
    )

/*++

Routine Description:

    Function to provide OEM plugins access to driver private devmode settings

Arguments:

    pdm - Points to the devmode to be access
    dwIndex - Predefined index to specify which devmode the caller is interested in
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Returns the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAPPSDEVMODEFIELD(index, field) \
        { index, offsetof(UNIDRVEXTRA, field), sizeof(pdmPrivate->field) }

{
    PUNIDRVEXTRA pdmPrivate;
    INT         i;

    static const struct {

        DWORD   dwIndex;
        DWORD   dwOffset;
        DWORD   dwSize;

    } aIndexMap[]  = {

        MAPPSDEVMODEFIELD(OEMGDS_UNIDM_GPDVER, wVer),
        MAPPSDEVMODEFIELD(OEMGDS_UNIDM_FLAGS, dwFlags),

        { 0, 0, 0 }
    };

    pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);
    i = 0;

    while (aIndexMap[i].dwSize != 0)
    {
        if (aIndexMap[i].dwIndex == dwIndex)
        {
            *pcbNeeded = aIndexMap[i].dwSize;

            if (cbSize < aIndexMap[i].dwSize || pOutput == NULL)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }

            CopyMemory(pOutput, (PBYTE) pdmPrivate + aIndexMap[i].dwOffset, aIndexMap[i].dwSize);
            return TRUE;
        }

        i++;
    }

    WARNING(("Unknown unidrv devmode index: %d\n", dwIndex));
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
BConvertPrinterPropertiesData(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData,
    IN PVOID            pvSrcData,
    IN DWORD            dwSrcSize
    )

/*++

Routine Description:

    Convert an older or newer version PRINTERDATA structure to current version

Arguments:

    hPrinter - Handle to the current printer
    pRawData - Points to raw printer description data
    pPrinterData - Points to destination buffer
    pvSrcData - Points to source data to be converted
    dwSrcSize - Size of the source data in bytes

Return Value:

    TRUE if conversion was successful, FALSE otherwise

Note:

    This function is called after the library function has already
    done a generic conversion.

--*/

{

    return TRUE;
}


VOID
VUpdatePrivatePrinterData(
    IN HANDLE           hPrinter,
    IN OUT PPRINTERDATA pPrinterData,
    IN DWORD            dwMode,
    IN PUIINFO          pUIInfo,
    IN POPTSELECT       pCombinedOptions
    )

/*++

Routine Description:

    Update the registry with the keywords

Arguments:

    hPrinter - Handle to the current printer
    pPrinterData - Points to PRINTERDATA
    dwMode - MODE_READ/MODE_WRITE

Return Value:

    None
    TRUE if conversion was successful, FALSE otherwise

--*/

{

    //
    // UniDriver read/write registry steps for point and print to NT4 drivers
    // 1. Writes ModelName to registry if necessary
    // 2. Upgrade PageProtection
    // 3. Upgrade FreeMem
    //

    PTSTR           ptstrModelName = NULL;
    PPAGEPROTECT    pPageProtect = NULL;
    PMEMOPTION      pMemOption = NULL;
    PFEATURE        pPPFeature, pMemFeature;
    DWORD           dwFeatureIndex,dwSelection,dwIndex,dwError;
    DWORD           dwFlag, dwType, cbNeeded;

    if (!pUIInfo || !pCombinedOptions)
        return;

    if (pPPFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEPROTECTION))
        pPageProtect = PGetIndexedOption(pUIInfo, pPPFeature, 0);

    if (pMemFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_MEMOPTION))
        pMemOption = PGetIndexedOption(pUIInfo, pMemFeature, 0);

    dwType = REG_BINARY;

    if (pPageProtect)
    {
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPPFeature);
        dwError = GetPrinterData(hPrinter, REGVAL_PAGE_PROTECTION, &dwType,
                                 (BYTE *)&dwFlag, sizeof(dwFlag), &cbNeeded);

        if (dwMode == MODE_READ )
        {
            if (dwError == ERROR_SUCCESS)
            {
                if (dwFlag & DXF_PAGEPROT)
                    dwSelection = PAGEPRO_ON;
                else
                    dwSelection = PAGEPRO_OFF;

                for (dwIndex = 0; dwIndex < pPPFeature->Options.dwCount; dwIndex++, pPageProtect++)
                {
                    if (dwSelection == pPageProtect->dwPageProtectID)
                        break;
                }

                if (dwIndex == pPPFeature->Options.dwCount)
                    dwIndex = pPPFeature->dwDefaultOptIndex;

                pCombinedOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)dwIndex;
            }
        }
        else // MODE_WRITE
        {
            #ifndef KERNEL_MODE

            SHORT sRasddFlag;

            if (dwError != ERROR_SUCCESS)
                sRasddFlag = 0;
            else
                sRasddFlag = (SHORT)dwFlag;

            pPageProtect = PGetIndexedOption(pUIInfo,
                                                pPPFeature,
                                                pCombinedOptions[dwFeatureIndex].ubCurOptIndex);

            if (pPageProtect && pPageProtect->dwPageProtectID == PAGEPRO_ON)
                sRasddFlag |= DXF_PAGEPROT;
            else
                sRasddFlag &= ~DXF_PAGEPROT;

            SetPrinterData(hPrinter,
                           REGVAL_PAGE_PROTECTION,
                           REG_BINARY,
                           (BYTE *)&sRasddFlag,
                           sizeof(sRasddFlag));
            #endif
        }
    }

    if ( pMemOption)
    {
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pMemFeature);
        dwError = GetPrinterData(hPrinter, REGVAL_RASDD_FREEMEM, &dwType,
                                 (BYTE *)&dwFlag, sizeof(dwFlag), &cbNeeded);

        if (dwMode == MODE_READ )
        {
            if (dwError == ERROR_SUCCESS)
            {

                for (dwIndex = 0; dwIndex < pMemFeature->Options.dwCount; dwIndex++, pMemOption++)
                {
                    if (dwFlag == (pMemOption->dwInstalledMem/KBYTES))
                        break;
                }

                if (dwIndex == pMemFeature->Options.dwCount)
                    dwIndex = pMemFeature->dwDefaultOptIndex;

                pCombinedOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)dwIndex;
            }

        }
        else // MODE_WRITE
        {
            #ifndef KERNEL_MODE

            pMemOption = PGetIndexedOption(pUIInfo,
                                           pMemFeature,
                                           pCombinedOptions[dwFeatureIndex].ubCurOptIndex);

            if (pMemOption)
                dwFlag = (pMemOption->dwInstalledMem/KBYTES);

            SetPrinterData(hPrinter,
                           REGVAL_RASDD_FREEMEM,
                           REG_BINARY,
                           (BYTE *)&dwFlag,
                           sizeof(dwFlag));

            #endif
        }
    }

    //
    // Rasdd requires ModelName, so check if it's there and write it if it's not.
    //
    if (!(ptstrModelName = PtstrGetPrinterDataString(hPrinter, REGVAL_MODELNAME, &dwFlag)))
    {
        #ifndef KERNEL_MODE

        PGPDDRIVERINFO pDriverInfo;

        pDriverInfo = OFFSET_TO_POINTER(pUIInfo->pInfoHeader,
                                        pUIInfo->pInfoHeader->loDriverOffset);

        BSetPrinterDataString(hPrinter,
                              REGVAL_MODELNAME,
                              pDriverInfo->Globals.pwstrModelName,
                              REG_SZ);

        #endif

    }

    if (ptstrModelName)
        MemFree(ptstrModelName);

    return;

}


VOID
VDefaultDevmodeFormFields(
    PUIINFO     pUIInfo,
    PDEVMODE    pDevmode,
    BOOL        bMetric
    )

/*++

Routine Description:

    Initialized the form-related devmode fields with their default values

Arguments:

    pUIInfo - Points for UIINFO
    pDevmode - Points to the DEVMODE whose form-related fields are to be initialized
    bMetric - Specifies whether the system is running in metric mode

Return Value:

    NONE

--*/

{
    PFEATURE    pFeature;
    PPAGESIZE   pPageSize;

    if (bMetric && (pUIInfo->dwFlags & FLAG_A4_SIZE_EXISTS))
    {
        CopyString(pDevmode->dmFormName, A4_FORMNAME, CCHFORMNAME);
        pDevmode->dmPaperSize = DMPAPER_A4;
        pDevmode->dmPaperWidth = 2100;      // 210mm measured in 0.1mm units
        pDevmode->dmPaperLength = 2970;     // 297mm

    }
    else if (!bMetric && (pUIInfo->dwFlags & FLAG_LETTER_SIZE_EXISTS))
    {
        CopyString(pDevmode->dmFormName, LETTER_FORMNAME, CCHFORMNAME);
        pDevmode->dmPaperSize = DMPAPER_LETTER;
        pDevmode->dmPaperWidth = 2159;      // 8.5"
        pDevmode->dmPaperLength = 2794;     // 11"
    }
    else
    {
        if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE))
        {
            //
            // Skip writing the dmFormName here because
            // ValidateDevmodeFormField will take care of it.
            //

            pPageSize = PGetIndexedOption(pUIInfo, pFeature, pFeature->dwDefaultOptIndex);
            if (pPageSize)
            {
                pDevmode->dmPaperSize = (SHORT)pPageSize->dwPaperSizeID;
                pDevmode->dmPaperWidth = (SHORT)(MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cx,
                                                                       pUIInfo->ptMasterUnits.x)
                                                 / DEVMODE_PAPER_UNIT);
                pDevmode->dmPaperLength = (SHORT)(MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cy,
                                                                        pUIInfo->ptMasterUnits.y)
                                                  / DEVMODE_PAPER_UNIT);

                pDevmode->dmFields |= (DM_PAPERWIDTH | DM_PAPERLENGTH | DM_PAPERSIZE);
                pDevmode->dmFields &= ~DM_FORMNAME;
                return;
            }
        }
    }

    pDevmode->dmFields &= ~(DM_PAPERWIDTH | DM_PAPERLENGTH);
    pDevmode->dmFields |= (DM_PAPERSIZE | DM_FORMNAME);
}

#endif  //  !defined(DEVSTUDIO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\uni\um\umlib.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    
    umlib.c

Abstract:

    This string handling the UM code for Unidrv

Environment:

    Win32 subsystem, Unidrv driver

Revision History:

    11/12/96 -eigos-
        Created it.

    dd-mm-yy -author-
        description

--*/

#if defined(DEVSTUDIO)
#include "..\precomp.h"
#else
#include "precomp.h"
#endif

DWORD
DwCopyStringToUnicodeString(
    IN  UINT  uiCodePage,
    IN  PSTR  pstrCharIn,
    OUT PWSTR pwstrCharOut,
    IN  INT   iwcOutSize)

{
    INT iCharCountIn;
    INT iRetVal;
    size_t  stStringLength;

    if ( NULL == pwstrCharOut )
    {
        return (DWORD)-1;
    }

    iCharCountIn =  strlen(pstrCharIn) + 1;

    iRetVal = MultiByteToWideChar( uiCodePage,
                                   0,
                                   pstrCharIn,
                                   iCharCountIn,
                                   pwstrCharOut,
                                   iwcOutSize);

    if ( 0 == iRetVal ||
        FAILED ( StringCchLengthW ( pwstrCharOut, iwcOutSize, &stStringLength ) ) )
    {
        pwstrCharOut[iwcOutSize-1] = TEXT('\0');
    }

    return (DWORD)iRetVal;

}

DWORD
DwCopyUnicodeStringToString(
    IN  UINT  uiCodePage,
    IN  PWSTR pwstrCharIn,
    OUT PSTR  pstrCharOut,
    IN  INT   icbOutSize)

{
    INT     iCharCountIn;
    INT     iRetVal;
    size_t  stStringLength;

    if ( NULL == pstrCharOut )
    {
        return (DWORD)-1;
    }

    iCharCountIn =  wcslen(pwstrCharIn) + 1;

    iRetVal = WideCharToMultiByte( uiCodePage,
                                   0,
                                   pwstrCharIn,
                                   iCharCountIn,
                                   pstrCharOut,
                                   icbOutSize,
                                   NULL,
                                   NULL);

    if ( 0 == iRetVal ||
        FAILED ( StringCchLengthA ( pstrCharOut, icbOutSize, &stStringLength ) ) )
    {
        pstrCharOut[icbOutSize-1] = '\0';
    }

    return (DWORD)iRetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\dbcsutil.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    dbcsutil.c

Abstract:

    Double byte font/character handling functions (for CJK)

Environment:

    Windows NT printer drivers

Revision History:

    10/8/97 -eigos-
        Removed BIsDBCSLeadByteXXX functions and Added TranslateCharSetInfo and
        GetACP.

    01/20/97 -eigos-
        Created it.

--*/

#include "lib.h"

//
//
// This is a hack implementation (although very close to the real one)
// so that all the places in the code that need to know what the default
// charset and/or codepage is don't have duplicate code all over the place.
// This allows us to have a single binary for Japan/Korea/Chinese.
//
// This code copied from \\rastaman\ntwin!src\ntgdi\gre\mapfile.c
//
// We should not call GreTranslateCharsetInfo and GreXXXX.
// So, MyTranslateCharsetInfo is here.
//
//

#define NCHARSETS       14

//
// Globals
//

struct _CHARSETINFO {
    UINT CharSet;
    UINT CodePage;
} CharSetInfo[NCHARSETS] = {
    { ANSI_CHARSET,        1252},
    { SHIFTJIS_CHARSET,     932},
    { HANGEUL_CHARSET,      949},
    { JOHAB_CHARSET,       1361},
    { GB2312_CHARSET,       936},
    { CHINESEBIG5_CHARSET,  950},
    { HEBREW_CHARSET,      1255},
    { ARABIC_CHARSET,      1256},
    { GREEK_CHARSET,       1253},
    { TURKISH_CHARSET,     1254},
    { BALTIC_CHARSET,      1257},
    { EASTEUROPE_CHARSET,  1250},
    { RUSSIAN_CHARSET,     1251},
    { THAI_CHARSET,         874}
};

//
// Functions
// no font signature implemented
//

BOOL PrdTranslateCharsetInfo(
    IN  UINT          dwSrc,
    OUT LPCHARSETINFO lpCs,
    IN  DWORD         dwType)
/*++
 
Routine Description:
 
    Translate Character set to Codepage and vise versa.
 
Arguments:
 
    dwSrc - Character set if dwType is TCI_SRCCHARSET
            Codepage if dwType is TCI_SRCCODEPAGE
 
    lpCs - Pointer to the CHARSETINFO
    dwType - a type of translation, TCI_SRCCHARSET and TCI_SRCCODEPAGE are
             currently supported.

Return Value:
 
    TRUE if successful, FALSE if there is an error
 
--*/
{
    int i;

    switch( dwType ) {

    case TCI_SRCCHARSET:

        for( i = 0; i < NCHARSETS; i++ )
            if ( CharSetInfo[i].CharSet == dwSrc )
            {
                lpCs->ciACP      = CharSetInfo[i].CodePage;
                lpCs->ciCharset  = CharSetInfo[i].CharSet;
                //lpCs->fs.fsCsb[0] = fs[i];
                return TRUE;
            }
        break;

    case TCI_SRCCODEPAGE:

        for( i = 0; i < NCHARSETS; i++ )
            if ( CharSetInfo[i].CodePage == dwSrc )
            {
                lpCs->ciACP      = CharSetInfo[i].CodePage;
                lpCs->ciCharset  = CharSetInfo[i].CharSet;
                //lpCs->fs.fsCsb[0] = fs[i];
                return TRUE;
            }
        break;

    case TCI_SRCFONTSIG:
    default:
        break;
    }

    return(FALSE);
}

UINT PrdGetACP(VOID)
/*++
 
Routine Description:
 
    Get a current CodePage.
 
Arguments:
 
    None

Return Value:
 
    None
 
--*/
{
    USHORT OemCodePage, AnsiCodePage;

    EngGetCurrentCodePage(&OemCodePage, &AnsiCodePage);

    return (UINT)AnsiCodePage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\libutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    libutil.c

Abstract:

    Utility functions

Environment:

        Windows NT printer drivers

Revision History:

        08/13/96 -davidx-
            Added CopyString functions and moved SPRINTF functions.

        08/13/96 -davidx-
        Added devmode conversion routine and spooler API wrapper functions.

        03/13/96 -davidx-
            Created it.

--*/

#include "lib.h"

//
// Digit characters used for converting numbers to ASCII
//

const CHAR gstrDigitString[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

//
// Variable to control the amount of debug messages generated
//

#if DBG

INT giDebugLevel = DBG_WARNING;

#endif


DWORD
HashKeyword(
    LPCSTR  pKeywordStr
    )

/*++

Routine Description:

    Generate a hash value for the given string.

Arguments:

    pKeywordStr - The string to generate the hash value for,
                  single byte ANSI null terminated.

Return Value:

    Hash value.

--*/

{
    LPBYTE  pbuf = (LPBYTE) pKeywordStr;
    DWORD   dwHashValue = 0;

    //
    // Note that only the last 32 characters of the keyword string are significant.
    //

    while (*pbuf)
        dwHashValue = (dwHashValue << 1) ^ *pbuf++;

    return(dwHashValue);
}



PTSTR
DuplicateString(
    IN LPCTSTR  ptstrSrc
    )

/*++

Routine Description:

    Make a duplicate of the specified character string

Arguments:

    ptstrSrc - Specifies the source string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    PTSTR   ptstrDest;
    INT     iSize;

    if (ptstrSrc == NULL)
        return NULL;

    iSize = SIZE_OF_STRING(ptstrSrc);

    if (ptstrDest = MemAlloc(iSize))
        CopyMemory(ptstrDest, ptstrSrc, iSize);
    else
        ERR(("Couldn't duplicate string: %ws\n", ptstrSrc));

    return ptstrDest;
}



VOID
CopyStringW(
    OUT PWSTR   pwstrDest,
    IN PCWSTR   pwstrSrc,
    IN INT      iDestSize
    )

/*++

Routine Description:

    Copy Unicode string from source to destination

Arguments:

    pwstrDest - Points to the destination buffer
    pwstrSrc - Points to source string
    iDestSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PWSTR   pwstrEnd;

    ASSERT(pwstrDest && pwstrSrc && iDestSize > 0);
    pwstrEnd = pwstrDest + (iDestSize - 1);

    while ((pwstrDest < pwstrEnd) && ((*pwstrDest++ = *pwstrSrc++) != NUL))
        NULL;

    while (pwstrDest <= pwstrEnd)
        *pwstrDest++ = NUL;
}



VOID
CopyStringA(
    OUT PSTR    pstrDest,
    IN PCSTR    pstrSrc,
    IN INT      iDestSize
    )

/*++

Routine Description:

    Copy ANSI string from source to destination

Arguments:

    pstrDest - Points to the destination buffer
    pstrSrc - Points to source string
    iDestSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PSTR    pstrEnd;

    ASSERT(pstrDest && pstrSrc && iDestSize > 0);
    pstrEnd = pstrDest + (iDestSize - 1);

    while ((pstrDest < pstrEnd) && (*pstrDest++ = *pstrSrc++) != NUL)
        NULL;

    while (pstrDest <= pstrEnd)
        *pstrDest++ = NUL;
}



PVOID
MyGetPrinter(
    IN HANDLE   hPrinter,
    IN DWORD    dwLevel
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    dwLevel - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    PVOID   pv = NULL;
    DWORD   dwBytesNeeded;

    if (!GetPrinter(hPrinter, dwLevel, NULL, 0, &dwBytesNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pv = MemAlloc(dwBytesNeeded)) &&
        GetPrinter(hPrinter, dwLevel, pv, dwBytesNeeded, &dwBytesNeeded))
    {
        return pv;
    }

    ERR(("GetPrinter failed: %d\n", GetLastError()));
    MemFree(pv);
    return NULL;
}



PVOID
MyEnumForms(
    IN HANDLE   hPrinter,
    IN DWORD    dwLevel,
    OUT PDWORD  pdwFormsReturned
    )

/*++

Routine Description:

    Wrapper function for EnumForms spooler API

Arguments:

    hPrinter - Identifies the printer in question
    dwLevel - Specifies the level of FORM_INFO_x structure requested
    pdwFormsReturned - Returns the number of FORM_INFO_x structures enumerated

Return Value:

    Pointer to an array of FORM_INFO_x structures,
    NULL if there is an error

--*/

{
    PVOID   pv = NULL;
    DWORD   dwBytesNeeded;

    if (!EnumForms(hPrinter, dwLevel, NULL, 0, &dwBytesNeeded, pdwFormsReturned) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pv = MemAlloc(dwBytesNeeded)) &&
        EnumForms(hPrinter, dwLevel, pv, dwBytesNeeded, &dwBytesNeeded, pdwFormsReturned))
    {
        return pv;
    }

    ERR(("EnumForms failed: %d\n", GetLastError()));
    MemFree(pv);
    *pdwFormsReturned = 0;
    return NULL;
}



#ifndef KERNEL_MODE

PVOID
MyGetForm(
    IN HANDLE   hPrinter,
    IN PTSTR    ptstrFormName,
    IN DWORD    dwLevel
    )

/*++

Routine Description:

    Wrapper function for GetForm spooler API

Arguments:

    hPrinter - Identifies the printer in question
    ptstrFormName - Specifies the name of interested form
    dwLevel - Specifies the level of FORM_INFO_x structure requested

Return Value:

    Pointer to a FORM_INFO_x structures, NULL if there is an error

--*/

{
    PVOID   pv = NULL;
    DWORD   cb;

    if (!GetForm(hPrinter, ptstrFormName, dwLevel, NULL, 0, &cb) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pv = MemAlloc(cb)) &&
        GetForm(hPrinter, ptstrFormName, dwLevel, pv, cb, &cb))
    {
        return pv;
    }

    ERR(("GetForm failed: %d\n", GetLastError()));
    MemFree(pv);
    return NULL;
}

#endif // !KERNEL_MODE



PVOID
MyGetPrinterDriver(
    IN HANDLE   hPrinter,
    IN HDEV     hDev,
    IN DWORD    dwLevel
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriver spooler API

Arguments:

    hPrinter - Identifies the printer in question
    hDev - GDI handle to current printer device context
    dwLevel - Specifies the level of DRIVER_INFO_x structure requested

Return Value:

    Pointer to a DRIVER_INFO_x structure, NULL if there is an error

--*/

{
    #if !defined(WINNT_40) || !defined(KERNEL_MODE)

    PVOID   pv = NULL;
    DWORD   dwBytesNeeded;

    if (!GetPrinterDriver(hPrinter, NULL, dwLevel, NULL, 0, &dwBytesNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pv = MemAlloc(dwBytesNeeded)) &&
        GetPrinterDriver(hPrinter, NULL, dwLevel, pv, dwBytesNeeded, &dwBytesNeeded))
    {
        return pv;
    }

    ERR(("GetPrinterDriver failed: %d\n", GetLastError()));
    MemFree(pv);

    #else // WINNT_40 && KERNEL_MODE

    PDRIVER_INFO_3  pDriverInfo3 = NULL;

    ASSERT(hDev != NULL);

    if (hDev)
    {
        //
        // hDev is available, so we can use Eng-calls to get driver_info_3 fields.
        //

        PWSTR           pwstrDriverFile, pwstrDataFile;
        INT             iDriverNameSize, iDataNameSize;
        PWSTR           pwstrDepFiles;
        DWORD           dwDepSize, dwDepSizeWithPath;
        PTSTR           ptstrDriverDir = NULL;

        //
        // EngGetPrinterDriver is not available on NT4. So we'll fake a
        // DRIVER_INFO_3 structure and fill in pDriverPath and pDataFile fields.
        //

        pwstrDriverFile = EngGetDriverName(hDev);
        pwstrDataFile = EngGetPrinterDataFileName(hDev);

        if (!pwstrDriverFile || !pwstrDataFile)
        {
            RIP(("Driver and/or data filename is NULL\n"));
            return NULL;
        }

        //
        // The pDependentFiles field is currently only used by PS driver.
        //

        pwstrDepFiles = PtstrGetPrinterDataString(hPrinter, REGVAL_DEPFILES, &dwDepSize);

        if (pwstrDepFiles && !BVerifyMultiSZ(pwstrDepFiles, dwDepSize))
        {
            RIP(("Dependent file list is not in MULTI_SZ format\n"));
            MemFree(pwstrDepFiles);
            pwstrDepFiles = NULL;
        }

        if (pwstrDepFiles && ((ptstrDriverDir = PtstrGetDriverDirectory((LPCTSTR)pwstrDriverFile)) == NULL))
        {
            RIP(("Can't get driver directory from driver file name\n"));
            MemFree(pwstrDepFiles);
            pwstrDepFiles = NULL;
        }

        iDriverNameSize = SIZE_OF_STRING(pwstrDriverFile);
        iDataNameSize = SIZE_OF_STRING(pwstrDataFile);

        if (pwstrDepFiles == NULL)
            dwDepSizeWithPath = 0;
        else
            dwDepSizeWithPath = dwDepSize + DwCountStringsInMultiSZ((LPCTSTR)pwstrDepFiles)
                                            * _tcslen(ptstrDriverDir) * sizeof(TCHAR);

        pDriverInfo3 = MemAllocZ(sizeof(DRIVER_INFO_3) + iDriverNameSize+iDataNameSize+dwDepSizeWithPath);

        if (pDriverInfo3 == NULL)
        {
            ERR(("Memory allocation failed\n"));
            MemFree(pwstrDepFiles);
            MemFree(ptstrDriverDir);
            return NULL;
        }

        pDriverInfo3->cVersion = 3;
        pDriverInfo3->pDriverPath = (PWSTR) ((PBYTE) pDriverInfo3 + sizeof(DRIVER_INFO_3));
        pDriverInfo3->pDataFile = (PWSTR) ((PBYTE) pDriverInfo3->pDriverPath + iDriverNameSize);

        CopyMemory(pDriverInfo3->pDriverPath, pwstrDriverFile, iDriverNameSize);
        CopyMemory(pDriverInfo3->pDataFile, pwstrDataFile, iDataNameSize);

        if (pwstrDepFiles)
        {
            PTSTR  ptstrSrc, ptstrDest;
            INT    iDirLen;

            ptstrSrc = pwstrDepFiles;
            ptstrDest = pDriverInfo3->pDependentFiles = (PWSTR) ((PBYTE) pDriverInfo3->pDataFile + iDataNameSize);

            iDirLen = _tcslen(ptstrDriverDir);

            while (*ptstrSrc)
            {
                INT  iNameLen;

                //
                // Copy the driver dir path (the last char is '\')
                //

                CopyMemory(ptstrDest, ptstrDriverDir, iDirLen * sizeof(TCHAR));
                ptstrDest += iDirLen;

                //
                // Copy the dependent file name
                //

                iNameLen = _tcslen(ptstrSrc);
                CopyMemory(ptstrDest, ptstrSrc, iNameLen * sizeof(TCHAR));
                ptstrDest += iNameLen + 1;

                ptstrSrc += iNameLen + 1;
            }
        }

        MemFree(pwstrDepFiles);
        MemFree(ptstrDriverDir);

        return((PVOID)pDriverInfo3);
    }

    #endif // WINNT_40 && KERNEL_MODE

    return NULL;
}



VOID
VGetSpoolerEmfCaps(
    IN  HANDLE  hPrinter,
    OUT PBOOL   pbNupOption,
    OUT PBOOL   pbReversePrint,
    IN  DWORD   cbOut,
    OUT PVOID   pSplCaps
    )

/*++

Routine Description:

    Figure out what EMF features (such as N-up and reverse-order printing)
    the spooler can support

Arguments:

    hPrinter - Handle to the current printer
    pbNupOption - Whether spooler supports N-up
    pbReversePrint - Whether spooler supports reverse-order printing
    cbOut - size in byte of output buffer pointed by pSplCaps
    pSplCaps - Get all spooler caps

Return Value:

    NONE

--*/

#define REGVAL_EMFCAPS  TEXT("PrintProcCaps_EMF")

{
    PVOID   pvData;
    DWORD   dwSize, dwType, dwStatus;

    if (pbNupOption)
        *pbNupOption = FALSE;

    if (pbReversePrint)
        *pbReversePrint = FALSE;

    #if !defined(WINNT_40)

    pvData = NULL;
    dwStatus = GetPrinterData(hPrinter, REGVAL_EMFCAPS, &dwType, NULL, 0, &dwSize);

    if ((dwStatus == ERROR_MORE_DATA || dwStatus == ERROR_SUCCESS) &&
        (dwSize >= sizeof(PRINTPROCESSOR_CAPS_1)) &&
        (pvData = MemAlloc(dwSize)) &&
        (GetPrinterData(hPrinter, REGVAL_EMFCAPS, &dwType, pvData, dwSize, &dwSize) == ERROR_SUCCESS))
    {
        PPRINTPROCESSOR_CAPS_1  pEmfCaps = pvData;

        if (pbNupOption)
            *pbNupOption = (pEmfCaps->dwNupOptions & ~1) != 0;

        if (pbReversePrint)
            *pbReversePrint = (pEmfCaps->dwPageOrderFlags & REVERSE_PRINT) != 0;

        if (pSplCaps)
        {
            CopyMemory(pSplCaps,
                       pEmfCaps,
                       min(cbOut, sizeof(PRINTPROCESSOR_CAPS_1)));
        }
    }
    else
    {
        ERR(("GetPrinterData PrintProcCaps_EMF failed: %d\n", dwStatus));
    }

    MemFree(pvData);

    #endif // !WINNT_40
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}


#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)


PVOID
MemRealloc(
    IN PVOID    pvOldMem,
    IN DWORD    cbOld,
    IN DWORD    cbNew
    )

/*++

Routine Description:

    Change the size of a specified memory block. The size can increase
    or decrease.

Arguments:

    pvOldMem - Pointer to the old memory block to be reallocated.
    cbOld - old size in bytes of the memory block
    cbNew - new size in bytes of the reallocated memory block

Return Value:

    If succeeds, it returns pointer to the reallocated memory block.
    Otherwise, it returns NULL.

--*/

{
    PVOID   pvNewMem;

    if (!(pvNewMem = MemAlloc(cbNew)))
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    if (pvOldMem)
    {
        if (cbOld)
        {
            CopyMemory(pvNewMem, pvOldMem, min(cbOld, cbNew));
        }

        MemFree(pvOldMem);
    }

    return pvNewMem;
}

#endif  // !KERNEL_MODE || USERMODE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\devmode.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    devmode.c

Abstract:

    Devmode related library functions

Environment:

	Windows NT printer drivers

Revision History:

    07/22/98 -fengy-
        Move OEM related devmode functions into "oemutil.c".

    02/04/97 -davidx-
        Devmode changes to support OEM plugins.

	09/20/96 -davidx-
        Seperated from libutil.c and implement BValidateDevmodeFormFields.

--*/

#include "lib.h"

#ifndef KERNEL_MODE
#include <winddiui.h>
#endif

#include <printoem.h>
#include "oemutil.h"


//
// Default halftone parameters
//

DEVHTINFO gDefaultDevHTInfo =
{
    HT_FLAG_HAS_BLACK_DYE,
    HT_PATSIZE_6x6_M,
    0,                                  // DevPelsDPI

    {   { 6380, 3350,       0 },        // xr, yr, Yr
        { 2345, 6075,       0 },        // xg, yg, Yg
        { 1410,  932,       0 },        // xb, yb, Yb
        { 2000, 2450,       0 },        // xc, yc, Yc Y=0=HT default
        { 5210, 2100,       0 },        // xm, ym, Ym
        { 4750, 5100,       0 },        // xy, yy, Yy
        { 3127, 3290,       0 },        // xw, yw, Yw=0=default

        12500,                          // R gamma
        12500,                          // G gamma
        12500,                          // B gamma, 12500=Default

        585,   120,                     // M/C, Y/C
          0,     0,                     // C/M, Y/M
          0, 10000                      // C/Y, M/Y  10000=default
    }
};

COLORADJUSTMENT gDefaultHTColorAdjustment =
{
    sizeof(COLORADJUSTMENT),
    0,
    ILLUMINANT_DEVICE_DEFAULT,
    10000,
    10000,
    10000,
    REFERENCE_BLACK_MIN,
    REFERENCE_WHITE_MAX,
    0,
    0,
    0,
    0
};



BOOL
BValidateDevmodeFormFields(
    HANDLE      hPrinter,
    PDEVMODE    pDevmode,
    PRECTL      prcImageArea,
    FORM_INFO_1 *pForms,
    DWORD       dwForms
    )

/*++

Routine Description:

    Validate the form-related fields in the input devmode and
    make sure they're consistent with each other.

Arguments:

    hPrinter - Handle to a printer
    pDevmode - Specifies the devmode whose form-related fields are to be validated
    prcImageArea - Returns the logical imageable area associated with the form
    pForms - Points to list of spooler forms
    dwForms - Number of spooler spooler

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    prcImageArea could be NULL in which case the caller is not interested
    in the imageable area information.

    If the caller doesn't want to provide the list of spooler forms,
    it can set pForms parameter to NULL and dwForms to 0.

--*/

#define FORMFLAG_ERROR  0
#define FORMFLAG_VALID  1
#define FORMFLAG_CUSTOM 2

{
    DWORD           dwIndex;
    PFORM_INFO_1    pAllocedForms = NULL;
    INT             iResult = FORMFLAG_ERROR;

    //
    // Get the list of spooler forms if the caller hasn't provided it
    //

    if (pForms == NULL)
    {
        pAllocedForms = pForms = MyEnumForms(hPrinter, 1, &dwForms);

        if (pForms == NULL)
            return FALSE;
    }

    if ((pDevmode->dmFields & DM_PAPERWIDTH) &&
        (pDevmode->dmFields & DM_PAPERLENGTH) &&
        (pDevmode->dmPaperWidth > 0) &&
        (pDevmode->dmPaperLength > 0))
    {
        LONG    lWidth, lHeight;

        //
        // Devmode is requesting form using width and height.
        // Go through the forms database and check if one of
        // the forms has the same size as what's being requested.
        //
        // The tolerance is 1mm. Also remember that our internal
        // unit for paper measurement is micron while the unit 
        // for width and height fields in a DEVMODE is 0.1mm.
        //

        lWidth = pDevmode->dmPaperWidth * DEVMODE_PAPER_UNIT;
        lHeight = pDevmode->dmPaperLength * DEVMODE_PAPER_UNIT;

        for (dwIndex = 0; dwIndex < dwForms; dwIndex++)
        {
            if (abs(lWidth - pForms[dwIndex].Size.cx) <= 1000 &&
                abs(lHeight - pForms[dwIndex].Size.cy) <= 1000)
            {
                iResult = FORMFLAG_VALID;
                break;
            }
        }

        //
        // Custom size doesn't match that of any predefined forms.
        //

        if (iResult != FORMFLAG_VALID)
        {
            iResult = FORMFLAG_CUSTOM;

            pDevmode->dmFields &= ~(DM_PAPERSIZE|DM_FORMNAME);
            pDevmode->dmPaperSize = DMPAPER_USER;
            ZeroMemory(pDevmode->dmFormName, sizeof(pDevmode->dmFormName));

            //
            // Assume the logical imageable area is the entire page in this case
            //

            if (prcImageArea)
            {
                prcImageArea->left = prcImageArea->top = 0;
                prcImageArea->right = lWidth;
                prcImageArea->bottom = lHeight;
            }
        }
    }
    else if (pDevmode->dmFields & DM_PAPERSIZE)
    {
        //
        // Devmode is requesting form using paper size index
        //

        dwIndex = pDevmode->dmPaperSize;

        if ((dwIndex >= DMPAPER_FIRST) && (dwIndex < DMPAPER_FIRST + dwForms))
        {
            dwIndex -= DMPAPER_FIRST;
            iResult = FORMFLAG_VALID;
        }
        else
        {
            ERR(("Paper size index out-of-range: %d\n", dwIndex));
        }
    }
    else if (pDevmode->dmFields & DM_FORMNAME)
    {
        //
        // Devmode is requesting form using form name. Go through
        // the forms database and check if the requested form
        // name matches that of a database form.
        //

        for (dwIndex = 0; dwIndex < dwForms; dwIndex++)
        {
            if (_wcsicmp(pDevmode->dmFormName, pForms[dwIndex].pName) == EQUAL_STRING)
            {
                iResult = FORMFLAG_VALID;
                break;
            }
        }

        if (iResult != FORMFLAG_VALID)
        {
            ERR(("Unrecognized form name: %ws\n", pDevmode->dmFormName));
        }
    }
    else
    {
        ERR(("Invalid form requested in the devmode.\n"));
    }

    //
    // If a valid form is found, fill in the form-related field
    // in the devmode to make sure they're consistent.
    //
    // Remember the conversion from micron to 0.1mm here.
    //

    if (iResult == FORMFLAG_VALID)
    {
        pDevmode->dmFields &= ~(DM_PAPERWIDTH|DM_PAPERLENGTH);
        pDevmode->dmFields |= (DM_PAPERSIZE|DM_FORMNAME);

        pDevmode->dmPaperWidth = (SHORT) (pForms[dwIndex].Size.cx / DEVMODE_PAPER_UNIT);
        pDevmode->dmPaperLength = (SHORT) (pForms[dwIndex].Size.cy / DEVMODE_PAPER_UNIT);
        pDevmode->dmPaperSize = (SHORT) (dwIndex + DMPAPER_FIRST);

        CopyString(pDevmode->dmFormName, pForms[dwIndex].pName, CCHFORMNAME);

        if (prcImageArea)
            *prcImageArea = pForms[dwIndex].ImageableArea;
    }

    MemFree(pAllocedForms);
    return (iResult != FORMFLAG_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\km\kmfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    kmfuncs.c

Abstract:

    Kernel-mode specific library functions

Environment:

    Windows NT printer drivers

Revision History:

    10/19/97 -fengy-
        added MapFileIntoMemoryForWrite,
              GenerateTempFileName.

    03/16/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#ifndef USERMODE_DRIVER

#include "lib.h"

//
// Maximum number of time to try to generate a unique name
//

#define MAX_UNIQUE_NAME_TRY  9



HANDLE
MapFileIntoMemoryForWrite(
    IN LPCTSTR  ptstrFilename,
    IN DWORD    dwDesiredSize,
    OUT PVOID  *ppvData,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Map a file into process memory space for write.

Arguments:

    ptstrFilename - Specifies the name of the file to be mapped
    dwDesiredSize - Specifies the desired size of the file to be mapped
    ppvData - Points to a variable for returning mapped memory address
    pdwSize - Points to a variable for returning the actual size of the mapped file

Return Value:

    Handle to identify the mapped file, NULL if there is an error

--*/

{
    HANDLE  hModule = NULL;
    DWORD   dwSize;

    if (hModule = EngLoadModuleForWrite((PWSTR)ptstrFilename, dwDesiredSize))
    {
        if (*ppvData = EngMapModule(hModule, &dwSize))
        {
            if (pdwSize)
                *pdwSize = dwSize;
        }
        else
        {
            ERR(("EngMapModule failed: %d\n", GetLastError()));
            EngFreeModule(hModule);
            hModule = NULL;
        }
    }
    else
        ERR(("EngLoadModuleForWrite failed: %d\n", GetLastError()));

    return hModule;
}



PTSTR
GenerateTempFileName(
    IN LPCTSTR lpszPath,
    IN DWORD   dwSeed
    )

/*++

Routine Description:

    Generate a temporary filename in kernel mode.

Arguments:

    lpszPath - A null-terminated string which specifies the path of the temp file.
               It should contain the trailing backslash.
    dwSeed   - a number used to generate unique file name

Return Value:

    Pointer to a null-terminated full path filename string, NULL if there is an error.
    Caller is responsible for freeing the returned string.

--*/

{
    ENG_TIME_FIELDS currentTime;
    ULONG ulNameValue,ulExtValue;
    PTSTR ptstr,tempName[36],tempStr[16];
    INT iPathLength,iNameLength,i;
    HFILEMAP hFileMap;
    PVOID pvData;
    DWORD dwSize;
    BOOL bNameUnique=FALSE;
    INT iTry=0;

    ASSERT(lpszPath != NULL);

    while (!bNameUnique && iTry < MAX_UNIQUE_NAME_TRY)
    {
        EngQueryLocalTime(&currentTime); 

        //
        // Use the seed number and current local time to compose the temporary file name
        //

        ulNameValue = currentTime.usDay * 1000000 +
                      currentTime.usHour * 10000 +
                      currentTime.usMinute * 100 +
                      currentTime.usSecond;
        ulExtValue = currentTime.usMilliseconds;

        _ultot((ULONG)dwSeed, (PTSTR)tempName, 10);
        _tcsncat((PTSTR)tempName, TEXT("_"), 1);

        _ultot(ulNameValue, (PTSTR)tempStr, 10);
        _tcsncat((PTSTR)tempName, (PTSTR)tempStr, _tcslen((PTSTR)tempStr));
        _tcsncat((PTSTR)tempName, TEXT("."), 1);

        _ultot(ulExtValue, (PTSTR)tempStr, 10);
        _tcsncat((PTSTR)tempName, (PTSTR)tempStr, _tcslen((PTSTR)tempStr));

        iPathLength = _tcslen(lpszPath);
        iNameLength = _tcslen((PTSTR)tempName);

        if ((ptstr = MemAlloc((iPathLength + iNameLength + 1) * sizeof(TCHAR))) != NULL)
        {
            CopyMemory(ptstr, lpszPath, iPathLength * sizeof(TCHAR));
            CopyMemory(ptstr+iPathLength, (PTSTR)tempName, (iNameLength+1) * sizeof(TCHAR));

            //
            // Verify if a file with the same name already exists
            //

            if (!(hFileMap = MapFileIntoMemory(ptstr, &pvData, &dwSize)))
                bNameUnique = TRUE;
            else
            {
                //
                // Need to generate another temporary file name
                //

                UnmapFileFromMemory(hFileMap);
                MemFree(ptstr);
                ptstr = NULL;
                iTry++;
            }
        }
        else
        {
            ERR(("Memory allocation failed\n"));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            break;
        }
    }

    return ptstr;
}



#if DBG

//
// Functions for outputting debug messages
//

VOID
DbgPrint(
    IN PCSTR pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}

#endif

#endif //!USERMODE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\um\umfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umfuncs.c

Abstract:

    User-mode specific library functions

Environment:

    Windows NT printer drivers

Revision History:

    08/13/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "lib.h"



BOOL
IsMetricCountry(
    VOID
    )

/*++

Routine Description:

    Determine if the current country is using metric system.

Arguments:

    NONE

Return Value:

    TRUE if the current country uses metric system, FALSE otherwise

--*/

{
    INT     iCharCount;
    PVOID   pv = NULL;
    LONG    lCountryCode = CTRY_UNITED_STATES;

    //
    // Determine the size of the buffer needed to retrieve locale information.
    // Allocate the necessary space.
    //
    //

    if ((iCharCount = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, NULL, 0)) > 0 &&
        (pv = MemAlloc(sizeof(TCHAR) * iCharCount)) &&
        (iCharCount == GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, pv, iCharCount)))
    {
        lCountryCode = _ttol(pv);
    }

    MemFree(pv);
    VERBOSE(("Default country code: %d\n", lCountryCode));

    //
    // This is the Win31 algorithm based on AT&T international dialing codes.
    //
    // Fix bug #31535: Brazil (country code 55) should use A4 as default paper size.
    //

    return ((lCountryCode == CTRY_UNITED_STATES) ||
            (lCountryCode == CTRY_CANADA) ||
            (lCountryCode >=  50 && lCountryCode <  60 && lCountryCode != CTRY_BRAZIL) ||
            (lCountryCode >= 500 && lCountryCode < 600)) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

SOURCES=..\libutil.c    \
        ..\regdata.c    \
        ..\devmode.c    \
        ..\parser.c     \
        ..\mapfile.c    \
        ..\dbcsutil.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\mapfile.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    umfuncs.c

Abstract:

    Help functions to map file into memory

Environment:

    Windows NT printer drivers

Revision History:

    08/13/96 -davidx-
        Created it.

--*/

#include "lib.h"


#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

HFILEMAP
MapFileIntoMemory(
    IN LPCTSTR  ptstrFilename,
    OUT PVOID  *ppvData,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Map a file into process memory space.

Arguments:

    ptstrFilename - Specifies the name of the file to be mapped
    ppvData - Points to a variable for returning mapped memory address
    pdwSize - Points to a variable for returning the size of the file

Return Value:

    Handle to identify the mapped file, NULL if there is an error

--*/

{
    HANDLE  hModule = NULL;
    DWORD   dwSize;

    if (hModule = EngLoadModule((PWSTR) ptstrFilename))
    {
        if (*ppvData = EngMapModule(hModule, &dwSize))
        {
            if (pdwSize)
                *pdwSize = dwSize;
        }
        else
        {
            TERSE(("EngMapModule failed: %d\n", GetLastError()));
            EngFreeModule(hModule);
            hModule = NULL;
        }
    }
    else
        ERR(("EngLoadModule failed: %d\n", GetLastError()));

    return (HFILEMAP) hModule;
}



VOID
UnmapFileFromMemory(
    IN HFILEMAP hFileMap
    )

/*++

Routine Description:

    Unmap a file from memory

Arguments:

    hFileMap - Identifies a file previously mapped into memory

Return Value:

    NONE

--*/

{
    ASSERT(hFileMap != NULL);
    EngFreeModule((HANDLE) hFileMap);
}

#else // !KERNEL_MODE


HFILEMAP
MapFileIntoMemory(
    IN LPCTSTR  ptstrFilename,
    OUT PVOID  *ppvData,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Map a file into process memory space.

Arguments:

    ptstrFilename - Specifies the name of the file to be mapped
    ppvData - Points to a variable for returning mapped memory address
    pdwSize - Points to a variable for returning the size of the file

Return Value:

    Handle to identify the mapped file, NULL if there is an error

--*/

{
    HANDLE  hFile, hFileMap;

    //
    // Open a handle to the specified file
    //

    hFile = CreateFile(ptstrFilename,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        TERSE(("CreateFile failed: %d\n", GetLastError()));
        return NULL;
    }


    //
    // Obtain the file size if requested
    //

    if (pdwSize != NULL)
    {
        *pdwSize = GetFileSize(hFile, NULL);

        if (*pdwSize == 0xFFFFFFFF)
        {
            ERR(("GetFileSize failed: %d\n", GetLastError()));
            CloseHandle(hFile);
            return NULL;
        }
    }

    //
    // Map the file into memory
    //

    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFileMap != NULL)
    {
        *ppvData = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(hFileMap);
    }
    else
    {
        ERR(("CreateFileMapping failed: %d\n", GetLastError()));
        *ppvData = NULL;
    }

    //
    // We can safely close both the file mapping object and the file object itself.
    //

    CloseHandle(hFile);

    //
    // The identifier for the mapped file is simply the starting memory address.
    //

    return (HFILEMAP) *ppvData;
}



VOID
UnmapFileFromMemory(
    IN HFILEMAP hFileMap
    )

/*++

Routine Description:

    Unmap a file from memory

Arguments:

    hFileMap - Identifies a file previously mapped into memory

Return Value:

    NONE

--*/

{
    ASSERT(hFileMap != NULL);
    UnmapViewOfFile((PVOID) hFileMap);
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\parser.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    parser.c

Abstract:

    Common functions shared by both PPD and PPD parsers

Environment:

    Windows NT printer drivers

Revision History:

    01/22/97 -davidx-
        Add PtstrGetDefaultTTSubstTable.

    12/03/96 -davidx-
        Check binary file date against all source printer description files.

    08/16/96 -davidx-
        Created it.

--*/

#include "lib.h"



BOOL
BIsRawBinaryDataUpToDate(
    IN PRAWBINARYDATA   pRawData
    )

/*++

Routine Description:

    Check if the raw binary data is up-to-date

Arguments:

    pRawData - pointer to raw binary printer description data

Return Value:

    TRUE if the raw binary data is up-to-date;
    FALSE if the timestamp for any of the source file has changed
    since the binary data was generated.

--*/

{
    //
    // This function is only available in user-mode.
    // It always returns TRUE when called from kernel-mode.
    // Only the KERNEL_MODE define now means render-module
    // and we added the capability of parsing from the render modula

    #if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    return TRUE;

    #else //

    PFILEDATEINFO   pFileDateInfo;
    DWORD           dwCount;
    PTSTR           ptstrFilename;
    HANDLE          hFile;
    FILETIME        FileTime;
    BOOL            bUpToDate = TRUE;

    pFileDateInfo = OFFSET_TO_POINTER(pRawData, pRawData->FileDateInfo.loOffset);

    dwCount = pRawData->FileDateInfo.dwCount;

    ASSERT(dwCount == 0 || pFileDateInfo != NULL);

    while (dwCount-- > 0)
    {
        ptstrFilename = OFFSET_TO_POINTER(pRawData, pFileDateInfo[dwCount].loFileName);

        ASSERT(ptstrFilename != NULL);

        bUpToDate = FALSE;

        hFile  = CreateFile(ptstrFilename,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                            NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (GetFileTime(hFile, NULL, NULL, &FileTime))
                bUpToDate = (CompareFileTime(&FileTime, &pFileDateInfo[dwCount].FileTime) == 0);
            else
                ERR(("GetFileTime '%ws' failed: %d\n", ptstrFilename, GetLastError()));

            CloseHandle(hFile);
        }
        else
            ERR(("CreateFile '%ws' failed: %d\n", ptstrFilename, GetLastError()));
    }

    if (! bUpToDate)
        TERSE(("Raw binary data file is out-of-date.\n"));

    return bUpToDate;

    #endif //!KERNEL_MODE
}



PFEATURE
PGetIndexedFeature(
    PUIINFO pUIInfo,
    DWORD   dwFeatureIndex
    )

/*++

Routine Description:

    Given a UIINFO structure and a feature index, return a pointer to
    the FEATURE structure corresponding to the specified feature.

Arguments:

    pUIInfo - Points to a UIINFO structure
    dwFeatureIndex - Specifies the index of the requested feature

Return Value:

    Pointer to the requested FEATURE, NULL if there is an error

--*/

{
    ASSERT(pUIInfo != NULL);

    if (dwFeatureIndex < pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures)
    {
        return ((PFEATURE) ((PBYTE) pUIInfo->pInfoHeader + pUIInfo->loFeatureList)) +
               dwFeatureIndex;
    } else
        return NULL;
}

POPTION
PGetNamedOption(
    PUIINFO pUIInfo,
    PFEATURE pFeature,
    PCSTR   pstrOptionName,
    PDWORD  pdwOptionIndex
    )

/*++

Routine Description:

    Find the option whose keyword string matches the specified name

Arguments:

    pUIInfo - Points to a UIINFO structure
    pFeature - Points to the feature in question
    pstrOptionName - Specifies the name of the interested option
    pdwOptionIndex - Returns the index of the option found

Return Value:

    Pointer to the OPTION structure whose keyword string matches
    the specified option name; NULL if the specified feature is not found

--*/

{
    POPTION     pOption;
    DWORD       dwIndex, dwOptionCount, dwOptionSize;
    PCSTR       pstrName;

    ASSERT(pFeature);

    dwOptionSize = pFeature->dwOptionSize;
    pOption = PGetIndexedOption(pUIInfo, pFeature, 0);
    dwOptionCount  = pFeature->Options.dwCount;

    if (pOption != NULL && dwOptionCount)
    {
        for (dwIndex=0; dwIndex < dwOptionCount; dwIndex++)
        {
            pstrName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName);
            ASSERT(pstrName != NULL);

            if (pstrName && (strcmp(pstrOptionName, pstrName) == EQUAL_STRING))
            {
                *pdwOptionIndex = dwIndex;
                return (pOption);
            }

            pOption = (POPTION)((PBYTE)pOption + dwOptionSize);
        }
    }

    if (pdwOptionIndex)
        *pdwOptionIndex = OPTION_INDEX_ANY;

    return NULL;
}



PFEATURE
PGetNamedFeature(
    PUIINFO pUIInfo,
    PCSTR   pstrFeatureName,
    PDWORD  pdwFeatureIndex
    )

/*++

Routine Description:

    Find the feature whose keyword string matches the specified name

Arguments:

    pUIInfo - Points to a UIINFO structure
    pstrFeatureName - Specifies the name of the interested feature
    pdwFeatureIndex - Returns the index of the feature found

Return Value:

    Pointer to the FEATURE structure whose keyword string matches
    the specified feature name; NULL if the specified feature is not found

--*/

{
    PFEATURE    pFeature;
    DWORD       dwIndex, dwFeatureCount;
    PCSTR       pstrName;

    pFeature = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->loFeatureList);

    if (pFeature != NULL)
    {
        dwFeatureCount = pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures;

        for (dwIndex=0; dwIndex < dwFeatureCount; dwIndex++, pFeature++)
        {
            pstrName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pFeature->loKeywordName);
            ASSERT(pstrName != NULL);

            if (strcmp(pstrFeatureName, pstrName) == EQUAL_STRING)
            {
                *pdwFeatureIndex = dwIndex;
                return pFeature;
            }
        }
    }

    *pdwFeatureIndex = 0xffffffff;
    return NULL;
}



PVOID
PGetIndexedOption(
    PUIINFO     pUIInfo,
    PFEATURE    pFeature,
    DWORD       dwOptionIndex
    )

/*++

Routine Description:

    Given UIINFO and FEATURE structures and an option index, return a pointer to
    the OPTION structure corresponding to the specified feature option

Arguments:

    pUIInfo - Points to a UIINFO structure
    pFeature - Specifies the feature whose option the caller is interested in
    dwOptionIndex - Specifies the index of the requested option

Return Value:

    Pointer to the request OPTION, NULL if there is an error

--*/

{
    ASSERT(pUIInfo != NULL && pFeature != NULL);

    if (dwOptionIndex < pFeature->Options.dwCount)
    {
        return (PBYTE) pUIInfo->pInfoHeader +
               (pFeature->Options.loOffset + (dwOptionIndex * pFeature->dwOptionSize));
    } else
        return NULL;
}



PVOID
PGetIndexedFeatureOption(
    PUIINFO pUIInfo,
    DWORD   dwFeatureIndex,
    DWORD   dwOptionIndex
    )

/*++

Routine Description:

    Given a UIINFO structure, a feature index, and an option index,
    return a pointer to the OPTION structure corresponding to
    the specified feature option

Arguments:

    pUIInfo - Points to a UIINFO structure
    dwFeatureIndex - Specifies the index of the specified feature
    dwOptionIndex - Specifies the index of the requested option

Return Value:

    Pointer to the request OPTION, NULL if there is an error

--*/

{
    PFEATURE pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex);

    return pFeature ? PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex) : NULL;
}



PPAGESIZE
PGetCustomPageSizeOption(
    PUIINFO pUIInfo
    )

/*++

Routine Description:

    Return a pointer to the PAGESIZE option structure which
    contains custom page size information (e.g. max width and height)

Arguments:

    pUIInfo - Points to UIINFO structure

Return Value:

    See above.

--*/

{
    PFEATURE    pFeature;

    return (SUPPORT_CUSTOMSIZE(pUIInfo) &&
            (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE))) ?
                PGetIndexedOption(pUIInfo, pFeature, pUIInfo->dwCustomSizeOptIndex) : NULL;
}



VOID
VCopyOptionSelections(
    OUT POPTSELECT  pDestOptions,
    IN INT          iDestIndex,
    IN POPTSELECT   pSrcOptions,
    IN INT          iSrcIndex,
    IN OUT PINT     piNext,
    IN INT          iMaxOptions
    )

/*++

Routine Description:

    Copy the current option selections for a single feature from
    the source OPTSELECT array to the destination OPTSELECT array

Arguments:

    pDestOptions - Points to the destination OPTSELECT array
    iDestIndex - Specifies the destination entry in pDestOptions
    pSrcOptions - Points to the source OPTSELECT array
    iSrcIndex - Specifies the source entry in pSrcOptions
    piNext - On input, it contains the index of next available entry
        in pDestOptions if there are more than one option selected.
        On output, it's updated to point to the next available entry
        in pDestOptions after any overflow selections are copied.
    iMaxOptions - Maximum number of entries in pDestOptions

Return Value:

    NONE

--*/

{
    pDestOptions[iDestIndex].ubCurOptIndex = pSrcOptions[iSrcIndex].ubCurOptIndex;

    while ((iSrcIndex = pSrcOptions[iSrcIndex].ubNext) != NULL_OPTSELECT)
    {
        if (*piNext < iMaxOptions)
        {
            INT iLastDestIndex;

            iLastDestIndex = iDestIndex;
            iDestIndex = *piNext;

            pDestOptions[iLastDestIndex].ubNext = (BYTE) iDestIndex;
            pDestOptions[iDestIndex].ubCurOptIndex = pSrcOptions[iSrcIndex].ubCurOptIndex;
        }

        (*piNext)++;
    }

    pDestOptions[iDestIndex].ubNext = NULL_OPTSELECT;
}



//
// 32 bit ANSI X3.66 CRC checksum table - polynomial 0xedb88320
//
// Copyright (C) 1986 Gary S. Brown.  You may use this program, or
// code or tables extracted from it, as desired without restriction.
//

static CONST DWORD Crc32Table[] = {

    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


DWORD
ComputeCrc32Checksum(
    IN PBYTE    pbuf,
    IN DWORD    dwCount,
    IN DWORD    dwChecksum
    )

/*++

Routine Description:

    Compute the 32-bit CRC checksum on a buffer of data

Arguments:

    pbuf - Points to a data buffer
    dwCount - Number of bytes in the data buffer
    dwChecksum - Initial checksum value

Return Value:

    Resulting checksum value

--*/

{
    while (dwCount--)
        dwChecksum = Crc32Table[(dwChecksum ^ *pbuf++) & 0xff] ^ (dwChecksum >> 8);

    return dwChecksum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\utils\regdata.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    regdata.c

Abstract:

    Functions for dealing with registry data

[Environment:]

    Windows NT printer drivers

Revision History:

    02/04/97 -davidx-
        Use REG_MULTI_SZ type where appropriate.

    01/21/97 -davidx-
        Add functions to manipulate MultiSZ strings.

    09/25/96 -davidx-
        Convert to Hungarian notation.

    08/18/96 -davidx-
        Implement GetPrinterProperties.

    08/13/96 -davidx-
        Created it.

--*/

#include "lib.h"



BOOL
BGetPrinterDataDWord(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    OUT PDWORD  pdwValue
    )

/*++

Routine Description:

    Get a DWORD value from the registry under PrinerDriverData key

Arguments:

    hPrinter - Specifies the printer object
    ptstrRegKey - Specifies the name of registry value
    pdwValue - Returns the requested DWORD value in the registry

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwType, dwByteCount, dwStatus;

    dwStatus = GetPrinterData(hPrinter,
                              (PTSTR) ptstrRegKey,
                              &dwType,
                              (PBYTE) pdwValue,
                              sizeof(DWORD),
                              &dwByteCount);

    if (dwStatus != ERROR_SUCCESS)
        VERBOSE(("GetPrinterData failed: %d\n", dwStatus));

    return (dwStatus == ERROR_SUCCESS);
}



PVOID
PvGetPrinterDataBinary(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrSizeKey,
    IN LPCTSTR  ptstrDataKey,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Get binary data from the registry under PrinterDriverData key

Arguments:

    hPrinter - Handle to the printer object
    ptstrSizeKey - Name of the registry value which contains the binary data size
    ptstrDataKey - Name of the registry value which contains the binary data itself
    pdwSize - Points to a variable for receiving the binary data size

Return Value:

    Pointer to the binary printer data read from the registry
    NULL if there is an error

--*/

{
    DWORD   dwType, dwSize, dwByteCount;
    PVOID   pvData = NULL;

    if (GetPrinterData(hPrinter,
                       (PTSTR) ptstrSizeKey,
                       &dwType,
                       (PBYTE) &dwSize,
                       sizeof(dwSize),
                       &dwByteCount) == ERROR_SUCCESS &&
        dwSize > 0 &&
        (pvData = MemAlloc(dwSize)) &&
        GetPrinterData(hPrinter,
                       (PTSTR) ptstrDataKey,
                       &dwType,
                       pvData,
                       dwSize,
                       &dwByteCount) == ERROR_SUCCESS &&
        dwSize == dwByteCount)
    {
        if (pdwSize)
            *pdwSize = dwSize;

        return pvData;
    }

    VERBOSE(("GetPrinterData failed: %ws/%ws\n", ptstrSizeKey, ptstrDataKey));
    MemFree(pvData);
    return NULL;
}



PTSTR
PtstrGetPrinterDataString(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    OUT LPDWORD   pdwSize
    )

/*++

Routine Description:

    Get a string value from PrinerDriverData registry key

Arguments:

    hPrinter - Specifies the printer object
    ptstrRegKey - Specifies the name of registry value
    pdwSize - Specifies the size

Return Value:

    Pointer to the string value read from the registry
    NULL if there is an error

--*/

{
    DWORD   dwType, dwSize, dwStatus;
    PVOID   pvData = NULL;

    dwStatus = GetPrinterData(hPrinter, (PTSTR) ptstrRegKey, &dwType, NULL, 0, &dwSize);

    if ((dwStatus == ERROR_MORE_DATA || dwStatus == ERROR_SUCCESS) &&
        (dwSize > 0) &&
        (dwType == REG_SZ || dwType == REG_MULTI_SZ) &&
        (pvData = MemAlloc(dwSize)) != NULL &&
        (dwStatus = GetPrinterData(hPrinter,
                                   (PTSTR) ptstrRegKey,
                                   &dwType,
                                   pvData,
                                   dwSize,
                                   &dwSize)) == ERROR_SUCCESS)
    {
        if (pdwSize)
            *pdwSize = dwSize;

        return pvData;
    }

    VERBOSE(("GetPrinterData '%ws' failed: %d\n", ptstrRegKey, dwStatus));
    MemFree(pvData);
    return NULL;
}



PTSTR
PtstrGetPrinterDataMultiSZPair(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Get a MULTI_SZ value from PrinerDriverData registry key

Arguments:

    hPrinter - Specifies the printer object
    ptstrRegKey - Specifies the name of registry value
    pdwSize - Return the size of MULTI_SZ value in bytes

Return Value:

    Pointer to the MULTI_SZ value read from the registry
    NULL if there is an error

--*/

{
    DWORD   dwType, dwSize, dwStatus;
    PVOID   pvData = NULL;

    dwStatus = GetPrinterData(hPrinter, (PTSTR) ptstrRegKey, &dwType, NULL, 0, &dwSize);

    if ((dwStatus == ERROR_MORE_DATA || dwStatus == ERROR_SUCCESS) &&
        (dwSize > 0) &&
        (pvData = MemAlloc(dwSize)) != NULL &&
        (dwStatus = GetPrinterData(hPrinter,
                                   (PTSTR) ptstrRegKey,
                                   &dwType,
                                   pvData,
                                   dwSize,
                                   &dwSize)) == ERROR_SUCCESS &&
        BVerifyMultiSZPair(pvData, dwSize))
    {
        if (pdwSize)
            *pdwSize = dwSize;

        return pvData;
    }

    VERBOSE(("GetPrinterData '%ws' failed: %d\n", ptstrRegKey, dwStatus));
    MemFree(pvData);
    return NULL;
}



BOOL
BGetDeviceHalftoneSetup(
    HANDLE      hPrinter,
    DEVHTINFO  *pDevHTInfo
    )

/*++

Routine Description:

    Retrieve device halftone setup information from registry

Arguments:

    hprinter - Handle to the printer
    pDevHTInfo - Pointer to a DEVHTINFO buffer

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   dwType, dwNeeded;

    return GetPrinterData(hPrinter,
                          REGVAL_CURRENT_DEVHTINFO,
                          &dwType,
                          (PBYTE) pDevHTInfo,
                          sizeof(DEVHTINFO),
                          &dwNeeded) == ERROR_SUCCESS &&
           dwNeeded == sizeof(DEVHTINFO);
}



#ifndef KERNEL_MODE

BOOL
BSavePrinterProperties(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData,
    IN  PPRINTERDATA    pPrinterData,
    IN  DWORD           dwSize
    )
/*++

Routine Description:

    Save Printer Properites to registry

Arguments:

    hPrinter - Specifies a handle to the current printer
    pRawData - Points to raw binary printer description data
    pPrinterData - Points to PRINTERDATA
    dwSize   - Specifies the size of PRINTERDATA

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL        bResult = FALSE;
    DWORD       dwKeywordSize, dwFeatureCount = 0;
    PSTR        pstrKeyword;
    POPTSELECT  pCombineOptions;
    PUIINFO     pUIInfo;
    PARSERINFO  ParserInfo;

    ParserInfo.pRawData = NULL;
    ParserInfo.pInfoHeader = NULL;

    if (((pCombineOptions = MemAllocZ(MAX_COMBINED_OPTIONS * sizeof(OPTSELECT))) == NULL) ||
        ((pUIInfo = PGetUIInfo(hPrinter,
                               pRawData,
                               pCombineOptions,
                               pPrinterData->aOptions,
                               &ParserInfo,
                               &dwFeatureCount)) == NULL))
    {
        //
        // We have to fail the function if out of memory, or PGetUIInfo returns NULL (in which
        // case pCombinOptions won't have valid option indices).
        //
        // Make sure free any allocated memory.
        //

        ERR(("pCombinOptions or pUIInfo is NULL\n"));

        if (pCombineOptions)
            MemFree(pCombineOptions);

        return FALSE;
    }

    pstrKeyword = PstrConvertIndexToKeyword(hPrinter,
                                            pPrinterData->aOptions,
                                            &dwKeywordSize,
                                            pUIInfo,
                                            pCombineOptions,
                                            dwFeatureCount);

    VUpdatePrivatePrinterData(hPrinter,
                              pPrinterData,
                              MODE_WRITE,
                              pUIInfo,
                              pCombineOptions
                              );

    if (pstrKeyword)
    {
        bResult = BSetPrinterDataBinary(hPrinter,
                                      REGVAL_PRINTER_DATA_SIZE,
                                      REGVAL_PRINTER_DATA,
                                      pPrinterData,
                                      dwSize) &&
                  BSetPrinterDataBinary(hPrinter,
                                      REGVAL_KEYWORD_SIZE,
                                      REGVAL_KEYWORD_NAME,
                                      pstrKeyword,
                                      dwKeywordSize);
    }

    if (pstrKeyword)
        MemFree(pstrKeyword);

    VFreeParserInfo(&ParserInfo);

    if (pCombineOptions)
        MemFree(pCombineOptions);

    return bResult;
}


BOOL
BSetPrinterDataDWord(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    IN DWORD    dwValue
    )

/*++

Routine Description:

    Save a DWORD value to the registry under PrinerDriverData key

Arguments:

    hPrinter - Specifies the printer object
    ptstrRegKey - Specifies the name of registry value
    dwValue - Specifies the value to be saved

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   dwStatus;

    dwStatus = SetPrinterData(hPrinter,
                              (PTSTR) ptstrRegKey,
                              REG_DWORD,
                              (PBYTE) &dwValue,
                              sizeof(dwValue));

    if (dwStatus != ERROR_SUCCESS)
        ERR(("Couldn't save printer data '%ws': %d\n", ptstrRegKey, dwStatus));

    return (dwStatus == ERROR_SUCCESS);
}



BOOL
BSetPrinterDataBinary(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrSizeKey,
    IN LPCTSTR  ptstrDataKey,
    IN PVOID    pvData,
    IN DWORD    dwSize
    )

/*++

Routine Description:

    Save binary data to the registry under PrinterDriverData key

Arguments:

    hPrinter - Handle to the printer object
    ptstrSizeKey - Name of the registry value which contains the binary data size
    ptstrDataKey - Name of the registry value which contains the binary data itself
    pvData - Points to the binary data to be saved
    dwSize - Specifies the binary data size in bytes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (SetPrinterData(hPrinter,
                       (PTSTR) ptstrSizeKey,
                       REG_DWORD,
                       (PBYTE) &dwSize,
                       sizeof(dwSize)) != ERROR_SUCCESS ||
        SetPrinterData(hPrinter,
                       (PTSTR) ptstrDataKey,
                       REG_BINARY,
                       pvData,
                       dwSize) != ERROR_SUCCESS)
    {
        ERR(("Couldn't save printer data '%ws'/'%ws'\n", ptstrSizeKey, ptstrDataKey));
        return FALSE;
    }

    return TRUE;
}

BOOL
BSetPrinterDataString(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    IN LPCTSTR  ptstrValue,
    IN DWORD    dwType
    )

/*++

Routine Description:

    Save a string value under PrinerDriverData registry key

Arguments:

    hPrinter - Specifies the printer object
    ptstrRegKey - Specifies the name of registry value
    ptstrValue - Points to string value to be saved
    dwType - Specifies string type: REG_SZ or REG_MULTI_SZ

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    If ptstrValue parameter is NULL, the specified registry value is deleted.

--*/

{
    DWORD   dwStatus, dwSize;

    if (ptstrValue != NULL)
    {
        if (dwType == REG_SZ)
            dwSize = SIZE_OF_STRING(ptstrValue);
        else
        {
            LPCTSTR p = ptstrValue;

            while (*p)
                p += _tcslen(p) + 1;

            dwSize = ((DWORD)(p - ptstrValue) + 1) * sizeof(TCHAR);
        }

        dwStatus = SetPrinterData(hPrinter,
                                  (PTSTR) ptstrRegKey,
                                  dwType,
                                  (PBYTE) ptstrValue,
                                  dwSize);

        if (dwStatus != ERROR_SUCCESS)
            ERR(("Couldn't save printer data '%ws': %d\n", ptstrRegKey, dwStatus));
    }
    else
    {
        dwStatus = DeletePrinterData(hPrinter, (PTSTR) ptstrRegKey);

        if (dwStatus == ERROR_FILE_NOT_FOUND)
            dwStatus = ERROR_SUCCESS;

        if (dwStatus != ERROR_SUCCESS)
            ERR(("Couldn't delete printer data '%ws': %d\n", ptstrRegKey, dwStatus));
    }

    return (dwStatus == ERROR_SUCCESS);
}




BOOL
BSetPrinterDataMultiSZPair(
    IN HANDLE   hPrinter,
    IN LPCTSTR  ptstrRegKey,
    IN LPCTSTR  ptstrValue,
    IN DWORD    dwSize
    )

/*++

Routine Description:

    Save a MULTI_SZ value under PrinerDriverData registry key

Arguments:

    hPrinter - Specifies the printer object
    ptstrRegKey - Specifies the name of registry value
    ptstrValue - Points to MULTI_SZ value to be saved
    dwSize - Specifies the size of the MULTI_SZ value in bytes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwStatus;

    ASSERT(BVerifyMultiSZPair(ptstrValue, dwSize));

    dwStatus = SetPrinterData(hPrinter,
                              (PTSTR) ptstrRegKey,
                              REG_MULTI_SZ,
                              (PBYTE) ptstrValue,
                              dwSize);

    if (dwStatus != ERROR_SUCCESS)
        ERR(("Couldn't save printer data '%ws': %d\n", ptstrRegKey, dwStatus));

    return (dwStatus == ERROR_SUCCESS);
}




BOOL
BSaveDeviceHalftoneSetup(
    HANDLE      hPrinter,
    DEVHTINFO  *pDevHTInfo
    )

/*++

Routine Description:

    Save device halftone setup information to registry

Arguments:

    hPrinter - Handle to the printer
    pDevHTInfo - Pointer to device halftone setup information

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    return SetPrinterData(hPrinter,
                          REGVAL_CURRENT_DEVHTINFO,
                          REG_BINARY,
                          (PBYTE) pDevHTInfo,
                          sizeof(DEVHTINFO)) == ERROR_SUCCESS;
}



BOOL
BSaveTTSubstTable(
    IN HANDLE           hPrinter,
    IN TTSUBST_TABLE    pTTSubstTable,
    IN DWORD            dwSize
    )

/*++

Routine Description:

    Save TrueType font substitution table in registry

Arguments:

    hPrinter - Handle to the current printer
    pTTSubstTable - Pointer to font substitution table to be saved
    dwSize - Size of font substitution table, in bytes

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    Previous version pscript driver used to save font substitution table
    as two separate keys: one for size and the other for actual data.
    We only need the data key now. But we should save the size as well
    to be compatible with old drivers.

--*/

{
    return
        BSetPrinterDataMultiSZPair(hPrinter, REGVAL_FONT_SUBST_TABLE, pTTSubstTable, dwSize) &&
        BSetPrinterDataDWord(hPrinter, REGVAL_FONT_SUBST_SIZE_PS40, dwSize);
}



BOOL
BSaveFormTrayTable(
    IN HANDLE           hPrinter,
    IN FORM_TRAY_TABLE  pFormTrayTable,
    IN DWORD            dwSize
    )

/*++

Routine Description:

    Save form-to-tray assignment table in registry

Arguments:

    hPrinter - Handle to the current printer
    pFormTrayTable - Pointer to the form-to-tray assignment table to be saved
    dwSize - Size of the form-to-tray assignment table, in bytes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Save the table in current format and then call driver-specific
    // functions to save the information in NT 4.0 format.
    //

    return
        (BSaveAsOldVersionFormTrayTable(hPrinter, pFormTrayTable, dwSize));
}

#endif // !KERNEL_MODE



FORM_TRAY_TABLE
PGetFormTrayTable(
    IN HANDLE   hPrinter,
    OUT PDWORD  pdwSize
    )

/*++

Routine Description:

    Retrieve form-to-tray assignment table from registry

Arguments:

    hPrinter - Handle to the printer object
    pdwSize - Returns the form-to-tray assignment table size

Return Value:

    Pointer to form-to-tray assignment table read from the registry
    NULL if there is an error

--*/

{
    FORM_TRAY_TABLE pFormTrayTable;
    DWORD           dwSize;

    //
    // Call either PSGetFormTrayTable or UniGetFormTrayTable
    //

    pFormTrayTable = PGetAndConvertOldVersionFormTrayTable(hPrinter, &dwSize);

    if (pFormTrayTable != NULL && pdwSize != NULL)
        *pdwSize = dwSize;

    return pFormTrayTable;
}



BOOL
BSearchFormTrayTable(
    IN FORM_TRAY_TABLE      pFormTrayTable,
    IN PTSTR                ptstrTrayName,
    IN PTSTR                ptstrFormName,
    IN OUT PFINDFORMTRAY    pFindData
    )

/*++

Routine Description:

    Find the specified tray-form pair in a form-to-tray assignment table

Arguments:

    pFormTrayTable - Specifies a form-to-tray assignment table to be searched
    ptstrTrayName - Specifies the interested tray name
    ptstrFormName - Specifies the interested form name
    pFindData - Data structure used to keep information from one call to the next

Return Value:

    TRUE if the specified tray-form pair is found in the table
    FALSE otherwise

NOTE:

    If either ptstrTrayName or ptstrFormName is NULL, they'll act as wildcard and
    match any tray name or form name.

    The caller must call ResetFindFormTray(pFormTrayTable, pFindData) before
    calling this function for the very first time.

--*/

{
    PTSTR   ptstrNextEntry;
    BOOL    bFound = FALSE;

    //
    // Make sure pFindData is properly initialized
    //

    ASSERT(pFindData->pvSignature == pFindData);
    ptstrNextEntry = pFindData->ptstrNextEntry;

    while (*ptstrNextEntry)
    {
        PTSTR   ptstrTrayField, ptstrFormField, ptstrPrinterFormField;

        //
        // Extract information from the current table entry
        //

        ptstrTrayField = ptstrNextEntry;
        ptstrNextEntry += _tcslen(ptstrNextEntry) + 1;

        ptstrFormField = ptstrNextEntry;
        ptstrNextEntry += _tcslen(ptstrNextEntry) + 1;

        //
        // Check if we found a matching entry
        //

        if ((ptstrTrayName == NULL || _tcscmp(ptstrTrayName, ptstrTrayField) == EQUAL_STRING) &&
            (ptstrFormName == NULL || _tcscmp(ptstrFormName, ptstrFormField) == EQUAL_STRING))
        {
            pFindData->ptstrTrayName = ptstrTrayField;
            pFindData->ptstrFormName = ptstrFormField;

            bFound = TRUE;
            break;
        }
    }

    pFindData->ptstrNextEntry = ptstrNextEntry;
    return bFound;
}



BOOL
BGetPrinterProperties(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData
    )

/*++

Routine Description:

    Return the current printer-sticky property data

Arguments:

    hPrinter - Specifies a handle to the current printer
    pRawData - Points to raw binary printer description data
    pPrinterData - Buffer for storing the retrieved printer property info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PVOID   pvRegData;
    PSTR    pstrKeyword;
    DWORD   dwRegDataSize, dwKeywordSize, dwFeatureCount, dwVersion;
    POPTSELECT  pCombineOptions;
    PUIINFO     pUIInfo;
    PARSERINFO  ParserInfo;

    //
    // Allocate a buffer to hold printer property data and
    // read the property property data from the registry.
    //

    if (pvRegData = PvGetPrinterDataBinary(hPrinter,
                                           REGVAL_PRINTER_DATA_SIZE,
                                           REGVAL_PRINTER_DATA,
                                           &dwRegDataSize))
    {
        //
        // Convert the printer property data from the registry to current version
        //

        ZeroMemory(pPrinterData, sizeof(PRINTERDATA));
        CopyMemory(pPrinterData, pvRegData, min(sizeof(PRINTERDATA), dwRegDataSize));

        pPrinterData->wDriverVersion = gwDriverVersion;
        pPrinterData->wSize = sizeof(PRINTERDATA);

        if (pPrinterData->wReserved2 != 0 ||
            pPrinterData->dwChecksum32 != pRawData->dwChecksum32)
        {
            InitDefaultOptions(pRawData,
                            pPrinterData->aOptions,
                            MAX_PRINTER_OPTIONS,
                            MODE_PRINTER_STICKY);

            pPrinterData->wReserved2 = 0;
            pPrinterData->dwChecksum32 = pRawData->dwChecksum32;
            pPrinterData->dwOptions = pRawData->dwPrinterFeatures;

            pPrinterData->wProtocol = PROTOCOL_ASCII;
            pPrinterData->dwFlags |= PFLAGS_CTRLD_AFTER;
            pPrinterData->wMinoutlinePPEM = DEFAULT_MINOUTLINEPPEM;
            pPrinterData->wMaxbitmapPPEM = DEFAULT_MAXBITMAPPPEM;
        }

        //
        // Call driver-specific conversion to give them a chance to touch up
        //

        (VOID) BConvertPrinterPropertiesData(hPrinter,
                                             pRawData,
                                             pPrinterData,
                                             pvRegData,
                                             dwRegDataSize);
    }
    else
    {
        if (!BGetDefaultPrinterProperties(hPrinter, pRawData, pPrinterData))
            return FALSE;
    }

    //
    // At this point we should get a valid PrinterData or a
    // default PrinterData.  Propagate Feature.Options to
    // PrinterData options array if possible
    //

    ParserInfo.pRawData = NULL;
    ParserInfo.pInfoHeader = NULL;

    if (((pCombineOptions = MemAllocZ(MAX_COMBINED_OPTIONS * sizeof(OPTSELECT))) == NULL) ||
        ((pUIInfo = PGetUIInfo(hPrinter,
                               pRawData,
                               pCombineOptions,
                               pPrinterData->aOptions,
                               &ParserInfo,
                               &dwFeatureCount)) == NULL))
    {
        //
        // We have to fail the function if out of memory, or PGetUIInfo returns NULL (in which
        // case pCombinOptions won't have valid option indices).
        //
        // Make sure free any allocated memory.
        //

        ERR(("pCombinOptions or pUIInfo is NULL\n"));

        if (pvRegData)
            MemFree(pvRegData);

        if (pCombineOptions)
            MemFree(pCombineOptions);

        return FALSE;
    }


    //
    // set the ADD_EURO flag if it has not intentionally been set to FALSE
    //
    if (pUIInfo)
    {
        if (!(pPrinterData->dwFlags & PFLAGS_EURO_SET))
        {
            if (pUIInfo->dwFlags & FLAG_ADD_EURO)
                pPrinterData->dwFlags |= PFLAGS_ADD_EURO;
            pPrinterData->dwFlags |= PFLAGS_EURO_SET;
        }
    }

    VUpdatePrivatePrinterData(hPrinter,
                              pPrinterData,
                              MODE_READ,
                              pUIInfo,
                              pCombineOptions);

    if ((pstrKeyword = PvGetPrinterDataBinary(hPrinter,
                                              REGVAL_KEYWORD_SIZE,
                                              REGVAL_KEYWORD_NAME,
                                              &dwKeywordSize)) &&
        dwKeywordSize)
    {

        //
        // Skip merging in the keyword feature.option if the driver version
        // is less than version 3. This is so point and print to OS version less
        // than NT5 will work. REGVAL_PRINTER_INITED exists only for version 3
        // or greater driver
        //

        if (!BGetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, &dwVersion))
            *pstrKeyword = NUL;

        //
        // Convert feature.option keyword names to option indices
        //

        VConvertKeywordToIndex(hPrinter,
                               pstrKeyword,
                               dwKeywordSize,
                               pPrinterData->aOptions,
                               pRawData,
                               pUIInfo,
                               pCombineOptions,
                               dwFeatureCount);

        MemFree(pstrKeyword);
    }
    else
    {
        SeparateOptionArray(pRawData,
                            pCombineOptions,
                            pPrinterData->aOptions,
                            MAX_PRINTER_OPTIONS,
                            MODE_PRINTER_STICKY);

    }

    VFreeParserInfo(&ParserInfo);

    if (pCombineOptions)
        MemFree(pCombineOptions);

    if (pvRegData)
        MemFree(pvRegData);

    return TRUE;
}



BOOL
BGetDefaultPrinterProperties(
    IN HANDLE           hPrinter,
    IN PRAWBINARYDATA   pRawData,
    OUT PPRINTERDATA    pPrinterData
    )

/*++

Routine Description:

    Return the default printer-sticky property data

Arguments:

    hPrinter - Specifies a handle to the current printer
    pRawData - Points to raw binary printer description data
    pPrinterData - Buffer for storing the default printer property info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PINFOHEADER     pInfoHdr;
    PUIINFO         pUIInfo;

    //
    // Allocate memory to hold the default printer property data
    //

    ASSERT(pPrinterData && pRawData);
    ZeroMemory(pPrinterData, sizeof(PRINTERDATA));

    pPrinterData->wDriverVersion = gwDriverVersion;
    pPrinterData->wSize = sizeof(PRINTERDATA);

    //
    // Get default printer-sticky option values
    //

    InitDefaultOptions(pRawData,
                       pPrinterData->aOptions,
                       MAX_PRINTER_OPTIONS,
                       MODE_PRINTER_STICKY);

    pPrinterData->dwChecksum32 = pRawData->dwChecksum32;
    pPrinterData->dwOptions = pRawData->dwPrinterFeatures;

    //
    // Ask the parser for a new binary data instance and
    // use it to initialize the remaining fields of PRINTERDATA.
    //

    if (pInfoHdr = InitBinaryData(pRawData, NULL, NULL))
    {
        pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr);

        ASSERT(pUIInfo != NULL);

        pPrinterData->dwFreeMem = pUIInfo->dwFreeMem;
        pPrinterData->dwWaitTimeout = pUIInfo->dwWaitTimeout;
        pPrinterData->dwJobTimeout = pUIInfo->dwJobTimeout;

        if (pUIInfo->dwFlags & FLAG_TRUE_GRAY)      // transfer the default into printer-sticky data
            pPrinterData->dwFlags |= (PFLAGS_TRUE_GRAY_TEXT | PFLAGS_TRUE_GRAY_GRAPH);

        FreeBinaryData(pInfoHdr);
    }

    //
    // Initialize any remaining fields
    //

    pPrinterData->wProtocol = PROTOCOL_ASCII;
    pPrinterData->dwFlags |= PFLAGS_CTRLD_AFTER;
    pPrinterData->wMinoutlinePPEM = DEFAULT_MINOUTLINEPPEM;
    pPrinterData->wMaxbitmapPPEM = DEFAULT_MAXBITMAPPPEM;

    #ifndef KERNEL_MODE

    //
    // Determine whether the system is running in a metric country.
    //

    if (IsMetricCountry())
        pPrinterData->dwFlags |= PFLAGS_METRIC;

    //
    // Ignore device fonts on non-1252 code page systems.
    //
    // NOTE: Adobe wants this to be turned off for NT4 driver.
    // For NT5 driver, we need to investigate and make sure
    // this doesn't break anything before turning this off.
    // Specifically, watch out for NT4-client to NT5 server
    // connection case.
    //
    // Fix MS bug #121883, Adobe bug #235417
    //

    #if 0
    #ifndef WINNT_40

    if (GetACP() != 1252)
        pPrinterData->dwFlags |= PFLAGS_IGNORE_DEVFONT;

    #endif // !WINNT_40
    #endif

    #endif // !KERNEL_MODE

    return TRUE;
}



LPCTSTR
PtstrSearchDependentFileWithExtension(
    LPCTSTR ptstrDependentFiles,
    LPCTSTR ptstrExtension
    )

/*++

Routine Description:

    Search the list of dependent files (in REG_MULTI_SZ format)
    for a file with the specified extension

Arguments:

    ptstrDependentFiles - Points to the list of dependent files
    ptstrExtension - Specifies the interested filename extension

Return Value:

    Points to the first filename in the dependent file list
    with the specified extension

--*/

{
    if (ptstrDependentFiles == NULL)
    {
        WARNING(("Driver dependent file list is NULL\n"));
        return NULL;
    }

    while (*ptstrDependentFiles != NUL)
    {
        LPCTSTR ptstr, ptstrNext;

        //
        // Go the end of current string
        //

        ptstr = ptstrDependentFiles + _tcslen(ptstrDependentFiles);
        ptstrNext = ptstr + 1;

        //
        // Search backward for '.' character
        //

        while (--ptstr >= ptstrDependentFiles)
        {
            if (*ptstr == TEXT('.'))
            {
                //
                // If the extension matches, return a pointer to
                // the current string
                //

                if (_tcsicmp(ptstr, ptstrExtension) == EQUAL_STRING)
                    return ptstrDependentFiles;

                break;
            }
        }

        ptstrDependentFiles = ptstrNext;
    }

    return NULL;
}



PTSTR
PtstrGetDriverDirectory(
    LPCTSTR ptstrDriverDllPath
    )

/*++

Routine Description:

    Figure out printer driver directory from the driver DLL's full pathname

Arguments:

    ptstrDriverDllPath - Driver DLL's full pathname

Return Value:

    Pointer to the printer driver directory string
    NULL if there is an error

    The returned directory contains a trailing backslash.
    Caller is responsible for freeing the returned string.

--*/

{
    PTSTR   ptstr;
    INT     iLength;

    ASSERT(ptstrDriverDllPath != NULL);

    if ((ptstr = _tcsrchr(ptstrDriverDllPath, TEXT(PATH_SEPARATOR))) != NULL)
        iLength = (INT)(ptstr - ptstrDriverDllPath) + 1;
    else
    {
        WARNING(("Driver DLL path is not fully qualified: %ws\n", ptstrDriverDllPath));
        iLength = 0;
    }

    if ((ptstr = MemAlloc((iLength + 1) * sizeof(TCHAR))) != NULL)
    {
        CopyMemory(ptstr, ptstrDriverDllPath, iLength * sizeof(TCHAR));
        ptstr[iLength] = NUL;
    }
    else
        ERR(("Memory allocation failed\n"));

    return ptstr;
}



LPCTSTR
PtstrSearchStringInMultiSZPair(
    LPCTSTR ptstrMultiSZ,
    LPCTSTR ptstrKey
    )

/*++

Routine Description:

    Search for the specified key in MultiSZ key-value string pairs

Arguments:

    ptstrMultiSZ - Points to the data to be searched
    ptstrKey - Specifies the key string

Return Value:

    Pointer to the value string corresponding to the specified
    key string; NULL if the specified key string is not found

--*/

{
    ASSERT(ptstrMultiSZ != NULL);

    while (*ptstrMultiSZ != NUL)
    {
        //
        // If the current string matches the specified key string,
        // then return the corresponding value string
        //

        if (_tcsicmp(ptstrMultiSZ, ptstrKey) == EQUAL_STRING)
            return ptstrMultiSZ + _tcslen(ptstrMultiSZ) + 1;

        //
        // Otherwise, advance to the next string pair
        //

        ptstrMultiSZ += _tcslen(ptstrMultiSZ) + 1;
        ptstrMultiSZ += _tcslen(ptstrMultiSZ) + 1;
    }

    return NULL;
}



BOOL
BVerifyMultiSZPair(
    LPCTSTR ptstrData,
    DWORD   dwSize
    )

/*++

Routine Description:

    Verify the input data block is in REG_MULTI_SZ format and
    it consists of multiple string pairs

Arguments:

    ptstrData - Points to the data to be verified
    dwSize - Size of the data block in bytes

Return Value:

    NONE

--*/

{
    LPCTSTR ptstrEnd;

    //
    // Size must be even
    //

    ASSERTMSG(dwSize % sizeof(TCHAR) == 0, ("Size is not even: %d\n", dwSize));
    dwSize /= sizeof(TCHAR);

    //
    // Go through one string pair during each iteration
    //

    ptstrEnd = ptstrData + dwSize;

    while (ptstrData < ptstrEnd && *ptstrData != NUL)
    {
        while (ptstrData < ptstrEnd && *ptstrData++ != NUL)
            NULL;

        if (ptstrData >= ptstrEnd)
        {
            ERR(("Corrupted MultiSZ pair\n"));
            return FALSE;
        }

        while (ptstrData < ptstrEnd && *ptstrData++ != NUL)
            NULL;

        if (ptstrData >= ptstrEnd)
        {
            ERR(("Corrupted MultiSZ pair\n"));
            return FALSE;
        }
    }

    //
    // Look for the last terminating NUL character
    //

    if (ptstrData++ >= ptstrEnd)
    {
        ERR(("Missing the last NUL terminator\n"));
        return FALSE;
    }

    if (ptstrData < ptstrEnd)
    {
        ERR(("Redundant data after the last NUL terminator\n"));
    }

    return TRUE;
}


BOOL
BVerifyMultiSZ(
    LPCTSTR ptstrData,
    DWORD   dwSize
    )

/*++

Routine Description:

    Verify the input data block is in REG_MULTI_SZ format

Arguments:

    ptstrData - Points to the data to be verified
    dwSize - Size of the data block in bytes

Return Value:

    NONE

--*/

{
    LPCTSTR ptstrEnd;

    //
    // Size must be even
    //

    ASSERTMSG(dwSize % sizeof(TCHAR) == 0, ("Size is not even: %d\n", dwSize));
    dwSize /= sizeof(TCHAR);

    ptstrEnd = ptstrData + dwSize;

    while (ptstrData < ptstrEnd && *ptstrData != NUL)
    {
        while (ptstrData < ptstrEnd && *ptstrData++ != NUL)
            NULL;

        if (ptstrData >= ptstrEnd)
        {
            ERR(("Corrupted MultiSZ pair\n"));
            return FALSE;
        }
    }

    //
    // Look for the last terminating NUL character
    //

    if (ptstrData++ >= ptstrEnd)
    {
        ERR(("Missing the last NUL terminator\n"));
        return FALSE;
    }

    if (ptstrData < ptstrEnd)
    {
        ERR(("Redundant data after the last NUL terminator\n"));
    }

    return TRUE;
}

DWORD
DwCountStringsInMultiSZ(
    IN LPCTSTR ptstrData
    )
{
    DWORD dwCount = 0;

    if (ptstrData)
    {
        while (*ptstrData)
        {
            dwCount++;
            ptstrData += wcslen(ptstrData);
            ptstrData++;
        }
    }

    return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\algndjmp.c ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    algndjmp.c

Abstract:

    This file wraps around setjmp/longjmp functions to fix up alignment 
    problems created by UFL memory management.

Author:

    Larry Zhu   (LZhu)                11-Apr-2001    Created

Environment:

    User Mode -Win32

Revision History:

--*/

#include "algndjmp.h"

//
// Don't EVER copy jmp_buf when returning from longjmp, because at the time 
// when it returns from longjmp, stack variable PS_AlignedJmpBuf maybe is 
// totaly trashed!
//
// Don't EVER try to call setjmp in this function, because that will change
// the stack when setjmp is called, hence return address and stack pointer
// registers etc.
//
void 
PS_CopyJmpBuf(
    IN     int     iSetjmpRetVal, 
       OUT jmp_buf envDest, 
    IN     jmp_buf envSrc
    )
{
    if (!iSetjmpRetVal) 
    {
        (void)memcpy(envDest, envSrc, sizeof(jmp_buf));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\algndjmp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation
All rights reserved

Module Name:

    algndjmp.h

Abstract:

    This file wraps around setjmp/longjmp functions to fix up alignment 
    problems created by UFL memory management.

Author:

    Larry Zhu   (LZhu)                11-Apr-2001    Created

Environment:

    User Mode -Win32

Revision History:

--*/
#ifndef _ALGNDJMP_H_
#define _ALGNDJMP_H_

#include <setjmp.h>

#define IN
#define OUT
 
#ifndef _M_IX86

void 
PS_CopyJmpBuf(
    IN     int     iSetjmpRetVal, 
       OUT jmp_buf envDest, 
    IN     jmp_buf envSrc
    );
 
#define DEFINE_ALIGN_SETJMP_VAR jmp_buf PS_AlignedJmpBuf; int iSetjmpRetVal
#define SETJMP(x)               (iSetjmpRetVal = setjmp(PS_AlignedJmpBuf), (void)PS_CopyJmpBuf(iSetjmpRetVal, (x), PS_AlignedJmpBuf), iSetjmpRetVal)
#define LONGJMP(x,y)            do { (void)memcpy(PS_AlignedJmpBuf, (x), sizeof(jmp_buf)); (void)longjmp(PS_AlignedJmpBuf, (y)); } while (0)
 
#else
 
#define DEFINE_ALIGN_SETJMP_VAR
#define SETJMP(x)               setjmp(x)
#define LONGJMP(x,y)            longjmp((x), (y))

#endif

#endif // #ifndef _ALGNDJMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_base.h ===
/* @(#)CM_VerSion xcf_base.h atm09 1.2 16499.eco sum= 64660 atm09.002 */
/* @(#)CM_VerSion xcf_base.h atm08 1.4 16293.eco sum= 04404 atm08.004 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1995-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

#ifndef XCF_BASE_H
#define XCF_BASE_H

#include <stddef.h>

#include "xcf_win.h"    /* set/define Windows dependent configuration */
#include <strsafe.h>

#ifndef PTR_PREFIX
#define PTR_PREFIX
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if 0
#ifndef _SIZE_T
typedef unsigned int size_t;
#define _SIZE_T
#endif
#endif

#ifndef NULL
#define NULL    ((void PTR_PREFIX *)0)
#endif

/* Basic Types */
#ifndef PUBLICTYPES_H   /* the following are already defined in publictypes.h */
typedef unsigned char Card8;
typedef unsigned short int Card16;
typedef unsigned long int Card32;
typedef unsigned CardX;
typedef char Int8;
typedef short int Int16;
typedef long int Int32;
typedef int IntX;

typedef unsigned int boolean;
#endif                  /* end ifndef PUBLICTYPES_H */

#ifndef true
#define true 1
#endif
#ifndef false
#define false 0
#endif

/* Inline Functions */
#ifndef ABS
#define ABS(x) ((x)<0?-(x):(x))
#endif
#ifndef MIN
#define MIN(a,b) ((a)<(b)?(a):(b))
#endif
#ifndef MAX
#define MAX(a,b) ((a)>(b)?(a):(b))
#endif

//
// Count of characters
//
#define CCHOF(x) (sizeof(x)/sizeof(*(x)))

#ifdef __cplusplus
}
#endif

#endif /* XCF_BASE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_cstr.c ===
/* @(#)CM_VerSion xcf_cstr.c atm09 1.2 16499.eco sum= 34614 atm09.002 */
/* @(#)CM_VerSion xcf_cstr.c atm08 1.6 16345.eco sum= 33712 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1995 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/



/* If Init fails you are done. If any other function fails you must call clean up */ 


#ifndef XCF_DUMP
	#include "xcf_priv.h"
#else
	#include <stdio.h>
	#ifndef _SIZE_T
		#define _SIZE_T /* so size_t isn't redefined here */
		#include "xcf_priv.h"
		#undef _SIZE_T
	#else
		#include "xcf_priv.h"
	#endif
#endif

#ifdef T13
#include "xcf_t13.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct                  /* Individual charstring record */
{
  unsigned short length;
  char *cstr;
} Charstring;

typedef struct                  /* Transitional char record */
{
  StringID sid;                        
  Charstring cstr;
} TransChar;

static void FlattenSubr(XCF_Handle h, unsigned int depth, boolean PTR_PREFIX
													 *endcharFound, boolean localSubr);

static void WriteT1Data(XCF_Handle h, Card8 *pData, CardX length, boolean subr)
{
CardX i;
	if (subr)
		for (i=0;i<length;++i)
			*da_NEXT(h->type1.subrs) = *pData++;
	else
		for (i=0;i<length;++i)
			*da_NEXT(h->type1.charStrs) = *pData++;
}

void XC_WriteT1OpCode(XCF_Handle h, Card16 opCode, boolean subr)
{
	Card8 output[2] = {tx_escape};
	output[1] = (Card8) OpCode(opCode);
	if (IsEscOp(opCode))
		WriteT1Data(h, output, 2, subr);
	else
		WriteT1Data(h, output + 1, 1, subr);
}

static void NewT1CharStr(XCF_Handle h)
{
	if (CIDFONT)
  {
    if ((h->options.outputCharstrType != 2) && (h->dict.fontType != 1))
  		h->type1.charStrs.cnt = 0;
  }
	else
  {
		*da_NEXT(h->type1.charStrOffsets) = h->type1.charStrs.cnt;
  }
}

static void FreeT1CharStr(XCF_Handle h)
{
	h->type1.charStrs.cnt = 0;
	h->type1.charStrOffsets.cnt = 0;
	*da_NEXT(h->type1.charStrOffsets) = 0;
}

#if 0
static void FreeT1Subr(XCF_Handle h)
{
	h->type1.subrs.cnt = 0;
	h->type1.subrOffsets.cnt = 0;
	*da_NEXT(h->type1.subrOffsets) = 0;
}
#endif

static void NewT1Subr(XCF_Handle h)
{
	if (h->type1.subrs.cnt)
		XC_WriteT1OpCode(h, tx_return, true);
		
	*da_NEXT(h->type1.subrOffsets) = h->type1.subrs.cnt;
}

/* Encode Int32 number and return length */
static Card16 IntToCharstr(Int32 i, Card8 PTR_PREFIX *t)
	{
	if (-107 <= i && i <= 107)
		{
		/* Single byte number */
		t[0] = (Card8)(i + 139);
		t[1] = '\0';
		return 1;
		}
	else if (108 <= i && i <= 1131)
		{
		/* +ve 2-byte number */
		i -= 108;
		t[0] = (Card8)((i>>8) + 247);
		t[1] = (Card8) i;
		t[2] = '\0';
		return 2;
		}
	else if (-1131 <= i && i <= -108)
		{
		/* -ve 2-byte number */
		i += 108;
		t[0] = (Card8)((-i>>8) + 251);
		t[1] = (Card8) -i;
		t[2] = '\0';
		return 2;
		}
	else
		{
		/* 5-byte fixed point */
		t[0] = 255;
		t[1] = (Card8) (i>>24 & 0x0ff);
		t[2] = (Card8) (i>>16 & 0x0ff);
		t[3] = (Card8) (i>>8 & 0x0ff);
		t[4] = (Card8) (i & 0x0ff);
		t[5] = '\0';
		return 5;
		}
	}

/*
	Convert a fixed point number into a charstring of the form "int int div".
	The second int in the charstring passed in is the "denominator".
*/
static Card16 ConvertFixedDiv(Fixed f, Card8 PTR_PREFIX *t, Int32 denominator)
{
	Int32 numerator;
	Card16 length;
	boolean negative = false;

	if (f < 0)
	{
		negative = true;
		f = -f;
	}

	/* 
	Multiply by denominator and round to nearest integer.
	Process upper and lower 16 bits seperately to avoid overflow.
	*/

	numerator = (f >> 16) * denominator;
	numerator += (((f & 0x0000ffff) * denominator) + 0x08000) >> 16;

	if (negative)
		numerator = -numerator;

	length = IntToCharstr(numerator, t);
	length += IntToCharstr(denominator, t+length);
	t[length] = (Card8) tx_escape;
	t[length+1] = (Card8) OpCode(tx_div);
	t[length+2] = '\0';
	return length+2;
}

/* 
Calculates how close to zero or one the fractional part of
a fixed point number is after it is multiplied by the integer
passed in "denominator".
*/
static Card32 CalculateTolerance(Fixed f, Card32 denominator)
{
	Card32 tolerance;

	if (f < 0)	/* Force number to be positive */
		f = -f;
  /* multiply and truncate integer part (leaving fractional part) */
	tolerance = (f * denominator) & 0x0000ffff;
	if (tolerance > 0x08000) /* If greater than 0.5 then use 1 - tolerance */
		tolerance = 0x10000 - tolerance;
	return (tolerance); 
}

#define DIV_MIN_TOLERANCE 64	/* 64/65536 = ~0.001 */

/* Encode 16.16 fixed point number and return length */

static Card16 FixedToCharstr(Fixed f, Card8 PTR_PREFIX *t)
{
	Int32 denominator, bestDenominator;
	Int32 tolerance, bestTolerance;

	/* If integer then convert to "int" format and return */	
	if (!(f & 0x0000ffff))
			return IntToCharstr(f>>16, t);

	/* Otherwise it's a fraction so convert to "int int div" format */
	
	/* Try common cases 10 and 100 first */
	if (CalculateTolerance(f, 10) < DIV_MIN_TOLERANCE)
		return (ConvertFixedDiv(f, t, 10));
	else if (CalculateTolerance(f, 100) < DIV_MIN_TOLERANCE)
		return (ConvertFixedDiv(f, t, 100));

	/* 
	Try all cases between 2 and 199. This can be slow 
	but it should only run all the way through if no
	close match is found. This will never happen for
	known fonts. If it does happen then the closest 
	match between 2 and 199 will be used.
	*/

	bestDenominator = 1;
	bestTolerance = 0x0ffff;
	for (denominator=2; denominator < 200; ++denominator)
	{
		tolerance = CalculateTolerance(f, denominator);
		if (tolerance < DIV_MIN_TOLERANCE)
			return (ConvertFixedDiv(f, t, denominator));
		else if (tolerance < bestTolerance) 
		{
			bestTolerance = tolerance;
			bestDenominator = denominator;
		}
	}
	return (ConvertFixedDiv(f, t, bestDenominator));
}

static void WriteFixed(XCF_Handle h, Fixed f, boolean subr)
{
	Card8 str[30];
	Card16 length;

	length = FixedToCharstr(f, str);

	if (length == 0)
		XCF_FATAL_ERROR(h, XCF_InvalidNumber, "FixedToCharstr failed.", 0 );
	else
		WriteT1Data(h, str, length, subr);
}

void XC_WriteT1PStackValue(XCF_Handle h, PStackValue psv, boolean subr)
{
	IntX i;
	Fixed initialValue = INT_TO_FIXED(0);

	if (!psv->blend)
	{
		WriteFixed(h, psv->value[0], subr);
	}
	else
	{
		WriteFixed(h, psv->value[0], subr);
		initialValue = psv->value[0];
		for (i=1; i<h->dict.numberOfMasters; ++i)
		{
			WriteFixed(h, psv->value[i] - initialValue, subr);
		}
	WriteFixed(h, INT_TO_FIXED(6), subr);
	XC_WriteT1OpCode(h, tx_callsubr, subr);
	}
}


/* StackValue Manipulation Routines */

#define NEXTSTACKVALUE(p, offset, svSize) (PStackValue)(p+offset); \
                                           offset += svSize;

static void NewStackValues(XCF_Handle h, void PTR_PREFIX * PTR_PREFIX *p,
                           Card32 cStackValues, Card16 PTR_PREFIX *svSize)
{
	Card16 totalSize;

	/* Allocate the data space for all the stack values that we need */
	*svSize = SIZEOF_STACK_VALUES((h->dict.numberOfMasters) ? h->dict.numberOfMasters : 1);
	totalSize = (Card16)(*svSize * cStackValues);

  *p = 0;
	if (!h->callbacks.allocate(p, totalSize, h->callbacks.allocateHook))
		XCF_FATAL_ERROR(h, XCF_MemoryAllocationError, "StackValue Allocation Failure.", totalSize);
	h->callbacks.memset((void PTR_PREFIX *)*p, 0, totalSize);
}

static PStackValue IntToPSV(void PTR_PREFIX *psv, Int32 i)
{
	((PShortStackValue)psv)->blend = false;
	((PShortStackValue)psv)->value = INT_TO_FIXED(i);
	return (PStackValue)psv;
}

static void FixedToPSV(void PTR_PREFIX *psv, Fixed f)
{
	((PShortStackValue)psv)->blend = false;
	((PShortStackValue)psv)->value = f;
}

static void PSVFixedAdd(XCF_Handle h, PStackValue psv, Fixed f)
{
	IntX i;

	if (psv->blend)
		for (i = 0; i < h->dict.numberOfMasters; ++i)
			psv->value[i] += f;
	else
		psv->value[0] += f;
}

static void PSVCopy(XCF_Handle h, PStackValue pdest, PStackValue psrc)
{
	IntX i;

	if (pdest != psrc)
	{
		pdest->blend = psrc->blend;
		if (psrc->blend)
			for (i=0; i < h->dict.numberOfMasters; ++i)
				pdest->value[i] = psrc->value[i];
		else
			pdest->value[0] = psrc->value[0];
	}
}

static void PSVFixedSubtract(XCF_Handle h, PStackValue psv, Fixed f)
{
	IntX i;

	if (psv->blend)
		for (i = 0; i < h->dict.numberOfMasters; ++i)
			psv->value[i] -= f;
	else
		psv->value[0] -= f;
}

static void FixedPSVSubtract(XCF_Handle h, PStackValue psv, Fixed f)
{
	IntX i;

	if (psv->blend)
		for (i = 0; i < h->dict.numberOfMasters; ++i)
			psv->value[i] = f - psv->value[i];
	else
		psv->value[0] = f - psv->value[0];
}

static void PSVRealAdd(XCF_Handle h, PStackValue psv, Fixed d)
{
	IntX i;

	if (psv->blend)
		for (i = 0; i < h->dict.numberOfMasters; ++i)
			psv->value[i] += d;
	else
		psv->value[0] += d;
}

/* psvDest cannot equal psv1 or psv2! */
static void PStackValueAdd(XCF_Handle h, PStackValue psvDest, PStackValue psv1, PStackValue psv2)
{
	IntX i;

	if (!psv1->blend)
	{
		PSVCopy(h,psvDest, psv2);
		PSVFixedAdd(h, psvDest, psv1->value[0]);
	}
	else if (!psv2->blend)
	{
		PSVCopy(h,psvDest, psv1);
		PSVFixedAdd(h, psvDest, psv2->value[0]);
	}
	else
	{
		PSVCopy(h,psvDest, psv1);
		for (i = 0; i < h->dict.numberOfMasters; ++i)
			psvDest->value[i] += psv2->value[i];
	}
}

#define PSVAdd(h, psvDest, psv1, psv2)	((!h->dict.numberOfMasters)?FixedToPSV(psvDest, (psv1)->value[0]+(psv2)->value[0]): PStackValueAdd(h, psvDest, psv1, psv2))

/* psvDest cannot equal psv1 or psv2! */
static void PSVSubtract(XCF_Handle h, PStackValue psvDest, PStackValue psv1, PStackValue psv2)
{
	IntX i;

	if (!psv1->blend) 
	{
		PSVCopy(h,psvDest, psv2);
		FixedPSVSubtract(h, psvDest, psv1->value[0]);
	}
	else if (!psv2->blend) 
	{
		PSVCopy(h,psvDest, psv1);
		PSVFixedSubtract(h, psvDest, psv2->value[0]);
	}
	else
	{
		PSVCopy(h,psvDest, psv1);
		for (i = 0; i < h->dict.numberOfMasters; ++i)
			psvDest->value[i] -= psv2->value[i];
	}
}

static void PStackValueAdd4(XCF_Handle h, PStackValue psvDest, PStackValue psv1, PStackValue psv2, PStackValue psv3, PStackValue psv4)
{
  StackValue temp1, temp2;

  PStackValueAdd(h, &temp1, psv1, psv2);
  PStackValueAdd(h, &temp2, &temp1, psv3);
  PStackValueAdd(h, psvDest, &temp2, psv4);
}

#define PSVAdd4(h, psvDest, psv1, psv2, psv3, psv4)	((!h->dict.numberOfMasters)?FixedToPSV(psvDest, (psv1)->value[0]+(psv2)->value[0]+(psv3)->value[0]+(psv4)->value[0]): PStackValueAdd4(h, psvDest, psv1, psv2, psv3, psv4))

static void PSVAdd5(XCF_Handle h, PStackValue psvDest, PStackValue psv1, PStackValue psv2, PStackValue psv3, PStackValue psv4, PStackValue psv5)
{
  StackValue temp;

	PSVAdd4(h,&temp,psv1,psv2,psv3,psv4);
	PStackValueAdd(h,psvDest,&temp,psv5);
}

static void PSVAdd7(XCF_Handle h, PStackValue psvDest, PStackValue psv1, PStackValue psv2, PStackValue psv3, PStackValue psv4, PStackValue psv5, PStackValue psv6, PStackValue psv7)
{
  StackValue temp;

	PSVAdd4(h,&temp,psv1,psv2,psv3,psv4);
	PSVAdd4(h,psvDest,&temp,psv5,psv6,psv7);
}

/***************************************************/


/************************** Basic Operations ******************************/

static void Hsbw(XCF_Handle h, PStackValue psbx, PStackValue pwx, boolean subr)
{
	XC_WriteT1PStackValue(h, psbx, subr);
	XC_WriteT1PStackValue(h, pwx, subr);
	XC_WriteT1OpCode(h, t1_hsbw, subr);

#ifdef XCF_DUMP
	printf("%g %g <hsbw> ", FIXED_TO_REAL(psbx->value[0]), FIXED_TO_REAL(pwx->value[0]));
#endif
}

static void RMoveTo(XCF_Handle h, PStackValue pdx, PStackValue pdy, boolean subr)
{
  StackValue temp;

	if ((!pdx->blend) && (pdx->value[0] == 0))
	{
		XC_WriteT1PStackValue(h, pdy, subr);
		XC_WriteT1OpCode(h, tx_vmoveto, subr);
	}
	else if ((!pdy->blend) && (pdy->value[0] == 0))
	{
		XC_WriteT1PStackValue(h, pdx, subr);
		XC_WriteT1OpCode(h, tx_hmoveto, subr);
	}
	else
	{
		XC_WriteT1PStackValue(h, pdx, subr);
		XC_WriteT1PStackValue(h, pdy, subr);
		XC_WriteT1OpCode(h, tx_rmoveto, subr);
	}
  PSVCopy(h, &temp, h->cstr.x);
	PSVAdd(h, h->cstr.x, &temp, pdx);
  PSVCopy(h, &temp, h->cstr.y);
	PSVAdd(h, h->cstr.y, &temp, pdy);

#ifdef XCF_DUMP
	printf("%g %g <rmoveto> ", FIXED_TO_REAL(pdx->value[0]), FIXED_TO_REAL(pdy->value[0]));
#endif
}

static void RLineTo(XCF_Handle h, PStackValue pdx, PStackValue pdy, boolean subr)
{
  StackValue temp;

	if ((!pdx->blend) && (pdx->value[0] == 0))
	{
		XC_WriteT1PStackValue(h, pdy, subr);
		XC_WriteT1OpCode(h, tx_vlineto, subr);
	}
	else if ((!pdy->blend) && (pdy->value[0] == 0))
	{
		XC_WriteT1PStackValue(h, pdx, subr);
		XC_WriteT1OpCode(h, tx_hlineto, subr);
	}
	else
	{
		XC_WriteT1PStackValue(h, pdx, subr);
		XC_WriteT1PStackValue(h, pdy, subr);
		XC_WriteT1OpCode(h, tx_rlineto, subr);
	}
  PSVCopy(h, &temp, h->cstr.x);
	PSVAdd(h, h->cstr.x, &temp, pdx);
  PSVCopy(h, &temp, h->cstr.y);
	PSVAdd(h, h->cstr.y, &temp, pdy);

#ifdef XCF_DUMP
	printf("%g %g <rlineto> ", FIXED_TO_REAL(pdx->value[0]), FIXED_TO_REAL(pdy->value[0]));
#endif
}

static void RRCurveTo(XCF_Handle h, PStackValue pdx1, PStackValue pdy1,
											PStackValue pdx2, PStackValue pdy2, PStackValue pdx3,
											PStackValue pdy3, boolean subr)
{
  StackValue temp;

	if ( ((!pdy1->blend) && (pdy1->value[0] == 0)) && ((!pdx3->blend) && (pdx3->value[0] == 0)))
	{
		XC_WriteT1PStackValue(h, pdx1, subr);
		XC_WriteT1PStackValue(h, pdx2, subr);
		XC_WriteT1PStackValue(h, pdy2, subr);
		XC_WriteT1PStackValue(h, pdy3, subr);
		XC_WriteT1OpCode(h, tx_hvcurveto, subr);
	}
	else if ( ((!pdx1->blend) && (pdx1->value[0] == 0)) && ((!pdy3->blend) && (pdy3->value[0] == 0)))
	{
		XC_WriteT1PStackValue(h, pdy1, subr);
		XC_WriteT1PStackValue(h, pdx2, subr);
		XC_WriteT1PStackValue(h, pdy2, subr);
		XC_WriteT1PStackValue(h, pdx3, subr);
		XC_WriteT1OpCode(h, tx_vhcurveto, subr);
	}
	else
	{
		XC_WriteT1PStackValue(h, pdx1, subr);
		XC_WriteT1PStackValue(h, pdy1, subr);
		XC_WriteT1PStackValue(h, pdx2, subr);
		XC_WriteT1PStackValue(h, pdy2, subr);
		XC_WriteT1PStackValue(h, pdx3, subr);
		XC_WriteT1PStackValue(h, pdy3, subr);
		XC_WriteT1OpCode(h, tx_rrcurveto, subr);
	}
  PSVCopy(h, &temp, h->cstr.x);
	PSVAdd4(h, h->cstr.x, &temp, pdx1, pdx2, pdx3);
  PSVCopy(h, &temp, h->cstr.y);
	PSVAdd4(h, h->cstr.y, &temp, pdy1, pdy2, pdy3);

#ifdef XCF_DUMP
	printf("%g %g %g %g %g %g <rrcurveto> ", FIXED_TO_REAL(pdx1->value[0]), FIXED_TO_REAL(pdy1->value[0]), FIXED_TO_REAL(pdx2->value[0]), FIXED_TO_REAL(pdy2->value[0]), FIXED_TO_REAL(pdx3->value[0]), FIXED_TO_REAL(pdy3->value[0]));
#endif
}

static void Seac(XCF_Handle h, PStackValue pasb, PStackValue padx, PStackValue
								 pady, PStackValue pbchar, PStackValue pachar, boolean subr)
{
	h->cstr.baseSeac = FIXED_TO_INT(pbchar->value[0]);
	h->cstr.accentSeac = FIXED_TO_INT(pachar->value[0]);

	XC_WriteT1PStackValue(h, pasb, subr);
	XC_WriteT1PStackValue(h, padx, subr);
	XC_WriteT1PStackValue(h, pady, subr);
	XC_WriteT1PStackValue(h, pbchar, subr);
	XC_WriteT1PStackValue(h, pachar, subr);
	XC_WriteT1OpCode(h, t1_seac, subr);
}

static void DotSection(XCF_Handle h, boolean subr)
{
	XC_WriteT1OpCode(h, tx_dotsection, subr);

#ifdef XCF_DUMP
	printf("<dotsection> ");
#endif
}

static void WriteFlexCoordinate(XCF_Handle h, PStackValue pdx, PStackValue pdy,
																boolean subr)
{
	ShortStackValue	temp;

	if ((!pdx->blend) && (pdx->value[0] == 0))
	{
		XC_WriteT1PStackValue(h, pdy, subr);
		XC_WriteT1OpCode(h, tx_vmoveto, subr);
	}
	else if ((!pdy->blend) && (pdy->value[0] == 0))
	{
		XC_WriteT1PStackValue(h, pdx, subr);
		XC_WriteT1OpCode(h, tx_hmoveto, subr);
	}
	else
	{
		XC_WriteT1PStackValue(h, pdx, subr);
		XC_WriteT1PStackValue(h, pdy, subr);
		XC_WriteT1OpCode(h, tx_rmoveto, subr);
	}

	XC_WriteT1PStackValue(h, IntToPSV(&temp, 2), subr);
	XC_WriteT1OpCode(h, tx_callsubr, subr);
}

static void Flex(
				XCF_Handle h,
				PStackValue pdx1, 
				PStackValue pdy1,
				PStackValue pdx2, 
				PStackValue pdy2,
				PStackValue pdx3, 
				PStackValue pdy3,
				PStackValue pdx4, 
				PStackValue pdy4,
				PStackValue pdx5, 
				PStackValue pdy5,
				PStackValue pdx6, 
				PStackValue pdy6,
				PStackValue pdx7, 
				PStackValue pdy7,
				PStackValue pflexHeight,
				PStackValue pendpointX,
				PStackValue pendpointY,
        boolean subr)
{
	
	ShortStackValue temp;

	XC_WriteT1PStackValue(h, IntToPSV(&temp, 1), subr);
	XC_WriteT1OpCode(h, tx_callsubr, subr);
	WriteFlexCoordinate(h, pdx1, pdy1, subr);
	WriteFlexCoordinate(h, pdx2, pdy2, subr);
	WriteFlexCoordinate(h, pdx3, pdy3, subr);
	WriteFlexCoordinate(h, pdx4, pdy4, subr);
	WriteFlexCoordinate(h, pdx5, pdy5, subr);
	WriteFlexCoordinate(h, pdx6, pdy6, subr);
	WriteFlexCoordinate(h, pdx7, pdy7, subr);
	XC_WriteT1PStackValue(h, pflexHeight, subr);
	XC_WriteT1PStackValue(h, pendpointX, subr);
	XC_WriteT1PStackValue(h, pendpointY, subr);
	XC_WriteT1PStackValue(h, PSTACKVALUE(h, SV0), subr);
	XC_WriteT1OpCode(h, tx_callsubr, subr);
		
	PSVCopy(h, h->cstr.x, pendpointX);
	PSVCopy(h, h->cstr.y, pendpointY);

#ifdef XCF_DUMP
	printf("<flex> ");
#endif
}

static void HStem(XCF_Handle h, PStackValue py, PStackValue pdy, boolean subr)
{
	boolean hintSub = ((!CIDFONT) && (h->cstr.subrFlatten == 0) &&
                     (h->cstr.hints	== SubrHints)) || subr;

	XC_WriteT1PStackValue(h, py, hintSub);
	XC_WriteT1PStackValue(h, pdy, hintSub);
	XC_WriteT1OpCode(h, tx_hstem, hintSub);
	h->cstr.waitingForFirstHint = false;

#ifdef XCF_DUMP
	printf("%g %g <hstem> ", FIXED_TO_REAL(py->value[0]), FIXED_TO_REAL(pdy->value[0]));
#endif
}

static void VStem(XCF_Handle h, PStackValue px, PStackValue pdx, boolean subr)
{
	boolean hintSub = ((!CIDFONT) && (h->cstr.subrFlatten == 0) &&
                     (h->cstr.hints	== SubrHints)) || subr;

	XC_WriteT1PStackValue(h, px, hintSub);
	XC_WriteT1PStackValue(h, pdx, hintSub);
	XC_WriteT1OpCode(h, tx_vstem, hintSub);
	h->cstr.waitingForFirstHint = false;

#ifdef XCF_DUMP
	printf("%g %g <vstem> ", FIXED_TO_REAL(px->value[0]), FIXED_TO_REAL(pdx->value[0]));
#endif
}

static void HStem3(XCF_Handle h, PStackValue py0, PStackValue pdy0, PStackValue
									 py1, PStackValue pdy1, PStackValue py2, PStackValue pdy2,
									 boolean subr)
{
	boolean hintSub = ((!CIDFONT) && (h->cstr.subrFlatten == 0) &&
                     (h->cstr.hints	== SubrHints)) || subr;

	XC_WriteT1PStackValue(h, py0, hintSub);
	XC_WriteT1PStackValue(h, pdy0, hintSub);
	XC_WriteT1PStackValue(h, py1, hintSub);
	XC_WriteT1PStackValue(h, pdy1, hintSub);
	XC_WriteT1PStackValue(h, py2, hintSub);
	XC_WriteT1PStackValue(h, pdy2, hintSub);
	XC_WriteT1OpCode(h, t1_hstem3, hintSub);
	h->cstr.waitingForFirstHint = false;

#ifdef XCF_DUMP
	printf("%g %g %g %g %g %g <hstem3> ", FIXED_TO_REAL(py0->value[0]), FIXED_TO_REAL(pdy0->value[0]), FIXED_TO_REAL(py1->value[0]), FIXED_TO_REAL(pdy1->value[0]), FIXED_TO_REAL(py2->value[0]), FIXED_TO_REAL(pdy2->value[0]));
#endif
}

static void VStem3(XCF_Handle h, PStackValue px0, PStackValue pdx0, PStackValue
									 px1, PStackValue pdx1, PStackValue px2, PStackValue pdx2,
									 boolean subr)
{
	boolean hintSub = ((!CIDFONT) && (h->cstr.subrFlatten == 0) &&
                     (h->cstr.hints	== SubrHints)) || subr;

	XC_WriteT1PStackValue(h, px0, hintSub);
	XC_WriteT1PStackValue(h, pdx0, hintSub);
	XC_WriteT1PStackValue(h, px1, hintSub);
	XC_WriteT1PStackValue(h, pdx1, hintSub);
	XC_WriteT1PStackValue(h, px2, hintSub);
	XC_WriteT1PStackValue(h, pdx2, hintSub);
	XC_WriteT1OpCode(h, t1_vstem3, hintSub);
	h->cstr.waitingForFirstHint = false;

#ifdef XCF_DUMP
	printf("%g %g %g %g %g %g <vstem3> ", FIXED_TO_REAL(px0->value[0]), FIXED_TO_REAL(pdx0->value[0]), FIXED_TO_REAL(px1->value[0]), FIXED_TO_REAL(pdx1->value[0]), FIXED_TO_REAL(px2->value[0]), FIXED_TO_REAL(pdx2->value[0]));
#endif
}

static void ClosePath(XCF_Handle h, boolean subr)
{
	XC_WriteT1OpCode(h, t1_closepath, subr);

#ifdef XCF_DUMP
	printf("<closepath> ");
#endif
}


static void EndChar(XCF_Handle h, boolean subr)
{
	XC_WriteT1OpCode(h, tx_endchar, subr);

#ifdef XCF_DUMP
	printf("<endchar> \n\n");
#endif
}


static void StartHintSub(XCF_Handle h, boolean subr)
{
	ShortStackValue	temp;

	if (CIDFONT)
	{
		XC_WriteT1PStackValue(h, IntToPSV(&temp, 4), subr);
		XC_WriteT1OpCode(h, tx_callsubr, subr);
	}
	else
	{
    if (!h->cstr.subrFlatten)
    	XC_WriteT1PStackValue(h, IntToPSV(&temp, h->type1.subrOffsets.cnt), subr);
  	XC_WriteT1PStackValue(h, IntToPSV(&temp, 4), subr);
    XC_WriteT1OpCode(h, tx_callsubr, subr);
    if (!h->cstr.subrFlatten)
  		NewT1Subr(h);
	}

#ifdef XCF_DUMP
	printf("[HINT SUB] ");
#endif
}

/*************************** End Basic Operations **************************/

static void WriteReversedCounterArg(XCF_Handle h, PStackValue parg, boolean subr)
{
	IntX argIndex;
	ShortStackValue	temp;

	if (h->cstr.counterBufferCount < 22)	
		PSVCopy(h, h->cstr.counterBuffer[h->cstr.counterBufferCount++], parg);
	else
	{
		for (argIndex = 21; argIndex >= 0; --argIndex)
			XC_WriteT1PStackValue(h, h->cstr.counterBuffer[argIndex], subr);
		XC_WriteT1PStackValue(h, IntToPSV(&temp, 22), subr);
		XC_WriteT1PStackValue(h, IntToPSV(&temp, 12), subr);
		XC_WriteT1OpCode(h, t1_callother, subr);
		PSVCopy(h, h->cstr.counterBuffer[0], parg);
		h->cstr.counterBufferCount = 1;
	}
}

static void FlushReversedCounterArgs(XCF_Handle h, boolean subr)
{
	IntX argIndex;
	ShortStackValue temp;

	if (!h->cstr.counterBufferCount)
		return;
	for (argIndex = h->cstr.counterBufferCount-1; argIndex >= 0; --argIndex)
		XC_WriteT1PStackValue(h, h->cstr.counterBuffer[argIndex], subr);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, h->cstr.counterBufferCount), subr);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 13), subr);
	XC_WriteT1OpCode(h, t1_callother, subr);
}

/* This structure is defined to store the temporary counterGroup info. */
typedef struct {
  StackValue edge;
  StackValue delta;
  Card16 opCode;
  Card32 counterGroups;
} CounterValue;

static void NewCounterValues(XCF_Handle h, void PTR_PREFIX * PTR_PREFIX *p)
{
  if ( *p == 0 )
  {
    Card16 totalSize;

    /* Allocate the data space for all the counter values that we need */
    totalSize = (Card16)(sizeof(CounterValue) * MAX_HINTS);

    if (!h->callbacks.allocate(p, totalSize, h->callbacks.allocateHook))
	    XCF_FATAL_ERROR(h, XCF_MemoryAllocationError, "CounterValue Allocation Failure.", totalSize);

    h->callbacks.memset((void PTR_PREFIX *)*p, 0, totalSize);
  }
}

static void WriteHorVCounters(XCF_Handle h, Card16 opCode, CardX groupCount,
															boolean subr)
{
	CardX		hintIndex;
	CardX		groupIndex;
	IntX		argIndex;
	CounterValue	*counterGroup;
	CardX		counterGroupCount;
	StackValue	currentEdge;
	StackValue	nextEdge;
  StackValue temp;
	boolean		firstStem;

  /* Make sure that we allocate memory for our temp CounterValue. */
  NewCounterValues(h, (void PTR_PREFIX * PTR_PREFIX *)&h->cstr.pCounterVal);

  counterGroup = (CounterValue *)h->cstr.pCounterVal;

	for (groupIndex = groupCount; groupIndex > 0; --groupIndex)
  {   /* loop backwards through groups */
		IntToPSV(&currentEdge, 0);
		counterGroupCount = 0;
		/* Gather stems into array */
		for (hintIndex=0;hintIndex<h->cstr.hintCount;++hintIndex)
		{
			if ((h->cstr.hintMap[hintIndex].opCode == opCode) && (h->cstr.hintMap[hintIndex].counterGroups & (1 << (groupIndex - 1))))
			{
        /* Copy stem */
        PSVCopy(h, &counterGroup[counterGroupCount].edge,
								h->cstr.hintMap[hintIndex].edge);
        PSVCopy(h, &counterGroup[counterGroupCount].delta,
								h->cstr.hintMap[hintIndex].delta);
        counterGroup[counterGroupCount].opCode =
					h->cstr.hintMap[hintIndex].opCode;
        counterGroup[counterGroupCount].counterGroups =
					h->cstr.hintMap[hintIndex].counterGroups;

        /* Find trailing edge for next delta. */
				PSVAdd(h, &nextEdge, &counterGroup[counterGroupCount].edge,
							 &counterGroup[counterGroupCount].delta);
        PSVCopy(h, &temp, &counterGroup[counterGroupCount].edge);
				PSVSubtract(h, &counterGroup[counterGroupCount].edge, &temp, &currentEdge); /* turn leading edge into delta */
				PSVCopy(h, &currentEdge, &nextEdge); /* save trailing edge calculate delta for next stem */
				++counterGroupCount;
			}

		}
		/* write out stems backwards */

		firstStem = true;
		for (argIndex = counterGroupCount-1; argIndex >= 0; --argIndex)
		{
			if (firstStem)
			{
				IntToPSV(&temp, 0);
				PSVSubtract(h, &currentEdge, &temp, &counterGroup[argIndex].delta);
				WriteReversedCounterArg(h, &currentEdge, subr);
				PSVAdd(h, &currentEdge, &counterGroup[argIndex].edge, &counterGroup[argIndex].delta);
				WriteReversedCounterArg(h, &currentEdge, subr);
				firstStem = false;
			}
			else
			{
				WriteReversedCounterArg(h, &counterGroup[argIndex].delta, subr);
				WriteReversedCounterArg(h, &counterGroup[argIndex].edge, subr);
			}
		}
	}
	WriteReversedCounterArg(h, IntToPSV(&currentEdge, groupCount), subr);
}


static void WriteCounters(XCF_Handle h, boolean subr)
{
	h->cstr.counterBufferCount = 0; /* Clear counter buffer */
	WriteHorVCounters(h, tx_vstem, h->cstr.counterGroupVCount, subr);
	WriteHorVCounters(h, tx_hstem, h->cstr.counterGroupHCount, subr);
	FlushReversedCounterArgs(h, subr);
}

static void WriteHints(XCF_Handle h, boolean all, boolean subr)
{
	Card16 hintIndex;
	Card8 currentByte;
	Card8 currentBit = 0;
	HintValue hstem3Args[3];
	HintValue vstem3Args[3];
	Card8 hstem3ArgCount = 0;
	Card8 vstem3ArgCount = 0;

	for (hintIndex=0;hintIndex<h->cstr.hintCount;++hintIndex)
	{
		if ((!all) && (!currentBit))
		{
			currentByte = *h->inBuffer.pos++;
			currentBit = 0x080;
		}
		if ((all) || (currentByte & currentBit))
		{
			/* cstr.languageGroup is set for each charstring in xcf_cff.c/ProcessCharStrings. */
			if ((h->cstr.hintMap[hintIndex].counterGroups) && (h->cstr.languageGroup == 0))
			{
				if (h->cstr.hintMap[hintIndex].opCode == tx_hstem)
				{
					if (hstem3ArgCount >= 3)
						XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Too many counters for hstem3", hstem3ArgCount );
					hstem3Args[hstem3ArgCount++] = h->cstr.hintMap[hintIndex];
				}
				else
				{
					if (vstem3ArgCount >= 3)
						XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Too many counters for vstem3", vstem3ArgCount );
					vstem3Args[vstem3ArgCount++] = h->cstr.hintMap[hintIndex];
				}
			}
			else
			{
				if (h->cstr.hintMap[hintIndex].opCode == tx_hstem)
					HStem(h, h->cstr.hintMap[hintIndex].edge,
								h->cstr.hintMap[hintIndex].delta, subr);
				else
					VStem(h, h->cstr.hintMap[hintIndex].edge,
								h->cstr.hintMap[hintIndex].delta, subr);
			}
		}
		currentBit = currentBit>>1;
	}
	if (hstem3ArgCount == 3)
		HStem3(h, hstem3Args[0].edge, hstem3Args[0].delta, hstem3Args[1].edge,
					 hstem3Args[1].delta, hstem3Args[2].edge, hstem3Args[2].delta, subr);
	else if (hstem3ArgCount == 1)
		HStem(h, hstem3Args[0].edge, hstem3Args[0].delta, subr);
	else if (hstem3ArgCount == 2)
	{
		HStem(h, hstem3Args[0].edge, hstem3Args[0].delta, subr);
		HStem(h, hstem3Args[1].edge, hstem3Args[1].delta, subr);
	}
	else if (hstem3ArgCount > 3)
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "hstem3 argument count is greater than 3", hstem3ArgCount );


	if (vstem3ArgCount == 3)
		VStem3(h, vstem3Args[0].edge, vstem3Args[0].delta, vstem3Args[1].edge,
					 vstem3Args[1].delta, vstem3Args[2].edge, vstem3Args[2].delta, subr);
	else if (vstem3ArgCount == 1)
		VStem(h, vstem3Args[0].edge, vstem3Args[0].delta, subr);
	else if (vstem3ArgCount == 2)
	{
		VStem(h, vstem3Args[0].edge, vstem3Args[0].delta, subr);
		VStem(h, vstem3Args[1].edge, vstem3Args[1].delta, subr);
	}
	else if (vstem3ArgCount > 3)
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "vstem3 argument count is greater than 3", vstem3ArgCount );
}

static void StateChange(XCF_Handle h, 
						enum PenStateTransition penTran, 
						enum HintStateTransition hintTran, 
						boolean triggerHsbw,
						unsigned int expectedArgumentCount,
            boolean subr)
{
	Card16 stackIndex;
	StackValue svx;

	switch (penTran)
	{
	case ToPenUp :
		if (h->cstr.pen == PenDown)
			ClosePath(h, subr);
		h->cstr.pen = PenUp;
		break;
	case ToPenDown :
		if (h->cstr.pen == PenNull)
		{
      /* Make sure all contours start with a move */
			RMoveTo(h, PSTACKVALUE(h, SV0), PSTACKVALUE(h, SV0), subr);
		}
		h->cstr.pen = PenDown;
		break;
	case NoPenEffect :
		break;
	}
	switch (hintTran)
	{
	case ToNotInHints :
		if (h->cstr.hints == InitialHints)
		{
			if ((h->cstr.languageGroup != 0)  && (h->cstr.counterGroupCount))
				WriteCounters(h, subr);
			WriteHints(h, true, subr);
		}
		h->cstr.hints = NotInHints;
		break;
	case ToInitialHints :
		h->cstr.hints = InitialHints;
		break;
	case ToSubrHints :
		h->cstr.hints = SubrHints;
		break;
	case NoHintEffect :
		break;
	}
	if (h->cstr.waitingForHsbw && triggerHsbw)
	{
		h->cstr.waitingForHsbw = false;
		if (h->cstr.stackTop <= expectedArgumentCount) 
		{
      /* Currently, subr is true only when processing a transitional
         design character. These characters have the hsbw defined in
         their charstring and therefore hsbw should not be included
         in the subr definition.
       */
      if (!subr)
      {
        FixedToPSV(&svx, h->dict.defaultWidthX);
			  Hsbw(h, PSTACKVALUE(h, SV0), &svx, subr);
      }
		}
		else
		{
			PSVCopy(h, &svx, h->cstr.stack[0]);
			PSVRealAdd(h, &svx, h->dict.nominalWidthX);
			Hsbw(h, PSTACKVALUE(h, SV0), &svx, subr);
			if (h->cstr.stackTop < 1)
				XCF_FATAL_ERROR(h, XCF_StackUnderflow, "Stack Underflow In hsbw ", h->cstr.stackTop );
			for (stackIndex = 0; stackIndex<h->cstr.stackTop-1; ++stackIndex)
         /* remove first item and shift stack */
				PSVCopy(h, h->cstr.stack[stackIndex], h->cstr.stack[stackIndex+1]);
			--h->cstr.stackTop;
		}
	}
}


static void AddToHintMap(XCF_Handle h, Card16 opCode)
{
	StackValue y;
	StackValue dy;
  StackValue temp;
	Card16 opIndex;
	Card16 index = 0;

	IntToPSV(&temp, 0);
	for (opIndex=1;opIndex<=h->cstr.stackTop/2;++opIndex)
	{
		if (h->cstr.hintCount == MAX_HINTS)
			XCF_FATAL_ERROR(h, XCF_HintOverflow, "Hint Overflow", h->cstr.hintCount);

    
		PSVAdd(h, &y, &temp, h->cstr.stack[index++]);
		PSVCopy(h, &dy, h->cstr.stack[index++]);
		PSVCopy(h, h->cstr.hintMap[h->cstr.hintCount].edge, &y);
		PSVCopy(h, h->cstr.hintMap[h->cstr.hintCount].delta, &dy);
		h->cstr.hintMap[h->cstr.hintCount].opCode = opCode;
		h->cstr.hintMap[h->cstr.hintCount].counterGroups = 0;
    PSVCopy(h, &temp, &y);
		PSVAdd(h, &y, &temp, &dy);
    PSVCopy(h, &temp, &y);
		++h->cstr.hintCount;
	}
}

void XC_WriteHMoveTo(XCF_Handle h, boolean subr)
{
	StateChange(h, ToPenUp, ToNotInHints, true, 1, subr);
	RMoveTo(h, h->cstr.stack[0], PSTACKVALUE(h, SV0), subr);
}

void XC_WriteVMoveTo(XCF_Handle h, boolean subr)
{
	StateChange(h, ToPenUp, ToNotInHints, true, 1, subr);
	RMoveTo(h, PSTACKVALUE(h,SV0), h->cstr.stack[0], subr);
}

void XC_WriteRMoveTo(XCF_Handle h, boolean subr)
{
	StateChange(h, ToPenUp, ToNotInHints, true, 2, subr);
	RMoveTo(h, h->cstr.stack[0], h->cstr.stack[1], subr);
}

void XC_WriteRLineTo(XCF_Handle h, boolean subr)
{
	Card16 stackIndex = 0;
	Card16 opIndex;
	Card16 repeatCount = h->cstr.stackTop/2;
	
	StateChange(h, ToPenDown, ToNotInHints, false, 0, subr);
	for (opIndex=1;opIndex<=repeatCount;++opIndex)
	{
		RLineTo(h, h->cstr.stack[stackIndex], h->cstr.stack[stackIndex+1], subr);
		stackIndex += 2;
	}
}

void XC_WriteHLineToAndVLineTo(XCF_Handle h, boolean hLine, boolean subr)
{
	Card16 opIndex;

	StateChange(h, ToPenDown, ToNotInHints, false, 0, subr);
	for (opIndex=1;opIndex<=h->cstr.stackTop;++opIndex)
	{
		if (hLine)
			RLineTo(h, h->cstr.stack[opIndex-1], PSTACKVALUE(h, SV0), subr);
		else
			RLineTo(h, PSTACKVALUE(h, SV0), h->cstr.stack[opIndex-1], subr);
		hLine = !hLine;
	}
}

static void WriteSingleRRCurveTo(XCF_Handle h, 
						  PStackValue pdx1, 
						  PStackValue pdy1,
						  PStackValue pdx2, 
						  PStackValue pdy2,
						  PStackValue pdx3, 
						  PStackValue pdy3,
              boolean subr)
{
	StateChange(h, ToPenDown, ToNotInHints, false, 0, subr);
	RRCurveTo(h, pdx1, pdy1, pdx2, pdy2, pdx3, pdy3, subr);
}

void XC_WriteRRCurveTo(XCF_Handle h, boolean subr)
{
	Card16 stackIndex = 0;
	Card16 opIndex;
	Card16 repeatCount = h->cstr.stackTop/6;
	
	for (opIndex=1;opIndex<=repeatCount;++opIndex)
	{
		WriteSingleRRCurveTo(h,
			h->cstr.stack[stackIndex], 
			h->cstr.stack[stackIndex+1], 
			h->cstr.stack[stackIndex+2], 
			h->cstr.stack[stackIndex+3], 
			h->cstr.stack[stackIndex+4], 
			h->cstr.stack[stackIndex+5],
      subr);
		stackIndex+=6;
	}
}

void XC_WriteEndChar(XCF_Handle h, boolean subr)
{
	if (h->cstr.stackTop >= 4)
	{
		StateChange(h, NoPenEffect, NoHintEffect, true, 4, subr);
		Seac(h,
			PSTACKVALUE(h, SV0), 
			h->cstr.stack[0], 
			h->cstr.stack[1], 
			h->cstr.stack[2], 
			h->cstr.stack[3],
      subr);
	}
	else
	{
		StateChange(h, ToPenUp, ToNotInHints, true, 0, subr);
		if (h->cstr.stackTop == 0)
			EndChar(h, subr);
		else
			XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Arguments Left On Stack At endchar ", h->cstr.stackTop );
	}
}

void XC_WriteRCurveLine(XCF_Handle h, boolean subr)
{
	Card16 stackIndex = 0;

	while (stackIndex + 2 < h->cstr.stackTop)
	{
		WriteSingleRRCurveTo(h,
			h->cstr.stack[stackIndex], 
			h->cstr.stack[stackIndex+1], 
			h->cstr.stack[stackIndex+2], 
			h->cstr.stack[stackIndex+3], 
			h->cstr.stack[stackIndex+4], 
			h->cstr.stack[stackIndex+5],
      subr);
		stackIndex+=6;
	}

	if (stackIndex + 2 <= h->cstr.stackTop)
	{
		RLineTo(h, h->cstr.stack[stackIndex], h->cstr.stack[stackIndex+1], subr);
	}
}

void XC_WriteRLineCurve(XCF_Handle h, boolean subr)
{
	Card16 stackIndex = 0;

	StateChange(h, ToPenDown, ToNotInHints, false, 0, subr);
	while (stackIndex + 6 < h->cstr.stackTop)
	{
		RLineTo(h, h->cstr.stack[stackIndex], h->cstr.stack[stackIndex+1], subr);
		stackIndex += 2;
	}
	if (stackIndex + 6 <= h->cstr.stackTop)
		WriteSingleRRCurveTo(h,
			h->cstr.stack[stackIndex], 
			h->cstr.stack[stackIndex+1], 
			h->cstr.stack[stackIndex+2], 
			h->cstr.stack[stackIndex+3], 
			h->cstr.stack[stackIndex+4], 
			h->cstr.stack[stackIndex+5],
      subr);

}

void XC_WriteVVCurveTo(XCF_Handle h, boolean subr)
{
	Card16 stackIndex = 0;

	if (h->cstr.stackTop & 0x01)	/* If odd number of arguments */
	{
		WriteSingleRRCurveTo(h,
			h->cstr.stack[0], 
			h->cstr.stack[1], 
			h->cstr.stack[2], 
			h->cstr.stack[3], 
			PSTACKVALUE(h, SV0), 
			h->cstr.stack[4],
      subr);
		stackIndex = 5;
	}

	while (stackIndex + 4 <= h->cstr.stackTop)
	{
		WriteSingleRRCurveTo(h,
			PSTACKVALUE(h, SV0), 
			h->cstr.stack[stackIndex], 
			h->cstr.stack[stackIndex+1], 
			h->cstr.stack[stackIndex+2], 
			PSTACKVALUE(h, SV0), 
			h->cstr.stack[stackIndex+3],
      subr);
		stackIndex+=4;
	}
}

void XC_WriteHHCurveTo(XCF_Handle h, boolean subr)
{
	Card16 stackIndex = 0;

	if (h->cstr.stackTop & 0x01)	/* If odd number of arguments */
	{
		WriteSingleRRCurveTo(h,
			h->cstr.stack[1], 
			h->cstr.stack[0], 
			h->cstr.stack[2], 
			h->cstr.stack[3], 
			h->cstr.stack[4], 
			PSTACKVALUE(h, SV0),
      subr);
		stackIndex = 5;
	}

	while (stackIndex + 4 <= h->cstr.stackTop)
	{
		WriteSingleRRCurveTo(h,
			h->cstr.stack[stackIndex], 
			PSTACKVALUE(h, SV0), 
			h->cstr.stack[stackIndex+1], 
			h->cstr.stack[stackIndex+2], 
			h->cstr.stack[stackIndex+3], 
			PSTACKVALUE(h, SV0),
      subr);
		stackIndex+=4;
	}
}


void XC_WriteHVorVHCurveTo(XCF_Handle h, boolean hvCurve, boolean subr)
{
	Card16 stackIndex = 0;

	while (stackIndex + 4 <= h->cstr.stackTop)
	{
		if (stackIndex + 5 == h->cstr.stackTop)
			{
			if (hvCurve)
				WriteSingleRRCurveTo(h,
					h->cstr.stack[stackIndex], 
					PSTACKVALUE(h, SV0), 
					h->cstr.stack[stackIndex+1], 
					h->cstr.stack[stackIndex+2], 
					h->cstr.stack[stackIndex+4], 
					h->cstr.stack[stackIndex+3],
          subr);
			else
				WriteSingleRRCurveTo(h,
					PSTACKVALUE(h, SV0), 
					h->cstr.stack[stackIndex], 
					h->cstr.stack[stackIndex+1], 
					h->cstr.stack[stackIndex+2], 
					h->cstr.stack[stackIndex+3], 
					h->cstr.stack[stackIndex+4],
          subr);
			stackIndex+=5;
			}
		else
		{
			StateChange(h, ToPenDown, ToNotInHints, false, 0, subr);
			if (hvCurve)
			{
				RRCurveTo(h, 
					h->cstr.stack[stackIndex], 
					PSTACKVALUE(h, SV0), 
					h->cstr.stack[stackIndex+1],
					h->cstr.stack[stackIndex+2],
					PSTACKVALUE(h, SV0), 
					h->cstr.stack[stackIndex+3],
          subr);
			}
			else
			{
				RRCurveTo(h, 
					PSTACKVALUE(h, SV0), 
					h->cstr.stack[stackIndex], 
					h->cstr.stack[stackIndex+1],
					h->cstr.stack[stackIndex+2],
					h->cstr.stack[stackIndex+3],
					PSTACKVALUE(h, SV0),
          subr); 
			}
			hvCurve = !hvCurve;
			stackIndex+=4;
		}
	}
}

static Fixed AbsoluteValue(Fixed f)
{
	if (f < 0)
		return -f;
	else
		return f;
}

static void WriteExpandedFlexCurveTo(XCF_Handle h, 
						  PStackValue pdx2, 
						  PStackValue pdy2,
						  PStackValue pdx3, 
						  PStackValue pdy3,
						  PStackValue pdx4, 
						  PStackValue pdy4,
						  PStackValue pdx5, 
						  PStackValue pdy5,
						  PStackValue pdx6, 
						  PStackValue pdy6,
						  PStackValue pdx7, 
						  PStackValue pdy7,
						  PStackValue pflexHeight,
              boolean subr)
{
	StackValue endpointX;
	StackValue endpointY;
	StackValue refX, refY;	/* reference point */
	StackValue dx1, dy1;		/* first two arguments passed to flex */
	StackValue temp, temp1;

	PSVAdd7(h,&endpointX,h->cstr.x,pdx2,pdx3,pdx4,pdx5,pdx6,pdx7);
	PSVAdd7(h,&endpointY,h->cstr.y,pdy2,pdy3,pdy4,pdy5,pdy6,pdy7);
	h->cstr.flexUsed = true;

	if (AbsoluteValue(endpointX.value[0] - h->cstr.x->value[0]) > AbsoluteValue(endpointY.value[0] - h->cstr.y->value[0])) /* horizontal */
	{
		PSVAdd4(h,&refX,h->cstr.x,pdx2,pdx3,pdx4);
		PSVAdd7(h,&refY,h->cstr.y,pdy2,pdy3,pdy4,pdy5,pdy6,pdy7);
	}
	else
	{
		PSVAdd7(h,&refX,h->cstr.x,pdx2,pdx3,pdx4,pdx5,pdx6,pdx7); 
		PSVAdd4(h,&refY,h->cstr.y,pdy2,pdy3,pdy4);
	}

	PSVSubtract(h, &dx1, &refX, h->cstr.x);
	PSVSubtract(h, &dy1, &refY, h->cstr.y);

	PSVSubtract(h, &temp, h->cstr.x, &refX);
  PSVCopy(h, &temp1, pdx2);
	PStackValueAdd(h, pdx2, &temp1, &temp);
	
	PSVSubtract(h, &temp, h->cstr.y, &refY);
  PSVCopy(h, &temp1, pdy2);
	PStackValueAdd(h, pdy2, &temp1, &temp);

	StateChange(h, ToPenDown, ToNotInHints, false, 0, subr);

	Flex(h, &dx1, &dy1, pdx2, pdy2, pdx3, pdy3, pdx4, pdy4, pdx5, pdy5, pdx6,
			 pdy6, pdx7, pdy7, pflexHeight, &endpointX, &endpointY, subr);
}


void XC_WriteFlex(XCF_Handle h, boolean subr)
{
	if (h->cstr.stackTop == 13)
	{
		WriteExpandedFlexCurveTo(h,
			h->cstr.stack[0],
			h->cstr.stack[1],
			h->cstr.stack[2],
			h->cstr.stack[3],
			h->cstr.stack[4],
			h->cstr.stack[5],
			h->cstr.stack[6],
			h->cstr.stack[7],
			h->cstr.stack[8],
			h->cstr.stack[9],
			h->cstr.stack[10],
			h->cstr.stack[11],
			h->cstr.stack[12],
      subr);
	}
	else
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Incorrect Argument Count For flex ", h->cstr.stackTop );
}


void XC_WriteFlex1(XCF_Handle h, boolean subr)
{
	StackValue lastControlPointX, lastControlPointY;
	StackValue dx, dy;
	StackValue lastCtrlDx, lastCtrlDy;
	
	if (h->cstr.stackTop != 11)
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Incorrect Argument Count For flex1 ", h->cstr.stackTop );

	PSVAdd5(h,&lastCtrlDx,h->cstr.stack[0],h->cstr.stack[2],h->cstr.stack[4],h->cstr.stack[6],h->cstr.stack[8]); 
	PSVAdd5(h,&lastCtrlDy,h->cstr.stack[1],h->cstr.stack[3],h->cstr.stack[5],h->cstr.stack[7],h->cstr.stack[9]); 

	PSVAdd(h,&lastControlPointX,h->cstr.x, &lastCtrlDx);
	PSVAdd(h,&lastControlPointY, h->cstr.y, &lastCtrlDy);

	if (AbsoluteValue(lastCtrlDx.value[0]) > AbsoluteValue(lastCtrlDy.value[0]))
	{
		PSVCopy(h, &dx, h->cstr.stack[10]);
		PSVSubtract(h, &dy, PSTACKVALUE(h, SV0), &lastCtrlDy);
	}
	else
	{
		PSVSubtract(h, &dx, PSTACKVALUE(h, SV0), &lastCtrlDx); 
		PSVCopy(h, &dy, h->cstr.stack[10]);
	}

	WriteExpandedFlexCurveTo(h,
		h->cstr.stack[0],
		h->cstr.stack[1],
		h->cstr.stack[2],
		h->cstr.stack[3],
		h->cstr.stack[4],
		h->cstr.stack[5],
		h->cstr.stack[6],
		h->cstr.stack[7],
		h->cstr.stack[8],
		h->cstr.stack[9],
		&dx,
		&dy,
		PSTACKVALUE(h, SV50),
    subr);
}

void XC_WriteHFlex(XCF_Handle h, boolean subr)
{
	if (h->cstr.stackTop == 7)
	{
		PSVSubtract(h, PSTACKVALUE(h, SVTEMP), PSTACKVALUE(h, SV0),
                h->cstr.stack[2]);
		WriteExpandedFlexCurveTo(h,
			h->cstr.stack[0],
			PSTACKVALUE(h, SV0),
			h->cstr.stack[1],
			h->cstr.stack[2],
			h->cstr.stack[3],
			PSTACKVALUE(h, SV0),
			h->cstr.stack[4],
			PSTACKVALUE(h, SV0),
			h->cstr.stack[5],
			PSTACKVALUE(h, SVTEMP),
			h->cstr.stack[6],
			PSTACKVALUE(h, SV0),
			PSTACKVALUE(h, SV50),
      subr);
	}
	else
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Incorrect Argument Count For hflex ", h->cstr.stackTop );
}

void XC_WriteHFlex1(XCF_Handle h, boolean subr)
{
  StackValue temp, temp1;

	if (h->cstr.stackTop == 9)
	{
		PSVSubtract(h, &temp, PSTACKVALUE(h, SV0), h->cstr.stack[1]);
		PSVSubtract(h, &temp1,  &temp, h->cstr.stack[3]);
		PSVSubtract(h, PSTACKVALUE(h, SVTEMP), &temp1, h->cstr.stack[7]);
		WriteExpandedFlexCurveTo(h,
			h->cstr.stack[0],
			h->cstr.stack[1],
			h->cstr.stack[2],
			h->cstr.stack[3],
			h->cstr.stack[4],
			PSTACKVALUE(h, SV0),
			h->cstr.stack[5],
			PSTACKVALUE(h, SV0),
			h->cstr.stack[6],
			h->cstr.stack[7],
			h->cstr.stack[8],
			PSTACKVALUE(h, SVTEMP),
			PSTACKVALUE(h, SV50),
      subr);
	}
	else
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Incorrect Argument Count For hflex1 ", h->cstr.stackTop );
}


void XC_WriteDotSection(XCF_Handle h, boolean subr)
{
	if (h->cstr.stackTop != 0)
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Arguments On Stack For dotsection ", h->cstr.stackTop );
	StateChange(h, ToPenUp, ToNotInHints, false, 0, subr);
	DotSection(h, subr);
}

void XC_WriteVStem(XCF_Handle h, boolean subr)
{
	StateChange(h, NoPenEffect, NoHintEffect, true,
							h->cstr.stackTop-(h->cstr.stackTop & 0x01), subr);
	AddToHintMap(h, tx_vstem);
}

void XC_WriteHStem(XCF_Handle h, boolean subr)
{
	StateChange(h, NoPenEffect, NoHintEffect, true,
							h->cstr.stackTop-(h->cstr.stackTop & 0x01), subr);
	AddToHintMap(h, tx_hstem);
}

void XC_WriteHintMask(XCF_Handle h, boolean subr)
{
	if (h->cstr.stackTop > 0)	/* If stack is not empty then implied VStem */
		XC_WriteVStem(h, subr);

		if ((h->cstr.hints == InitialHints) && (h->cstr.languageGroup != 0)  && (h->cstr.counterGroupCount))
			WriteCounters(h, subr);

		if (h->cstr.waitingForFirstHint)	/* In case inital hints aren't at beginning of char string */
			h->cstr.hints = InitialHints;
		else
		{
			h->cstr.hints = SubrHints;
			StartHintSub(h, subr);
		}
		WriteHints(h, false, subr);
		h->cstr.hints = SubrHints; 
}

void XC_SetCounters(XCF_Handle h, boolean subr)
{
	Card16 hintIndex;
	Card8 currentByte;
	Card8 currentBit = 0;

	if (h->cstr.stackTop > 0)	/* If stack is not empty then implied VStem */
		XC_WriteVStem(h, subr);

	for (hintIndex=0;hintIndex<h->cstr.hintCount;++hintIndex)
	{
		if (!currentBit)
		{
			currentByte = *h->inBuffer.pos++;
			currentBit = 0x080;
		}
		if (currentByte & currentBit)
		{
			if (h->cstr.counterGroupCount >= MAX_COUNTER_GROUPS)
				XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Too many counter groups ", h->cstr.counterGroupCount );
			h->cstr.hintMap[hintIndex].counterGroups |= 1 << h->cstr.counterGroupCount;
			if (h->cstr.hintMap[hintIndex].opCode == tx_hstem)
				h->cstr.counterGroupHCount = h->cstr.counterGroupCount+1;
			else /* tx_vstem */
				h->cstr.counterGroupVCount = h->cstr.counterGroupCount+1;
		}
		currentBit = currentBit>>1;
	}
	++h->cstr.counterGroupCount;
}

#if JUDY
static void Blend(XCF_Handle h)
{
	CardX numberOfValues;
	CardX numberOfBlends;
	CardX stackIndex;
	CardX blendStackIndex;
	CardX i,j;

	if (h->cstr.stackTop == 0)
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Stack empty during blend operation ", h->cstr.stackTop );
	--h->cstr.stackTop;
	numberOfBlends = h->cstr.stack[h->cstr.stackTop].value[0];
	numberOfValues = h->dict.numberOfMasters * numberOfBlends;

	if (h->cstr.stackTop < numberOfValues)
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Stack underflow during blend operation ", h->cstr.stackTop );

	stackIndex = h->cstr.stackTop - numberOfValues;
	blendStackIndex = stackIndex;

	for (i=0; i<numberOfBlends; ++i)
	{
		for (j=0; j< (CardX)h->dict.numberOfMasters; ++j)
			h->cstr.stack[blendStackIndex].value[j] = h->cstr.stack[stackIndex++].value[0];
		h->cstr.stack[blendStackIndex].blend = true;
		++blendStackIndex;
	}
	h->cstr.stackTop = blendStackIndex;
}
#endif /* JUDY */

static void Translate(XCF_Handle h, boolean subr)
{
	switch (h->cstr.opCode)
	{
	case tx_hstem		:
	case t2_hstemhm		: XC_WriteHStem(h, subr);
		break;
	case tx_vstem		:
	case t2_vstemhm		: XC_WriteVStem(h, subr);
		break;
	case tx_hmoveto		: XC_WriteHMoveTo(h, subr);
		break;
	case tx_vmoveto		: XC_WriteVMoveTo(h, subr); 
		break;
	case tx_rlineto		: XC_WriteRLineTo(h, subr);
		break;
	case tx_hlineto		: XC_WriteHLineToAndVLineTo(h, true, subr);
		break;
	case tx_vlineto		: XC_WriteHLineToAndVLineTo(h, false, subr);
		break;
	case tx_rrcurveto	: XC_WriteRRCurveTo(h, subr);
		break;
	case tx_endchar		: XC_WriteEndChar(h, subr);
		break;
	case tx_rmoveto		: XC_WriteRMoveTo(h, subr);
		break;
	case t2_rcurveline	: XC_WriteRCurveLine(h, subr);
		break;
	case t2_rlinecurve	: XC_WriteRLineCurve(h, subr);
		break;
	case t2_vvcurveto	: XC_WriteVVCurveTo(h, subr);
		break;
	case t2_hhcurveto	: XC_WriteHHCurveTo(h, subr);
		break;
	case tx_vhcurveto	: XC_WriteHVorVHCurveTo(h, false, subr); 
		break;
	case tx_hvcurveto	: XC_WriteHVorVHCurveTo(h, true, subr);
		break;
	case tx_dotsection	: XC_WriteDotSection(h, subr);
		break;
	case t2_flex		: XC_WriteFlex(h, subr);
		break;
	case t2_flex1		: XC_WriteFlex1(h, subr);
		break;
	case t2_hflex		: XC_WriteHFlex(h, subr);
		break;
	case t2_hflex1		: XC_WriteHFlex1(h, subr);
		break;
	case t2_hintmask	: XC_WriteHintMask(h, subr);
		break;
	case t2_cntrmask	: XC_SetCounters(h, subr);
		break;
  /* The following opcodes can be found in certain mmfonts. */
  case tx_add:
  case tx_sub:
  case tx_load:
  case tx_get:
  case tx_put:
  case tx_store:
  case tx_ifelse:
  {
    Card16 j;
    for (j = 0; j < h->cstr.stackTop; j++)
     XC_WriteT1PStackValue(h, h->cstr.stack[j], subr);
    XC_WriteT1OpCode(h, h->cstr.opCode, subr);
  }
    break;
	default					:
		XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Unrecognized Operator",
										h->cstr.opCode );
		break;
	}
  h->cstr.stackTop = 0;
}


static void CopyArgumentsToStack(XCF_Handle h, Card8 PTR_PREFIX *pArgList, IntX argCount, boolean blend)
{
	IntX stackIndex;
	IntX blendArg;
	IntX deltaIndex;
	IntX i;
	IntX j;

	for (stackIndex= (IntX)h->cstr.stackTop; stackIndex < (IntX)h->cstr.stackTop + argCount; ++stackIndex)
	{
		h->cstr.stack[stackIndex]->value[0] = XCF_ArgPtrToFixed(h, &pArgList, false);
		h->cstr.stack[stackIndex]->blend = false;
	}
	h->cstr.stackTop += (Card16)argCount;

	if (blend)
	{
		--h->cstr.stackTop;
		blendArg = FIXED_TO_INT(h->cstr.stack[h->cstr.stackTop]->value[0]);
		stackIndex = h->cstr.stackTop - (blendArg * h->dict.numberOfMasters);
		deltaIndex = stackIndex + blendArg;

		for (i=stackIndex;i<stackIndex+blendArg;++i)
		{
			h->cstr.stack[i]->blend = true;
			for (j=1;j<h->dict.numberOfMasters;++j)
				h->cstr.stack[i]->value[j] = h->cstr.stack[deltaIndex++]->value[0] + h->cstr.stack[i]->value[0];
		}
		h->cstr.stackTop = stackIndex + blendArg;
	}
}

static void ProcessCharstr(XCF_Handle h, unsigned int depth, boolean PTR_PREFIX
													 *endcharFound, boolean subr)
{
	Card8 PTR_PREFIX *argList;
	IntX argCount;

	if (depth == 0)
	{
		h->cstr.stackTop = 0;
		h->cstr.pen = PenNull;
	}

	if (depth > TX_MAX_CALL_STACK)
		XCF_FATAL_ERROR(h, XCF_SubrDepthOverflow, "Maximum Subr Depth Exceeded", depth );

	while (h->inBuffer.pos < h->inBuffer.end)
	{
		argList = h->inBuffer.pos;
		argCount = XCF_FindNextOperator(h, &h->cstr.opCode, false);
		if ((h->cstr.stackTop + argCount) > MAX_OPERAND_STACK)
			XCF_FATAL_ERROR(h, XCF_StackOverflow, "Charstring Stack Overflow", h->cstr.stackTop + argCount );

		CopyArgumentsToStack(h, argList, argCount, (h->cstr.opCode == t2_blend));
		
		switch (h->cstr.opCode)
		{
			case tx_return:
				if (depth == 0)
					XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Subr Return Encountered While Not In Subr", tx_return );
				return;
				break;
			case tx_callsubr: 
        /* Make sure the stack isn't empty then flatten the subroutine. */
        if (h->cstr.stackTop == 0)
          XCF_FATAL_ERROR(h, XCF_StackUnderflow, "No subr number associated with subr call", 0);
        else  /* flatten the subroutine */
          FlattenSubr(h, depth + 1, endcharFound, true);
        break;
			case t2_callgsubr: 
				if (h->cstr.stackTop == 0)
					XCF_FATAL_ERROR(h, XCF_StackUnderflow, "No subr number associated with subr call", 0);
        else
          FlattenSubr(h, depth + 1, endcharFound, false);
        break;
			case t2_blend : /* Do Nothing and loop again */
				break;
			default:
				Translate(h, subr);
				break;
		} /* end case */

		if (h->cstr.opCode == tx_endchar)
		{
			*endcharFound = true;
			return;
		}	
	} /* end while */

	XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Charstring Not Terminated With endchar", 0 );
}


/* This is called recursively from ProcessCharstr to flatten subroutines. */
static void FlattenSubr(XCF_Handle h, unsigned int depth, boolean PTR_PREFIX
													 *endcharFound, boolean localSubr)
{
  Card16 subrNum;
  Card16 pos;
  InBufferStruct inBuffer;

  if ((localSubr && h->dict.localSubrs.count == 0) ||
      (!localSubr && h->fontSet.globalSubrs.count == 0))
    XCF_FATAL_ERROR(h, XCF_InvalidCharString, "No subrs defined but subr called in charstring", 0);

  /* Save value of inBuffer. */
  h->callbacks.memcpy(&inBuffer, (Card8 PTR_PREFIX *)&h->inBuffer, (Card16)
											sizeof(InBufferStruct));
  pos = (Card16)(h->inBuffer.pos - h->inBuffer.start); /* position relative to start */

  subrNum = FIXED_TO_INT(h->cstr.stack[h->cstr.stackTop-1]->value[0]) +	(localSubr ? h->dict.localSubrBias : h->fontSet.globalSubrBias);
  XCF_LookUpTableEntry(h, (localSubr ? &h->dict.localSubrs : &h->fontSet.globalSubrs), subrNum);
 
  --h->cstr.stackTop;    /* Remove subr number from stack. */

  ProcessCharstr(h, depth, endcharFound, false);

  /* Restore value of inBuffer. */
  XCF_ReadBlock(h, inBuffer.blockOffset, inBuffer.blockLength);
  h->inBuffer.pos = h->inBuffer.start + pos;
}

void XC_SetUpStandardSubrs(XCF_Handle h)
{
	ShortStackValue temp;

/* dup 0 ## -| { 3 0 callother pop pop setcurrentpoint return } */
	NewT1Subr(h);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 3), true);
	XC_WriteT1PStackValue(h, PSTACKVALUE(h, SV0), true);
	XC_WriteT1OpCode(h, t1_callother, true);
	XC_WriteT1OpCode(h, t1_pop, true);
	XC_WriteT1OpCode(h, t1_pop, true);
	XC_WriteT1OpCode(h, t1_setcurrentpt, true);

/* dup 1 ## -| { 0 1 callother return } | */
	NewT1Subr(h);
	XC_WriteT1PStackValue(h, PSTACKVALUE(h, SV0), true);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 1), true);
	XC_WriteT1OpCode(h, t1_callother, true);

/* dup 2 ## -| { 0 2 callother return } | */
	NewT1Subr(h);
	XC_WriteT1PStackValue(h, PSTACKVALUE(h, SV0), true);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 2), true);
	XC_WriteT1OpCode(h, t1_callother, true);

/* dup 3 ## -| { return } | */
	NewT1Subr(h);

/* dup 4 ## -| { <<3>> 1 3 callother pop callsubr return } */
	NewT1Subr(h);
	if (CIDFONT || h->options.subrFlatten)
		XC_WriteT1PStackValue(h, IntToPSV(&temp, 3), true);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 1), true);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 3), true);
	XC_WriteT1OpCode(h, t1_callother, true);
	XC_WriteT1OpCode(h, t1_pop, true);
	XC_WriteT1OpCode(h, tx_callsubr, true);

/* dup 5 ## -| { return } | */
	NewT1Subr(h);

/* Last subr in a CIDFont is 4; the call to NewT1Subr above closes out the DA. */
	if (CIDFONT || !h->dict.numberOfMasters)
		return;
	
/* dup 6 ## -| { 2 14 callother pop return } | */
	NewT1Subr(h);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, h->dict.numberOfMasters), true);
	XC_WriteT1PStackValue(h, IntToPSV(&temp, 14), true);
	XC_WriteT1OpCode(h, t1_callother, true);
	XC_WriteT1OpCode(h, t1_pop, true);

}

static void InitStackVal(XCF_Handle h)
{
	Card16  i;
	Card16  svSize;
	Card8   *p;
	Card16  offset;


  NewStackValues(h, (void PTR_PREFIX * PTR_PREFIX *)&p, NUM_STACK_VALUES, &svSize);
	h->cstr.pstackVal = (PStackValue)p;
	offset = 0;
	h->cstr.x = NEXTSTACKVALUE(p, offset, svSize);
	h->cstr.y = NEXTSTACKVALUE(p, offset, svSize);

	for (i=0; i < MAX_OPERAND_STACK; i++)
	{
		h->cstr.stack[i] = NEXTSTACKVALUE(p, offset, svSize);
	}

	for (i=0; i <  MAX_COUNTER_BUFFER; i++)
	{
		h->cstr.counterBuffer[i] = NEXTSTACKVALUE(p, offset, svSize);
	}

	for (i=0; i < MAX_HINTS; i++)
	{
		h->cstr.hintMap[i].delta = NEXTSTACKVALUE(p, offset, svSize);
		h->cstr.hintMap[i].edge = NEXTSTACKVALUE(p, offset, svSize);
	}

	for (i=0; i < MAX_SVTEMP; i++)
	{
		h->cstr.psvTemp[i] = NEXTSTACKVALUE(p, offset, svSize);
	}

	IntToPSV(PSTACKVALUE(h, SV0), 0);
	IntToPSV(PSTACKVALUE(h, SV50), 50);
}

void XC_Init(XCF_Handle h) 
{
	h->cstr.flexUsed = false;
  InitStackVal(h);

  h->cstr.pCounterVal = 0;

	if (CIDFONT)
		h->type1.cid.charDataCount = 0;
}

static void InitCharstr(XCF_Handle h)
{
	h->cstr.pen = PenNull;
	h->cstr.hints = InitialHints;
	h->cstr.waitingForHsbw = true;
	h->cstr.waitingForFirstHint = true;
	h->cstr.stackTop = 0;
	h->cstr.hintCount = 0;
	h->cstr.counterGroupCount = 0;
	h->cstr.counterGroupVCount = 0;
	h->cstr.counterGroupHCount = 0;
	IntToPSV(h->cstr.x, 0);
	IntToPSV(h->cstr.y, 0);

	h->cstr.subrFlatten = h->options.subrFlatten;
	/* Initialize the seac characters */
	h->cstr.baseSeac = 0;
	h->cstr.accentSeac = 0;
}

void XC_ProcessCharstr(XCF_Handle h)
{
	boolean endCharFound = false;

  InitCharstr(h);
	if (!CIDFONT && h->options.subrFlatten)
		FreeT1CharStr(h);
	else
		NewT1CharStr(h);

#ifdef T13
  if (h->dict.fontType == 13)
    XT13_ProcessCharstr(h, 0, &endCharFound, false);
  else
#endif
  if ((h->options.outputCharstrType != 2) && (h->dict.fontType != 1))
	  ProcessCharstr(h, 0, &endCharFound, false);
}

void XC_CleanUp(XCF_Handle h)
{
	if (!CIDFONT)
	{
		NewT1Subr(h);
		NewT1CharStr(h);
	}
}

void CheckSeacCharString(XCF_Handle h, CardX index)
{
	Card8 PTR_PREFIX *argList;
	IntX argCount;

	XCF_LookUpTableEntry(h, &h->fontSet.charStrings, index);

	h->cstr.pen = PenNull;
	h->cstr.hints = InitialHints;
	h->cstr.waitingForHsbw = true;
	h->cstr.waitingForFirstHint = true;
	h->cstr.stackTop = 0;
	h->cstr.hintCount = 0;
	h->cstr.counterGroupCount = 0;
	h->cstr.counterGroupVCount = 0;
	h->cstr.counterGroupHCount = 0;
	IntToPSV(h->cstr.x, 0);
	IntToPSV(h->cstr.y, 0);
	h->cstr.baseSeac = 0;
	h->cstr.accentSeac = 0;
	h->cstr.stackTop = 0;

	argList = h->inBuffer.pos;
	argCount = XCF_FindNextOperator(h, &h->cstr.opCode, false);
	if ((h->cstr.stackTop + argCount) > MAX_OPERAND_STACK)
			XCF_FATAL_ERROR(h, XCF_StackOverflow, "Charstring Stack Overflow", h->cstr.stackTop + argCount );

	CopyArgumentsToStack(h, argList, argCount, (h->cstr.opCode == t2_blend));
		
	if (h->cstr.opCode == tx_endchar && h->cstr.stackTop >= 4)
	{
		h->cstr.baseSeac =	FIXED_TO_INT(h->cstr.stack[2]->value[0]);
		h->cstr.accentSeac = FIXED_TO_INT(h->cstr.stack[3]->value[0]);
	} 
}

/* All charstring stack operations are performed using the fixed point type.
   The following functions deal with storing and retrieving values from
   the stack. */

/* Push fixed point number on stack (as fixed) */
static void PushFix(XCF_Handle h, Fixed f)
{
  if (h->cstr.stackTop >= MAX_OPERAND_STACK)
    XCF_FATAL_ERROR(h, XCF_StackOverflow, "Charstring Stack Overflow",
h->cstr.stackTop);
  h->cstr.stack[h->cstr.stackTop]->value[0] = f;
  h->cstr.stack[h->cstr.stackTop++]->blend = false;
}

/* Push integer number on stack (as fixed) */
static void PushInt(XCF_Handle h, long l)
{
  if (h->cstr.stackTop >= MAX_OPERAND_STACK)
    XCF_FATAL_ERROR(h, XCF_StackOverflow, "Charstring Stack Overflow",
h->cstr.stackTop);
  h->cstr.stack[h->cstr.stackTop]->value[0] = INT_TO_FIXED(l);
  h->cstr.stack[h->cstr.stackTop++]->blend = false;
}

/* Pop number from stack (return fixed) */
static Fixed PopFix(XCF_Handle h)
{
  if (h->cstr.stackTop < 1)
    XCF_FATAL_ERROR(h, XCF_StackUnderflow, "Charstring Stack Underflow",
										h->cstr.stackTop);
  h->cstr.stackTop -= 1;
  return h->cstr.stack[h->cstr.stackTop]->value[0];
}

/* Pop number from stack (return long) */
static long PopInt(XCF_Handle h)
{
  if (h->cstr.stackTop < 1)
    XCF_FATAL_ERROR(h, XCF_StackUnderflow, "Charstring Stack Underflow",
										h->cstr.stackTop);
  h->cstr.stackTop -= 1;
  return (FIXED_TO_INT(h->cstr.stack[h->cstr.stackTop]->value[0]));
}

/* Select registry item. */
static Fixed *SelRegItem(XCF_Handle h, int reg, int *regSize)
{
  switch (reg)
  {
	case TX_REG_WV:
		*regSize = TX_MAX_MASTERS;
		return h->dict.weightVector;
	case TX_REG_NDV:
		*regSize = TX_MAX_AXES;
		return h->dict.normDesignVector;
	case TX_REG_UDV:
		*regSize = TX_MAX_AXES;
		return h->dict.userDesignVector;
	default:
		XCF_FATAL_ERROR(h, XCF_InternalError, "unknown registry item", reg);
	}
	return 0;	/* Suppress compiler warning */
}

/* Parse and execute the given charstring. This is used specifically for
   multiple master fonts when converting a user design vector to a
   weight vector. It can be used more generally when functionality is
   added for more operators. */
int XC_ParseCharStr(XCF_Handle h, unsigned char PTR_PREFIX *cstr, int init)
{
  int i;
  Fixed PTR_PREFIX *bcArray = NULL;

  if (!h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&bcArray,
														 h->dict.lenBuildCharArray * sizeof(Fixed), h->callbacks.allocateHook))
    XCF_FATAL_ERROR(h, XCF_MemoryAllocationError,
     "Failure to allocate memory for buildchar array", h->dict.lenBuildCharArray);
  switch (init)
  {
  case 1:
    break;
  case 2:
    InitCharstr(h);
    break;
  }

  i = 0;
  for (;;)
    switch (cstr[i])
    {
		case tx_endchar:
      if (bcArray != NULL)
        h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&bcArray, 0,
															h->callbacks.allocateHook);

      return i + 1; /* Return charstring length */
 		case tx_reserved0:
		case t2_reserved2:
		case t2_reserved9:
		case t2_reserved13:
		case t2_reserved15:
		case t2_reserved17:
      XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Reserved Charstring Operator",
											cstr[i]);
    case tx_rlineto:
		case tx_hlineto:
		case tx_vlineto:
		case tx_rrcurveto:
		case tx_callsubr:
		case tx_return:
		case t2_rcurveline:
		case t2_rlinecurve:
		case t2_vvcurveto:
		case t2_hhcurveto:
		case t2_callgsubr:
		case tx_vhcurveto:
		case tx_hvcurveto:
		case tx_rmoveto:
		case tx_hmoveto:
		case tx_vmoveto:
		case tx_hstem:
		case tx_vstem:
		case t2_hstemhm:
		case t2_vstemhm:
		case t2_hintmask:
		case t2_cntrmask:
      XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Unsupported Charstring Operator", cstr[i]);
      break;
    case tx_escape:
		{
			Fixed a;
			Fixed b;
			Fixed x;
			Fixed y;
			switch (cff_ESC(cstr[i + 1]))
			{
			case tx_dotsection:
				break;
			default:
			case t2_reservedESC1:
			case t2_reservedESC2:
			case t2_reservedESC6:
			case t2_reservedESC7:
			case t2_reservedESC16:
			case t2_reservedESC17:
			case tx_reservedESC25:
			case tx_reservedESC31:
			case tx_reservedESC32:
			case t2_reservedESC33:
			case t2_reservedESC19:
			case t2_cntron:
        XCF_FATAL_ERROR(h, XCF_InvalidCharString,
                       "Reserved Charstring Operator", cstr[i+1]);
      case tx_and:
        b = PopFix(h);
        a = PopFix(h);
        PushInt(h, a || b);
        break;
      case tx_not:
				a = PopFix(h);
        PushInt(h, !a);
        break;
      case tx_store:
      {
        Int32 count = PopInt(h);
        Int32 i = PopInt(h);
        Int32 j = PopInt(h);
        Int32 iReg = PopInt(h);
        int regSize;
        Fixed *reg = SelRegItem(h, (int)iReg, &regSize);
        if (i < 0 || i + count - 1 >= h->dict.lenBuildCharArray ||
          j < 0 || j + count - 1 >= regSize)
          XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "bounds check (store)", 0);
        h->callbacks.memcpy(&reg[j], &bcArray[i], (unsigned short int)(sizeof(Fixed) * count));
      }
        break;
      case tx_abs:
        a = PopFix(h);
        PushFix(h, (a < 0) ? -a : a);
        break;
      case tx_add:
        b = PopFix(h);
        a = PopFix(h);
        PushFix(h, a + b);
        break;
      case tx_sub:
        b = PopFix(h);
        a = PopFix(h);
        PushFix(h, a - b);
        break;
      case tx_div:
        y = PopFix(h);
        x = PopFix(h);
        if (y == 0)
          XCF_FATAL_ERROR(h, XCF_InvalidNumber, "divide by zero (div)", 0);
        PushFix(h, XCF_FixDiv(x, y));
        break;
      case tx_load:
      {
         int regSize;
         Int32 count = PopInt(h);
         Int32 i = PopInt(h);
         Int32 iReg = PopInt(h);
         Fixed *reg = SelRegItem(h, (int)iReg, &regSize);
         if (i < 0 || i + count - 1 >= h->dict.lenBuildCharArray || count >
						 regSize)
           XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "bounds check (load)", i);
         h->callbacks.memcpy(&bcArray[i], &reg[0], (unsigned short int)(sizeof(Fixed) * count));
      }
        break;
      case tx_neg:
        a = PopFix(h);
        PushFix(h, -a);
        break;
      case tx_eq:
        b = PopFix(h);
        a = PopFix(h);
        PushInt(h, a == b);
        break;
      case tx_drop:
        (void)PopFix(h);
         break;
      case tx_put:
      {
        Int32 i = PopInt(h);
        if (i < 0 || i >= h->dict.lenBuildCharArray)
          XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "bounds check (put)", i);
        bcArray[i] = PopFix(h);
      }
      break;
      case tx_get:
      {
         Int32 i = PopInt(h);
         if (i < 0 || i >= h->dict.lenBuildCharArray)
           XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "bounds check (get)", i);
         PushFix(h, bcArray[i]);
      }
      break;
      case tx_ifelse:
      {
        Fixed v2 = PopFix(h);
        Fixed v1 = PopFix(h);
        Fixed s2 = PopFix(h);
        Fixed s1 = PopFix(h);
        PushFix(h, (v1 > v2) ? s2 : s1);
      }
      break;
      case tx_random:
        /* For generators that aren't very random in the low order bits
				   (a common problem) the following is a good example of what
				   not to do. However, obtaining good randomness is not very
				   important in this application so I opted for simplicity */
/*				PushFix(h, rand() % FIXEDONE + 1); */
				break;
      case tx_mul:
        y = PopFix(h);
        x = PopFix(h);
        PushFix(h, XCF_FixMul(x, y));
        break;
      case tx_dup:
        PushFix(h, h->cstr.stack[h->cstr.stackTop - 1]->value[0]);
        break;
      case tx_exch:
        b = PopFix(h);
        a = PopFix(h);
        PushFix(h, b);
        PushFix(h, a);
        break;
      case tx_index:
      {
        Int32 i = PopInt(h);
        if (i < 0)
          i = 0; /* Duplicate top element */
        if (i >= (int)h->cstr.stackTop)
          XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "limit check (index)", i);
        PushFix(h, h->cstr.stack[h->cstr.stackTop - 1 - i]->value[0]);
      }
      break;
      case tx_roll:
      {
        int k;
				int iSrc;
				int iDst;
				Fixed tmp[T2_MAX_OP_STACK];
				int   tmpSize = sizeof(tmp) / sizeof(Fixed);
				Int32 j = PopInt(h);
				Int32 n = PopInt(h);
				int iBottom = h->cstr.stackTop - (int)n;

				if (n < 0 || iBottom < 0)
          XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "limit check (roll)", 0);

				if (j < 0)
					j += n;		/* Convert to positive roll */
				j %= n;			/* Constrain j to (-n,n) */
				if (j < 0)	
					j += n;		/* Constrain j to [0,n) */

				iSrc = iBottom;
				iDst = iBottom + (int)j;
				for (k = 0; (Int32)k < n - j; k++)
				{
					if (iDst >= tmpSize)   
						break;
					tmp[iDst++] = h->cstr.stack[iSrc++]->value[0];
				}

				iSrc = iBottom + (int)n - (int)j;
				iDst = iBottom;
				for (k = 0; k < j; k++)
				{
					if (iDst >= tmpSize)   
						break;
					tmp[iDst++] = h->cstr.stack[iSrc++]->value[0];
				}

				for (k = iBottom; k < (int)h->cstr.stackTop; k++)
				{
					if (k >= tmpSize)   
						break;
					h->cstr.stack[k]->value[0] = tmp[k];
				}
			}
			break;
			case t2_hflex:
			case t2_flex:
			case t2_hflex1:
			case t2_flex1:
      case tx_sqrt:
        XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Unsupported Charstring	Operator", cstr[i]);
        break;
      }
      i += 2;
		}
    break;
    case t2_blend:
/*      Blend(h); */
      i++;
      break;
    case t2_shortint:
      PushInt(h, cstr[i + 1]<<8 | cstr[i + 2]);
      i += 3;
      break;
    case 247: case 248: case 249: case 250:
			/* Positive 2 byte number */
      PushInt(h, 108 + 256 * (cstr[i] - 247) + cstr[i + 1]);
      i += 2;
      break;
    case 251: case 252: case 253: case 254:
			/* Negative 2 byte number */
      PushInt(h, -108 - 256 * (cstr[i] - 251) - cstr[i + 1]);
      i += 2;
      break;
    case 255:
      /* 5 byte number */
      PushFix(h, (long)cstr[i + 1]<<24 | (long)cstr[i + 2]<<16 |
			cstr[i + 3]<<8 | cstr[i + 4]);
      i += 5;
      break;
    default:
      /* 1 byte number */
      PushInt(h, cstr[i] - 139);
      i++;
      break;
    }
}

/* Read the charstring and include as a subroutine. */        
static int CharStrToSubr(XCF_Handle h, unsigned char PTR_PREFIX *cstr)
{
  int i;
  int j;
  Card16 op;

  NewT1Subr(h);

  h->cstr.stackTop = 0;
  i = 0;
  for (;;)
    switch (cstr[i])
    {
    case tx_endchar:
      XC_WriteT1OpCode(h, tx_endchar, true);
      return i + 1; /* Return charstring length */
    case tx_reserved0:
		case t2_reserved2:
		case t2_reserved9:
		case t2_reserved13:
		case t2_reserved15:
		case t2_reserved17:
      XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Reserved Charstring Operator",
											cstr[i]);
    case tx_rlineto:
		case tx_hlineto:
		case tx_vlineto:
		case tx_rrcurveto:
		case tx_callsubr:
		case tx_return:
		case t2_rcurveline:
		case t2_rlinecurve:
		case t2_vvcurveto:
		case t2_hhcurveto:
		case t2_callgsubr:
		case tx_vhcurveto:
		case tx_hvcurveto:
		case tx_rmoveto:
		case tx_hmoveto:
		case tx_vmoveto:
		case tx_hstem:
		case tx_vstem:
		case t2_hstemhm:
		case t2_vstemhm:
		case t2_hintmask:
		case t2_cntrmask:
      XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Unsupported Charstring Operator in Design Vector subr", cstr[i]);
      break;
    case tx_escape:
		{
			switch (cff_ESC(cstr[i + 1]))
			{
			case tx_dotsection:
				break;
			default:
			case t2_reservedESC1:
			case t2_reservedESC2:
			case t2_reservedESC6:
			case t2_reservedESC7:
			case t2_reservedESC16:
			case t2_reservedESC17:
			case tx_reservedESC25:
			case tx_reservedESC31:
			case tx_reservedESC32:
			case t2_reservedESC33:
			case t2_reservedESC19:
			case t2_cntron:
        XCF_FATAL_ERROR(h, XCF_InvalidCharString,
                       "Reserved Charstring Operator", cstr[i+1]);
      case tx_and:
      case tx_not:
      case tx_store:
      case tx_abs:
      case tx_add:
      case tx_sub:
      case tx_div:
      case tx_load:
      case tx_neg:
      case tx_eq:
      case tx_drop:
      case tx_put:
      case tx_get:
      case tx_ifelse:
      case tx_random:
      case tx_mul:
      case tx_dup:
      case tx_exch:
      case tx_index:
      case tx_roll:
        for (j = 0; j < (int)h->cstr.stackTop; j++)
         XC_WriteT1PStackValue(h, h->cstr.stack[j], true);
        op = (cstr[i] << 8) | cstr[i+1];
        XC_WriteT1OpCode(h, op, true);
        h->cstr.stackTop = 0;
        break;
      case t2_hflex:
			case t2_flex:
			case t2_hflex1:
			case t2_flex1:
      case tx_sqrt:
        XCF_FATAL_ERROR(h, XCF_InvalidCharString, "Unsupported Charstring	Operator", cstr[i]);
        break;
      }
      i += 2;
		}
    break;
    case t2_blend:
/*      Blend(h); */
      i++;
      break;
    case t2_shortint:
      PushInt(h, cstr[i + 1]<<8 | cstr[i + 2]);
      i += 3;
      break;
    case 247: case 248: case 249: case 250:
			/* Positive 2 byte number */
      PushInt(h, 108 + 256 * (cstr[i] - 247) + cstr[i + 1]);
      i += 2;
      break;
    case 251: case 252: case 253: case 254:
			/* Negative 2 byte number */
      PushInt(h, -108 - 256 * (cstr[i] - 251) - cstr[i + 1]);
      i += 2;
      break;
    case 255:
      /* 5 byte number */
      PushFix(h, (long)cstr[i + 1]<<24 | (long)cstr[i + 2]<<16 |
			cstr[i + 3]<<8 | cstr[i + 4]);
      i += 5;
      break;
    default:
      /* 1 byte number */
      PushInt(h, cstr[i] - 139);
      i++;
      break;
    }
}

/* Write out NDV and CDV as subroutines. */
void XC_DVToSubr(XCF_Handle h)
{
  char PTR_PREFIX *str;
  Card16 length;

  XCF_LookUpString(h, h->dict.ndv, &str, &length);
  CharStrToSubr(h, (unsigned char PTR_PREFIX *)str);
  XCF_LookUpString(h, h->dict.cdv, &str, &length);
  CharStrToSubr(h, (unsigned char PTR_PREFIX *)str);
  NewT1Subr(h);
}

#if HAS_COOLTYPE_UFL == 1
/* Returns 1 if i is a character with transitional designs and has
   already been processed. */
int XC_TransDesignChar(XCF_Handle h, CardX sid)
{
  /* JimboMM transitional characters */
  static unsigned char Jimbo0_cstr[] =
  {
    #include "xcf_jimbo0.h"
  };
  static unsigned char Jimbo1_cstr[] =
  {
    #include "xcf_jimbo1.h"
  };
  static unsigned char Jimbo2_cstr[] =
  {
    #include "xcf_jimbo2.h"
  };
  static TransChar Jimbo_chars[] =
	{
    {50, {sizeof(Jimbo0_cstr), (char *)Jimbo0_cstr}},
    {56, {sizeof(Jimbo1_cstr), (char *)Jimbo1_cstr}},
    {88, {sizeof(Jimbo2_cstr), (char *)Jimbo2_cstr}},
  };
  /* ITCGaramond Roman transitional characters */
  static unsigned char GaraRm0_cstr[] =
  {
    #include "xcf_rgara0.h"
  };
  static unsigned char GaraRm1_cstr[] =
  {
    #include "xcf_rgara1.h"
  };
  static unsigned char GaraRm2_cstr[] =
  {
    #include "xcf_rgara2.h"
  };
  static unsigned char GaraRm3_cstr[] =
  {
    #include "xcf_rgara3.h"
  };
  static TransChar GaraRm_chars[] =
  {
    {56, {sizeof(GaraRm0_cstr), (char *)GaraRm0_cstr}},
    {97, {sizeof(GaraRm1_cstr), (char *)GaraRm1_cstr}},
    { 5, {sizeof(GaraRm2_cstr), (char *)GaraRm2_cstr}},
    {88, {sizeof(GaraRm3_cstr), (char *)GaraRm3_cstr}},
  };
  /* ITCGaramond Italic transitional characters */
  static unsigned char GaraIt0_cstr[] =
  {
    #include "xcf_igara0.h"
  };
  static unsigned char GaraIt1_cstr[] =
  {
    #include "xcf_igara1.h"
  };
  static unsigned char GaraIt2_cstr[] =
  {
    #include "xcf_igara2.h"
  };
  static unsigned char GaraIt3_cstr[] =
  {
    #include "xcf_igara3.h"
  };
  static unsigned char GaraIt4_cstr[] =
  {
    #include "xcf_igara4.h"
  };
  static TransChar GaraIt_chars[] =
  {
    { 56, {sizeof(GaraIt0_cstr), (char *)GaraIt0_cstr}},
    { 97, {sizeof(GaraIt1_cstr), (char *)GaraIt1_cstr}},
    {  5, {sizeof(GaraIt2_cstr), (char *)GaraIt2_cstr}},
    { 32, {sizeof(GaraIt3_cstr), (char *)GaraIt3_cstr}},
    {123, {sizeof(GaraIt4_cstr), (char *)GaraIt4_cstr}},
  };

  char fontName[512];
  TransChar *transCharTbl = 0;
  Card16 tblLen = 0;
  Card16 i, j;

  if (XCF_FontName(h, (unsigned short int)h->fontSet.fontIndex, fontName,
               (unsigned short int)512) != XCF_Ok)
    return 0;

  if (h->callbacks.strcmp(fontName,	"ITCGaramondMM") == 0)
	{
    transCharTbl = GaraRm_chars;
    tblLen = sizeof(GaraRm_chars)/sizeof(GaraRm_chars[0]);
  }
  else if (h->callbacks.strcmp(fontName,	"ITCGaramondMM-It") == 0)
  {
    transCharTbl = GaraIt_chars;
    tblLen = sizeof(GaraIt_chars)/sizeof(GaraIt_chars[0]);
  }
  else if (h->callbacks.strcmp(fontName, "JimboMM") == 0)
  {
    transCharTbl = Jimbo_chars;
    tblLen = sizeof(Jimbo_chars)/sizeof(Jimbo_chars[0]);
  }

  if (tblLen == 0) /* Not a font with transitional designs. */
    return 0;

  for (i = 0; i < tblLen; i++)
    if (transCharTbl[i].sid == sid)
    {
      Card8 PTR_PREFIX *args;
      IntX argCount;

      InitCharstr(h);
      if (h->options.subrFlatten)
		    FreeT1CharStr(h);
	    else
		    NewT1CharStr(h);
      h->inBuffer.pos = (Card8 *)transCharTbl[i].cstr.cstr;
      h->inBuffer.blockLength = transCharTbl[i].cstr.length;
      h->inBuffer.end = h->inBuffer.pos + h->inBuffer.blockLength;
      while (h->inBuffer.pos < h->inBuffer.end)
      {
        args = h->inBuffer.pos;
        argCount = XCF_FindNextOperator(h, &h->cstr.opCode, false);
        if ((h->cstr.stackTop + argCount) > MAX_OPERAND_STACK)
			      XCF_FATAL_ERROR(h, XCF_StackOverflow, "Charstring Stack Overflow", h->cstr.stackTop + argCount );

		    CopyArgumentsToStack(h, args, argCount, (h->cstr.opCode == t2_blend));
        for (j = 0; j < h->cstr.stackTop; j++)
          XC_WriteT1PStackValue(h, h->cstr.stack[j], false);
        XC_WriteT1OpCode(h, h->cstr.opCode, false);
        h->cstr.stackTop = 0;
      }
      return 1;
    }
              
  return 0;
}

/* Only processes the subroutines associated with transitional
   design characters. */
void XC_ProcessTransDesignSubrs(XCF_Handle h)
{
  Card16 i;
  char fontName[512];
  Card16 tblLen = 0;
  short *subrTbl = 0;
  boolean endCharFound = false;

  static short Jimbo_subrs[] = {0, 1, 2, 3, 4, 5};
  static short GaraRm_subrs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8};
  static short GaraIt_subrs[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  if (XCF_FontName(h, (unsigned short int)h->fontSet.fontIndex, fontName,
               (unsigned short int)512) != XCF_Ok)
    return;

  if (h->callbacks.strcmp(fontName,	"ITCGaramondMM") == 0)
	{
    subrTbl = GaraRm_subrs;
    tblLen = sizeof(GaraRm_subrs)/sizeof(GaraRm_subrs[0]);
  }
  else if (h->callbacks.strcmp(fontName,	"ITCGaramondMM-It") == 0)
  {
    subrTbl = GaraIt_subrs;
    tblLen = sizeof(GaraIt_subrs)/sizeof(GaraIt_subrs[0]);
  }
  else if (h->callbacks.strcmp(fontName, "JimboMM") == 0)
  {
    subrTbl = Jimbo_subrs;
    tblLen = sizeof(Jimbo_subrs)/sizeof(Jimbo_subrs[0]);
  }

  if (tblLen == 0) /* Not a font with transitional designs. */
    return;

  for (i = 0; i < tblLen; i++)
  {
    InitCharstr(h);
    NewT1Subr(h);
    XCF_LookUpTableEntry(h, &h->dict.localSubrs, subrTbl[i]);
#ifdef T13
    if (h->dict.fontType == 13)
      XT13_ProcessCharstr(h, 0, &endCharFound, true);
    else
#endif
      ProcessCharstr(h, 0, &endCharFound, true);
  }
}
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_cff.c ===
/* @(#)CM_VerSion xcf_cff.c atm09 1.3 16499.eco sum= 57954 atm09.002 */
/* @(#)CM_VerSion xcf_cff.c atm08 1.7 16343.eco sum= 21676 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1995-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

/***********************************************************************
Original version: John Felton, Dec 12 1995
************************************************************************/

/* -------------------------------------------------------------------------
     Header Includes
  --------------------------------------------------------------------- */
#ifdef __cplusplus
extern "C" {
#endif
#include "xcf_pub.h"
#include "xcf_priv.h"

#ifdef T13
#include "xcf_t13.h"
#endif

char PTR_PREFIX *stdStrIndex[] = {
#include "xcf_sstr.h"
};

static StringID isoAdobeCharset[] = {
#include "xcf_isoc.h"
};

static StringID expertCharset[] = {
#include "xcf_expc.h"
};

static StringID expertSubsetCharset[] = {
#include "xcf_exsc.h"
};

static StringID stdEncoding[] = {
#include "xcf_stde.h"
};

static StringID expertEncoding[] = {
#include "xcf_expe.h"
};

void XCF_ReadBlock(XCF_Handle h, Offset pos, Card32 length)
{
   if (!h->callbacks.getBytes(&h->inBuffer.start, pos, (short int) length, h->callbacks.getBytesHook))
      XCF_FATAL_ERROR(h, XCF_GetBytesCallbackFailure, "Read block error.", 0);
   h->inBuffer.pos = h->inBuffer.start;
   h->inBuffer.end = (unsigned char PTR_PREFIX *)h->inBuffer.start + length;
   h->inBuffer.blockOffset = pos;
   h->inBuffer.blockLength = length;
}

void XCF_LookUpTableEntry(XCF_Handle h, IndexDesc PTR_PREFIX *pIndex, CardX index)
{
   Card32 offset, nextOffset;
   Card16 length;

   offset = pIndex->offsetArrayOffset + (pIndex->offsetSize*index);
   XCF_ReadBlock(h, offset, pIndex->offsetSize*2);
   offset = XCF_Read(h, pIndex->offsetSize);
   nextOffset = XCF_Read(h, pIndex->offsetSize);
   length = (Card16) (nextOffset - offset);
   XCF_ReadBlock(h, pIndex->dataOffset + offset, length);
}

static Offset ReadTableInfo(XCF_Handle h, Offset pos, IndexDesc PTR_PREFIX *pIndex)
{
   XCF_ReadBlock(h, pos, 2);
   pIndex->count = XCF_Read2(h);
   if (pIndex->count == 0)
   {
      pIndex->offsetSize = 1;
      pIndex->offsetArrayOffset = 0;
      pIndex->dataOffset = 0;
      return pos + 2;
   }

   XCF_ReadBlock(h, pos + 2, 1);
   pIndex->offsetSize = XCF_Read1(h);
   if ((pIndex->offsetSize == 0) || (pIndex->offsetSize > 4))
      XCF_FATAL_ERROR(h, XCF_InvalidOffsetSize, "Invalid offset size in table.", pIndex->offsetSize);
   pIndex->offsetArrayOffset = pos + 3;
   pIndex->dataOffset = pIndex->offsetArrayOffset + ((pIndex->count+1)*pIndex->offsetSize) - 1;;
   XCF_LookUpTableEntry(h, pIndex, pIndex->count-1);
   return h->inBuffer.blockOffset + h->inBuffer.blockLength;
}

void XCF_LookUpString(XCF_Handle h, StringID sid, char PTR_PREFIX * PTR_PREFIX *str, Card16 PTR_PREFIX *length)
{
   if (sid < ARRAY_LEN(stdStrIndex))
   {
      *str = stdStrIndex[sid];
      *length = h->callbacks.strlen(*str);
   }
   else
   {
      sid -= ARRAY_LEN(stdStrIndex);
      XCF_LookUpTableEntry(h, &h->fontSet.strings, sid);
      *length = (Card16) h->inBuffer.blockLength;
      *str = (char *) h->inBuffer.start;
   }
}

Card16 XCF_CalculateSubrBias(CardX subrCount)
{
   if (subrCount < 1240)
      return(107);
   else if (subrCount < 33900)
      return(1131);
      return(32768);
}

/* Returns 1 if this is a font with transitional designs, 0 otherwise. */
int XCF_TransDesignFont(XCF_Handle h)
{
  char fontName[512];

  XCF_FontName(h, (unsigned short int)h->fontSet.fontIndex, fontName,
               (unsigned short int)512);
  if (h->callbacks.strcmp(fontName, "ITCGaramondMM") == 0 ||
      h->callbacks.strcmp(fontName, "ITCGaramondMM-It") == 0 ||
      h->callbacks.strcmp(fontName, "JimboMM") == 0)
    return 1;
  return 0;
}

void ProcessOneCharString(XCF_Handle h, CardX i)
{
#if HAS_COOLTYPE_UFL == 1
  /* Characters that have transitional designs are handled separately
     because there isn't a general mechanism that can deal with these
     special characters. The charstrings are hardcoded (yech!) and
     written out directly by the TransDesignChar procedure.
   */
  if (!CIDFONT && XC_TransDesignChar(h, i))
    return;
#endif

  XCF_LookUpTableEntry(h, &h->fontSet.charStrings, i);
  if (CIDFONT)
  {
    Card8 fd = XCF_GetFDIndex(h, i);
   h->cstr.languageGroup = h->type1.cid.languageGroup[fd];
   h->dict.nominalWidthX = h->type1.cid.nominalWidthX[fd];
      h->dict.defaultWidthX = h->type1.cid.defaultWidthX[fd];
    h->dict.localSubrs = h->type1.cid.localSubrs[fd];
    h->dict.localSubrBias = h->type1.cid.localSubrBias[fd];
    if ((h->options.outputCharstrType != 2) && (h->dict.fontType == 1))
      h->type1.charStrs.cnt = i;
  }
  else
    h->cstr.languageGroup = (CardX) h->dict.languageGroup;
  XC_ProcessCharstr(h);
}

static void ProcessCharStrings(XCF_Handle h)
{
   CardX i;
   if ((CIDFONT) || ((h->options.outputCharstrType != 2) && (h->dict.fontType != 1)))
   {
    if (CIDFONT || !h->options.subrFlatten)
    {
        for (i=0; i<h->fontSet.charStrings.count; ++i)
      {
        ProcessOneCharString(h, i);
        if (CIDFONT)
          XT1_CIDWriteCharString(h);
      }
        XC_CleanUp(h);
    }
   }
}

static void SaveArgs(
                XCF_Handle h,
                IntX PTR_PREFIX *countDest,
                Fixed PTR_PREFIX *pArgArray,
                Card8 PTR_PREFIX *argList,
                Card16 opCode,
                IntX argCount,
                IntX min,
                IntX max,
                boolean type2)
{
   IntX i;
  boolean fracType =
    (opCode == cff_BlueScale) || (opCode == cff_ExpansionFactor);

   if (*countDest)   /* Only save if entry has not already been saved */
      return;
   if (argCount < min)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too few arguments for operator", opCode);
   if (argCount > max)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too many arguments for operator", opCode);
   *countDest = argCount;
   if (type2)
   {
      for (i=0; i<argCount; i++)
         *pArgArray++ = fracType ? h->dict.mmDictArg[i] << 14 : h->dict.mmDictArg[i];
      h->dict.mmDictArgCount = 0;
   }
   else
      XCF_SaveDictArgumentList(h, pArgArray, argList, argCount, fracType);
}

static void SaveIntArgs(
                XCF_Handle h,
                IntX PTR_PREFIX *countDest,
                Int32 PTR_PREFIX *pArgArray,
                Card8 PTR_PREFIX *argList,
                Card16 opCode,
                IntX argCount,
                IntX min,
                IntX max,
                boolean type2)
{
   if (*countDest)   /* Only save if entry has not already been saved */
      return;
   if (argCount < min)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too few arguments for operator", opCode);
   if (argCount > max)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too many arguments for operator", opCode);
   *countDest = argCount;
   if (type2)
    /* Can't have more than 1 value for UniqueID and UIDBase. */
    XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too many arguments for operator", opCode);
   else
      XCF_SaveDictIntArgumentList(h, pArgArray, argList, argCount);
}

static void SaveFontMatrixStr(
                XCF_Handle h,
                IntX PTR_PREFIX *countDest,
                char (PTR_PREFIX *pArgArray)[FONT_MATRIX_ENTRY_SIZE],
                Card8 PTR_PREFIX *argList,
                Card16 opCode,
                IntX argCount,
                IntX min,
                IntX max)
{
   if (*countDest)   /* Only save if entry has not already been saved */
      return;
   if (argCount < min)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too few arguments for operator", opCode);
   if (argCount > max)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too many arguments for operator", opCode);
   *countDest = argCount;
  XCF_SaveFontMatrixStr(h, pArgArray, argList, argCount);
}

static void SaveStrArgs(
                XCF_Handle h,
                IntX PTR_PREFIX *countDest,
                char PTR_PREFIX *pArgArray,
                Card8 PTR_PREFIX *argList,
                Card16 opCode,
                IntX argCount,
                IntX min,
                IntX max)
{
   if (*countDest)   /* Only save if entry has not already been saved */
      return;
   if (argCount < min)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too few arguments for operator", opCode);
   if (argCount > max)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too many arguments for operator", opCode);
   *countDest = argCount;
  XCF_SaveStrArgs(h, pArgArray, argList, argCount);
}

static void SaveDictEntry(XCF_Handle h, Card16 opCode, Card8 PTR_PREFIX *argList, IntX argCount, boolean type2)
{

   switch (opCode)
   {
   case cff_BlendAxisTypes :
      SaveIntArgs(h, &h->dict.blendAxisTypesCount, (Int32 *)&h->dict.blendAxisTypes[0], argList, opCode, argCount, 1, MAX_MM_AXES, type2);
      break;
   case cff_MultipleMaster :
   {
   IntX i;
      SaveArgs(h, &h->dict.userDesignVectorCount, &h->dict.userDesignVector[0],
                   argList, opCode, argCount, 2, MAX_MM_AXES + 4, type2);
      h->dict.numberOfMasters = FIXED_TO_INT(h->dict.userDesignVector[0]);
    h->dict.userDesignVectorCount = h->dict.normDesignVectorCount = argCount - 4;
      for (i=0; i<h->dict.userDesignVectorCount; ++i)
         h->dict.userDesignVector[i] = h->dict.userDesignVector[i+1];
    i += 1;
      h->dict.lenBuildCharArray = FIXED_TO_INT(h->dict.userDesignVector[i++]);
    h->dict.lenBuildCharArrayCount = h->dict.lenBuildCharArray == 0 ? 0 : 1;
    h->dict.ndv = FIXED_TO_INT(h->dict.userDesignVector[i++]);
    h->dict.cdv = FIXED_TO_INT(h->dict.userDesignVector[i++]);
   }
      break;
   case cff_XUID :
      SaveIntArgs(h, &h->dict.xUIDCount, (Int32 *)&h->dict.xUID[0], argList, opCode, argCount, 1, MAX_XUID_ENTRIES, type2);
      break;
   case cff_FontBBox :
      SaveArgs(h, &h->dict.fontBBoxCount, &h->dict.fontBBox[0], argList, opCode, argCount, 4, MAX_FONTBBOX_ENTRIES, type2);
      break;
   case cff_StdHW :
      SaveArgs(h, &h->dict.stdHWCount, &h->dict.stdHW[0], argList, opCode, argCount, 1, MAX_STD_HW_ENTRIES, type2);
      break;
   case cff_StdVW :
      SaveArgs(h, &h->dict.stdVWCount, &h->dict.stdVW[0], argList, opCode, argCount, 1, MAX_STD_VW_ENTRIES, type2);
      break;
   case cff_BlueValues :
      SaveArgs(h, &h->dict.blueValuesCount, &h->dict.blueValues[0], argList, opCode, argCount, 1, MAX_BLUE_VALUE_ENTRIES, type2);
      break;
   case cff_OtherBlues :
      SaveArgs(h, &h->dict.otherBluesCount, &h->dict.otherBlues[0], argList, opCode, argCount, 1, MAX_OTHER_BLUES_ENTRIES, type2);
      break;
   case cff_FamilyBlues :
      SaveArgs(h, &h->dict.familyBluesCount, &h->dict.familyBlues[0], argList, opCode, argCount, 1, MAX_FAMILY_BLUES_ENTRIES, type2);
      break;
   case cff_FamilyOtherBlues :
      SaveArgs(h, &h->dict.familyOtherBluesCount, &h->dict.familyOtherBlues[0], argList, opCode, argCount, 1, MAX_FAMILY_OTHER_BLUES_ENTRIES, type2);
      break;
   case cff_UniqueID :
      SaveIntArgs(h, &h->dict.uniqueIDCount, (Int32 *)&h->dict.uniqueID, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_version :
      SaveIntArgs(h, &h->dict.versionCount, (Int32 *)&h->dict.version, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_Encoding :
      SaveIntArgs(h, &h->dict.encodingCount, (Int32 *)&h->dict.encoding, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_Subrs :
      SaveIntArgs(h, &h->dict.subrsCount, (Int32 *)&h->dict.subrs, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_FullName :
      SaveIntArgs(h, &h->dict.fullNameCount, (Int32 *)&h->dict.fullName, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_FamilyName :
      SaveIntArgs(h, &h->dict.familyNameCount, (Int32 *)&h->dict.familyName, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_BaseFontName :
      SaveIntArgs(h, &h->dict.baseFontNameCount, (Int32 *)&h->dict.baseFontName, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_BaseFontBlend :
      SaveArgs(h, &h->dict.baseFontBlendCount, &h->dict.baseFontBlend[0], argList, opCode, argCount, 1, MAX_BASE_FONT_BLEND_ENTRIES, type2);
      break;
   case cff_Weight :
      SaveIntArgs(h, &h->dict.weightCount, (Int32 *)&h->dict.weight, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_Private :
      SaveIntArgs(h, &h->dict.privateDictCount, (Int32 *)&h->dict.privateDict[0], argList, opCode, argCount, PRIVATE_DICT_ENTRIES, PRIVATE_DICT_ENTRIES, type2);
      h->fontSet.fontPrivDictInfo.offset = (Offset) h->dict.privateDict[1];
      h->fontSet.fontPrivDictInfo.size = (short int) h->dict.privateDict[0];
      break;
   case cff_charset :
      SaveIntArgs(h, &h->dict.charsetCount, (Int32 *)&h->dict.charset, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_CharStrings :
      SaveIntArgs(h, &h->dict.charStringsCount, (Int32 *)&h->dict.charStrings, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_nominalWidthX :
      SaveArgs(h, &h->dict.nominalWidthXCount, &h->dict.nominalWidthX, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_defaultWidthX :
      SaveArgs(h, &h->dict.defaultWidthXCount, &h->dict.defaultWidthX, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_Notice :
      SaveIntArgs(h, &h->dict.noticeCount, (Int32 *)&h->dict.notice, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_StemSnapH :
      SaveArgs(h, &h->dict.stemSnapHCount, &h->dict.stemSnapH[0], argList, opCode, argCount, 1, MAX_STEM_SNAP_H_ENTRIES, type2);
      break;
   case cff_StemSnapV :
      SaveArgs(h, &h->dict.stemSnapVCount, &h->dict.stemSnapV[0], argList, opCode, argCount, 1, MAX_STEM_SNAP_V_ENTRIES, type2);
      break;
   case cff_BlueScale :
      SaveArgs(h, &h->dict.blueScaleCount, &h->dict.blueScale[0], argList, opCode, argCount, 1, MAX_BLUE_SCALE_ENTRIES, type2);
      break;
   case cff_BlueFuzz :
      SaveArgs(h, &h->dict.blueFuzzCount, &h->dict.blueFuzz[0], argList, opCode, argCount, 1, MAX_BLUE_FUZZ_ENTRIES, type2);
      break;
   case cff_BlueShift :
      SaveArgs(h, &h->dict.blueShiftCount, &h->dict.blueShift[0], argList, opCode, argCount, 1, MAX_BLUE_SHIFT_ENTRIES, type2);
      break;
   case cff_ForceBold :
      SaveArgs(h, &h->dict.forceBoldCount, &h->dict.forceBold[0], argList, opCode, argCount, 1, MAX_FORCE_BOLD_ENTRIES, type2);
      break;
   case cff_FontMatrix :
      SaveFontMatrixStr(h, &h->dict.fontMatrixCount, h->dict.fontMatrix, argList, opCode, argCount, FONT_MATRIX_ENTRIES, FONT_MATRIX_ENTRIES);
      break;
   case cff_StrokeWidth :
      SaveArgs(h, &h->dict.strokeWidthCount, &h->dict.strokeWidth[0], argList, opCode, argCount, 1, MAX_MM_DESIGNS, type2);
      break;
   case cff_ExpansionFactor :
      SaveArgs(h, &h->dict.expansionFactorCount, &h->dict.expansionFactor, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_ForceBoldThreshold :
      SaveArgs(h, &h->dict.forceBoldThresholdCount, &h->dict.forceBoldThreshold, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_initialRandomSeed :
      SaveArgs(h, &h->dict.initialRandomSeedCount, &h->dict.initialRandomSeed, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_lenIV :
      SaveIntArgs(h, &h->dict.lenIVCount, &h->dict.lenIV, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_PaintType :
      SaveArgs(h, &h->dict.paintTypeCount, &h->dict.paintType, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_LanguageGroup :
      SaveIntArgs(h, &h->dict.languageGroupCount, (Int32 *)&h->dict.languageGroup, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_ItalicAngle :
      SaveArgs(h, &h->dict.italicAngleCount, &h->dict.italicAngle[0], argList, opCode, argCount, 1, MAX_MM_DESIGNS, type2);
      break;
   case cff_isFixedPitch :
      SaveArgs(h, &h->dict.isFixedPitchCount, &h->dict.isFixedPitch[0], argList, opCode, argCount, 1, MAX_MM_DESIGNS, type2);
      break;
   case cff_UnderlinePosition :
      SaveArgs(h, &h->dict.underlinePositionCount, &h->dict.underlinePosition[0], argList, opCode, argCount, 1, MAX_MM_DESIGNS, type2);
      break;
   case cff_UnderlineThickness :
      SaveArgs(h, &h->dict.underlineThicknessCount, &h->dict.underlineThickness[0], argList, opCode, argCount, 1, MAX_MM_DESIGNS, type2);
      break;
   case cff_PostScript :
      SaveIntArgs(h, &h->dict.embeddedPostscriptCount, (Int32 *)&h->dict.embeddedPostscript, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_Copyright :
      SaveIntArgs(h, &h->dict.copyrightCount, (Int32 *)&h->dict.copyright, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_CharstringType :
      SaveIntArgs(h, &h->dict.fontTypeCount, &h->dict.fontType, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_FontName :
      SaveIntArgs(h, &h->dict.fdFontNameCount, (Int32 *)&h->dict.fdFontName, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_CIDFontVersion :
      SaveStrArgs(h, &h->dict.cidFontVersionCount, h->dict.cidFontVersion, argList, opCode, argCount, 1, 1);
      break;
   case cff_CIDFontType :
      SaveIntArgs(h, &h->dict.cidFontTypeCount, &h->dict.cidFontType, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_ROS :
      SaveIntArgs(h, &h->dict.ROSCount, (Int32 *)&h->dict.ROS[0], argList, opCode,
                        argCount, 3, 3, type2);
      break;
   case cff_UIDBase :
      SaveIntArgs(h, &h->dict.uidBaseCount, (Int32 *)&h->dict.uidBase, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_FDArray :
      SaveIntArgs(h, &h->dict.cidFDArrayCount, &h->dict.cidFDArray, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_FDSelect :
      SaveIntArgs(h, &h->dict.cidFDIndexCount, &h->dict.cidFDIndex, argList, opCode, argCount, 1, 1, type2);
      break;
   case cff_SyntheticBase :
      SaveArgs(h, &h->dict.syntheticBaseCount, &h->dict.syntheticBase, argList,
                   opCode, argCount, 1, 1, type2);
    break;
   case cff_CIDCount :
      SaveIntArgs(h, &h->dict.cidCountCount, &h->dict.cidCount, argList, opCode, argCount, 1, 1, type2);
      break;
#ifdef XCF_DEVELOP
   default :
      XCF_FATAL_ERROR(h, XCF_InternalError, "Development Error, Unknown Dictionary Operator", opCode);
      break;
#endif
   }

}

static void SaveT2Args(XCF_Handle h, Card8 PTR_PREFIX *argList, IntX argCount)
{
   if (argCount == 0)
      return;
   XCF_SaveDictArgumentList(h, &h->dict.mmDictArg[h->dict.mmDictArgCount],
                                        argList, argCount, false);
   h->dict.mmDictArgCount += argCount;
}


static void SaveT2BlendArgs(XCF_Handle h, Card8 PTR_PREFIX *argList, IntX argCount)
{
   IntX blendCount;
   Fixed argArray[T2_MAX_OP_STACK];
   IntX i, j, deltaIndex;

   if (argCount == 0)
      return;

   if (argCount > T2_MAX_OP_STACK)
      XCF_FATAL_ERROR(h, XCF_InvalidDictArgumentCount, "Too many arguments", argCount);
   XCF_SaveDictArgumentList(h, &argArray[0], argList, argCount, false);
   blendCount = FIXED_TO_INT(argArray[argCount-1]);

   deltaIndex = blendCount;
   for (i=0; i<blendCount; i++)
   {
      h->dict.mmDictArg[h->dict.mmDictArgCount++] = argArray[i];
      for (j=0; j<h->dict.numberOfMasters-1; j++)
      {
         h->dict.mmDictArg[h->dict.mmDictArgCount++] = argArray[i] + argArray[deltaIndex++];
      }
   }
}

void XCF_ReadDictionary(XCF_Handle h)
{
   Card16 opCode;
   Card8 PTR_PREFIX *argList;
   IntX argCount;
   boolean t2Active = false;

   while (h->inBuffer.pos < h->inBuffer.end)
   {
      argList = h->inBuffer.pos; /* Save Position */
      argCount = XCF_FindNextOperator(h, &opCode, true);
      if (opCode != cff_T2)
         SaveDictEntry(h, opCode, argList, argCount, false);
      else
      {  /* Process T2 charstring */
         h->dict.mmDictArgCount = 0;
         while ((t2Active) || (opCode == cff_T2))
         {
            if (opCode == cff_T2)
            {
               t2Active = true;
               SaveT2Args(h, argList, argCount);
            }
            else if (opCode == tx_endchar)
            {
               t2Active = false;
            }
            else if (opCode == t2_blend)
            {
               SaveT2BlendArgs(h, argList, argCount);
            }

         argList = h->inBuffer.pos; /* Save Position */
         argCount = XCF_FindNextOperator(h, &opCode, true);
         }
         SaveDictEntry(h, opCode, (Card8 *)NULL, h->dict.mmDictArgCount, true);
      }
   }
}

static void SetDefault(XCF_Handle h, IntX *pCount, Fixed *pValue, const Fixed defaultValue)
{
   if (!*pCount)
   {
      *pCount = 1;
      *pValue = defaultValue;
   }
}

#define BLUE_SCALE_DEFAULT 0x0289374CL /* 0.039625 */
#define EXP_FACTOR_DEFAULT 0x03D70A3EL /* 0.06 */

static void AssignDictionaryDefaults(XCF_Handle h)
{
   SetDefault(h, &h->dict.fontTypeCount, (Fixed *)&h->dict.fontType, 2);
   SetDefault(h, &h->dict.lenIVCount, (Fixed *)&h->dict.lenIV, -1);

   SetDefault(h, &h->dict.isFixedPitchCount, &h->dict.isFixedPitch[0], 0);
   SetDefault(h, &h->dict.italicAngleCount, &h->dict.italicAngle[0], 0);
   SetDefault(h, &h->dict.underlinePositionCount, &h->dict.underlinePosition[0], INT_TO_FIXED(-100));
   SetDefault(h, &h->dict.underlineThicknessCount, &h->dict.underlineThickness[0], INT_TO_FIXED(50));
   SetDefault(h, &h->dict.encodingCount, (Fixed *) &h->dict.encoding, 0);
   SetDefault(h, &h->dict.paintTypeCount, &h->dict.paintType, 0);
   SetDefault(h, &h->dict.strokeWidthCount, &h->dict.strokeWidth[0], 0);
   SetDefault(h, &h->dict.blueScaleCount, &h->dict.blueScale[0], BLUE_SCALE_DEFAULT);
   SetDefault(h, &h->dict.blueShiftCount, &h->dict.blueShift[0], INT_TO_FIXED(7));
   SetDefault(h, &h->dict.blueFuzzCount, &h->dict.blueFuzz[0], FIXEDONE);
   SetDefault(h, &h->dict.expansionFactorCount, &h->dict.expansionFactor, EXP_FACTOR_DEFAULT);
   SetDefault(h, &h->dict.initialRandomSeedCount, &h->dict.initialRandomSeed, 0);
   SetDefault(h, &h->dict.cidFontTypeCount, (Fixed *)&h->dict.cidFontType, 0);
   /* xxx Currently the CIDFontType is not written in the cff since it must be zero. */
   SetDefault(h, &h->dict.cidCountCount, (Fixed *)&h->dict.cidCount, 8720);

   if (!h->dict.fontMatrixCount)
   {
      h->dict.fontMatrixCount = 6;
      h->callbacks.memcpy(h->dict.fontMatrix[0], "0.001", 5);
    h->callbacks.memcpy(h->dict.fontMatrix[1], "0", 1);
    h->callbacks.memcpy(h->dict.fontMatrix[2], "0", 1);
      h->callbacks.memcpy(h->dict.fontMatrix[3], "0.001", 5);
    h->callbacks.memcpy(h->dict.fontMatrix[4], "0", 1);
    h->callbacks.memcpy(h->dict.fontMatrix[5], "0", 1);
   }
}


static void ProcessDictionaryData(XCF_Handle h, boolean setDefaults)
{
   if (setDefaults)
      AssignDictionaryDefaults(h);

   if (h->dict.charStringsCount != 0)
      ReadTableInfo(h, (Offset) h->dict.charStrings, &h->fontSet.charStrings);
   else
      XCF_FATAL_ERROR(h, XCF_NoCharstringsFound, "No charstring offset found in dictionary", 0 );
   if (h->dict.subrsCount != 0)
  {
    /* The local subrs offset is relative to the private dict data. */
      ReadTableInfo(h,
                 (Offset) (h->dict.subrs + h->fontSet.fontPrivDictInfo.offset),
                 &h->dict.localSubrs);
    h->dict.localSubrBias = XCF_CalculateSubrBias(h->dict.localSubrs.count);
  }
   else
      h->dict.localSubrs.count = 0;
}


#if 0
static void InitFontSetValues(XCF_Handle h)
{
}

static void InitClientOptions(XCF_Handle h)
{
  h->options.fontIndex = 0;
  h->options.uniqueIDMethod = XCF_KEEP_UID;
  h->options.subrFlatten = false;
   h->options.lenIV = 4;
   h->options.hexEncoding = true;
   h->options.eexecEncryption = true;
   h->options.outputCharstrType = 1;
   h->options.maxBlockSize = MAX_OUT_BUFFER;
  h->options.dlOptions.useSpecialEncoding = 0;
  h->options.dlOptions.encodeName = 0;
  h->options.dlOptions.fontName = 0;
}
#endif

static void CopyOptionStrings(XCF_Handle h,
                              XCF_ClientOptions PTR_PREFIX *options)
{
  char PTR_PREFIX *str;
  Card32 cb;

  if (options->dlOptions.encodeName)
  {
    cb = h->callbacks.strlen((char *)options->dlOptions.encodeName) + 1;
    str = 0;
    if (!h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&str, cb,
                               h->callbacks.allocateHook))
      XCF_FATAL_ERROR(h, XCF_MemoryAllocationError,
        "Failure to allocate memory for encode name option", cb);
    h->callbacks.xcfSprintf(str, cb / sizeof(char), "%s", options->dlOptions.encodeName);
    h->options.dlOptions.encodeName = (unsigned char PTR_PREFIX *) str;
  }
  if (options->dlOptions.fontName)
  {
    cb = h->callbacks.strlen((char *)options->dlOptions.fontName) + 1;
    str = 0;
    if (!h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&str, cb,
                               h->callbacks.allocateHook))
      XCF_FATAL_ERROR(h, XCF_MemoryAllocationError,
        "Failure to allocate memory for font name option", cb);
    h->callbacks.xcfSprintf(str, cb / sizeof(char), "%s", options->dlOptions.fontName);
    h->options.dlOptions.fontName = (unsigned char PTR_PREFIX *)str;
  }
}

static void SetClientOptions(XCF_Handle h,
                             XCF_ClientOptions PTR_PREFIX *options)
{
  if (!options)
    return;
  h->options.uniqueIDMethod = options->uniqueIDMethod;
  h->options.uniqueID = options->uniqueID;
  h->options.subrFlatten = options->subrFlatten;
   h->options.lenIV = options->lenIV;
   h->options.hexEncoding = options->hexEncoding;
   h->options.eexecEncryption = options->eexecEncryption;
   h->options.outputCharstrType = options->outputCharstrType;
  h->options.dlOptions.otherSubrNames = options->dlOptions.otherSubrNames;
   h->options.maxBlockSize = MIN(options->maxBlockSize, MAX_OUT_BUFFER);
  h->options.dlOptions.useSpecialEncoding =
    options->dlOptions.useSpecialEncoding;
  h->options.dlOptions.notdefEncoding = options->dlOptions.notdefEncoding;

  CopyOptionStrings(h, options);
}

static void InitOutBuffer(XCF_Handle h)
{
   h->outBuffer.eexecOn = false;
   h->outBuffer.eexecKey = 0;
   h->outBuffer.charsOnLine = 0;
   h->outBuffer.outBufferCount = 0;
   h->outBuffer.lenIVInitialBytes[0] = 'x';
   h->outBuffer.lenIVInitialBytes[1] = 'x';
   h->outBuffer.lenIVInitialBytes[2] = 'x';
   h->outBuffer.lenIVInitialBytes[3] = 'x';
   h->outBuffer.eexecInitialBytes[0] = 'y';
   h->outBuffer.eexecInitialBytes[1] = 'o';
   h->outBuffer.eexecInitialBytes[2] = 'g';
   h->outBuffer.eexecInitialBytes[3] = 'i';
}

static void InitInBuffer(XCF_Handle h)
{
   h->inBuffer.start = (Card8 *)NULL;
   h->inBuffer.end = (Card8 *)NULL;
   h->inBuffer.pos = (Card8 *)NULL;
   h->inBuffer.blockOffset = 0;
   h->inBuffer.blockLength = 0;
}

static void InitDownloadRecord(XCF_Handle h)
{
  h->dl.glyphs = (Card8 *)NULL;
  h->dl.cSeacs = 0;
  h->dl.state = XCF_DL_CREATE;
}

static void ClearDictionaryData(XCF_Handle h)
{
   h->callbacks.memset(&h->dict, 0, sizeof(DictEntriesStruct));
}

static unsigned long int DA_Allocate(void PTR_PREFIX * PTR_PREFIX *pBlock, unsigned long int size, void PTR_PREFIX *clientHook )
{

   XCF_Handle h = (XCF_Handle) clientHook;

   if (!h->callbacks.allocate(pBlock, size, h->callbacks.allocateHook))
      XCF_FATAL_ERROR(h, XCF_MemoryAllocationError, "Dynamic Array Allocation Failure.", size);
   return true;
}


static void InitType1(XCF_Handle h)
{
  /* Only allocate enough space for the best scenario which will flatten
   * both subrs and charstrings */
   da_INIT(h->type1.charStrs, 2000, 20000,DA_Allocate, h);
   da_INIT(h->type1.charStrOffsets, 10, 500,DA_Allocate, h);
   da_INIT(h->type1.subrs, 300, 8000,DA_Allocate, h);
   da_INIT(h->type1.subrOffsets, 10, 500,DA_Allocate, h);
   da_INIT(h->type1.charset, 400, 400,DA_Allocate, h);
}


static int InRAMGetBytes( unsigned char PTR_PREFIX * PTR_PREFIX *ppData, long int position, unsigned short int length, void PTR_PREFIX *clientHook )
{
   XCF_Handle h = (XCF_Handle) clientHook;
   if ((Card32)(position + length) > h->callbacks.fontLength)
      return false;
   *ppData = (Card8 PTR_PREFIX *) h->callbacks.pFont + position;
   return true;
}


static void InitHandle(
                  XCF_Handle h,                       /* Out */
                  XCF_CallbackStruct PTR_PREFIX *pCallbacks)   /* In */
{
   pCallbacks->memset(h, 0, sizeof(*h));
   h->callbacks = *pCallbacks;
   if (h->callbacks.getBytes == (XCF_GetBytesFromPosFunc)NULL)
   {
      h->callbacks.getBytes = InRAMGetBytes;
      h->callbacks.getBytesHook = h;
   }
/* InitFontSetValues(h); */
/*    InitClientOptions(h); */
   InitOutBuffer(h);
   InitInBuffer(h);
   InitType1(h);
  InitDownloadRecord(h);
}

static void ProcessCharset(XCF_Handle h)
{
   CardX i;
   CardX    formatType;

   if ((!h->dict.charsetCount) || (h->dict.charset == cff_ISOAdobeCharset))
   {
      h->type1.pCharset = isoAdobeCharset;
      h->type1.charsetSize = ARRAY_LEN(isoAdobeCharset);
   }
   else if (h->dict.charset == cff_ExpertCharset)
   {
      h->type1.pCharset = expertCharset;
      h->type1.charsetSize = ARRAY_LEN(expertCharset);
   }
   else if (h->dict.charset == cff_ExpertSubsetCharset)
   {
      h->type1.pCharset = expertSubsetCharset;
      h->type1.charsetSize = ARRAY_LEN(expertSubsetCharset);
   }
   else
   {
      h->type1.charset.cnt = 0; /* clear charset */
      XCF_ReadBlock(h, (Offset) h->dict.charset, 1);
      formatType = XCF_Read1(h);
      if (formatType == 0)
      {
         XCF_ReadBlock(h, (Offset) h->dict.charset + 1, (h->fontSet.charStrings.count-1)*2);
         for (i=0; i<h->fontSet.charStrings.count-1; ++i)
            *da_NEXT(h->type1.charset) = XCF_Read2(h);
      }
      else /* (formatType is 1 or 2 ) */
      {
         Offset charsetDataOffset = (Offset) h->dict.charset + 1;
         CardX glyphCount = 0;
         CardX nLeftSize = (formatType == 1) ? 1 : 2;
         while (glyphCount < h->fontSet.charStrings.count - 1)
         {
            StringID firstSID;
            CardX numberOfSIDsInRange;
            XCF_ReadBlock(h, charsetDataOffset, 2 + nLeftSize);
            charsetDataOffset += 2 + nLeftSize;
            firstSID = XCF_Read2(h);
            numberOfSIDsInRange = (CardX) XCF_Read(h, nLeftSize) + 1;
            for (i=0; i<numberOfSIDsInRange; ++i)
            {
               *da_NEXT(h->type1.charset) = firstSID + i;
               glyphCount++;
            }
         } /* end for */
      }
      h->type1.pCharset = h->type1.charset.array;
      h->type1.charsetSize = h->fontSet.charStrings.count-1;
   }
}

static enum XCF_Result ProcessFDIndex(XCF_Handle h)
{
   Card16   i = 0;
   CardX formatType;

   if (!h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&h->type1.cid.pFDIndex,
         h->type1.charsetSize + 1, h->callbacks.allocateHook))
      return XCF_MemoryAllocationError;

   XCF_ReadBlock(h, (Offset) h->dict.cidFDIndex, 1);
   formatType = XCF_Read1(h);
   switch (formatType)
   {
   case 0:
      XCF_ReadBlock(h, (Offset) h->dict.cidFDIndex + 1, h->type1.charsetSize + 1);
      for (i = 0 ; i < h->type1.charsetSize + 1 ; ++i)
         h->type1.cid.pFDIndex[i] = XCF_Read1(h);
      break;

   case 2:
      {
      FDIndex fd;
      Card16 count;
      Offset dataOffset = (Offset) h->dict.cidFDIndex + 1;
      while (i < h->type1.charsetSize + 1)
         {
         XCF_ReadBlock(h, dataOffset, 3);
         dataOffset += 3;
         fd = XCF_Read1(h);
         count = XCF_Read2(h) + 1;
         while (count-- != 0)
            h->type1.cid.pFDIndex[i++] = fd;
         }
      }
      break;
  case 3:
    {
      Offset dataOffset = (Offset) h->dict.cidFDIndex + 1;
      Card16 nRanges; /* number of ranges defined */
      Card16 first, last; /* first and last glyph index in range */
      FDIndex fd;
      Card16 j;
      XCF_ReadBlock(h, dataOffset, 4);
      dataOffset += 4;
      nRanges = XCF_Read2(h);
      first = XCF_Read2(h);
      for (i = 0; i < nRanges; i++)
      {
        XCF_ReadBlock(h, dataOffset, 3);
        dataOffset += 3;
        fd = XCF_Read1(h);
        last = XCF_Read2(h);
        for (j = first; j < last; j++)
          h->type1.cid.pFDIndex[j] = fd;
        first = last;
      }
    }
    break;
   default:
      return XCF_IndexOutOfRange;
   }
   return XCF_Ok;
}

Card8 XCF_GetFDIndex(XCF_Handle h, Int32 code)
   {
   if (!h->type1.cid.pFDIndex)
      XCF_FATAL_ERROR(h, XCF_EarlyEndOfData, "no FDIndex", code);
   if (code > (IntX) h->type1.charsetSize)
      XCF_FATAL_ERROR(h, XCF_EarlyEndOfData, "FDIndex error", code);
   return h->type1.cid.pFDIndex[code];
   }

static void ProcessEncoding(XCF_Handle h)
{
   CardX i, j;
   CardX formatType;
   CardX numberOfElements;
   Card8 characterCode;
   CardX glyphCount;
   Card8 firstCode;
   CardX numberOfCodesInRange;
   Offset extraEntries;


   if ((!h->dict.encodingCount) || (h->dict.encoding == cff_StandardEncoding))
      h->type1.pEncoding = stdEncoding;
   else if (h->dict.encoding == cff_ExpertEncoding)
      h->type1.pEncoding = expertEncoding;
   else
   {
      XCF_ReadBlock(h, (Offset) h->dict.encoding, 2);
      formatType = XCF_Read1(h);
      numberOfElements = XCF_Read1(h);
      if ((formatType == 0) || (formatType == 128))
      {
         XCF_ReadBlock(h, (Offset) h->dict.encoding + 2, numberOfElements);
         for (i=0; i<numberOfElements; ++i)
         {
            characterCode = XCF_Read1(h);
            h->type1.encoding[characterCode] = h->type1.pCharset[i];
         }
         extraEntries = (Offset) h->dict.encoding + 2 + numberOfElements;
      }
      else /* ((formatType == 1) || (formatType == 129)) */
      {
         XCF_ReadBlock(h, (Offset) h->dict.encoding + 2, numberOfElements * 2);
         glyphCount = 0;
         for (i=0; i<numberOfElements; ++i)
         {
            firstCode = XCF_Read1(h);
            numberOfCodesInRange = XCF_Read1(h) + 1;
            for (j=0;j<numberOfCodesInRange;++j)
               h->type1.encoding[firstCode + j] = h->type1.pCharset[glyphCount++];
         } /* end for */
         extraEntries = (Offset) h->dict.encoding + 2 + (numberOfElements * 2);
      }

      if (formatType > 127) /* Additional entries */
      {

         XCF_ReadBlock(h, (Offset) extraEntries, 1);
         numberOfElements = XCF_Read1(h);
         XCF_ReadBlock(h, (Offset) extraEntries + 1, numberOfElements * 3);
         for (i=0; i<numberOfElements; ++i)
         {
            characterCode = XCF_Read1(h);
            h->type1.encoding[characterCode] = XCF_Read2(h);
         }
      }
      h->type1.pEncoding = h->type1.encoding;
   }
}

static void ReadFontSetHeader(XCF_Handle h) /* Read all values which are not specific to a given font.   */
{
   Offset offset;

   /* Read Header */
   XCF_ReadBlock(h, 0, 4);
   h->fontSet.majorVersion = XCF_Read1(h);
   h->fontSet.minorVersion = XCF_Read1(h);
   h->fontSet.headerSize = XCF_Read1(h);
   h->fontSet.offsetSize = XCF_Read1(h);

   if (h->fontSet.majorVersion != 1)
      XCF_FATAL_ERROR(h, XCF_UnsupportedVersion, "Unsupported Major Version", h->fontSet.majorVersion);
   if ((h->fontSet.offsetSize == 0) || (h->fontSet.offsetSize > 4))
      XCF_FATAL_ERROR(h, XCF_InvalidOffsetSize, "Invalid Global Offset Size", h->fontSet.offsetSize);

   offset = h->fontSet.headerSize;
   offset = ReadTableInfo(h, offset, &h->fontSet.fontNames);
   offset = ReadTableInfo(h, offset, &h->fontSet.fontDicts);
   offset = ReadTableInfo(h, offset, &h->fontSet.strings);
   offset = ReadTableInfo(h, offset, &h->fontSet.globalSubrs);
   h->fontSet.globalSubrBias = XCF_CalculateSubrBias(h->fontSet.globalSubrs.count);
}

static void FreeDAStorage(XCF_Handle h)
{
  da_FREE(h->type1.charStrs);
  da_FREE(h->type1.charStrOffsets);
  da_FREE(h->type1.subrs);
  da_FREE(h->type1.subrOffsets);
  da_FREE(h->type1.charset);
}

static void FreeDownloadData(XCF_Handle h)
{
  /* Free download record */
  if (h->dl.glyphs)
  {
    h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&h->dl.glyphs,
                          0, h->callbacks.allocateHook);
    h->dl.glyphs = 0;
  }
  if (h->options.dlOptions.encodeName)
    h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&h->options.dlOptions.encodeName, 0, h->callbacks.allocateHook);
  if (h->options.dlOptions.fontName)
      h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&h->options.dlOptions.fontName, 0, h->callbacks.allocateHook);
}

static void FreeCounterValues(XCF_Handle h, void PTR_PREFIX* PTR_PREFIX *p)
{
   if (*p)
   {
      h->callbacks.allocate(p, 0, h->callbacks.allocateHook);
      *p = 0;
   }
}

static void FreeStackValues(XCF_Handle h, void PTR_PREFIX* PTR_PREFIX *p)
{
   if (*p)
   {
      h->callbacks.allocate(p, 0, h->callbacks.allocateHook);
      *p = 0;
   }
}

enum XCF_Result XCF_Init(
                  XFhandle PTR_PREFIX *pHandle,                 /* Out */
                  XCF_CallbackStruct PTR_PREFIX *pCallbacks, /* In */
            XCF_ClientOptions PTR_PREFIX *options)     /* In */
{
   XCF_Handle h = (XCF_Handle)NULL;
   enum XCF_Result status;
   jmp_buf old_env;
   DEFINE_ALIGN_SETJMP_VAR;

   if (!pCallbacks->allocate((void PTR_PREFIX * PTR_PREFIX *)&h, sizeof(*h), pCallbacks->allocateHook))
      return XCF_MemoryAllocationError;
   InitHandle(h, pCallbacks);

  h->callbacks.memcpy(old_env, &h->jumpData, sizeof(h->jumpData));
   status = (enum XCF_Result)SETJMP(h->jumpData);  /* Set up error handler */
   if (status)
  {
    h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
      return status;
  }

   ReadFontSetHeader(h);
   *pHandle = h;

  SetClientOptions(h, options);
   h->fontSet.fontIndex = options->fontIndex;
   h->fontSet.stringIDBias = ARRAY_LEN(stdStrIndex);

  h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
   return XCF_Ok;
}

enum XCF_Result XCF_CleanUp(
                  XFhandle PTR_PREFIX *pHandle)          /* In/Out */
{
   XCF_Handle h = (XCF_Handle) *pHandle;

  FreeDAStorage(h);
  FreeDownloadData(h);
  FreeCounterValues(h, (void PTR_PREFIX* PTR_PREFIX *)&h->cstr.pCounterVal);
   FreeStackValues(h, (void PTR_PREFIX* PTR_PREFIX *)&h->cstr.pstackVal);
  if (CIDFONT && h->type1.cid.pFDIndex)
   {
    h->callbacks.allocate((void PTR_PREFIX* PTR_PREFIX *)&h->type1.cid.pFDIndex, 0,
                                       h->callbacks.allocateHook);
    h->type1.cid.pFDIndex = 0;
  }
   h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&h,
    0, h->callbacks.allocateHook);
   *pHandle = NULL;
   return XCF_Ok;
}

enum XCF_Result XCF_FontCount(
                  XFhandle handle,                    /* In */
                  unsigned int PTR_PREFIX *count)           /* Out */
{
   XCF_Handle h = (XCF_Handle) handle;
   *count = h->fontSet.fontNames.count;
   return XCF_Ok;
}

enum XCF_Result XCF_FontName(XFhandle handle,            /* In */
                  unsigned short int fontIndex,          /* In */
                  char PTR_PREFIX *fontName,             /* Out */
                  unsigned short int maxFontNameLength)     /* In */
{
   XCF_Handle h = (XCF_Handle) handle;
   enum XCF_Result status;
   jmp_buf old_env;
   DEFINE_ALIGN_SETJMP_VAR;

   h->callbacks.memcpy(old_env, &h->jumpData, sizeof(h->jumpData));
   status = (enum XCF_Result)SETJMP(h->jumpData);  /* Set up error handler */
   if (status)
   {
      h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
        return status;
   }

   *fontName = '\0';
   if (fontIndex >= h->fontSet.fontNames.count)
      XCF_FATAL_ERROR(h, XCF_InvalidFontIndex, "Invalid Font index", fontIndex);

   XCF_LookUpTableEntry(h, &h->fontSet.fontNames, fontIndex);

   if (maxFontNameLength < h->inBuffer.blockLength + 1)
   {
      h->callbacks.memcpy(fontName, h->inBuffer.start, (unsigned short int) (maxFontNameLength - 1));
      fontName += maxFontNameLength-1;
      *fontName = 0; /* Null terminate string */
      XCF_FATAL_ERROR(h, XCF_FontNameTooLong, "Font name too long to fit in available space", h->inBuffer.blockLength);
   }
   h->callbacks.memcpy(fontName, h->inBuffer.start, (short int) h->inBuffer.blockLength);
   fontName += h->inBuffer.blockLength;
   *fontName = 0; /* Null terminate string */
  h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
   return XCF_Ok;
}

/* Given a handle to a font returns in identifier whether it is a synthetic,
   multiple master, single master, cid, or chameleon font. */
enum XCF_Result XCF_FontIdentification(
            XFhandle handle,
            unsigned short int PTR_PREFIX *identifier)
{
   XCF_Handle h = (XCF_Handle) handle;
  Card16 opCode;

  if (handle == 0)
    return XCF_InvalidFontSetHandle;

  XCF_LookUpTableEntry(h, &h->fontSet.fontDicts, h->options.fontIndex);
  XCF_FindNextOperator(h, &opCode, true);
  switch(opCode)
  {
     case cff_Chameleon:
      *identifier = XCF_Chameleon;
      break;
    case cff_MultipleMaster:
      *identifier = XCF_MultipleMaster;
      break;
    case cff_ROS:
      *identifier = XCF_CID;
      break;
    case cff_SyntheticBase:
      *identifier = XCF_SyntheticBase;
      break;
    default:
      *identifier = XCF_SingleMaster;
      break;
  }
  return XCF_Ok;
}

static enum XCF_Result ReadCIDTopDictInfo(XCF_Handle h)
{
  Card8 offSize;

   if (h->dict.charStringsCount != 0)
      ReadTableInfo(h, (Offset) h->dict.charStrings, &h->fontSet.charStrings);
   else
      XCF_FATAL_ERROR(h, XCF_NoCharstringsFound, "No charstring offset found in dictionary", 0);

   /* must have 1 offset to FontDict */
   if (h->dict.cidFDArrayCount != 1)
      return XCF_InvalidCIDFont;

   XCF_ReadBlock(h, (Offset) h->dict.cidFDArray, 3);
   h->type1.cid.fdCount = XCF_Read2(h);
   offSize = XCF_Read1(h);

   if (h->type1.cid.fdCount > MAX_FD)
      XCF_FATAL_ERROR(h, XCF_InvalidCIDFont, "too many FDs", h->type1.cid.fdCount);

   ProcessCharset(h);   /* Also counts CharStrings */

   ProcessFDIndex(h);

   /* We already read the top-level dict data in XCF_ProcessCFF. */
   AssignDictionaryDefaults(h);

   XC_SetUpStandardSubrs(h);

  return XCF_Ok;
}

static void ReadandWriteCIDDict(XCF_Handle h, Card32 subrMapStart)
{
   Offset index;
   Offset dataStart;
  Card8 offSize;
   Card32 dictOffset;
   Card32 nextdictOffset;
   CardX dictLength;
   Card16 fd;
   Card32 subrMapOffset = subrMapStart;
   Card16 subrCount;
  Int32 saveFontType;
  char defStr[10];

  /* Always use the fontType from the top-level dictionary. */
  saveFontType = h->dict.fontType;

  XCF_ReadBlock(h, (Offset) h->dict.cidFDArray + 2, 1);
  offSize = XCF_Read1(h);

   /* We can avoid reading the first offset, which is 1. */
   index = (Offset) h->dict.cidFDArray + 3 + offSize;
   dataStart = index + (offSize * h->type1.cid.fdCount) - 1;
   dictOffset = 1;

   for (fd = 0; fd < h->type1.cid.fdCount ; ++fd)
   {
      /* Clear dictionary data before filling. */
      h->callbacks.memset(&h->dict, 0, sizeof(DictEntriesStruct));
      /* Read next Offset */
      XCF_ReadBlock(h, index, offSize);
      nextdictOffset = XCF_Read(h, offSize);
      index += offSize;

      /* Read dict */
      dictLength = (CardX) (nextdictOffset - dictOffset);
      XCF_ReadBlock(h, dataStart + dictOffset, dictLength);

      /* Process font dict */
      XCF_ReadDictionary(h);

    /* Process Private dict */
      XCF_ReadBlock(h, h->fontSet.fontPrivDictInfo.offset,
                  h->fontSet.fontPrivDictInfo.size);
      XCF_ReadDictionary(h);

      /* Advance to next index element */
      dictOffset = nextdictOffset;
      /* Both FontDict and Private have been processed for this value of fd, now write them. */
      if (h->dict.subrsCount)
      {
         /* The local subrs offset is relative to the private dict data. */
        ReadTableInfo(h,
                 (Offset) (h->dict.subrs + h->fontSet.fontPrivDictInfo.offset),
                 &h->type1.cid.localSubrs[fd]);
      h->type1.cid.localSubrBias[fd] =
        XCF_CalculateSubrBias(h->type1.cid.localSubrs[fd].count);
      }
      subrCount = h->options.outputCharstrType == 1 ? 5 : h->type1.cid.localSubrs[fd].count;
      AssignDictionaryDefaults(h);

    h->dict.fontType = saveFontType;

#ifdef T13
    XT13_SetLenIV(h);
#endif

    h->type1.cid.languageGroup[fd] = (Card8) ((h->dict.languageGroupCount == 1) ? h->dict.languageGroup : 0);
   h->type1.cid.nominalWidthX[fd] = (Fixed) ((h->dict.nominalWidthXCount == 1) ? h->dict.nominalWidthX : 0);
   h->type1.cid.defaultWidthX[fd] = (Fixed) ((h->dict.defaultWidthXCount == 1) ?
                                                                  h->dict.defaultWidthX : 0);

      XT1_WriteCIDDict(h, fd, subrMapOffset, subrCount);
      subrMapOffset += (subrCount + 1) * 4;  /* xxx if SDBytes is not 4 this changes! */
      /* The +1 is for the final interval for the last subr in each group. */
   }
  h->callbacks.xcfSprintf(defStr, CCHOF(defStr), "def%s", XCF_NEW_LINE);
  XCF_PutData(h, (Card8 PTR_PREFIX *)defStr, h->callbacks.strlen(defStr));
   h->type1.cid.subrDataStart = subrMapOffset;
  h->type1.cid.charMapStart = 0;
}

static enum XCF_Result Process_CIDFont(XCF_Handle h)
   {
  Card16 fd;
  Card16 fdBytes = (h->type1.cid.fdCount > 1 ? 1 : 0);

   XT1_WriteCIDTop(h);  /* Write top-level dict, up to FDArray */

  /* xxx If FDBytes or GDBytes is variable, then the 2nd argument,
     subrMapStart will change. */
  ReadandWriteCIDDict(h, ((Offset)h->dict.cidCount + 1) * (fdBytes + 4));

   XT1_CIDBeginBinarySection(h);

  h->type1.cid.flags |= WRITE_SUBR_FLAG;

   /* xxx This will become more complicated when we have real subrs. */
   for (fd = 0; fd < h->type1.cid.fdCount ; ++fd)
      XT1_CIDWriteSubrMap(h, fd);
   /* xxx now we should be in the same place */
   h->type1.cid.subrDataStart = XCF_OutputPos(h);

   for (fd = 0; fd < h->type1.cid.fdCount ; ++fd)
      XT1_CIDWriteSubrs(h, fd);

   h->type1.cid.charDataStart = XCF_OutputPos(h);

  h->type1.cid.flags &= 0xFFFD; /* Reset WriteSubr flag */

   ProcessCharStrings(h);
   h->type1.cid.charDataEnd = XCF_OutputPos(h);

   XT1_CIDWriteCharMap(h);
   XT1_CIDEndBinarySection(h);

   XCF_FlushOutputBuffer(h);
   return XCF_Ok;
   }

static void DLGlyphs_Allocate(XCF_Handle h)
{
  /* Allocate space to keep track of the downloaded glyphs */
  h->dl.glyphs = (Card8 *)NULL;
  h->dl.glyphsSize = (h->fontSet.charStrings.count + 7) / 8;
  /* Allocate memory for incremental download bookkeeping */
  if (!h->callbacks.allocate(
       (void PTR_PREFIX * PTR_PREFIX *)&h->dl.glyphs,
       h->dl.glyphsSize, h->callbacks.allocateHook))
    XCF_FATAL_ERROR(h, XCF_MemoryAllocationError,
       "Failure to allocate memory for incremental download bookkeeping",
       h->dl.glyphsSize);
  /* Initialize the list */
  h->callbacks.memset(h->dl.glyphs, 0, (unsigned short int)h->dl.glyphsSize);
  h->dl.state = XCF_DL_INIT;
}

/* Modifies the XUID if one exists and creates an XUID if one doesn't
   exist in order to prevent any possible conflicts that can occur
   between a subsetted font that has been downloaded and the fully
   "released" Type 1 font as a result of font caching. The problem
   occurs if both fonts have the same UniqueID or XUID. For example,
   if the subsetted font has flattened subroutines and is downloaded
   first then the full font which includes subroutines is downloaded
   the second font will not work if it tries to show a glyph that
   depends on a subroutine because the font cache has not been updated.
 */
static void SetXUID(XCF_Handle h)
{
  if (h->dict.xUIDCount != 0)
    /* 5 means that the rest of the XUID is an XUID for a font which is
       basically the same as this except that "flattening" of subroutines
       has been done in this font. */
    h->dict.xUID[0] = 5;
  else if ((h->dict.uniqueIDCount != 0)
            || (h->options.uniqueIDMethod == XCF_USER_UID))
  { /* Create an XUID of the form: [6 <UniqueID>] */
    h->dict.xUIDCount = 2;
    h->dict.xUID[0] = 6;
    h->dict.xUID[1] = h->options.uniqueIDMethod == XCF_USER_UID ?
         h->options.uniqueID : h->dict.uniqueID;
  }
}

enum XCF_Result XCF_ProcessCFF(XFhandle handle)
{
   XCF_Handle h = (XCF_Handle) handle;
   enum XCF_Result status;
   jmp_buf old_env;
   DEFINE_ALIGN_SETJMP_VAR;

   h->callbacks.memcpy(old_env, &h->jumpData, sizeof(h->jumpData));
   status = (enum XCF_Result)SETJMP(h->jumpData);  /* Set up error handler */
   if (status)
   {
      h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
        return status;
   }

   h->type1.cid.flags = 0;

  /* Initialize XCF */
  ClearDictionaryData(h);

  XCF_LookUpTableEntry(h, &h->fontSet.fontDicts, h->options.fontIndex);
  XCF_ReadDictionary(h); /* Font Dict */
  XC_Init(h); /* This call has to be after the top dict is read because
               * it uses the numberOfMasters field to allocate space.
               */
  if (h->dict.numberOfMasters)
  { /* Convert user design vector to a weight vector. */
    char PTR_PREFIX *str;
    Card16 length;

    XCF_LookUpString(h, h->dict.ndv, &str, &length);
    XC_ParseCharStr(h, (unsigned char PTR_PREFIX *)str, 2);
    XCF_LookUpString(h, h->dict.cdv, &str, &length);
    XC_ParseCharStr(h, (unsigned char PTR_PREFIX *)str, 2);
  }

  if (h->dict.ROSCount == 3)
    h->type1.cid.flags |= CID_FLAG;

  SetXUID(h);

  /* This version of xcf does not support global subroutines or
     outputting Type 2 charstrings in CIDFonts. */
  if ((h->options.outputCharstrType == 2) && (CIDFONT ||
                                                                     h->fontSet.globalSubrs.count))
  {
    h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
    return XCF_Unimplemented;
  }

  if (!CIDFONT)
  {
    XCF_ReadBlock(h, h->fontSet.fontPrivDictInfo.offset,
                        h->fontSet.fontPrivDictInfo.size);
    XCF_ReadDictionary(h); /* Private Dict */
    ProcessDictionaryData(h, true);
    if (h->dl.state == XCF_DL_CREATE)
      DLGlyphs_Allocate(h);

      ProcessCharset(h);
    /* Don't need to process the encoding array if the client specifies
       its own encoding array name */
    if (!h->options.dlOptions.encodeName && h->dl.state == XCF_DL_INIT)
      ProcessEncoding(h);
      XC_SetUpStandardSubrs(h);
#if HAS_COOLTYPE_UFL == 1
    if (h->options.outputCharstrType != 2 && XCF_TransDesignFont(h))
      XC_ProcessTransDesignSubrs(h);
#endif
    ProcessCharStrings(h);
  }
  else
  {
    /* CID font indicated by presence of ROS in top level dict */
    if ((status = ReadCIDTopDictInfo(h)) == XCF_Ok)
      if (h->dl.state == XCF_DL_CREATE)
        DLGlyphs_Allocate(h);
  }

  h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
  return status;
}

enum XCF_Result XCF_ConvertToPostScript(XFhandle handle)
{
   XCF_Handle h = (XCF_Handle) handle;
   enum XCF_Result status;

  status = XCF_ProcessCFF(handle);

   if (status == XCF_Ok)
  {
    if (!CIDFONT)
     {
        XT1_WriteT1Font(h);
        XCF_FlushOutputBuffer(h);
     }
    else
      Process_CIDFont(h);
  }
  return status;
}

#ifdef XCF_DUMP_CFF
enum XCF_Result XCF_DumpCff(
                  XFhandle handle,                    /* In */
                  unsigned int fontIndex,                /* In */
                  int   dumpCompleteFontSet,             /* In */
                  char PTR_PREFIX *fileName,             /* In */
                  char PTR_PREFIX *commandLine)          /* In */
{
   XCF_Handle h = (XCF_Handle) handle;
   enum XCF_Result status;
   Card16 lastFontIndex;
   Card16 i;
   jmp_buf old_env;
   DEFINE_ALIGN_SETJMP_VAR;

   h->callbacks.memcpy(&old_env, &h->jumpData, sizeof(h->jumpData));
   status = (enum XCF_Result)SETJMP(h->jumpData);  /* Set up error handler */
   if (status)
   {
     h->callbacks.memcpy(&h->jumpData, &old_env, sizeof(h->jumpData));
       return status;
   }

   h->options.eexecEncryption = 0;
   h->options.maxBlockSize = MAX_OUT_BUFFER;
   h->fontSet.stringIDBias = ARRAY_LEN(stdStrIndex);

   if (dumpCompleteFontSet)
   {
      fontIndex = 0;
      lastFontIndex = h->fontSet.fontNames.count - 1;
   }
   else
   {
      lastFontIndex = fontIndex;
      h->fontSet.fontIndex = fontIndex;
   }

   h->outBuffer.eexecOn = false;
/*
   XCF_PutString(h, "// CFF To ASCII conversion" XCF_NEW_LINE);
   XCF_PutString(h, "// Generated by XCF VER " XCF_Version XCF_NEW_LINE);
   XCF_PutString(h, "// Input File = \"");
   XCF_PutString(h, fileName);
   XCF_PutString(h, "\"" XCF_NEW_LINE);
   XCF_PutString(h, "// Command Line = \"");
   XCF_PutString(h, commandLine);
   XCF_PutString(h, "\"" XCF_NEW_LINE);
*/
   XCF_PutString(h, "CFF Dump Version 0.2" XCF_NEW_LINE);

   XCF_DumpGlobalCFFSections(h, dumpCompleteFontSet);
   for (i = fontIndex; i <= lastFontIndex; ++i)
   {
      ClearDictionaryData(h);
      h->fontSet.fontIndex = i;
      XCF_LookUpTableEntry(h, &h->fontSet.fontDicts, i);
      XCF_ReadDictionary(h); /* Font Dict */
      if (h->dict.syntheticBaseCount)  /* If synthetic then read base font dict */
      {
         XCF_LookUpTableEntry(h, &h->fontSet.fontDicts, (CardX) h->dict.syntheticBase);
         XCF_ReadDictionary(h);
      }
      if (h->dict.ROSCount == 3)
         h->type1.cid.flags |= CID_FLAG;
      XCF_ReadBlock(h, h->fontSet.fontPrivDictInfo.offset, h->fontSet.fontPrivDictInfo.size);
      XCF_ReadDictionary(h); /* Private Dict */
      ProcessDictionaryData(h, false);
      ProcessCharset(h);
      ProcessEncoding(h);
      if (CIDFONT)
      ProcessFDIndex(h);
     XCF_DumpFontSpecificCFFSections(h);
   }
   XCF_PutString(h, XCF_NEW_LINE "[END]" XCF_NEW_LINE);
   XCF_FlushOutputBuffer(h);

  h->callbacks.memcpy(&h->jumpData, &old_env, sizeof(h->jumpData));
   return XCF_Ok;
}
#endif

static void DownloadFont(XCF_Handle h, short cGlyphs,
                         XCFGlyphID PTR_PREFIX *pGlyphID,
                         unsigned char PTR_PREFIX **pGlyphName,
                         unsigned long PTR_PREFIX *pCharStrLength)
{

  if (h->dl.state == XCF_DL_INIT)
  { /* A new font */
    if (!CIDFONT)
      XT1_WriteFontSubset(h, cGlyphs, pGlyphID, pGlyphName, pCharStrLength);
    else
    {
      XT1_WriteCIDTop(h);  /* Write top-level dict, up to FDArray */
      ReadandWriteCIDDict(h, 0);
      XT1_WriteGlyphDictEntries(h, cGlyphs, pGlyphID, pCharStrLength);
      XT1_WriteCIDVMBinarySection(h);
    }
    h->dl.state = XCF_DL_BASE;
  }
  else
  { /* A font that has been downloaded */
    if (!CIDFONT)
      XT1_WriteAdditionalFontSubset(h, cGlyphs, pGlyphID, pGlyphName,
                                                      pCharStrLength);
    else
    {
      XT1_WriteAdditionalGlyphDictEntries(h, cGlyphs, pGlyphID, pCharStrLength);
    }
    h->dl.state = XCF_DL_SUBSET;
  }

  XCF_FlushOutputBuffer(h);
}

enum XCF_Result XCF_DownloadFontIncr(
            XFhandle hfontset,
            short cGlyphs,    /* In */
            XCFGlyphID PTR_PREFIX *pGlyphID,        /* In */
            unsigned char PTR_PREFIX **pGlyphName,  /* In */
            unsigned long PTR_PREFIX *pCharStrLength /* Out */
            )
{
  enum XCF_Result retVal;
  XCF_Handle h = (XCF_Handle)hfontset;
  short i, glyphID;
  short numGlyphs = cGlyphs;
  CardX totalGlyphs = h->fontSet.charStrings.count;
  boolean completeFont = false;
  boolean glyphsToDld = false;
  XCFGlyphID PTR_PREFIX *pID = pGlyphID;
  DEFINE_ALIGN_SETJMP_VAR;

   /* Set up error handler */
  retVal = (enum XCF_Result)SETJMP(((XCF_Handle)h)->jumpData);

  if (retVal != 0)
    return retVal;

  if (h->dl.state == XCF_DL_INIT)
    glyphsToDld = true;
  else /* Check if there are any glyphs to download. */
  {
    if (cGlyphs == -1)
    {
      numGlyphs = (short)totalGlyphs;
      completeFont = true;
    }

    for (i = 0; i < numGlyphs; i++, pID++)
    {
       glyphID = (short)((completeFont) ? i : *pID);
       if (glyphID > (XCFGlyphID)totalGlyphs)
         XCF_FATAL_ERROR(h, XCF_InvalidGID, "bad Glyph ID", glyphID);

       if (!IS_GLYPH_SENT(h->dl.glyphs, glyphID))
         {
         glyphsToDld = true;
         break;
       }
     }
   }

  if (glyphsToDld)
    DownloadFont(h, cGlyphs, pGlyphID, pGlyphName, pCharStrLength);

  return retVal;
}

/* Clears (reset to 0) the list of glyphs that have been downloaded. */
enum XCF_Result XCF_ClearIncrGlyphList(XFhandle hfontset)
{
  XCF_Handle h;

  if (hfontset == 0)
    return XCF_InvalidFontSetHandle;

  h = (XCF_Handle)hfontset;

  if (h->dl.glyphs != NULL)
  {
    h->callbacks.memset(h->dl.glyphs, 0, (unsigned short int)h->dl.glyphsSize);
    h->callbacks.memset(&h->dl.seacs, 0, (unsigned short int)32);
    h->dl.cSeacs = 0;
   }

  return XCF_Ok;
}

/* For each glyphID in pGlyphIDs gidToCharName is called with the associated
   character name and string length. */
enum XCF_Result XCF_GlyphIDsToCharNames(
            XFhandle handle,
            short cGlyphs,
            XCFGlyphID PTR_PREFIX *pGlyphIDs, /* list of glyphIDs */
            void PTR_PREFIX *client, /* client data passed to callback, can be NULL */
            unsigned short  clientSize  /* size of client data buffer */)
{
  short i;
  char PTR_PREFIX *str;
  char cidStr[10];
  Card16 len = 0, lenUsed;
  XCF_Handle h;
  Card32 index;

  if (handle == 0)
    return XCF_InvalidFontSetHandle;


  h = (XCF_Handle)handle;

  if (h->callbacks.gidToCharName == 0)
    return XCF_InvalidCallbackFunction;

  for (i = 0; i < cGlyphs; i++)
  {
    index = *pGlyphIDs;
    /* The charset table does not include the 0th entry for .notdef. */
    if (index)
      index--;
    else
    {
      if (CIDFONT)
        h->callbacks.gidToCharName(handle, client, *pGlyphIDs++, "0", 1);
      else
        h->callbacks.gidToCharName(handle, client, *pGlyphIDs++, ".notdef", 7);
      continue;
    }

    if (CIDFONT)
    {
      h->callbacks.xcfSprintf(cidStr, CCHOF(cidStr), "%d", h->type1.pCharset[index]);
      len = h->callbacks.strlen(cidStr);
      str = cidStr;
    }
    else
      XCF_LookUpString(h, h->type1.pCharset[index], &str, &len);
    lenUsed = (len < (Card16)clientSize)? len : (Card16)(clientSize-1);
    h->callbacks.gidToCharName(handle, client, *pGlyphIDs++, str, lenUsed);
  }

  return XCF_Ok;
}
/* For each glyphID in pGlyphIDs gidToCID is called with the associated cid. */
enum XCF_Result XCF_GlyphIDsToCIDs(XFhandle handle,
                    short cGlyphs,  /* number of glyphs in glyphID list */
                    XCFGlyphID PTR_PREFIX *pGlyphIDs, /* list of glyphIDs */
                    void PTR_PREFIX *client /* client data, can be NULL */)
{
  short i;
  XCF_Handle h = (XCF_Handle)handle;
  Card32 gid;
  Card16 cid;
  CardX  totalGlyphs = h->fontSet.charStrings.count;

  if (handle == 0)
    return XCF_InvalidFontSetHandle;

  if (h->callbacks.gidToCID == 0)
    return XCF_InvalidCallbackFunction;

  for (i = 0; i < cGlyphs; i++, pGlyphIDs++)
  {
    gid = *pGlyphIDs;
    /* The charset table does not include the 0th entry for .notdef. */
    cid = (gid == 0 || gid > (Card32)totalGlyphs) ? 0 : (Card16)(h->type1.pCharset[gid - 1]);

    h->callbacks.gidToCID(handle, client, gid, cid);
  }

  return XCF_Ok;
}

enum XCF_Result XCF_CharNamesToGIDs(XFhandle handle,
                           short cGlyphs,
                           char PTR_PREFIX **charNames,
                           void PTR_PREFIX *client)
{
   Card16 i,j;
   char PTR_PREFIX *str;
   Card16 len, inputLen;
   XCF_Handle h = (XCF_Handle)handle;

   if (h->callbacks.gnameToGid == 0)
      return XCF_InvalidCallbackFunction;

   /* for now, this doesnt work for cid fonts */
   if (CIDFONT)
      return XCF_Unimplemented;

        for (i = 0; i < (Card16)cGlyphs; i++)
   {
      /* The charset array does not include an entry for ".notdef" */
      if (h->callbacks.strcmp(charNames[i], NOTDEF_STR) == 0) {
         h->callbacks.gnameToGid(handle, client, i, charNames[i], NOTDEF_GID);
         continue;
      }

      inputLen = h->callbacks.strlen(charNames[i]);
      /* there is no good way to do this...just loop through
       * looking for a match
       */
      for (j = 0; j < h->type1.charsetSize; j++) {
         XCF_LookUpString(h, h->type1.pCharset[j], &str, &len);
         if (inputLen == len && !h->callbacks.strncmp(charNames[i], str, len)){
            h->callbacks.gnameToGid(handle, client, i, charNames[i], j+1);
            break;
         }
      }
   }

   return XCF_Ok;
}

enum XCF_Result XCF_CountDownloadGlyphs(
    XFhandle hfontset,                              /* In */
    short cGlyphs,                                  /* In */
    XCFGlyphID PTR_PREFIX *pGlyphID,                /* In */
    unsigned short PTR_PREFIX *pcNewGlyphs          /* Out */
    )
{
    enum XCF_Result status;
    boolean flCompleteFont;
    short   i, glyphID;
    Card8 PTR_PREFIX *tempGlyphList = 0;
    XCF_Handle h = (XCF_Handle)hfontset;
    CardX   totalGlyphs;
    jmp_buf old_env;
    DEFINE_ALIGN_SETJMP_VAR;

    *pcNewGlyphs = 0;

    h->callbacks.memcpy(old_env, &h->jumpData, sizeof(h->jumpData));
    if (!(status = (enum XCF_Result)SETJMP(h->jumpData)))  /* Set up error                                                                                            handler */
    {
      totalGlyphs = h->fontSet.charStrings.count;
      if ( cGlyphs == -1 )
      {
          cGlyphs = (short)totalGlyphs;
          flCompleteFont = true;
      }
      else
          flCompleteFont = false;

      /* Allocate memory for the temporary list. */
      if (!h->callbacks.allocate(
                    (void PTR_PREFIX * PTR_PREFIX *)&tempGlyphList,
                     h->dl.glyphsSize, h->callbacks.allocateHook))
          XCF_FATAL_ERROR(h, XCF_MemoryAllocationError,
             "Failure to allocate memory for incremental download bookkeeping",
             h->dl.glyphsSize);

      /* Copy this current downloaded glyphs */
      h->callbacks.memcpy(tempGlyphList, h->dl.glyphs, (Card16)h->dl.glyphsSize);

      for (i=0; i < cGlyphs; i++, pGlyphID++)
      {
          glyphID = (short)((flCompleteFont) ? i : *pGlyphID);

          if (glyphID < 0 || glyphID > (XCFGlyphID)totalGlyphs)
              XCF_FATAL_ERROR(h, XCF_InvalidGID, "bad Glyph ID", glyphID);

          /* Check to see if we have downloaded this glyph. If this is a normal
             character, then we simply check it against the glyphs
             list.  */

          if (!IS_GLYPH_SENT(tempGlyphList, glyphID))
          {
              SET_GLYPH_SENT_STATUS(tempGlyphList, glyphID);
              *pcNewGlyphs += 1;
          }
      }
    }

    /* Deallocate temporary glyph list */
    if (tempGlyphList)
        h->callbacks.allocate((void PTR_PREFIX * PTR_PREFIX *)&tempGlyphList, 0, h->callbacks.allocateHook);

    h->callbacks.memcpy(&h->jumpData, old_env, sizeof(h->jumpData));
    return status;
}

CardX GetStdEncodeSID(CardX gid)
{
  return stdEncoding[gid];
}

char PTR_PREFIX *GetStdEncodingName(CardX gid)
{
  if (gid < 256)
    return  (char PTR_PREFIX *)(stdStrIndex[stdEncoding[gid]]);
  else
    return (char PTR_PREFIX *)NULL;
}

#if HAS_COOLTYPE_UFL == 1
/* Initializes, creates, and returns an XFhandle in pHandle.
   This is essentially the same function as XCF_Init except
   that it does not read a fontset to initialize certain
   fields in its internal fontSet data structure.
 */
enum XCF_Result XCF_InitHandle(
                  XFhandle PTR_PREFIX *pHandle,                  /* Out */
                  XCF_CallbackStruct PTR_PREFIX *pCallbacks,  /* In */
            XCF_ClientOptions PTR_PREFIX *options,       /* In */
            unsigned long charStrCt)                    /* In */
{
   XCF_Handle h = (XCF_Handle)NULL;
   enum XCF_Result status;
   jmp_buf old_env;

   if (!pCallbacks->allocate((void PTR_PREFIX * PTR_PREFIX *)&h, sizeof(*h), pCallbacks->allocateHook))
      return XCF_MemoryAllocationError;
   InitHandle(h, pCallbacks);

  /* Allocate download glyph data structure. */
  h->fontSet.charStrings.count = charStrCt;
  DLGlyphs_Allocate(h);
  DEFINE_ALIGN_SETJMP_VAR;

  h->callbacks.memcpy(&old_env, &h->jumpData, sizeof(h->jumpData));

  status = (enum XCF_Result)SETJMP(h->jumpData);  /* Set up error handler */
  if (status)
  {
    h->callbacks.memcpy(&h->jumpData, &old_env, sizeof(h->jumpData));
      return status;
  }

   *pHandle = h;

  SetClientOptions(h, options);
   h->fontSet.fontIndex = options->fontIndex;
   h->fontSet.stringIDBias = ARRAY_LEN(stdStrIndex);
  h->callbacks.memcpy(&h->jumpData, &old_env, sizeof(h->jumpData));

   return XCF_Ok;
}
#endif

#ifdef XCF_DEVELOP
enum XCF_Result  XCF_ShowHexString(XFhandle fontsetHandle,
       unsigned char PTR_PREFIX *hexString, unsigned char showCtrlD)
{
   enum XCF_Result status;
   DEFINE_ALIGN_SETJMP_VAR;

   /* Set up error handler */
   status = (enum XCF_Result)SETJMP(((XCF_Handle)fontsetHandle)->jumpData);

   if (status)
      return status;

   XT1_ShowHexString((XCF_Handle)fontsetHandle, hexString, showCtrlD);
   XCF_FlushOutputBuffer((XCF_Handle)fontsetHandle);
}
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_expe.h ===
/* @(#)CM_VerSion xcf_expe.h atm08 1.2 16248.eco sum= 52358 atm08.003 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Expert encoding aggregate initializer. Element values are SIDs.
 */

#ifndef EXENC_H
#define EXENC_H

	  0,	/*   0 .notdef */
	  0,	/*   1 .notdef */
	  0,	/*   2 .notdef */
	  0,	/*   3 .notdef */
	  0,	/*   4 .notdef */
	  0,	/*   5 .notdef */
	  0,	/*   6 .notdef */
	  0,	/*   7 .notdef */
	  0,	/*   8 .notdef */
	  0,	/*   9 .notdef */
	  0,	/*  10 .notdef */
	  0,	/*  11 .notdef */
	  0,	/*  12 .notdef */
	  0,	/*  13 .notdef */
	  0,	/*  14 .notdef */
	  0,	/*  15 .notdef */
	  0,	/*  16 .notdef */
	  0,	/*  17 .notdef */
	  0,	/*  18 .notdef */
	  0,	/*  19 .notdef */
	  0,	/*  20 .notdef */
	  0,	/*  21 .notdef */
	  0,	/*  22 .notdef */
	  0,	/*  23 .notdef */
	  0,	/*  24 .notdef */
	  0,	/*  25 .notdef */
	  0,	/*  26 .notdef */
	  0,	/*  27 .notdef */
	  0,	/*  28 .notdef */
	  0,	/*  29 .notdef */
	  0,	/*  30 .notdef */
	  0,	/*  31 .notdef */
	  1,	/*  32 space */
	229,	/*  33 exclamsmall */
	230,	/*  34 Hungarumlautsmall */
	  0,	/*  35 .notdef */
	231,	/*  36 dollaroldstyle */
	232,	/*  37 dollarsuperior */
	233,	/*  38 ampersandsmall */
	234,	/*  39 Acutesmall */
	235,	/*  40 parenleftsuperior */
	236,	/*  41 parenrightsuperior */
	237,	/*  42 twodotenleader */
	238,	/*  43 onedotenleader */
	 13,	/*  44 comma */
	 14,	/*  45 hyphen */
	 15,	/*  46 period */
	 99,	/*  47 fraction */
	239,	/*  48 zerooldstyle */
	240,	/*  49 oneoldstyle */
	241,	/*  50 twooldstyle */
	242,	/*  51 threeoldstyle */
	243,	/*  52 fouroldstyle */
	244,	/*  53 fiveoldstyle */
	245,	/*  54 sixoldstyle */
	246,	/*  55 sevenoldstyle */
	247,	/*  56 eightoldstyle */
	248,	/*  57 nineoldstyle */
	 27,	/*  58 colon */
	 28,	/*  59 semicolon */
	249,	/*  60 commasuperior */
	250,	/*  61 threequartersemdash */
	251,	/*  62 periodsuperior */
	252,	/*  63 questionsmall */
	  0,	/*  64 .notdef */
	253,	/*  65 asuperior */
	254,	/*  66 bsuperior */
	255,	/*  67 centsuperior */
	256,	/*  68 dsuperior */
	257,	/*  69 esuperior */
	  0,	/*  70 .notdef */
	  0,	/*  71 .notdef */
	  0,	/*  72 .notdef */
	258,	/*  73 isuperior */
	  0,	/*  74 .notdef */
	  0,	/*  75 .notdef */
	259,	/*  76 lsuperior */
	260,	/*  77 msuperior */
	261,	/*  78 nsuperior */
	262,	/*  79 osuperior */
	  0,	/*  80 .notdef */
	  0,	/*  81 .notdef */
	263,	/*  82 rsuperior */
	264,	/*  83 ssuperior */
	265,	/*  84 tsuperior */
	  0,	/*  85 .notdef */
	266,	/*  86 ff */
	109,	/*  87 fi */
	110,	/*  88 fl */
	267,	/*  89 ffi */
	268,	/*  90 ffl */
	269,	/*  91 parenleftinferior */
	  0,	/*  92 .notdef */
	270,	/*  93 parenrightinferior */
	271,	/*  94 Circumflexsmall */
	272,	/*  95 hyphensuperior */
	273,	/*  96 Gravesmall */
	274,	/*  97 Asmall */
	275,	/*  98 Bsmall */
	276,	/*  99 Csmall */
	277,	/* 100 Dsmall */
	278,	/* 101 Esmall */
	279,	/* 102 Fsmall */
	280,	/* 103 Gsmall */
	281,	/* 104 Hsmall */
	282,	/* 105 Ismall */
	283,	/* 106 Jsmall */
	284,	/* 107 Ksmall */
	285,	/* 108 Lsmall */
	286,	/* 109 Msmall */
	287,	/* 110 Nsmall */
	288,	/* 111 Osmall */
	289,	/* 112 Psmall */
	290,	/* 113 Qsmall */
	291,	/* 114 Rsmall */
	292,	/* 115 Ssmall */
	293,	/* 116 Tsmall */
	294,	/* 117 Usmall */
	295,	/* 118 Vsmall */
	296,	/* 119 Wsmall */
	297,	/* 120 Xsmall */
	298,	/* 121 Ysmall */
	299,	/* 122 Zsmall */
	300,	/* 123 colonmonetary */
	301,	/* 124 onefitted */
	302,	/* 125 rupiah */
	303,	/* 126 Tildesmall */
	  0,	/* 127 .notdef */
	  0,	/* 128 .notdef */
	  0,	/* 129 .notdef */
	  0,	/* 130 .notdef */
	  0,	/* 131 .notdef */
	  0,	/* 132 .notdef */
	  0,	/* 133 .notdef */
	  0,	/* 134 .notdef */
	  0,	/* 135 .notdef */
	  0,	/* 136 .notdef */
	  0,	/* 137 .notdef */
	  0,	/* 138 .notdef */
	  0,	/* 139 .notdef */
	  0,	/* 140 .notdef */
	  0,	/* 141 .notdef */
	  0,	/* 142 .notdef */
	  0,	/* 143 .notdef */
	  0,	/* 144 .notdef */
	  0,	/* 145 .notdef */
	  0,	/* 146 .notdef */
	  0,	/* 147 .notdef */
	  0,	/* 148 .notdef */
	  0,	/* 149 .notdef */
	  0,	/* 150 .notdef */
	  0,	/* 151 .notdef */
	  0,	/* 152 .notdef */
	  0,	/* 153 .notdef */
	  0,	/* 154 .notdef */
	  0,	/* 155 .notdef */
	  0,	/* 156 .notdef */
	  0,	/* 157 .notdef */
	  0,	/* 158 .notdef */
	  0,	/* 159 .notdef */
	  0,	/* 160 .notdef */
	304,	/* 161 exclamdownsmall */
	305,	/* 162 centoldstyle */
	306,	/* 163 Lslashsmall */
	  0,	/* 164 .notdef */
	  0,	/* 165 .notdef */
	307,	/* 166 Scaronsmall */
	308,	/* 167 Zcaronsmall */
	309,	/* 168 Dieresissmall */
	310,	/* 169 Brevesmall */
	311,	/* 170 Caronsmall */
	  0,	/* 171 .notdef */
	312,	/* 172 Dotaccentsmall */
	  0,	/* 173 .notdef */
	  0,	/* 174 .notdef */
	313,	/* 175 Macronsmall */
	  0,	/* 176 .notdef */
	  0,	/* 177 .notdef */
	314,	/* 178 figuredash */
	315,	/* 179 hypheninferior */
	  0,	/* 180 .notdef */
	  0,	/* 181 .notdef */
	316,	/* 182 Ogoneksmall */
	317,	/* 183 Ringsmall */
	318,	/* 184 Cedillasmall */
	  0,	/* 185 .notdef */
	  0,	/* 186 .notdef */
	  0,	/* 187 .notdef */
	158,	/* 188 onequarter */
	155,	/* 189 onehalf */
	163,	/* 190 threequarters */
	319,	/* 191 questiondownsmall */
	320,	/* 192 oneeighth */
	321,	/* 193 threeeighths */
	322,	/* 194 fiveeighths */
	323,	/* 195 seveneighths */
	324,	/* 196 onethird */
	325,	/* 197 twothirds */
	  0,	/* 198 .notdef */
	  0,	/* 199 .notdef */
	326,	/* 200 zerosuperior */
	150,	/* 201 onesuperior */
	164,	/* 202 twosuperior */
	169,	/* 203 threesuperior */
	327,	/* 204 foursuperior */
	328,	/* 205 fivesuperior */
	329,	/* 206 sixsuperior */
	330,	/* 207 sevensuperior */
	331,	/* 208 eightsuperior */
	332,	/* 209 ninesuperior */
	333,	/* 210 zeroinferior */
	334,	/* 211 oneinferior */
	335,	/* 212 twoinferior */
	336,	/* 213 threeinferior */
	337,	/* 214 fourinferior */
	338,	/* 215 fiveinferior */
	339,	/* 216 sixinferior */
	340,	/* 217 seveninferior */
	341,	/* 218 eightinferior */
	342,	/* 219 nineinferior */
	343,	/* 220 centinferior */
	344,	/* 221 dollarinferior */
	345,	/* 222 periodinferior */
	346,	/* 223 commainferior */
	347,	/* 224 Agravesmall */
	348,	/* 225 Aacutesmall */
	349,	/* 226 Acircumflexsmall */
	350,	/* 227 Atildesmall */
	351,	/* 228 Adieresissmall */
	352,	/* 229 Aringsmall */
	353,	/* 230 AEsmall */
	354,	/* 231 Ccedillasmall */
	355,	/* 232 Egravesmall */
	356,	/* 233 Eacutesmall */
	357,	/* 234 Ecircumflexsmall */
	358,	/* 235 Edieresissmall */
	359,	/* 236 Igravesmall */
	360,	/* 237 Iacutesmall */
	361,	/* 238 Icircumflexsmall */
	362,	/* 239 Idieresissmall */
	363,	/* 240 Ethsmall */
	364,	/* 241 Ntildesmall */
	365,	/* 242 Ogravesmall */
	366,	/* 243 Oacutesmall */
	367,	/* 244 Ocircumflexsmall */
	368,	/* 245 Otildesmall */
	369,	/* 246 Odieresissmall */
	370,	/* 247 OEsmall */
	371,	/* 248 Oslashsmall */
	372,	/* 249 Ugravesmall */
	373,	/* 250 Uacutesmall */
	374,	/* 251 Ucircumflexsmall */
	375,	/* 252 Udieresissmall */
	376,	/* 253 Yacutesmall */
	377,	/* 254 Thornsmall */
	378,	/* 255 Ydieresissmall */

#endif /* EXENC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_expc.h ===
/* @(#)CM_VerSion xcf_expc.h atm08 1.2 16248.eco sum= 16746 atm08.003 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Expert charset aggregate initializer. Element values are SIDs.
 */

#ifndef EXCS_H
#define EXCS_H

	  1,	/* space */
	229,	/* exclamsmall */
	230,	/* Hungarumlautsmall */
	231,	/* dollaroldstyle */
	232,	/* dollarsuperior */
	233,	/* ampersandsmall */
	234,	/* Acutesmall */
	235,	/* parenleftsuperior */
	236,	/* parenrightsuperior */
	237,	/* twodotenleader */
	238,	/* onedotenleader */
	 13,	/* comma */
	 14,	/* hyphen */
	 15,	/* period */
	 99,	/* fraction */
	239,	/* zerooldstyle */
	240,	/* oneoldstyle */
	241,	/* twooldstyle */
	242,	/* threeoldstyle */
	243,	/* fouroldstyle */
	244,	/* fiveoldstyle */
	245,	/* sixoldstyle */
	246,	/* sevenoldstyle */
	247,	/* eightoldstyle */
	248,	/* nineoldstyle */
	 27,	/* colon */
	 28,	/* semicolon */
	249,	/* commasuperior */
	250,	/* threequartersemdash */
	251,	/* periodsuperior */
	252,	/* questionsmall */
	253,	/* asuperior */
	254,	/* bsuperior */
	255,	/* centsuperior */
	256,	/* dsuperior */
	257,	/* esuperior */
	258,	/* isuperior */
	259,	/* lsuperior */
	260,	/* msuperior */
	261,	/* nsuperior */
	262,	/* osuperior */
	263,	/* rsuperior */
	264,	/* ssuperior */
	265,	/* tsuperior */
	266,	/* ff */
	109,	/* fi */
	110,	/* fl */
	267,	/* ffi */
	268,	/* ffl */
	269,	/* parenleftinferior */
	270,	/* parenrightinferior */
	271,	/* Circumflexsmall */
	272,	/* hyphensuperior */
	273,	/* Gravesmall */
	274,	/* Asmall */
	275,	/* Bsmall */
	276,	/* Csmall */
	277,	/* Dsmall */
	278,	/* Esmall */
	279,	/* Fsmall */
	280,	/* Gsmall */
	281,	/* Hsmall */
	282,	/* Ismall */
	283,	/* Jsmall */
	284,	/* Ksmall */
	285,	/* Lsmall */
	286,	/* Msmall */
	287,	/* Nsmall */
	288,	/* Osmall */
	289,	/* Psmall */
	290,	/* Qsmall */
	291,	/* Rsmall */
	292,	/* Ssmall */
	293,	/* Tsmall */
	294,	/* Usmall */
	295,	/* Vsmall */
	296,	/* Wsmall */
	297,	/* Xsmall */
	298,	/* Ysmall */
	299,	/* Zsmall */
	300,	/* colonmonetary */
	301,	/* onefitted */
	302,	/* rupiah */
	303,	/* Tildesmall */
	304,	/* exclamdownsmall */
	305,	/* centoldstyle */
	306,	/* Lslashsmall */
	307,	/* Scaronsmall */
	308,	/* Zcaronsmall */
	309,	/* Dieresissmall */
	310,	/* Brevesmall */
	311,	/* Caronsmall */
	312,	/* Dotaccentsmall */
	313,	/* Macronsmall */
	314,	/* figuredash */
	315,	/* hypheninferior */
	316,	/* Ogoneksmall */
	317,	/* Ringsmall */
	318,	/* Cedillasmall */
	158,	/* onequarter */
	155,	/* onehalf */
	163,	/* threequarters */
	319,	/* questiondownsmall */
	320,	/* oneeighth */
	321,	/* threeeighths */
	322,	/* fiveeighths */
	323,	/* seveneighths */
	324,	/* onethird */
	325,	/* twothirds */
	326,	/* zerosuperior */
	150,	/* onesuperior */
	164,	/* twosuperior */
	169,	/* threesuperior */
	327,	/* foursuperior */
	328,	/* fivesuperior */
	329,	/* sixsuperior */
	330,	/* sevensuperior */
	331,	/* eightsuperior */
	332,	/* ninesuperior */
	333,	/* zeroinferior */
	334,	/* oneinferior */
	335,	/* twoinferior */
	336,	/* threeinferior */
	337,	/* fourinferior */
	338,	/* fiveinferior */
	339,	/* sixinferior */
	340,	/* seveninferior */
	341,	/* eightinferior */
	342,	/* nineinferior */
	343,	/* centinferior */
	344,	/* dollarinferior */
	345,	/* periodinferior */
	346,	/* commainferior */
	347,	/* Agravesmall */
	348,	/* Aacutesmall */
	349,	/* Acircumflexsmall */
	350,	/* Atildesmall */
	351,	/* Adieresissmall */
	352,	/* Aringsmall */
	353,	/* AEsmall */
	354,	/* Ccedillasmall */
	355,	/* Egravesmall */
	356,	/* Eacutesmall */
	357,	/* Ecircumflexsmall */
	358,	/* Edieresissmall */
	359,	/* Igravesmall */
	360,	/* Iacutesmall */
	361,	/* Icircumflexsmall */
	362,	/* Idieresissmall */
	363,	/* Ethsmall */
	364,	/* Ntildesmall */
	365,	/* Ogravesmall */
	366,	/* Oacutesmall */
	367,	/* Ocircumflexsmall */
	368,	/* Otildesmall */
	369,	/* Odieresissmall */
	370,	/* OEsmall */
	371,	/* Oslashsmall */
	372,	/* Ugravesmall */
	373,	/* Uacutesmall */
	374,	/* Ucircumflexsmall */
	375,	/* Udieresissmall */
	376,	/* Yacutesmall */
	377,	/* Thornsmall */
	378,	/* Ydieresissmall */

#endif /* EXCS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_da.c ===
/* @(#)CM_VerSion xcf_da.c atm08 1.6 16343.eco sum= 41325 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1994 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/* This code was taken from Jerry Hall by John Felton on 3/26/96 */

/*
 * Dynamic array support.
 */

/* #include "lstdio.h" */

#include "xcf_da.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Dynamic array object template */
typedef da_DCL(void, DA);

/* Initialize dynamic array */
void xcf_da_Init (void PTR_PREFIX * object, ULONG_PTR intl, unsigned long incr, AllocFunc alloc, void PTR_PREFIX *clientHook)
	{
	DA PTR_PREFIX *da = (DA PTR_PREFIX *)object;

	da->array = (void *)intl;
	da->cnt = 0;
	da->size = 0;
	da->incr = incr;
	da->init = (int (*)(void PTR_PREFIX*))NULL;
	da->alloc = alloc;
	da->hook = clientHook;
	}

/* Grow dynamic array to accomodate index */
void xcf_da_Grow (void PTR_PREFIX *object, size_t element, unsigned long index)
	{
	DA PTR_PREFIX *da = (DA PTR_PREFIX *)object;
	unsigned long newSize;

	if (da->size == 0)
		{
		/* Initial allocation */
		unsigned long intl = (unsigned long)(ULONG_PTR)da->array;
		da->array = NULL;
		newSize = (index < intl)? intl:
			intl + ((index - intl) + da->incr) / da->incr * da->incr;
		}
	else
		{
		/* Incremental allocation */
		newSize = da->size +
			((index - da->size) + da->incr) / da->incr * da->incr;
		}

	(*da->alloc)((void PTR_PREFIX * PTR_PREFIX *)&da->array, newSize * element, da->hook);

	if (da->init != (int (*)(void PTR_PREFIX*))NULL &&
      da->array != NULL)
		{
		/* Initialize new elements */
		char *p;

		for (p = &((char *)da->array)[da->size * element];
			 p < &((char *)da->array)[newSize * element];
			 p += element)
			if (da->init(p))
				break;			/* Client function wants to stop */
		}
	da->size = newSize;
	}

/* Free dynamic array */
void xcf_da_Free(void PTR_PREFIX * object)
	{
	DA PTR_PREFIX *da = (DA PTR_PREFIX *)object;
	if (da->size != 0)
		{
		da->alloc((void PTR_PREFIX * PTR_PREFIX *)&da->array, 0, da->hook);	/* Free array storage */
		da->size = 0;
		}
	}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_dtop.h ===
/* @(#)CM_VerSion xcf_dtop.h atm08 1.4 16293.eco sum= 35997 atm08.004 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1995 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * CFF dictionary operator definitions.
 * 
 * There are several kinds of fonts that are supported by CFF that have
 * different dict organizations:
 *
 *                  Top     Private     FDs     PDs
 *                  ---     -------     ---     ---
 * single master    x       x
 * synthetic        x
 * multiple master  x       x
 * CID              x                   x       x
 * chameleon        x       
 *
 * The Top dict, so named because of its position in the dictionary hierarchy,
 * is also known as the Font dict in all but CID fonts. CID fonts have two
 * arrays of Font and Private sub-dicts called FDs and PDs, respectively.
 * Synthetic fonts just have a Top dict containing a reference to another font.
 *
 * This file defines the dict operators that can appear in these dicts. In
 * order to aid font recognition and parsing, the following restrictions are 
 * imposed upon dict op ordering:
 *
 * Synthetic/top:   Must begin with cff_SyntheticBase.
 * MM/top:          Must begin cff_MultipleMaster.
 * CID/top:         Must begin with cff_ROS.
 * Chameleon/top:   Must begin with cff_Chameleon.
 * Private/PD:      cff_OtherBlues must follow cff_BlueValues and 
 *                  cff_FamilyOtherBlues must follow cff_FamilyBlues.
 *
 * If the top dict doesn't begin with one of the operators listed above it is
 * assumed to define a single master font. Chameleon fonts don't define a
 * Private dict but instead use the Private operator to specify the size and
 * offset of the Chameleon font descriptor for the font.
 *
 * Comments indicate in which dicts an op may appear along with a default
 * value, if any, within parentheses.
 */

#ifndef DICTOPS_H
#define DICTOPS_H

/* One byte operators (0-31) */
#define cff_version                 0   /* Top/FD */
#define cff_Notice                  1   /* Top/FD */
#define cff_FullName                2   /* Top/FD */
#define cff_FamilyName              3   /* Top/FD */
#define cff_Weight                  4   /* Top/FD */
#define cff_FontBBox                5   /* Top/FD */
#define cff_BlueValues              6   /* Private/PD (empty array) */
#define cff_OtherBlues              7   /* Private/PD */
#define cff_FamilyBlues             8   /* Private/PD */
#define cff_FamilyOtherBlues        9   /* Private/PD */
#define cff_StdHW                   10  /* Private/PD */
#define cff_StdVW                   11  /* Private/PD */
#define cff_escape                  12  /* All. Shared with T2 op */
#define cff_UniqueID                13  /* Top/FD */
#define cff_XUID                    14  /* Top/FD */
#define cff_charset                 15  /* Top/FD (0) */
#define cff_Encoding                16  /* Top/FD (0) */
#define cff_CharStrings             17  /* Top/FD */
#define cff_Private                 18  /* Top/FD */
#define cff_Subrs                   19  /* Private/PD */
#define cff_defaultWidthX           20  /* Private/PD (0) */
#define cff_nominalWidthX           21  /* Private/PD (0) */
#define cff_reserved22              22
#define cff_reserved23              23
#define cff_reserved24              24
#define cff_reserved25              25
#define cff_reserved26              26
#define cff_reserved27              27
#define cff_shortint                28  /* All. Shared with T2 op */
#define cff_longint                 29  /* All */
#define cff_BCD                     30  /* All */  
#define cff_T2                      31  /* Top/Private */
#define cff_reserved255             255
#define cff_LAST_ONE_BYTE_OP        cff_T2

/* Make escape operator value; may be redefined to suit implementation */
#ifndef cff_ESC
#define cff_ESC(op)                 (cff_escape<<8|(op))
#endif

/* Two byte operators */
#define cff_Copyright               cff_ESC(0)  /* Top/FD */
#define cff_isFixedPitch            cff_ESC(1)  /* Top/FD (false) */
#define cff_ItalicAngle             cff_ESC(2)  /* Top/FD (0) */
#define cff_UnderlinePosition       cff_ESC(3)  /* Top/FD (-100) */
#define cff_UnderlineThickness      cff_ESC(4)  /* Top/FD (50) */
#define cff_PaintType               cff_ESC(5)  /* Top/FD (0) */
#define cff_CharstringType          cff_ESC(6)  /* Top/FD (2) */
#define cff_FontMatrix              cff_ESC(7)  /* Top/FD (.001 0 0 .001 0 0)*/
#define cff_StrokeWidth             cff_ESC(8)  /* Top/FD (0) */
#define cff_BlueScale               cff_ESC(9)  /* Private/PD (0.039625) */
#define cff_BlueShift               cff_ESC(10) /* Private/PD (7) */
#define cff_BlueFuzz                cff_ESC(11) /* Private/PD (1) */
#define cff_StemSnapH               cff_ESC(12) /* Private/PD */
#define cff_StemSnapV               cff_ESC(13) /* Private/PD */
#define cff_ForceBold               cff_ESC(14) /* Private/PD (false) */
#define cff_ForceBoldThreshold      cff_ESC(15) /* Private/PD (0) */
#define cff_lenIV                   cff_ESC(16) /* Private/PD (-1) */
#define cff_LanguageGroup           cff_ESC(17) /* Private/PD */
#define cff_ExpansionFactor         cff_ESC(18) /* Private/PD (0.06) */
#define cff_initialRandomSeed       cff_ESC(19) /* Private/PD (0) */
#define cff_SyntheticBase           cff_ESC(20) /* Top/FD */
#define cff_PostScript              cff_ESC(21) /* Private/PD */
#define cff_BaseFontName            cff_ESC(22) /* Top/FD */
#define cff_BaseFontBlend           cff_ESC(23) /* Top/FD */
#define cff_MultipleMaster          cff_ESC(24) /* Top */
#define cff_reservedESC25           cff_ESC(25) /* Top */
#define cff_BlendAxisTypes          cff_ESC(26) /* Top */
#define cff_reservedESC27           cff_ESC(27)
#define cff_reservedESC28           cff_ESC(28)
#define cff_reservedESC29           cff_ESC(29)
#define cff_ROS                     cff_ESC(30) /* Top */
#define cff_CIDFontVersion          cff_ESC(31) /* Top (0) */
#define cff_CIDFontRevision         cff_ESC(32) /* Top (0) */
#define cff_CIDFontType             cff_ESC(33) /* Top (0) */
#define cff_CIDCount                cff_ESC(34) /* Top (8720) */
#define cff_UIDBase                 cff_ESC(35) /* Top */
#define cff_FDArray                 cff_ESC(36) /* Top */
#define cff_FDSelect                cff_ESC(37) /* Top */
#define cff_FontName                cff_ESC(38) /* FD */
#define cff_Chameleon               cff_ESC(39) /* Top */
#define cff_LAST_TWO_BYTE_OP        cff_Chameleon
/*                                          40-255 Reserved */

/* Predefined charsets (cff_charset operands) */
#define cff_ISOAdobeCharset         0
#define cff_ExpertCharset           1
#define cff_ExpertSubsetCharset     2

/* Predefined encodings (cff_Encoding operands) */
#define cff_StandardEncoding        0
#define cff_ExpertEncoding          1

#endif /* DICTOPS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_da.h ===
/* @(#)CM_VerSion xcf_da.h atm08 1.3 16343.eco sum= 37189 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1994 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/* This code was taken from Jerry Hall by John Felton on 3/26/96 */

#ifndef XCF_DA_H
#define XCF_DA_H

#include "xcf_base.h"
#include "xcf_pub.h"

/* Dynamic array support.

Overview
========
The da (dynamic array) library provides simple and flexible support for
homogeneous arrays that automatically grow to accomodate new elements. da's are
particularly useful in situations where the size of the array isn't known at
compile or run time until the last element has been stored and no suitable
default size can be determined. Such situations occur, for example, when data
is being read from a file and loaded into an array. In order to use a da object
a client program must perform 4 steps:

1. Initialize the da module.
2. Declare and initialize a da object.
3. Add data to the da object via one of the access macros.
4. Use the data in the da object.

Each of these steps is described in more detail in the following sections.

The da object
=============
A da is implemented as a C stucture that contains a pointer to a dynamically
allocated array and a few fields to control (re)allocation, and optional
initialization, of elements of that array.

struct
    {
    <type> *array;
    long cnt;
    unsigned long size;
    unsigned long incr;
    int (*init)(<type> *element);
	} <name>;

Field							Description
-----							-----------
<type> *array					This is a pointer to the first element of a
								dynamically allocated array. Each element has
								type <type> which may be any C data type.

long cnt						This is a count of the number of elements of
								the array that are in use which is also the
								index of the next free element of the array.

unsigned long size				This is the total number of elements available
								in the array.

unsigned long incr				This is the number of elements by which the
								array grows in order to accomodate a new index.

int (*init)(<type> *element)	This is the address of a client-supplied
								function that initializes new elements of the
								array.

[Note: <name> and <type> are supplied by the client program via declaration
macros.]

Library Initialization
======================
The da library must be initialized with the addresses of the client's memory
memory management functions before any da is accessed. Initialization is simply
achieved by calling da_SetMemFuncs() before the first use of the da library.
The client functions must have the following prototypes:

    void *(*alloc)(size_t size);
    void *(*resize)(void *old, size_t size);
    void (*dealloc)(void *ptr));

The prototypes of these functions are identical to the standard C library
functions: malloc, realloc, and free. The client-provided functions must handle
out-of-memory errors either by exiting the program or longjumping to a special
handler. Failure to take these precautions will cause a fatal error to occur in
the da access functions after memory is exhausted. If the standard C library
functions are used they should be wrapped with code that handles the
out-of-memory errors.

Declaration
===========
A da may be declared with one of 2 declaration macros:

    da_DCL(<type>, <name>);
    da_DCLI(<type>, <name>, <initial>, <increment>);

where:

    <type> is the array element type.
    <name> is the da object name.
    <initial> is the number of array elements initially allocated.
    <increment> is the number of elements by which the array subsequently
        grows.

The first form simply declares the da object without initialization (which
must be performed subsequently). The second form declares the da object and
initializes it using an agregate initializer. The first form is used when the
da object is a field in another structure and can't be initialized with an
agregate initializer. The second form is used when the da object is a global or
automatic variable and is preferred over the other form when circumstances
permit.

Object Initialization
=====================
As mentioned above it is preferable to use the da_DCLI macro to initialize the
da object where permitted. When circumstances force the use of the da_DCL macro
you must explicitly initialize the da object before it's used. This is achieved
by calling either of the following macros:

    da_INIT(<name>, <initial>, <increment>);
    da_INIT_ONCE(<name>, <initial>, <increment>);

where:
    <name> is the da object name.
    <initial> is the number of array elements initially allocated.
    <increment> is the number of elements by which the array subsequently
        grows.

The first form is used in situations where the macro is only executed once. The
second form is used in situations where the macro may be executed more than
once but initization is performed during the first call only. Such situations
occur when clients may be reusing a da but don't want to separate the
initialization from the reuse.

cnt initialization, init initialization

Access
======
Once a da has be declared and initialized it may be accessed so that elements
of the underlying array can be loaded. This is accomplished by using the
following macros:

    da_GROW(<name>, <index>);
    da_INDEX(<name>, <index>);
    da_NEXT(<name>);
    da_EXTEND(<name>, <length>);

The first two forms specify access to an explict <index>. The last two forms
specify access to an implicit index which is the next free element of the array
given by the da object's cnt field. In all cases if the index is greater than
or equal to the size of the array the da_Grow() function is called to grow the
array enough to accomodate the new index.


[This needs finishing--JH]

 */

/* Functions:
 *
 * da_Init			Only call via da_INIT or da_INIT_ONCE
 * da_Grow			Only call via da_GROW, da_INDEX, or da_NEXT
 * da_Free			Only call via da_FREE
 * da_SetMemFuncs	Set memory management functions (initializes da module)
 */


typedef unsigned long int (*AllocFunc) (void PTR_PREFIX * PTR_PREFIX *ppBlock,
																				unsigned long int size, void PTR_PREFIX
																				*clientHook);
#ifdef __cplusplus
extern "C" {
#endif
extern void xcf_da_Init (void PTR_PREFIX *object, ULONG_PTR intl, unsigned long incr, AllocFunc alloc, void PTR_PREFIX *clientHook);
extern void xcf_da_Grow(void PTR_PREFIX *object, size_t element, unsigned long index);
extern void xcf_da_Free(void PTR_PREFIX *object);
#ifdef __cplusplus
}
#endif

/* Creation/destruction:
 *
 * da_DCL	Declare da object (initialize with da_INIT or da_INIT_ONCE)
 * da_DCLI	Declare and initialize da object
 * da_FREE	Free array
 */
#define da_DCL(type,da) \
struct \
    { \
	type PTR_PREFIX *array; \
	unsigned long cnt; \
	unsigned long size; \
	unsigned long incr; \
	int (* init)(type PTR_PREFIX *element); \
	AllocFunc alloc; \
	void PTR_PREFIX *hook; \
	} da
#define da_DCLI(type,da,intl,incr) da_DCL(type,da)={(type PTR_PREFIX *)intl,0,0,incr,NULL}
#define da_FREE(da) xcf_da_Free(&(da))

/* Initialization:
 *
 * da_INIT		Unconditional initialization
 * da_INIT_ONCE	Conditional initialization
 */
#define da_INIT(da,intl,incr,alloc,hook) xcf_da_Init((void PTR_PREFIX *)(&(da)),intl,incr,alloc,hook)
#define da_INIT_ONCE(da,intl,incr,alloc,hook) \
    do{if((da).size==0)xcf_da_Init((void PTR_PREFIX *)(&(da)),intl,incr,alloc,hook);}while(0)

/* Access:
 *
 * da_GROW  	Grow da enough to accommodate index and return array
 * da_INDEX		Grow da, return pointer to indexed element
 * da_NEXT		Grow da, return pointer to next element and bump count
 * da_EXTEND	Grow da, return pointer to next element and extend count
 */
#define da_GROW(da,inx) ((inx)>=(da).size? \
    (xcf_da_Grow((void PTR_PREFIX *)(&(da)),sizeof((da).array[0]),inx), \
	 (da).array):(da).array)

#define da_INDEX(da,inx) (&da_GROW(da,inx)[inx])

#define da_INDEXI(da,inx) \
	(&da_GROW(da,inx)[((da).cnt=(((inx)>(da).cnt)?(inx):(da).cnt),(inx))])

#define da_NEXT(da) (((da).cnt)>=(da).size? \
    (xcf_da_Grow((void PTR_PREFIX *)(&(da)),sizeof((da).array[0]),(da).cnt),\
	 &(da).array[(da).cnt++]):&(da).array[(da).cnt++])

#define da_EXTEND(da,len) (((da).cnt+(len)-1)>=(da).size? \
    (xcf_da_Grow((void PTR_PREFIX *)(&(da)),sizeof((da).array[0]),(da).cnt+(len)-1), \
	 &(da).array[(da).cnt+=(len),(da).cnt-(len)]): \
	 &(da).array[(da).cnt+=(len),(da).cnt-(len)])

#endif /* XCF_DA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_exsc.h ===
/* @(#)CM_VerSion xcf_exsc.h atm08 1.2 16248.eco sum= 16463 atm08.003 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Expert subset charset aggregate initializer. Element values are SIDs.
 */

#ifndef EXSUBCS_H
#define EXSUBCS_H

	  1,	/* space */
	231,	/* dollaroldstyle */
	232,	/* dollarsuperior */
	235,	/* parenleftsuperior */
	236,	/* parenrightsuperior */
	237,	/* twodotenleader */
	238,	/* onedotenleader */
	 13,	/* comma */
	 14,	/* hyphen */
	 15,	/* period */
	 99,	/* fraction */
	239,	/* zerooldstyle */
	240,	/* oneoldstyle */
	241,	/* twooldstyle */
	242,	/* threeoldstyle */
	243,	/* fouroldstyle */
	244,	/* fiveoldstyle */
	245,	/* sixoldstyle */
	246,	/* sevenoldstyle */
	247,	/* eightoldstyle */
	248,	/* nineoldstyle */
	 27,	/* colon */
	 28,	/* semicolon */
	249,	/* commasuperior */
	250,	/* threequartersemdash */
	251,	/* periodsuperior */
	253,	/* asuperior */
	254,	/* bsuperior */
	255,	/* centsuperior */
	256,	/* dsuperior */
	257,	/* esuperior */
	258,	/* isuperior */
	259,	/* lsuperior */
	260,	/* msuperior */
	261,	/* nsuperior */
	262,	/* osuperior */
	263,	/* rsuperior */
	264,	/* ssuperior */
	265,	/* tsuperior */
	266,	/* ff */
	109,	/* fi */
	110,	/* fl */
	267,	/* ffi */
	268,	/* ffl */
	269,	/* parenleftinferior */
	270,	/* parenrightinferior */
	272,	/* hyphensuperior */
	300,	/* colonmonetary */
	301,	/* onefitted */
	302,	/* rupiah */
	305,	/* centoldstyle */
	314,	/* figuredash */
	315,	/* hypheninferior */
	158,	/* onequarter */
	155,	/* onehalf */
	163,	/* threequarters */
	320,	/* oneeighth */
	321,	/* threeeighths */
	322,	/* fiveeighths */
	323,	/* seveneighths */
	324,	/* onethird */
	325,	/* twothirds */
	326,	/* zerosuperior */
	150,	/* onesuperior */
	164,	/* twosuperior */
	169,	/* threesuperior */
	327,	/* foursuperior */
	328,	/* fivesuperior */
	329,	/* sixsuperior */
	330,	/* sevensuperior */
	331,	/* eightsuperior */
	332,	/* ninesuperior */
	333,	/* zeroinferior */
	334,	/* oneinferior */
	335,	/* twoinferior */
	336,	/* threeinferior */
	337,	/* fourinferior */
	338,	/* fiveinferior */
	339,	/* sixinferior */
	340,	/* seveninferior */
	341,	/* eightinferior */
	342,	/* nineinferior */
	343,	/* centinferior */
	344,	/* dollarinferior */
	345,	/* periodinferior */
	346,	/* commainferior */

#endif /* EXSUBCS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_fp.c ===
/* @(#)CM_VerSion xcf_fp.c atm09 1.3 16499.eco sum= 31680 atm09.002 */
/* @(#)CM_VerSion xcf_fp.c atm08 1.3 16343.eco sum= 19313 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Fixed point multiply, divide, and conversions.
 * The double-to-int conversion is assumed to truncate rather than round;
 * this is specified by the C language manual. The direction of truncation
 * is machine-dependent, but is toward zero rather than toward minus
 * infinity on the Vax and Sun. This explains the peculiar way in which
 * fixmul and fixdiv do rounding.
 */

#include "xcf_priv.h"

#if (USE_FIXMUL == USE_HWFP)
Fixed XCF_FixMul(Fixed x, Fixed y)       /* returns x*y */
{
  double d = (double) x * (double) y / fixedScale;
  d += (d < 0)? -0.5 : 0.5;
  if (d >= FixedPosInf) return FixedPosInf;
  if (d <= FixedNegInf) return FixedNegInf;
  return (Fixed) d;
}
#endif

#if (USE_FIXMUL == USE_SWFP)
Fixed XCF_SWFixMul(Fixed x, Fixed y);
Fixed XCF_SWFixMul(Fixed x, Fixed y)       /* returns x*y */
{
  Int32 xu, yu, up, sign;
    
  if (x && y) {

    sign = x ^ y;
    if (x < 0)  x = -x;
    if (y < 0)  y = -y; 

    xu = x >> 16; x = x & 0xffff;
    yu = y >> 16; y = y & 0xffff;

    up = (xu * yu);
    if (!(up >> 15)) { /* overflow */
      x = (x * yu) + (xu * y) + (up << 16) +
          ((((unsigned int)(x * y) >> 15) + 1) >> 1);
      if (x >= 0) return (sign < 0) ? -x : x;
    }
    return (sign < 0) ? FixedNegInf : FixedPosInf;
  }
  return 0;
}
#endif

#if (USE_FIXDIV == USE_HWFP)
Fixed XCF_FixDiv(Fixed x, Fixed y)       /* returns x/y */
{
  double d;
  if (y == 0) return (x < 0)? FixedNegInf : FixedPosInf;
  d = (double) x / (double) y * fixedScale;
  d += (d < 0)? -0.5 : 0.5;
  if (d >= FixedPosInf) return FixedPosInf;
  if (d <= FixedNegInf) return FixedNegInf;
  return (Fixed) d;
}
#endif

#if (USE_FIXDIV == USE_SWFP)
Fixed XCF_SWFixDiv(Fixed i, Fixed j);
Fixed XCF_SWFixDiv(Fixed i, Fixed j)
{
  Int32 q,m;
  unsigned int sign = (unsigned int)((i ^ j) >> 31) & 1;  /* should not need & */
 
  if (i) {    /* zero divided by anything is zero */
    if (j) {    /* divide by zero is infinity */
      if (i < 0) i = -i;  /* get absolute value for unsigned divide */
        if (j < 0) j = -j;  /* get absolute value for unsigned divide */
        q = i / j;          /* do the divide */
        m = i % j;          /* and remainder -- same operation? */
 
        if (!(q >> 15)) {   /* otherwise it's overflow */
          q = q << 16;
 
          if (m) {    /* otherwise no remainder -- we're done */
            if (m >> 15) { /* sigh.  Do this the hard way */
              m = m << 1; if (m > j) { q += 0x8000; m -= j;};
              m = m << 1; if (m > j) { q += 0x4000; m -= j;};
              m = m << 1; if (m > j) { q += 0x2000; m -= j;};
              m = m << 1; if (m > j) { q += 0x1000; m -= j;};
 
              m = m << 1; if (m > j) { q += 0x800; m -= j;};
              m = m << 1; if (m > j) { q += 0x400; m -= j;};
              m = m << 1; if (m > j) { q += 0x200; m -= j;};
              m = m << 1; if (m > j) { q += 0x100; m -= j;};
 
              m = m << 1; if (m > j) { q += 0x80; m -= j;};
              m = m << 1; if (m > j) { q += 0x40; m -= j;};
              m = m << 1; if (m > j) { q += 0x20; m -= j;};
              m = m << 1; if (m > j) { q += 0x10; m -= j;};
 
              m = m << 1; if (m > j) { q += 0x8; m -= j;};
              m = m << 1; if (m > j) { q += 0x4; m -= j;};
              m = m << 1; if (m > j) { q += 0x2; m -= j;};
              m = m << 1; if (m > j) { q += 0x1; m -= j;};
              if ((m << 1) > j) q += 1;  /* round the result */
              return ((sign)? -q : q);
            } else {   /* oh, good -- we can use another divide */
              m = m << 16;
              q += m / j;
              m = m % j;
              if ((m << 1) > j) q += 1;  /* round the result */
              return ((sign)? -q : q);
            }
          }
          return ((sign)? -q : q);
        }
      } return (sign + FixedPosInf);
  } return ((j) ? 0 : FixedPosInf);
}
#endif

#if (USE_FRACMUL == USE_HWFP)
Frac XCF_FracMul(Frac x, Frac y)
{
  Int32 sign = x ^ y;
  double d = (double) x * (double) y / fracScale;
  if (sign >= 0) { /* positive result */
    d += 0.5;
    if (d < (double)FixedPosInf) return (Fixed) d;
    return FixedPosInf;
  }
  /* result is negative */
  d -= 0.5;
  if(d > (double)FixedNegInf) return (Fixed) d;
  return FixedNegInf;
}
#endif

#if (USE_FRACMUL == USE_SWFP)
Frac XCF_SWFracMul(Frac x, Frac y);
Frac XCF_SWFracMul(Frac x, Frac y)
{
    Int32 xu, yu, up, sign;
    
    if (x && y) {

      sign = x ^ y;
      if (x < 0)  x = -x;
      if (y < 0)  y = -y; 

      xu = x >> 16; x = x & 0xffff;
      yu = y >> 16; y = y & 0xffff;

      up = (xu * yu);
      if (!(up >> 29)) { /* overflow */
        x = (x * yu) + (xu * y) + ((unsigned int)(x * y) >> 16) + 0x2000;
        x = (x >> 14) & 0x3ffff;
        x += (up << 2);
        if (x >= 0) return (sign < 0) ? -x : x;
      }
      return (sign < 0) ? FixedNegInf : FixedPosInf;
    }
    return 0;
}
#endif

static long convFract[] =
    {
    65536L,
    6553L,
    655L,
    66L,
    6L
    };

/* Converts a number in Fixed format to a string and stores it in s. */
void XCF_Fixed2CString(Fixed f, char PTR_PREFIX *s, short precision,
															boolean fracType)
{
  char u[12];
  char PTR_PREFIX *t;
  short v;
  char sign;
  Card32 frac;
  long fracPrec = (precision <= 4) ? convFract[precision] : 0L;

  if ((sign = f < 0) != 0)
    f = -f;

  /* If f started out as fixedMax or -fixedMax, the precision adjustment
     puts it out of bounds.  Reset it correctly. */
  if (f >= 0x7FFF7FFF)
    f =(Fixed)0x7fffffff;
  else
    f += fracType ? 0x03 : (fracPrec + 1) >> 1;

  v =  fracType ? (short)(f >> 30) : (short)(f >> 16);
  f &= fracType ? 0x3fffffff : 0x0000ffff;
  if (sign && (v || f >= fracPrec))
    *s++ = '-';
        
  t = u;
  do 
  {
    *t++ = v % 10 + '0';
    v /= 10;
  } while (v);
    
  for (; t > u;)
    *s++ = *--t;
        
  if (f >= fracPrec) 
  {
    /* If this is a fracType then shift the value right by 2 so we don't
       have to worry about overflow. If the current callers request
       more than 9 significant digits then we'll have to re-evaluate
       this to make sure we don't lose any precision. */
    frac = fracType ? f >> 2 : f;
    *s++ = '.';
    for (v = precision; v-- && frac;) 
    {
      frac = (frac << 3) + (frac << 1); /* multiply by 10 */
      *s++ = fracType ? (char)((frac >> 28) + '0') : (char)((frac >> 16) + '0');
      frac &= fracType ? 0x0fffffff : 0x0000ffff;
    }
    for (; *--s == '0';)
      ;
    if (*s != '.')
      s++;
  }
   *s = '\0';
}

#if USE_FXL
static Fxl powersof10[MAXEXP - MINEXP + 1] = {
  { 1441151880, -27 },
  { 1801439850, -24 },
  { 1125899906, -20 },
  { 1407374883, -17 },
  { 1759218604, -14 },
  { 1099511627, -10 },
  { 1374389534,  -7 },
  { 1717986918,  -4 },
  { 1073741824,   0 },
  { 1342177280,   3 },
  { 1677721600,   6 },
  { 2097152000,   9 },
  { 1310720000,  13 }
};

#define Odd(x)		((x) & 1)
#define isdigit(c)  ((c) >= '0' && (c) <= '9')

/* mkfxl -- create a normalized Fxl from mantissa and exponent */
static Fxl mkfxl(Frac mantissa, Int32 exp) 
{
    Fxl fxl;
    if (mantissa == 0)
        exp = 0;
    else {
        boolean neg;
        if (mantissa >= 0)
            neg = 0;
        else {
            mantissa = -mantissa;
            neg = 1;
        }
        
        for (; (mantissa & mostSigBit) == 0; exp--)
            mantissa <<= 1;
        
        if (neg)
            mantissa = -mantissa;
    }
    
    fxl.mantissa = mantissa;
    fxl.exp = exp;
    return fxl;
}

static Fxl fxladd (Fxl a, Fxl b) 
{
    Frac mantissa, fa, fb;
    Int32 shift, exp;

    if (FxlIsZero(a))
        return b;
    if (FxlIsZero(b))
        return a;

    shift = a.exp - b.exp;
    if (shift < 0) {
        Fxl t;
        t = a;
        a = b;
        b = t;
        shift = -shift;
    }

    exp = a.exp;
    fa = a.mantissa;
    fb = b.mantissa;
    if (shift > 0)
        if (fb >= 0) {
            fb >>= (shift - 1);
            fb = (fb >> 1) + Odd(fb);
        } 
        else {
            fb = (-fb) >> (shift - 1);
            fb = -((fb >> 1) + Odd(fb));
        }

    if ((fa < 0) == (fb < 0)) {		/* signs alike */
        boolean neg = (fa < 0) ? 1 : 0;
        unsigned long f;

        if (neg) {
            fa = -fa;
            fb = -fb;
        }
        
        f = fa + fb;
        if (f >= (Card32) 0x80000000l) {		/* overflow */
            mantissa = (f >> 1) + Odd(f);
            exp++;
        } else
            mantissa = f;
        if (neg)
            mantissa = -mantissa;
    } else
        mantissa = fa + fb;

    return mkfxl(mantissa, exp);
}

static Fxl fxlmul(Fxl a, Fxl b) 
{
    Frac f;

    /* Force a to be in [.5 .. 1) (as Frac!) to keep in range */
    if (a.mantissa >= 0)
        f = (a.mantissa >> 1) + Odd(a.mantissa);
    else
        f = -(((-a.mantissa) >> 1) + Odd(a.mantissa));

    return mkfxl(XCF_FracMul(f, b.mantissa), a.exp + b.exp + 1);
}

static Fxl fxlpow10 (Fxl f, IntX n) 
{
    if (n < 0) {
        for (; n < MINEXP; n -= MINEXP)
            f = fxlmul(f, powersof10[0]);
        f = fxlmul(f, powersof10[n - MINEXP]);
    } 
    else if (n > 0) {
        for (; n > MAXEXP; n -= MAXEXP)
            f = fxlmul(f, powersof10[MAXEXP - MINEXP]);
        
        f = fxlmul(f, powersof10[n - MINEXP]);
    }
    
    return f;
}


#if 0
static Fxl FixedToFxl (Fixed f) 
{
    return mkfxl(f, expFixed);
}
#endif

static Fxl Int32ToFxl (Int32 i) 
{
    return mkfxl(i, expInteger);
}



/*
 * strtofxl
 *	convert a PostScript numeric token to a Fxl.  we have to accept
 *	three formats:  (see pslrm 2, pp 27-28)
 *		integers:	[+-]?[0-9]+
 *		reals:		[+-]?[0-9]*('.'[0-9]*)?([eE][+-]?[0-9]+)?
 *		radix numbers:	[0-9]+'#'[0-9a-zA-Z]+
 *	note that this routine is a bit more forgiving than PostScript itself.
 */

static Fxl strtofxl(XCF_Handle h, Card8 PTR_PREFIX *token) 
{
    long    c;
    Card8 PTR_PREFIX *s;
    boolean    neg;
    Fxl     f;

    c = *token;
    if (c == '-') {
      neg = 1;
      token++;
    } 
    else {
      neg = 0;
      if (c == '+')
        token++;
    }

    for (c = *(s = token); isdigit(c); c = *++s);

    if (c == '#')
      if (s == token)
        goto INVALID;
    else {
      unsigned long radix = h->callbacks.atoi((char *) token);
        
      if (radix > 36)
        goto INVALID;
      else {
        char *t;
        long number = h->callbacks.strtol((char *) s + 1, &t, (int) radix);

	      if (*t != '\0')
	        goto INVALID;
	        
        return Int32ToFxl(neg ? -number : number);
    }
  }

  f = Int32ToFxl(h->callbacks.strtol((char *) token, NULL, 10));

  if (c == '.') {
    for (c = *(token = ++s); isdigit(c); c = *++s);

    if (s != token)
      f = fxladd(f, fxlpow10(Int32ToFxl(h->callbacks.strtol((char *) token, NULL, 10)), (IntX)(token - s)));
    }

  if (c == 'e' || c == 'E') {
    token = ++s;
    c = *s;
        
    if (c == '+' || c == '-')
      c = *++s;
       
    for (; isdigit(c); c = *++s);
        
    f = fxlpow10(f, h->callbacks.atoi((char *) token));
  }

  if (neg)
    f.mantissa = -f.mantissa;
  
  if (c == '\0')
    return f;

INVALID:
  f.mantissa = 1;
  f.exp = 30000;		/* big enough to overflow, always */
    
  return f;
}

static Fixed FxlToFixed (Fxl fxl) 
{
    Fixed f = fxl.mantissa;
    Int32  shift = fxl.exp - expFixed;
    boolean  neg = false;

    if (f == 0 || shift == 0)
        return f;
    else if (shift < 0) 
    {
        Fixed tempF = f >> (-shift - 1);
        if (tempF < 0) {
            neg = true;
            tempF = -tempF;
        }
        f = (tempF >> 1) + (tempF & 1);
        return neg ? -f : f;
    } else
        return (fxl.mantissa < 0) ? FixedNegInf : FixedPosInf;
}

static Frac FxlToFrac (Fxl fxl) 
{
    Fixed f = fxl.mantissa;
    Int32 shift = fxl.exp;
    boolean neg = false;

    if (f == 0 || shift == 0)
      return f;
    else if (shift < 0) {
      Fixed tempF = f >> (-shift - 1);
        
      if (tempF < 0) {
        neg = 1;
        tempF = -tempF;
      }
    
      f = (tempF >> 1) + (tempF & 1);
        
      return neg ? -f : f;
    } else
    return (fxl.mantissa < 0) ? FixedNegInf : FixedPosInf;
}

/* ConvertFixed -- takes an ascii token and converts to a 16.16 fixed */
Fixed XCF_ConvertFixed (XCF_Handle h, char *s) 
{
    Fxl f;

    f = strtofxl(h, (unsigned char *) s);

    return FxlToFixed(f);
}

/* ConvertFrac -- takes an ascii token and converts to a 2.30 frac */
Frac XCF_ConvertFrac (XCF_Handle h, char *s) 
{
    Fxl f;
    
    f = strtofxl(h, (unsigned char *) s);

    return FxlToFrac(f);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_fa.c ===
/* @(#)CM_VerSion xcf_fa.c atm09 1.2 16499.eco sum= 10644 atm09.002 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1998 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Minimal font authentication related functions. If full functionality
 * is needed within xcf then the fa library should be used.
 */

#ifdef __cplusplus
extern "C" {
#endif

#include "xcf_pub.h"
#include "xcf_priv.h"

#define FA_STRING_MINLENGTH 44  /* length in bytes of canonical fa string */
#define FA_SUBSET_OFFSET 10L /* offset of subset restrict. in fa string */

/* Checks the last string in the string index table for a font authentication
   string. If it is there then usageRestricted is true and the subsetting
   restrictions are returned in subset. If this is not a usageRestricted font
   then subset is set to 100. subset contains a positive number between
   0 and 100. It is the maximum percentage of glyphs that can be included
   in a subsetted font. So 0 means subsetting is not allowed and 100 means
   subsetting is unrestricted.
 */
enum XCF_Result XCF_SubsetRestrictions(XFhandle handle,              /* In */
                                       unsigned char  PTR_PREFIX *usageRestricted, /* Out */
                                       unsigned short PTR_PREFIX *subset)         /* Out */
{
  enum XCF_Result status;
  XCF_Handle h;
  char PTR_PREFIX *str;
  Card16 len;
  DEFINE_ALIGN_SETJMP_VAR;

  if (handle == 0)
    return XCF_InvalidFontSetHandle;

  h = (XCF_Handle)handle;

  /* Initialize output values. */
  *usageRestricted = 1;
  *subset = 0;

  status = (enum XCF_Result)SETJMP(h->jumpData);  /* Set up error handler */
  if (status)
    return status;

  /* If this is a protected font then the last string in the string
     index table is the font authentication string. Get the last
     string in the table and check if the length matches the fa
     string length. If it does then parse the string.
   */
  XCF_LookUpString(h,
        (StringID)(h->fontSet.strings.count - 1 + h->fontSet.stringIDBias),
        &str, &len);

  if ((len >= FA_STRING_MINLENGTH) && (str[0] == 2))
  { /* a protected font */
   long value;

    str += FA_SUBSET_OFFSET;
   value = *str++;
    *subset = (unsigned short)(value << 8 | *(unsigned char *)str);
  }
  else
  { /* not a protected font */
    *usageRestricted = 0;
    *subset = 100;
  }

  return XCF_Ok;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_mac.h ===
//
// Copyright (c) 1997 Adobe Systems Incorporated
//
/* @(#)CM_VerSion xcf_mac.h atm08 1.3 16270.eco sum= 63431 atm08.003 */
#define MAC_ENV 1
#define XCF_DEVELOP 1
#include "MacHeaders.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_isoc.h ===
/* @(#)CM_VerSion xcf_isoc.h atm08 1.2 16248.eco sum= 28583 atm08.003 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Isoadobe charset aggregate initializer. Element values are SIDs.
 */

#ifndef ISOCS_H
#define ISOCS_H

	  1,	/* space */
	  2,	/* exclam */
	  3,	/* quotedbl */
	  4,	/* numbersign */
	  5,	/* dollar */
	  6,	/* percent */
	  7,	/* ampersand */
	  8,	/* quoteright */
	  9,	/* parenleft */
	 10,	/* parenright */
	 11,	/* asterisk */
	 12,	/* plus */
	 13,	/* comma */
	 14,	/* hyphen */
	 15,	/* period */
	 16,	/* slash */
	 17,	/* zero */
	 18,	/* one */
	 19,	/* two */
	 20,	/* three */
	 21,	/* four */
	 22,	/* five */
	 23,	/* six */
	 24,	/* seven */
	 25,	/* eight */
	 26,	/* nine */
	 27,	/* colon */
	 28,	/* semicolon */
	 29,	/* less */
	 30,	/* equal */
	 31,	/* greater */
	 32,	/* question */
	 33,	/* at */
	 34,	/* A */
	 35,	/* B */
	 36,	/* C */
	 37,	/* D */
	 38,	/* E */
	 39,	/* F */
	 40,	/* G */
	 41,	/* H */
	 42,	/* I */
	 43,	/* J */
	 44,	/* K */
	 45,	/* L */
	 46,	/* M */
	 47,	/* N */
	 48,	/* O */
	 49,	/* P */
	 50,	/* Q */
	 51,	/* R */
	 52,	/* S */
	 53,	/* T */
	 54,	/* U */
	 55,	/* V */
	 56,	/* W */
	 57,	/* X */
	 58,	/* Y */
	 59,	/* Z */
	 60,	/* bracketleft */
	 61,	/* backslash */
	 62,	/* bracketright */
	 63,	/* asciicircum */
	 64,	/* underscore */
	 65,	/* quoteleft */
	 66,	/* a */
	 67,	/* b */
	 68,	/* c */
	 69,	/* d */
	 70,	/* e */
	 71,	/* f */
	 72,	/* g */
	 73,	/* h */
	 74,	/* i */
	 75,	/* j */
	 76,	/* k */
	 77,	/* l */
	 78,	/* m */
	 79,	/* n */
	 80,	/* o */
	 81,	/* p */
	 82,	/* q */
	 83,	/* r */
	 84,	/* s */
	 85,	/* t */
	 86,	/* u */
	 87,	/* v */
	 88,	/* w */
	 89,	/* x */
	 90,	/* y */
	 91,	/* z */
	 92,	/* braceleft */
	 93,	/* bar */
	 94,	/* braceright */
	 95,	/* asciitilde */
	 96,	/* exclamdown */
	 97,	/* cent */
	 98,	/* sterling */
	 99,	/* fraction */
	100,	/* yen */
	101,	/* florin */
	102,	/* section */
	103,	/* currency */
	104,	/* quotesingle */
	105,	/* quotedblleft */
	106,	/* guillemotleft */
	107,	/* guilsinglleft */
	108,	/* guilsinglright */
	109,	/* fi */
	110,	/* fl */
	111,	/* endash */
	112,	/* dagger */
	113,	/* daggerdbl */
	114,	/* periodcentered */
	115,	/* paragraph */
	116,	/* bullet */
	117,	/* quotesinglbase */
	118,	/* quotedblbase */
	119,	/* quotedblright */
	120,	/* guillemotright */
	121,	/* ellipsis */
	122,	/* perthousand */
	123,	/* questiondown */
	124,	/* grave */
	125,	/* acute */
	126,	/* circumflex */
	127,	/* tilde */
	128,	/* macron */
	129,	/* breve */
	130,	/* dotaccent */
	131,	/* dieresis */
	132,	/* ring */
	133,	/* cedilla */
	134,	/* hungarumlaut */
	135,	/* ogonek */
	136,	/* caron */
	137,	/* emdash */
	138,	/* AE */
	139,	/* ordfeminine */
	140,	/* Lslash */
	141,	/* Oslash */
	142,	/* OE */
	143,	/* ordmasculine */
	144,	/* ae */
	145,	/* dotlessi */
	146,	/* lslash */
	147,	/* oslash */
	148,	/* oe */
	149,	/* germandbls */
	150,	/* onesuperior */
	151,	/* logicalnot */
	152,	/* mu */
	153,	/* trademark */
	154,	/* Eth */
	155,	/* onehalf */
	156,	/* plusminus */
	157,	/* Thorn */
	158,	/* onequarter */
	159,	/* divide */
	160,	/* brokenbar */
	161,	/* degree */
	162,	/* thorn */
	163,	/* threequarters */
	164,	/* twosuperior */
	165,	/* registered */
	166,	/* minus */
	167,	/* eth */
	168,	/* multiply */
	169,	/* threesuperior */
	170,	/* copyright */
	171,	/* Aacute */
	172,	/* Acircumflex */
	173,	/* Adieresis */
	174,	/* Agrave */
	175,	/* Aring */
	176,	/* Atilde */
	177,	/* Ccedilla */
	178,	/* Eacute */
	179,	/* Ecircumflex */
	180,	/* Edieresis */
	181,	/* Egrave */
	182,	/* Iacute */
	183,	/* Icircumflex */
	184,	/* Idieresis */
	185,	/* Igrave */
	186,	/* Ntilde */
	187,	/* Oacute */
	188,	/* Ocircumflex */
	189,	/* Odieresis */
	190,	/* Ograve */
	191,	/* Otilde */
	192,	/* Scaron */
	193,	/* Uacute */
	194,	/* Ucircumflex */
	195,	/* Udieresis */
	196,	/* Ugrave */
	197,	/* Yacute */
	198,	/* Ydieresis */
	199,	/* Zcaron */
	200,	/* aacute */
	201,	/* acircumflex */
	202,	/* adieresis */
	203,	/* agrave */
	204,	/* aring */
	205,	/* atilde */
	206,	/* ccedilla */
	207,	/* eacute */
	208,	/* ecircumflex */
	209,	/* edieresis */
	210,	/* egrave */
	211,	/* iacute */
	212,	/* icircumflex */
	213,	/* idieresis */
	214,	/* igrave */
	215,	/* ntilde */
	216,	/* oacute */
	217,	/* ocircumflex */
	218,	/* odieresis */
	219,	/* ograve */
	220,	/* otilde */
	221,	/* scaron */
	222,	/* uacute */
	223,	/* ucircumflex */
	224,	/* udieresis */
	225,	/* ugrave */
	226,	/* yacute */
	227,	/* ydieresis */
	228,	/* zcaron */

#endif /* ISOCS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_priv.h ===
/* @(#)CM_VerSion xcf_priv.h atm09 1.3 16499.eco sum= 64834 atm09.002 */
/* @(#)CM_VerSion xcf_priv.h atm08 1.5 16343.eco sum= 50459 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1995-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

#ifndef XCF_PRIV_H
#define XCF_PRIV_H

#include "algndjmp.h"
#include "xcf_base.h"
#include "xcf_pub.h"
#include "xcf_da.h"
#include "xcf_dtop.h"
#include "xcf_txop.h"

#ifdef __cplusplus
extern "C" {
#endif

#define XCF_Version	"1.0m"

/* Font Basic Types */
#ifndef ARCH_64BIT
typedef long int Fixed;		/* 16 bits of integer, 16 bits of fraction */
#ifndef	FP_H
typedef long int Frac;    /*  2 bits of integer, 30 bits of fraction */
#endif
#else
typedef int Fixed;		/* 16 bits of integer, 16 bits of fraction */
typedef int Frac;    /*  2 bits of integer, 30 bits of fraction */
#endif

#ifndef CFF_READ_H		/* the following are already defined in cff_read.h */
typedef Card16 StringID;
typedef Card32 Offset;
#endif

typedef struct {
  Frac    mantissa;	/* signed mantissa */
  long    exp;      /* number of bits to shift to turn the mantissa
                     * into a 16.16 fixed point number:
                     *     pos => lshift, neg => rshift
                     */
} Fxl;

#define	FxlIsZero(fxl)	((fxl).mantissa == 0)

#define EOL_SPACING	62

#if UNIX_ENV
#define XCF_NEW_LINE "\n"
#else
#if defined(MAC_ENV)
#if HAS_COOLTYPE_UFL == 1
/* Note: Technically this should be \r on the Mac. But we turn on MW's
 * "Map newlines to CR" option for historic compatibility with MPW's
 * compiler that reversed the meaning of \r and \n. Thus, we have to
 * specify \n here instead, due to this compiler dependency.
 */
#define XCF_NEW_LINE "\n"
#else
#define XCF_NEW_LINE "\r"
#endif
#else
#define XCF_NEW_LINE "\r\n"
#endif
#endif

#define NOTDEF_STR ".notdef"
#define NOTDEF_GID 0
#define NOTDEF_SID 0

#define mostSigBit	0x40000000
#define	MAXEXP      4   /* must be >=0 */
#define	MINEXP      -8  /* must be <=0 */
#define expFixed    14  /* difference in exponent from Fixed to Frac */
#define expInteger  30  /* difference in exponent from integer to Frac */

#define FIXEDHALF       (Fixed)0x00008000L
#define FIXEDONE        (Fixed)0x00010000L

#ifndef FixedPosInf
#define FixedPosInf ((Fixed)0x7FFFFFFF)
#endif
#ifndef FixedNegInf
#define FixedNegInf ((Fixed)0x80000000)
#endif

#define fixedScale 65536.0      /* i=16, f=16, range [-32768, 32768) */
#define fracScale 1073741824.0  /* i=2, f=30 , range [-2, 2) */

#define ROUND_FIXED_TO_INT(x) ((Int16)(x < 0 ? ((x)-(FIXEDHALF))>>16 : ((x)+(FIXEDHALF))>>16))
#define INT_TO_FIXED(number)	(((Fixed)(number))<<16)
#define FIXED_TO_INT(number)	((Int16)((number)>>16))
#define REAL_TO_FIXED(number)	((Fixed)(number < 0 ? (number) * fixedScale - 0.5 : (number) * fixedScale + 0.5))
#define FIXED_TO_REAL(number)	((double)(number)/fixedScale)
#define REAL_TO_FRAC(number) ((Frac)number < 0 ? number * fracScale - 0.5 :	number * fracScale + 0.5)
#define FRAC_TO_REAL(number) ((double)number/fracScale)

#define ARRAY_LEN(t) (sizeof(t)/sizeof((t)[0]))

#define MAX_OUT_BUFFER 4096		/* Returned data accumulate in a buffer of this size before being returned by putBytes. */
#define MAX_ENCODE_LENGTH 500	/* Largest block of data encrypted with a single call to BufferEncrypt */
#define	MAX_EXPANSION_FACTOR 3	/* Must exceed actual data expansion for hex encoding */
#define LEN_IV_INITIAL_KEY 4330
#define EEXEC_INITIAL_KEY 55665
#define COMPACT_FONT_TYPE 2
#define INITIAL_CHARS_ON_HEX_LINE 18
#define MAX_COUNTER_GROUPS 32
#define MAX_COUNTER_BUFFER 25	/* must be greater than 22 */

/* Multiple Master Limits */
#define MAX_MM_AXES						4
#define MAX_MM_DESIGNS					16
#define MAX_BLEND1_VALUES				MAX_MM_DESIGNS

/* Stack Limits */
#define MAX_RASTERIZER_STACK_SIZE		48
#define MAX_STACK_SIZE					MAX_RASTERIZER_STACK_SIZE * 2

/* BCD Number Size Limit */
#ifndef XCF_MAX_BCD_NIBBLES  /* Changed from MAX_BCD_BYTES to avoid name space
                              * conflict. */
#define XCF_MAX_BCD_NIBBLES					16
#endif

/* Dictionary Limits */
#define MAX_STD_HW_ENTRIES					MAX_MM_DESIGNS
#define MAX_STD_VW_ENTRIES					MAX_MM_DESIGNS
#define MAX_BLUE_SCALE_ENTRIES				MAX_MM_DESIGNS
#define MAX_BLUE_SHIFT_ENTRIES				MAX_MM_DESIGNS
#define MAX_BLUE_FUZZ_ENTRIES				MAX_MM_DESIGNS
#define MAX_FORCE_BOLD_ENTRIES				MAX_MM_DESIGNS
#define MAX_FONTBBOX_ENTRIES				4  * MAX_MM_DESIGNS
#define MAX_BLUE_VALUE_ENTRIES				14 * MAX_MM_DESIGNS
#define MAX_OTHER_BLUES_ENTRIES				10 * MAX_MM_DESIGNS
#define MAX_FAMILY_BLUES_ENTRIES			14 * MAX_MM_DESIGNS
#define MAX_FAMILY_OTHER_BLUES_ENTRIES		10 * MAX_MM_DESIGNS
#define MAX_STEM_SNAP_H_ENTRIES				12 * MAX_MM_DESIGNS
#define MAX_STEM_SNAP_V_ENTRIES				12 * MAX_MM_DESIGNS
#define MAX_BLEND_DESIGN_MAP_ENTRIES		12 * MAX_MM_AXES
#define MAX_DICT_ARGS						14 * MAX_MM_DESIGNS

#define FONT_MATRIX_ENTRIES			6
#define FONT_MATRIX_ENTRY_SIZE   XCF_MAX_BCD_NIBBLES * 2 + 1 /* add one for null
																												 character */
#define PRIVATE_DICT_ENTRIES		2
#define MAX_BASE_FONT_BLEND_ENTRIES	16
#define CIDFONT_VERSION_SIZE 15
#define MAX_XUID_ENTRIES			16


#define MAX_CURRENT_OPERATION_STR_LENGTH		100

/* TrueType */
#define INITIAL_GLYPH_INFO_SIZE			256
#define INCR_GLYPH_INFO_SIZE			100
#define INITIAL_POINTS_IN_GLYPH_SIZE	200
#define INCR_POINTS_IN_GLYPH_SIZE		100

typedef Card8 FDIndex;

typedef struct
{
	CardX  count;
	CardX  offsetSize;
	Offset offsetArrayOffset;
	Offset dataOffset;
} IndexDesc;

typedef struct
{
	IntX			numberOfMasters; /* weightVectorCount */
	Fixed			weightVector[MAX_MM_DESIGNS];
  StringID  cdv;
  StringID  ndv;
  IntX      normDesignVectorCount;
  Fixed     normDesignVector[MAX_MM_AXES];
	IntX			userDesignVectorCount;
	Fixed			userDesignVector[MAX_MM_AXES + 4]; /* Include room for other
																									arguments to mm operator. */
	IntX			blendAxisTypesCount;
	Card32		blendAxisTypes[MAX_MM_AXES];
	IntX			charsetCount;
	Card32		charset;
	IntX			privateDictCount;
	Card32		privateDict[PRIVATE_DICT_ENTRIES];
	IntX			subrsCount;
	Card32		subrs;
	IntX			charStringsCount;
	Card32		charStrings;
	IntX			uniqueIDCount;
	Card32		uniqueID;
	IntX			versionCount;
	Card32		version;
	IntX			fullNameCount;
	Card32		fullName;
	IntX			familyNameCount;
	Card32		familyName;
	IntX			baseFontNameCount;
	Card32		baseFontName;
	IntX			baseFontBlendCount;
	Fixed			baseFontBlend[MAX_BASE_FONT_BLEND_ENTRIES];
	IntX			weightCount;
	Card32		weight;
	IntX			embeddedPostscriptCount;
	StringID	embeddedPostscript;
	IntX			encodingCount;
	Card32		encoding;
	IntX			defaultWidthXCount;
	Fixed			defaultWidthX;
	IntX			nominalWidthXCount;
	Fixed			nominalWidthX;
	IntX			noticeCount;
	Card32		notice;
	IntX			fontMatrixCount;
	char			fontMatrix[FONT_MATRIX_ENTRIES][FONT_MATRIX_ENTRY_SIZE];
	IntX			strokeWidthCount;
	Fixed			strokeWidth[MAX_MM_DESIGNS];
	IntX			expansionFactorCount;
	Frac			expansionFactor;
	IntX			initialRandomSeedCount;
	Fixed			initialRandomSeed;
	IntX			lenIVCount;
	Int32     lenIV;
	IntX			paintTypeCount;
	Fixed     paintType;
	IntX			languageGroupCount;
	CardX			languageGroup;
	IntX			xUIDCount;
	Card32		xUID[MAX_XUID_ENTRIES];
	IntX			lenBuildCharArrayCount;
	Fixed			lenBuildCharArray;
	IntX			italicAngleCount;
	Fixed			italicAngle[MAX_MM_DESIGNS];
	IntX			isFixedPitchCount;
	Fixed			isFixedPitch[MAX_MM_DESIGNS];
	IntX			underlinePositionCount;
	Fixed			underlinePosition[MAX_MM_DESIGNS];
	IntX			underlineThicknessCount;
	Fixed			underlineThickness[MAX_MM_DESIGNS];
	IntX			copyrightCount;
	Card32		copyright;
	IntX			fontTypeCount;
	Int32			fontType;
	IntX			syntheticBaseCount;
	Fixed			syntheticBase;
/* Multiple Master Entries */
	IntX			fontBBoxCount;
	Fixed			fontBBox[MAX_FONTBBOX_ENTRIES];
	IntX			stdHWCount;
	Fixed			stdHW[MAX_STD_HW_ENTRIES];
	IntX			stdVWCount;
	Fixed			stdVW[MAX_STD_VW_ENTRIES];
	IntX			blueValuesCount;
	Fixed			blueValues[MAX_BLUE_VALUE_ENTRIES];
	IntX			otherBluesCount;
	Fixed			otherBlues[MAX_OTHER_BLUES_ENTRIES];
	IntX			familyBluesCount;
	Fixed			familyBlues[MAX_FAMILY_BLUES_ENTRIES];
	IntX			familyOtherBluesCount;
	Fixed			familyOtherBlues[MAX_FAMILY_OTHER_BLUES_ENTRIES];
	IntX			stemSnapHCount;
	Fixed			stemSnapH[MAX_STEM_SNAP_H_ENTRIES];
	IntX			stemSnapVCount;
	Fixed			stemSnapV[MAX_STEM_SNAP_V_ENTRIES];
	IntX			blueScaleCount;
	Frac			blueScale[MAX_BLUE_SCALE_ENTRIES];
	IntX			blueShiftCount;
	Fixed			blueShift[MAX_BLUE_SHIFT_ENTRIES];
	IntX			blueFuzzCount;
	Fixed			blueFuzz[MAX_BLUE_FUZZ_ENTRIES];
	IntX			forceBoldCount;
	Fixed			forceBold[MAX_FORCE_BOLD_ENTRIES];
	IntX			forceBoldThresholdCount;
	Fixed			forceBoldThreshold;
	IndexDesc		localSubrs;
	Card16			localSubrBias;
/* Buffer to hold blend arguments in T2/endchar segments in MM dictionaries */
	IntX			mmDictArgCount;
	Fixed			mmDictArg[MAX_DICT_ARGS];
/* CID entries */
	IntX			fdFontNameCount;
	Card32		fdFontName;
	IntX			cidFontVersionCount;
	char  		cidFontVersion[CIDFONT_VERSION_SIZE];
	IntX			cidFontTypeCount;
	Int32			cidFontType;
	IntX			ROSCount;
	Card32		ROS[3];
	IntX			uidBaseCount;
	Card32		uidBase;
	IntX			cidFDArrayCount;
	Int32			cidFDArray;	/* offset to FontDict index */
	IntX			cidFDIndexCount;
	Int32			cidFDIndex;
	IntX			cidCountCount;
	Int32			cidCount;
} DictEntriesStruct;

#define CIDFONT (h->type1.cid.flags & CID_FLAG)	/* xxx do we want a better flag for this? */

typedef struct
{
	Offset offset;
	Card32  size;
} BlockDesc;

typedef struct
{
	Int16 code;
	StringID glyph;
} EncodingMap;


typedef struct
{
	CardX			fontIndex;
	CardX			majorVersion;
	CardX			minorVersion;
	CardX			offsetSize;
	CardX			headerSize;
	IndexDesc		fontNames;
	IndexDesc		fontDicts;
	IndexDesc		strings;
	IndexDesc		charStrings;
	IndexDesc		globalSubrs;
	Card16			globalSubrBias;
	BlockDesc		fontPrivDictInfo;
	Card16			stringIDBias;
} FontSetValuesStruct;

typedef struct
{
	boolean				eexecOn;
	Card8				eexecInitialBytes[4];
	Card8				lenIVInitialBytes[4];
	Card16				eexecKey;
	IntX				charsOnLine;	/* character count used for formating hex characters */
	Card8				outBuffer[MAX_OUT_BUFFER];
	Card16				outBufferCount;
	Card8				eexecEncodeBuffer[MAX_ENCODE_LENGTH*MAX_EXPANSION_FACTOR];
	Card8				charStringEncodeBuffer[MAX_ENCODE_LENGTH];
} OutBufferStruct;


typedef struct
{
	Card8 PTR_PREFIX			*start;
	Card8	PTR_PREFIX			*end;
	Card8	PTR_PREFIX			*pos;
	Offset				blockOffset;
	Card32				blockLength;
} InBufferStruct;

typedef struct
{
	Card16		fdCount;		/* number of FD's in CIDFont */
	Card32		replaceSD1;		/* number to replace in DSC comment */
	Card32		replaceSD2;		/* in PS parameter */
	Card32		charMapStart;	/* placemarkers in CID binary output */
	Card32		subrMapStart;
	Card32		subrDataStart;
	Card32		charDataStart;
	Card32		charDataEnd;
	Card32		charDataCount;
	FDIndex		*pFDIndex;
	Card16		flags;
	Card32		cidCount;		/* number of glyphs in this collection, NOT in this font */
#define CID_FLAG 1
#define WRITE_SUBR_FLAG 2
#define MAX_FD	256
	/* These vary by FD and need to be supplied to the cff->t1 conversion code. */
	Card8		languageGroup[MAX_FD];
	Fixed		nominalWidthX[MAX_FD];
	Fixed		defaultWidthX[MAX_FD];
	IndexDesc		localSubrs[MAX_FD];
	Card16			localSubrBias[MAX_FD];
}	CIDData;

typedef struct
{
	da_DCL(Card8, charStrs);
	da_DCL(Offset, charStrOffsets);
	da_DCL(Card8, subrs);
	da_DCL(Offset, subrOffsets);
	da_DCL(StringID, charset);	/* Using if custom charset (Not ISOAdobe, Expert or ExpertSubset) */
	StringID	encoding[256];	/* Using if custom encoding  (Not ISOAdobe or Expert) */
	Card16		charsetSize;
	StringID	*pCharset; /* points to standard internal charset array or dynamic array declared above */
	StringID	*pEncoding; /* points to standard internal encoding array or encoding array declared above */
	CIDData		cid;
} Type1Struct;

#ifndef MAX_OPERAND_STACK
#define MAX_OPERAND_STACK	96
#endif
#ifndef MAX_HINTS
#define MAX_HINTS	128
#endif

enum XC_PenState { PenNull, PenUp, PenDown };
enum XC_HintState { NotInHints, InitialHints, SubrHints };

enum PenStateTransition { NoPenEffect, ToPenUp, ToPenDown };
enum HintStateTransition { NoHintEffect, ToNotInHints, ToInitialHints, ToSubrHints };
enum InitialMoveStateTransition { NoMoveEffect, MoveFound, DrawFound };

typedef struct {
	boolean	blend;
	Fixed	value[MAX_MM_DESIGNS];
} StackValue, PTR_PREFIX *PStackValue;

typedef struct {
	boolean blend;
	Fixed    value;
} ShortStackValue, PTR_PREFIX *PShortStackValue;

typedef struct {
	PStackValue	edge;
	PStackValue	delta;
	Card16	opCode;
	Card32	counterGroups;	/* One bit is set for each counter group to which the stem belongs. */
} HintValue;

/* Index of the temp StackValue */
#define SV0			0
#define SV50		1
#define	SVTEMP	2
#define MAX_SVTEMP	SVTEMP+1

#define PSTACKVALUE(h, i)	(h->cstr.psvTemp[i])

/* Change this definition if you add more StackValue fields into the
   CharStrStruct */
/* x, y + stack + counterBuffer + ((HintValue.edge + HintValue.delta) * MAX_HINTS) + psvTemp */
#define NUM_STACK_VALUES	(2  + MAX_OPERAND_STACK  + MAX_COUNTER_BUFFER + ( MAX_HINTS * 2 ) + MAX_SVTEMP)

/* Change this definition if you change the StackValue definition */
#define SIZEOF_STACK_VALUES(numMasters)	(sizeof(boolean) + (sizeof(Fixed) * (numMasters)))

typedef struct
{
	enum XC_PenState	pen;
	enum XC_HintState	hints;
	boolean				waitingForHsbw;
	boolean				waitingForFirstHint;
	boolean				flexUsed;
	boolean				subrFlatten;
	Card16				 baseSeac;
	Card16				 accentSeac;
	Card16				opCode;
	PStackValue			x;
	PStackValue			y;
	PStackValue			stack[MAX_OPERAND_STACK];
	Card16 				stackTop;
	HintValue			hintMap[MAX_HINTS];
	Card16				hintCount;
	CardX				counterGroupCount;
	CardX				counterGroupHCount;
	CardX				counterGroupVCount;
	PStackValue			counterBuffer[MAX_COUNTER_BUFFER]; /* Used to break counter arguments into 22 arg callothersubrs */
	CardX				counterBufferCount;
	CardX				languageGroup;	/* must be set before parsing a charstring */
	Card16			destsvCount;
	PStackValue	psvTemp[MAX_SVTEMP];
	PStackValue pstackVal;	 /* All the StackValue points to this data space.
                            * This space is init'ed and freed in XC_Init
														* and XC_CleanUp of the xcf_cstr module. */
  void *pCounterVal; /* Pointer for the CounterValues contained in CIDFonts.
                      * This space is inited and freed in XC_Init and
                      * XC_Cleanup.
                      */
} CharStrStruct,  PTR_PREFIX *PCharStrStruct;

/* Definitions of download record state */
#define XCF_DL_CREATE 0
#define XCF_DL_INIT   1
#define XCF_DL_BASE   2
#define XCF_DL_SUBSET 3

#define IS_GLYPH_SENT(arr, i) 		      ((arr)[((i)>>3)] & (1 << ((i)&7)))
#define SET_GLYPH_SENT_STATUS(arr, i) 	(arr)[((i)>>3)] |= (1 << ((i)&7))

typedef struct
{
  unsigned short state;
  Card32 glyphsSize;        /* size of the glyphs list */
	Card8 PTR_PREFIX *glyphs;	/* a list of downloaded chars, the length
                             * of the list is equal to the number of characters
     												 * available in the charset / 8, i.e., each
                             * character consumes a single bit w/i the list
                             */
	Card8	   seacs[32];
	Card16	 cSeacs;  /* Number of seac chars found w/i a subset */
} DownloadRecordStruct;

typedef struct
{
	jmp_buf					jumpData;
	XCF_CallbackStruct		callbacks;
	DictEntriesStruct		dict;
	FontSetValuesStruct		fontSet;
	XCF_ClientOptions		options;
	OutBufferStruct			outBuffer;
	InBufferStruct			inBuffer;
	Type1Struct				type1;
	CharStrStruct			cstr;
  DownloadRecordStruct dl;
} PTR_PREFIX *XCF_Handle;


/* Misc Functions */
#ifdef XCF_DEVELOP
#define XCF_FATAL_ERROR(h, error, msg, number)	XCF_FatalErrorHandler((h),(error),(msg),(number))
extern void XCF_FatalErrorHandler(XCF_Handle hndl, int error, char *str, Card32 number);
#else
#define XCF_FATAL_ERROR(h, error, msg, number)	XCF_FatalErrorHandler((h),(error))
extern void XCF_FatalErrorHandler(XCF_Handle hndl, int error);
#endif

extern Card16 XCF_CalculateSubrBias(CardX subrCount);
extern void XCF_ReadBlock(XCF_Handle h, Offset pos, Card32 length);
extern Card32 XCF_Read(XCF_Handle h, IntX byteCount);
extern Card8 XCF_Read1(XCF_Handle h);
extern Card16 XCF_Read2(XCF_Handle h);
extern void XCF_PutData(XCF_Handle h, Card8 PTR_PREFIX *pData, Card32 length);
extern void XCF_PutString(XCF_Handle h, char PTR_PREFIX *str);
extern void XCF_FlushOutputBuffer(XCF_Handle h);
extern void XCF_SetOuputPosition(XCF_Handle h, Card32 pos);
extern double XCF_ArgPtrToDouble(XCF_Handle h, Card8 PTR_PREFIX * PTR_PREFIX
																 *ppArgList);
extern Fixed XCF_ArgPtrToFixed(XCF_Handle h, Card8 PTR_PREFIX * PTR_PREFIX
															 *ppArgList, boolean fracType);
extern  IntX XCF_FindNextOperator(XCF_Handle h, Card16 PTR_PREFIX *opCode, boolean dict);
extern void XCF_SaveDictArgumentList(XCF_Handle h, Fixed PTR_PREFIX *pArgArray,
																		 Card8 PTR_PREFIX *pArgList, IntX
																		 argCount, boolean fracType);
extern void XCF_SaveDictIntArgumentList(XCF_Handle h,
                                     Int32 PTR_PREFIX *pArgArray,
																		 Card8 PTR_PREFIX *pArgList, IntX
																		 argCount);
extern void XCF_SaveFontMatrixStr(XCF_Handle h, char (PTR_PREFIX *pArgArray)[FONT_MATRIX_ENTRY_SIZE],
																	Card8 PTR_PREFIX *pArgList, IntX argCount);
extern void XCF_SaveStrArgs(XCF_Handle h, char PTR_PREFIX *pArgArray,
														Card8 PTR_PREFIX *pArgList, IntX argCount);
extern void XCF_LookUpString(XCF_Handle h, StringID sid, char PTR_PREFIX * PTR_PREFIX *str, Card16 PTR_PREFIX *length);
extern void XCF_ReadDictionary(XCF_Handle h);
extern void XCF_LookUpTableEntry(XCF_Handle h, IndexDesc PTR_PREFIX *pIndex, CardX index);
extern void XCF_DumpGlobalCFFSections(XCF_Handle h, int	dumpCompleteFontSet);
extern void XCF_DumpFontSpecificCFFSections(XCF_Handle h);
extern void XT1_PutT1Data(XCF_Handle h, Card8 PTR_PREFIX *pData, Card32 length);
extern void XT1_WriteT1Font(XCF_Handle h);
extern void XT1_WriteCIDTop(XCF_Handle h);
extern void XT1_WriteCIDDict(XCF_Handle h, Card16 fd, Card32 subrMapOffset, Card16 subrCount);
extern void XT1_CIDBeginBinarySection(XCF_Handle h);
extern void XT1_CIDWriteSubrMap(XCF_Handle h, Card16 fdIndex);
extern void XT1_CIDWriteSubrs(XCF_Handle h, Card16 fdIndex);
extern void XT1_CIDWriteCharString(XCF_Handle h);
extern long int XCF_OutputPos(XCF_Handle h);
extern void XT1_CIDWriteCharMap(XCF_Handle h);
extern Card8 XCF_GetFDIndex(XCF_Handle h, Int32 code);
extern void XT1_CIDEndBinarySection(XCF_Handle h);
extern void XT1_WriteAdditionalGlyphDictEntries(XCF_Handle h,
    short cGlyphs, XCFGlyphID PTR_PREFIX *pGlyphID,
    unsigned long PTR_PREFIX *pCharStrLength);
extern void XT1_WriteGlyphDictEntries(XCF_Handle h, short cGlyphs,
								                XCFGlyphID PTR_PREFIX *pGlyphID,
                                unsigned long PTR_PREFIX *pCharStrLength);
extern void XT1_WriteCIDVMBinarySection(XCF_Handle h);
extern void XC_SetUpStandardSubrs(XCF_Handle h);
extern void XC_DVToSubr(XCF_Handle h);

#if HAS_COOLTYPE_UFL == 1
/* These functions are just called from CoolType when converting a CIDFont to
   a VMCIDFont. Caution should be used when calling these functions because
   it depends on certain internal data structures being initialized.
 */
extern Card32 PutType1CharString(XCF_Handle h, Card8 PTR_PREFIX *pData, Card32
																 length);
extern void PutSizedNumber(XCF_Handle h, Card32 value, Card16 size);
#endif

#ifndef USE_FIXDIV
#define USE_FIXDIV USE_HWFP
#endif

#ifndef USE_FIXMUL
#define USE_FIXMUL USE_HWFP
#endif

#ifndef USE_FRACMUL
#define USE_FRACMUL USE_HWFP
#endif

/* Fixed arithmetic functions. */
extern Fixed XCF_FixMul(Fixed x, Fixed y);
extern Fixed XCF_FixDiv(Fixed x, Fixed y);
extern Frac XCF_FracMul(Frac x, Frac y);
extern void XCF_Fixed2CString(Fixed f, char PTR_PREFIX *s, short precision,
															boolean fracType);

#ifdef USE_FXL
Fixed XCF_ConvertFixed (XCF_Handle h, char *s);
Frac XCF_ConvertFrac (XCF_Handle h, char * s);
#endif


/* Charstring Processing Functions */
extern void XC_Init(XCF_Handle h);
extern void XC_ProcessCharstr(XCF_Handle h);
extern void XC_CleanUp(XCF_Handle h);
extern void XC_SetCounters(XCF_Handle h, boolean subr);
extern void XC_WriteHStem(XCF_Handle h, boolean subr);
extern void XC_WriteVStem(XCF_Handle h, boolean subr);
extern void XC_WriteHMoveTo(XCF_Handle h, boolean subr);
extern void XC_WriteVMoveTo(XCF_Handle h, boolean subr);
extern void XC_WriteRLineTo(XCF_Handle h, boolean subr);
extern void XC_WriteRMoveTo(XCF_Handle h, boolean subr);
extern void XC_WriteHLineToAndVLineTo(XCF_Handle h, boolean hLine, boolean subr);
extern void XC_WriteRRCurveTo(XCF_Handle h, boolean subr);
extern void XC_WriteEndChar(XCF_Handle h, boolean subr);
extern void XC_WriteRCurveLine(XCF_Handle h, boolean subr);
extern void XC_WriteRLineCurve(XCF_Handle h, boolean subr);
extern void XC_WriteVVCurveTo(XCF_Handle h, boolean subr);
extern void XC_WriteHHCurveTo(XCF_Handle h, boolean subr);
extern void XC_WriteHVorVHCurveTo(XCF_Handle h, boolean hvCurve, boolean subr);
extern void XC_WriteDotSection(XCF_Handle h, boolean subr);
extern void XC_WriteFlex(XCF_Handle h, boolean subr);
extern void XC_WriteFlex1(XCF_Handle h, boolean subr);
extern void XC_WriteHFlex(XCF_Handle h, boolean subr);
extern void XC_WriteHFlex1(XCF_Handle h, boolean subr);
extern void XC_WriteHintMask(XCF_Handle h, boolean subr);
extern void XC_WriteT1PStackValue(XCF_Handle h, PStackValue psv, boolean subr);
extern void XC_WriteT1OpCode(XCF_Handle h, Card16 opCode, boolean subr);

extern int XC_ParseCharStr(XCF_Handle h, unsigned char PTR_PREFIX *cstr, int init);

/* CoolType is the only client that requires the mm specific code in xcf
 * because it converts all Type 1 fonts (including mm) to CFF then calls
 * xcf to download. Other clients should be directly dealing with OpenType
 * fonts and there should never be an OpenType mm font. Instances will be
 * generated instead.
 */
#if HAS_COOLTYPE_UFL == 1
extern int XC_TransDesignChar(XCF_Handle h, CardX sid);
extern void XC_ProcessTransDesignSubrs(XCF_Handle h);
#endif

extern int XCF_TransDesignFont(XCF_Handle h);

/* Downloading Functions */
extern void XT1_WriteFontSubset(XCF_Handle h, short cCharStr,
                               XCFGlyphID PTR_PREFIX *pCharStrID,
                               unsigned char PTR_PREFIX **pGlyphName,
                               unsigned long PTR_PREFIX *pCharStrLength);
extern void XT1_WriteAdditionalFontSubset(XCF_Handle h, short cCharStr,
                XCFGlyphID PTR_PREFIX *pCharStrID,
                unsigned char PTR_PREFIX **pGlyphName,
                unsigned long PTR_PREFIX *pCharStrLength);
extern void ProcessOneCharString(XCF_Handle h, unsigned int index);
extern CardX GetStdEncodeSID(CardX gid);
extern char PTR_PREFIX *GetStdEncodingName(CardX gid);
extern void CheckSeacCharString(XCF_Handle h, CardX index);

#ifdef XCF_DEVELOP
extern void XT1_ShowHexString(XCF_Handle h, unsigned char PTR_PREFIX* hexString,
                              boolean	showCtrlD);
/*************************************************************************
Function name:  XCF_ShowHexString()
Summary:        Show a string
Description:    This function is used to display a hex string.
Parameters:
				fontsetHandle - XCF fontset handle obtained from XCF_Init().
				hexString - hex string to display
				showCtrlD - set this to true if you want to add a control D
				at the end of the page.  This is used in a Windows environment.

Return Values:  standard XCF_Result values
*************************************************************************/
extern enum XCF_Result XCF_ShowHexString(XFhandle fonsetHandle,
            unsigned char PTR_PREFIX *hexString, unsigned char showCtrlD);
#endif

#define OpCode(op) (0x0FF & (op))		/* strip the escape off an opcode */
#define IsEscOp(op) (!!(0xFF00 & (op)))	/* Is this an escape-op? */

#define HintSubtitutionOtherSubrStr \
"{" XCF_NEW_LINE \
"systemdict /internaldict known not" XCF_NEW_LINE \
"{pop 3}" XCF_NEW_LINE \
"{1183615869 systemdict /internaldict get exec" XCF_NEW_LINE \
	" dup /startlock known" XCF_NEW_LINE \
	" {/startlock get exec}" XCF_NEW_LINE \
	" {dup /strtlck known" XCF_NEW_LINE \
	" {/strtlck get exec}" XCF_NEW_LINE \
	" {pop 3}" XCF_NEW_LINE \
	" ifelse}" XCF_NEW_LINE \
	" ifelse}" XCF_NEW_LINE \
	" ifelse" XCF_NEW_LINE \
	"} executeonly" XCF_NEW_LINE

#define FlexOtherSubrStr1 \
	"[systemdict /internaldict known" XCF_NEW_LINE \
	"{1183615869 systemdict /internaldict get exec" XCF_NEW_LINE \
	"/FlxProc known {save true} {false} ifelse}" XCF_NEW_LINE \
	"{userdict /internaldict known not {" XCF_NEW_LINE \
	"userdict /internaldict" XCF_NEW_LINE \
	"{count 0 eq" XCF_NEW_LINE \
	"{/internaldict errordict /invalidaccess get exec} if" XCF_NEW_LINE \
	"dup type /integertype ne" XCF_NEW_LINE \
	"{/internaldict errordict /invalidaccess get exec} if" XCF_NEW_LINE \
	"dup 1183615869 eq" XCF_NEW_LINE
#define FlexOtherSubrStr2 \
	"{pop 0}" XCF_NEW_LINE \
	"{/internaldict errordict /invalidaccess get exec}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"}" XCF_NEW_LINE \
	"dup 14 get 1 25 dict put" XCF_NEW_LINE \
	"bind executeonly put" XCF_NEW_LINE \
	"} if" XCF_NEW_LINE \
	"1183615869 userdict /internaldict get exec" XCF_NEW_LINE \
	"/FlxProc known {save true} {false} ifelse}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE
#define FlexOtherSubrStr3 \
	"[" XCF_NEW_LINE \
	"systemdict /internaldict known not" XCF_NEW_LINE \
	"{ 100 dict /begin cvx /mtx matrix /def cvx } if" XCF_NEW_LINE \
	"systemdict /currentpacking known {currentpacking true setpacking} if" XCF_NEW_LINE \
	"{" XCF_NEW_LINE \
	"systemdict /internaldict known {" XCF_NEW_LINE \
	"1183615869 systemdict /internaldict get exec" XCF_NEW_LINE \
	"dup /$FlxDict known not {" XCF_NEW_LINE \
	"dup dup length exch maxlength eq" XCF_NEW_LINE \
	"{ pop userdict dup /$FlxDict known not" XCF_NEW_LINE
#define FlexOtherSubrStr4 \
	"{ 100 dict begin /mtx matrix def" XCF_NEW_LINE \
	"dup /$FlxDict currentdict put end } if }" XCF_NEW_LINE \
	"{ 100 dict begin /mtx matrix def" XCF_NEW_LINE \
	"dup /$FlxDict currentdict put end }" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"} if /$FlxDict get begin } if" XCF_NEW_LINE \
	"grestore" XCF_NEW_LINE \
	"/exdef {exch def} def" XCF_NEW_LINE \
	"/dmin exch abs 100 div def" XCF_NEW_LINE \
	"/epX exdef /epY exdef" XCF_NEW_LINE
#define FlexOtherSubrStr5 \
	"/c4y2 exdef /c4x2 exdef /c4y1 exdef /c4x1 exdef /c4y0 exdef /c4x0 exdef" XCF_NEW_LINE \
	"/c3y2 exdef /c3x2 exdef /c3y1 exdef /c3x1 exdef /c3y0 exdef /c3x0 exdef" XCF_NEW_LINE \
	"/c1y2 exdef /c1x2 exdef /c2x2 c4x2 def /c2y2 c4y2 def" XCF_NEW_LINE \
	"/yflag c1y2 c3y2 sub abs c1x2 c3x2 sub abs gt def" XCF_NEW_LINE \
	"/PickCoords { " XCF_NEW_LINE \
	"{c1x0 c1y0 c1x1 c1y1 c1x2 c1y2 c2x0 c2y0 c2x1 c2y1 c2x2 c2y2}" XCF_NEW_LINE \
	"{c3x0 c3y0 c3x1 c3y1 c3x2 c3y2 c4x0 c4y0 c4x1 c4y1 c4x2 c4y2}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"/y5 exdef /x5 exdef /y4 exdef /x4 exdef /y3 exdef /x3 exdef" XCF_NEW_LINE \
	"/y2 exdef /x2 exdef /y1 exdef /x1 exdef /y0 exdef /x0 exdef" XCF_NEW_LINE
#define FlexOtherSubrStr6 \
	"} def" XCF_NEW_LINE \
	"mtx currentmatrix pop " XCF_NEW_LINE \
	"mtx 0 get abs .00001 lt mtx 3 get abs .00001 lt or" XCF_NEW_LINE \
	"{/flipXY -1 def}" XCF_NEW_LINE \
	"{mtx 1 get abs .00001 lt mtx 2 get abs .00001 lt or" XCF_NEW_LINE \
	"{/flipXY 1 def}" XCF_NEW_LINE \
	"{/flipXY 0 def}" XCF_NEW_LINE \
	"ifelse }" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"/erosion 1 def " XCF_NEW_LINE
#define FlexOtherSubrStr7 \
	"systemdict /internaldict known {" XCF_NEW_LINE \
 	" 1183615869 systemdict /internaldict get exec dup " XCF_NEW_LINE \
	"/erosion known" XCF_NEW_LINE \
	"{/erosion get /erosion exch def}" XCF_NEW_LINE \
	"{pop}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"} if" XCF_NEW_LINE \
	"yflag" XCF_NEW_LINE \
	"{flipXY 0 eq c3y2 c4y2 eq or" XCF_NEW_LINE \
	"{false PickCoords}" XCF_NEW_LINE
#define FlexOtherSubrStr8 \
	"{/shrink c3y2 c4y2 eq" XCF_NEW_LINE \
	"{0}{c1y2 c4y2 sub c3y2 c4y2 sub div abs} ifelse def" XCF_NEW_LINE \
	"/yshrink {c4y2 sub shrink mul c4y2 add} def" XCF_NEW_LINE \
	"/c1y0 c3y0 yshrink def /c1y1 c3y1 yshrink def" XCF_NEW_LINE \
	"/c2y0 c4y0 yshrink def /c2y1 c4y1 yshrink def" XCF_NEW_LINE \
	"/c1x0 c3x0 def /c1x1 c3x1 def /c2x0 c4x0 def /c2x1 c4x1 def" XCF_NEW_LINE \
	"/dY 0 c3y2 c1y2 sub round" XCF_NEW_LINE \
	"dtransform flipXY 1 eq {exch} if pop abs def" XCF_NEW_LINE \
	"dY dmin lt PickCoords" XCF_NEW_LINE \
	"y2 c1y2 sub abs 0.001 gt {" XCF_NEW_LINE
#define FlexOtherSubrStr9 \
	"c1x2 c1y2 transform flipXY 1 eq {exch} if " XCF_NEW_LINE \
	"/cx exch def /cy exch def" XCF_NEW_LINE \
	"/dY 0 y2 c1y2 sub round dtransform flipXY 1 eq {exch}" XCF_NEW_LINE \
	"if pop def" XCF_NEW_LINE \
	"dY round dup 0 ne" XCF_NEW_LINE \
	"{/dY exdef }" XCF_NEW_LINE \
	"{pop dY 0 lt {-1}{1} ifelse /dY exdef}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"/erode PaintType 2 ne erosion 0.5 ge and def" XCF_NEW_LINE \
	"erode {/cy cy 0.5 sub def} if" XCF_NEW_LINE
#define FlexOtherSubrStr10 \
	"/ey cy dY add def " XCF_NEW_LINE \
	"/ey ey ceiling ey sub ey floor add def " XCF_NEW_LINE \
	"erode {/ey ey 0.5 add def} if " XCF_NEW_LINE \
	"ey cx flipXY 1 eq {exch} if itransform exch pop" XCF_NEW_LINE \
	"y2 sub /eShift exch def" XCF_NEW_LINE \
	"/y1 y1 eShift add def /y2 y2 eShift add def /y3 y3" XCF_NEW_LINE \
	"eShift add def" XCF_NEW_LINE \
	"} if" XCF_NEW_LINE \
	"} ifelse" XCF_NEW_LINE \
	"}" XCF_NEW_LINE
#define FlexOtherSubrStr11 \
	"{flipXY 0 eq c3x2 c4x2 eq or" XCF_NEW_LINE \
	"{false PickCoords }" XCF_NEW_LINE \
	"{/shrink c3x2 c4x2 eq" XCF_NEW_LINE \
	"{0}{c1x2 c4x2 sub c3x2 c4x2 sub div abs} ifelse def" XCF_NEW_LINE \
	"/xshrink {c4x2 sub shrink mul c4x2 add} def" XCF_NEW_LINE \
	"/c1x0 c3x0 xshrink def /c1x1 c3x1 xshrink def" XCF_NEW_LINE \
	"/c2x0 c4x0 xshrink def /c2x1 c4x1 xshrink def" XCF_NEW_LINE \
	"/c1y0 c3y0 def /c1y1 c3y1 def /c2y0 c4y0 def /c2y1 c4y1 def" XCF_NEW_LINE \
	"/dX c3x2 c1x2 sub round 0 dtransform" XCF_NEW_LINE \
	"flipXY -1 eq {exch} if pop abs def" XCF_NEW_LINE
#define FlexOtherSubrStr12 \
	"dX dmin lt PickCoords" XCF_NEW_LINE \
	"x2 c1x2 sub abs 0.001 gt {" XCF_NEW_LINE \
	"c1x2 c1y2 transform flipXY -1 eq {exch} if" XCF_NEW_LINE \
	"/cy exch def /cx exch def " XCF_NEW_LINE \
	"/dX x2 c1x2 sub round 0 dtransform flipXY -1 eq {exch} if pop def" XCF_NEW_LINE \
	"dX round dup 0 ne" XCF_NEW_LINE \
	"{/dX exdef}" XCF_NEW_LINE \
	"{pop dX 0 lt {-1}{1} ifelse /dX exdef}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"/erode PaintType 2 ne erosion .5 ge and def" XCF_NEW_LINE
#define FlexOtherSubrStr13 \
	"erode {/cx cx .5 sub def} if" XCF_NEW_LINE \
	"/ex cx dX add def" XCF_NEW_LINE \
	"/ex ex ceiling ex sub ex floor add def" XCF_NEW_LINE \
	"erode {/ex ex .5 add def} if" XCF_NEW_LINE \
	"ex cy flipXY -1 eq {exch} if itransform pop" XCF_NEW_LINE \
	"x2 sub /eShift exch def" XCF_NEW_LINE \
	"/x1 x1 eShift add def /x2 x2 eShift add def /x3 x3 eShift add def" XCF_NEW_LINE \
	"} if" XCF_NEW_LINE \
	"} ifelse" XCF_NEW_LINE \
	"} ifelse" XCF_NEW_LINE
#define FlexOtherSubrStr14 \
	"x2 x5 eq y2 y5 eq or" XCF_NEW_LINE \
	"{x5 y5 lineto }" XCF_NEW_LINE \
	"{x0 y0 x1 y1 x2 y2 curveto" XCF_NEW_LINE \
	"x3 y3 x4 y4 x5 y5 curveto}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"epY epX " XCF_NEW_LINE \
	"}" XCF_NEW_LINE \
	"systemdict /currentpacking known {exch setpacking} if " XCF_NEW_LINE \
	"/exec cvx /end cvx ] cvx" XCF_NEW_LINE \
	"executeonly" XCF_NEW_LINE
#define FlexOtherSubrStr15 \
	"exch" XCF_NEW_LINE \
	"{pop true exch restore} " XCF_NEW_LINE \
	"{ " XCF_NEW_LINE \
	"systemdict /internaldict known not" XCF_NEW_LINE \
	"{1183615869 userdict /internaldict get exec" XCF_NEW_LINE \
	"exch /FlxProc exch put true}" XCF_NEW_LINE \
	"{1183615869 systemdict /internaldict get exec" XCF_NEW_LINE \
	"dup length exch maxlength eq" XCF_NEW_LINE \
	"{false} " XCF_NEW_LINE \
	"{1183615869 systemdict /internaldict get exec" XCF_NEW_LINE
#define FlexOtherSubrStr16 \
	"exch /FlxProc exch put true}" XCF_NEW_LINE \
	"ifelse}" XCF_NEW_LINE \
	"ifelse}" XCF_NEW_LINE \
	"ifelse" XCF_NEW_LINE \
	"{systemdict /internaldict known" XCF_NEW_LINE \
	"{{1183615869 systemdict /internaldict get exec /FlxProc get exec}}" XCF_NEW_LINE \
	"{{1183615869 userdict /internaldict get exec /FlxProc get exec}}" XCF_NEW_LINE \
	"ifelse executeonly" XCF_NEW_LINE \
	"} if" XCF_NEW_LINE \
	"{gsave currentpoint newpath moveto} executeonly " XCF_NEW_LINE
#define FlexOtherSubrStr17 \
	"{currentpoint grestore gsave currentpoint newpath moveto}" XCF_NEW_LINE \
	"executeonly " XCF_NEW_LINE

#ifdef __cplusplus
}
#endif

#endif /* XCF_PRIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_misc.c ===
/* @(#)CM_VerSion xcf_misc.c atm09 1.2 16426.eco sum= 60874 atm09.001 */
/* @(#)CM_VerSion xcf_misc.c atm08 1.4 16343.eco sum= 47357 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1995-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

/***********************************************************************
Original version: John Felton, March 8, 1996
************************************************************************/

/* -------------------------------------------------------------------------
     Header Includes 
  --------------------------------------------------------------------------- */

#include "algndjmp.h"
#include "xcf_priv.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifdef XCF_DEVELOP

void XCF_FatalErrorHandler(XCF_Handle hndl, int error, char *str, Card32 number)
{
    XCF_Handle h = (XCF_Handle) hndl;
    DEFINE_ALIGN_SETJMP_VAR;

    if (h->callbacks.printfError != NULL)
        h->callbacks.printfError("Fatal Error: %s: %ld\n", str, number);
    LONGJMP(h->jumpData, error);
}

#else

void XCF_FatalErrorHandler(XCF_Handle hndl, int error)
{
    XCF_Handle h = (XCF_Handle) hndl;
    DEFINE_ALIGN_SETJMP_VAR;

    if (h->callbacks.printfError != (XCF_printfError)NULL)
        h->callbacks.printfError("*** Fatal Error ***\n");
    LONGJMP(h->jumpData, error);
}

#endif


Card32 XCF_Read(XCF_Handle h, IntX byteCount)
{
    Card32 result = 0;
    if (h->inBuffer.pos+byteCount > h->inBuffer.end)
        XCF_FATAL_ERROR(h, XCF_EarlyEndOfData, "Read Past End Of Data",
            (Card32)(h->inBuffer.blockOffset + (h->inBuffer.pos - h->inBuffer.start) + byteCount-1));
    else
    {
        switch (byteCount)
        {
            case 4 :
                result = (*h->inBuffer.pos++)<<8;
            case 3 :
                result = (result + *h->inBuffer.pos++)<<8;
            case 2 :
                result = (result + *h->inBuffer.pos++)<<8;
            case 1 :
                result += *h->inBuffer.pos++;
                break;
            default :
                XCF_FATAL_ERROR(h, XCF_InternalError, "Invalid Byte Count in Read.",(Card32)byteCount);
        }
        return result;
    }
    return 0; /* This return prevents a compiler warning */
}



Card8 XCF_Read1(XCF_Handle h)
{
    if (h->inBuffer.pos >= h->inBuffer.end)
        XCF_FATAL_ERROR(h, XCF_EarlyEndOfData, "One Byte Read Past End Of Data",
            (Card32)(h->inBuffer.blockOffset + (h->inBuffer.pos - h->inBuffer.start)));
    else
        return *h->inBuffer.pos++;
    return 0; /* This return prevents a compiler warning */
}

Card16 XCF_Read2(XCF_Handle h)
{
    Card16 result;

    if (h->inBuffer.pos+2 > h->inBuffer.end)
        XCF_FATAL_ERROR(h, XCF_EarlyEndOfData, "Two Byte Read Past End Of Data",(Card32)(h->inBuffer.blockOffset + (h->inBuffer.pos - h->inBuffer.start)));
    else
    {
        result = *h->inBuffer.pos++;
        result = (result<<8) + *h->inBuffer.pos++;
        return result;
    }
    return 0; /* This return prevents a compiler warning */
}

long int XCF_OutputPos(XCF_Handle h)
{
    XCF_FlushOutputBuffer(h);
    return h->callbacks.outputPos(h->callbacks.outputPosHook);
}

void XCF_FlushOutputBuffer(XCF_Handle h)
{
    h->callbacks.putBytes(h->outBuffer.outBuffer, -1, h->outBuffer.outBufferCount, h->callbacks.putBytesHook);
    h->outBuffer.outBufferCount = 0;
}

void XCF_PutData(XCF_Handle h, Card8 PTR_PREFIX *pData, Card32 length)
{
    if ((h->outBuffer.outBufferCount + length) > h->options.maxBlockSize)
        XCF_FlushOutputBuffer(h);

    while (length > h->options.maxBlockSize)
    {
        h->callbacks.putBytes(pData, -1, h->options.maxBlockSize, h->callbacks.putBytesHook);
        length -= h->options.maxBlockSize;
        pData += h->options.maxBlockSize;
    }

    if (length > 0) /* add remainder to buffer */
    {
        h->callbacks.memcpy(&h->outBuffer.outBuffer[h->outBuffer.outBufferCount], pData, (Card16) length);
        h->outBuffer.outBufferCount += (Card16) length;
    }
}

void XCF_PutString(XCF_Handle h, char PTR_PREFIX *str)
{
    XCF_PutData(h,(Card8 PTR_PREFIX *)str,h->callbacks.strlen(str));
}

void XCF_SetOuputPosition(XCF_Handle h, Card32 pos)
{
    XCF_FlushOutputBuffer(h);
    h->callbacks.putBytes((unsigned char *)NULL, pos, 0, h->callbacks.putBytesHook);
}

static void BCDToStr(XCF_Handle h, Card8 PTR_PREFIX *pData, char PTR_PREFIX *str)
{
    Card8 currentByte;
    Card8 currentNibble;
    boolean firstNibble = false;
    IntX byteCount = 0;


    while (1)
    {
        if (!firstNibble)
        {
            currentByte = *pData++;
            currentNibble = currentByte>>4;
            if (++byteCount > XCF_MAX_BCD_NIBBLES)
                XCF_FATAL_ERROR(h, XCF_InvalidNumber, "BCD String Conversion Number of Bytes Exceeds Maximum Length",(Card32)byteCount);
        }
        else
            currentNibble = currentByte & 0x0F;

        firstNibble = !firstNibble;
    
        if (currentNibble <= 9)
            *str++ = currentNibble + '0';
        else if (currentNibble == 10)
            *str++ = '.';
        else if (currentNibble == 11)
            *str++ = 'E';
        else if (currentNibble == 12)
        {
            *str++ = 'E';
            *str++ = '-';
        }
        else if (currentNibble == 14)
            *str++ = '-';
        else if (currentNibble == 15)
        {
            *str = '\0';
            return;
        }
        else
            XCF_FATAL_ERROR(h, XCF_InvalidNumber, "Invalid Nibble in BCD Number",(Card32)currentNibble);
    } /* end while */
}


static Fixed XCF_BCDToFixed(XCF_Handle h,Card8 PTR_PREFIX *pData, boolean fracType)
{
    char numbStr[XCF_MAX_BCD_NIBBLES*2 + 1]; /* Add one for null character. */

    BCDToStr(h, pData, numbStr);
#if USE_FXL
  return (fracType ? XCF_ConvertFrac(h, numbStr) : XCF_ConvertFixed(h,
                                                                                                                                        numbStr));
#else
    return (fracType ? (Fixed)REAL_TO_FRAC(h->callbacks.atof(numbStr)) :
                    (Fixed)(REAL_TO_FIXED(h->callbacks.atof(numbStr))));
#endif
}

#if JUDY
static double XCF_BCDToDouble(XCF_Handle h,Card8 PTR_PREFIX *pData)
{
    char numbStr[XCF_MAX_BCD_NIBBLES*2];

    BCDToStr(h, pData, numbStr);
    return h->callbacks.atof(numbStr);
}
#endif

IntX XCF_FindNextOperator(XCF_Handle h, Card16 PTR_PREFIX *opCode, boolean dict)
{
    IntX  argCount = 0;
    Card8 byteIn;

    while (1)
    {
        byteIn = XCF_Read1(h);
        if (byteIn > 31)
        {
            if (byteIn == 255)
                XCF_Read(h,4);
            else if (byteIn > 246)
                XCF_Read1(h);
        }
        else if (byteIn == OpCode(cff_shortint))
            XCF_Read2(h);
        else if (dict && (byteIn == OpCode(cff_longint)))
            XCF_Read(h,4);
        else if (dict && (byteIn == OpCode(cff_BCD)))
        {
            byteIn = XCF_Read1(h);
            while (((byteIn>>4) != 15) && ((byteIn & 0x0F) != 15))
                byteIn = XCF_Read1(h);
        }
        else
        {
            if (byteIn == OpCode(tx_escape))
                *opCode = cff_ESC(XCF_Read1(h));
            else
                *opCode = byteIn;
            return argCount;
        }
        ++argCount;
    }
}


static Int32 XCF_ArgPtrToInt(XCF_Handle h, Card8 PTR_PREFIX * PTR_PREFIX *ppArgList)
{
    Card8 PTR_PREFIX *pArgList = *ppArgList;
    Card8 byteIn = *pArgList++;
    Int32 result;
    long int intNumber;
    Fixed fixedNumber;

        if (byteIn > 31)
        {
            if (byteIn <= 246)
            {
                result = (Int32)byteIn - 139;
            }
            else if (byteIn <= 250)
            {
                result = (((Int32)byteIn - 247) << 8) + *pArgList++ + 108;
            }
            else if (byteIn <= 254)
            {
                result = -((((Int32)byteIn - 251) << 8) + *pArgList++ + 108);
            }
            else /* byteIn == 255 */
            {
                fixedNumber = *pArgList++;
                fixedNumber = (fixedNumber << 8) | *pArgList++;
                fixedNumber = (fixedNumber << 8) | *pArgList++;
                fixedNumber = (fixedNumber << 8) | *pArgList++;
                result = ROUND_FIXED_TO_INT(fixedNumber);
            }
        }
        else if (byteIn == OpCode(cff_shortint))
        {
            intNumber = *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            result = intNumber;
        }
        else if (byteIn == OpCode(cff_longint))
        {
            intNumber = *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            result = intNumber;
        }
        else if (byteIn == OpCode(cff_BCD))
        { /* This opcode shouldn't occur for the keywords for which
         this procedure is currently called. */
#if JUDY
            result = XCF_BCDToDouble(h, pArgList);
            tempByte = *pArgList++;
            while (((tempByte>>4) != 15) && ((tempByte & 0x0F) != 15))
                tempByte = *pArgList++;
#else
      XCF_FATAL_ERROR(h, XCF_InternalError,"cff_BCD operator encountered",(Card32)pArgList);
#endif
        }
        else
            XCF_FATAL_ERROR(h, XCF_InternalError,"Command Encountered in Argument List",(Card32)pArgList);

        *ppArgList = pArgList;
        return result;
}

Fixed XCF_ArgPtrToFixed(XCF_Handle h, Card8 PTR_PREFIX * PTR_PREFIX
                                                             *ppArgList, boolean fracType)
{
    Card8 PTR_PREFIX *pArgList = *ppArgList;
    Card8 byteIn = *pArgList++;
    Fixed result;
    long int intNumber;
    Card8 tempByte;

        if (byteIn > 31)
        {
            if (byteIn <= 246)
            {
                result = INT_TO_FIXED((Int32)byteIn - 139);
            }
            else if (byteIn <= 250)
            {
                result = INT_TO_FIXED((((Int32)byteIn - 247) << 8) + *pArgList++ + 108);
            }
            else if (byteIn <= 254)
            {
                result = -INT_TO_FIXED(((((Int32)byteIn - 251) << 8) + *pArgList++ + 108));
            }
            else /* byteIn == 255 */
            {
                result = *pArgList++;
                result = (result << 8) | *pArgList++;
                result = (result << 8) | *pArgList++;
                result = (result << 8) | *pArgList++;
            }
        }
        else if (byteIn == OpCode(cff_shortint))
        {
            intNumber = *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            result = INT_TO_FIXED(intNumber);
        }
        else if (byteIn == OpCode(cff_longint))
        {   /* This just uses the low order bytes when converting a long to fixed. */
            intNumber = *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            intNumber = (intNumber << 8) | *pArgList++;
            result = INT_TO_FIXED(intNumber);
        }
        else if (byteIn == OpCode(cff_BCD))
    {
      result = XCF_BCDToFixed(h, pArgList, fracType);
      tempByte = *pArgList++;
      while (((tempByte>>4) != 15) && ((tempByte & 0x0F) != 15))
                tempByte = *pArgList++;
    }
    else
            XCF_FATAL_ERROR(h, XCF_InternalError,"Command Or Invalid Number Format Encountered in Argument List",(Card32)pArgList);

        *ppArgList = pArgList;
        return result;
}

/* Assumes that argCount can be read safely without running past end of data. This should always be the case. */
void XCF_SaveDictArgumentList(XCF_Handle h, Fixed PTR_PREFIX *pArgArray,
                                                                         Card8 PTR_PREFIX *pArgList, IntX argCount,
                                                                         boolean fracType)
{
    IntX loopIndex;

    for (loopIndex=1; loopIndex <= argCount; ++loopIndex)
    *pArgArray++ = XCF_ArgPtrToFixed(h, &pArgList, fracType);
}

/* Assumes that argCount can be read safely without running past end of data. This should always be the case. */
void XCF_SaveDictIntArgumentList(XCF_Handle h, Int32 PTR_PREFIX *pArgArray, Card8 PTR_PREFIX *pArgList, IntX argCount)
{
    IntX loopIndex;

    for (loopIndex=1; loopIndex <= argCount; ++loopIndex)
        *pArgArray++ = XCF_ArgPtrToInt(h, &pArgList);
}

/* Assumes that argCount can be read safely without running past end of
     data. This should always be the case. */
void XCF_SaveFontMatrixStr(XCF_Handle h,
                                                    char (PTR_PREFIX *pArgArray)[FONT_MATRIX_ENTRY_SIZE],
                          Card8 PTR_PREFIX *pArgList, IntX argCount)
{
    IntX loopIndex;
  Fixed val;
  Card8 tempByte;
  Card8 byteIn;

    for (loopIndex=0; loopIndex < argCount; loopIndex++)
  {
    byteIn = *pArgList;
    if (byteIn == OpCode(cff_BCD))
    {
      byteIn = *pArgList++;
          BCDToStr(h, pArgList, pArgArray[loopIndex]);
      tempByte = *pArgList++;
      while (((tempByte>>4) != 15) && ((tempByte & 0x0F) != 15))
        tempByte = *pArgList++;
    }
    else
    {
      val = XCF_ArgPtrToFixed(h, &pArgList, false);
      XCF_Fixed2CString(val, pArgArray[loopIndex], 7, false);
    }
  }
}

/* Assumes that argCount can be read safely without running past end of
     data. This should always be the case. */
void XCF_SaveStrArgs(XCF_Handle h, char PTR_PREFIX *pArgArray,
                            Card8 PTR_PREFIX *pArgList, IntX argCount)
{
    IntX loopIndex;
  Fixed val;
  Card8 tempByte;
  Card8 byteIn;

    for (loopIndex=0; loopIndex < argCount; loopIndex++)
  {
    byteIn = *pArgList;
    if (byteIn == OpCode(cff_BCD))
    {
      byteIn = *pArgList++;
          BCDToStr(h, pArgList, &pArgArray[loopIndex]);
      tempByte = *pArgList++;
      while (((tempByte>>4) != 15) && ((tempByte & 0x0F) != 15))
        tempByte = *pArgList++;
    }
    else
    {
      val = XCF_ArgPtrToFixed(h, &pArgList, false);
      XCF_Fixed2CString(val, &pArgArray[loopIndex], 7, false);
    }
  }
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_sstr.h ===
/* @(#)CM_VerSion xcf_sstr.h atm08 1.2 16248.eco sum= 48232 atm08.003 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1995 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Standard string id table aggregate initializer.
 */

#ifndef STDSTR_H
#define STDSTR_H

	/*   0 */ ".notdef",
	/*   1 */ "space",
	/*   2 */ "exclam",
	/*   3 */ "quotedbl",
	/*   4 */ "numbersign",
	/*   5 */ "dollar",
	/*   6 */ "percent",
	/*   7 */ "ampersand",
	/*   8 */ "quoteright",
	/*   9 */ "parenleft",
	/*  10 */ "parenright",
	/*  11 */ "asterisk",
	/*  12 */ "plus",
	/*  13 */ "comma",
	/*  14 */ "hyphen",
	/*  15 */ "period",
	/*  16 */ "slash",
	/*  17 */ "zero",
	/*  18 */ "one",
	/*  19 */ "two",
	/*  20 */ "three",
	/*  21 */ "four",
	/*  22 */ "five",
	/*  23 */ "six",
	/*  24 */ "seven",
	/*  25 */ "eight",
	/*  26 */ "nine",
	/*  27 */ "colon",
	/*  28 */ "semicolon",
	/*  29 */ "less",
	/*  30 */ "equal",
	/*  31 */ "greater",
	/*  32 */ "question",
	/*  33 */ "at",
	/*  34 */ "A",
	/*  35 */ "B",
	/*  36 */ "C",
	/*  37 */ "D",
	/*  38 */ "E",
	/*  39 */ "F",
	/*  40 */ "G",
	/*  41 */ "H",
	/*  42 */ "I",
	/*  43 */ "J",
	/*  44 */ "K",
	/*  45 */ "L",
	/*  46 */ "M",
	/*  47 */ "N",
	/*  48 */ "O",
	/*  49 */ "P",
	/*  50 */ "Q",
	/*  51 */ "R",
	/*  52 */ "S",
	/*  53 */ "T",
	/*  54 */ "U",
	/*  55 */ "V",
	/*  56 */ "W",
	/*  57 */ "X",
	/*  58 */ "Y",
	/*  59 */ "Z",
	/*  60 */ "bracketleft",
	/*  61 */ "backslash",
	/*  62 */ "bracketright",
	/*  63 */ "asciicircum",
	/*  64 */ "underscore",
	/*  65 */ "quoteleft",
	/*  66 */ "a",
	/*  67 */ "b",
	/*  68 */ "c",
	/*  69 */ "d",
	/*  70 */ "e",
	/*  71 */ "f",
	/*  72 */ "g",
	/*  73 */ "h",
	/*  74 */ "i",
	/*  75 */ "j",
	/*  76 */ "k",
	/*  77 */ "l",
	/*  78 */ "m",
	/*  79 */ "n",
	/*  80 */ "o",
	/*  81 */ "p",
	/*  82 */ "q",
	/*  83 */ "r",
	/*  84 */ "s",
	/*  85 */ "t",
	/*  86 */ "u",
	/*  87 */ "v",
	/*  88 */ "w",
	/*  89 */ "x",
	/*  90 */ "y",
	/*  91 */ "z",
	/*  92 */ "braceleft",
	/*  93 */ "bar",
	/*  94 */ "braceright",
	/*  95 */ "asciitilde",
	/*  96 */ "exclamdown",
	/*  97 */ "cent",
	/*  98 */ "sterling",
	/*  99 */ "fraction",
	/* 100 */ "yen",
	/* 101 */ "florin",
	/* 102 */ "section",
	/* 103 */ "currency",
	/* 104 */ "quotesingle",
	/* 105 */ "quotedblleft",
	/* 106 */ "guillemotleft",
	/* 107 */ "guilsinglleft",
	/* 108 */ "guilsinglright",
	/* 109 */ "fi",
	/* 110 */ "fl",
	/* 111 */ "endash",
	/* 112 */ "dagger",
	/* 113 */ "daggerdbl",
	/* 114 */ "periodcentered",
	/* 115 */ "paragraph",
	/* 116 */ "bullet",
	/* 117 */ "quotesinglbase",
	/* 118 */ "quotedblbase",
	/* 119 */ "quotedblright",
	/* 120 */ "guillemotright",
	/* 121 */ "ellipsis",
	/* 122 */ "perthousand",
	/* 123 */ "questiondown",
	/* 124 */ "grave",
	/* 125 */ "acute",
	/* 126 */ "circumflex",
	/* 127 */ "tilde",
	/* 128 */ "macron",
	/* 129 */ "breve",
	/* 130 */ "dotaccent",
	/* 131 */ "dieresis",
	/* 132 */ "ring",
	/* 133 */ "cedilla",
	/* 134 */ "hungarumlaut",
	/* 135 */ "ogonek",
	/* 136 */ "caron",
	/* 137 */ "emdash",
	/* 138 */ "AE",
	/* 139 */ "ordfeminine",
	/* 140 */ "Lslash",
	/* 141 */ "Oslash",
	/* 142 */ "OE",
	/* 143 */ "ordmasculine",
	/* 144 */ "ae",
	/* 145 */ "dotlessi",
	/* 146 */ "lslash",
	/* 147 */ "oslash",
	/* 148 */ "oe",
	/* 149 */ "germandbls",
	/* 150 */ "onesuperior",
	/* 151 */ "logicalnot",
	/* 152 */ "mu",
	/* 153 */ "trademark",
	/* 154 */ "Eth",
	/* 155 */ "onehalf",
	/* 156 */ "plusminus",
	/* 157 */ "Thorn",
	/* 158 */ "onequarter",
	/* 159 */ "divide",
	/* 160 */ "brokenbar",
	/* 161 */ "degree",
	/* 162 */ "thorn",
	/* 163 */ "threequarters",
	/* 164 */ "twosuperior",
	/* 165 */ "registered",
	/* 166 */ "minus",
	/* 167 */ "eth",
	/* 168 */ "multiply",
	/* 169 */ "threesuperior",
	/* 170 */ "copyright",
	/* 171 */ "Aacute",
	/* 172 */ "Acircumflex",
	/* 173 */ "Adieresis",
	/* 174 */ "Agrave",
	/* 175 */ "Aring",
	/* 176 */ "Atilde",
	/* 177 */ "Ccedilla",
	/* 178 */ "Eacute",
	/* 179 */ "Ecircumflex",
	/* 180 */ "Edieresis",
	/* 181 */ "Egrave",
	/* 182 */ "Iacute",
	/* 183 */ "Icircumflex",
	/* 184 */ "Idieresis",
	/* 185 */ "Igrave",
	/* 186 */ "Ntilde",
	/* 187 */ "Oacute",
	/* 188 */ "Ocircumflex",
	/* 189 */ "Odieresis",
	/* 190 */ "Ograve",
	/* 191 */ "Otilde",
	/* 192 */ "Scaron",
	/* 193 */ "Uacute",
	/* 194 */ "Ucircumflex",
	/* 195 */ "Udieresis",
	/* 196 */ "Ugrave",
	/* 197 */ "Yacute",
	/* 198 */ "Ydieresis",
	/* 199 */ "Zcaron",
	/* 200 */ "aacute",
	/* 201 */ "acircumflex",
	/* 202 */ "adieresis",
	/* 203 */ "agrave",
	/* 204 */ "aring",
	/* 205 */ "atilde",
	/* 206 */ "ccedilla",
	/* 207 */ "eacute",
	/* 208 */ "ecircumflex",
	/* 209 */ "edieresis",
	/* 210 */ "egrave",
	/* 211 */ "iacute",
	/* 212 */ "icircumflex",
	/* 213 */ "idieresis",
	/* 214 */ "igrave",
	/* 215 */ "ntilde",
	/* 216 */ "oacute",
	/* 217 */ "ocircumflex",
	/* 218 */ "odieresis",
	/* 219 */ "ograve",
	/* 220 */ "otilde",
	/* 221 */ "scaron",
	/* 222 */ "uacute",
	/* 223 */ "ucircumflex",
	/* 224 */ "udieresis",
	/* 225 */ "ugrave",
	/* 226 */ "yacute",
	/* 227 */ "ydieresis",
	/* 228 */ "zcaron",
	/* 229 */ "exclamsmall",
	/* 230 */ "Hungarumlautsmall",
	/* 231 */ "dollaroldstyle",
	/* 232 */ "dollarsuperior",
	/* 233 */ "ampersandsmall",
	/* 234 */ "Acutesmall",
	/* 235 */ "parenleftsuperior",
	/* 236 */ "parenrightsuperior",
	/* 237 */ "twodotenleader",
	/* 238 */ "onedotenleader",
	/* 239 */ "zerooldstyle",
	/* 240 */ "oneoldstyle",
	/* 241 */ "twooldstyle",
	/* 242 */ "threeoldstyle",
	/* 243 */ "fouroldstyle",
	/* 244 */ "fiveoldstyle",
	/* 245 */ "sixoldstyle",
	/* 246 */ "sevenoldstyle",
	/* 247 */ "eightoldstyle",
	/* 248 */ "nineoldstyle",
	/* 249 */ "commasuperior",
	/* 250 */ "threequartersemdash",
	/* 251 */ "periodsuperior",
	/* 252 */ "questionsmall",
	/* 253 */ "asuperior",
	/* 254 */ "bsuperior",
	/* 255 */ "centsuperior",
	/* 256 */ "dsuperior",
	/* 257 */ "esuperior",
	/* 258 */ "isuperior",
	/* 259 */ "lsuperior",
	/* 260 */ "msuperior",
	/* 261 */ "nsuperior",
	/* 262 */ "osuperior",
	/* 263 */ "rsuperior",
	/* 264 */ "ssuperior",
	/* 265 */ "tsuperior",
	/* 266 */ "ff",
	/* 267 */ "ffi",
	/* 268 */ "ffl",
	/* 269 */ "parenleftinferior",
	/* 270 */ "parenrightinferior",
	/* 271 */ "Circumflexsmall",
	/* 272 */ "hyphensuperior",
	/* 273 */ "Gravesmall",
	/* 274 */ "Asmall",
	/* 275 */ "Bsmall",
	/* 276 */ "Csmall",
	/* 277 */ "Dsmall",
	/* 278 */ "Esmall",
	/* 279 */ "Fsmall",
	/* 280 */ "Gsmall",
	/* 281 */ "Hsmall",
	/* 282 */ "Ismall",
	/* 283 */ "Jsmall",
	/* 284 */ "Ksmall",
	/* 285 */ "Lsmall",
	/* 286 */ "Msmall",
	/* 287 */ "Nsmall",
	/* 288 */ "Osmall",
	/* 289 */ "Psmall",
	/* 290 */ "Qsmall",
	/* 291 */ "Rsmall",
	/* 292 */ "Ssmall",
	/* 293 */ "Tsmall",
	/* 294 */ "Usmall",
	/* 295 */ "Vsmall",
	/* 296 */ "Wsmall",
	/* 297 */ "Xsmall",
	/* 298 */ "Ysmall",
	/* 299 */ "Zsmall",
	/* 300 */ "colonmonetary",
	/* 301 */ "onefitted",
	/* 302 */ "rupiah",
	/* 303 */ "Tildesmall",
	/* 304 */ "exclamdownsmall",
	/* 305 */ "centoldstyle",
	/* 306 */ "Lslashsmall",
	/* 307 */ "Scaronsmall",
	/* 308 */ "Zcaronsmall",
	/* 309 */ "Dieresissmall",
	/* 310 */ "Brevesmall",
	/* 311 */ "Caronsmall",
	/* 312 */ "Dotaccentsmall",
	/* 313 */ "Macronsmall",
	/* 314 */ "figuredash",
	/* 315 */ "hypheninferior",
	/* 316 */ "Ogoneksmall",
	/* 317 */ "Ringsmall",
	/* 318 */ "Cedillasmall",
	/* 319 */ "questiondownsmall",
	/* 320 */ "oneeighth",
	/* 321 */ "threeeighths",
	/* 322 */ "fiveeighths",
	/* 323 */ "seveneighths",
	/* 324 */ "onethird",
	/* 325 */ "twothirds",
	/* 326 */ "zerosuperior",
	/* 327 */ "foursuperior",
	/* 328 */ "fivesuperior",
	/* 329 */ "sixsuperior",
	/* 330 */ "sevensuperior",
	/* 331 */ "eightsuperior",
	/* 332 */ "ninesuperior",
	/* 333 */ "zeroinferior",
	/* 334 */ "oneinferior",
	/* 335 */ "twoinferior",
	/* 336 */ "threeinferior",
	/* 337 */ "fourinferior",
	/* 338 */ "fiveinferior",
	/* 339 */ "sixinferior",
	/* 340 */ "seveninferior",
	/* 341 */ "eightinferior",
	/* 342 */ "nineinferior",
	/* 343 */ "centinferior",
	/* 344 */ "dollarinferior",
	/* 345 */ "periodinferior",
	/* 346 */ "commainferior",
	/* 347 */ "Agravesmall",
	/* 348 */ "Aacutesmall",
	/* 349 */ "Acircumflexsmall",
	/* 350 */ "Atildesmall",
	/* 351 */ "Adieresissmall",
	/* 352 */ "Aringsmall",
	/* 353 */ "AEsmall",
	/* 354 */ "Ccedillasmall",
	/* 355 */ "Egravesmall",
	/* 356 */ "Eacutesmall",
	/* 357 */ "Ecircumflexsmall",
	/* 358 */ "Edieresissmall",
	/* 359 */ "Igravesmall",
	/* 360 */ "Iacutesmall",
	/* 361 */ "Icircumflexsmall",
	/* 362 */ "Idieresissmall",
	/* 363 */ "Ethsmall",
	/* 364 */ "Ntildesmall",
	/* 365 */ "Ogravesmall",
	/* 366 */ "Oacutesmall",
	/* 367 */ "Ocircumflexsmall",
	/* 368 */ "Otildesmall",
	/* 369 */ "Odieresissmall",
	/* 370 */ "OEsmall",
	/* 371 */ "Oslashsmall",
	/* 372 */ "Ugravesmall",
	/* 373 */ "Uacutesmall",
	/* 374 */ "Ucircumflexsmall",
	/* 375 */ "Udieresissmall",
	/* 376 */ "Yacutesmall",
	/* 377 */ "Thornsmall",
	/* 378 */ "Ydieresissmall",
	/* 379 */ "001.000",
	/* 380 */ "001.001",
	/* 381 */ "001.002",
	/* 382 */ "001.003",
	/* 383 */ "Black",
	/* 384 */ "Bold",
	/* 385 */ "Book",
	/* 386 */ "Light",
	/* 387 */ "Medium",
	/* 388 */ "Regular",
	/* 389 */ "Roman",
	/* 390 */ "Semibold",

#endif /* STDSTR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_stde.h ===
/* @(#)CM_VerSion xcf_stde.h atm08 1.2 16248.eco sum= 50428 atm08.003 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************
 * SCCS Id:    %W%
 * Changed:    %G% %U%
 ***********************************************************************/

/*
 * Standard encoding aggregate initializer. Element values are SIDs.
 */

#ifndef STDENC_H
#define STDENC_H

	  0,	/*   0 .notdef */
	  0,	/*   1 .notdef */
	  0,	/*   2 .notdef */
	  0,	/*   3 .notdef */
	  0,	/*   4 .notdef */
	  0,	/*   5 .notdef */
	  0,	/*   6 .notdef */
	  0,	/*   7 .notdef */
	  0,	/*   8 .notdef */
	  0,	/*   9 .notdef */
	  0,	/*  10 .notdef */
	  0,	/*  11 .notdef */
	  0,	/*  12 .notdef */
	  0,	/*  13 .notdef */
	  0,	/*  14 .notdef */
	  0,	/*  15 .notdef */
	  0,	/*  16 .notdef */
	  0,	/*  17 .notdef */
	  0,	/*  18 .notdef */
	  0,	/*  19 .notdef */
	  0,	/*  20 .notdef */
	  0,	/*  21 .notdef */
	  0,	/*  22 .notdef */
	  0,	/*  23 .notdef */
	  0,	/*  24 .notdef */
	  0,	/*  25 .notdef */
	  0,	/*  26 .notdef */
	  0,	/*  27 .notdef */
	  0,	/*  28 .notdef */
	  0,	/*  29 .notdef */
	  0,	/*  30 .notdef */
	  0,	/*  31 .notdef */
	  1,	/*  32 space */
	  2,	/*  33 exclam */
	  3,	/*  34 quotedbl */
	  4,	/*  35 numbersign */
	  5,	/*  36 dollar */
	  6,	/*  37 percent */
	  7,	/*  38 ampersand */
	  8,	/*  39 quoteright */
	  9,	/*  40 parenleft */
	 10,	/*  41 parenright */
	 11,	/*  42 asterisk */
	 12,	/*  43 plus */
	 13,	/*  44 comma */
	 14,	/*  45 hyphen */
	 15,	/*  46 period */
	 16,	/*  47 slash */
	 17,	/*  48 zero */
	 18,	/*  49 one */
	 19,	/*  50 two */
	 20,	/*  51 three */
	 21,	/*  52 four */
	 22,	/*  53 five */
	 23,	/*  54 six */
	 24,	/*  55 seven */
	 25,	/*  56 eight */
	 26,	/*  57 nine */
	 27,	/*  58 colon */
	 28,	/*  59 semicolon */
	 29,	/*  60 less */
	 30,	/*  61 equal */
	 31,	/*  62 greater */
	 32,	/*  63 question */
	 33,	/*  64 at */
	 34,	/*  65 A */
	 35,	/*  66 B */
	 36,	/*  67 C */
	 37,	/*  68 D */
	 38,	/*  69 E */
	 39,	/*  70 F */
	 40,	/*  71 G */
	 41,	/*  72 H */
	 42,	/*  73 I */
	 43,	/*  74 J */
	 44,	/*  75 K */
	 45,	/*  76 L */
	 46,	/*  77 M */
	 47,	/*  78 N */
	 48,	/*  79 O */
	 49,	/*  80 P */
	 50,	/*  81 Q */
	 51,	/*  82 R */
	 52,	/*  83 S */
	 53,	/*  84 T */
	 54,	/*  85 U */
	 55,	/*  86 V */
	 56,	/*  87 W */
	 57,	/*  88 X */
	 58,	/*  89 Y */
	 59,	/*  90 Z */
	 60,	/*  91 bracketleft */
	 61,	/*  92 backslash */
	 62,	/*  93 bracketright */
	 63,	/*  94 asciicircum */
	 64,	/*  95 underscore */
	 65,	/*  96 quoteleft */
	 66,	/*  97 a */
	 67,	/*  98 b */
	 68,	/*  99 c */
	 69,	/* 100 d */
	 70,	/* 101 e */
	 71,	/* 102 f */
	 72,	/* 103 g */
	 73,	/* 104 h */
	 74,	/* 105 i */
	 75,	/* 106 j */
	 76,	/* 107 k */
	 77,	/* 108 l */
	 78,	/* 109 m */
	 79,	/* 110 n */
	 80,	/* 111 o */
	 81,	/* 112 p */
	 82,	/* 113 q */
	 83,	/* 114 r */
	 84,	/* 115 s */
	 85,	/* 116 t */
	 86,	/* 117 u */
	 87,	/* 118 v */
	 88,	/* 119 w */
	 89,	/* 120 x */
	 90,	/* 121 y */
	 91,	/* 122 z */
	 92,	/* 123 braceleft */
	 93,	/* 124 bar */
	 94,	/* 125 braceright */
	 95,	/* 126 asciitilde */
	  0,	/* 127 .notdef */
	  0,	/* 128 .notdef */
	  0,	/* 129 .notdef */
	  0,	/* 130 .notdef */
	  0,	/* 131 .notdef */
	  0,	/* 132 .notdef */
	  0,	/* 133 .notdef */
	  0,	/* 134 .notdef */
	  0,	/* 135 .notdef */
	  0,	/* 136 .notdef */
	  0,	/* 137 .notdef */
	  0,	/* 138 .notdef */
	  0,	/* 139 .notdef */
	  0,	/* 140 .notdef */
	  0,	/* 141 .notdef */
	  0,	/* 142 .notdef */
	  0,	/* 143 .notdef */
	  0,	/* 144 .notdef */
	  0,	/* 145 .notdef */
	  0,	/* 146 .notdef */
	  0,	/* 147 .notdef */
	  0,	/* 148 .notdef */
	  0,	/* 149 .notdef */
	  0,	/* 150 .notdef */
	  0,	/* 151 .notdef */
	  0,	/* 152 .notdef */
	  0,	/* 153 .notdef */
	  0,	/* 154 .notdef */
	  0,	/* 155 .notdef */
	  0,	/* 156 .notdef */
	  0,	/* 157 .notdef */
	  0,	/* 158 .notdef */
	  0,	/* 159 .notdef */
	  0,	/* 160 .notdef */
	 96,	/* 161 exclamdown */
	 97,	/* 162 cent */
	 98,	/* 163 sterling */
	 99,	/* 164 fraction */
	100,	/* 165 yen */
	101,	/* 166 florin */
	102,	/* 167 section */
	103,	/* 168 currency */
	104,	/* 169 quotesingle */
	105,	/* 170 quotedblleft */
	106,	/* 171 guillemotleft */
	107,	/* 172 guilsinglleft */
	108,	/* 173 guilsinglright */
	109,	/* 174 fi */
	110,	/* 175 fl */
	  0,	/* 176 .notdef */
	111,	/* 177 endash */
	112,	/* 178 dagger */
	113,	/* 179 daggerdbl */
	114,	/* 180 periodcentered */
	  0,	/* 181 .notdef */
	115,	/* 182 paragraph */
	116,	/* 183 bullet */
	117,	/* 184 quotesinglbase */
	118,	/* 185 quotedblbase */
	119,	/* 186 quotedblright */
	120,	/* 187 guillemotright */
	121,	/* 188 ellipsis */
	122,	/* 189 perthousand */
	  0,	/* 190 .notdef */
	123,	/* 191 questiondown */
	  0,	/* 192 .notdef */
	124,	/* 193 grave */
	125,	/* 194 acute */
	126,	/* 195 circumflex */
	127,	/* 196 tilde */
	128,	/* 197 macron */
	129,	/* 198 breve */
	130,	/* 199 dotaccent */
	131,	/* 200 dieresis */
	  0,	/* 201 .notdef */
	132,	/* 202 ring */
	133,	/* 203 cedilla */
	  0,	/* 204 .notdef */
	134,	/* 205 hungarumlaut */
	135,	/* 206 ogonek */
	136,	/* 207 caron */
	137,	/* 208 emdash */
	  0,	/* 209 .notdef */
	  0,	/* 210 .notdef */
	  0,	/* 211 .notdef */
	  0,	/* 212 .notdef */
	  0,	/* 213 .notdef */
	  0,	/* 214 .notdef */
	  0,	/* 215 .notdef */
	  0,	/* 216 .notdef */
	  0,	/* 217 .notdef */
	  0,	/* 218 .notdef */
	  0,	/* 219 .notdef */
	  0,	/* 220 .notdef */
	  0,	/* 221 .notdef */
	  0,	/* 222 .notdef */
	  0,	/* 223 .notdef */
	  0,	/* 224 .notdef */
	138,	/* 225 AE */
	  0,	/* 226 .notdef */
	139,	/* 227 ordfeminine */
	  0,	/* 228 .notdef */
	  0,	/* 229 .notdef */
	  0,	/* 230 .notdef */
	  0,	/* 231 .notdef */
	140,	/* 232 Lslash */
	141,	/* 233 Oslash */
	142,	/* 234 OE */
	143,	/* 235 ordmasculine */
	  0,	/* 236 .notdef */
	  0,	/* 237 .notdef */
	  0,	/* 238 .notdef */
	  0,	/* 239 .notdef */
	  0,	/* 240 .notdef */
	144,	/* 241 ae */
	  0,	/* 242 .notdef */
	  0,	/* 243 .notdef */
	  0,	/* 244 .notdef */
	145,	/* 245 dotlessi */
	  0,	/* 246 .notdef */
	  0,	/* 247 .notdef */
	146,	/* 248 lslash */
	147,	/* 249 oslash */
	148,	/* 250 oe */
	149,	/* 251 germandbls */
	  0,	/* 252 .notdef */
	  0,	/* 253 .notdef */
	  0,	/* 254 .notdef */
	  0,	/* 255 .notdef */

#endif /* STDENC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_win.h ===
/***********************************************************************/
/*                                                                     */
/* Copyright 1995-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

#ifndef XCF_WIN
#define XCF_WIN

#ifdef WINNT

#ifdef WINNT_40
#include <p64_nt4.h>
#else
#include <basetsd.h>
#endif

#else /* Win9x */

#include "UFLCnfig.h"

#ifndef LONG_PTR
typedef long LONG_PTR, *PLONG_PTR;
#endif

#ifndef ULONG_PTR
typedef unsigned long ULONG_PTR, *PULONG_PTR;
#endif

#ifndef PTR_PREFIX
#define PTR_PREFIX __huge
#endif

#endif /* WINNT */

#endif /* XCF_WIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_pub.h ===
/* @(#)CM_VerSion xcf_pub.h atm09 1.3 16499.eco sum= 57734 atm09.002 */
/* @(#)CM_VerSion xcf_pub.h atm08 1.6 16343.eco sum= 46145 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/



#ifndef XCF_PUB_H
#define XCF_PUB_H

#include "xcf_base.h"

#ifdef __cplusplus
extern "C" {
#endif


/***************************
    Type definitions
***************************/

enum XCF_Result {
                    XCF_Ok,
                    XCF_EarlyEndOfData,
                    XCF_StackOverflow,
                    XCF_StackUnderflow,
                    XCF_UnterminatedDictionary,
                    XCF_InvalidDictionaryOrder,
                    XCF_IndexOutOfRange,
                    XCF_MemoryAllocationError,
                    XCF_FontNotFound,
                    XCF_UnsupportedVersion,
                    XCF_InvalidOffsetSize,
                    XCF_InvalidString,
                    XCF_InvalidOffset,
                    XCF_CharStringDictNotFound,
                    XCF_InvalidCharString,
                    XCF_SubrDepthOverflow,
                    XCF_FontNameTooLong,
                    XCF_InvalidNumber,
                    XCF_HintOverflow,
                    XCF_UnsupportedCharstringTypeRequested,
                    XCF_InternalError,
                    XCF_InvalidNumberType,
                    XCF_GetBytesCallbackFailure,
                    XCF_InvalidFontIndex,
                    XCF_InvalidDictArgumentCount,
                    XCF_InvalidCIDFont,
                    XCF_NoCharstringsFound,
                    XCF_InvalidBlendArgumentCount,
                    XCF_InvalidBlendDesignMap,
                    XCF_InvalidDownloadArgument,
                    XCF_InvalidDownloadOptions,
                    XCF_InvalidFontSetHandle,
                    XCF_InvalidState,
                    XCF_InvalidGID,
          XCF_InvalidCallbackFunction,
          XCF_Unimplemented
                    };

typedef void PTR_PREFIX *XFhandle;

typedef long XCFGlyphID;

/******************************************
    xcf Specific Callback Functions
*******************************************/
typedef int (*XCF_PutBytesAtPosFunc) ( unsigned char PTR_PREFIX *pData, long int position, unsigned short int length, void PTR_PREFIX *clientHook );
typedef long int (*XCF_OutputPosFunc) ( void PTR_PREFIX *clientHook );
typedef int (*XCF_GetBytesFromPosFunc) ( unsigned char PTR_PREFIX * PTR_PREFIX *ppData, long int position, unsigned short int length, void PTR_PREFIX *clientHook );
typedef unsigned long int (*XCF_AllocateFunc) ( void PTR_PREFIX * PTR_PREFIX
                                                                                             *ppBlock, unsigned long int
                                                                                             size, void PTR_PREFIX
                                                                                             *clientHook  );

/* The following is only used by the XCF_GlyphIDsToCharNames function.
   Note that charName is not guaranteed to be null terminated. */
typedef int (*XCF_GIDToCharName) (XFhandle handle, void PTR_PREFIX *client,
                                                                    XCFGlyphID glyphID, char PTR_PREFIX
                                                                    *charName, unsigned short int length);

/* The following is only used by the XCF_GlyphIDsToCIDs function. */
typedef int (*XCF_GIDToCID) (XFhandle handle, void PTR_PREFIX *client,
                                                         XCFGlyphID glyphID, Card16 cid);

/* the following is only used by the XCF_CharNamesToGIDs function */
typedef int (*XCF_CharNameToGID)(XFhandle handle, void PTR_PREFIX *client,
                                                                 Card16 count, char PTR_PREFIX *charName,
                                                                 XCFGlyphID glyphID);

/* The following is used when writing the glyphs in a GlyphDirectory
   and should only be used when writing a VMCIDFont. This is
   called by WriteOneGlyphDictEntry. In this case the id is equal to
   the cid. This code assumes that the client is parsing the font and
   filling in xcf's internal data structures appropriately. */
typedef unsigned short (*XCF_GetCharString)(
                        XFhandle h,
                        long id,
                        Card8 PTR_PREFIX *PTR_PREFIX *ppCharStr,
                        Card16 PTR_PREFIX *charStrLength,
                        Card8 PTR_PREFIX *fdIndex,
                        void PTR_PREFIX *clientHook);

/* The following is used to get the FSType value for a CIDFont. This value's
 * definition is the same as the fsType value in the OS/2 table of an
 * OpenType font. This value needs to be included in the CIDFont that xcf
 * generates, but is not defined in the CFF spec.
 */
typedef void (*XCF_GetFSType)(XFhandle h, long PTR_PREFIX *fsType,
                                                            void PTR_PREFIX *clientHook);

//GOODNAME
typedef void (*XCF_IsKnownROS)(XFhandle h, long PTR_PREFIX *knownROS,
                               char PTR_PREFIX *R, Card16 lenR,
                               char PTR_PREFIX *O, Card16 lenO,
                               long S,
                               void PTR_PREFIX *clientHook);

#if HAS_COOLTYPE_UFL == 1
/* The following two definitons are used to get the BlendDesignPositions and
 * BlendDesignMap values for a multiple master font. In CoolType, Type 1 fonts
 * are always converted to CFF before xcf is called and the values for these
 * two keywords are lost because they are not in the CFF spec. However, these
 * keywords are needed by Distiller and possibly other apps. So this info is
 * saved before the CFF conversion executes and these callbacks retrieve the
 * info when writing out the Type 1 font. The format of the string is
 * equivalent to the format expected for the keyword value in the font.
 */
typedef void (*XCF_GetDesignPositions)(XFhandle h, char PTR_PREFIX *PTR_PREFIX *designPositions, void PTR_PREFIX *clientHook);
typedef void (*XCF_GetDesignMap)(XFhandle h, char PTR_PREFIX *PTR_PREFIX *designMap, void PTR_PREFIX *clientHook);
#endif

/*****************************************
    Standard Library Callback Functions
******************************************/
typedef unsigned short int (*XCF_strlen) ( const char PTR_PREFIX *string );
typedef void PTR_PREFIX *(*XCF_memcpy) ( void PTR_PREFIX *dest, const void PTR_PREFIX *src, unsigned short int count );
typedef void PTR_PREFIX *(*XCF_memset) ( void PTR_PREFIX *dest, int c, unsigned short int count );
typedef int (*XCF_sprintf) ( char PTR_PREFIX *buffer, size_t cchDest, const char PTR_PREFIX *format, ... );
 /* Optional - used in DEVELOP mode to report error descriptions. */
typedef int (*XCF_printfError) ( const char PTR_PREFIX *format, ... );

typedef int (*XCF_atoi) ( const char *string );
typedef long (*XCF_strtol)( const char *nptr, char **endptr, int base );
typedef double (*XCF_atof) ( const char *string );

/* String comparison */
typedef int (*XCF_strcmp)( const char PTR_PREFIX *string1, const char
                                                    PTR_PREFIX *string2 );

typedef int (*XCF_strncmp)(const char PTR_PREFIX *string1, const char
                           PTR_PREFIX *string2, int len);

/******************************************
    Structure To Hold Callback Functions
*******************************************/
typedef struct
{
    XCF_PutBytesAtPosFunc putBytes;
    void PTR_PREFIX *putBytesHook;
    XCF_OutputPosFunc outputPos;
    void PTR_PREFIX *outputPosHook;
    XCF_GetBytesFromPosFunc getBytes;   /* Used if font does NOT reside in memory, otherwise NULL */
    void PTR_PREFIX *getBytesHook;
    XCF_AllocateFunc allocate;
    void PTR_PREFIX *allocateHook;
    void PTR_PREFIX *pFont;             /* Used if font resides in a single contiguous block of memory, otherwise NULL */
    unsigned long int  fontLength;
    XCF_strlen strlen;
    XCF_memcpy memcpy;
    XCF_memset memset;
    XCF_sprintf xcfSprintf;
    XCF_printfError printfError;    /* Optional - used in DEVELOP mode to report
                                                                     error descriptions. */
  /* The following 3 functions, atoi, strtol, and atof are used as follows:
   * if USE_FXL is defined, then both atoi and strtol need to be provided.
   * Otherwise, atof needs to be provided.
   */
  XCF_atoi atoi;
  XCF_strtol strtol;
    XCF_atof atof;
    XCF_strcmp strcmp;
  /* gidToCharName only needs to be defined if the client calls the
     function XCF_GlyphIDsToCharNames. */
  XCF_GIDToCharName gidToCharName;
  /* gidToCID only needs to be defined if the client calls the
     function XCF_GlyphIDsToCIDs. */
  XCF_GIDToCID gidToCID;
  /* This only needs to be defined if the client is providing the
     charstring data. */
  XCF_GetCharString getCharStr;
  void PTR_PREFIX *getCharStrHook;
  XCF_GetFSType getFSType;
  void PTR_PREFIX *getFSTypeHook;
  // GOODNAME
  XCF_IsKnownROS  isKnownROS;
  void PTR_PREFIX *isKnownROSHook;
#if HAS_COOLTYPE_UFL == 1
  XCF_GetDesignPositions getDesignPositions;
  void PTR_PREFIX *getDesignPositionsHook;
  XCF_GetDesignMap getDesignMap;
  void PTR_PREFIX *getDesignMapHook;
#endif
  XCF_CharNameToGID gnameToGid;
  XCF_strncmp strncmp;
} XCF_CallbackStruct;

/***************************
  Client Options
***************************/

/* UniqueID Options */
#define XCF_KEEP_UID     0x00 /* Define UID with the one in the font. */
#define XCF_UNDEFINE_UID 0x01 /* Don't define a UniqueID in the font. */
#define XCF_USER_UID     0x02 /* Replace UniqueID with one specified. */

/* Subroutine flattening options */
#define XCF_KEEP_SUBRS          0x00    /* Keep all subroutines intact */
#define XCF_FLATTEN_SUBRS       0x01    /* Flatten all the subroutines */

typedef struct {
  boolean useSpecialEncoding; /* Use special encoding that is not derived
                               * from Adobe Standard Encoding
                               */
  boolean notdefEncoding; /* Generate an encoding array w/.notdef names */
  unsigned char PTR_PREFIX *encodeName; /* If this field is not NULL, the
                                         * generated font will use the
                                         * specified encodeName for the
                                         * font encoding definition.
                                         */
  unsigned char PTR_PREFIX *fontName;   /* If this field is not NULL, the
                                         * generated font will use the
                                         * specified fontName for the
                                         * font name definition.
                                         */
  unsigned char PTR_PREFIX * PTR_PREFIX *otherSubrNames;
                                        /* If this field is not  NULL,
                                         * the generated font uses the names
                                         * in this array as the Flex and
                                         * Hint Substitution names to call
                                         * in the OtherSubrs array of the
                                         * font private dict. This is
                                         * required if the client needs to
                                         * support  pre 51 version printers.
                                         */
} XCF_DownloadOptions;

typedef struct
{
    unsigned int fontIndex;   /* font index w/i a CFF font set */
  unsigned int uniqueIDMethod;
  unsigned long uniqueID;   /* use this id if XCF_USER_UID is the method */
  boolean subrFlatten;      /* flatten/unwind subroutines; local and
                               global subrs are always flattened, this
                               field just indicates whether hint substitution
                               subrs are created - 1 = yes, 0 = no.
                             */
    Int16    lenIV;           /* This field is the value for charstring
                             * encryption. Typically -1 (no encryption),
                             * 0 (encryption with no extra bytes), or
                             * 4 (encryption with 4 extra bytes).
                             */
    boolean  hexEncoding;     /* 0 = binary, or 1 = hex encoding */
    boolean  eexecEncryption;
    Card8        outputCharstrType; /* 1 = Type1, 2 = Type2 charstrings */
    Card16   maxBlockSize;
  XCF_DownloadOptions dlOptions;
} XCF_ClientOptions;

/****************************
  Font Identifer Definitions
****************************/

#define XCF_SingleMaster   0x00
#define XCF_MultipleMaster 0x01
#define XCF_CID            0x02
#define XCF_SyntheticBase  0x03
#define XCF_Chameleon      0x04

/***************************
    API Functions
***************************/

extern enum XCF_Result XCF_Init(
                        XFhandle PTR_PREFIX *pHandle,                       /* Out */
                        XCF_CallbackStruct PTR_PREFIX *pCallbacks,  /* In */
            XCF_ClientOptions PTR_PREFIX *options);     /* In */

extern enum XCF_Result XCF_CleanUp(
                        XFhandle PTR_PREFIX *pHandle);              /* In/Out */

extern enum XCF_Result XCF_FontCount(
                        XFhandle handle,                                /* In */
                        unsigned int PTR_PREFIX *count);    /* Out */

extern enum XCF_Result XCF_FontName(XFhandle handle,    /* In */
                        unsigned short int fontIndex,                     /* In */
                        char PTR_PREFIX *fontName,                        /* Out */
                        unsigned short int maxFontNameLength);      /* In */

extern enum XCF_Result XCF_ConvertToPostScript(
                        XFhandle handle);                                      /* In */

extern enum XCF_Result XCF_DumpCff(
                        XFhandle handle,                             /* In */
                        unsigned int fontIndex,              /* In */
                        int dumpCompleteFontSet,             /* In */
                        char PTR_PREFIX *fileName,       /* In */
                        char PTR_PREFIX *commandLine); /* In */

/* Given a handle to a font returns in identifer whether it is a synthetic,
   multiple master, single master, cid, or chameleon font. */
extern enum XCF_Result XCF_FontIdentification(
            XFhandle handle,
            unsigned short int PTR_PREFIX *identifier);

#if HAS_COOLTYPE_UFL == 1
/* Initializes, creates, and returns an XFhandle in pHandle.
   This is essentially the same function as XCF_Init except
   that it does not read a fontset to initialize certain
   fields in its internal fontSet data structure. charStrCt
   is the number of glyphs in this font. This is used to
   allocate the structure that keeps track of which glyphs
   have been downloaded.
 */
extern enum XCF_Result XCF_InitHandle(
                        XFhandle PTR_PREFIX *pHandle,                       /* Out */
                        XCF_CallbackStruct PTR_PREFIX *pCallbacks,  /* In */
            XCF_ClientOptions PTR_PREFIX *options,      /* In */
            unsigned long charStrCt);                   /* In */
#endif

/*************************************************************************
                        XCF Overview
**************************************************************************

XCF is used to convert fonts from the CFF (Compact Font Format) format
to the standard PostScript Type 1 font format. The CFF format records
font data more compactly than the original Type 1 format. The CFF format
also allows multiple fonts to be stored in a single file called a font
set. XCF_ConvertToPostScript can be used to examine the contents of a
font set and expand selected fonts within it.

Calls into the xcf API always begin with a call to XCF_Init(). This
function initializes, creates, and returns a XFHandle
which will be passed to all subsequent calls. XCF_Init()
takes as arguments a pointer to a structure containing callbacks and
a pointer to XCF_ClientOptions. The client options passed in are
copied by XCF_Init so the client does not have to maintain this data
structure. The fontIndex argument should be set to 0 for CFF files
that contain a single font. Passing the options to XCF_Init implies
that the same options are used for each font in a fontset. If this
isn't true for all clients then XCF_ConvertToPostScript and
XCF_DownloadFontIncr will need to be modified to accept the client options.

A pointer and length can be passed if the font resides completely in
memory. In this case the GetBytes callback should be set to NULL.
Otherwise the GetBytes() callback is used to read the CFF font. Callback
procedures are used in place of library calls to maintain portability.
The expanded font is returned using the PutBytes callback function. The
only library dependency xcf has is <setjmp.h>.

Calls into xcf should always end with a call to CleanUp()
except when the call to XCF_Init() fails. All xcf functions return
an enumerated status value of type XCF_Result. Any value other than XCF_Ok
indicates that an error has occurred.

A font set is expanded with a call to XCF_ConvertToPostScript().
This procedure will expand the font specified in the fontIndex
field of the XCF_ClientOptions struct.

FontCount() is used to obtain the number of fonts stored in a CFF font
file.
FontName() is used to read the name of any font in a CFF font file.


*************************************************************************/

/*************************************************************************
                        XCF Downloading Overview
**************************************************************************
The following functions are used to incrementally download or subset
CFF fonts with Type 1 or Type 2 charstrings. They monitor:
  1) the state of the downloading process, and
  2) the characters that have been downloaded.
The latter is necessary so that seac characters are handled effectively.
These functions accept a glyph id (GID) which can be used to index into
the CFF's charset table. It assumes that clients can convert a character
code or unicode into a GID. It also assumes that the font will be used
in a Level 2 or above PostScript printer.

In order to download a font subset from a CFF font set a client needs
to perform the following steps:
1. Initialize the font set by calling XCF_Init().
2. Call XCF_ProcessCFF to read the cff data.
3. Download a font subset by calling XCF_DownloadFontIncr().
4. Repeat #3 as often as necessary for this font.
5. Terminate XCF by calling XCF_CleanUp().

To get various information about the downloaded font step 3 can be
replaced by calls to: XCF_CountDownloadGlyphs, XCF_GlyphIDsToCharNames,
or XCF_GlyphIDsToCIDs.

*************************************************************************/
/**************************************************************************
Function name:  XCF_DownloadFontIncr()
Summary:        Download a font from a CFF fontset.
Description:    Generate a font that is specified by the pCharStrID.

Parameters:
                hfontset - XCF fontset handle obtained from XCF_Init().
                cGlyphs - number of charstrings to download.
          If cGlyphs = 0, the function downloads a base font with only
          a ".notdef" charstring. If cGlyphs = -1, the function downloads
          the entire font in which case the rest of the arguments are
          ignored, i.e., pGlyphID, etc.
                pGlyphID - pointer to a list of glyphIDs
                pGlyphName - pointer to a list of character names to use. This
          list must be in the same order as the pGlyphID list.
          If this list is NULL, then the name defined in the
          charset will be used.
                pCharStrLength - pointer to the total length of charstrings
          downloaded.

Return Values:  standard XCF_Result values
Notes: This function keeps track of the downloaded characters, therefore,
  it won't download characters that have already been downloaded.
  Characters that are needed for seac characters are downloaded
  automatically.
*************************************************************************/

extern enum XCF_Result XCF_DownloadFontIncr(
    XFhandle hfontset,                      /* In */
    short cGlyphs,                              /* In */
    XCFGlyphID PTR_PREFIX *pGlyphID,              /* In */
    unsigned char PTR_PREFIX **pGlyphName,      /* In */
    unsigned long PTR_PREFIX *pCharStrLength    /* Out */
    );


/*************************************************************************
Function name:  XCF_CountDownloadGlyphs()
Summary:        Get the number of glyphs necessary to download.
Description:    This function returns in pcNewGlyphs the number of glyphs
                in the pGlyphID list that have not been downloaded.

Parameters:
  hfontset - XCF fontset handle obtained from XCF_Init().
  cGlyphs - number of glyphs in the pGlyphID list.
  pGlyphID - pointer to a list of glyphIDs
  pcNewGlyphs - Number of new glyphs that have not been downloaded.
                This number does not include seac characters.

Return values: standard XCF_Result value
*************************************************************************/
extern enum XCF_Result XCF_CountDownloadGlyphs(
  XFhandle hfontset,                                /* In */
  short cGlyphs,                          /* In */
  XCFGlyphID PTR_PREFIX *pGlyphID,        /* In */
  unsigned short PTR_PREFIX *pcNewGlyphs  /* Out */
);

/*************************************************************************
Function name:  XCF_ClearIncrGlyphList()
Summary:        Clears (reset to 0) the list of glyphs that have been dlded.
Description:    Updates the DownloadRecordStruct.

Parameters:
  hfontset - XCF fontset handle obtained from XCF_Init().

Return values: standard XCF_Result value
*************************************************************************/
extern enum XCF_Result XCF_ClearIncrGlyphList(XFhandle hfontset);

/*************************************************************************
Function name:  XCF_SubsetRestrictions()
Summary:        Checks for usage and subsetting restrictions.
Description:    Checks the last string in the string index table for a font
                authentication string. If it is there then usageRestricted
                is true and the subsetting restrictions are returned in
                subset. If this is not a usageRestricted font then subset
                is set to 100. subset contains a positive number between
                0 and 100. It is the maximum percentage of glyphs that can
                be included in a subsetted font. So 0 means subsetting is
                not allowed and 100 means subsetting is unrestricted.

Parameters:
  handle - XCF fontset handle obtained from XCF_Init().
  usageRestricted - returns 1 if font is usage restricted, otherwise 0.
  subset - returns a number between 0 and 100 inclusive.

Return values: standard XCF_Result value
*************************************************************************/
extern enum XCF_Result XCF_SubsetRestrictions(XFhandle handle,        /* In */
                                                     unsigned char PTR_PREFIX *usageRestricted, /* Out */
                                                     unsigned short PTR_PREFIX *subset          /* Out */
                                                     );

/* Reads the CFF data. */
extern enum XCF_Result XCF_ProcessCFF(XFhandle handle);

/* For each glyphID in pGlyphIDs gidToCharName is called with the associated
   character name and string length. The character name is not guaranteed
   to be null terminated.*/
extern enum XCF_Result XCF_GlyphIDsToCharNames(
            XFhandle handle,
            short cGlyphs, /* number of glyphs in glyphID list */
            XCFGlyphID PTR_PREFIX *pGlyphIDs, /* list of glyphIDs */
            void PTR_PREFIX *client, /* client data passed to callback, can be NULL */
            unsigned short  clientSize  /* size of client data buffer */
);

/* For each glyphID in pGlyphIDs gidToCID is called with the associated cid. */
extern enum XCF_Result XCF_GlyphIDsToCIDs(
      XFhandle handle,
      short cGlyphs, /* number of glyphs in glyphID list */
      XCFGlyphID PTR_PREFIX *pGlyphIDs, /* list of glyphIDs */
      void PTR_PREFIX *client /* client data passed to callback, can be NULL */
);

/* For each glyphName in pGlyphNames, gnameToGid is called with the associated
   glyph id.  */
extern enum XCF_Result XCF_CharNamesToGIDs(
            XFhandle handle,
            short cGlyphs, /* number of glyph names */
            char PTR_PREFIX **ppGlyphNames, /* list of glyphNames */
            void PTR_PREFIX *client /* client data passed to callback, can be NULL */
);

/*************************************************************************
                        Callback Functions
**************************************************************************

The callback functions are passed to xcf in a callback structure.
Callbacks are used by xcf instead of library calls for portability.

-- PutBytes --
typedef int (*XCF_PutBytesAtPosFunc) ( char PTR_PREFIX *pData, long int position, unsigned short int length, void PTR_PREFIX *clientHook );

This function takes a pointer to the data, a position, a length  and a
client hook as arguments. XCF uses the XCF_PutBytesAtPosFunc() to
return the expanded font to it's client. If position is less than zero
then the data should immediately follow the data sent in the last call
to XCF_PutBytesAtPosFunc. (No repositioning occurs.) If position is
greater than or equal to zero then the output should be repositioned
to that point. (Position bytes from the begining of the output file.)
XCF buffers it's output to avoid overly frequent calls to this
function. clientHook contains the same pointer which was passed in
via the putBytesHook field in the callback structure.

-- OutputPos --
typedef long int (*XCF_OutputPosFunc) ( void PTR_PREFIX *clientHook )

This function reports the current position of the output stream. The
result of this function can be used as the 'position' argument to
XCF_PutBytesAtPosFunc. clientHook contains the same pointer which was
passed in via the outputPosHook field in the callback structure.

-- Allocate --
typedef unsigned int (*XCF_AllocateFunc) ( void PTR_PREFIX * PTR_PREFIX * handle, unsigned int size );

This function allocates, deallocates or reallocates memory.
Required functionality:
    When size == 0 and handle != NULL
        free the handle
    When size == 0 and handle == NULL
        don't do anything
    When size > 0 and handle != NULL
        reallocate memory, preserving the data.
    When size > 0 and handle == NULL
        allocate the memory (it does not have to be cleared).

    Return true on success, false on failure.

    In the case of failure handle should be set to NULL. If a failure
    occurs during memory reallocation then the original memory pointed
    to by handle should be deallocated.

-- GetBytesFromPosFunc --
typedef int (*XCF_GetBytesFromPosFunc) ( char PTR_PREFIX * PTR_PREFIX *ppData, long int position, unsigned short int length, void PTR_PREFIX *clientHook );

  This function is only needed if the font does not reside in RAM.
  XCF_GetBytesFromPosFunc() requests a block of data from the cff font set.
  The block size will never exceed 64K. 'position' contains an offset to the
  begining of the data (0 = first byte) and 'length' contains the number
  of bytes requested. A pointer to the requested data is returned in
  'ppData'. 'clientHook' can be used to by the client if needed. It returns
  the hook passed in via the getBytesHook field in the callback structure.
  Each call to GetFontBlock() indicates that the previous block is no longer
  needed. This allows a single block of memory to be reused (growing if needed)
  for each call to XCF_GetBytesFromPosFunc(). Memory allocated to hold the
  data requested by XCF_GetBytesFromPosFunc() may be freed after the current
  typedef unsigned short int (*XCF_strlen) ( const char PTR_PREFIX *string );
  typedef void PTR_PREFIX *(*XCF_memcpy) ( void PTR_PREFIX *dest, const void PTR_PREFIX *src, unsigned short int count );
  typedef void PTR_PREFIX *(*XCF_memset) ( void PTR_PREFIX *dest, int c, unsigned short int count );
  typedef int (*XCF_sprintf) ( char PTR_PREFIX *buffer, size_t cchDest, const char PTR_PREFIX *format, ... );
  typedef double (*XCF_atof) ( const char *string );

  -- Optional --
  typedef int (*XCF_printfError) ( const char PTR_PREFIX *format, ... );    Optional - used in DEVELOP mode to report error descriptions.

*************************************************************************/


/*************************************************************************
                            Preprocessor Definitions
**************************************************************************/

/*************************************************************************

  XCF_DEVELOP   -   If defined then additional error message information
                    is returned via the printf callback. Also, additional
                    error checking is performed. XCF_DUMP should only be
                    defined during debugging.

  XCF_DUMP      -   Causes charstring debug information to be printed
                    during processing. XCF_DUMP should only be defined
                    during debugging.

  XCF_DUMP_CFF - allows reading and writing of CFF data to a file
                 (not as a Type 1 font).

**************************************************************************/

#ifdef __cplusplus
}
#endif

#endif /* XCF_PUB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_t1.c ===
/* @(#)CM_VerSion xcf_t1.c atm09 1.3 16499.eco sum= 63806 atm09.002 */
/* @(#)CM_VerSion xcf_t1.c atm08 1.6 16343.eco sum= 18288 atm08.005 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1995-1996 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

/***********************************************************************
Original version: John Felton, April 17, 1996
************************************************************************/

/* -------------------------------------------------------------------------
     Header Includes
  --------------------------------------------------------------------------- */

#include "xcf_pub.h"
#include "xcf_priv.h"
#include <math.h>
#ifdef T13
#include "xcf_t13.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

static Card8 HexTable[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

#define MAX_LINE_LENGTH 1024
#define REAL_TO_INT(x) (long)(x < 0 ? x - 0.5 : x + 0.5)

/* Definitions of font data replacement points. */
#define XCF_FONTNAME  0
#define XCF_ENCODING  1
#define XCF_UID       2
#define XCF_XUID      3

/* The following items are artifacts of the Type 1 format and are */
/* no longer considered necessary for the proper functioning of fonts. */
#if 1
#define T1_READONLY ""
#define T1_NOACCESS ""
#else /* old way */
#define T1_READONLY " readonly "
#define T1_NOACCESS " noaccess "
#endif /*1*/

static void BufferEncrypt(XCF_Handle h,
                          Card8 PTR_PREFIX *inBuf,
                          Card8 PTR_PREFIX *outBuf,
                          Int32 inLen,
                          Card32 PTR_PREFIX *outLen,
                          Card16 PTR_PREFIX *KeyP,
                          boolean hexEncode)
{
register Card8 Cipher;
register Card8 PTR_PREFIX *PlainSource = inBuf;
register Card8 PTR_PREFIX *CipherDest = outBuf;
register Card16 R = *KeyP;
Card8 totalEOLs = 0;

if (!hexEncode) /* Binary encode */
 { *outLen = inLen;

   while (--inLen >= 0)
    { Cipher = (*PlainSource++ ^ (Card8)(R >> 8));
      R = (Card16)(((Card16)Cipher + R) * 52845 + 22719);
      *CipherDest++ = Cipher;
    } /* end while */
 } /* end if */
else /* Hex Encode */
 { Card8 t;
   *outLen = (inLen << 1);

   while (--inLen >= 0)
    { Cipher = (*PlainSource++ ^ (Card8)(R >> 8));
      R = (Card16)(((Card16)Cipher + R) * 52845 + 22719);
      t = (Card8)(((Cipher >> 4) & 0x0F) + 0x30);
      if (t > 0x39)
        t += 7;
      *CipherDest++ = t;
      t = (Card8)((Cipher & 0x0F) + 0x30);
      if (t > 0x39)
        t += 7;
      *CipherDest++ = t;
      h->outBuffer.charsOnLine+=2;
      if (h->outBuffer.charsOnLine > EOL_SPACING)
       {
#if 0
        *CipherDest++ = '\r';
        *CipherDest++ = '\n';
         totalEOLs += 2;
#else
         Card8 PTR_PREFIX *p;
                 for (p = (Card8 *)XCF_NEW_LINE; *p; ++p)
                        {
                        *CipherDest++ = *p;
                        totalEOLs  += 1;
                        }
#endif
         h->outBuffer.charsOnLine = 0;
       } /* end if */
    } /* end while */

   *outLen += totalEOLs;
 } /* end else */

*KeyP = R;
} /* end BufferEncrypt() */

static void BufferHexEncode(XCF_Handle h,
                          Card8 PTR_PREFIX *inBuf,
                          Card8 PTR_PREFIX *outBuf,
                          Int32 inLen,
                          Card32 PTR_PREFIX *outLen
                          )
{
    Card8   Datum;
    Int32    i;

    *outLen = (inLen << 1);
    h->outBuffer.charsOnLine = 0;
    for (i = 0; i < inLen; i++)               /* for all input data */
    {
        Datum   = *inBuf++;
        *outBuf++ = HexTable[((Card8)(Datum >> 4)) & 0x0f];
        *outBuf++ = HexTable[((Card8)Datum) & 0x0f];
        h->outBuffer.charsOnLine+=2;

        if (h->outBuffer.charsOnLine > EOL_SPACING)   /* End of the line reached */
        {
#if 0
            *outBuf++ = '\r';
            *outBuf++ = '\n';
            *outLen  += 2;
#else
           Card8 PTR_PREFIX *p;
         for (p = (Card8 *)XCF_NEW_LINE; *p; ++p)
         {
           *outBuf++ = *p;
           *outLen  += 1;
         }
#endif
        h->outBuffer.charsOnLine = 0;
        }

    }
}

static void WriteSizedNumber(XCF_Handle h, Card8 PTR_PREFIX *data, Card32
                                                         length)
{
  Card32 bytesWritten;

  if (h->options.hexEncoding)
  {
    BufferHexEncode(h, data, h->outBuffer.eexecEncodeBuffer, length,
                                    &bytesWritten);
    XCF_PutData(h, h->outBuffer.eexecEncodeBuffer, bytesWritten);
  }
    else
    XCF_PutData(h, data, length);
}

#if HAS_COOLTYPE_UFL == 0
static
#endif
void PutSizedNumber(XCF_Handle h, Card32 value, Card16 size)
{
    Card8 data;

    switch (size)
        {
        case 4:
            data = (Card8) (value >> 24 & 0xff);
      WriteSizedNumber(h, &data, 1);
        case 3:
            data = (Card8) (value >> 16 & 0xff);
      WriteSizedNumber(h, &data, 1);
        case 2:
            data = (Card8) (value >> 8 & 0xff);
      WriteSizedNumber(h, &data, 1);
        case 1:
            data = (Card8) (value & 0xff);
      WriteSizedNumber(h, &data, 1);
            break;
        default:
            XCF_FATAL_ERROR(h, XCF_IndexOutOfRange, "bad size on PutSizedNumber", size);
        }
}

static void HexEncodeCharString(XCF_Handle h, Card8 PTR_PREFIX *pData,
                                                                Card32 length)
{
  Card32 blockSize, encodedBlockSize;

  while (length > 0)
  {
    blockSize = MIN(length, MAX_ENCODE_LENGTH);
    BufferHexEncode(h, pData, h->outBuffer.eexecEncodeBuffer, blockSize,
      &encodedBlockSize);
    XCF_PutData(h, h->outBuffer.eexecEncodeBuffer, encodedBlockSize);
    length -= blockSize;
    pData += blockSize;
  }
}

void XT1_PutT1Data(XCF_Handle h, Card8 PTR_PREFIX *pData, Card32 length)
{
    Card32 blockSize, encodedBlockSize;

    if (!h->outBuffer.eexecOn)
      XCF_PutData(h, pData, length);
    else
    {
        while (length > 0)
        {
            blockSize = MIN(length,MAX_ENCODE_LENGTH);
            BufferEncrypt(h, pData, h->outBuffer.eexecEncodeBuffer,
                blockSize, &encodedBlockSize, &h->outBuffer.eexecKey,
                h->options.hexEncoding);
            XCF_PutData(h, h->outBuffer.eexecEncodeBuffer, encodedBlockSize);
            length -= blockSize;
            pData += blockSize;
        }
    }
}

#if HAS_COOLTYPE_UFL==0
static
#endif
Card32 PutType1CharString(XCF_Handle h, Card8 PTR_PREFIX *pData, Card32 length) {
    Card32 blockSize, encodedBlockSize;
    Card16 lenIVKey;
    Card32 bytesWritten = length;

    if (h->options.lenIV == -1)
  {
    if (h->options.hexEncoding)
      HexEncodeCharString(h, pData, length);
    else
        XT1_PutT1Data(h, pData, length);
  }
    else
#ifdef T13
  if (!XT13_PutCharString(h, pData, length, &bytesWritten))
#endif
    {
        bytesWritten += h->options.lenIV;
        lenIVKey = LEN_IV_INITIAL_KEY;
        BufferEncrypt(h, h->outBuffer.lenIVInitialBytes,
            h->outBuffer.charStringEncodeBuffer, h->options.lenIV,
            &encodedBlockSize, &lenIVKey, false);
        if (h->options.hexEncoding && !h->outBuffer.eexecOn)
      HexEncodeCharString(h, h->outBuffer.charStringEncodeBuffer, encodedBlockSize);
    else
      XT1_PutT1Data(h, h->outBuffer.charStringEncodeBuffer, encodedBlockSize);
        while (length > 0)
        {
            blockSize = MIN(length,MAX_ENCODE_LENGTH);
            BufferEncrypt(h, pData, h->outBuffer.charStringEncodeBuffer, blockSize, &encodedBlockSize, &lenIVKey, false);
        if (h->options.hexEncoding && !h->outBuffer.eexecOn)
        HexEncodeCharString(h, h->outBuffer.charStringEncodeBuffer, encodedBlockSize);
          else
        XT1_PutT1Data(h, h->outBuffer.charStringEncodeBuffer, encodedBlockSize);
            length -= blockSize;
            pData += blockSize;
        }
    }
    return bytesWritten;
}

static void PutStringID(XCF_Handle h, StringID sid)
{
    char PTR_PREFIX *str;
    Card16 len;

    XCF_LookUpString(h, sid, &str, &len);
    XT1_PutT1Data(h,(Card8 PTR_PREFIX *)str,len);
}

static void PutString(XCF_Handle h, char PTR_PREFIX *str)
{
    XT1_PutT1Data(h,(Card8 PTR_PREFIX *)str,h->callbacks.strlen(str));
}

static void PutLine(XCF_Handle h, char PTR_PREFIX *str)
    {
    PutString(h, str);
    PutString(h, XCF_NEW_LINE);
    }

static void PutLongNumber(XCF_Handle h, long n)
{
    char str[30];

  h->callbacks.xcfSprintf(str, CCHOF(str), "%ld", n);
    PutString(h,str);
}

#ifdef XCF_REAL_OK
static void PutNumber(XCF_Handle h, Fixed n, boolean fracType)
{
  char str[30];

  if ((!fracType && (n & 0x0000FFFF) == 0) || (fracType && (n & 0x3FFFFFFF) == 0))
    /* n is an integer */
    h->callbacks.xcfSprintf(str, CCHOF(str), "%ld", fracType ? (Int32)FRAC_TO_REAL(n) : (Int32)FIXED_TO_INT(n));
  else
    h->callbacks.xcfSprintf(str, CCHOF(str), "%.7g", fracType ? FRAC_TO_REAL(n) : FIXED_TO_REAL(n));
  PutString(h,str);
}

static void PutRoundedFixedNumber(XCF_Handle h, Fixed n)
{
  char str[30];

  h->callbacks.xcfSprintf(str, CCHOF(str), "%.2f", FIXED_TO_REAL(n));
  PutString(h,str);
}

#else

static void PutNumber(XCF_Handle h, Fixed n, boolean fracType)
{
    char str[30];

  if ((!fracType && (n & 0x0000FFFF) == 0) || (fracType && (n & 0x3FFFFFFF) == 0))
    /* n is an integer */
    h->callbacks.xcfSprintf(str, CCHOF(str), "%ld", fracType ? (Int32)(n >> 30) : (Int32)FIXED_TO_INT(n));
  else
    XCF_Fixed2CString(n, str, 7, fracType);
    PutString(h,str);
}

static void PutRoundedFixedNumber(XCF_Handle h, Fixed n)
{
    char str[30];

  XCF_Fixed2CString(n, str, 2, false);
    PutString(h,str);
}
#endif /* XCF_REAL_OK */

static void StartEexec(XCF_Handle h)
{
        PutString(h,"currentfile eexec ");
        XCF_FlushOutputBuffer(h);
        h->outBuffer.eexecOn = true;
        h->outBuffer.charsOnLine = INITIAL_CHARS_ON_HEX_LINE;
        h->outBuffer.eexecKey = EEXEC_INITIAL_KEY;
        XT1_PutT1Data(h, h->outBuffer.eexecInitialBytes, 4);
}

static void StopEexec(XCF_Handle h)
{
    XCF_FlushOutputBuffer(h);
    h->outBuffer.eexecOn = false;
}

static void WriteSIDLine(XCF_Handle h, char *name, Fixed sid, IntX count)
{
    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " (");
        PutStringID(h, (StringID)sid);
        PutString(h, ")" T1_READONLY " def" XCF_NEW_LINE);
    }
}

static void WriteLongNumberLine(XCF_Handle h, char *name, long number, IntX count)
{
    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " ");
        PutLongNumber(h, number);
        PutString(h, " def" XCF_NEW_LINE);
    }
}

static void WriteNumberLine(XCF_Handle h, char *name, Fixed number, IntX count,
                                                        boolean fracType)
{
    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " ");
        PutNumber(h, number, fracType);
        PutString(h, " def" XCF_NEW_LINE);
    }
}

static Fixed PutNumberList(XCF_Handle h, Fixed numbers[], IntX count, boolean
                                                     delta, Fixed initialValue, boolean fracType)
{
    Fixed number = initialValue;
    Int16 i;

    for (i=0; i < count; ++i)
    {
        if (delta)
            number += numbers[i];
        else
            number = numbers[i];
        PutNumber(h, number, fracType);
        PutString(h, " ");
    }
    return number;
}

static void PutBlendNumberList(XCF_Handle h, Fixed numbers[], IntX count,
                               boolean delta,
                               Fixed PTR_PREFIX *pInitialValues,
                               IntX iniValCount,
                               boolean fracType)
{
    Fixed number;
    Int16 i;

    for (i=0; (i < count) && (i < iniValCount); ++i)
    {
        if (delta)
            number = numbers[i] + *pInitialValues;
        else
            number = numbers[i];
        PutNumber(h, number, fracType);
        PutString(h, " ");
        *pInitialValues++ = number;
    }
}

static void PutFontMatrix(XCF_Handle h, char (PTR_PREFIX *list)[FONT_MATRIX_ENTRY_SIZE], IntX count)
{
  Int16 i;

  for (i = 0; i < count; i++)
  {
    PutString(h, list[i]);
    PutString(h, " ");
  }
}

static void WriteNumberListLine(XCF_Handle h, char PTR_PREFIX *name, Fixed
                                                                numbers[], IntX count, boolean fracType)
{
    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " [");
        PutNumberList(h, numbers, count, false, 0, fracType);
        PutString(h, "]" T1_READONLY " def" XCF_NEW_LINE);
    }
}

static void WriteLongNumberListLine(XCF_Handle h, char PTR_PREFIX *name, Card32
                                                                numbers[], IntX count)
{
  Int16 i;

    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " [");
        for (i = 0; i < count; i++)
    {
      PutLongNumber(h, numbers[i]);
      PutString(h, " ");
    }
        PutString(h, "]" T1_READONLY " def" XCF_NEW_LINE);
    }
}

static void WriteFontMatrix(XCF_Handle h, char PTR_PREFIX *name,
                            char (PTR_PREFIX *stringList)[FONT_MATRIX_ENTRY_SIZE], IntX count)
{
  if (count)
  {
    PutString(h, "/");
    PutString(h, name);
    PutString(h, " [");
    PutFontMatrix(h, stringList, count);
    PutString(h, "]" T1_READONLY " def" XCF_NEW_LINE);
  }
}

static Fixed Blend(XCF_Handle h, Fixed numbers[], IntX count, boolean delta,
                   Fixed PTR_PREFIX *pInitialValues, IntX iniValCount, boolean fracType)
{
    Fixed   blend = 0;
    Fixed   value;
    IntX    i;

    if (count == 1)
        return(numbers[0]);
    else
    {
        if (count != h->dict.numberOfMasters)
                XCF_FATAL_ERROR(h, XCF_InvalidBlendArgumentCount, "Blend argument count does not equal number of masters", count);
        for (i=0; (i < count) && (i < iniValCount) ; ++i)
        {
            if (delta)
                value = numbers[i] + *pInitialValues;
            else
                value = numbers[i];
            blend += fracType? XCF_FracMul(value, h->dict.weightVector[i] << 14) : XCF_FixMul(value, h->dict.weightVector[i]);
            *pInitialValues++ = value;
        }
    }
    return blend;
}

static void PutBlendedNumber(XCF_Handle h, Fixed numbers[], IntX count,
                             boolean delta, Fixed PTR_PREFIX *pInitialValues,
                             IntX iniValCount, boolean fracType)
{
  Fixed val = Blend(h, numbers, count, delta, pInitialValues, iniValCount, fracType);

  if (fracType)
    PutNumber(h, val, true);
  else
      PutRoundedFixedNumber(h, val);
}

static void PutBlend(XCF_Handle h, Fixed numbers[], IntX count, boolean
                     instance, boolean squareBrackets, boolean delta, Fixed
                     PTR_PREFIX *pInitialValues, IntX iniValCount, boolean fracType)
{
    IntX    i;

    if (count == 1)
    {
        if ((h->dict.numberOfMasters == 0) || (instance))
            PutNumber(h, numbers[0], fracType);
        else /* expand single value to number of masters */
        {
            PutString(h, squareBrackets ? "[ " : "{ ");
            for (i = 0; i < h->dict.numberOfMasters; ++i)
            {
                PutNumber(h, numbers[0], fracType);
                PutString(h, " ");
            }
            PutString(h, squareBrackets ? "]" : "}");
        }
    }
    else if (instance)
    {
        PutBlendedNumber(h, numbers, count, delta, pInitialValues, iniValCount, fracType);
    }
    else
    {
        PutString(h, squareBrackets ? "[ " : "{ ");
        PutBlendNumberList(h, numbers, count, delta, pInitialValues, iniValCount, fracType);
        PutString(h, squareBrackets ? "]" : "}");
    }
}

static void WriteBlendLine(XCF_Handle h, char PTR_PREFIX *name, Fixed
                                                     numbers[], IntX count, boolean instance, boolean
                                                     squareBrackets, boolean delta, boolean fracType)
{
    Fixed previousValues[MAX_RASTERIZER_STACK_SIZE] = {0};

    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " ");
        PutBlend(h, numbers, count, instance, squareBrackets, delta,
                         &previousValues[0],
                         sizeof(previousValues)/sizeof(Fixed), fracType);
        PutString(h, " def" XCF_NEW_LINE);
    }
}

static void PutBlendArray(XCF_Handle h, Fixed numbers[], IntX count, boolean
                                                    instance, boolean squareBrackets, boolean delta,
                                                    boolean fracType)
{
    IntX    blendCount;
    IntX    i;
    Fixed previousValues[MAX_RASTERIZER_STACK_SIZE] = {0};

    if (h->dict.numberOfMasters == 0)
        PutNumberList(h, numbers, count, delta, 0, fracType);
    else
    {
        blendCount = (IntX) (count / h->dict.numberOfMasters);
        for (i = 0; i < blendCount; ++i)
        {
            PutBlend(h, &numbers[i*h->dict.numberOfMasters], h->dict.numberOfMasters,
                             instance, squareBrackets, delta, &previousValues[0],
                             sizeof(previousValues)/sizeof(Fixed), fracType);
            PutString(h, " ");
        }
    }
}

static void WriteBlendArrayLine(XCF_Handle h, char PTR_PREFIX *name, Fixed
                                                                numbers[], IntX count, boolean instance,
                                                                boolean squareBrackets, boolean delta,
                                boolean fracType)
{
    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, squareBrackets ? " [ " : " { ");
        PutBlendArray(h, numbers, count, instance, squareBrackets, delta, fracType);
        PutString(h, squareBrackets ? "]" : "}");
        PutString(h, " def" XCF_NEW_LINE);
    }
}


static void PutBoolean(XCF_Handle h, Fixed value)
{
    if (value)
        PutString(h, "true ");
    else
        PutString(h, "false ");
}

static void PutBlendBoolean(XCF_Handle h, Fixed values[], IntX count, boolean instance, Fixed threshold)
{
  Fixed blend = 0;
    IntX    i;

    if (count == 1)
    {
        if ((h->dict.numberOfMasters == 0) || (instance))
            PutBoolean(h, values[0]);
        else /* expand single value to number of masters */
        {
            PutString(h, "[ ");
            for (i = 0; i < h->dict.numberOfMasters; ++i)
                PutBoolean(h, values[0]);
            PutString(h, "]");
        }
    }
    else if (instance)
    {
        for (i=0; i < count ; ++i)
            blend += XCF_FixMul(values[i], h->dict.weightVector[i]);
        PutBoolean(h, (blend >= threshold));
    }
    else
    {
        PutString(h, "[ ");
        for (i=0; i < count ; ++i)
            PutBoolean(h, values[i]);
        PutString(h, "]");
    }
}

static char StreamEncodeName(XCF_Handle h)
{
    if (!h->options.dlOptions.encodeName)
        return 0;
    PutString(h, "/Encoding ");
    PutString(h, (char PTR_PREFIX *)h->options.dlOptions.encodeName);
    PutString(h, " def" XCF_NEW_LINE);
    return 1;
}

static char StreamFontName(XCF_Handle h)
{
    if (!h->options.dlOptions.fontName)
        return 0;
    PutString(h, (char PTR_PREFIX *)h->options.dlOptions.fontName);
    return 1;
}

static char StreamUID(XCF_Handle h)
{
  switch (h->options.uniqueIDMethod)
  {
    case XCF_KEEP_UID:
          return 0;
      case XCF_UNDEFINE_UID:
          return 1;
      case XCF_USER_UID:
          WriteLongNumberLine(h, "UniqueID", h->options.uniqueID, 1);
          return 1;
      default:
          return 0;
    }
}

static char StreamKeyPointData(XCF_Handle h, Card16 code)
{
  switch (code)
  {
      case XCF_ENCODING:
      return StreamEncodeName(h);
      break;
    case XCF_FONTNAME:
      return StreamFontName(h);
      break;
    case XCF_UID:
      return StreamUID(h);
      break;
    }
  return 0;
}

static void WriteBlendBooleanLine(XCF_Handle h, char PTR_PREFIX *name, Fixed values[], IntX count, boolean instance, Fixed threshold)
{
    if (count)
    {
        PutString(h, "/");
        PutString(h, name);
        PutString(h, " ");
        PutBlendBoolean(h, values, count, instance, threshold);
        PutString(h, " def" XCF_NEW_LINE);
    }
}

#define BLDOTHERSUBRS (5) /* Number of OtherSubrs specific to mmfonts. */

static void WriteRoll(XCF_Handle h, int m, int n)
{
  char str[50];

  if (m < 2 || n == 0 || n == m)
    return;
  if (m == 2 && (n == 1 || n == -1))
  {
    PutString(h, "exch ");
    return;
  }
  if (n < 0 && m + n <= -n)
    n = m + n;
  h->callbacks.xcfSprintf(str, CCHOF(str), "%ld %ld roll ", m, n);
  PutString(h, str);
}

/* Writes the PS code for OtherSubrs 14 - 18, if necessary.  If
   this OtherSubr is unnecessary, i.e. the # of masters times
   the # of results exceeds the font stack limit then no more
   OtherSubrs are written out. */
static void WriteBlendOtherSubrs(XCF_Handle h)
{
  int i = 0;
  int j;
  int resultCt[BLDOTHERSUBRS]; /* Number of results after blending */
  int numOutput = 0;

  resultCt[i++] = 1;
  resultCt[i++] = 2;
  resultCt[i++] = 3;
  resultCt[i++] = 4;
  resultCt[i++] = 6;
  for (i = 0; i < BLDOTHERSUBRS; i++)
  {
    if (h->dict.numberOfMasters * resultCt[i] > T1_MAX_OP_STACK)
      break;
    PutString(h, "{ ");
    for (j = resultCt[i]; j > 1; j--)
    {
      WriteRoll(h, resultCt[i], -1);
      WriteRoll(h, j * (h->dict.numberOfMasters - 1) + resultCt[i], 1 -
                                h->dict.numberOfMasters);
      PutString(h, "$Blend ");
    }
    WriteRoll(h, resultCt[i], -1);
    WriteRoll(h, h->dict.numberOfMasters + resultCt[i] - 1,
                            -(h->dict.numberOfMasters - 1));
    PutString(h, "$Blend } bind" XCF_NEW_LINE);
    numOutput++;
  }
  /* Make certain that we output up through OtherSubr #18. */
  for (i = numOutput; i < BLDOTHERSUBRS; i++)
    PutString(h, "{}" XCF_NEW_LINE);
}

/* Write the PS code for OtherSubrs 19-27. Currently, these are only
   defined for fonts with transitional designs and are for backward
   compatibility with earlier rasterizers that did not have these
   operators defined. */
static void WriteAdditionalOtherSubrs(XCF_Handle h)
{
  /* 19 storeWV */
  PutString(h, "{currentfont dup /WeightVector get exch /Private get /BuildCharArray get 3 -1 roll cvi 3 -1 roll putinterval}" XCF_NEW_LINE);
  /* 20 add */
  PutString(h, "{add}" XCF_NEW_LINE);
  /* 21 sub */
  PutString(h, "{exch sub}" XCF_NEW_LINE);
  /* 22 mul */
  PutString(h, "{mul}" XCF_NEW_LINE);
  /* 23 div */
  PutString(h, "{exch div}" XCF_NEW_LINE);
  /* 24 put */
  PutString(h, "{currentfont /Private get /BuildCharArray get 3 1 roll exch cvi exch put}" XCF_NEW_LINE);
  /* 25 get */
  PutString(h, "{currentfont /Private get /BuildCharArray get exch cvi get }"
                        XCF_NEW_LINE);
  /* 26 psput */
  PutString(h, "{exch dup mark eq {3 1 roll}{exch} ifelse currentfont /Private get /BuildCharArray get 3 1 roll cvi exch put}" XCF_NEW_LINE);
  /* 27 ifelse */
  PutString(h, "{4 2 roll exch le {exch} if pop}" XCF_NEW_LINE);
}

static void WriteOtherSubrs(XCF_Handle h, boolean flexUsed, boolean hintSubUsed)
{
  /* Check if the client requests to use special names for OtherSubrs 0-3. */
  if ( h->options.dlOptions.otherSubrNames )
  {
    unsigned short i;

    PutString(h, "/OtherSubrs [" XCF_NEW_LINE);
    for ( i = 0; i < 4; i++ )
    {
       PutString(h, "{");
#if HAS_COOLTYPE_UFL == 1
       PutString(h, "ct_CffDict/");
#endif
       if ( h->options.dlOptions.otherSubrNames[i] )
       {
         PutString(h, (char PTR_PREFIX *)h->options.dlOptions.otherSubrNames[i]);
#if HAS_COOLTYPE_UFL == 1
             PutString(h, " get exec");
#endif
         PutString(h, "}executeonly");
       }
       else
       {
         PutString(h, "}");
       }
     }
       if (h->dict.numberOfMasters)
         {
            PutString(h, "{} {} {}" XCF_NEW_LINE); /* 4-6 */
            PutString(h, "{} {} {} {} {} {} {} " XCF_NEW_LINE); /* 7-13 */
            WriteBlendOtherSubrs(h); /* 14-18 */
            if (XCF_TransDesignFont(h))
                WriteAdditionalOtherSubrs(h); /* 19-27 */
     }

     PutString(h, "] |-" XCF_NEW_LINE);
     return;
  }

    if (flexUsed || hintSubUsed || h->dict.numberOfMasters)
  {
      PutString(h, "/OtherSubrs" XCF_NEW_LINE);
      if (flexUsed)
      {
          PutString(h, FlexOtherSubrStr1);
          PutString(h, FlexOtherSubrStr2);
          PutString(h, FlexOtherSubrStr3);
          PutString(h, FlexOtherSubrStr4);
        PutString(h, FlexOtherSubrStr5);
          PutString(h, FlexOtherSubrStr6);
          PutString(h, FlexOtherSubrStr7);
          PutString(h, FlexOtherSubrStr8);
          PutString(h, FlexOtherSubrStr9);
          PutString(h, FlexOtherSubrStr10);
          PutString(h, FlexOtherSubrStr11);
          PutString(h, FlexOtherSubrStr12);
          PutString(h, FlexOtherSubrStr13);
          PutString(h, FlexOtherSubrStr14);
          PutString(h, FlexOtherSubrStr15);
          PutString(h, FlexOtherSubrStr16);
          PutString(h, FlexOtherSubrStr17);
      }
      else
      {
          PutString(h, "[ {} {} {}" XCF_NEW_LINE);
      }

      if (hintSubUsed)
      {
          PutString(h, HintSubtitutionOtherSubrStr);
      }
      else
      {
          PutString(h, "{}" XCF_NEW_LINE); /* 3 */
      }

      PutString(h, "{} {} {}" XCF_NEW_LINE); /* 4-6 */

    if (h->dict.numberOfMasters)
    {
      PutString(h, "{} {} {} {} {} {} {} " XCF_NEW_LINE); /* 7-13 */
      WriteBlendOtherSubrs(h); /* 14-18 */
      if (XCF_TransDesignFont(h))
        WriteAdditionalOtherSubrs(h); /* 19-27 */
    }
    PutString(h, "]|-" XCF_NEW_LINE);
  }
}

static void WriteCIDOtherSubrs(XCF_Handle h)
    {
    PutLine(h, XCF_NEW_LINE "/OtherSubrs [ {} {} {} { systemdict /internaldict known not" XCF_NEW_LINE
          "{ pop 3 } { 1183615869 systemdict /internaldict get exec dup" XCF_NEW_LINE
          "/startlock known { /startlock get exec }" XCF_NEW_LINE
          "{ dup /strtlck known { /strtlck get exec } { pop 3 } ifelse } ifelse } ifelse } bind" XCF_NEW_LINE
      "{} {} {} {} {} {} {} {} {}" XCF_NEW_LINE
      "{ 2 {cvi { { pop 0 lt { exit } if } loop } repeat } repeat } bind" XCF_NEW_LINE
      "{} {} {} {} {} {} {} {} {} {} {} {} {} {} {} ] def");
    }

static void PutCharacterName(XCF_Handle h, CardX index,
                             unsigned char PTR_PREFIX **pGlyphName)
{
    if (pGlyphName)
        PutString(h, (char PTR_PREFIX *)pGlyphName[index]);
    else
    {
        if (index)
            PutStringID(h, h->type1.pCharset[index-1]);
        else
            PutStringID(h, 0);
    }
}

static void PutFontName(XCF_Handle h)
{
    if (!StreamKeyPointData(h, XCF_FONTNAME))
    {
        XCF_LookUpTableEntry(h, &h->fontSet.fontNames, h->fontSet.fontIndex);
        XT1_PutT1Data(h,(Card8 PTR_PREFIX *)h->inBuffer.start, (Card16)h->inBuffer.blockLength);
    }
}

/*
Dictionary Entries

*** Font Info Dict ***

version
Notice
FullName
FamilyName
Weight
isFixedPitch        Default = "false"
ItalicAngle         Default = 0
UnderlinePosition   Default = -100
UnderlineThickness  Default = 50
Copyright
SyntheticBase
BaseFontName
BaseFontBlend

*** Font Dict ***

FontName
Encoding            Default = StandardEncoding
PaintType           Default = 0
FontType
FontMatrix          Default = [0.001 0 0 0.001 0 0]
FontBBox
UniqueID
XUID
StrokeWidth         Default = 0
Private
CharStrings
BlendDesignMap
BlendAxisTypes
WeightVector

*** Private Dict ***

BlueValues              Default = [] -- Emit empty brackets if there are no BlueValues
OtherBlues
FamilyBlues
FamilyOtherBlues
StdHW
StdVW
BlueScale               Default = 0.039625
BlueShift               Default = 7
BlueFuzz                Default = 1
StemSnapH
StemSnapV
ForceBold               Default = "false"
ForceBoldThreshold      Default = 0
lenIV
LanguageGroup           Default = 0
ExpansionFactor         Default = 0.06
initialRandomSeed       Default = 0
PostScript
defaultWidthX
nominalWidthX
NDV
CDV
lenBuildCharArray
*/

static boolean GlyphInCharSet(XCF_Handle h, StringID sid)
{
    CardX i;

    for (i=0; i < h->type1.charsetSize; ++i)
        if (sid == h->type1.pCharset[i])
            return true;
    return false;
    }

static void WriteEncodingArray(XCF_Handle h)
{
    char str[50];
    CardX i;

  if (h->options.dlOptions.notdefEncoding)
  {
    PutString(h, "/Encoding 256 array" XCF_NEW_LINE);
    PutString(h, "0 1 255 {1 index exch /.notdef put} for");
#if HAS_COOLTYPE_UFL == 1
      /* If this font needs to be parsed by CoolType or ATM then the
       * Encoding array needs to explicitly define at least one
       * encoding via the dup <charcode>/<name> put format.
       */
      PutString(h, XCF_NEW_LINE);
      PutString(h, "dup 0 /.notdef put" XCF_NEW_LINE);
      PutString(h, T1_READONLY " def" XCF_NEW_LINE);
#else
      PutString(h, " def" XCF_NEW_LINE);
#endif
    return;
  }
    if ((!h->dict.encodingCount) || (h->dict.encoding == cff_StandardEncoding))
        PutString(h, "/Encoding StandardEncoding def" XCF_NEW_LINE);
    else
    {
        PutString(h, "/Encoding 256 array" XCF_NEW_LINE);
        PutString(h, "0 1 255 {1 index exch /.notdef put} for" XCF_NEW_LINE);
        for (i=0;i<256;++i)
        {
            if (h->type1.pEncoding[i] != NOTDEF_SID)
            {
                if ((h->dict.encoding != cff_ExpertEncoding) || GlyphInCharSet(h, h->type1.pEncoding[i]))
                {
                    h->callbacks.xcfSprintf(str, CCHOF(str), "dup %ld /",(long int)i);
                    PutString(h, str);
                    PutStringID(h, h->type1.pEncoding[i]);
                    PutString(h," put" XCF_NEW_LINE);
                }
            }
        }
        PutString(h, T1_READONLY " def" XCF_NEW_LINE);
    }
}

static void WriteBlendAxisTypes(XCF_Handle h)
    {
        IntX i;
        if (!h->dict.blendAxisTypesCount)
            return;

        PutString(h, "/BlendAxisTypes [");
        for (i=0;i<h->dict.blendAxisTypesCount;++i)
        {
            PutString(h, "/");
            PutStringID(h, (StringID)h->dict.blendAxisTypes[i]);
            PutString(h, " ");
        }
        PutString(h, "] def" XCF_NEW_LINE);
    }


static CardX FontInfoDictCount(XCF_Handle h)
{
    CardX count = 5;    /* Add extra space for safety margin */

    count += (h->dict.noticeCount != 0);
    count += (h->dict.copyrightCount != 0);
    count += (h->dict.versionCount != 0);
    count += (h->dict.fullNameCount != 0);
    count += (h->dict.familyNameCount != 0);
    count += (h->dict.baseFontNameCount != 0);
    count += (h->dict.baseFontBlendCount != 0);
    count += (h->dict.weightCount != 0);
    count += (h->dict.italicAngleCount != 0);
    count += (h->dict.isFixedPitchCount != 0);
    count += (h->dict.underlinePositionCount != 0);
    count += (h->dict.underlineThicknessCount != 0);
    count += (h->dict.blendAxisTypesCount != 0);
  count += (h->callbacks.getFSType != 0);
    if (h->dict.numberOfMasters != 0)
    count += 4; /* Add for /DesignVector, /NormDesignVector,
                                 * /BlendDesignPositions, and /BlendDesignMap */
    return count;
}

static CardX FontDictCount(XCF_Handle h)
{
    CardX count;

  /* Add extra space for FontName, Encoding, FontType, etc. plus safety margin.
   * For mm fonts enough space is added for all of the extra mm definitions */
  count = (h->dict.numberOfMasters != 0) ? 25 : 10;
    count += (h->dict.paintTypeCount != 0);
    count += (h->dict.fontMatrixCount != 0);
    count += (h->dict.fontBBoxCount != 0);
    count += (h->dict.uniqueIDCount != 0);
    count += (h->dict.xUIDCount != 0);
    count += (h->dict.strokeWidthCount != 0);
    return count;
}

static CardX PrivateDictCount(XCF_Handle h)
{
    CardX count = 15;   /* Add extra space for LenIV, MinFeature, password, Erode, OtherSubrs, Subr, etc. plus safety margin */

    count += (h->dict.uniqueIDCount != 0);
    count += (h->dict.blueValuesCount != 0);
    count += (h->dict.otherBluesCount != 0);
    count += (h->dict.familyBluesCount != 0);
    count += (h->dict.familyOtherBluesCount != 0);
    count += (h->dict.stdHWCount != 0);
    count += (h->dict.stdVWCount != 0);
    count += (h->dict.blueScaleCount != 0);
    count += (h->dict.blueShiftCount != 0);
    count += (h->dict.blueFuzzCount != 0);
    count += (h->dict.stemSnapHCount != 0);
    count += (h->dict.stemSnapVCount != 0);
    count += (h->dict.forceBoldCount != 0);
    count += (h->dict.forceBoldThresholdCount != 0);
    count += (h->dict.languageGroupCount != 0);
    count += (h->dict.expansionFactorCount != 0);
    count += (h->dict.initialRandomSeedCount != 0);
    if (h->options.outputCharstrType != 1)
    {
        count += (h->dict.defaultWidthXCount != 0);
        count += (h->dict.nominalWidthXCount != 0);
    }
  if (h->dict.lenBuildCharArrayCount != 0)
    count += 2; /* Add extra one for /BuildCharArray */
  if (h->dict.numberOfMasters > 0)
    count += 2; /* Add 2 for NDV and CDV */
    count += (h->dict.embeddedPostscriptCount != 0);
#ifdef T13
  if (XT13_IST13(h))
    count++;
#endif

    return count;
}

static void WriteBlendProc(XCF_Handle h)
{
    IntX vectorIndex;

    if (h->dict.numberOfMasters == 0)
        return;
    PutString(h, "/$Blend {");
    for (vectorIndex = 1; vectorIndex < h->dict.numberOfMasters; ++vectorIndex)
    {
        PutRoundedFixedNumber(h, h->dict.weightVector[vectorIndex]);
        PutString(h, "  mul ");
        if (vectorIndex > 1)
            PutString(h, "add ");
        if (vectorIndex < h->dict.numberOfMasters - 1)
            PutString(h, "exch ");
    }
    PutString(h, "add } bind def" XCF_NEW_LINE);
}


#if HAS_COOLTYPE_UFL == 1
static void WriteBlendDict(XCF_Handle h)
{
    PutString(h, "/Blend 3 dict dup begin" XCF_NEW_LINE );
    WriteBlendArrayLine(h, "FontBBox", h->dict.fontBBox, h->dict.fontBBoxCount,
                                            false, false, false, false);
    PutString(h, "/FontInfo 3 dict dup begin" XCF_NEW_LINE);
    WriteBlendLine(h, "ItalicAngle", h->dict.italicAngle,
                                 h->dict.italicAngleCount, false, true, true, false);
    WriteBlendLine(h, "UnderlinePosition", h->dict.underlinePosition,
                                 h->dict.underlinePositionCount, false, true, true, false);
    WriteBlendLine(h, "UnderlineThickness", h->dict.underlineThickness,
                                 h->dict.underlineThicknessCount, false, true, true, false);
    PutString(h, "end def" XCF_NEW_LINE);
    PutString(h, "/Private 14 dict def" XCF_NEW_LINE "end def"  XCF_NEW_LINE);
}

static void WriteMakeBlendedFontOp(XCF_Handle h)
{
#include "xcf_mkbf.h"
}

static void WriteInterpCharString(XCF_Handle h)
{
boolean unprocessed = h->options.outputCharstrType == 2;

#include "xcf_ics.h"
}

static void WriteMMFindFontDef(XCF_Handle h)
{
#include "xcf_mmff.h"
}

/* Writes the multiple master font specific NormalizeDesignVector and
 * ConvertDesignVector procedures.
 */
static void WriteDesignVectorProcs(XCF_Handle h)
{
  char icsmemname[128];
  char icsflagname[128];
  char str[128];
  char fontName[512];
  Card32 subrNum = h->options.outputCharstrType == 1 ?
            h->type1.subrOffsets.cnt : h->dict.localSubrs.count;

  if (h->options.dlOptions.fontName)
  {
    unsigned short int length = sizeof(fontName);
    /* add 1 for null terminator */
    if (length > (unsigned short int)(h->callbacks.strlen((const char PTR_PREFIX *)h->options.dlOptions.fontName) + 1))
        length = (unsigned short int)(h->callbacks.strlen((const char PTR_PREFIX *)h->options.dlOptions.fontName) + 1);
    h->callbacks.memcpy(fontName, h->options.dlOptions.fontName, length);
  }
  else
    XCF_FontName(h, (unsigned short int)h->fontSet.fontIndex, fontName,
                 (unsigned short int)(sizeof(fontName)));
  h->callbacks.xcfSprintf(icsmemname, CCHOF(icsmemname), "&%sicsmem", fontName);
  h->callbacks.xcfSprintf(icsflagname, CCHOF(icsflagname), "&%sflag", fontName);
  PutString(h, "/ICSsetup {" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "userdict /%s known not {%s", icsmemname,
                                             XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s 25 dict put%s", icsmemname,
                                             XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s get /&thisfontdict currentdict put%s", icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s get /:savestack 10 array put%s",
                                             icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s get /:savelevel 0 put%s",
                                             icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s get dup /&me exch put%s",
                                             icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s get /WeightVector known not {%s",
                                             icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "    userdict /%s get /WeightVector %d array put%s", icsmemname, h->dict.numberOfMasters, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "    userdict /%s get /NormDesignVector %d array put%s", icsmemname, h->dict.userDesignVectorCount, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "    userdict /%s get /DesignVector %d array put%s", icsmemname, h->dict.userDesignVectorCount, XCF_NEW_LINE);
  PutString(h, str);
  PutString(h, "  } if" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s get {%s", icsflagname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "    currentdict /WeightVector get aload pop userdict /%s", icsmemname);
  PutString(h, str);
  PutString(h, " get /WeightVector get astore pop" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "    currentdict /NormDesignVector get aload pop userdict /%s", icsmemname);
  PutString(h, str);
  PutString(h, " get /NormDesignVector get astore pop" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "    currentdict /DesignVector get aload pop userdict /%s", icsmemname);
  PutString(h, str);
  PutString(h, " get /DesignVector get astore pop" XCF_NEW_LINE);
  PutString(h, "  } if" XCF_NEW_LINE);
  PutString(h, "} if } bind def" XCF_NEW_LINE);
  PutString(h, "/Pre-N&C {" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  userdict /%s known not {userdict /%s true put}%s", icsflagname, icsflagname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "  {/%s true store} ifelse%s", icsflagname,
                                             XCF_NEW_LINE);
  PutString(h, str);
  PutString(h, "} bind def" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "/Post-N&C {/%s false store} bind def%s",
                                             icsflagname, XCF_NEW_LINE);
  PutString(h, str);

  /* Write NormalizeDesignVector procedure. */
  PutString(h, "/NormalizeDesignVector {" XCF_NEW_LINE);
  PutString(h, "Pre-N&C ICSsetup" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "%s /DesignVector get astore pop%s", icsmemname,
                                             XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "%d %s interpcharstring%s", (IntX) subrNum, icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "%s /NormDesignVector get aload pop ", icsmemname);
  PutString(h, str);
  PutString(h, XCF_NEW_LINE "} bind def" XCF_NEW_LINE);

  /* Write ConvertDesignVector procedure. */
  PutString(h, "/ConvertDesignVector {" XCF_NEW_LINE);
  PutString(h, "Pre-N&C ICSsetup" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "%s /NormDesignVector get astore pop%s",
                                             icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  h->callbacks.xcfSprintf(str, CCHOF(str), "%d %s interpcharstring%s",
                                             (IntX) subrNum + 1, icsmemname, XCF_NEW_LINE);
  PutString(h, str);
  PutString(h, "Post-N&C" XCF_NEW_LINE);
  h->callbacks.xcfSprintf(str, CCHOF(str), "%s /WeightVector get aload pop ", icsmemname);
  PutString(h, str);
  PutString(h, XCF_NEW_LINE "} bind def" XCF_NEW_LINE);
}
#endif /* HAS_COOLTYPE_UFL */

static void PutStemSnapBugFix(XCF_Handle h, Fixed arg1, Fixed numbers[], IntX count)
{
    Fixed arg2 = 0;
    IntX i;

    for (i=0; i < count; ++i)
        arg2 += numbers[i];

    PutString(h, XCF_NEW_LINE " systemdict /internaldict known" XCF_NEW_LINE "{1183615869 systemdict /internaldict get exec" XCF_NEW_LINE "/StemSnapLength 2 copy known {get ");
    PutLongNumber(h, count);
    PutString(h, " lt} {pop pop true} ifelse}" XCF_NEW_LINE "{true} ifelse {pop [");
    PutNumber(h, arg1, false);
    PutString(h, " ");
    PutNumber(h, arg2, false);
    PutString(h, "]} if def" XCF_NEW_LINE);
}

static void WriteStemSnap(XCF_Handle h, boolean instance)
{
    WriteBlendArrayLine(h, "StdHW", h->dict.stdHW, h->dict.stdHWCount, instance,
                                            true, true, false);
    WriteBlendArrayLine(h, "StdVW", h->dict.stdVW, h->dict.stdVWCount, instance,
                                            true, true, false);
    if (h->dict.stemSnapHCount)
    {
        PutString(h, "/StemSnapH [ ");
        PutBlendArray(h, h->dict.stemSnapH, h->dict.stemSnapHCount, instance, true,
                                    true, false);
        PutString(h, "] ");
        if ((h->dict.stemSnapHCount > 2) && (!h->dict.numberOfMasters))/* xxx fix stem snap bug fix to work for MM */
            PutStemSnapBugFix(h, h->dict.stdHW[0], h->dict.stemSnapH, h->dict.stemSnapHCount);
        else
            PutString(h, "def" XCF_NEW_LINE);
    }
    if (h->dict.stemSnapVCount)
    {
        PutString(h, "/StemSnapV [ ");
        PutBlendArray(h, h->dict.stemSnapV, h->dict.stemSnapVCount, instance, true,
                                    true, false);
        PutString(h, "] ");
        if ((h->dict.stemSnapVCount > 2) && (!h->dict.numberOfMasters))/* xxx fix stem snap bug fix to work for MM */
            PutStemSnapBugFix(h, h->dict.stdVW[0], h->dict.stemSnapV, h->dict.stemSnapVCount);
        else
            PutString(h, "def" XCF_NEW_LINE);
    }
}

#define FIXEDEIGHT 0x00080000L

static void WriteErode(XCF_Handle h, boolean instance) /* xxx fix to use instance */
{
    IntX i;
    Fixed value = 0;
    Fixed previousValues[MAX_RASTERIZER_STACK_SIZE] = {0};
    Fixed blend = 0;
    Fixed blendedStdVW = Blend(h, h->dict.stdVW, h->dict.stdVWCount, true,
                               &previousValues[0],
                               sizeof(previousValues)/sizeof(Fixed), false);

    if ((h->dict.stdVWCount) && (h->dict.stdVW[0] != 0))
    {
        PutString(h,"/Erode{" XCF_NEW_LINE);
        if (!h->dict.numberOfMasters)
            PutNumber(h, XCF_FixDiv(h->dict.stdVW[0],FIXEDEIGHT), false); /* trunc(stdvw/8) + 0.5 */
        else if (instance)
        {
            for (i = 0; i < h->dict.stdVWCount; ++i)
            {
                value = h->dict.stdVW[i];
        blend += XCF_FixMul(XCF_FixDiv(value, FIXEDEIGHT), h->dict.weightVector[i]);
            }
            PutNumber(h, blend, false);
            PutString(h, " ");
        }

        else
        {
            PutString(h, "{ ");
            for (i = 0; i < h->dict.stdVWCount; ++i)
            {
                value = h->dict.stdVW[i];
        PutNumber(h, XCF_FixDiv(value, FIXEDEIGHT), false); /* trunc(stdvw/8) + 0.5 */
                PutString(h, " ");
            }
            PutString(h, "}");
        }
        PutString(h," dup 3 -1 roll 0.1 mul exch 0.5 sub mul cvi sub dup mul" XCF_NEW_LINE);

        if ((instance) || (!h->dict.numberOfMasters))
            PutNumber(h, blendedStdVW, false);
        else
        {
            PutString(h, "{ ");
            PutNumberList(h, h->dict.stdVW, h->dict.stdVWCount, false, 0, false);
            PutString(h, "}");
        }
/*      PutNumber(h,h->dict.stdVW[0]); */
        PutString(h," 0 dtransform dup mul exch dup mul add" XCF_NEW_LINE "le{pop pop 1.0 1.0}{pop pop 0.0 1.5}ifelse}def" XCF_NEW_LINE);
    }
}

static void WritePrivateBlendDict(XCF_Handle h)
{
    if (h->dict.numberOfMasters == 0)
        return;

    PutString(h, "3 index /Blend get /Private get begin" XCF_NEW_LINE );
    WriteBlendArrayLine(h, "BlueValues", h->dict.blueValues,
                                            h->dict.blueValuesCount, false, true, true, false);
    WriteBlendArrayLine(h, "OtherBlues", h->dict.otherBlues,
                                            h->dict.otherBluesCount, false, true, true, false);
    WriteBlendLine(h, "BlueScale", h->dict.blueScale, h->dict.blueScaleCount,
                                 false, true, true, true);
    WriteBlendLine(h, "BlueShift", h->dict.blueShift, h->dict.blueShiftCount,
                                 false, true, true, false);
    WriteBlendArrayLine(h, "FamilyBlues", h->dict.familyBlues,
                                            h->dict.familyBluesCount, false, true, true, false);
    WriteBlendArrayLine(h, "FamilyOtherBlues", h->dict.familyOtherBlues,
                                            h->dict.familyOtherBluesCount, false, true, true, false);
    WriteBlendBooleanLine(h, "ForceBold", h->dict.forceBold, h->dict.forceBoldCount, false, h->dict.forceBoldThreshold);
    WriteStemSnap(h, false);
    WriteErode(h, false);
    PutString(h, "end" XCF_NEW_LINE );

}
/*
3 index /Blend get /Private get begin
/BlueValues[[ -18 -25][ 0 0][ 528 532][ 553 557][ 430 432][ 450 457][ 520 516][ 521 524][ 563 588][ 588 607][ 605 627][ 612 638]] def
/OtherBlues[[ 252 263][ 259 268][ -144 -168][ -121 -143][ -85 -114][ -68 -105]] def
/FamilyBlues[[ -18 -18][ 0 0][ 528 528][ 553 553][ 430 430][ 450 450][ 520 520][ 521 521][ 563 563][ 588 588][ 605 605][ 612 612]] def
/FamilyOtherBlues[[ 252 252][ 259 259][ -144 -144][ -121 -121][ -85 -85][ -68 -68]] def
/ForceBold [ false true] def
/StdHW [[25 60 ]] def
/StdVW [[45 140 ]] def
/Erode{
{5.5 17.5 } dup 3 -1 roll 0.1 mul exch 0.5 sub mul cvi sub dup mul
{45 140 } 0 dtransform dup mul exch dup mul add
le{pop pop 1.0 1.0}{pop pop 0.0 1.5}ifelse}def
end

/Erode{
 8.166522 dup 3 -1 roll 0.1 mul exch 0.5 sub mul cvi sub dup mul
66.11  0 dtransform dup mul exch dup mul add
le{pop pop 1.0 1.0}{pop pop 0.0 1.5}ifelse}def

*/

static void WriteFontDict(XCF_Handle h)
{
    char line[MAX_LINE_LENGTH];

  /* Note: for ATM compatibility
     * for mm fonts the BlendDict must come after the BlendDesignPositions,
   * BlendDesignMap, and BlendAxisTypes definitions.
     */

    PutString(h, "%!FontType1" XCF_NEW_LINE);

    /**** Start Font & FontInfo Dicts ****/
    h->callbacks.xcfSprintf(line, CCHOF(line), "%ld dict begin" XCF_NEW_LINE "/FontInfo %ld dict dup begin" XCF_NEW_LINE, (Card32) FontDictCount(h), (Card32) FontInfoDictCount(h));
    PutString(h,line);

    /**** Write Info Dict ****/

    WriteSIDLine(h, "Notice", h->dict.notice, h->dict.noticeCount);
    WriteSIDLine(h, "Copyright", h->dict.copyright, h->dict.copyrightCount);
    WriteSIDLine(h, "version", h->dict.version, h->dict.versionCount);
    WriteSIDLine(h, "FullName", h->dict.fullName, h->dict.fullNameCount);
    WriteSIDLine(h, "FamilyName", h->dict.familyName, h->dict.familyNameCount);
    WriteSIDLine(h, "BaseFontName", h->dict.baseFontName, h->dict.baseFontNameCount);
    WriteNumberListLine(h, "BaseFontBlend", h->dict.baseFontBlend,
                                            h->dict.baseFontBlendCount, false);
    WriteSIDLine(h, "Weight", h->dict.weight, h->dict.weightCount);
    WriteBlendLine(h, "ItalicAngle", h->dict.italicAngle,
                                 h->dict.italicAngleCount, true, true, true, false);
    WriteBlendBooleanLine(h, "isFixedPitch", h->dict.isFixedPitch, h->dict.isFixedPitchCount, true, FIXEDHALF);  /* xxx What do we use for threshold? */
    WriteBlendLine(h, "UnderlinePosition", h->dict.underlinePosition,
                                 h->dict.underlinePositionCount, true, true, true, false);
    WriteBlendLine(h, "UnderlineThickness", h->dict.underlineThickness,
                                 h->dict.underlineThicknessCount, true, true, true, false);

  if (h->callbacks.getFSType)
  {
    long fsType;

    h->callbacks.getFSType(h, &fsType, h->callbacks.getFSTypeHook);
    if (fsType != -1)
      WriteLongNumberLine(h, "FSType", fsType, 1);
  }

    if (h->dict.numberOfMasters != 0)
    {
#if HAS_COOLTYPE_UFL == 1
        if (h->callbacks.getDesignPositions)
        {
            char *bdp;

            h->callbacks.getDesignPositions(h, &bdp, h->callbacks.getDesignPositionsHook);
            if (bdp[0] != 0)
            {
                h->callbacks.xcfSprintf(line, CCHOF(line), "/BlendDesignPositions %s def" XCF_NEW_LINE, bdp);
                PutString(h, line);
            }
        }
        if (h->callbacks.getDesignMap)
        {
            char *bdm;

            h->callbacks.getDesignMap(h, &bdm, h->callbacks.getDesignMapHook);
            if (bdm[0] != 0)
            {
                h->callbacks.xcfSprintf(line, CCHOF(line), "/BlendDesignMap %s def" XCF_NEW_LINE, bdm);
                PutString(h, line);
            }
        }
#endif

        WriteBlendAxisTypes(h);
    }

    PutString(h,"end" T1_READONLY " def" XCF_NEW_LINE); /* end of FontInfo dict*/

    /**** Write Font Dict ****/

    PutString(h, "/FontName /");
  PutFontName(h);
    PutString(h, " def" XCF_NEW_LINE);
  if (!StreamKeyPointData(h, XCF_ENCODING))
    WriteEncodingArray(h);
    WriteNumberLine(h, "PaintType", h->dict.paintType, h->dict.paintTypeCount, false);
    WriteLongNumberLine(h, "FontType", h->options.outputCharstrType, 1);
  WriteNumberListLine(h, "DesignVector", h->dict.userDesignVector,
                                            h->dict.userDesignVectorCount, false);
  WriteNumberListLine(h, "NormDesignVector", h->dict.normDesignVector,
                                            h->dict.normDesignVectorCount, false);
    WriteNumberListLine(h, "WeightVector", h->dict.weightVector,
                                            h->dict.numberOfMasters, false);
    WriteBlendProc(h);
    WriteFontMatrix(h, "FontMatrix", h->dict.fontMatrix, h->dict.fontMatrixCount);
    WriteBlendArrayLine(h, "FontBBox", h->dict.fontBBox,
                      h->dict.fontBBoxCount, true, false, false, false);

#if HAS_COOLTYPE_UFL == 1
    if (h->dict.numberOfMasters != 0)
  {
      WriteBlendDict(h);
    WriteMakeBlendedFontOp(h);
    WriteInterpCharString(h);
    WriteDesignVectorProcs(h);
    WriteMMFindFontDef(h);
  }
#endif

  if (!StreamKeyPointData(h, XCF_UID))
    WriteLongNumberLine(h, "UniqueID", h->dict.uniqueID,
                                                h->dict.uniqueIDCount);
  if (h->dict.xUIDCount > 0)
      WriteLongNumberListLine(h, "XUID", h->dict.xUID, h->dict.xUIDCount);
    WriteBlendLine(h, "StrokeWidth", h->dict.strokeWidth,
                                 h->dict.strokeWidthCount, true, true, true, false);

    PutString(h, "currentdict end" XCF_NEW_LINE);
}


static void GetSubr(XCF_Handle h,
                          CardX index,
                          boolean unprocessed,
                          Card8 PTR_PREFIX * PTR_PREFIX *ppSubr,
                          Card16 PTR_PREFIX *pSubrLength)
{
    Offset subrOffset, nextSubrOffset;
    if (unprocessed)
    {
        XCF_LookUpTableEntry(h, &h->dict.localSubrs, index);
        *pSubrLength = (Card16) h->inBuffer.blockLength;
        *ppSubr = h->inBuffer.start;
    }
    else
    {
        subrOffset = *da_INDEX(h->type1.subrOffsets, index);
        nextSubrOffset = *da_INDEX(h->type1.subrOffsets, index+1);
        *pSubrLength = (Card16)(nextSubrOffset - subrOffset);
        *ppSubr = da_INDEX(h->type1.subrs, subrOffset);
    }
}


void XT1_CIDWriteSubrs(XCF_Handle h, Card16 fdIndex)
{
    CardX i;
    Card8 PTR_PREFIX *pSubr;
    Card16 subrLength;
  Card32 numberOfSubrs;

  h->dict.localSubrs = h->type1.cid.localSubrs[fdIndex];
  h->dict.localSubrBias = h->type1.cid.localSubrBias[fdIndex];
  numberOfSubrs = h->options.outputCharstrType == 2 ?
        h->dict.localSubrs.count : h->type1.subrOffsets.cnt - 1;

    for (i=0 ; i < numberOfSubrs ; ++i)
    {
    GetSubr(h, i, h->options.outputCharstrType == 2, &pSubr, &subrLength);
        PutType1CharString(h, pSubr, subrLength);
    }
}

void XT1_CIDWriteSubrMap(XCF_Handle h, Card16 fdIndex)
{
    CardX i;
    Offset subrOffset = 0;
    Card16 lenIVextraBytes = (h->options.lenIV == -1) ? 0 : h->options.lenIV;
    Card32 accum = h->type1.cid.subrDataStart - h->type1.cid.charMapStart;
  boolean unprocessed = h->options.outputCharstrType == 2;
  Card32 numberOfSubrs = unprocessed ?
    h->type1.cid.localSubrs[fdIndex].count : h->type1.subrOffsets.cnt;

    for (i=0 ; i < numberOfSubrs ; ++i)
    {
        subrOffset = unprocessed ? i : *da_INDEX(h->type1.subrOffsets, i);
        PutSizedNumber(h, accum + subrOffset, 4);   /* xxx will change if SDBytes is not 4! */
        accum += lenIVextraBytes;
    }
}

static void GetCIDCharString(XCF_Handle h, Card8 PTR_PREFIX *PTR_PREFIX
                                                         *ppCharStr, Card16 PTR_PREFIX *charStrLength)
{
  if ((h->options.outputCharstrType != 2) && (h->dict.fontType != 1))
  {
    *ppCharStr = h->type1.charStrs.array;
    *charStrLength = (Card16) h->type1.charStrs.cnt;
  }
  else
  {
    XCF_LookUpTableEntry(h, &h->fontSet.charStrings, (Card16)h->type1.charStrs.cnt);
    *charStrLength = (Card16) h->inBuffer.blockLength;
    *ppCharStr = h->inBuffer.start;
  }
}

void XT1_CIDWriteCharString(XCF_Handle h)
{
  Card8 PTR_PREFIX *pCharStr;
  Card16 charStrLength;

  GetCIDCharString(h, &pCharStr, &charStrLength);

    h->type1.cid.charDataCount += PutType1CharString(h, pCharStr, charStrLength);
    *da_NEXT(h->type1.charStrOffsets) = h->type1.cid.charDataCount;
}

static void WriteDVSubr(XCF_Handle h, Card32 subrNum, StringID sid, Card16 lenIVextraBytes)
{
  char PTR_PREFIX *pSubr;
  Card16 length;
  char str[50];

  XCF_LookUpString(h, sid, &pSubr, &length);
    h->callbacks.xcfSprintf(str, CCHOF(str), "dup %ld %lu -| ", (long int)subrNum,
    (long unsigned int) (length + lenIVextraBytes));
    PutString(h, str);
    PutType1CharString(h, (Card8 PTR_PREFIX *)pSubr, length);
    PutString(h," |" XCF_NEW_LINE);
}

static void WriteSubrs(XCF_Handle h, boolean unprocessed)
{
    CardX i;
    char str[50];
    Card8 PTR_PREFIX *pSubr;
    Card16 subrLength;
    Card16 lenIVextraBytes;
    Card32 numberOfSubrs;
    if (unprocessed)
        numberOfSubrs = h->dict.localSubrs.count;
    else
        numberOfSubrs = h->type1.subrOffsets.cnt - 1;

    if ((numberOfSubrs == 0) && !(h->dict.numberOfMasters && unprocessed))
        return;

    h->callbacks.xcfSprintf(str, CCHOF(str), "/Subrs %u  array" XCF_NEW_LINE,
    /* Add 2 for NDV, CDV */
    numberOfSubrs  + ((unprocessed && (h->dict.numberOfMasters > 0)) ? 2 : 0));
    PutString(h,str);
    lenIVextraBytes = (h->options.lenIV == -1) ? 0 : h->options.lenIV;
    for (i=0;i<numberOfSubrs;++i)
    {
        GetSubr(h, i, unprocessed, &pSubr, &subrLength);
        h->callbacks.xcfSprintf(str, CCHOF(str), "dup %ld %lu -| ",(long int)i,(long unsigned int) (subrLength+lenIVextraBytes));
        PutString(h, str);
        PutType1CharString(h, pSubr, subrLength);
        PutString(h," |" XCF_NEW_LINE);
    }
  if (unprocessed && (h->dict.numberOfMasters > 0))
  {
    WriteDVSubr(h, numberOfSubrs, h->dict.ndv, lenIVextraBytes);
    WriteDVSubr(h, numberOfSubrs + 1, h->dict.cdv, lenIVextraBytes);
  }
    PutString(h,"|-" XCF_NEW_LINE);
}

static void GetCharstring(XCF_Handle h,
                          CardX index,
                          boolean unprocessed,
                          Card8 PTR_PREFIX * PTR_PREFIX *ppCharStr,
                          Card16 PTR_PREFIX *pCharStrLength)
{
    Offset charStrOffset, nextCharStrOffset;

  if (h->options.subrFlatten && !unprocessed)
    /* Need to process the charstring first since we always re-use data
       space in the DA charstring */
    ProcessOneCharString(h, index);
  else
    /* We already processed all the charstrings, but we still need to
       check for seac characters. */
    CheckSeacCharString(h, index);

    if (unprocessed)
    {
        XCF_LookUpTableEntry(h, &h->fontSet.charStrings, index);
        *pCharStrLength = (Card16) h->inBuffer.blockLength;
        *ppCharStr = h->inBuffer.start;
    }
  else
  {
    charStrOffset = *da_INDEX(h->type1.charStrOffsets,
      h->options.subrFlatten ? 0 : index);
    if (!h->options.subrFlatten)
    {
      nextCharStrOffset = *da_INDEX(h->type1.charStrOffsets, index+1);
      *pCharStrLength = (Card16)(nextCharStrOffset - charStrOffset);
    }
    else
        *pCharStrLength = (Card16)h->type1.charStrs.cnt;
        *ppCharStr = da_INDEX(h->type1.charStrs, charStrOffset);
  }
}

static Card32 GetSeacGlyphID(XCF_Handle h, CardX index)
{
    char PTR_PREFIX *stdName;
    char PTR_PREFIX *str;
    Card16 len;
    Card32 i;
    Card32 id = (Card32)-1;

    /* Get the correct glyph id for a seac character.  Seac character index
       always uses standard encoding
    */
    if (h->dict.charset == cff_ISOAdobeCharset)
    {
        id = GetStdEncodeSID(index);
    }
    else if (index)
    {
        stdName = GetStdEncodingName(index);

        if (index < h->fontSet.charStrings.count)
        {   /* See if the glyph name matches the one in Standard encoding */
            XCF_LookUpString(h, h->type1.pCharset[index-1], &str, &len);
            if (len)
            {
                if (!h->callbacks.strcmp(stdName, str))
                    id = h->type1.pCharset[index - 1];
            }
        }

        if (id == (Card32)-1)
        {
            /* Search for the glyphID.  Worse case is we have to search the
         entire charset. We may want to sort the character list to
         improve the searching performance. */


            for (i = 0; i < h->type1.charsetSize; i++)
            {
                XCF_LookUpString(h, h->type1.pCharset[i], &str, &len);
                if (len)
                {
                    if (!h->callbacks.strcmp(stdName, str))
                    {
                        id = i+1;
                        break;
                    }
                }
            }
        }
    }

    return id;
}

static unsigned short GetSeacCharacters(XCF_Handle h,
                                        XCFGlyphID PTR_PREFIX *seacID)
{
    Card32 gid;
    unsigned short cSeacGlyphs;

    cSeacGlyphs = 0;
    if (h->cstr.baseSeac != 0)
    {
        gid = GetSeacGlyphID(h, h->cstr.baseSeac);
        if (gid != -1)
            seacID[cSeacGlyphs++] = (unsigned short)gid;
    }

    if (h->cstr.accentSeac != 0)
    {
        gid = GetSeacGlyphID(h, h->cstr.accentSeac);
        if (gid != -1)
            seacID[cSeacGlyphs++] = (unsigned short)gid;
    }

    return cSeacGlyphs;
}

static void WriteCharstringDict(XCF_Handle h)
{
    char str[50];
    Card32 numberOfCharString;

    numberOfCharString = h->fontSet.charStrings.count;

    h->callbacks.xcfSprintf(str, CCHOF(str), "2 index /CharStrings %lu dict dup begin" XCF_NEW_LINE, (long unsigned int) numberOfCharString);
    PutString(h, str);
}

static void WriteCharstrings(XCF_Handle h, boolean flSeac,
                                   short cGlyphs, XCFGlyphID PTR_PREFIX *pGlyphID,
                                   unsigned char PTR_PREFIX **pGlyphName,
                   unsigned long PTR_PREFIX *pCharStrLength)
{
    IntX i;
    char str[50];
    Card8 PTR_PREFIX *pCharStr;
    Card16 charStrLength;
  boolean flDownload;
  boolean unprocessed;
  boolean flCompleteFont = 0;
  short glyphID;
    Card16 lenIVextraBytes;
  short totalGlyphs = cGlyphs;

  unprocessed = (h->options.outputCharstrType == 2);

  if (pCharStrLength && !flSeac)
    *pCharStrLength = 0;

  if (cGlyphs == -1)
  /* Check to see if the request is to download the entire font */
    {
        totalGlyphs = (short)h->fontSet.charStrings.count;
        flCompleteFont = 1;
    }

    lenIVextraBytes = (h->options.lenIV == -1) ? 0 : h->options.lenIV;
    for (i=0; i < totalGlyphs; i++)
    {
        glyphID = (short)((flCompleteFont) ? i : *pGlyphID);

        if (glyphID > (long)h->fontSet.charStrings.count)
            XCF_FATAL_ERROR(h, XCF_InvalidGID, "bad Glyph ID", glyphID);

        if (!flSeac)
            flDownload = (!IS_GLYPH_SENT(h->dl.glyphs, glyphID));
        else
        {
            flDownload = (h->options.dlOptions.useSpecialEncoding) ?
                                (!IS_GLYPH_SENT(h->dl.seacs, glyphID)) :
                                (!IS_GLYPH_SENT(h->dl.glyphs, glyphID));
        }

    if (flDownload)
    {
      PutString(h,"/");
        PutCharacterName(h, pGlyphName ? i : glyphID, pGlyphName);
      GetCharstring(h, glyphID, unprocessed, &pCharStr, &charStrLength);
      h->callbacks.xcfSprintf(str, CCHOF(str), " %lu -| ", (long unsigned int)
                                                     (charStrLength+lenIVextraBytes));

        PutString(h,str);
          PutType1CharString(h, pCharStr, charStrLength);
          PutString(h," |-" XCF_NEW_LINE);

      /* Set downloaded status for this glyph */
            if (!flSeac)
                SET_GLYPH_SENT_STATUS(h->dl.glyphs, glyphID);
            else
      {
            if (h->options.dlOptions.useSpecialEncoding)
                    SET_GLYPH_SENT_STATUS(h->dl.seacs, glyphID);
                else
                    SET_GLYPH_SENT_STATUS(h->dl.glyphs, glyphID);
            }

       if (pCharStrLength)
         *pCharStrLength += (unsigned long)charStrLength;

       /* Take care of seac characters .*/
       if (!flCompleteFont && !flSeac)
       {
         XCFGlyphID seacID[2];
         unsigned short cSeacGlyphs;

         cSeacGlyphs = GetSeacCharacters(h, (XCFGlyphID *)seacID);
         if (cSeacGlyphs)
         {
             /* Don't pass in the client's glyphName because:
                  1. We are downloading a seac's base or accent character.
                  2. The client uses a special encoding array that is not
                     derived from Adobe Standard Encoding (G00..GFF).
                     We need to use the real PS character name in this case.
              */
             WriteCharstrings(h, 1, cSeacGlyphs, seacID, 0, pCharStrLength);
         }
             }
      }
    if (!flCompleteFont)
      pGlyphID++;
    }
} /* end WriteCharstrings */

/*
xxx complete

  The following table shows the value types associated with various dict keys:

    Key                 Type
    ---                 ----
    WeightVector        Array
    isFixedPitch        Blend
*    ItalicAngle         Blend
*    UnderlinePosition   Blend
*    UnderlineThickness  Blend
    StrokeWidth         Blend
    BlendDesignMap      Array
    BlendAxisTypes      Array (of SIDs)
    XUID                Array
    BaseFontBlend       DeltaArray
*    BlueValues          BlendArray
*    OtherBlues          BlendArray
*    FamilyBlues         BlendArray
*    FamilyOtherBlues    BlendArray
*    BlueScale           Blend
*    BlueShift           Blend
*    BlueFuzz            Blend
*    StdHW               Blend
*    StdVW               Blend
*    StemSnapH           BlendArray
*    StemSnapV           BlendArray

  */

static void WritePrivateDict(XCF_Handle h, short cGlyphs,
                             XCFGlyphID PTR_PREFIX *pGlyphID,
                             unsigned char PTR_PREFIX **pGlyphName,
                             unsigned long PTR_PREFIX *pCharStrLength)
{
    char line[MAX_LINE_LENGTH];
  boolean  unprocessed = (h->options.outputCharstrType == 2);
  static XCFGlyphID notdefID = 0;

    /**** Start Private Dict ****/
    h->callbacks.xcfSprintf(line, CCHOF(line), "dup /Private %ld dict dup begin" XCF_NEW_LINE, (Card32) PrivateDictCount(h));
    PutString(h,line);
  if (h->options.hexEncoding && !h->options.eexecEncryption)
        PutString(h, "/-|{string currentfile exch readhexstring pop}executeonly def" XCF_NEW_LINE);
    else
      PutString(h, "/-|{string currentfile exch readstring pop}executeonly def" XCF_NEW_LINE);
    PutString(h, "/|-{" T1_NOACCESS "def}executeonly def" XCF_NEW_LINE);
    PutString(h, "/|{" T1_NOACCESS "put}executeonly def" XCF_NEW_LINE);

    /**** Write Private Dict ****/

  if (!StreamKeyPointData(h, XCF_UID))
      /* Duplicated from Font Dict */
        WriteLongNumberLine(h, "UniqueID", h->dict.uniqueID, h->dict.uniqueIDCount);
    if (!h->dict.blueValuesCount) /* Write BlueValues array if not present in cff */
        PutString(h, "/BlueValues [ ] |-" XCF_NEW_LINE);
    WriteBlendArrayLine(h, "BlueValues", h->dict.blueValues,
                                            h->dict.blueValuesCount, true, true, true, false);
    WriteBlendArrayLine(h, "OtherBlues", h->dict.otherBlues,
                                            h->dict.otherBluesCount, true, true, true, false);
    WriteBlendArrayLine(h, "FamilyBlues", h->dict.familyBlues,
                                            h->dict.familyBluesCount, true, true, true, false);
    WriteBlendArrayLine(h, "FamilyOtherBlues", h->dict.familyOtherBlues,
                                            h->dict.familyOtherBluesCount, true, true, true, false);

    WriteStemSnap(h, true);
    WriteBlendLine(h, "BlueScale", h->dict.blueScale, h->dict.blueScaleCount,
                                 true, true, true, true);
    WriteBlendLine(h, "BlueShift", h->dict.blueShift, h->dict.blueShiftCount,
                                 true, true, true, false);
    WriteBlendLine(h, "BlueFuzz", h->dict.blueFuzz, h->dict.blueFuzzCount, true,
                                 true, true, false);
    WriteBlendBooleanLine(h, "ForceBold", h->dict.forceBold, h->dict.forceBoldCount, true, h->dict.forceBoldThreshold);
    WriteNumberLine(h, "ForceBoldThreshold", h->dict.forceBoldThreshold,
                                    h->dict.forceBoldThresholdCount, false);
    if ((h->dict.languageGroupCount) && (h->dict.languageGroup == 1))
        PutString(h, "/RndStemUp false def" XCF_NEW_LINE);
    WriteLongNumberLine(h, "LanguageGroup", h->dict.languageGroup,
                                    h->dict.languageGroupCount);
    WriteNumberLine(h, "ExpansionFactor", h->dict.expansionFactor,
                                    h->dict.expansionFactorCount, true);
    WriteNumberLine(h, "initialRandomSeed", h->dict.initialRandomSeed,
                                    h->dict.initialRandomSeedCount, false);
    if (unprocessed)
    {
        WriteNumberLine(h, "defaultWidthX", h->dict.defaultWidthX,
                                        h->dict.defaultWidthXCount, false);
        WriteNumberLine(h, "nominalWidthX", h->dict.nominalWidthX,
                                        h->dict.nominalWidthXCount, false);
    /* Need to account for the NDV and CDV subrs in mmfonts. */
    if (h->dict.localSubrs.count > 0)
      WriteLongNumberLine(h, "subroutineNumberBias", h->dict.numberOfMasters ?
                        XCF_CalculateSubrBias(h->dict.localSubrs.count + 2) : h->dict.localSubrBias, 1);
    }
    if (h->dict.fontType == 2)
        WriteLongNumberLine(h, "lenIV", h->options.lenIV, 1);
    else if ((h->dict.fontType == 1) && (h->options.outputCharstrType == 1))
        WriteLongNumberLine(h, "lenIV", h->dict.lenIV, h->dict.lenIVCount);

    if (h->dict.numberOfMasters > 0)
  { /* Write out ndv, cdv and include as subroutines. */
    Card32 subrNum = unprocessed ? h->dict.localSubrs.count:
            h->type1.subrOffsets.cnt;
    WriteLongNumberLine(h, "NDV", subrNum, 1);
    WriteLongNumberLine(h, "CDV", subrNum + 1, 1);
    if (h->options.outputCharstrType == 1)
      XC_DVToSubr(h);
  }

  WriteLongNumberLine(h, "lenBuildCharArray", h->dict.lenBuildCharArray,
                                    h->dict.lenBuildCharArrayCount);
  if (h->dict.lenBuildCharArrayCount)
    PutString(h, "/BuildCharArray lenBuildCharArray array def" XCF_NEW_LINE);
    PutString(h, "/MinFeature {16 16} def" XCF_NEW_LINE);
    PutString(h, "/password 5839 def" XCF_NEW_LINE);
    WriteErode(h, true);
    WritePrivateBlendDict(h);

    if (h->dict.embeddedPostscriptCount)
    {
        PutStringID(h, (StringID)h->dict.embeddedPostscript);
        PutString(h, XCF_NEW_LINE);
    }

    WriteOtherSubrs(h, h->cstr.flexUsed, (h->type1.subrOffsets.cnt > 5));
    WriteSubrs(h, (h->options.outputCharstrType == 2));
  WriteCharstringDict(h);

  if (cGlyphs != -1)
    /* Always download the .notdef character. */
    WriteCharstrings(h, 0, 1, &notdefID, 0, pCharStrLength);

  WriteCharstrings(h, 0, cGlyphs, pGlyphID, pGlyphName, pCharStrLength);

    /* Flag -- Add support for

        NDV
        CDV
  */
}

static void T1Init(XCF_Handle h)
{
    h->outBuffer.eexecOn = false;
}

/* Called for each dict in the FDArray of a CIDFont. */
void XT1_WriteCIDDict(XCF_Handle h, Card16 fd, Card32 subrMapOffset, Card16 subrCount)
    {
    char line[MAX_LINE_LENGTH];

    h->callbacks.xcfSprintf(line, CCHOF(line), "dup %d" XCF_NEW_LINE, fd);
    PutLine(h,line);

    PutLine(h,"%ADOBeginFontDict");
    h->callbacks.xcfSprintf(line, CCHOF(line),
        "%ld dict" XCF_NEW_LINE "begin",
        (Card32)FontDictCount(h) /* xxx wrong number? */);
    PutLine(h,line);

    if (h->dict.fdFontNameCount)
    {
        PutString(h, "/FontName /");
        PutStringID(h, (StringID)h->dict.fdFontName);
        PutLine(h, " def");
    }
    WriteLongNumberLine(h, "FontType", h->options.outputCharstrType, 1);
    WriteFontMatrix(h, "FontMatrix", h->dict.fontMatrix, h->dict.fontMatrixCount);
    WriteNumberLine(h, "PaintType", h->dict.paintType, h->dict.paintTypeCount, false);

    PutLine(h,XCF_NEW_LINE "%ADOBeginPrivateDict");
    h->callbacks.xcfSprintf(line, CCHOF(line),
        "/Private %ld dict dup" XCF_NEW_LINE "begin",
        (Card32)PrivateDictCount(h) /* xxx wrong number? */);
    PutLine(h,line);

    PutLine(h, "/MinFeature {16 16} def");
    /* xxx deal with lenIV output */
    if ((h->dict.fontType == 2) && (h->options.outputCharstrType == 1))
        WriteLongNumberLine(h, "lenIV", h->options.lenIV, 1);
    else if ((h->dict.fontType == 2) && (h->options.outputCharstrType == 2))
        WriteLongNumberLine(h, "lenIV", -1, 1);
    else if ((h->dict.fontType == 1) && (h->options.outputCharstrType == 1))
        WriteLongNumberLine(h, "lenIV", h->dict.lenIV, h->dict.lenIVCount);
#ifdef T13
  else
    XT13_WritePrivDictValues(h);
#endif
    WriteLongNumberLine(h, "LanguageGroup", h->dict.languageGroup,
                                    h->dict.languageGroupCount);
    if ((h->dict.languageGroupCount) && (h->dict.languageGroup == 1))
        PutString(h, "/RndStemUp false def" XCF_NEW_LINE);
  if ((h->dict.fontType == 2) && (h->options.outputCharstrType == 2))
  {
    WriteNumberLine(h, "defaultWidthX", h->dict.defaultWidthX,
                                        h->dict.defaultWidthXCount, false);
        WriteNumberLine(h, "nominalWidthX", h->dict.nominalWidthX,
                                        h->dict.nominalWidthXCount, false);
  }
    if (!h->dict.blueValuesCount) /* Write BlueValues array if not present in cff */
        PutString(h, "/BlueValues [ ] def" XCF_NEW_LINE);
    WriteBlendArrayLine(h, "BlueValues", h->dict.blueValues,
                                            h->dict.blueValuesCount, true, true, true, false);
    WriteBlendArrayLine(h, "OtherBlues", h->dict.otherBlues,
                                            h->dict.otherBluesCount, true, true, true, false);
    WriteBlendLine(h, "BlueScale", h->dict.blueScale, h->dict.blueScaleCount,
                                 true, true, true, true);
    WriteBlendLine(h, "BlueShift", h->dict.blueShift, h->dict.blueShiftCount,
                                 true, true, true, false);
    WriteBlendLine(h, "BlueFuzz", h->dict.blueFuzz, h->dict.blueFuzzCount, true,
                                 true, true, false);
    WriteStemSnap(h, true);
    WriteCIDOtherSubrs(h);
    WriteErode(h, true);
    PutLine(h, XCF_NEW_LINE "/password 5839 def" XCF_NEW_LINE);
  if (subrCount)
    {
    h->callbacks.xcfSprintf(line, CCHOF(line), "/SubrMapOffset %d def", subrMapOffset);
    PutLine(h,line);
    PutLine(h, "/SDBytes 4 def");
    h->callbacks.xcfSprintf(line, CCHOF(line), "/SubrCount %d def", subrCount);
    PutLine(h,line);
  }

    PutLine(h, "end def" XCF_NEW_LINE
            "%ADOEndPrivateDict" XCF_NEW_LINE XCF_NEW_LINE
            "currentdict" XCF_NEW_LINE
            "end" XCF_NEW_LINE
            "%ADOEndFontDict" XCF_NEW_LINE XCF_NEW_LINE
            "put");
    }

/* Write top-level dict, up to FDArray */
#define MAX_FONTNAME_LENGTH 128
void XT1_WriteCIDTop(XCF_Handle h)
    {
    char line[MAX_LINE_LENGTH];
    char fontName[MAX_FONTNAME_LENGTH];

    T1Init(h);

    PutLine(h, "%!PS-Adobe-3.0 Resource-CIDFont");
    PutLine(h, "%%DocumentNeededResources: ProcSet (CIDInit)");
    PutLine(h, "%%IncludeResource: ProcSet (CIDInit)");

    /* FontName */
  if (!h->options.dlOptions.fontName)
  {
      Card16 length = sizeof(fontName) - 1;
      XCF_LookUpTableEntry(h, &h->fontSet.fontNames, h->fontSet.fontIndex);
      if ((Card16)h->inBuffer.blockLength < length)
          length = (Card16)h->inBuffer.blockLength;
      h->callbacks.memcpy(fontName, (Card8 PTR_PREFIX *)h->inBuffer.start, length);
      fontName[length] = '\0';
  }
  else
  {
    Card16 length = h->callbacks.strlen((char PTR_PREFIX *)h->options.dlOptions.fontName);
    if (length > (sizeof(fontName) - 1))
        length = sizeof(fontName) - 1;
    h->callbacks.memcpy(fontName, h->options.dlOptions.fontName, length);
    fontName[length] = '\0';
    }
    h->callbacks.xcfSprintf(line, CCHOF(line), "%%%%BeginResource: CIDFont (%s)", fontName);
    PutLine(h,line);

    /* Title */
    PutString(h, "%%Title: (");
    PutStringID(h, (StringID) h->dict.fullName);
    PutString(h, " ");
    PutStringID(h, (StringID) h->dict.ROS[0]);
    PutString(h, " ");
    PutStringID(h, (StringID) h->dict.ROS[1]);
    PutString(h, " ");
    PutLongNumber(h, h->dict.ROS[2]);
    PutLine(h, ")");

    /* Version */
    h->callbacks.xcfSprintf(line, CCHOF(line), "%%%%Version: %s", h->dict.cidFontVersion);
    PutLine(h,line);

    PutLine(h, XCF_NEW_LINE "/CIDInit /ProcSet findresource begin" XCF_NEW_LINE);

    PutLine(h, "20 dict begin" XCF_NEW_LINE);

    h->callbacks.xcfSprintf(line, CCHOF(line), "/CIDFontName /%s def", fontName);
    PutLine(h,line);
  if (h->dict.cidFontVersionCount > 0)
  {
      h->callbacks.xcfSprintf(line, CCHOF(line), "/CIDFontVersion %s def", h->dict.cidFontVersion);
      PutLine(h,line);
  }
    WriteLongNumberLine(h, "CIDFontType", h->dict.cidFontType,
                                    h->dict.cidFontTypeCount);

    PutLine(h, XCF_NEW_LINE "/CIDSystemInfo 3 dict dup begin");
    WriteSIDLine(h, "Registry", h->dict.ROS[0], h->dict.ROSCount);
    WriteSIDLine(h, "Ordering", h->dict.ROS[1], h->dict.ROSCount);
    WriteLongNumberLine(h, "Supplement", h->dict.ROS[2], h->dict.ROSCount);
    PutLine(h, "end def" XCF_NEW_LINE);

    WriteNumberListLine(h, "FontBBox", h->dict.fontBBox, h->dict.fontBBoxCount, false);
    PutString(h, XCF_NEW_LINE);

    // JJIA: fix bug 366539. Added Metrics2 for vertical printing.
    PutLine(h, "/Metrics2 16 dict def" XCF_NEW_LINE);
    PutLine(h, "/CDevProc {pop 4 index add} bind def" XCF_NEW_LINE);

  if ( h->options.uniqueIDMethod != XCF_UNDEFINE_UID )
  {
      WriteLongNumberLine(h, "UIDBase", h->dict.uidBase, h->dict.uidBaseCount);
      WriteLongNumberListLine(h, "XUID", h->dict.xUID, h->dict.xUIDCount);
  }

    PutLine(h, XCF_NEW_LINE "/FontInfo 3 dict dup begin");
    WriteSIDLine(h, "Notice", h->dict.notice, h->dict.noticeCount);
    WriteSIDLine(h, "FullName", h->dict.fullName, h->dict.fullNameCount);
    if (h->callbacks.getFSType)
    {
        long fsType;

        h->callbacks.getFSType(h, &fsType, h->callbacks.getFSTypeHook);
        if (fsType != -1)
            WriteLongNumberLine(h, "FSType", fsType, 1);
    }

    // GOODNAME
    if (h->callbacks.isKnownROS)
    {
        long knownROS;
        char PTR_PREFIX *R;
        Card16 lenR;
        char PTR_PREFIX *O;
        Card16 lenO;

        XCF_LookUpString(h, (StringID) h->dict.ROS[0], &R, &lenR);
        XCF_LookUpString(h, (StringID) h->dict.ROS[1], &O, &lenO);
        h->callbacks.isKnownROS(h, &knownROS,
            R, lenR,
            O, lenO,
            h->dict.ROS[2],
            h->callbacks.isKnownROSHook);
        if (knownROS == 0)
        {
            PutLine(h, "/GlyphNames2Unicode 16 dict def");
            PutLine(h, "/GlyphNames2HostCode 16 dict def");
        }
    }

    PutLine(h,
        "end" T1_READONLY " def" XCF_NEW_LINE XCF_NEW_LINE
        "/CIDMapOffset 0 def" XCF_NEW_LINE XCF_NEW_LINE
        "/GDBytes 4 def");
    h->callbacks.xcfSprintf(line, CCHOF(line), "/FDBytes %s def", (h->type1.cid.fdCount > 1 ? "1" : "0"));
    PutLine(h,line);

#ifdef T13
  XT13_WriteSetup(h);
#endif

    WriteLongNumberLine(h, "CIDCount", h->dict.cidCount, h->dict.cidCountCount);
    h->type1.cid.cidCount = (Card32) h->dict.cidCount;
    h->callbacks.xcfSprintf(line, CCHOF(line), XCF_NEW_LINE "/FDArray %d array", h->type1.cid.fdCount);
    PutLine(h,line);
    }

static Card16 CalculateTotalSubrLength(XCF_Handle h, boolean unprocessed)
{
  Card16 subrLength = 0;
  Card8 PTR_PREFIX *pSubr;
  Card16 len;
  Card16 fd;
  Card16 lenIVextraBytes;
  CardX i;
  Card32 numberOfSubrs;

  lenIVextraBytes = (h->options.lenIV == -1) ? 0 : h->options.lenIV;
  for (fd = 0; fd < h->type1.cid.fdCount; fd++)
  {
    h->dict.localSubrs = h->type1.cid.localSubrs[fd];
    h->dict.localSubrBias =  h->type1.cid.localSubrBias[fd];
    numberOfSubrs = unprocessed ? h->dict.localSubrs.count :
      h->type1.subrOffsets.cnt - 1;
    subrLength += (Card16)(lenIVextraBytes * numberOfSubrs);
    for (i = 0; i < numberOfSubrs; ++i)
    {
      GetSubr(h, i, unprocessed, &pSubr, &len);
          subrLength += len;
    }
  }
  return subrLength;
}

/* Totals the number of local subrs in each font dictionary. */
static Card16 TotalLocalSubrCount(XCF_Handle h)
{
  Card16 fd;
  Card16 total = 0;

  if (CIDFONT)
  {
    for (fd = 0; fd < h->type1.cid.fdCount; fd++)
      total += (Card16)h->type1.cid.localSubrs[fd].count;
  }
  else
    total = (Card16)h->dict.localSubrs.count;

  return total;
}

/* Write the binary section for a VM resident CIDFont. In this case
   the binary section only contains the SubrMap and subr data.
   For now only the standard subrs are written out. */
void XT1_WriteCIDVMBinarySection(XCF_Handle h)
{
  boolean unprocessed = (h->options.outputCharstrType == 2);
  Card16 subrLength = CalculateTotalSubrLength(h, unprocessed);
  Card16 subrMapLength;
  Card16 fd;
  Card32 totalLen;
  char str[MAX_LINE_LENGTH];

  /* The SubrMap length is the SDBytes value which currently is always 4. */
  subrMapLength = (Card16)(unprocessed ? TotalLocalSubrCount(h) * 4 : ((h->type1.subrOffsets.cnt * 4) * h->type1.cid.fdCount));
  totalLen = subrLength + subrMapLength;

    PutString(h, "%%BeginData: ");
  if (h->options.hexEncoding)
  {
    /* totalLen * 2 - double the data size because it's hex
       25 - to account for (Hex) ... StartData
        2 - for the > to end hex data and newline
     */
    h->callbacks.xcfSprintf(str, CCHOF(str), "%8ld Binary Bytes%s", (Card32)(totalLen * 2) + 25 + ((subrLength > 0) ? 2 : 0), XCF_NEW_LINE);
    PutString(h, str);
    h->callbacks.xcfSprintf(str, CCHOF(str), "(Hex) %8ld StartData%s", (Card32)totalLen, XCF_NEW_LINE);
    PutString(h, str);
  }
  else /* binary */
  {
    /* The extra 28 bytes is to account for (Binary) ... StartData */
    h->callbacks.xcfSprintf(str, CCHOF(str), "%8ld Binary Bytes", (Card32)totalLen + 28);
    PutString(h, str);
    PutString(h, XCF_NEW_LINE);
    h->callbacks.xcfSprintf(str, CCHOF(str), "(Binary) %8ld StartData ", (Card32)totalLen);
    PutString(h, str);
  }
  if (subrLength != 0)
  {
    h->type1.cid.flags |= WRITE_SUBR_FLAG;
    for (fd = 0; fd < h->type1.cid.fdCount; ++fd)
      XT1_CIDWriteSubrMap(h, fd);
    for (fd = 0; fd < h->type1.cid.fdCount; ++fd)
      XT1_CIDWriteSubrs(h, fd);
    h->type1.cid.flags &= 0xFFFD; /* Reset WriteSubr flag */
  }
  if (h->options.hexEncoding && (subrLength > 0))
    PutString(h, ">" XCF_NEW_LINE); /* indicate end of hex data */
  PutString(h, "%%EndData" XCF_NEW_LINE "%%EndResource" XCF_NEW_LINE);
}

void XT1_CIDBeginBinarySection(XCF_Handle h)
    {
    Card16 i;

    PutString(h, "%%BeginData: ");
    h->type1.cid.replaceSD1 = XCF_OutputPos(h);
    PutLine(h, "12345678 Binary Bytes");
  if (h->options.hexEncoding)
    PutString(h, "(Hex) ");
  else
    PutString(h, "(Binary) ");
    h->type1.cid.replaceSD2 = XCF_OutputPos(h);
    PutString(h, "12345678 StartData ");
    h->type1.cid.charMapStart = XCF_OutputPos(h);

    /* put placeholders for the charmap */
    /* The +1 is for the final interval */
    for (i = 0 ; i < h->type1.cid.cidCount + 1 ; ++i)
  {
    if (h->type1.cid.cidCount > 1)
          XT1_PutT1Data(h, (Card8 *)"chars", 5); /* If GD or FDBytes changes this
                                                                                         can change. */
    else
      XT1_PutT1Data(h, (Card8 *)"char", 4);
    }
    h->type1.cid.subrMapStart = XCF_OutputPos(h);
    /* before this was missing the offset of the start of the binary data */
    h->type1.cid.subrDataStart += h->type1.cid.charMapStart;
    }

void XT1_CIDEndBinarySection(XCF_Handle h)
    {
    char line[MAX_LINE_LENGTH];
    Card32 charOffset = h->type1.cid.charDataStart - h->type1.cid.charMapStart;
    XCF_SetOuputPosition(h, h->type1.cid.replaceSD1);
  h->callbacks.xcfSprintf(line, CCHOF(line), "%8ld",
          charOffset + h->type1.cid.charDataCount + h->type1.cid.replaceSD2 - h->type1.cid.replaceSD1);
    PutString(h, line);
    XCF_SetOuputPosition(h, h->type1.cid.replaceSD2);
    h->callbacks.xcfSprintf(line, CCHOF(line), "%8ld", charOffset + h->type1.cid.charDataCount);
    PutString(h, line);
  XCF_SetOuputPosition(h, h->type1.cid.charDataEnd);
  if (h->options.hexEncoding)
    PutString(h, ">" XCF_NEW_LINE);
  PutString(h, "%%EndData" XCF_NEW_LINE "%%EndResource" XCF_NEW_LINE);
    }

void XT1_CIDWriteCharMap(XCF_Handle h)
    {
    Card16 i;
    Card32 charOffset = h->type1.cid.charDataStart - h->type1.cid.charMapStart;
    CardX interval;
    StringID *charset = h->type1.pCharset;
  char fdBytes = (h->type1.cid.fdCount > 1 ? 1 : 0);

    XCF_SetOuputPosition(h, h->type1.cid.charMapStart);

    /* Output the notdef character, which is always required. */
  if (fdBytes)
      PutSizedNumber(h, XCF_GetFDIndex(h, 0), 1);   /* xxx will change if FDBytes changes! */
    PutSizedNumber(h, charOffset, 4);   /* xxx will change if GDBytes changes! */

  /* Write out any empty intervals between 0 and charset[0]. */
  for (i = 1; i < charset[0]; i++)
  {
     if (fdBytes)
       PutSizedNumber(h, 255, 1);
     PutSizedNumber(h, charOffset + h->type1.charStrOffsets.array[0], 4);
  }

  /* The charset array does not include the notdef character, but the
     FDIndex array does include the notdef character. */
  for (i = 0; i < h->type1.charsetSize; i++)
  {
    if (fdBytes)
      PutSizedNumber(h, XCF_GetFDIndex(h, i+1), 1);
    PutSizedNumber(h, charOffset + h->type1.charStrOffsets.array[i], 4);
    if (i + 1 < h->type1.charsetSize)
      for (interval = charset[i] + 1; interval < charset[i+1]; interval++)
      { /* Write empty interval */
        if (fdBytes)
          PutSizedNumber(h, 255, 1);
        PutSizedNumber(h, charOffset + h->type1.charStrOffsets.array[i+1], 4);
      }
  }
  /* Put ending location, and fill out to end of table. */
  for (interval = charset[i-1]; interval < h->type1.cid.cidCount; interval++)
  {
    if (fdBytes)
      PutSizedNumber(h, 255, 1);
    PutSizedNumber(h, charOffset + h->type1.charStrOffsets.array[i], 4);
  }
}

/* Write the prolog for a CIDFont in VM when the initial font is created. */
static void WriteCIDBaseFontProlog(XCF_Handle h)
{
#if HAS_COOLTYPE_UFL == 1
    /* In CoolType the GlyphDirectory procedures are stored in a dictionary,
       ct_GlyphDirProcs, that is downloaded once by the client in a procset.
     */
    PutString(h, "ct_GlyphDirProcs begin" XCF_NEW_LINE);
#endif
  PutString(h, "GlyphDirectory" XCF_NEW_LINE);
#if HAS_COOLTYPE_UFL == 1
    PutString(h, "+" XCF_NEW_LINE);
#else
  PutString(h, "5 dict begin/$ exch def/? $ type/dicttype eq def/|{?{def}{$ 3 1 roll put}" XCF_NEW_LINE);
  PutString(h, "ifelse}bind def/!{?{end}if end}bind def/:{string currentfile exch readstring" XCF_NEW_LINE);
  PutString(h, "pop}executeonly def ?{$ begin}if" XCF_NEW_LINE);
#endif
}

/* Write the prolog for a CIDFont in VM when incrementally adding glyphs. */
static void WriteGlyphDictProlog(XCF_Handle h, short cGlyphs)
{
  char str[MAX_LINE_LENGTH];

#if HAS_COOLTYPE_UFL == 1
  /* Put these dicts on the stack so the correct findresource call is made and
     the GlyphDirectory procedures are defined. */
  PutString(h, "ct_Dict begin ct_MakeOCF begin ct_GlyphDirProcs begin" XCF_NEW_LINE);
#endif

  PutString(h, "/");
  PutFontName(h);
  h->callbacks.xcfSprintf(str, CCHOF(str), " %ld%s", (long int)cGlyphs, XCF_NEW_LINE);
  PutString(h, str);
#if HAS_COOLTYPE_UFL == 1
  PutString(h, "GetGlyphDirectory" XCF_NEW_LINE);
#else
  PutString(h, "systemdict/languagelevel known not{1 index/CIDFont findresource/GlyphDirectory" XCF_NEW_LINE);
  PutString(h, "get dup type/dicttype eq{dup dup maxlength exch length sub 2 index lt{dup" XCF_NEW_LINE);
  PutString(h, "length 2 index add dict copy 2 index/CIDFont findresource/GlyphDirectory 2" XCF_NEW_LINE);
  PutString(h, "index put}if}if exch pop exch pop}{pop/CIDFont findresource/GlyphDirectory get" XCF_NEW_LINE);
  PutString(h, "}ifelse 5 dict begin/$ exch def/? $ type/dicttype eq def/|{?{def}{$ 3 1 roll" XCF_NEW_LINE);
  PutString(h, "put}ifelse}bind def/!{?{end}if end}bind def/:{string currentfile exch" XCF_NEW_LINE);
  PutString(h, "readstring pop}executeonly def ?{$ begin}if" XCF_NEW_LINE);
#endif
}

static void WriteOneGlyphDictEntry(XCF_Handle h, XCFGlyphID glyphID, unsigned
                                                                     long PTR_PREFIX *pCharStrLength)
{
  char line[MAX_LINE_LENGTH];
  Card8 fd = 0;
  Card16 charStrLength = 0;
  Card8 PTR_PREFIX *pCharStr;
  Card16 fdIndexLen = (h->type1.cid.fdCount > 1) ? 1 : 0;
  Card16 id;
  Card16 lenIVextraBytes = (h->options.lenIV == -1) ? 0 : h->options.lenIV;

  if (h->callbacks.getCharStr == 0)
  {
    if (h->options.outputCharstrType != 2)
      ProcessOneCharString(h, (unsigned int)glyphID);
    else
      /* So GetCIDCharString gets the string from the charstr table. */
      h->type1.charStrs.cnt = glyphID;

    GetCIDCharString(h, &pCharStr, &charStrLength);

    id = glyphID ? h->type1.pCharset[glyphID-1] : 0;

  }
  else
  {
    h->callbacks.getCharStr((XFhandle)h, glyphID, &pCharStr, &charStrLength,
                            &fd, h->callbacks.getCharStrHook);
    id = (Card16) glyphID; /* In this case glyphID == cid. */
  }

  if (h->options.hexEncoding)
    h->callbacks.xcfSprintf(line, CCHOF(line), "%d <", id);
  else
    /* If FDBytes is variable then the amt to add to charStrLength changes. */
    h->callbacks.xcfSprintf(line, CCHOF(line), "%d %d : ", id, (charStrLength + fdIndexLen + lenIVextraBytes));
  XCF_PutData(h, (Card8 PTR_PREFIX *)line, h->callbacks.strlen(line));
  /* If there is more than one value in the FDArray then the first
     byte in the charstring must be the FD index. */
  if (h->type1.cid.fdCount > 1)
  {
    /* According to the spec the index byte must not be encrypted. */
    if (h->callbacks.getCharStr == 0)
      fd = XCF_GetFDIndex(h, glyphID);
    if (h->options.hexEncoding)
      h->callbacks.xcfSprintf(line, CCHOF(line), "%02X", (int)fd);
    else
      h->callbacks.xcfSprintf(line, CCHOF(line), "%c", fd);
    XCF_PutData(h, (Card8 PTR_PREFIX *)line, h->callbacks.strlen(line));
  }
  PutType1CharString(h, pCharStr, charStrLength);
  if (h->options.hexEncoding)
    PutString(h, ">");
  PutString(h, " |" XCF_NEW_LINE);
  SET_GLYPH_SENT_STATUS(h->dl.glyphs, glyphID);
  if (pCharStrLength)
    *pCharStrLength += (unsigned long)charStrLength;
}

/* Creates the GlyphDirectory dictionary for VM resident CIDFonts.
   Hex and binary encoding is supported. The client is responsible
   for knowing whether the download channel supports binary data. */
void XT1_WriteGlyphDictEntries(XCF_Handle h, short cGlyphs,
                                                XCFGlyphID PTR_PREFIX *pGlyphID,
                                unsigned long PTR_PREFIX *pCharStrLength)
{
  IntX i;
  char line[MAX_LINE_LENGTH];
  short totalGlyphs;
  long glyphID;
  boolean dlEntireFont = cGlyphs == -1 ? 1 : 0;

  if (pCharStrLength)
    *pCharStrLength = 0;

  totalGlyphs = dlEntireFont ? h->fontSet.charStrings.count : cGlyphs;

  if (h->dl.state == XCF_DL_INIT)
  {
    /* Add one to the total to make sure the .notdef character is included. */
    h->callbacks.xcfSprintf(line, CCHOF(line), "/GlyphDirectory %d dict def", dlEntireFont ?
                                                 totalGlyphs : totalGlyphs + 1);
    PutLine(h, line);
    WriteCIDBaseFontProlog(h);
    /* Ensure the .notdef character is included. */
    if (!dlEntireFont)
      WriteOneGlyphDictEntry(h, 0, pCharStrLength);
  }
  for (i = 0; i < totalGlyphs; i++)
  {
    glyphID = dlEntireFont ? i : *pGlyphID;
    if (glyphID > (long)h->fontSet.charStrings.count)
            XCF_FATAL_ERROR(h, XCF_InvalidGID, "bad Glyph ID", glyphID);
    if (!IS_GLYPH_SENT(h->dl.glyphs, glyphID))
      WriteOneGlyphDictEntry(h, glyphID, pCharStrLength);
    if (!dlEntireFont)
      pGlyphID++;
  }
  PutString(h, "!" XCF_NEW_LINE); /* ! is the name of the cleanup proc. */

#if HAS_COOLTYPE_UFL == 1
  if (h->dl.state != XCF_DL_INIT)
      PutString(h, "end end end" XCF_NEW_LINE); /* end for ct_Dict, ct_MakeOCF, ct_GlyphDirProcs */
  else
      PutString(h, "end" XCF_NEW_LINE); /* end for ct_GlyphDirProcs */
#endif
}

void XT1_WriteAdditionalGlyphDictEntries(XCF_Handle h,
    short cGlyphs, XCFGlyphID PTR_PREFIX *pGlyphID,
    unsigned long PTR_PREFIX *pCharStrLength)
{
  WriteGlyphDictProlog(h, cGlyphs);
  XT1_WriteGlyphDictEntries(h, cGlyphs, pGlyphID, pCharStrLength);
}

void XT1_WriteT1Font(XCF_Handle h)
{
    IntX i;

    T1Init(h);
    WriteFontDict(h);
    if (h->options.eexecEncryption)
        StartEexec(h);
    WritePrivateDict(h, -1, 0, 0, 0);
    PutString(h, "end" XCF_NEW_LINE "end" XCF_NEW_LINE T1_READONLY "put" XCF_NEW_LINE T1_NOACCESS "put" XCF_NEW_LINE "dup/FontName get exch definefont pop" XCF_NEW_LINE);
    if (h->options.eexecEncryption)
    {
        PutString(h, "mark currentfile closefile\n");   /* must be terminated with line feed (\n) only */
        StopEexec(h);
        PutString(h, XCF_NEW_LINE);
        for (i=1;i<=8;++i)
            PutString(h, "0000000000000000000000000000000000000000000000000000000000000000" XCF_NEW_LINE);
        PutString(h,"cleartomark" XCF_NEW_LINE);
    }
}

void XT1_WriteFontSubset(XCF_Handle h, short cGlyphs,
                                                XCFGlyphID PTR_PREFIX *pGlyphID,
                                                unsigned char PTR_PREFIX **pGlyphName,
                                unsigned long PTR_PREFIX *pCharStrLength)
{
    IntX i;

    T1Init(h);

    WriteFontDict(h);
    if (h->options.eexecEncryption)
        StartEexec(h);
    else
        PutString(h, "systemdict begin" XCF_NEW_LINE);
    WritePrivateDict(h, cGlyphs, pGlyphID, pGlyphName, pCharStrLength);
    PutString(h, "end" XCF_NEW_LINE "end" XCF_NEW_LINE T1_READONLY "put" XCF_NEW_LINE T1_NOACCESS "put" XCF_NEW_LINE "dup/FontName get exch definefont pop" XCF_NEW_LINE);
    if (h->options.eexecEncryption)
    {
        PutString(h, "mark currentfile closefile\n");   /* must be terminated with line feed only */
        StopEexec(h);
        PutString(h, XCF_NEW_LINE);
        for (i=1;i<=8;++i)
            PutString(h, "0000000000000000000000000000000000000000000000000000000000000000" XCF_NEW_LINE);
        PutString(h,"cleartomark" XCF_NEW_LINE);
    }
    else
        PutString(h, "end" XCF_NEW_LINE);       /* "end" for systemdict begin */
}

static void WriteAdditionalProlog(XCF_Handle h)
{
  if (h->options.eexecEncryption)
    StopEexec(h);
  PutString(h, "" XCF_NEW_LINE);
  PutString(h, "" XCF_NEW_LINE);
  if (h->options.eexecEncryption)
    StartEexec(h);
  else /* eexec makes the systemdict current.  When encryption is off this
          must be done explicitly. */
        PutString(h, "systemdict begin" XCF_NEW_LINE);
    PutString(h, "/");
    PutFontName(h);
    PutString(h, " findfont dup" XCF_NEW_LINE);
    PutString(h, "/Private get dup rcheck" XCF_NEW_LINE);
    PutString(h, "{begin true}{pop false}ifelse exch" XCF_NEW_LINE);
    PutString(h, "/CharStrings get begin" XCF_NEW_LINE);
}

static void WriteAdditionalEpilog(XCF_Handle h)
{
    int i;

    PutString(h, "end {end}if" XCF_NEW_LINE); /* end of the charstrings */
    if (h->options.eexecEncryption)
  {
        PutString(h, "mark currentfile closefile\n"); /* must be terminated with
                                                                                                         line feed only */
        StopEexec(h);
        PutString(h, ""XCF_NEW_LINE);
        for(i = 0;i < 8;i++)
            PutString(h, "0000000000000000000000000000000000000000000000000000000000000000" XCF_NEW_LINE);
        PutString(h, "cleartomark" XCF_NEW_LINE);
    }
    else
        PutString(h, "end" XCF_NEW_LINE);       /* "end" for systemdict begin */
}

void XT1_WriteAdditionalFontSubset(XCF_Handle h,
                                          short cGlyphs, XCFGlyphID PTR_PREFIX *pGlyphID,
                                          unsigned char PTR_PREFIX **pGlyphName,
                                          unsigned long PTR_PREFIX *pCharStrLength)
{
    WriteAdditionalProlog(h);
    WriteCharstrings(h, 0, cGlyphs, pGlyphID, pGlyphName, pCharStrLength);
    WriteAdditionalEpilog(h);
}

void XT1_ShowHexString(XCF_Handle h,
                              unsigned char PTR_PREFIX *hexString,
                              boolean showCtrlD)
{
    short i, j;
    char str[50];
    boolean done = false;

    PutString(h, "/inch {72 mul} def" XCF_NEW_LINE);
    PutString(h, "/");
    PutFontName(h);
    PutString(h, " findfont" XCF_NEW_LINE);
    PutString(h, "0.5 inch scalefont" XCF_NEW_LINE);
    PutString(h, "setfont" XCF_NEW_LINE);
    for ( i = 0; !done; i++)
    {
        h->callbacks.xcfSprintf(str, CCHOF(str), "%s0.5 inch %d inch moveto%s", XCF_NEW_LINE,
                         10 - i, XCF_NEW_LINE );
        PutString(h, str);
        PutString(h, "<");
        for (j = 0; j <= 40;)
        {
            str[j++] = *hexString++;
            str[j++] = *hexString++;
            if (*hexString == '\0')
            {
                done = true;
                break;
            }
        }
        str[j] = '\0';
        PutString(h, str);
        PutString(h, "> show " XCF_NEW_LINE);
        if (i > 9)
        {
            i = -1;
            PutString(h, "showpage" XCF_NEW_LINE);
        }
    }
    PutString(h, "showpage" XCF_NEW_LINE);

    if (showCtrlD)
        PutString(h, "\004");
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\lib\xcf\xcf_txop.h ===
/* @(#)CM_VerSion xcf_txop.h atm08 1.3 16293.eco sum= 17208 atm08.004 */
/***********************************************************************/
/*                                                                     */
/* Copyright 1990-1995 Adobe Systems Incorporated.                     */
/* All rights reserved.                                                */
/*                                                                     */
/* Patents Pending                                                     */
/*                                                                     */
/* NOTICE: All information contained herein is the property of Adobe   */
/* Systems Incorporated. Many of the intellectual and technical        */
/* concepts contained herein are proprietary to Adobe, are protected   */
/* as trade secrets, and are made available only to Adobe licensees    */
/* for their internal use. Any reproduction or dissemination of this   */
/* software is strictly forbidden unless prior written permission is   */
/* obtained from Adobe.                                                */
/*                                                                     */
/* PostScript and Display PostScript are trademarks of Adobe Systems   */
/* Incorporated or its subsidiaries and may be registered in certain   */
/* jurisdictions.                                                      */
/*                                                                     */
/***********************************************************************/

/*
 * Type 1 and 2 charstring operators.
 *
 * The Type 2 operator set was derived from the Type 1 set by the removal of
 * some old operators and the addition of new operators. In some cases the 
 * functionality of retained operators has also been extended by utilizing
 * operand count information. Spare (unassigned) operators are shown reserved. 
 *
 * Macro prefixes:
 *
 * tx_  Shared by Type 1 and Type 2
 * t1_  Found in Type 1 only
 * t2_  Found in Type 2 only
 */

#ifndef TXOPS_H
#define TXOPS_H

/* --- One byte operators (0-31) --- */

/* Type 2 */
#define tx_reserved0        0   /* Reserved */
#define tx_hstem            1
#define t2_reserved2        2   /* Reserved (Cube compose) */
#define tx_vstem            3
#define tx_vmoveto          4
#define tx_rlineto          5
#define tx_hlineto          6
#define tx_vlineto          7
#define tx_rrcurveto        8
#define t2_reserved9        9   /* Reserved */
#define tx_callsubr         10
#define tx_return           11
#define tx_escape           12
#define t2_reserved13       13  /* Reserved */
#define tx_endchar          14
#define t2_reserved15       15  /* Reserved */
#define t2_blend            16
#define t2_reserved17       17  /* Reserved */
#define t2_hstemhm          18 
#define t2_hintmask         19
#define t2_cntrmask         20
#define tx_rmoveto          21
#define tx_hmoveto          22
#define t2_vstemhm          23
#define t2_rcurveline       24
#define t2_rlinecurve       25
#define t2_vvcurveto        26
#define t2_hhcurveto        27
#define t2_shortint         28
#define t2_callgsubr        29
#define tx_vhcurveto        30
#define tx_hvcurveto        31

/* Type 1 (where different from above) */
#define t1_compose          2
#define t1_closepath        9
#define t1_hsbw             13
#define t1_moveto           15  /* Not in Black Book, used in a few fonts */
#define t1_reserved16       16
#define t1_curveto          17  /* Not in Black Book, used in a few fonts */
#define t1_reserved18       18
#define t1_reserved19       19
#define t1_reserved20       20
#define t1_reserved23       23
#define t1_reserved24       24
#define t1_reserved25       25
#define t1_reserved26       26
#define t1_reserved27       27
#define t1_reserved28       28
#define t1_reserved29       29

/* --- Two byte operators --- */

/* Make escape operator value; may be redefined to suit implementation */
#ifndef tx_ESC
#define tx_ESC(op)          (tx_escape<<8|(op))
#endif

/* Type 2 */
#define tx_dotsection       tx_ESC(0)
#define t2_reservedESC1     tx_ESC(1)   /* Reserved */
#define t2_reservedESC2     tx_ESC(2)   /* Reserved */
#define tx_and              tx_ESC(3)   
#define tx_or               tx_ESC(4)   
#define tx_not              tx_ESC(5)   
#define t2_reservedESC6     tx_ESC(6)   /* Reserved */
#define t2_reservedESC7		tx_ESC(7)	/* Reserved */
#define tx_store            tx_ESC(8)   
#define tx_abs              tx_ESC(9)   
#define tx_add              tx_ESC(10) 
#define tx_sub              tx_ESC(11) 
#define tx_div              tx_ESC(12) 
#define tx_load             tx_ESC(13) 
#define tx_neg              tx_ESC(14) 
#define tx_eq               tx_ESC(15) 
#define t2_reservedESC16    tx_ESC(16)	/* Reserved */
#define t2_reservedESC17    tx_ESC(17)  
#define tx_drop             tx_ESC(18) 
#define t2_reservedESC19    tx_ESC(19)  /* Reserved (Cube setwv) */
#define tx_put              tx_ESC(20) 
#define tx_get              tx_ESC(21) 
#define tx_ifelse           tx_ESC(22) 
#define tx_random           tx_ESC(23) 
#define tx_mul              tx_ESC(24) 
#define tx_reservedESC25    tx_ESC(25)
#define tx_sqrt             tx_ESC(26) 
#define tx_dup              tx_ESC(27) 
#define tx_exch             tx_ESC(28) 
#define tx_index            tx_ESC(29) 
#define tx_roll             tx_ESC(30) 
#define tx_reservedESC31    tx_ESC(31)  /* Reserved (Cube rotate) */
#define tx_reservedESC32    tx_ESC(32)  /* Reserved (Cube attach) */
#define t2_reservedESC33    tx_ESC(33)  /* Reserved */
#define t2_hflex            tx_ESC(34)
#define t2_flex             tx_ESC(35)
#define t2_hflex1           tx_ESC(36)
#define t2_flex1            tx_ESC(37)
#define t2_cntron           tx_ESC(38)
/*                                 39-255 Reserved */

/* Type 1 (where different from above) */
#define t1_vstem3           tx_ESC(1)
#define t1_hstem3           tx_ESC(2)
#define t1_seac             tx_ESC(6)   
#define t1_sbw              tx_ESC(7)   
#define t1_callother        tx_ESC(16)
#define t1_pop              tx_ESC(17)  
#define t1_setwv            tx_ESC(19)
#define t1_div2             tx_ESC(25) 
#define t1_setcurrentpt     tx_ESC(33)

/* --- Othersubrs --- */

/* Type 1 */
#define t1_otherFlex        0
#define t1_otherPreflex1    1
#define t1_otherPreflex2    2
#define t1_otherHintSubs    3
#define t1_otherUniqueId    4
#define t1_otherGlobalColor 6
#define t1_otherReserved7   7
#define t1_otherReserved8   8
#define t1_otherReserved9   9
#define t1_otherReserved10  10
#define t1_otherReserved11  11
#define t1_otherCntr1       12
#define t1_otherCntr2       13
#define t1_otherBlend1      14
#define t1_otherBlend2      15
#define t1_otherBlend3      16
#define t1_otherBlend4      17
#define t1_otherBlend6      18
#define t1_otherStoreWV     19
#define t1_otherAdd         20
#define t1_otherSub         21
#define t1_otherMul         22
#define t1_otherDiv         23
#define t1_otherPut         24
#define t1_otherGet         25
#define t1_otherPSPut       26
#define t1_otherIfelse      27
#define t1_otherRandom      28
#define t1_otherDup         29
#define t1_otherExch        30

/* Return operator size from definition (doesn't handle mask or number ops) */
#define TXOPSIZE(op) (((op)&0xff00)?2:1)

/* --- Interpreter limits/definitions --- */
#define T2_MAX_OP_STACK     48  /* Max operand stack depth */
#define TX_MAX_CALL_STACK   10  /* Max callsubr stack depth */
#define T2_MAX_STEMS        96  /* Max stems */
#define TX_MAX_MASTERS      16  /* Max master designs */
#define TX_MAX_AXES         15   /* Max design axes */
#define TX_MAX_AXIS_MAPS	  12	/* Max axis maps (piecewise division) */
#define TX_STD_FLEX_HEIGHT  50  /* Standard flex height (100ths/pixel) */
#define TX_MAX_BLUE_VALUES  14  /* 14 values (7 pairs) */

/* load/store registry ids */
#define TX_REG_WV			0	/* WeightVector */
#define TX_REG_NDV			1	/* NormalizedDesignVector */
#define TX_REG_UDV			2	/* UserDesignVector */

/* Type 1 (where different from above) */
#define T1_MAX_OP_STACK     24  /* Max operand stack depth */
#define T1_MAX_AXES         4   /* Max design axes */

#endif /* TXOPS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\inc\plotgpc.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotgpc.h


Abstract:

    This module contains the plotter characterization data definition


Author:

    10-Nov-1993 Wed 02:04:24 created  

    18-Mar-1994 Fri 14:00:14 updated  
        Adding PLOTF_RTL_NO_DPI_XY, PLOTF_RTLMONO_NO_CID and
        PLOTF_RTLMONO_FIXPAL flags

[Environment:]

    GDI Device Driver - PLOTTER.


[Notes:]


Revision History:


--*/


#ifndef _PLOTGPC_
#define _PLOTGPC_


#define PLOTF_RASTER                0x00000001
#define PLOTF_COLOR                 0x00000002
#define PLOTF_BEZIER                0x00000004
#define PLOTF_RASTERBYTEALIGN       0x00000008
#define PLOTF_PUSHPOPPAL            0x00000010
#define PLOTF_TRANSPARENT           0x00000020
#define PLOTF_WINDINGFILL           0x00000040
#define PLOTF_ROLLFEED              0x00000080
#define PLOTF_PAPERTRAY             0x00000100
#define PLOTF_NO_BMP_FONT           0x00000200
#define PLOTF_RTLMONOENCODE_5       0x00000400
#define PLOTF_RTL_NO_DPI_XY         0x00000800
#define PLOTF_RTLMONO_NO_CID        0x00001000
#define PLOTF_RTLMONO_FIXPAL        0x00002000
#define PLOTF_ALL_FLAGS             0x00003fff

#define PLOTGPC_ID                  'tolP'
#define PLOTGPC_VERSION             0x010a

#define ROP_LEVEL_0                 0
#define ROP_LEVEL_1                 1
#define ROP_LEVEL_2                 2
#define ROP_LEVEL_3                 3
#define ROP_LEVEL_MAX               ROP_LEVEL_3

#define MAX_SCALE_MAX               10000
#define MAX_QUALITY_MAX             4
#define MAX_PENPLOTTER_PENS         32

//
// The form data
//

typedef struct _FORMSRC {
    CHAR    Name[CCHFORMNAME];              // Form name
    SIZEL   Size;                           // cx/cy size in 1/1000mm
    RECTL   Margin;                         // L/T/R/B margins in 1/1000mm
    } FORMSRC, *PFORMSRC;


//
// The pen plotter pen information
//
//  Index            R   G   B
// ------------------------------
// PC_IDX_WHITE     255 255 255
// PC_IDX_BLACK       0   0   0
// PC_IDX_RED       255   0   0
// PC_IDX_GREEN       0 255   0
// PC_IDX_YELLOW    255 255   0
// PC_IDX_BLUE        0   0 255
// PC_IDX_MAGENTA   255   0 255
// PC_IDX_CYAN        0 255 255
// PC_IDX_ORANGE    255 128   0
// PC_IDX_BROWN     255 192   0
// PC_IDX_VIOLET    128   0 255
//

#define PC_IDX_FIRST                PC_IDX_WHITE
#define PC_IDX_WHITE                0
#define PC_IDX_BLACK                1
#define PC_IDX_RED                  2
#define PC_IDX_GREEN                3
#define PC_IDX_YELLOW               4
#define PC_IDX_BLUE                 5
#define PC_IDX_MAGENTA              6
#define PC_IDX_CYAN                 7
#define PC_IDX_ORANGE               8
#define PC_IDX_BROWN                9
#define PC_IDX_VIOLET               10
#define PC_IDX_LAST                 PC_IDX_VIOLET
#define PC_IDX_TOTAL                (PC_IDX_LAST - PC_IDX_FIRST + 1)


typedef struct _PENDATA {
    WORD    ColorIdx;
    } PENDATA, *PPENDATA;

//
// Variable size definitions 
// Note: If you change any of these structures you have to make the appropriate
// change in CopyPlotGPCFromPCD() in file readgpc.c
//

typedef struct _GPCVARSIZE {
    WORD    Count;                          // Count of total structures
    WORD    SizeEach;                       // Size of each structure
    LPVOID  pData;                          // offset of data, fixed up at load
    } GPCVARSIZE, *PGPCVARSIZE;


typedef struct _PLOTGPC {
    DWORD       ID;                         // ID For checking
    DWORD       Version;                    // Version number
    WORD        cjThis;                     // size of PLOTGPC structure
    WORD        SizeExtra;                  // extra size at end of structure
    BYTE        DeviceName[CCHDEVICENAME];  // Device name
    SIZEL       DeviceSize;                 // cx/cy in 1/1000 mm
    RECTL       DeviceMargin;               // L/T/R/B margins in 1/1000mm
    DWORD       Flags;                      // PLOTF_xxxx flags
    DWORD       PlotXDPI;                   // Pen Plotter DotPerInch in X
    DWORD       PlotYDPI;                   // Pen Plotter DotPerInch in Y
    WORD        RasterXDPI;                 // Raster DotPerInch in X
    WORD        RasterYDPI;                 // Raster DotPerInch in Y
    WORD        ROPLevel;                   // Raster Operation Level
    WORD        MaxScale;                   // Scale in 1% increment 100 = 100%
    WORD        MaxPens;                    // Maximum pens device has
    WORD        MaxCopies;                  // Maximum copies device can handle
    WORD        MaxPolygonPts;              // Maximum polygon pt it can handle
    WORD        MaxQuality;                 // Maximum avaliable quality
    SIZEL       PaperTraySize;              // Paper Tray Size
    COLORINFO   ci;                         // Color Info structure
    DWORD       DevicePelsDPI;              // Real effective DPI for device
    DWORD       HTPatternSize;              // Halftone pattern size
    GPCVARSIZE  InitString;                 // init string send during StartDoc
    GPCVARSIZE  Forms;                      // Form supported (FORMSRC)
    GPCVARSIZE  Pens;                       // Pen plotter pens' Data
    } PLOTGPC, *PPLOTGPC;

/*
 * These structures represent the values on the .pcd files. They have the same
 * structure on both 32 bit and 64 bit machines. To achieve this, the pack (4)
 * directive is used. Also, no 64 bit quantities, like LPVOID, are used. 
 */
#pragma pack(push, 4)

typedef struct _GPCVARSIZE_PCD {
    WORD    Count;                          // Count of total structures
    WORD    SizeEach;                       // Size of each structure
    DWORD   pData;                          // offset of data, fixed up at load
    } GPCVARSIZE_PCD, *PGPCVARSIZE_PCD;


typedef struct _PLOTGPC_PCD {
    DWORD           ID;                         // ID For checking
    DWORD           Version;                    // Version number
    WORD            cjThis;                     // size of PLOTGPC_PCD structure
    WORD            SizeExtra;                  // extra size at end of structure
    BYTE            DeviceName[CCHDEVICENAME];  // Device name
    SIZEL           DeviceSize;                 // cx/cy in 1/1000 mm
    RECTL           DeviceMargin;               // L/T/R/B margins in 1/1000mm
    DWORD           Flags;                      // PLOTF_xxxx flags
    DWORD           PlotXDPI;                   // Pen Plotter DotPerInch in X
    DWORD           PlotYDPI;                   // Pen Plotter DotPerInch in Y
    WORD            RasterXDPI;                 // Raster DotPerInch in X
    WORD            RasterYDPI;                 // Raster DotPerInch in Y
    WORD            ROPLevel;                   // Raster Operation Level
    WORD            MaxScale;                   // Scale in 1% increment 100 = 100%
    WORD            MaxPens;                    // Maximum pens device has
    WORD            MaxCopies;                  // Maximum copies device can handle
    WORD            MaxPolygonPts;              // Maximum polygon pt it can handle
    WORD            MaxQuality;                 // Maximum avaliable quality
    SIZEL           PaperTraySize;              // Paper Tray Size
    COLORINFO       ci;                         // Color Info structure
    DWORD           DevicePelsDPI;              // Real effective DPI for device
    DWORD           HTPatternSize;              // Halftone pattern size
    GPCVARSIZE_PCD  InitString;                 // init string send during StartDoc
    GPCVARSIZE_PCD  Forms;                      // Form supported (FORMSRC)
    GPCVARSIZE_PCD  Pens;                       // Pen plotter pens' Data
    } PLOTGPC_PCD, *PPLOTGPC_PCD;

#pragma pack(pop)

#define DWORD_ALIGNED(x)            (((DWORD)x + 3) & (DWORD)~3)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\cachegpc.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    cachegpc.c


Abstract:

    This module contains functions to cached the PLOTGPC


Author:

    15-Dec-1993 Wed 20:29:07 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgCacheGPC

#define DBG_CACHE_DATA      0x00000001
#define DBG_CS              0x00000002
#define DBG_FORCE_UPDATE    0x80000000


DEFINE_DBGVAR(0);


//
// Local structrue and definitions only used in this module
//

typedef struct _CACHEDPLOTGPC {
    struct _CACHEDPLOTGPC   *pNext;
    DWORD                   cRef;
    PPLOTGPC                pPlotGPC;
    WCHAR                   wszFile[1];
    } CACHEDPLOTGPC, *PCACHEDPLOTGPC;

#define MAX_CACHED_PLOTGPC      16


DWORD               cCachedGPC = 0;
PCACHEDPLOTGPC      pCHead = NULL;

#if defined(UMODE) || defined(USERMODE_DRIVER)

    CRITICAL_SECTION    CachedGPCDataCS;

    #define ACQUIREGPCSEM()     EnterCriticalSection(&CachedGPCDataCS)

    #define RELEASEGPCSEM()     LeaveCriticalSection(&CachedGPCDataCS)

    #define CREATEGPCSEM()      InitializeCriticalSection(&CachedGPCDataCS)

    #define DELETEGPCSEM()      DeleteCriticalSection(&CachedGPCDataCS)

#else

    HSEMAPHORE hsemGPC = NULL;

    #define ACQUIREGPCSEM()     EngAcquireSemaphore(hsemGPC)
    #define RELEASEGPCSEM()     EngReleaseSemaphore(hsemGPC)
    #define CREATEGPCSEM()      hsemGPC = EngCreateSemaphore()
    #define DELETEGPCSEM()      EngDeleteSemaphore(hsemGPC)

#endif




BOOL
InitCachedData(
    VOID
    )

/*++

Routine Description:

    This function initialized the GPC data cache


Arguments:

    NONE


Return Value:

    VOID

Author:

    12-May-1994 Thu 11:50:04 created  


Revision History:


--*/

{

    PLOTDBG(DBG_CS, ("InitCachedData: InitCriticalSection, Count=%ld, pCHead=%08lx",
                    cCachedGPC, pCHead));

    cCachedGPC = 0;
    pCHead     = NULL;

    try {

        CREATEGPCSEM();

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        //
        // Critical section failed to get initialized.
        //
        return FALSE;
    }

    return TRUE;
}





VOID
DestroyCachedData(
    VOID
    )

/*++

Routine Description:

    This function destroy all the cached information for PPRINTERINFO

Arguments:

    VOID

Return Value:

    VOID


Author:

    15-Dec-1993 Wed 20:30:16 38:27 created  


Revision History:


--*/

{
    try {

        PCACHEDPLOTGPC  pTemp;


        PLOTDBG(DBG_CS, ("DestroyCachedData: EnterCriticalSection, TOT=%ld",
                cCachedGPC));

        ACQUIREGPCSEM();

        while (pCHead) {

            PLOTDBG(DBG_CACHE_DATA, ("!!!DESTROY cached pPlotGPC=[%p] %s",
                                (DWORD_PTR)pCHead->pPlotGPC, pCHead->wszFile));

            PLOTASSERT(1, "DestroyCachedData: cCachedGPC <= 0, pCHead=%08lx",
                       cCachedGPC > 0, pCHead);

            pTemp  = pCHead;
            pCHead = pCHead->pNext;

            --cCachedGPC;

            LocalFree((HLOCAL)pTemp->pPlotGPC);
            LocalFree((HLOCAL)pTemp);
        }

    } finally {


        PLOTDBG(DBG_CS, ("DestroyCachedData: LeaveCriticalSection"));

        RELEASEGPCSEM();

        PLOTDBG(DBG_CS, ("DestroyCachedData: DeleteCriticalSection"));

        DELETEGPCSEM();
    }
}




BOOL
UnGetCachedPlotGPC(
    PPLOTGPC    pPlotGPC
    )

/*++

Routine Description:

    This function un-reference a used cached GPC object

Arguments:

    pPlotGPC    - Pointer to the cached GPC returned from GetCachedPlotGPC

Return Value:

    BOOL


Author:

    10-May-1994 Tue 16:27:15 created  


Revision History:


--*/

{
    BOOL    Ok = FALSE;


    try {

        PCACHEDPLOTGPC  pCur;


        PLOTDBG(DBG_CS, ("UnGetCachedPlotGPC: EnterCriticalSection"));

        ACQUIREGPCSEM();

        pCur = pCHead;

        while (pCur) {

            if (pCur->pPlotGPC == pPlotGPC) {

                //
                // Found it, move that to the front and return pPlotGPC
                //

                PLOTDBG(DBG_CACHE_DATA, ("UnGetCachedPlotGPC: TOT=%ld, Found Cached pPlotGPC=%08lx, cRef=%ld->%ld, <%s>",
                        cCachedGPC, pCur->pPlotGPC, pCur->cRef,
                        pCur->cRef - 1, pCur->wszFile));

                if (pCur->cRef) {

                    --(pCur->cRef);

                } else {

                    PLOTWARN(("UnGetCachedPlotGPC(): Ref Count == 0 already???"));
                }

                Ok = TRUE;

                //
                // Exit Now
                //

                break;
            }

            pCur = pCur->pNext;
        }

        if (!Ok) {

            PLOTERR(("UnGetCachedPlotGPC(): pPlotGPC=%08lx not found!", pPlotGPC));
        }

    } finally {

        PLOTDBG(DBG_CS, ("UnGetCachedPlotGPC: LeaveCriticalSection"));

        RELEASEGPCSEM();
    }

    return(Ok);
}




PPLOTGPC
GetCachedPlotGPC(
    LPWSTR  pwDataFile
    )

/*++

Routine Description:

    This function return cached PlotGPC pointer, if not cached then it will
    add it to the cached, if cached data is full it will delete least used one
    first.

Arguments:

    pwDataFile      - Pointe to the data file

Return Value:

    pPlotGPC, NULL if failed


Author:

    15-Dec-1993 Wed 20:30:25 created  


Revision History:


--*/

{
    PPLOTGPC    pPlotGPC = NULL;


    try {

        PCACHEDPLOTGPC  pCur;
        PCACHEDPLOTGPC  pPrev;
        UINT            Idx;


        PLOTDBG(DBG_CS, ("GetCachedPlotGPC: EnterCriticalSection"));

        ACQUIREGPCSEM();

        pCur  = pCHead;
        pPrev = NULL;

        //
        // Traverse through the linked list, and exit when at end, remember if
        // we have more than 2 in the cached then we want to preserved last
        // pPrev, so we know the pPrev of the last one, (because we need to
        // delete last one)
        //

        while (pCur) {

            if (!_wcsicmp(pCur->wszFile, pwDataFile)) {

                //
                // Found it, move that to the front and return pPlotGPC
                //

                if (pPrev) {

                    pPrev->pNext = pCur->pNext;
                    pCur->pNext  = pCHead;
                    pCHead       = pCur;
                }

                PLOTDBG(DBG_CACHE_DATA,
                       ("GetCachedPlotGPC: TOT=%ld, FOUND [%08lx], cRef=%ld->%ld, <%s>",
                        cCachedGPC, pCur->pPlotGPC, pCur->cRef,
                        pCur->cRef + 1, pCur->wszFile));
#if DBG
                if (DBG_PLOTFILENAME & DBG_FORCE_UPDATE) {

                    LocalFree((HLOCAL)(pCur->pPlotGPC));
                    pCur->pPlotGPC =
                    pPlotGPC       = ReadPlotGPCFromFile(pwDataFile);

                    PLOTDBG(DBG_FORCE_UPDATE,
                            ("GetCachedPlotGPC: ForceUpdate: pPlotGPC=%08lx: %s",
                            pPlotGPC, pCur->wszFile));
                }
#endif
                ++(pCur->cRef);
                pPlotGPC = pCur->pPlotGPC;

                break;
            }

            pPrev = pCur;
            pCur  = pCur->pNext;
        }

        //
        // If we have too many entries in the cache then delete them to fit
        // into the MAX_CACHED_PLOTGPC, delete the oldest one first
        //

        if (cCachedGPC > MAX_CACHED_PLOTGPC) {

            PCACHEDPLOTGPC  pFree[MAX_CACHED_PLOTGPC];


            pPrev = NULL;
            pCur  = pCHead;
            Idx   = 0;

            while ((pCur) && (Idx < MAX_CACHED_PLOTGPC)) {

                if (pCur->cRef == 0) {

                    pFree[Idx++] = pPrev;
                }

                pPrev = pCur;
                pCur  = pCur->pNext;
            }

            while ((cCachedGPC > MAX_CACHED_PLOTGPC) && (Idx--)) {

                if (pPrev = pFree[Idx]) {

                    pCur         = pPrev->pNext;
                    pPrev->pNext = pPrev->pNext->pNext;

                } else {

                    pCur   = pCHead;
                    pCHead = pCHead->pNext;
                }

                PLOTDBG(DBG_CACHE_DATA,
                        ("Cached Full=%ld, DELETE: 1pCur=%08lx, pPlotGPC=%08lx <%s>",
                            cCachedGPC, pCur, pCur->pPlotGPC, pCur->wszFile));

                --cCachedGPC;

                LocalFree((HLOCAL)pCur->pPlotGPC);
                LocalFree((HLOCAL)pCur);
            }
        }

        if (!pPlotGPC) {

            PLOTDBG(DBG_CACHE_DATA,("GPC cached NOT FOUND for %s", pwDataFile));

            //
            // Read the New pPlotGPC, and add that to the linked list, make
            // it as most recent used (at the Head)
            //

            if (pPlotGPC = ReadPlotGPCFromFile(pwDataFile)) {

                SIZE_T cchDataFile;

                cchDataFile = wcslen(pwDataFile) + 1;

                Idx = (UINT)((cchDataFile * sizeof(WCHAR)) +
                             sizeof(CACHEDPLOTGPC));

                if (pCur = (PCACHEDPLOTGPC)LocalAlloc(LMEM_FIXED, Idx)) {

                    //
                    // Setting all the fields to the new NODE, and make this
                    // node as the head of the linked list
                    //

                    if (SUCCEEDED(StringCchCopyW(pCur->wszFile, cchDataFile, pwDataFile)))
                    {
                        pCur->pNext    = pCHead;
                        pCur->cRef     = 1;
                        pCur->pPlotGPC = pPlotGPC;
                        pCHead         = pCur;

                        //
                        // Said we have one more in the cache
                        //

                        ++cCachedGPC;

                        PLOTDBG(DBG_CACHE_DATA,
                                ("GetCachedPlotGPC: TOT=%ld, cRef=0->1, ADD CACHED pPlotGPC=%08lx <%s>",
                                cCachedGPC, pCur->pPlotGPC, pCur->wszFile));
                    }
                    else
                    {
                        PLOTERR(("GetCachedPlotGPC: StringCchCopyW failed"));

                        LocalFree((HLOCAL)pCur);
                        pCur = NULL;

                        LocalFree((HLOCAL)pPlotGPC);
                        pPlotGPC = NULL;
                    }

                } else {

                    PLOTERR(("GetCachedPlotGPC: LocalAlloc(%ld)) failed", Idx));

                    LocalFree((HLOCAL)pPlotGPC);
                    pPlotGPC = NULL;
                }

            } else {

                PLOTERR(("GetCachedPlotGPC: ReadPlotGPCFormFile(%s) failed",
                                                                    pwDataFile));
            }
        }

    } finally {

        PLOTDBG(DBG_CS, ("GetCachedPlotGPC: LeaveCriticalSection"));

        RELEASEGPCSEM();
    }

    return(pPlotGPC);
}




#ifdef UMODE


PPLOTGPC
hPrinterToPlotGPC(
    HANDLE  hPrinter,
    LPWSTR  pwDeviceName,
    size_t  cchDeviceName
    )

/*++

Routine Description:

    This function return cached PlotGPC pointer and it also return the device
    name

Arguments:

    hPrinter        - Handle to the printer interested

    pwDataFile      - Pointe to the data file

    pwDeviceName    - Pointer to the dmDeviceName where the name will be
                      stored if this pointer is not NULL

Return Value:

    pPlotGPC, NULL if failed


Author:

    15-Dec-1993 Wed 20:30:25 created  


Revision History:


--*/

{
    DRIVER_INFO_2   *pDI2;
    PPLOTGPC        pPlotGPC;


    if (!(pDI2 = (DRIVER_INFO_2 *)GetDriverInfo(hPrinter, 2))) {

        PLOTERR(("GetCachedPlotGPC: GetDriverInfo(DRIVER_INFO_2) failed"));
        return(NULL);
    }

    if (pwDeviceName) {

        size_t cchSize;

        if (cchDeviceName < CCHDEVICENAME)
        {
            cchSize = cchDeviceName;
        }
        else
        {
            cchSize = CCHDEVICENAME;
        }
        _WCPYSTR(pwDeviceName, pDI2->pName, cchSize);
    }

    pPlotGPC = GetCachedPlotGPC(pDI2->pDataFile);

    LocalFree((HLOCAL)pDI2);

    return(pPlotGPC);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\inc\plotdm.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotdm.h


Abstract:

    This module contains the PLOTDEVMODE plotter extented devmode definitions


Author:

    18-Nov-1993 Thu 06:28:56 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTPLOTDM_
#define _PLOTPLOTDM_

//
// Plotter pen definitions
//

typedef struct _PLOTPEN {
    BYTE    r;                      // Red Color
    BYTE    g;                      // Green Color
    BYTE    b;                      // Blue Color
    BYTE    Type;                   // What type of the pen
    } PLOTPEN, *PPLOTPEN;


//
// we print on anything at least 1cm x 1cm
//

#define MIN_PLOTGPC_FORM_CX     10000
#define MIN_PLOTGPC_FORM_CY     10000

//
// Variation defitions for the forms
//

typedef struct _FORMSIZE {
    SIZEL   Size;
    RECTL   ImageArea;
    } FORMSIZE, FAR *PFORMSIZE;



typedef struct _PAPERINFO {
    WCHAR   Name[CCHFORMNAME];
    SIZEL   Size;
    RECTL   ImageArea;
    } PAPERINFO, FAR *PPAPERINFO;

//
// Following are the flags for the printer properties flags setting
//

#define PPF_AUTO_ROTATE             0x0001
#define PPF_SMALLER_FORM            0x0002
#define PPF_MANUAL_FEED_CX          0x0004

#define PPF_ALL_BITS                (PPF_AUTO_ROTATE            |   \
                                     PPF_SMALLER_FORM           |   \
                                     PPF_MANUAL_FEED_CX)

typedef struct _PPDATA {
    WORD    Flags;
    WORD    NotUsed;
    } PPDATA, FAR *PPPDATA;

//
// Now, this is our EXTDEVMODE
//

#define PDMF_FILL_TRUETYPE          0x00000001
#define PDMF_PLOT_ON_THE_FLY        0x00000002

#define PDMF_ALL_BITS               0x00000003

typedef struct _PLOTDEVMODE {
    DEVMODE         dm;             // standard DEVMODE portion
    DWORD           PrivID;         // a ID Checker
    DWORD           PrivVer;        // a private version
    DWORD           Flags;          // PDMF_xxxx variouse flags
    COLORADJUSTMENT ca;             // default color adjustment for stretchblt
    } PLOTDEVMODE, FAR *PPLOTDEVMODE;

//
// Extra DM bits for ourself
//

#define DM_INV_SPEC_VER             0x80000000L
#define DM_INV_DEVMODESIZE          0x40000000L
#define DM_INV_PLOTPRIVATE          0x20000000L

#define DM_INV_ERRORS               (DM_INV_SPEC_VER | DM_INV_DEVMODESIZE)
#define DM_GDI_ERRORS               (DM_ORIENTATION     |           \
                                     DM_PAPERSIZE       |           \
                                     DM_PAPERLENGTH     |           \
                                     DM_PAPERWIDTH      |           \
                                     DM_SCALE           |           \
                                     DM_COPIES          |           \
                                     DM_DEFAULTSOURCE   |           \
                                     DM_PRINTQUALITY    |           \
                                     DM_COLOR           |           \
                                     DM_DUPLEX          |           \
                                     DM_YRESOLUTION     |           \
                                     DM_TTOPTION        |           \
                                     DM_COLLATE         |           \
                                     DM_FORMNAME)



#define PLOTDM_PRIV_ID              'PEDM'
#define PLOTDM_PRIV_VER             0x0001000
#define PLOTDM_PRIV_SIZE            (sizeof(PLOTDEVMODE) - sizeof(DEVMODE))


#endif  // _PLOTPLOTDM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\devmode.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    devmode.c


Abstract:

    This module contains devmode conversion



Development History:

    08-Jun-1995 Thu 13:47:33 created  


[Environment:]

    GDI printer drivers, user and kernel mode


[Notes:]


Revision History:

    11/09/95 
        New conversion routines

    09-Feb-1999 Tue 11:15:55 updated   
        Move from printers\lib directory

--*/

#include "precomp.h"
#pragma hdrstop


//
// This is the devmode version 320 (DM_SPECVERSION)
//

#define DM_SPECVERSION320   0x0320
#define DM_SPECVERSION400   0x0400
#define DM_SPECVERSION401   0x0401
#define DM_SPECVER_BASE     DM_SPECVERSION320

//
// size of a device name string
//

#define CCHDEVICENAME320   32
#define CCHFORMNAME320     32

typedef struct _devicemode320A {
    BYTE    dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    BYTE    dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320A, *PDEVMODE320A, *NPDEVMODE320A, *LPDEVMODE320A;

typedef struct _devicemode320W {
    WCHAR   dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    WCHAR   dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320W, *PDEVMODE320W, *NPDEVMODE320W, *LPDEVMODE320W;



#ifdef UNICODE

typedef DEVMODE320W     DEVMODE320;
typedef PDEVMODE320W    PDEVMODE320;
typedef NPDEVMODE320W   NPDEVMODE320;
typedef LPDEVMODE320W   LPDEVMODE320;

#else

typedef DEVMODE320A     DEVMODE320;
typedef PDEVMODE320A    PDEVMODE320;
typedef NPDEVMODE320A   NPDEVMODE320;
typedef LPDEVMODE320A   LPDEVMODE320;

#endif // UNICODE


typedef struct _DMEXTRA400 {
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;
} DMEXTRA400;


typedef struct _DMEXTRA401 {
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} DMEXTRA401;


#define DM_SIZE320  sizeof(DEVMODE320)
#define DM_SIZE400  (DM_SIZE320 + sizeof(DMEXTRA400))
#define DM_SIZE401  (DM_SIZE400 + sizeof(DMEXTRA401))

// Current version devmode size - public portion only

#ifdef  UNICODE
#define DM_SIZE_CURRENT sizeof(DEVMODEW)
#else
#define DM_SIZE_CURRENT sizeof(DEVMODEA)
#endif



WORD
CheckDevmodeVersion(
    PDEVMODE pdm
    )

/*++

Routine Description:

    Verify dmSpecVersion and dmSize fields of a devmode

Arguments:

    pdm - Specifies a devmode to be version-checked

Return Value:

    0 if the input devmode is unacceptable
    Otherwise, return the expected dmSpecVersion value

--*/

{
    WORD    expectedVersion;

    if (pdm == NULL)
        return 0;

    // Check against known devmode sizes

    switch (pdm->dmSize) {

    case DM_SIZE320:
        expectedVersion = DM_SPECVERSION320;
        break;

    case DM_SIZE400:
        expectedVersion = DM_SPECVERSION400;
        break;

    case DM_SIZE401:
        expectedVersion = DM_SPECVERSION401;
        break;

    default:
        expectedVersion = pdm->dmSpecVersion;
        break;
    }


    return expectedVersion;
}



LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Convert an input devmode to a different version devmode.

    Whenever driver gets an input devmode, it should call this
    routine to convert it to current version.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized/valid output devmode

Return Value:

    Total number of bytes copied
    -1 if either input or output devmode is invalid

--*/

{
    WORD    dmSpecVersion, dmDriverVersion;
    WORD    dmSize, dmDriverExtra;
    LONG    cbCopied = 0;

    //
    // Parameter check
    //
    if (NULL == pdmIn ||
        NULL == pdmOut )
    {
        return -1;
    }

    // Look for inconsistency between dmSpecVersion and dmSize

    if (! CheckDevmodeVersion(pdmIn) ||
        ! (dmSpecVersion = CheckDevmodeVersion(pdmOut)))
    {
        return -1;
    }

    // Copy public devmode fields

    dmDriverVersion = pdmOut->dmDriverVersion;
    dmSize = pdmOut->dmSize;
    dmDriverExtra = pdmOut->dmDriverExtra;

    cbCopied = min(dmSize, pdmIn->dmSize);
    memcpy(pdmOut, pdmIn, cbCopied);

    pdmOut->dmSpecVersion = dmSpecVersion;
    pdmOut->dmDriverVersion = dmDriverVersion;
    pdmOut->dmSize = dmSize;
    pdmOut->dmDriverExtra = dmDriverExtra;

    // Copy private devmode fields

    cbCopied += min(dmDriverExtra, pdmIn->dmDriverExtra);
    memcpy((PBYTE) pdmOut + pdmOut->dmSize,
           (PBYTE) pdmIn + pdmIn->dmSize,
           min(dmDriverExtra, pdmIn->dmDriverExtra));

    return cbCopied;
}


#if defined(UMODE) || defined(USERMODE_DRIVER)



BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Copy a source devmode to an output devmode buffer.

    Driver should call this routine before it returns to the caller
    of DrvDocumentPropertySheets.

Arguments:

    pdmSrc - Points to a current version source devmode
    pdmIn - Points to input devmode passed to DrvDocumentPropertySheets through lparam
    pdmOut - Output buffer pointer passed to DrvDocumentPropertySheets through lparam

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (pdmIn == NULL) {

        if (pdmSrc == NULL || pdmOut == NULL)
        {
            return FALSE;
        }

        memcpy(pdmOut, pdmSrc, pdmSrc->dmSize + pdmSrc->dmDriverExtra);
        return TRUE;

    } else {

        if (pdmSrc == NULL || pdmOut == NULL)
        {
            return FALSE;
        }

        // We have to deal with the public fields and private fields
        // separately. Also remember pdmIn and pdmOut may point to
        // the same buffer.

        // Public fields: take dmSpecVersion and dmSize from
        // the smaller of pdmSrc and pdmIn

        if (pdmIn->dmSize < pdmSrc->dmSize) {

            pdmOut->dmSpecVersion = pdmIn->dmSpecVersion;
            pdmOut->dmSize        = pdmIn->dmSize;

        } else {

            pdmOut->dmSpecVersion = pdmSrc->dmSpecVersion;
            pdmOut->dmSize        = pdmSrc->dmSize;
        }

        // Similarly for private fields

        if (pdmIn->dmDriverExtra < pdmSrc->dmDriverExtra) {

            pdmOut->dmDriverVersion = pdmIn->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmIn->dmDriverExtra;

        } else {

            pdmOut->dmDriverVersion = pdmSrc->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmSrc->dmDriverExtra;
        }

        return ConvertDevmode(pdmSrc, pdmOut) > 0;
    }
}



INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    )

/*++

Routine Description:

    Library routine to handle common cases of DrvConvertDevMode

Arguments:

    pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode
        Correspond to parameters passed to DrvConvertDevMode
    pDriverVersions - Specifies driver version numbers and private devmode sizes

Return Value:

    CDM_RESULT_TRUE
        If the case is handled by the library routine and driver
        shoud return TRUE to the caller of DrvConvertDevMode.

    CDM_RESULT_FALSE
        If the case is handled by the library routine and driver
        shoud return FALSE to the caller of DrvConvertDevMode.

    CDM_RESULT_NOT_HANDLED
        The case is NOT handled by the library routine and driver
        should continue on with whatever it needs to do.

--*/

{
    LONG    size;

    // Make sure pcbNeeded parameter is not NULL

    if (pcbNeeded == NULL) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return CDM_RESULT_FALSE;
    }

    switch (fMode) {

    case CDM_CONVERT:

        // Convert any input devmode to any output devmode.
        // Both input and output must be valid.

        if (pdmOut != NULL &&
            *pcbNeeded >= (pdmOut->dmSize + pdmOut->dmDriverExtra) &&
            ConvertDevmode(pdmIn, pdmOut) > 0)
        {
            *pcbNeeded = pdmOut->dmSize + pdmOut->dmDriverExtra;
            return CDM_RESULT_TRUE;
        }
        break;

    case CDM_CONVERT351:

        // Convert any input devmode to 3.51 version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE320 + pDriverVersions->dmDriverExtra351;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // Do the conversion from input devmode to 3.51 devmode

        pdmOut->dmSpecVersion = DM_SPECVERSION320;
        pdmOut->dmSize = DM_SIZE320;
        pdmOut->dmDriverVersion = pDriverVersions->dmDriverVersion351;
        pdmOut->dmDriverExtra = pDriverVersions->dmDriverExtra351;

        if (ConvertDevmode(pdmIn, pdmOut) > 0) {

            *pcbNeeded = size;
            return CDM_RESULT_TRUE;
        }

        break;

    case CDM_DRIVER_DEFAULT:

        // Convert any input devmode to current version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE_CURRENT + pDriverVersions->dmDriverExtra;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // This case (getting driver-default devmode) is not handled
        // by the library routine.

        *pcbNeeded = size;

        // FALL THROUGH TO THE DEFAULT CASE!

    default:
        return CDM_RESULT_NOT_HANDLED;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return CDM_RESULT_FALSE;
}

#endif // USER MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\drvinfo.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    drvinfo.c


Abstract:

    This module This module contains functions to access spooler's
    DRIVER_INFO_1/DRIVER_INFO_2 data strcture


Author:

    02-Dec-1993 Thu 22:54:51 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgMiscUtil

#define DBG_DRVINFO2        0x00000001

DEFINE_DBGVAR(0);


#ifdef UMODE


LPBYTE
GetDriverInfo(
    HANDLE  hPrinter,
    UINT    DrvInfoLevel
    )

/*++

Routine Description:

    This function get the DRIVER_INFO_1 Pointer from a hPrinter

Arguments:

    hPrinter        - The handle to the printer interested

    DrvInfoLevel    - if 1 then DRIVER_INFO_1 is returned else if 2 then
                      DRIVER_INFO_2 is returned, any other vaules are invlaid

Return Value:

    the return value is NULL if failed else a pointer to the DRIVER_INFO_1 or
    DRIVER_INFO_2 is returned, the caller must call LocalFree() to free the
    memory object after using it.


Author:

    02-Dec-1993 Thu 22:07:14 created  


Revision History:


--*/

{
    LPVOID  pb;
    DWORD   cb;

    //
    // Find out total bytes required
    //

    PLOTASSERT(1, "GetDriverInfo: Invalid DrvInfoLevl = %u",
                    (DrvInfoLevel == 1) || (DrvInfoLevel == 2), DrvInfoLevel);

    GetPrinterDriver(hPrinter, NULL, DrvInfoLevel, NULL, 0, &cb);

    if (xGetLastError() != ERROR_INSUFFICIENT_BUFFER) {

        PLOTERR(("GetDriverInfo%d: GetPrinterDriver(1st) error=%08lx",
                                        DrvInfoLevel, xGetLastError()));

    } else if (!(pb = (LPBYTE)LocalAlloc(LMEM_FIXED, cb))) {

        PLOTERR(("GetDriverInfo%d: LocalAlloc(%ld) failed", DrvInfoLevel, cb));

    } else if (GetPrinterDriver(hPrinter, NULL, DrvInfoLevel, pb, cb, &cb)) {

        //
        // Got it allright, so return it
        //

        return(pb);

    } else {

        PLOTERR(("GetDriverInfo%d: GetPrinterDriver(2nd) error=%08lx",
                                        DrvInfoLevel, xGetLastError()));
        LocalFree((HLOCAL)pb);
    }

    return(NULL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\halftone.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    halftone.c


Abstract:

    This module contains data and function to validate the COLORADJUSTMENT



Development History:

    27-Oct-1995 Fri 15:48:17 created   


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    09-Feb-1999 Tue 11:15:55 updated  
        Move from printers\lib directory

--*/


#include "precomp.h"
#pragma hdrstop


DEVHTINFO    DefDevHTInfo = {

        HT_FLAG_HAS_BLACK_DYE,
        HT_PATSIZE_SUPERCELL_M,
        0,                                  // DevPelsDPI

        {
            { 6380, 3350,       0 },        // xr, yr, Yr
            { 2345, 6075,       0 },        // xg, yg, Yg
            { 1410,  932,       0 },        // xb, yb, Yb
            { 2000, 2450,       0 },        // xc, yc, Yc Y=0=HT default
            { 5210, 2100,       0 },        // xm, ym, Ym
            { 4750, 5100,       0 },        // xy, yy, Yy
            { 3127, 3290,       0 },        // xw, yw, Yw=0=default

            12500,                          // R gamma
            12500,                          // G gamma
            12500,                          // B gamma, 12500=Default

            585,   120,                     // M/C, Y/C
              0,     0,                     // C/M, Y/M
              0, 10000                      // C/Y, M/Y  10000=default
        }
    };


COLORADJUSTMENT  DefHTClrAdj = {

        sizeof(COLORADJUSTMENT),
        0,
        ILLUMINANT_DEVICE_DEFAULT,
        10000,
        10000,
        10000,
        REFERENCE_BLACK_MIN,
        REFERENCE_WHITE_MAX,
        0,
        0,
        0,
        0
    };



#define ADJ_CA(p,a,i,x) if ((p->a<i)||(p->a>x)){Ok=FALSE;p->a=DefHTClrAdj.a;}



BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    )

/*++

Routine Description:

    This function validate and adjust the invalid color adjustment fields

Arguments:

    pca - Pointer to the COLORADJUSTMENT data structure


Return Value:

    TRUE if everything in the range FALSE otherwise



Development History:

    02-Dec-1993 Thu 22:45:59 created  


Revision History:

    02-Apr-1995 Sun 11:19:04 updated  
        Update the RGB_GAMMA_MIN/MAX checking and make default to 1.0


--*/

{
    BOOL    Ok = TRUE;

    //
    // Validate pointer and the color adjustment
    //

    if (NULL == pca) {
        return(FALSE);
    }
    if (pca->caSize != sizeof(COLORADJUSTMENT)) {

        *pca = DefHTClrAdj;
        return(FALSE);
    }

    ADJ_CA(pca, caIlluminantIndex,  0,                  ILLUMINANT_MAX_INDEX);
    ADJ_CA(pca, caRedGamma,         RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caGreenGamma,       RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caBlueGamma,        RGB_GAMMA_MIN,      RGB_GAMMA_MAX       );
    ADJ_CA(pca, caReferenceBlack,   0,                  REFERENCE_BLACK_MAX );
    ADJ_CA(pca, caReferenceWhite,   REFERENCE_WHITE_MIN,10000               );
    ADJ_CA(pca, caContrast,         COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caBrightness,       COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caColorfulness,     COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );
    ADJ_CA(pca, caRedGreenTint,     COLOR_ADJ_MIN,      COLOR_ADJ_MAX       );

    return(Ok);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\file.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    file.c


Abstract:

    This module contains function to read file


Author:

    24-Oct-1995 Tue 14:09:59 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#include "precomp.h"
#pragma hdrstop


#if !defined(UMODE) && !defined(USERMODE_DRIVER)


HANDLE
OpenPlotFile(
    LPWSTR  pFileName
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Oct-1995 Tue 14:16:46 created  


Revision History:


--*/

{
    PPLOTFILE   pPF;
    DWORD       cbSize;


    if ((pPF = (PPLOTFILE)EngAllocMem(FL_ZERO_MEMORY,
                                      sizeof(PLOTFILE),
                                      'tolp'))                          &&
        (pPF->hModule = EngLoadModule((LPWSTR)pFileName))               &&
        (pPF->pbBeg = EngMapModule(pPF->hModule, &cbSize))) {

        pPF->pbEnd = (pPF->pbCur = pPF->pbBeg) + cbSize;

        return((HANDLE)pPF);
    }

    if (pPF) {

        if (pPF->hModule) {
            EngFreeModule(pPF->hModule);
        }
        EngFreeMem((PVOID)pPF);
    }

    return((HANDLE)INVALID_HANDLE_VALUE);
}




BOOL
ClosePlotFile(
    HANDLE  hPlotFile
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Oct-1995 Tue 14:31:55 created  


Revision History:


--*/

{
    PPLOTFILE   pPF;

    if (pPF = (PPLOTFILE)hPlotFile) {

        EngFreeModule(pPF->hModule);
        EngFreeMem((PVOID)pPF);

        return(TRUE);
    }

    return(FALSE);
}




BOOL
ReadPlotFile(
    HANDLE  hPlotFile,
    LPVOID  pBuf,
    DWORD   cToRead,
    LPDWORD pcRead
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    24-Oct-1995 Tue 14:21:51 created  


Revision History:


--*/

{
    PPLOTFILE   pPF;


    if ((pPF = (PPLOTFILE)hPlotFile) && (pBuf)) {

        DWORD   cData;

        if ((cData = pPF->pbEnd - pPF->pbCur) < cToRead) {

            cToRead = cData;
        }

        if (cToRead) {

            CopyMemory((LPBYTE)pBuf, pPF->pbCur, cToRead);

            pPF->pbCur += cToRead;

            if (pcRead) {

                *pcRead = cToRead;
            }

            return(TRUE);
        }
    }

    return(FALSE);
}

#endif  // not UMODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\plotdbg.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotdbg.c


Abstract:

    This module contains all plotter's debugging functions


Author:

    15-Nov-1993 Mon 17:57:24 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#if DBG

BOOL    DoPlotWarn = FALSE;



VOID
cdecl
PlotDbgPrint(
    LPSTR   pszFormat,
    ...
    )

/*++

Routine Description:

    This fucntion output the debug informat to the debugger


Arguments:

    pszFormat   - format string

    ...         - variable data


Return Value:


    VOID

Author:

    15-Nov-1993 Mon 17:57:59 created  


Revision History:


--*/

{
    va_list         vaList;

#if defined(UMODE) || defined(USERMODE_DRIVER)

    static WCHAR    wOutBuf[768];
    static WCHAR    wFormatBuf[256];
    size_t          cch;

    //
    // We assume that UNICODE flag is turn on for the compilation, bug the
    // format string passed to here is ASCII version, so we need to convert
    // it to LPWSTR before the wvsprintf()
    //

    if (!SUCCEEDED(StringCchLengthA(pszFormat, CCHOF(wFormatBuf), &cch)))
    {
        return;
    }

    va_start(vaList, pszFormat);
    MultiByteToWideChar(CP_ACP, 0, pszFormat, -1, wFormatBuf, CCHOF(wFormatBuf));
    if (!SUCCEEDED(StringCchVPrintfW(wOutBuf, CCHOF(wOutBuf), wFormatBuf, vaList)))
    {
        return;
    }
    va_end(vaList);

    OutputDebugString((LPCTSTR)wOutBuf);
    OutputDebugString(TEXT("\n"));

#else

    va_start(vaList, pszFormat);
    EngDebugPrint("PLOT",pszFormat,vaList);
    va_end(vaList);

#endif
}




VOID
PlotDbgType(
    INT    Type
    )

/*++

Routine Description:

    this function output the ERROR/WARNING message


Arguments:

    Type

Return Value:


Author:

    15-Nov-1993 Mon 22:53:01 created  


Revision History:


--*/

{
    extern  TCHAR   DebugDLLName[];

#if defined(UMODE) || defined(USERMODE_DRIVER)

    if (Type) {

        OutputDebugString((Type < 0) ? TEXT("ERROR: ") : TEXT("WARNING: "));
    }

    OutputDebugString(DebugDLLName);
    OutputDebugString(TEXT("!"));

#else

    PlotDbgPrint("%s: %ws!\n",
                 (Type < 0) ? "ERROR" : "WARNING",
                 DebugDLLName);
#endif
}




VOID
_PlotAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    DWORD_PTR   Exp,
    BOOL    Stop
    )

/*++

Routine Description:

    This function output assertion message and false expression to the debugger
    then break into the debugger


Arguments:

    pMsg        - Message to displayed

    pFlaseExp   - false expression

    pFilename   - plotter source filename

    LineNo      - line number of the flase expression

Return Value:

    VOID


Author:

    15-Nov-1993 Mon 18:47:30 created  


Revision History:


--*/

{
    PlotDbgPrint("\n");

    if ((pMsg) && (*pMsg)) {

        PlotDbgPrint(pMsg, Exp);
    }

    if (pFalseExp && pFilename) {
        PlotDbgPrint("Assertion failed (%hs) in %hs line %u",
	            pFalseExp, pFilename, LineNo);
    }

    if (Stop) {

        DebugBreak();
    }
}



#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\plotlib.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotlib.h


Abstract:

    This module contains defines and prototype for the plotter library


Author:

    15-Nov-1993 Mon 22:52:46 created  

    29-Dec-1993 Wed 11:00:56 updated  
        Change PLOTDBGBLK() macro by adding automatical semi in macro

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTLIB_
#define _PLOTLIB_

#include <plotdm.h>
#include <plotgpc.h>

#define _WCPYSTR(pd,ps,n)           wcsncpy((LPWSTR)(pd),(LPWSTR)(ps),(n)); \
                                    *(((LPWSTR)(pd))+(n)-1)=L'\0'
#define WCPYFIELDNAME(pField,ps)    _WCPYSTR((pField),(ps),COUNT_ARRAY(pField))

#define SWAP(a,b,t)                 { (t)=(a); (a)=(b); (b)=(t); }

#define CCHOF(x)                    (sizeof(x)/sizeof(*(x)))

// Some other convinence defines

#define DM_PAPER_FIELDS (DM_PAPERWIDTH | DM_PAPERLENGTH |   \
                         DM_PAPERSIZE  | DM_FORMNAME)
#define DM_PAPER_WL     (DM_PAPERWIDTH | DM_PAPERLENGTH)


//
// new ddi stuff
//

#if defined(UMODE) || defined(USERMODE_DRIVER)

#pragma message("*** MSPLOT: Compile in USER Mode ***")


#define xEnumForms                  EnumForms
#define xGetPrinter                 GetPrinter
#define xGetPrinterData             GetPrinterData
#define xSetPrinterData             SetPrinterData
#define xGetLastError               GetLastError
#define AnsiToUniCode(pb,pw,cch)    \
            MultiByteToWideChar(CP_ACP,0,(pb),(cch),(pw),(cch))
#define UniCodeToAnsi(pb,pw,cch)    \
            WideCharToMultiByte(CP_ACP,0,(pw),(cch),(pb),(cch),NULL,NULL)

#else

#pragma message("*** MSPLOT: Compile in KERNEL Mode ***")

#define WritePrinter                EngWritePrinter
#define SetLastError                EngSetLastError
#define GetLastError                EngGetLastError
#define MulDiv                      EngMulDiv
#define xEnumForms                  EngEnumForms
#define xGetPrinter                 EngGetPrinter
#define xGetPrinterData             EngGetPrinterData
#define xSetPrinterData             EngSetPrinterData
#define xGetLastError               EngGetLastError
#define AnsiToUniCode(pb,pw,cch)    \
            EngMultiByteToUnicodeN((pw),(cch)*sizeof(WCHAR),NULL,(pb),(cch))
#define UniCodeToAnsi(pb,pw,cch)    \
            EngUnicodeToMultiByteN((pb),(cch),NULL,(pw),(cch)*sizeof(WCHAR))

#define LocalAlloc(fl,c)            \
            EngAllocMem(((fl) & LMEM_ZEROINIT) ? FL_ZERO_MEMORY:0,c,'tolp')
#define LocalFree(p)                EngFreeMem((PVOID)p)

#define DebugBreak()                EngDebugBreak()


#endif  // UMODE

//===========================================================================
// cacheGPC.c
//===========================================================================


BOOL
InitCachedData(
    VOID
    );

VOID
DestroyCachedData(
    VOID
    );

BOOL
UnGetCachedPlotGPC(
    PPLOTGPC    pPlotGPC
    );

PPLOTGPC
GetCachedPlotGPC(
    LPWSTR  pwDataFile
    );

#ifdef UMODE

PPLOTGPC
hPrinterToPlotGPC(
    HANDLE  hPrinter,
    LPWSTR  pwDeviceName,
    size_t  cchDeviceName
    );

#endif

//===========================================================================
// drvinfo.c
//===========================================================================

#ifdef UMODE

LPBYTE
GetDriverInfo(
    HANDLE  hPrinter,
    UINT    DrvInfoLevel
    );

#endif

//===========================================================================
// RegData.c
//===========================================================================

#define PRKI_FIRST          PRKI_CI
#define PRKI_CI             0
#define PRKI_DEVPELSDPI     1
#define PRKI_HTPATSIZE      2
#define PRKI_FORM           3
#define PRKI_PPDATA         4
#define PRKI_PENDATA_IDX    5
#define PRKI_PENDATA1       6
#define PRKI_PENDATA2       7
#define PRKI_PENDATA3       8
#define PRKI_PENDATA4       9
#define PRKI_PENDATA5       10
#define PRKI_PENDATA6       11
#define PRKI_PENDATA7       12
#define PRKI_PENDATA8       13
#define PRKI_LAST           PRKI_PENDATA8

#define PRK_MAX_PENDATA_SET (PRKI_LAST - PRKI_PENDATA1 + 1)


BOOL
GetPlotRegData(
    HANDLE  hPrinter,
    LPBYTE  pData,
    DWORD   RegIdx
    );


BOOL
UpdateFromRegistry(
    HANDLE      hPrinter,
    PCOLORINFO  pColorInfo,
    LPDWORD     pDevPelsDPI,
    LPDWORD     pHTPatSize,
    PPAPERINFO  pCurPaper,
    PPPDATA     pPPData,
    LPBYTE      pIdxPlotData,
    DWORD       cPenData,
    PPENDATA    pPenData
    );

#ifdef UMODE

BOOL
SetPlotRegData(
    HANDLE  hPrinter,
    LPBYTE  pData,
    DWORD   RegIdx
    );
BOOL
SaveToRegistry(
    HANDLE      hPrinter,
    PCOLORINFO  pColorInfo,
    LPDWORD     pDevPelsDPI,
    LPDWORD     pHTPatSize,
    PPAPERINFO  pCurPaper,
    PPPDATA     pPPData,
    LPBYTE      pIdxPlotData,
    DWORD       cPenData,
    PPENDATA    pPenData
    );

#endif

//===========================================================================
// Forms.c
//===========================================================================


#define FI1F_VALID_SIZE     0x80000000
#define FI1F_ENVELOPE       0x40000000
#define FI1F_MASK           0xc0000000

#define FI1F_ENUMFORMS_MASK 0x00000003


typedef struct _ENUMFORMPARAM {
    PFORM_INFO_1    pFI1Base;
    DWORD           Count;
    DWORD           ValidCount;
    DWORD           cMaxOut;
    PPLOTDEVMODE    pPlotDM;
    PPLOTGPC        pPlotGPC;
    PFORMSIZE       pCurForm;
    SHORT           FoundIndex;
    SHORT           ReqIndex;
    PFORM_INFO_1    pSizeFI1;
    SIZEL           ReqSize;
    } ENUMFORMPARAM, FAR *PENUMFORMPARAM;


//
// The following fields in ENUMFORMPARAM must set to valid pointer before
// the PlotEnumForms() call
//
//  1. pPlotDM
//  2. pPlotGPC
//  3. pCurForm (can be NULL)
//
// if a callback function is supplied then only forms which not greater than
// the device size will be passed to the callback function, for form which
// smaller or equal to the device size will have FI1F_VALID_SIZE bit set in
// the FORM_INFO_1 data structure's flag
//
//
// Call back function for enum forms, if return value is
//
// (Ret < 0) --> Free pFI1Base pointer and stop enum
// (Ret = 0) --> Keep pFI1Base and Stop Enum
// (Ret > 0) --> Continue Enum until all Count is enumerated
//
// The last enum callback will have following parameters to give the callback
// function a chance to return -1 (free the pFormInfo1 data)
//
//  pFI1  = NULL
//  Index = pEnumFormParam->Count
//

typedef INT (CALLBACK *ENUMFORMPROC)(PFORM_INFO_1       pFI1,
                                     DWORD              Index,
                                     PENUMFORMPARAM     pEnumFormParam);

//
// If (EnumFormProc == NULL) then no enumeration will happened but just
// return the pFI1/Count in pEnumFormParam, if both EnumFormProc and
// pEnumFormParam == NULL then it return FALSE
//

BOOL
PlotEnumForms(
    HANDLE          hPrinter,
    ENUMFORMPROC    EnumFormProc,
    PENUMFORMPARAM  pEnumFormParam
    );



//===========================================================================
// plotdm.c
//===========================================================================


BOOL
IsA4PaperDefault(
    VOID
    );

BOOL
IntersectRECTL(
    PRECTL  prclDest,
    PRECTL  prclSrc
    );

#define RM_L90      0
#define RM_180      1
#define RM_R90      2


BOOL
RotatePaper(
    PSIZEL  pSize,
    PRECTL  pImageArea,
    UINT    RotateMode
    );

SHORT
GetDefaultPaper(
    PPAPERINFO  pPaperInfo
    );

VOID
GetDefaultPlotterForm(
    PPLOTGPC    pPlotGPC,
    PPAPERINFO  pPaperInfo
    );

VOID
SetDefaultDMForm(
    PPLOTDEVMODE    pPlotDM,
    PFORMSIZE       pCurForm
    );

VOID
SetDefaultPLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pPlotDM,
    PFORMSIZE       pCurForm
    );

DWORD
ValidateSetPLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pPlotDMIn,
    PPLOTDEVMODE    pPlotDMOut,
    PFORMSIZE       pCurForm
    );


//===========================================================================
// WideChar.c - Unicode/Ansi conversion support
//===========================================================================

LPWSTR
str2Wstr(
    LPWSTR  pwStr,
    size_t  cchDest,
    LPSTR   pbStr
    );

LPWSTR
str2MemWstr(
    LPSTR   pStr
    );

LPSTR
WStr2Str(
    LPSTR   pbStr,
    size_t  cchDest,
    LPWSTR  pwStr
    );

//===========================================================================
// ReadGPC.c - PlotGPC reading/validating
//===========================================================================

BOOL
ValidateFormSrc(
    PGPCVARSIZE pFormGPC,
    SIZEL       DeviceSize,
    BOOL        DevRollFeed
    );

DWORD
PickDefaultHTPatSize(
    WORD    xDPI,
    WORD    yDPI,
    BOOL    HTFormat8BPP
    );

BOOL
ValidatePlotGPC(
    PPLOTGPC    pPlotGPC
    );

PPLOTGPC
ReadPlotGPCFromFile(
    PWSTR   pwsDataFile
    );

//===========================================================================
// file.c - file open/read/close
//===========================================================================


#if defined(UMODE) || defined(USERMODE_DRIVER)

#define OpenPlotFile(pFileName) CreateFile((LPCTSTR)pFileName,      \
                                           GENERIC_READ,            \
                                           FILE_SHARE_READ,         \
                                           NULL,                    \
                                           OPEN_EXISTING,           \
                                           FILE_ATTRIBUTE_NORMAL,   \
                                           NULL)

#define ClosePlotFile(h)        CloseHandle(h)
#define ReadPlotFile(h,p,c,pc)  ReadFile((h),(p),(c),(pc),NULL)


#else

typedef struct _PLOTFILE {
    HANDLE  hModule;
    LPBYTE  pbBeg;
    LPBYTE  pbEnd;
    LPBYTE  pbCur;
    } PLOTFILE, *PPLOTFILE;


HANDLE
OpenPlotFile(
    LPWSTR  pFileName
    );

BOOL
ClosePlotFile(
    HANDLE  hPlotFile
    );

BOOL
ReadPlotFile(
    HANDLE  hPlotFile,
    LPVOID  pBuf,
    DWORD   cToRead,
    LPDWORD pcRead
    );

#endif

//===========================================================================
// Devmode.c and halftone.c
//===========================================================================

BOOL
ValidateColorAdj(
    PCOLORADJUSTMENT    pca
    );


LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#if defined(UMODE) || defined(USERMODE_DRIVER)

#include <winspool.h>
#include <commctrl.h>
#include <winddiui.h>

// Copy DEVMODE to an output buffer before return to the
// caller of DrvDocumentPropertySheets

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

typedef struct {

    WORD    dmDriverVersion;    // current driver version
    WORD    dmDriverExtra;      // size of current version private devmode
    WORD    dmDriverVersion351; // 3.51 driver version
    WORD    dmDriverExtra351;   // size of 3.51 version private devmode

} DRIVER_VERSION_INFO, *PDRIVER_VERSION_INFO;

#define CDM_RESULT_FALSE        0
#define CDM_RESULT_TRUE         1
#define CDM_RESULT_NOT_HANDLED  2

INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    );

#endif


//===========================================================================
// PlotDBG.c - debug output support
//===========================================================================


#if DBG

VOID
cdecl
PlotDbgPrint(
    LPSTR   pszFormat,
    ...
    );

VOID
PlotDbgType(
    INT    Type
    );

VOID
_PlotAssert(
    LPSTR   pMsg,
    LPSTR   pFalseExp,
    LPSTR   pFilename,
    UINT    LineNo,
    DWORD_PTR   Exp,
    BOOL    Stop
    );

extern BOOL DoPlotWarn;


#define DBGP(x)             (PlotDbgPrint x)

#if 1

#define DEFINE_DBGVAR(x)    DWORD DBG_PLOTFILENAME=(x)
#define PLOTDBG(x,y)        if (x&DBG_PLOTFILENAME){PlotDbgType(0);DBGP(y);}

#else

#define DEFINE_DBGVAR(x)
#define PLOTDBG(x,y)        DBGP(y)

#endif  // DBG_PLOTFILENAME

#define PLOTDBGBLK(x)       x;
#define PLOTWARN(x)         if (DoPlotWarn) { PlotDbgType(1);DBGP(x); }
#define PLOTERR(x)          PlotDbgType(-1);DBGP(x)
#define PLOTRIP(x)          PLOTERR(x); DebugBreak()
#define PLOTASSERT(b,x,e,i)     \
            if (!(e)) { _PlotAssert(x,#e,__FILE__,(UINT)__LINE__,(DWORD_PTR)i,b); }

#else   // DBG

#define PLOTDBGBLK(x)
#define DEFINE_DBGVAR(x)
#define PLOTDBG(x,y)
#define PLOTWARN(x)
#define PLOTERR(x)
#define PLOTRIP(x)
#define PLOTASSERT(b,x,e,i)

#endif  // DBG





#endif  // _PLOTLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\forms.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    forms.c


Abstract:

    This module contains all functions related to the spooler/drivers forms


Author:

    18-Nov-1993 Thu 12:52:50 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgForms

#define DBG_ENUMFORMS       0x00000001
#define DBG_ENUMFORMS2      0x00000002

DEFINE_DBGVAR(0);

#if DBG

CHAR    *pszFormMode[] = { "   FORM_USER", "FORM_BUILTIN", "FORM_PRINTER" };

#endif



BOOL
PlotEnumForms(
    HANDLE          hPrinter,
    ENUMFORMPROC    EnumFormProc,
    PENUMFORMPARAM  pEnumFormParam
    )

/*++

Routine Description:

    This function enum all the forms from the spooler and return the
    FORM_INFO_1 arrary or using callback function to enum,

    this function automatically filter out the form size which greater then
    the device can support, it also set the valid bits if the device can
    handle the form in the data base.

Arguments:

    hPrinter        - Handler to the printer

    EnumFormProc    - callback function, if NULL then no callback is performed

    pEnumFormParam  - Pointer to the ENUMFORMPARAM data structure, the count
                      and pFI1Base will be set upon returned.

Return Value:

    BOOLEAN - if FALSE then a memory allocation or EnumForms() call failed


Author:

    18-Nov-1993 Thu 12:57:17 created  

    15-Dec-1993 Wed 21:14:46 updated  
        Make the form valid if it rotated and can fit into the device

    12-Jul-1994 Tue 12:43:50 updated  
        Move PaperTray checking into here, so it will not call out if the paper
        cannot hold by paper tray.

Revision History:


--*/

{
    PFORM_INFO_1    pFI1;
    DWORD           Count;
    DWORD           Index;
    DWORD           cb;
    SIZEL           DeviceSize;
    SIZEL           MinSize;


    if (pEnumFormParam == NULL) {
        PLOTERR(("PlotEnumForms: invalid parameters"));
        return (FALSE);
    }

    pEnumFormParam->Count      = 0;
    pEnumFormParam->ValidCount = 0;
    pEnumFormParam->pFI1Base   = NULL;

    xEnumForms(hPrinter, 1, NULL, 0, &cb, &Count);

    if (xGetLastError() != ERROR_INSUFFICIENT_BUFFER) {

        PLOTERR(("PlotEnumForms: 1st EnumForms failed"));
        return(FALSE);
    }

    if (!(pFI1 = (PFORM_INFO_1)LocalAlloc(LPTR, cb))) {

        PLOTERR(("PlotEnumForms: LocalAlloc(%lu) failed", cb));
        return(FALSE);
    }

    if (!xEnumForms(hPrinter, 1, (LPBYTE)pFI1, cb, &cb, &Count)) {

        PLOTERR(("PlotEnumForms: 2nd EnumForms failed"));
        LocalFree((HLOCAL)pFI1);
        return(FALSE);
    }

    pEnumFormParam->Count    = Count;
    pEnumFormParam->pFI1Base = pFI1;

    //
    // Firstable we will loop through the form to see if the form size is
    // smaller or equal to the the device size, if yes then set the
    // FI1F_VALID_SIZE bit
    //

    if (pEnumFormParam->pPlotGPC == NULL) {
        return (FALSE);
    }

    cb         = 0;
    DeviceSize = pEnumFormParam->pPlotGPC->DeviceSize;
    MinSize.cx = pEnumFormParam->pPlotGPC->DeviceMargin.left +
                 pEnumFormParam->pPlotGPC->DeviceMargin.right +
                 MIN_PLOTGPC_FORM_CX;
    MinSize.cy = pEnumFormParam->pPlotGPC->DeviceMargin.top +
                 pEnumFormParam->pPlotGPC->DeviceMargin.bottom +
                 MIN_PLOTGPC_FORM_CY;

    PLOTASSERT(0, "Device Length too small (%ld)",
                        DeviceSize.cy >= MIN_PLOTGPC_FORM_CY, DeviceSize.cy);

    PLOTDBG(DBG_ENUMFORMS2, ("\n---- PotEnumForm --Min=(%ld x %ld)-------------",
                MinSize.cx, MinSize.cy));

    if (MinSize.cx < MinSize.cy) {

        MinSize.cx = MinSize.cy;

    } else if (MinSize.cy < MinSize.cx) {

        MinSize.cy = MinSize.cx;
    }

    for (Index = 0; Index < Count; Index++) {

        //
        // The valid form means either straight or rotated form can be accepted
        // by the device.
        //

        pFI1->Flags &= ~FI1F_MASK;

        if ((pFI1->Size.cx >= MinSize.cx)           &&
            (pFI1->Size.cy >= MinSize.cy)           &&
            (((pFI1->Size.cx <= DeviceSize.cx)  &&
              (pFI1->Size.cy <= DeviceSize.cy))     ||
             ((pFI1->Size.cy <= DeviceSize.cx)  &&
              (pFI1->Size.cx <= DeviceSize.cy)))) {

            BOOL    ValidForm = TRUE;
            DWORD   FormMode;

            FormMode = pFI1->Flags & (FORM_USER | FORM_BUILTIN | FORM_PRINTER);

            if ((FormMode == FORM_BUILTIN)                                  &&
                (((Index >= (DMPAPER_ENV_9 - DMPAPER_FIRST))    &&
                  (Index <= (DMPAPER_ENV_14 - DMPAPER_FIRST)))          ||
                 ((Index >= (DMPAPER_ENV_DL - DMPAPER_FIRST))   &&
                  (Index <= (DMPAPER_ENV_PERSONAL - DMPAPER_FIRST)))    ||
                 (Index == (DMPAPER_ENV_INVITE - DMPAPER_FIRST)))) {

                pFI1->Flags |= FI1F_ENVELOPE;

            } else if (FormMode == FORM_PRINTER) {

                PFORMSRC    pFS;
                UINT        i;
                CHAR        bName[CCHFORMNAME];

                //
                // Check if this form is added by this driver
                //
                // Make sure that pFI1->pName is no longer than CCHFORMNAME.
                //
                if (wcslen(pFI1->pName) > CCHFORMNAME - 1) {
                    ValidForm = FALSE;
                }
                else
                {

                    WStr2Str(bName, CCHOF(bName), pFI1->pName);

                    pFS       = (PFORMSRC)pEnumFormParam->pPlotGPC->Forms.pData;
                    i         = (UINT)pEnumFormParam->pPlotGPC->Forms.Count;
                    ValidForm = FALSE;

                    while ((i--) && (!ValidForm)) {

                        if (!strcmp(bName, pFS->Name)) {

                            ValidForm = TRUE;
                        }

                        pFS++;
                    }
                }
            }

            if ((ValidForm)                                         &&
                (pEnumFormParam->pPlotGPC->Flags & PLOTF_PAPERTRAY) &&
                (pFI1->Size.cx != DeviceSize.cx)                    &&
                (pFI1->Size.cy != DeviceSize.cx)) {

                PLOTDBG(DBG_ENUMFORMS2,
                    ("%s: %ld x %ld CANNOT hold by PAPER TRAY (%ld)",
                    pFI1->pName, pFI1->Size.cx, pFI1->Size.cy,
                    DeviceSize.cx));

                ValidForm = FALSE;
            }

            if (ValidForm) {

                pFI1->Flags |= FI1F_VALID_SIZE;
                ++cb;
            }

            PLOTDBG(DBG_ENUMFORMS2, ("%hs [-%hs-]: <%ws> (%ld x %ld)",
                    pszFormMode[FormMode],
                    (ValidForm) ? "Ok" : "--", pFI1->pName,
                    pFI1->Size.cx, pFI1->Size.cy));
        }

        ++pFI1;
    }

    if (EnumFormProc) {

        //
        // In EnumFormProc it will increment ValidCount each time it called
        //

        if (pEnumFormParam->pCurForm) {

            DWORD   cMaxOut;

            PLOTDBG(DBG_ENUMFORMS,
                    ("PlotEnumForms: ValidCount=%ld, Count=%ld, cMaxOut=%ld",
                    cb, Count, pEnumFormParam->cMaxOut));

            cb      = 0;
            cMaxOut = pEnumFormParam->cMaxOut;
            pFI1    = pEnumFormParam->pFI1Base;

            for (Index = 0;
                 ((Index <= Count) && (cMaxOut > 0));
                 Index++, pFI1++, cMaxOut--) {

                if (Index == Count) {

                    pFI1 = NULL;
                }

                if ((!pFI1) || (pFI1->Flags & FI1F_VALID_SIZE)) {

                    ++cb;
                    (*EnumFormProc)(pFI1, Index, pEnumFormParam);
                }
            }

        } else {

            //
            // Add a Custom Size Form
            //

            ++cb;
        }

        LocalFree((HLOCAL)pEnumFormParam->pFI1Base);
        pEnumFormParam->pFI1Base = NULL;
    }

    pEnumFormParam->ValidCount = cb;

    PLOTDBG(DBG_ENUMFORMS, ("PlotEnumForms: ValidCount =  %ld / %ld",
                    pEnumFormParam->ValidCount, pEnumFormParam->Count));


    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\precomp.h ===
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <string.h>
#include <windows.h>
#include <winddi.h>
#include <strsafe.h>

#include <winspool.h>
#include <plotgpc.h>
#include <plotdm.h>
#include <plotters.h>
#include "plotlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\plotdm.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    plotdm.c


Abstract:

    This module contain functions which validate/set default the devmode and
    extented devmode (PLOTDEVMODE)


Author:

    15-Nov-1993 Mon 14:09:27 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:

    15-Dec-1993 Wed 21:08:49 updated  
        Add the default FILL_TRUETYPE flag stuff

    02-Feb-1994 Wed 01:04:21 updated  
        Change IsMetricMode() to IsA4PaperDefault(), this function right now
        will call RegOpenKey(), RegQueryValueEx() and RegCloseKey() to the
        control panel\International rather then using GetLocaleInfoW().
        The reason is if we call GetLocaleInfoW() then the registry key will
        keep opened by the API functions and since the WinSrv will never unload
        the driver, then the registry key will never get close, this has bad
        consquence which it never allowed user to save its updated profile at
        logoff time if this driver is used.

--*/


#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgDevMode

#define DBG_DEFDEVMODE      0x00000001
#define DBG_CURFORM         0x00000002
#define DBG_DEFPAPER        0x00000004
#define DBG_A4DEFAULT       0x00000008
#define DBG_ROTPAPER        0x00000010
#define DBG_INTERSECTRECTL  0x00000020
#define DBG_SHOWDEVMODE     0x00000040

DEFINE_DBGVAR(0);

//
// Depends on what we have to do what we have to do
//

#if defined(UMODE) || defined(USERMODE_DRIVER)
    #define HAS_GETREGDATA      1
#else
    #define HAS_GETREGDATA      0
#endif  // UMODE



//
// This is our default PLOTDEVMODE, we will update following fields
//
//  dmDeviceName    - Real device name passed in
//  dmFormName      - Letter if USA and A4 if NOT USA
//  dmPaperSize     - DMPAPER_LETTER/DMPAPER_A4
//  dmColor         - COLOR printer = DMCOLOR_COLOR else DMCOLOR_MONOCHROME
//

#define A4_FORM_NAME    _DefPlotDM.dm.dmDeviceName
#define A4_FORM_CX      _DefPlotDM.dm.dmPelsWidth
#define A4_FORM_CY      _DefPlotDM.dm.dmPelsHeight

#define DM_PAPER_CUSTOM (DM_PAPER_WL | DM_PAPERSIZE)


static const PLOTDEVMODE _DefPlotDM = {

        {
            TEXT("A4"),                 // dmDeviceName - filled later
            DM_SPECVERSION,             // dmSpecVersion
            DRIVER_VERSION,             // dmDriverVersion
            sizeof(DEVMODE),            // dmSize
            PLOTDM_PRIV_SIZE,           // dmDriverExtra

            DM_ORIENTATION       |
                DM_PAPERSIZE     |
                // DM_PAPERLENGTH   |
                // DM_PAPERWIDTH    |
                DM_SCALE         |
                DM_COPIES        |
                // DM_DEFAULTSOURCE |   // Reserved one, must zero
                DM_PRINTQUALITY  |
                DM_COLOR         |
                // DM_DUPLEX        |
                // DM_YRESOLUTION   |
                // DM_TTOPTION      |
                // DM_COLLATE       |
                DM_FORMNAME,

            DMORIENT_PORTRAIT,          // dmOrientation
            DMPAPER_LETTER,             // dmPaperSize
            2794,                       // dmPaperLength
            2159,                       // dmPaperWidth
            100,                        // dmScale
            1,                          // dmCopies
            0,                          // dmDefaultSource  - RESERVED = 0
            DMRES_HIGH,                 // dmPrintQuality
            DMCOLOR_COLOR,              // dmColor
            DMDUP_SIMPLEX,              // dmDuplex
            0,                          // dmYResolution
            0,                          // dmTTOption
            DMCOLLATE_FALSE,            // dmCollate
            TEXT("Letter"),             // dmFormName - depends on country
            0,                          // dmUnusedPadding   - DISPLAY ONLY
            0,                          // dmBitsPerPel      - DISPLAY ONLY
            2100,                       // dmPelsWidth       - DISPLAY ONLY
            2970,                       // dmPelsHeight      - DISPLAY ONLY
            0,                          // dmDisplayFlags    - DISPLAY ONLY
            0                           // dmDisplayFrequency- DISPLAY ONLY
        },

        PLOTDM_PRIV_ID,                 // PrivID
        PLOTDM_PRIV_VER,                // PrivVer
        PDMF_FILL_TRUETYPE,             // default advanced dialog box

        {
            sizeof(COLORADJUSTMENT),    // caSize
            0,                          // caFlags
            ILLUMINANT_DEVICE_DEFAULT,  // caIlluminantIndex
            10000,                      // caRedGamma
            10000,                      // caGreenGamma
            10000,                      // caBlueGamma
            REFERENCE_BLACK_MIN,        // caReferenceBlack
            REFERENCE_WHITE_MAX,        // caReferenceWhite
            0,                          // caContrast
            0,                          // caBrightness
            0,                          // caColorfulness
            0                           // caRedGreenTint
        }
    };



#define DEFAULT_COUNTRY             CTRY_UNITED_STATES


#if HAS_GETREGDATA

static const WCHAR  wszCountryKey[]   = L"Control Panel\\International";
static const WCHAR  wszCountryValue[] = L"iCountry";

#endif



BOOL
IsA4PaperDefault(
    VOID
    )

/*++

Routine Description:

    This function determine if the machine user is using the letter or A4
    paper as default based on the country code

Arguments:

    NONE


Return Value:

    BOOL true if the country default paper is A4, else LETTER

Author:

    23-Nov-1993 Tue 17:50:25 created  

    02-Feb-1994 Wed 03:01:12 updated  
        re-written so that we do open registry for the international data
        ourself, and we will make sure we close the all the keys opened by
        this function, so the system can unload the registry when the user
        log off.

Revision History:


--*/

{
#if HAS_GETREGDATA

    HKEY    hKey;
    LONG    CountryCode = DEFAULT_COUNTRY;
    WCHAR   wszStr[16];


    if (RegOpenKey(HKEY_CURRENT_USER, wszCountryKey, &hKey) == ERROR_SUCCESS) {

        DWORD   Type   = REG_SZ;
        DWORD   RetVal = sizeof(wszStr);
        size_t  cch;

        if (RegQueryValueEx(hKey,
                            (LPTSTR)wszCountryValue,
                            NULL,
                            &Type,
                            (LPBYTE)wszStr,
                            &RetVal) == ERROR_SUCCESS) {

            LPWSTR  pwStop;

            PLOTDBG(DBG_A4DEFAULT, ("IsA4PaperDefault: Country = %s", wszStr));

            if (Type == REG_SZ && SUCCEEDED(StringCchLength(wszStr, CCHOF(wszStr), &cch)))
            {
                CountryCode = wcstoul(wszStr, &pwStop, 10);
            }
            else
            {
                PLOTERR(("IsA4PaperDefault: RegQueryValue '%s' FAILED", wszCountryValue));
            }

        } else {

            PLOTERR(("IsA4PaperDefault: RegQueryValue '%s' FAILED", wszCountryValue));
        }

        RegCloseKey(hKey);

    } else {

        PLOTERR(("IsA4PaperDefault: RegOpenKey '%s' FAILED", wszCountryKey));
    }

    if ((CountryCode == CTRY_UNITED_STATES)             ||
        (CountryCode == CTRY_CANADA)                    ||
        ((CountryCode >= 50) && (CountryCode < 60))     ||
        ((CountryCode >= 500) && (CountryCode < 600))) {

        PLOTDBG(DBG_A4DEFAULT, ("IsA4PaperDefault = No, Use 'LETTER'"));

        return(FALSE);

    } else {

        PLOTDBG(DBG_A4DEFAULT, ("IsA4PaperDefault = Yes"));

        return(TRUE);
    }

#else

    //
    // Use letter size now
    //

    return(FALSE);

#endif  // HAS_GETREGDATA
}






BOOL
IntersectRECTL(
    PRECTL  prclDest,
    PRECTL  prclSrc
    )

/*++

Routine Description:

    This function intersect two RECTL data structures which specified imageable
    areas.

Arguments:

    prclDest    - pointer to the destination RECTL data structure, the result
                  is written back to here

    prclSrc     - pointer to the source RECTL data structure to be intersect
                  with the destination RECTL

Return Value:

    TRUE if destination is not empty, FALSE if final destination is empty

Author:

    20-Dec-1993 Mon 14:08:02 updated  
        Change return value's meaning as if intersection is not empty

    17-Dec-1993 Fri 14:41:10 updated  
        Add prclDif and compare it correctly

    29-Nov-1993 Mon 19:02:01 created  


Revision History:


--*/

{
    BOOL    IsNULL = FALSE;


    if (prclSrc != prclDest) {

        //
        // For left/top we will set to whichever is larger.
        //

        if (prclDest->left < prclSrc->left) {

            prclDest->left = prclSrc->left;
        }

        if (prclDest->top < prclSrc->top) {

            prclDest->top = prclSrc->top;
        }

        //
        // For right/bottom we will set to whichever is smaller
        //

        if (prclDest->right > prclSrc->right) {

            prclDest->right = prclSrc->right;
        }

        if (prclDest->bottom > prclSrc->bottom) {

            prclDest->bottom = prclSrc->bottom;
        }
    }

    PLOTDBG(DBG_INTERSECTRECTL, ("IntersectRECTL: Dest = (%ld x %ld)",
            prclDest->right-prclDest->left, prclDest->bottom-prclDest->top));

    return((prclDest->right > prclDest->left) &&
           (prclDest->bottom > prclDest->top));
}





BOOL
RotatePaper(
    PSIZEL  pSize,
    PRECTL  pImageArea,
    UINT    RotateMode
    )

/*++

Routine Description:

    This function rotate a paper left 90 degree, right 90 degree or 180 degree
    depends on the RotateMode passed

Arguments:

    pSize       - Pointer to the size of the paper to be rotated

    pImageArea  - Pointer to the RECTL of Imageable area

    RotateMode  - Must be one of RM_L90, RM_R90, RM_180

Return Value:

    No return value, but the pSize, and pImageArea pointed to location will
    be updated.

Author:

    16-Dec-1993 Thu 09:18:33 created  


Revision History:


--*/

{
    SIZEL   Size;
    RECTL   Margin;

    //
    // To be sucessfully rotate the paper to the left 90 degree we must know
    // all four sides margin before we can do anything
    //

    Size          = *pSize;
    Margin.left   = pImageArea->left;
    Margin.top    = pImageArea->top;
    Margin.right  = Size.cx - pImageArea->right;
    Margin.bottom = Size.cy - pImageArea->bottom;

    PLOTASSERT(0, "RotatePaper: cx size too small (%ld)",
                        (Size.cx - Margin.left - Margin.right) > 0, Size.cx);
    PLOTASSERT(0, "RotatePaper: cy size too small (%ld)",
                        (Size.cy - Margin.top - Margin.bottom) > 0, Size.cy);
    PLOTDBG(DBG_ROTPAPER,
            ("RotatePaper(%ld) FROM (%ld x %ld), (%ld, %ld)-(%ld, %ld)",
                        (LONG)RotateMode,
                        pSize->cx, pSize->cy,
                        pImageArea->left,   pImageArea->top,
                        pImageArea->right,  pImageArea->bottom));

    //
    // Now we can pick the right margin/corner for the rotation
    //
    //         cx        Rotate Left 90     Rotate Right 90
    //      +-------+
    //      |   T   |         cy                 cy
    //      |       |    +------------+     +------------+
    //     c|       |    |     R      |     |     L      |
    //     y|       |   c|            |    c|            |
    //      |L     R|   x|            |    x|            |
    //      |       |    |T          B|     |B          T|
    //      |       |    |            |     |            |
    //      |       |    |     L      |     |     R      |
    //      |   B   |    +------------+     +------------+
    //      +-------+
    //

    switch (RotateMode) {

    case RM_L90:

        pSize->cx          = Size.cy;
        pSize->cy          = Size.cx;
        pImageArea->left   = Margin.top;
        pImageArea->top    = Margin.right;
        pImageArea->right  = Size.cy - Margin.bottom;
        pImageArea->bottom = Size.cx - Margin.left;
        break;

    case RM_R90:

        pSize->cx          = Size.cy;
        pSize->cy          = Size.cx;
        pImageArea->left   = Margin.bottom;
        pImageArea->top    = Margin.left;
        pImageArea->right  = Size.cy - Margin.top;
        pImageArea->bottom = Size.cx - Margin.right;
        break;

    case RM_180:

        pImageArea->top    = Margin.bottom;
        pImageArea->bottom = Size.cy - Margin.top;
        break;

    default:

        PLOTERR(("RotatePaper(%ld): Invalid RotateMode passed", RotateMode));
        return(FALSE);
    }

    PLOTDBG(DBG_ROTPAPER,
            ("RotatePaper(%ld) - TO (%ld x %ld), (%ld, %ld)-(%ld, %ld)",
                        (LONG)RotateMode,
                        pSize->cx, pSize->cy,
                        pImageArea->left,   pImageArea->top,
                        pImageArea->right,  pImageArea->bottom));

    return(TRUE);
}





SHORT
GetDefaultPaper(
    PPAPERINFO  pPaperInfo
    )

/*++

Routine Description:

    This function compute the default paper name, size.

Arguments:

    pPaperInfo  - Point to the paper info which will be fill by this function

Return Value:

    It return a SHORT value which specified the standard paper index in as
    DMPAPER_xxx

Author:

    03-Dec-1993 Fri 13:13:42 created  


Revision History:


--*/

{
    SHORT   dmPaperSize;
    HRESULT hr;

    if (pPaperInfo == NULL) {
        return 0;
    }

    pPaperInfo->ImageArea.left =
    pPaperInfo->ImageArea.top  = 0;

    if (IsA4PaperDefault()) {

        dmPaperSize                  = (SHORT)DMPAPER_A4;
        pPaperInfo->Size.cx          =
        pPaperInfo->ImageArea.right  = DMTOSPL(A4_FORM_CX);
        pPaperInfo->Size.cy          =
        pPaperInfo->ImageArea.bottom = DMTOSPL(A4_FORM_CY);

        hr = StringCchCopy(pPaperInfo->Name, CCHOF(pPaperInfo->Name), A4_FORM_NAME);

        PLOTDBG(DBG_DEFPAPER, ("Pick 'A4' paper as default"));

    } else {

        dmPaperSize         = (SHORT)DMPAPER_LETTER;
        pPaperInfo->Size.cx = (LONG)_DefPlotDM.dm.dmPaperWidth;
        pPaperInfo->Size.cy = (LONG)_DefPlotDM.dm.dmPaperLength;

        dmPaperSize                  = (SHORT)DMPAPER_LETTER;
        pPaperInfo->Size.cx          =
        pPaperInfo->ImageArea.right  = DMTOSPL(_DefPlotDM.dm.dmPaperWidth);
        pPaperInfo->Size.cy          =
        pPaperInfo->ImageArea.bottom = DMTOSPL(_DefPlotDM.dm.dmPaperLength);

        hr = StringCchCopy(pPaperInfo->Name, CCHOF(pPaperInfo->Name), _DefPlotDM.dm.dmFormName);

        PLOTDBG(DBG_DEFPAPER, ("Pick 'Letter' paper as default"));
    }

    PLOTDBG(DBG_DEFPAPER, ("SetDefaultPaper: '%ls' (%ld x %ld)",
                pPaperInfo->Name, pPaperInfo->Size.cx, pPaperInfo->Size.cy));

    return(dmPaperSize);
}




VOID
GetDefaultPlotterForm(
    PPLOTGPC    pPlotGPC,
    PPAPERINFO  pPaperInfo
    )

/*++

Routine Description:

    This function set the default loaded paper on the plotter to the first
    form data list in the PCD data file

Arguments:

    pPlotGPC    - Pointer to the GPC data

    pPaperInfo  - Pointer to the paper info to be returned


Return Value:

    TRUE if sucessful, false if failed

Author:

    03-Feb-1994 Thu 11:37:37 created  


Revision History:


--*/

{
    PFORMSRC    pFS;


    if ((pFS = (PFORMSRC)pPlotGPC->Forms.pData) &&
        (pPlotGPC->Forms.Count)) {

        str2Wstr(pPaperInfo->Name, CCHOF(pPaperInfo->Name), pFS->Name);

        pPaperInfo->Size             = pFS->Size;
        pPaperInfo->ImageArea.left   = pFS->Margin.left;
        pPaperInfo->ImageArea.top    = pFS->Margin.top;
        pPaperInfo->ImageArea.right  = pFS->Size.cx - pFS->Margin.right;
        pPaperInfo->ImageArea.bottom = pFS->Size.cy - pFS->Margin.bottom;

    } else {

        PLOTERR(("GetDefaultPlotterForm: No FORM DATA in PCD, used country default"));

        GetDefaultPaper(pPaperInfo);
    }
}



VOID
SetDefaultDMForm(
    PPLOTDEVMODE    pPlotDM,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function set the default form for the PLOTDEVMODE, these includes
    dmPaperSize, dmPaperWidth, dmPaperLength, dmFormName and set pCurForm
    if pointer is not NULL

Arguments:

    pPlotDM     - Pointer to the PLOTDEVMODE data structure

    pCurForm    - pointer to the FORMSIZE data structure to store current
                  default form set by this function

Return Value:

    VOID


Author:

    01-Dec-1993 Wed 13:44:31 created  


Revision History:


--*/

{
    PAPERINFO   PaperInfo;
    HRESULT     hr;

    pPlotDM->dm.dmFields      &= ~DM_PAPER_FIELDS;
    pPlotDM->dm.dmFields      |= (DM_FORMNAME | DM_PAPERSIZE);
    pPlotDM->dm.dmPaperSize    = GetDefaultPaper(&PaperInfo);
    pPlotDM->dm.dmPaperWidth   = SPLTODM(PaperInfo.Size.cx);
    pPlotDM->dm.dmPaperLength  = SPLTODM(PaperInfo.Size.cy);

    hr = StringCchCopy((LPWSTR)pPlotDM->dm.dmFormName, CCHOF(pPlotDM->dm.dmFormName), PaperInfo.Name);

    if (pCurForm) {

        pCurForm->Size      = PaperInfo.Size;
        pCurForm->ImageArea = PaperInfo.ImageArea;
    }
}





VOID
SetDefaultPLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pPlotDM,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function set the default devmode based on the current pPlotGPC

Arguments:

    hPrinter        - Handle to the printer

    pPlotGPC        - our loaded/verified GPC data.

    pwDeviceName    - the device name passed in

    pPlotDM         - Pointer to our ExtDevMode

    pCurForm        - Pointer to the FORMSIZE data structure which will be
                      updated if the pointer is not NULL, the final result of
                      the form size/imagable area selected by the user will
                      be written to here. the form name will be in
                      pPlotDM->dmFormName.

Return Value:

    VOID


Author:

    14-Dec-1993 Tue 20:21:48 updated  
        Update the dmScale based on maximum the device can support

    06-Dec-1993 Mon 12:49:52 updated  
        make sure we turn off the DM_xxx bits if one of those is not valid or
        supported in current plotter

    16-Nov-1993 Tue 13:49:27 created  


Revision History:


--*/

{
    WCHAR   *pwchDeviceName = NULL;
    ULONG   ulStrLen = 0;

    //
    // Device name including NULL terminator
    // must be equal or shorter than CCHDEVICENAME.
    // PREFIX doesn' take this assumption. Buffer size needs to be flexible and
    // should not be on stack.
    //
    if (pwDeviceName) {

        ulStrLen = wcslen(pwDeviceName);

        //
        // Allocate buffer to hold pwDeviceName including null terminator.
        // Make sure that pwDeviceName has a device name.
        //
        if (0 == ulStrLen ||
            !(pwchDeviceName = (WCHAR*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (ulStrLen + 1) * sizeof(WCHAR))))
        {
            PLOTERR(("SetDefaultPLOTDM: memory allocaton failed.\n"));

            //
            // Make sure that pPlotGPC->DeviceName has a null terminator.
            //
            pPlotGPC->DeviceName[0] = (BYTE)NULL;
        }
        else
        {

            _WCPYSTR(pwchDeviceName, pwDeviceName, ulStrLen + 1);

            //
            // Make sure the PlotGPC's device name is ssync with the pDeviceName
            // passed.
            // String length must be equal or shorter than CCHDEVICENAME.
            // DEVMODE's device name and pPlotGPC->DeviceName can't hold a sting
            // longer than CCHDEVICENAME.
            //
            if (ulStrLen + 1 > CCHDEVICENAME)
            {
                PLOTERR(("SetDefaultPLOTDM: DeviceName is longer than buffer size.\n"));
            }
            else
            {
                WStr2Str(pPlotGPC->DeviceName, CCHOF(pPlotGPC->DeviceName), pwchDeviceName);
            }
        }

        PLOTDBG(DBG_DEFDEVMODE, ("PlotGPC DeviceName=%hs\npwDeviceName=%ls",
                            pPlotGPC->DeviceName, pwDeviceName));

    } else {

        PLOTERR(("No DeviceName passed, using GPC's '%hs'",
                                                    pPlotGPC->DeviceName));
        ulStrLen = strlen(pPlotGPC->DeviceName);

        //
        // Allocate buffer to hold pwDeviceName including null terminator.
        // Make sure that pwDeviceName has a device name.
        //
        if (0 == ulStrLen ||
            !(pwchDeviceName = (WCHAR*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (ulStrLen + 1) * sizeof(WCHAR))))
        {
            PLOTERR(("SetDefaultPLOTDM: memory allocaton failed.\n"));
        }
        else
        {
            str2Wstr(pwchDeviceName, ulStrLen + 1, pPlotGPC->DeviceName);
        }
    }

    //
    // Make a default copy first then copy device name down
    //

    CopyMemory(pPlotDM, &_DefPlotDM, sizeof(PLOTDEVMODE));

    if (pwchDeviceName)
    {
        WCPYFIELDNAME(pPlotDM->dm.dmDeviceName, pwchDeviceName);
        LocalFree(pwchDeviceName);
    }
    else
    {
        pPlotDM->dm.dmDeviceName[0] = (WCHAR)NULL;
    }

    //
    // We must turn off the DM_xxx bits in dmFields if we do not support it,
    // look at default fields we copy down then update it
    //

    if (pPlotGPC->MaxScale) {

        if ((WORD)pPlotDM->dm.dmScale > pPlotGPC->MaxScale) {

            pPlotDM->dm.dmScale = (SHORT)pPlotGPC->MaxScale;
        }

    } else {

        pPlotDM->dm.dmFields &= ~DM_SCALE;
    }

    if (pPlotGPC->MaxCopies <= 1) {

        pPlotDM->dm.dmFields &= ~DM_COPIES;
    }

    if (!(pPlotGPC->MaxQuality)) {

        pPlotDM->dm.dmFields &= ~DM_PRINTQUALITY;
    }

    //
    // DEFAULT 50% quality for byte align plotter (DJ 600) to do ROP right
    //

    if (pPlotGPC->Flags & PLOTF_RASTERBYTEALIGN) {

        pPlotDM->dm.dmPrintQuality = DMRES_LOW;

        PLOTWARN(("SetDefaultPLOTDM: HACK Default Qaulity = DMRES_LOW"));
    }

    if (!(pPlotGPC->Flags & PLOTF_COLOR)) {

        if (pPlotGPC->Flags & PLOTF_RASTER) {

            pPlotDM->dm.dmFields &= ~DM_COLOR;
            pPlotDM->dm.dmColor   = DMCOLOR_MONOCHROME;

        } else {

            PLOTASSERT(0,
                       "SetDefaultPLOTDM: The Pen Ploter CANNOT be MONO.",
                       (pPlotGPC->Flags & PLOTF_COLOR), 0);

            pPlotGPC->Flags |= PLOTF_COLOR;
        }
    }

    //
    // Set default form name based on the country
    //

    SetDefaultDMForm(pPlotDM, pCurForm);

}





DWORD
MergePLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    PPLOTDEVMODE    pPlotDMFrom,
    PPLOTDEVMODE    pPlotDMTo,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function merge and validate the pPlotDMTo from pPlotDMFrom. The
    PlotDMOut must valid


Arguments:

    hPrinter        - Handle to the printer to be checked

    pPlotGPC        - The plotter's GPC data loaded from the file

    pPlotDMFrom     - pointer to the input PLOTDEVMODE data structure, if can
                      be NULL

    pPlotDMTo       - Pointer to the output PLOTDEVMODE data structure, if
                      pPlotDMFrom is NULL then a default PLOTDEVMODE is
                      returned

    pCurForm        - Pointer to the FORMSIZE data structure which will be
                      updated if the pointer is not NULL, the final result of
                      the form size/imagable area selected by the user will
                      be written to here. the form name will be in
                      pPlotDM->dmFormName.

Return Value:

    the return value is a DWORD dmField error code which specified dmFields
    are invalid (DM_xxxxx in wingdi.h) if the return value has any DM_INV_xxx
    bits set then it should raised an error to the user.

    if return value is 0 then function sucessful


Author:

    25-Oct-1994 Tue 13:32:18 created  


Revision History:


--*/

{
    PLOTDEVMODE     PlotDMIn;
    ENUMFORMPARAM   EFP;
    DWORD           dmErrFields = 0;
    SIZEL           PaperSize;

    //
    // First: set the default PLOTDEVMODE for the output then from there
    //        validate/settting from input devmode, if pwDeviceName passed as
    //        NULL then it assume that pPlotDMTo alreay set and validated
    //
    // If we have invalid input devmode then this it is
    //

    if ((!pPlotDMFrom) || (!pPlotDMTo) || (!pPlotGPC)) {

        return(0);
    }

    //
    // Do some conversion here if necessary, first, copy the output one
    //

    CopyMemory(&PlotDMIn, pPlotDMTo, sizeof(PLOTDEVMODE));
    ConvertDevmode((PDEVMODE) pPlotDMFrom, (PDEVMODE) &PlotDMIn);


    PLOTDBG(DBG_SHOWDEVMODE,
                ("--------------- Input DEVMODE Setting -------------------"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmDeviceName = %ls",
                (DWORD_PTR)PlotDMIn.dm.dmDeviceName));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmSpecVersion = %04lx",
                (DWORD)PlotDMIn.dm.dmSpecVersion));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmDriverVersion = %04lx",
                (DWORD)PlotDMIn.dm.dmDriverVersion));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmSize = %0ld (%ld)",
                (DWORD)PlotDMIn.dm.dmSize, sizeof(DEVMODE)));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmDriverExtra = %ld (%ld)",
                (DWORD)PlotDMIn.dm.dmDriverExtra, PLOTDM_PRIV_SIZE));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmFields = %08lx",
                (DWORD)PlotDMIn.dm.dmFields));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmOrientation = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmOrientation,
                (PlotDMIn.dm.dmFields & DM_ORIENTATION) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPaperSize = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPaperSize,
                (PlotDMIn.dm.dmFields & DM_PAPERSIZE) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPaperLength = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPaperLength,
                (PlotDMIn.dm.dmFields & DM_PAPERLENGTH) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPaperWidth = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPaperWidth,
                (PlotDMIn.dm.dmFields & DM_PAPERWIDTH) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmScale = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmScale,
                (PlotDMIn.dm.dmFields & DM_SCALE) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmCopies = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmCopies,
                (PlotDMIn.dm.dmFields & DM_COPIES) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmPrintQuality = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmPrintQuality,
                (PlotDMIn.dm.dmFields & DM_PRINTQUALITY) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmColor = %ld (%hs)",
                (DWORD)PlotDMIn.dm.dmColor,
                (PlotDMIn.dm.dmFields & DM_COLOR) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: dmFormName = %ls (%hs)",
                (DWORD_PTR)PlotDMIn.dm.dmFormName,
                (PlotDMIn.dm.dmFields & DM_FORMNAME) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: Fill Truetype Font = %hs",
                (PlotDMIn.Flags & PDMF_FILL_TRUETYPE) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("ValidateSetPLOTDM: Plot On the Fly = %hs",
                (PlotDMIn.Flags & PDMF_PLOT_ON_THE_FLY) ? "ON" : "OFF"));
    PLOTDBG(DBG_SHOWDEVMODE,
                ("---------------------------------------------------------"));

    //
    // Statring checking the dmFields, *** REMEMBER: The orientation must
    // check before the checking the paper/form
    //

    if (PlotDMIn.dm.dmFields & DM_ORIENTATION) {

        switch (PlotDMIn.dm.dmOrientation) {

        case DMORIENT_PORTRAIT:
        case DMORIENT_LANDSCAPE:

            pPlotDMTo->dm.dmOrientation  = PlotDMIn.dm.dmOrientation;
            pPlotDMTo->dm.dmFields      |= DM_ORIENTATION;
            break;

        default:

            PLOTERR(("ValidatePLOTDM: Invalid dmOrientation = %ld",
                                            (LONG)PlotDMIn.dm.dmOrientation));
            dmErrFields |= DM_ORIENTATION;
            break;
        }
    }

    //
    // Validate form name so we have correct data, assume error first
    //

    dmErrFields |= (DWORD)(PlotDMIn.dm.dmFields & DM_PAPER_FIELDS);

    if (((PlotDMIn.dm.dmFields & DM_PAPER_CUSTOM) == DM_PAPER_CUSTOM)   &&
        ((PlotDMIn.dm.dmPaperSize == DMPAPER_USER)                      ||
         (PlotDMIn.dm.dmPaperSize == 0))                                &&
        (PaperSize.cx = DMTOSPL(PlotDMIn.dm.dmPaperWidth))              &&
        (PaperSize.cy = DMTOSPL(PlotDMIn.dm.dmPaperLength))             &&
        (PaperSize.cx >= MIN_SPL_FORM_CX)                                   &&
        (PaperSize.cy >= MIN_SPL_FORM_CY)                                   &&
        (((PaperSize.cx <= pPlotGPC->DeviceSize.cx)              &&
          (PaperSize.cy <= pPlotGPC->DeviceSize.cy))        ||
         ((PaperSize.cy <= pPlotGPC->DeviceSize.cx)              &&
          (PaperSize.cx <= pPlotGPC->DeviceSize.cy)))) {

        //
        // First choice, this is what the caller wants, we need to validate
        // for this device, since the size may be larger then device can
        // handle
        //

        pPlotDMTo->dm.dmPaperWidth   = PlotDMIn.dm.dmPaperWidth;
        pPlotDMTo->dm.dmPaperLength  = PlotDMIn.dm.dmPaperLength;
        pPlotDMTo->dm.dmFields      &= ~DM_PAPER_FIELDS;
        pPlotDMTo->dm.dmFields      |= DM_PAPER_CUSTOM;
        pPlotDMTo->dm.dmPaperSize    = DMPAPER_USER;
        pPlotDMTo->dm.dmFormName[0]  = L'\0';

        if (pCurForm) {

            //
            // This one is full imageable area as the widht/height
            //

            pCurForm->ImageArea.left =
            pCurForm->ImageArea.top  = 0;

            pCurForm->Size.cx          =
            pCurForm->ImageArea.right  = PaperSize.cx;
            pCurForm->Size.cy          =
            pCurForm->ImageArea.bottom = PaperSize.cy;
        }

        dmErrFields &= ~DM_PAPER_FIELDS;    // Fine, no error

        PLOTDBG(DBG_CURFORM,("ValidateSetPLOTDM: FORM=USER <%ld> (%ld x %ld)",
                    PlotDMIn.dm.dmPaperSize, PaperSize.cx, PaperSize.cy));

    } else if ((PlotDMIn.dm.dmFields & (DM_PAPERSIZE | DM_FORMNAME))    &&
               (EFP.pPlotDM = pPlotDMTo)                                    &&
               (EFP.pPlotGPC = pPlotGPC)                                    &&
               (PlotEnumForms(hPrinter, NULL, &EFP))) {

        FORM_INFO_1 *pFI1;
        SHORT       sPaperSize;
        BOOL        Found = FALSE;

        //
        // Firstable check sPaperSize index and if not found then check formname
        //

        if ((PlotDMIn.dm.dmFields & DM_PAPERSIZE)                       &&
            ((sPaperSize = PlotDMIn.dm.dmPaperSize) >= DMPAPER_FIRST)    &&
            (sPaperSize <= (SHORT)EFP.Count)                                 &&
            (pFI1 = EFP.pFI1Base + (sPaperSize - DMPAPER_FIRST))             &&
            (pFI1->Flags & FI1F_VALID_SIZE)) {

            //
            // Whu..., this guy really pick a right index
            //

            Found = TRUE;

            PLOTDBG(DBG_CURFORM,("ValidateSetPLOTDM: Fount dmPaperSize=%ld",
                                    PlotDMIn.dm.dmPaperSize));

        } else if (PlotDMIn.dm.dmFields & DM_FORMNAME) {

            //
            // Now go through all the formname trouble
            //

            pFI1      = EFP.pFI1Base;
            sPaperSize = DMPAPER_FIRST;

            while (EFP.Count--) {

                if ((pFI1->Flags & FI1F_VALID_SIZE) &&
                    (!wcscmp(pFI1->pName, PlotDMIn.dm.dmFormName))) {

                    PLOTDBG(DBG_CURFORM,("ValidateSetPLOTDM: Found dmFormName=%s",
                                            PlotDMIn.dm.dmFormName));

                    Found = TRUE;

                    break;
                }

                ++sPaperSize;
                ++pFI1;
            }
        }

        if (Found) {

            pPlotDMTo->dm.dmFields      &= ~DM_PAPER_FIELDS;
            pPlotDMTo->dm.dmFields      |= (DM_FORMNAME | DM_PAPERSIZE);
            pPlotDMTo->dm.dmPaperSize    = sPaperSize;
            pPlotDMTo->dm.dmPaperWidth   = SPLTODM(pFI1->Size.cx);
            pPlotDMTo->dm.dmPaperLength  = SPLTODM(pFI1->Size.cy);

            WCPYFIELDNAME(pPlotDMTo->dm.dmFormName, pFI1->pName);

            PLOTDBG(DBG_CURFORM,("FI1 [%ld]: (%ld x %ld), (%ld, %ld)-(%ld, %ld)",
                        (LONG)pPlotDMTo->dm.dmPaperSize,
                        pFI1->Size.cx, pFI1->Size.cy,
                        pFI1->ImageableArea.left,  pFI1->ImageableArea.top,
                        pFI1->ImageableArea.right, pFI1->ImageableArea.bottom));

            if (pCurForm) {

                pCurForm->Size      = pFI1->Size;
                pCurForm->ImageArea = pFI1->ImageableArea;
            }

            dmErrFields &= ~DM_PAPER_FIELDS;    // Fine, no error
        }

        //
        // Free up the memory used
        //

        LocalFree((HLOCAL)EFP.pFI1Base);
    }

    if ((PlotDMIn.dm.dmFields & DM_SCALE) &&
        (pPlotGPC->MaxScale)) {

        if ((PlotDMIn.dm.dmScale > 0) &&
            ((WORD)PlotDMIn.dm.dmScale <= pPlotGPC->MaxScale)) {

            pPlotDMTo->dm.dmScale   = PlotDMIn.dm.dmScale;
            pPlotDMTo->dm.dmFields |= DM_SCALE;

        } else {

            PLOTERR(("ValidatePLOTDM: Invalid dmScale = %ld [%ld]",
                    (LONG)PlotDMIn.dm.dmScale, (LONG)pPlotGPC->MaxScale));
            dmErrFields |= DM_SCALE;
        }
    }

    if (PlotDMIn.dm.dmFields & DM_COPIES) {

        if ((PlotDMIn.dm.dmCopies > 0) &&
            ((LONG)PlotDMIn.dm.dmCopies <= (LONG)pPlotGPC->MaxCopies)) {

            pPlotDMTo->dm.dmCopies  = PlotDMIn.dm.dmCopies;
            pPlotDMTo->dm.dmFields |= DM_COPIES;

        } else {

            PLOTERR(("ValidatePLOTDM: Invalid dmCopies = %ld [%ld]",
                    (LONG)PlotDMIn.dm.dmCopies, (LONG)pPlotGPC->MaxCopies));
            dmErrFields |= DM_COPIES;
        }
    }

    if (PlotDMIn.dm.dmFields & DM_PRINTQUALITY) {

        dmErrFields |= DM_PRINTQUALITY;     // assume error, proven otherwise

        if (pPlotGPC->MaxQuality) {

            switch (PlotDMIn.dm.dmPrintQuality) {

            case DMRES_DRAFT:
            case DMRES_LOW:
            case DMRES_MEDIUM:
            case DMRES_HIGH:

                dmErrFields                   &= ~DM_PRINTQUALITY;
                pPlotDMTo->dm.dmPrintQuality  = PlotDMIn.dm.dmPrintQuality;
                pPlotDMTo->dm.dmFields       |= DM_PRINTQUALITY;
                break;
            }
        }

        if (dmErrFields & DM_PRINTQUALITY) {

            PLOTERR(("ValidatePLOTDM: Invalid dmPrintQuality = %ld [%ld]",
                                        (LONG)PlotDMIn.dm.dmPrintQuality,
                                        (LONG)pPlotGPC->MaxQuality));
        }
    }

    if (PlotDMIn.dm.dmFields & DM_COLOR) {

        dmErrFields |= DM_COLOR;            // assume error, proven otherwise

        if (pPlotGPC->Flags & PLOTF_COLOR) {

            switch (PlotDMIn.dm.dmColor) {

            case DMCOLOR_MONOCHROME:

                if (!(pPlotGPC->Flags & PLOTF_RASTER)) {

                    PLOTERR(("ValidatePLOTDM: Cannot Set Pen Plotter to MONO"));
                    break;
                }

            case DMCOLOR_COLOR:

                pPlotDMTo->dm.dmColor   = PlotDMIn.dm.dmColor;
                pPlotDMTo->dm.dmFields |= DM_COLOR;
                dmErrFields             &= ~DM_COLOR;
                break;
            }

        } else if (PlotDMIn.dm.dmColor == DMCOLOR_MONOCHROME) {

            dmErrFields &= ~DM_COLOR;
        }

        if (dmErrFields & DM_COLOR) {

            PLOTERR(("ValidatePLOTDM: Invalid dmColor = %ld [%hs]",
                    (LONG)PlotDMIn.dm.dmColor,
                    (pPlotGPC->Flags & PLOTF_COLOR) ? "COLOR" : "MONO"));
        }
    }

    //
    // Any other dmFields we just skip because we do not have that caps, now
    // check if they have correct EXTDEVMODE stuff
    //

    if ((PlotDMIn.dm.dmDriverExtra == PLOTDM_PRIV_SIZE) &&
        (PlotDMIn.PrivID == PLOTDM_PRIV_ID)             &&
        (PlotDMIn.PrivVer == PLOTDM_PRIV_VER)) {

        pPlotDMTo->Flags = (DWORD)(PlotDMIn.Flags & PDMF_ALL_BITS);
        pPlotDMTo->ca    = PlotDMIn.ca;

        if (pPlotGPC->Flags & PLOTF_RASTER) {

            pPlotDMTo->Flags |= PDMF_FILL_TRUETYPE;

        } else {

            //
            // Non raster device does not have plot on the fly mode
            //

            pPlotDMTo->Flags &= ~PDMF_PLOT_ON_THE_FLY;
        }

        if (!ValidateColorAdj(&(pPlotDMTo->ca))) {

            dmErrFields |= DM_INV_PLOTPRIVATE;

            PLOTERR(("ValidatePLOTDM: Invalid coloradjusment data"));
        }
    }

    return(dmErrFields);

}




DWORD
ValidateSetPLOTDM(
    HANDLE          hPrinter,
    PPLOTGPC        pPlotGPC,
    LPWSTR          pwDeviceName,
    PPLOTDEVMODE    pPlotDMIn,
    PPLOTDEVMODE    pPlotDMOut,
    PFORMSIZE       pCurForm
    )

/*++

Routine Description:

    This function set and validate the pPlotDMOut from pPlotDMIn
    (if not null and valid)

Arguments:

    hPrinter        - Handle to the printer to be checked

    pPlotGPC        - The plotter's GPC data loaded from the file

    pwDeviceName    - Device Name to be put into dmDeviceName, if NULL then
                      the device name is set from pPlotGPC->DeviceName

    pPlotDMIn       - pointer to the input PLOTDEVMODE data structure, if can
                      be NULL

    pPlotDMOut      - Pointer to the output PLOTDEVMODE data structure, if
                      pPlotDMIn is NULL then a default PLOTDEVMODE is returned

    pCurForm        - Pointer to the FORMSIZE data structure which will be
                      updated if the pointer is not NULL, the final result of
                      the form size/imagable area selected by the user will
                      be written to here. the form name will be in
                      pPlotDM->dmFormName.

Return Value:

    the return value is a DWORD dmField error code which specified dmFields
    are invalid (DM_xxxxx in wingdi.h) if the return value has any DM_INV_xxx
    bits set then it should raised an error to the user.

    if return value is 0 then function sucessful

Author:

    23-Nov-1993 Tue 10:08:50 created  

    15-Dec-1993 Wed 21:27:52 updated  
        Fixed bug which compare dmPaperWidth/Length to MIN_SPL_FORM_CX

    18-Dec-1993 Sat 03:57:24 updated  
        Fixed bug which reset dmFields when we checking DM_PAPERxxx and
        DM_FORMNAME, this turn off DM_ORIENTATION fields which let the
        orientation setting never stick.

        Also change how this fucntion set the paper fields, this function now
        only set DM_FORMNAME upon returned if the dmPaperSize getting larger
        then DMPAPER_LAST, otherwise it set DM_FORMNAME | DM_PAPERSIZE

    12-Apr-1994 Tue 15:07:24 updated  
        Make smaller spec version printable

    25-Oct-1994 Tue 13:41:03 updated  
        Change to have default as current Printer Properties setting first,


Revision History:


--*/

{
    DWORD   dmErrFields = 0;


    if (NULL == pPlotDMOut || NULL == pPlotGPC)
    {
        PLOTASSERT(1, "ValidatePLOTDM: NULL pPlotDMOut", pPlotDMOut, 0);
        PLOTASSERT(1, "ValidatePLOTDM: NULL pPlotGPC", pPlotGPC, 0);
        return 0xFFFFFFFF;
    }

    if ((pPlotDMOut) || (pPlotGPC)) {

        PPRINTER_INFO_2 pPrinter2 = NULL;
        DWORD           cbNeed;
        DWORD           cbRet;


        //
        // First: set the default PLOTDEVMODE for the output then from there
        //        validate/settting from input devmode, if pwDeviceName passed
        //        as NULL then it assume that pPlotDMOut alreay set and
        //        validated
        //

        if (pwDeviceName) {

            SetDefaultPLOTDM(hPrinter,
                             pPlotGPC,
                             pwDeviceName,
                             pPlotDMOut,
                             pCurForm);

            PLOTDBG(DBG_DEFDEVMODE,
                    ("ValidateSetPLOTDM: Set Default PLOTDM DeviceName=%ls", pwDeviceName));
        }

        //
        // Now see if we can get the current printman devmode setting as default
        //

        cbNeed =
        cbRet  = 0;

        if ((!xGetPrinter(hPrinter, 2, NULL, 0, &cbNeed))                   &&
            (xGetLastError() == ERROR_INSUFFICIENT_BUFFER)                  &&
            (pPrinter2 = LocalAlloc(LMEM_FIXED, cbNeed))                    &&
            (xGetPrinter(hPrinter, 2, (LPBYTE)pPrinter2, cbNeed, &cbRet))   &&
            (cbNeed == cbRet)                                               &&
            (pPrinter2->pDevMode)) {

            PLOTDBG(DBG_DEFDEVMODE, ("ValidateSetPLOTDM: Got the PrintMan DEVMODE"));

            dmErrFields = MergePLOTDM(hPrinter,
                                      pPlotGPC,
                                      (PPLOTDEVMODE)pPrinter2->pDevMode,
                                      pPlotDMOut,
                                      pCurForm);

        } else {

            PLOTWARN(("ValidateSetPLOTDM: CANNOT get the PrintMan's DEVMODE"));
            PLOTWARN(("pPrinter2=%08lx, pDevMode=%08lx, cbNeed=%ld, cbRet=%ld, LastErr=%ld",
                        pPrinter2, (pPrinter2) ? pPrinter2->pDevMode : 0,
                        cbNeed, cbRet, xGetLastError()));
        }

        if (pPrinter2) {

            LocalFree((HLOCAL)pPrinter2);
        }

        //
        // Now the pPlotDMOut is validated, merge it with user's request
        //

        if (pPlotDMIn) {

            dmErrFields = MergePLOTDM(hPrinter,
                                      pPlotGPC,
                                      pPlotDMIn,
                                      pPlotDMOut,
                                      pCurForm);
        }
    }

    return(dmErrFields);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\sources.inc ===
SOURCES=..\plotdbg.c    \
        ..\readgpc.c    \
        ..\widechar.c   \
        ..\file.c       \
        ..\forms.c      \
        ..\regdata.c    \
        ..\plotdm.c     \
        ..\drvinfo.c    \
        ..\cachegpc.c   \
        ..\devmode.c    \
        ..\halftone.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\regdata.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    regdata.c


Abstract:

    This module contains all registry data save/retrieve function for the
    printer properties


Author:

    30-Nov-1993 Tue 00:17:47 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgRegData

#define DBG_GETREGDATA      0x00000001
#define DBG_SETREGDATA      0x00000002

DEFINE_DBGVAR(0);


//
// Local definition
//

typedef struct _PLOTREGKEY {
        LPWSTR  pwKey;
        DWORD   Size;
        } PLOTREGKEY, *PPLOTREGKEY;

PLOTREGKEY  PlotRegKey[] = {

        { L"ColorInfo",     sizeof(COLORINFO)   },
        { L"DevPelsDPI",    sizeof(DWORD)       },
        { L"HTPatternSize", sizeof(DWORD)       },
        { L"InstalledForm", sizeof(PAPERINFO)   },
        { L"PtrPropData",   sizeof(PPDATA)      },
        { L"IndexPenData",  sizeof(BYTE)        },
        { L"PenData",       sizeof(PENDATA)     }
    };


#define MAX_PEN_DIGITS      6


LPWSTR
GetPenDataKey(
    LPWSTR  pwBuf,
    size_t  cchBuf,
    WORD    PenNum
    )

/*++

Routine Description:

    This fucntion composed the PenData%ld string as wsprintf does


Arguments:

    pwBuf   - Where data to be stored

    PenNum  - Pen number to be appended


Return Value:

    VOID


Author:

    24-Oct-1995 Tue 15:06:17 created  


Revision History:


--*/

{
    LPWSTR  pwSrc;
    LPWSTR  pwDst;
    WCHAR   wNumBuf[MAX_PEN_DIGITS + 1];
    size_t  cchDst;

    //
    // Fristable copy the string
    //

    pwSrc = PlotRegKey[PRKI_PENDATA1].pwKey;
    pwDst = pwBuf;

    //while (*pwDst++ = *pwSrc++);
    if (SUCCEEDED(StringCchCopyW(pwDst, cchBuf, pwSrc)) &&
        SUCCEEDED(StringCchLengthW(pwDst, cchBuf, &cchDst)))
    {
	pwDst += cchDst;
        cchBuf -= cchDst;
    }
    else
    {
        return NULL;
    }

    //
    // We need to back one, since we also copy the NULL
    //

    --pwDst;
    ++cchBuf;

    //
    // conver the number to string, remember the 0 case and always end with
    // a NULL
    //

    pwSrc  = &wNumBuf[MAX_PEN_DIGITS];
    *pwSrc = (WCHAR)0;

    do {

        *(--pwSrc)  = (WCHAR)((PenNum % 10) + L'0');

    } while (PenNum /= 10);

    //
    // Copy the number string now
    //

    //while (*pwDst++ = *pwSrc++);
    if (!SUCCEEDED(StringCchCopyW(pwDst, cchBuf, pwSrc)))
    {
        return NULL;
    }

    return(pwBuf);
}



BOOL
GetPlotRegData(
    HANDLE  hPrinter,
    LPBYTE  pData,
    DWORD   RegIdx
    )

/*++

Routine Description:

    This function retrieve from registry to the pData

Arguments:

    hPrinter    - Handle to the printer interested

    pData       - Pointer to the data area buffer, it must large enough

    RegIdx      - One of the PRKI_xxxx in LOWORD(Index), HIWORD(Index)
                  specified total count for the PENDATA set


Return Value:

    TRUE if sucessful, FALSE if failed,


Author:

    06-Dec-1993 Mon 22:22:47 created  

    10-Dec-1993 Fri 01:13:14 updated  
        Fixed nesty problem in spooler of GetPrinterData which if we passed
        a pbData and cb but if it cannot get any data then it will clear all
        our buffer, this is not we expected (we expected it just return error
        rather clear our buffer).  Now we do extended test before we really
        go get the data. The other problem is, if we set pbData = NULL then
        spooler always have excption happened even we pass &cb as NULL also.


Revision History:


--*/

{
    PPLOTREGKEY pPRK;
    LONG        lRet;
    DWORD       cb;
    DWORD       Type;
    WCHAR       wBuf[32];
    PLOTREGKEY  PRK;
    UINT        Index;


    Index = LOWORD(RegIdx);

    PLOTASSERT(0, "GetPlotRegData: Invalid PRKI_xxx Index %ld",
                                Index <= PRKI_LAST, Index);


    if (Index >= PRKI_PENDATA1) {

        UINT    cPenData;

        if ((cPenData = (UINT)HIWORD(RegIdx)) >= MAX_PENPLOTTER_PENS) {

            PLOTERR(("GetPlotRegData: cPenData too big %ld (Max=%ld)",
                                    cPenData, MAX_PENPLOTTER_PENS));

            cPenData = MAX_PENPLOTTER_PENS;
        }

        PRK.pwKey = GetPenDataKey(wBuf, CCHOF(wBuf), (WORD)(Index - PRKI_PENDATA1 + 1));
        PRK.Size  = (DWORD)sizeof(PENDATA) * (DWORD)cPenData;
        pPRK      = &PRK;

    } else {

        pPRK = (PPLOTREGKEY)&PlotRegKey[Index];
    }

    //
    // We must do following sequence or if an error occurred then the pData
    // will be filled with ZEROs
    //
    //  1. Set Type/cb to invalid value
    //  1. query the type/size of the keyword, (if more data available)
    //  2. and If size is exact as we want
    //  3. and if the type is as we want (REG_BINARY)
    //  4. assume data valid then query it
    //

    Type = 0xffffffff;
    cb   = 0;

    if ((lRet = xGetPrinterData(hPrinter,
                               pPRK->pwKey,
                               &Type,
                               (LPBYTE)pData,
                               0,
                               &cb)) != ERROR_MORE_DATA) {

        if (lRet == ERROR_FILE_NOT_FOUND) {

            PLOTWARN(("GetPlotRegData: GetPrinterData(%ls) not found",
                     pPRK->pwKey));

        } else {

            PLOTERR(("GetPlotRegData: 1st GetPrinterData(%ls) failed, Error=%ld",
                                pPRK->pwKey, lRet));
        }

    } else if (cb != pPRK->Size) {

        PLOTERR(("GetPlotRegData: GetPrinterData(%ls) Size != %ld (%ld)",
                    pPRK->pwKey, pPRK->Size, cb));

    } else if (Type != REG_BINARY) {

        PLOTERR(("GetPlotRegData: GetPrinterData(%ls) Type != REG_BINARY (%ld)",
                    pPRK->pwKey, Type));

    } else if ((lRet = xGetPrinterData(hPrinter,
                                      pPRK->pwKey,
                                      &Type,
                                      (LPBYTE)pData,
                                      pPRK->Size,
                                      &cb)) == NO_ERROR) {

        PLOTDBG(DBG_GETREGDATA, ("READ '%ws' REG Data: Type=%ld, %ld bytes",
                                        pPRK->pwKey, Type, cb));
        return(TRUE);

    } else {

        PLOTERR(("GetPlotRegData: 2nd GetPrinterData(%ls) failed, Error=%ld",
                                    pPRK->pwKey, lRet));
    }

    return(FALSE);
}



BOOL
UpdateFromRegistry(
    HANDLE      hPrinter,
    PCOLORINFO  pColorInfo,
    LPDWORD     pDevPelsDPI,
    LPDWORD     pHTPatSize,
    PPAPERINFO  pCurPaper,
    PPPDATA     pPPData,
    LPBYTE      pIdxPlotData,
    DWORD       cPenData,
    PPENDATA    pPenData
    )

/*++

Routine Description:

    This function take hPrinter and read the printer properties from the
    registry, if sucessful then it update to the pointer supplied

Arguments:

    hPrinter        - The printer it interested

    pColorInfo      - Pointer to the COLORINFO data structure

    pDevPelsDPI     - Pointer to the DWORD for Device Pels per INCH

    pHTPatSize      - Poineer to the DWORD for halftone patterns size

    pCurPaper       - Pointer to the PAPERINFO data structure for update

    pPPData         - Pointer to the PPDATA data structure

    pIdxPlotData    - Pointer to the BYTE which have current PlotData index

    cPenData        - count of PENDATA to be updated

    pPenData        - Pointer to the PENDATA data structure


Return Value:

    return TRUE if it read sucessful from the registry else FALSE, for each of
    the data pointer passed it will try to read from registry, if a NULL
    pointer is passed then that registry is skipped.

    if falied, the pCurPaper will be set to default

Author:

    30-Nov-1993 Tue 14:54:33 created  

    02-Feb-1994 Wed 01:40:07 updated  
        Fixed &pDevPelsDPI, &pHTPatSize typo to pDevPelsDPI, pHTPatSize.

    19-May-1994 Thu 18:09:06 updated  
        Do not save back if something go wrong


Revision History:


--*/

{
    BOOL    Ok = TRUE;
    BYTE    bData;


    //
    // In turn get each of the data from registry, the GetPlotRegData will
    // not update the data if read failed
    //

    if (pColorInfo) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pColorInfo, PRKI_CI)) {

            Ok = FALSE;
        }
    }

    if (pDevPelsDPI) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pDevPelsDPI, PRKI_DEVPELSDPI)) {

            Ok = FALSE;
        }
    }

    if (pHTPatSize) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pHTPatSize, PRKI_HTPATSIZE)) {

            Ok = FALSE;
        }
    }

    if (pCurPaper) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pCurPaper, PRKI_FORM)) {

            Ok = FALSE;
        }
    }

    if (pPPData) {

        if (!GetPlotRegData(hPrinter, (LPBYTE)pPPData, PRKI_PPDATA)) {

            Ok = FALSE;
        }

        pPPData->Flags &= PPF_ALL_BITS;
    }

    if (pIdxPlotData) {

        if ((!GetPlotRegData(hPrinter, &bData, PRKI_PENDATA_IDX)) ||
            (bData >= PRK_MAX_PENDATA_SET)) {

            bData = 0;
            Ok    = FALSE;
        }

        *pIdxPlotData = bData;
    }

    if ((cPenData) && (pPenData)) {

        WORD    IdxPen;

        //
        // First is get the current pendata selection index
        //

        if ((IdxPen = LOWORD(cPenData)) >= PRK_MAX_PENDATA_SET) {

            if (!pIdxPlotData) {

                if ((!GetPlotRegData(hPrinter, &bData, PRKI_PENDATA_IDX)) ||
                    (bData >= PRK_MAX_PENDATA_SET)) {

                    bData = 0;
                }
            }

            IdxPen = (WORD)bData;
        }

        cPenData = MAKELONG(IdxPen + PRKI_PENDATA1, HIWORD(cPenData));

        if (!GetPlotRegData(hPrinter, (LPBYTE)pPenData, cPenData)) {

            Ok = FALSE;
        }
    }

    return(Ok);
}


#ifdef UMODE


BOOL
SetPlotRegData(
    HANDLE  hPrinter,
    LPBYTE  pData,
    DWORD   RegIdx
    )

/*++

Routine Description:

    This function save pData to to the registry

Arguments:

    hPrinter    - Handle to the printer interested

    pData       - Pointer to the data area buffer, it must large enough

    RegIdx      - One of the PRKI_xxxx in LOWORD(Index), HIWORD(Index)
                  specified total count for the PENDATA set

Return Value:

    TRUE if sucessful, FALSE if failed,

Author:

    06-Dec-1993 Mon 22:25:55 created  


Revision History:


--*/

{
    PPLOTREGKEY pPRK;
    WCHAR       wBuf[32];
    PLOTREGKEY  PRK;
    UINT        Index;


    Index = (UINT)LOWORD(RegIdx);

    PLOTASSERT(0, "SetPlotRegData: Invalid PRKI_xxx Index %ld",
                                Index <= PRKI_LAST, Index);

    if (Index >= PRKI_PENDATA1) {

        UINT    cPenData;

        if ((cPenData = (UINT)HIWORD(RegIdx)) >= MAX_PENPLOTTER_PENS) {

            PLOTERR(("GetPlotRegData: cPenData too big %ld (Max=%ld)",
                                    cPenData, MAX_PENPLOTTER_PENS));

            cPenData = MAX_PENPLOTTER_PENS;
        }

        PRK.pwKey = GetPenDataKey(wBuf, CCHOF(wBuf), (WORD)(Index - PRKI_PENDATA1 + 1));
        PRK.Size  = (DWORD)sizeof(PENDATA) * (DWORD)cPenData;
        pPRK      = &PRK;

    } else {

        pPRK = (PPLOTREGKEY)&PlotRegKey[Index];
    }

    if (xSetPrinterData(hPrinter,
                        pPRK->pwKey,
                        REG_BINARY,
                        pData,
                        pPRK->Size) != NO_ERROR) {

        PLOTERR(("SetPlotRegData: SetPrinterData(%ls [%ld]) failed",
                                                pPRK->pwKey, pPRK->Size));
        return(FALSE);

    } else {

        PLOTDBG(DBG_SETREGDATA, ("SAVE '%ws' registry data", pPRK->pwKey));
        return(TRUE);
    }
}


BOOL
SaveToRegistry(
    HANDLE      hPrinter,
    PCOLORINFO  pColorInfo,
    LPDWORD     pDevPelsDPI,
    LPDWORD     pHTPatSize,
    PPAPERINFO  pCurPaper,
    PPPDATA     pPPData,
    LPBYTE      pIdxPlotData,
    DWORD       cPenData,
    PPENDATA    pPenData
    )

/*++

Routine Description:

    This function take hPrinter and read the printer properties from the
    registry, if sucessful then it update to the pointer supplied

Arguments:

    hPrinter        - The printer it interested

    pColorInfo      - Pointer to the COLORINFO data structure

    pDevPelsDPI     - Pointer to the DWORD for Device Pels per INCH

    pHTPatSize      - Poineer to the DWORD for halftone patterns size

    pCurPaper       - Pointer to the PAPERINFO data structure for update

    pPPData         - Pointer to the PPDATA data structure

    pIdxPlotData    - Pointer to the DWORD which have current PlotData index

    cPenData        - count of PENDATA to be updated

    pPenData        - Pointer to the PENDATA data structure


Return Value:

    return TRUE if it read sucessful from the registry else FALSE, for each of
    the data pointer passed it will try to read from registry, if a NULL
    pointer is passed then that registry is skipped.

    if falied, the pCurPaper will be set to default

Author:

    30-Nov-1993 Tue 14:54:33 created  


Revision History:


--*/

{
    BOOL    Ok = TRUE;


    //
    // In turn get each of the data from registry.
    //

    if (pColorInfo) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pColorInfo, PRKI_CI)) {

            Ok = FALSE;
        }
    }

    if (pDevPelsDPI) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pDevPelsDPI, PRKI_DEVPELSDPI)) {

            Ok = FALSE;
        }
    }

    if (pHTPatSize) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pHTPatSize, PRKI_HTPATSIZE)) {

            Ok = FALSE;
        }
    }

    if (pCurPaper) {

        if (!SetPlotRegData(hPrinter, (LPBYTE)pCurPaper, PRKI_FORM)) {

            Ok = FALSE;
        }
    }

    if (pPPData) {

        pPPData->NotUsed = 0;

        if (!SetPlotRegData(hPrinter, (LPBYTE)pPPData, PRKI_PPDATA)) {

            Ok = FALSE;
        }
    }

    if (pIdxPlotData) {

        if (*pIdxPlotData >= PRK_MAX_PENDATA_SET) {

            *pIdxPlotData = 0;
            Ok            = FALSE;
        }

        if (!SetPlotRegData(hPrinter, pIdxPlotData, PRKI_PENDATA_IDX)) {

            Ok = FALSE;
        }
    }

    if ((cPenData) && (pPenData)) {

        WORD    IdxPen;

        //
        // First is get the current pendata selection index
        //

        if ((IdxPen = LOWORD(cPenData)) >= PRK_MAX_PENDATA_SET) {

            IdxPen = (WORD)((pIdxPlotData) ? *pIdxPlotData : 0);
        }

        cPenData = MAKELONG(IdxPen + PRKI_PENDATA1, HIWORD(cPenData));

        if (!SetPlotRegData(hPrinter, (LPBYTE)pPenData, cPenData)) {

            Ok = FALSE;
        }
    }

    return(Ok);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\readgpc.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    readgpc.c


Abstract:

    This module contain functions to read the PLOTGPC data file



Development History:

    15-Nov-1993 Mon 10:00:01 created  


[Environment:]

    GDI Device Driver - Plotter.



--*/

#include "precomp.h"
#pragma hdrstop

extern DEVHTINFO    DefDevHTInfo;



BOOL
ValidateFormSrc(
    PGPCVARSIZE pFormGPC,
    SIZEL       DeviceSize,
    BOOL        DevRollFeed
    )

/*++

Routine Description:

    This function validate if FORMSRC has valid filed in it

Arguments:

    pFormGPC    - pointer to the GPCVARSIZE for the form data.

    DeviceSize  - Device size to check against,

    DevRollFeed - TRUE if device can do roll feed


Return Value:

    BOOL return value, the fields already verified and corrected.



Development History:

    15-Nov-1993 Mon 10:34:29 created 




--*/

{
    PFORMSRC    pFS;
    LONG        cy;
    UINT        Count;
    BOOL        InvalidFS;
    BOOL        Ok = TRUE;



    pFS   = (PFORMSRC)pFormGPC->pData;
    Count = (UINT)pFormGPC->Count;

    while (Count--) {

        InvalidFS = FALSE;

        //
        // Make sure that imageable area is less or eqaul to the size
        //

        if (pFS->Size.cy) {

            if (pFS->Size.cy < MIN_PLOTGPC_FORM_CY) {

                //
                // Make it as variable length paper
                //

                PLOTERR(("Invalid Form CY, make it as variable length (%ld)",
                                                                pFS->Size.cy));

                pFS->Size.cy = 0;
            }
        }

        if (!(cy = pFS->Size.cy)) {

            cy = DeviceSize.cy;
        }

        if (((pFS->Size.cx <= DeviceSize.cx) &&
             (pFS->Size.cy <= cy))              ||
            ((pFS->Size.cy <= DeviceSize.cx) &&
             (pFS->Size.cx <= cy))) {

            NULL;

        } else {

            PLOTERR(("Invalid Form Size, too big for device to handle"));
            InvalidFS = TRUE;
        }

        if ((pFS->Size.cy) &&
            ((pFS->Size.cy - pFS->Margin.top - pFS->Margin.bottom) <
                                                        MIN_PLOTGPC_FORM_CY)) {

            PLOTERR(("Invalid Form CY or top/bottom margins"));

            InvalidFS = TRUE;
        }

        if ((pFS->Size.cx < MIN_PLOTGPC_FORM_CX)                            ||
            ((pFS->Size.cx - pFS->Margin.left - pFS->Margin.right) <
                                                    MIN_PLOTGPC_FORM_CX)) {

            PLOTERR(("Invalid Form CX or left/right margins"));

            InvalidFS = TRUE;
        }

        if ((!DevRollFeed) && (pFS->Size.cy == 0)) {

            InvalidFS = TRUE;
            PLOTERR(("The device cannot handle roll paper %hs", pFS->Name));
        }


        if (InvalidFS) {

            PLOTERR(("ValidateFormSrc: invalid form data, (removed it)"));

            Ok = FALSE;

            if (Count) {

                CopyMemory(pFS, pFS + 1, sizeof(FORMSRC));
            }

            pFormGPC->Count -= 1;

        } else {

            //
            // Make sure ansi ascii end with a NULL
            //

            pFS->Name[sizeof(pFS->Name) - 1] = '\0';

            ++pFS;
        }
    }

    if (!pFormGPC->Count) {

        PLOTERR(("ValidateFormSrc: NO form are valid, count = 0"));

        ZeroMemory(pFormGPC, sizeof(GPCVARSIZE));
    }

    return(Ok);
}




DWORD
PickDefaultHTPatSize(
    WORD    xDPI,
    WORD    yDPI,
    BOOL    HTFormat8BPP
    )

/*++

Routine Description:

    This function return default halftone pattern size used for a particular
    device resolution

Arguments:

    xDPI            - Device LOGPIXELS X

    yDPI            - Device LOGPIXELS Y

    8BitHalftone    - If a 8-bit halftone will be used


Return Value:

    DWORD   HT_PATSIZE_xxxx



Development History:

    29-Jun-1993 Tue 14:46:49 created  



--*/

{
    DWORD    HTPatSize;

    //
    // use the smaller resolution as the pattern guide
    //

    if (xDPI > yDPI) {

        xDPI = yDPI;
    }

    if (xDPI >= 2400) {

        HTPatSize = HT_PATSIZE_16x16_M;

    } else if (xDPI >= 1800) {

        HTPatSize = HT_PATSIZE_14x14_M;

    } else if (xDPI >= 1200) {

        HTPatSize = HT_PATSIZE_12x12_M;

    } else if (xDPI >= 900) {

        HTPatSize = HT_PATSIZE_10x10_M;

    } else if (xDPI >= 400) {

        HTPatSize = HT_PATSIZE_8x8_M;

    } else if (xDPI >= 180) {

        HTPatSize = HT_PATSIZE_6x6_M;

    } else {

        HTPatSize = HT_PATSIZE_4x4_M;
    }

    if (HTFormat8BPP) {

        HTPatSize -= 2;
    }

    return(HTPatSize);
}





BOOL
ValidatePlotGPC(
    PPLOTGPC    pPlotGPC
    )

/*++

Routine Description:

    This function validate a PLOTGPC data structure


Arguments:

    pPlotGPC


Return Value:

    BOOL


Development History:

    15-Feb-1994 Tue 22:49:40 updated 
        Update the pen plotter validation for the bitmap font and color

    15-Nov-1993 Mon 10:11:58 created  


Revision History:

    02-Apr-1995 Sun 11:23:46 updated  
        Update the COLORINFO checking so it will make to NT3.51's default
        and not compute the devpels on the spot.

--*/

{
    if ((pPlotGPC->ID != PLOTGPC_ID)            ||
        (pPlotGPC->cjThis != sizeof(PLOTGPC))) {

        PLOTERR(("ValidatePlotGPC: invalid PLOTGPC data (ID/Size)"));
        return(FALSE);
    }

    pPlotGPC->DeviceName[sizeof(pPlotGPC->DeviceName) - 1]  = '\0';
    pPlotGPC->Flags                                        &= PLOTF_ALL_FLAGS;

    //
    // Validate device size and its margin
    //

    if (pPlotGPC->DeviceSize.cx - (pPlotGPC->DeviceMargin.left +
                        pPlotGPC->DeviceMargin.right) < MIN_PLOTGPC_FORM_CX) {

        PLOTERR(("Invalid Device CX (%ld) set to default",
                                                    pPlotGPC->DeviceSize.cx));

        pPlotGPC->DeviceSize.cx = pPlotGPC->DeviceMargin.left +
                                  pPlotGPC->DeviceMargin.right +
                                  MIN_PLOTGPC_FORM_CX;
    }

    if (pPlotGPC->DeviceSize.cy < MIN_PLOTGPC_FORM_CY) {

        PLOTERR(("Invalid Device CY (%ld) default to 50' long",
                                                    pPlotGPC->DeviceSize.cx));

        pPlotGPC->DeviceSize.cy = 15240000;
    }

    if (pPlotGPC->DeviceSize.cy - (pPlotGPC->DeviceMargin.top +
                        pPlotGPC->DeviceMargin.bottom) < MIN_PLOTGPC_FORM_CY) {

        PLOTERR(("Invalid Device CY (%ld) set to default",
                                                    pPlotGPC->DeviceSize.cy));

        pPlotGPC->DeviceSize.cx = pPlotGPC->DeviceMargin.top +
                                  pPlotGPC->DeviceMargin.bottom +
                                  MIN_PLOTGPC_FORM_CY;
    }

    //
    // For now we must have 1:1 ratio
    //

    if (pPlotGPC->PlotXDPI != pPlotGPC->PlotYDPI) {

        pPlotGPC->PlotYDPI = pPlotGPC->PlotXDPI;
    }

    if (pPlotGPC->RasterXDPI != pPlotGPC->RasterYDPI) {

        pPlotGPC->RasterYDPI = pPlotGPC->RasterXDPI;
    }

    if (pPlotGPC->ROPLevel > ROP_LEVEL_MAX) {

        pPlotGPC->ROPLevel = ROP_LEVEL_MAX;
    }

    if (pPlotGPC->MaxScale > MAX_SCALE_MAX) {

        pPlotGPC->MaxScale = MAX_SCALE_MAX;
    }

    if ((!(pPlotGPC->Flags & PLOTF_RASTER)) &&
        (pPlotGPC->MaxPens > MAX_PENPLOTTER_PENS)) {

        pPlotGPC->MaxPens = MAX_PENPLOTTER_PENS;
    }

    if (pPlotGPC->MaxPolygonPts < 3) {      // minimum 3 points to make up a
                                            // region
        pPlotGPC->MaxPolygonPts = 0;
    }

    if (pPlotGPC->MaxQuality > MAX_QUALITY_MAX) {

        pPlotGPC->MaxQuality = MAX_QUALITY_MAX;
    }

    if (pPlotGPC->Flags & PLOTF_PAPERTRAY) {

        if ((pPlotGPC->PaperTraySize.cx != pPlotGPC->DeviceSize.cx) &&
            (pPlotGPC->PaperTraySize.cy != pPlotGPC->DeviceSize.cx)) {

            PLOTERR(("Invalid PaperTraySize (%ld x %ld), Make it as DeviceSize",
                                                    pPlotGPC->PaperTraySize.cx,
                                                    pPlotGPC->PaperTraySize.cy));

            pPlotGPC->PaperTraySize.cx = pPlotGPC->DeviceSize.cx;
            pPlotGPC->PaperTraySize.cy = pPlotGPC->DeviceSize.cy;
        }

    } else {

        pPlotGPC->PaperTraySize.cx  =
        pPlotGPC->PaperTraySize.cy  = 0;
    }

    if (!pPlotGPC->ci.Cyan.Y) {

        //
        // This is NT3.51 default
        //

        pPlotGPC->ci            = DefDevHTInfo.ColorInfo;
        pPlotGPC->DevicePelsDPI = 0;

    } else if ((pPlotGPC->DevicePelsDPI < 30) ||
               (pPlotGPC->DevicePelsDPI > pPlotGPC->RasterXDPI)) {

        pPlotGPC->DevicePelsDPI = 0;
    }

    if (pPlotGPC->HTPatternSize > HT_PATSIZE_16x16_M) {

        pPlotGPC->HTPatternSize = PickDefaultHTPatSize(pPlotGPC->RasterXDPI,
                                                       pPlotGPC->RasterYDPI,
                                                       FALSE);
    }

    if ((pPlotGPC->InitString.Count != 1)   ||
        (!pPlotGPC->InitString.SizeEach)    ||
        (!pPlotGPC->InitString.pData)) {

        ZeroMemory(&(pPlotGPC->InitString), sizeof(GPCVARSIZE));
    }

    if ((pPlotGPC->Forms.Count)                       &&
        (pPlotGPC->Forms.SizeEach == sizeof(FORMSRC)) &&
        (pPlotGPC->Forms.pData)) {

        ValidateFormSrc(&(pPlotGPC->Forms),
                        pPlotGPC->DeviceSize,
                        (pPlotGPC->Flags & PLOTF_ROLLFEED));

    } else {

        ZeroMemory(&(pPlotGPC->Forms), sizeof(GPCVARSIZE));
    }

    if (!(pPlotGPC->Flags & PLOTF_RASTER)) {

        //
        // PEN PLOTTER MUST COLOR and NO_BMP_FONT
        //

        pPlotGPC->Flags |= (PLOTF_NO_BMP_FONT | PLOTF_COLOR);
    }

    if ((!(pPlotGPC->Flags & PLOTF_RASTER))             &&
        (pPlotGPC->Pens.Count)                          &&
        (pPlotGPC->Pens.SizeEach == sizeof(PENDATA))    &&
        (pPlotGPC->Pens.pData)) {

        UINT        i;
        PPENDATA    pPD;


        pPD = (PPENDATA)pPlotGPC->Pens.pData;

        for (i = 0; i < (UINT)pPlotGPC->MaxPens; i++, pPD++) {

            if (pPD->ColorIdx > PC_IDX_LAST) {

                PLOTERR(("Invalid ColorIndex (%ld), set to default",
                                                            pPD->ColorIdx));

                pPD->ColorIdx = PC_IDX_FIRST;
            }
        }

    } else {

        ZeroMemory(&(pPlotGPC->Pens), sizeof(GPCVARSIZE));
    }

    return(TRUE);
}

VOID
CopyPlotGPCFromPCD(
    PPLOTGPC     pPlotGPC,
    PPLOTGPC_PCD pPlotGPC_PCD
    )

/*++

Routine Description:

    This function copies a PLOTGPC_PCD structure into a PLOTGPC structure.

Arguments:

    pPlotGPC     - destination
    pPlotGPC_PCD - source

Return Value:

    None 


Development History:

    1 Feb 2000

Revision History:

--*/

{
    // All the datatypes upto InitString are the same in both the structures.
    CopyMemory(pPlotGPC, 
               pPlotGPC_PCD, 
               (LPBYTE)&(pPlotGPC_PCD->InitString) - (LPBYTE)pPlotGPC_PCD);
    
    // We replace sizeof(PLOTGPC_PCD) with sizeof(PLOTGPC)
    pPlotGPC->cjThis = sizeof(PLOTGPC);

    pPlotGPC->InitString.Count     = pPlotGPC_PCD->InitString.Count;
    pPlotGPC->InitString.SizeEach  = pPlotGPC_PCD->InitString.SizeEach;
    if (pPlotGPC_PCD->InitString.pData) {
        pPlotGPC->InitString.pData = (LPVOID)(pPlotGPC_PCD->InitString.pData
                                                 + (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD)));
    } else {
        pPlotGPC->InitString.pData = NULL;
    }

    pPlotGPC->Forms.Count          = pPlotGPC_PCD->Forms.Count;
    pPlotGPC->Forms.SizeEach       = pPlotGPC_PCD->Forms.SizeEach;
    if (pPlotGPC_PCD->Forms.pData) {
        pPlotGPC->Forms.pData      = (LPVOID)(pPlotGPC_PCD->Forms.pData
                                                 + (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD)));
    } else {
        pPlotGPC->Forms.pData      = NULL;
    }

    pPlotGPC->Pens.Count           = pPlotGPC_PCD->Pens.Count;
    pPlotGPC->Pens.SizeEach        = pPlotGPC_PCD->Pens.SizeEach;
    if (pPlotGPC_PCD->Pens.pData) {
        pPlotGPC->Pens.pData       = (LPVOID)(pPlotGPC_PCD->Pens.pData
                                                 + (sizeof(PLOTGPC) - sizeof(PLOTGPC_PCD)));
    } else {
        pPlotGPC->Pens.pData       = NULL;
    }
}




PPLOTGPC
ReadPlotGPCFromFile(
    PWSTR   pwsDataFile
    )

/*++

Routine Description:

    This function open/read the PlotGPC data file and validate them also


Arguments:

    pwsDataFile - a pointer to full qualify path for the data file name

Return Value:

    BOOL - to indicate state



Development History:

    15-Nov-1993 Mon 10:01:17 created  


Revision History:


--*/

{
    HANDLE        hFile;
    DWORD         dwSize;
    PLOTGPC_PCD   PlotGPC_PCD;
    BOOL          bSuccess = TRUE;
    PPLOTGPC      pPlotGPC = NULL;

    if ((hFile = OpenPlotFile(pwsDataFile)) == (HANDLE)INVALID_HANDLE_VALUE) {

        PLOTERR(("ReadPlotGPCFromFile: Open data file failed"));
        return(NULL);
    }

    if ((ReadPlotFile(hFile, &PlotGPC_PCD, sizeof(PLOTGPC_PCD), &dwSize)) &&
        (dwSize == sizeof(PLOTGPC_PCD))) {

        if ((PlotGPC_PCD.ID != PLOTGPC_ID)           ||
            (PlotGPC_PCD.cjThis != sizeof(PLOTGPC_PCD))) {

            bSuccess = FALSE;
            PLOTERR(("ReadPlotGPCFromFile: invalid data file"));
        }

    } else {

        bSuccess = FALSE;
        PLOTERR(("ReadPlotGPCFromFile: Read data file failed"));
    }

    //
    // if we have pPlotGPC_PCD == NULL then an error ocurred
    //

    if (bSuccess) {

        dwSize = PlotGPC_PCD.SizeExtra + sizeof(PLOTGPC);

        if (pPlotGPC = (PPLOTGPC)LocalAlloc(LPTR, dwSize)) {

            CopyPlotGPCFromPCD(pPlotGPC, &PlotGPC_PCD);

            if ((PlotGPC_PCD.SizeExtra)                                 &&
                (ReadPlotFile(hFile,
                              (LPBYTE)pPlotGPC + sizeof(PLOTGPC),
                              PlotGPC_PCD.SizeExtra,
                              &dwSize))                             &&
                (dwSize == PlotGPC_PCD.SizeExtra)) {

                if ((pPlotGPC->InitString.Count == 1) &&
                    (pPlotGPC->InitString.SizeEach)   &&
                    (pPlotGPC->InitString.pData)) {

                    (LPBYTE)pPlotGPC->InitString.pData += (ULONG_PTR)pPlotGPC;

                } else {

                    ZeroMemory(&(pPlotGPC->InitString), sizeof(GPCVARSIZE));
                }

                if ((pPlotGPC->Forms.Count)                       &&
                    (pPlotGPC->Forms.SizeEach == sizeof(FORMSRC)) &&
                    (pPlotGPC->Forms.pData)) {

                    (LPBYTE)pPlotGPC->Forms.pData += (ULONG_PTR)pPlotGPC;

                } else {

                    ZeroMemory(&(pPlotGPC->Forms), sizeof(GPCVARSIZE));
                }

                if ((pPlotGPC->Pens.Count)                          &&
                    (pPlotGPC->Pens.SizeEach == sizeof(PENDATA))    &&
                    (pPlotGPC->Pens.pData)) {

                    (LPBYTE)pPlotGPC->Pens.pData += (ULONG_PTR)pPlotGPC;

                } else {

                    ZeroMemory(&(pPlotGPC->Pens), sizeof(GPCVARSIZE));
                }

            } else {

                //
                // Failed to read, free the memory and return NULL
                //

                LocalFree((HLOCAL)pPlotGPC);
                pPlotGPC = NULL;

                PLOTERR(("ReadPlotGPCFromFile: read variable size data failed"));
            }

        } else {

            PLOTERR(("ReadPlotGPCFromFile: allocate memory (%lu bytes) failed",
                                             dwSize));
        }
    }

    ClosePlotFile(hFile);

    if (pPlotGPC) {

        ValidatePlotGPC(pPlotGPC);
    }

    return(pPlotGPC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\lib\widechar.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    widechar.c


Abstract:

    This module contains all NLS unicode / ansi translation code


Author:

    18-Nov-1993 Thu 08:21:37 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop



LPWSTR
str2Wstr(
    LPWSTR  pwStr,
    size_t  cchDest,
    LPSTR   pbStr
    )

/*++

Routine Description:

    This function copy a ansi string to the equvlent of unicode string which
    also include the NULL teiminator

Arguments:

    pwStr   - Point to the unicode string location, it must have the size of
              (strlen(pstr) + 1) * sizeof(WCHAR)

    pbStr   - a null teiminated string

Return Value:

    pwcs

Author:

    18-Nov-1993 Thu 08:36:00 created  


Revision History:


--*/

{
    size_t    cch;

    if (NULL == pbStr || NULL == pwStr)
    {
        return NULL;
    }

    //
    // Make sure that the size of dest buffer is large enough.
    //
    if (SUCCEEDED(StringCchLengthA(pbStr, cchDest, &cch)))
    {
        //
        // cch returned above does not include the null terminator.
        // So we need to add 1 to cch to make sure destination string is
        // null terminated.
        //
        AnsiToUniCode(pbStr, pwStr, cch+1);
        return pwStr;
    }
    else
    {
        return NULL;
    }
}






LPSTR
WStr2Str(
    LPSTR   pbStr,
    size_t  cchDest,
    LPWSTR  pwStr
    )

/*++

Routine Description:

    This function convert a UNICODE string to the ANSI string, assume that
    pbStr has same character count memory as pwStr

Arguments:

    pbStr   - Point to the ANSI string which has size of wcslen(pwStr) + 1

    pwStr   - Point to the UNICODE string


Return Value:


    pbStr


Author:

    06-Dec-1993 Mon 13:06:12 created  


Revision History:


--*/

{

    size_t    cch;

    if (NULL == pbStr || NULL == pwStr)
    {
        return NULL;
    }

    if (SUCCEEDED(StringCchLengthW(pwStr, cchDest, &cch)))
    {
        //
        // cch returned above does not include the null terminator.
        // So we need to add 1 to cch to make sure destination string is 
        // null terminated.
        //
        UniCodeToAnsi(pbStr, pwStr, cch+1);
        return pbStr;
    }
    else
    {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\bitblt.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    bitblt.h


Abstract:

    This module contains all #defines and protypes for the bitblt.c module.


Author:

    18-Nov-1993 Thu 05:24:42 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTBITBLT_
#define _PLOTBITBLT_


ROP4
MixToRop4(
   MIX  mix
   );


BOOL
BandingHTBlt(
    PPDEV           pPDev,
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    PRECTL          prclDst,
    PRECTL          prclSrc,
    PPOINTL         pptlMask,
    WORD            HTRop3,
    BOOL            InvertMask
    );

BOOL
DoFill(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrush,
    ROP4        Rop4
    );


#endif  // _PLOTBITBLT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\brush.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    brush.h


Abstract:

    This module contains brush definitions and prototypes for module brush.c


Author:

    27-Jan-1994 Thu 21:05:01 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/


#ifndef _PLOTBRUSH_
#define _PLOTBRUSH_


VOID
ResetDBCache(
    PPDEV   pPDev
    );


LONG
FindDBCache(
    PPDEV   pPDev,
    WORD    DBUniq
    );

BOOL
CopyUserPatBGR(
    PPDEV       pPDev,
    SURFOBJ     *psoPat,
    XLATEOBJ    *pxlo,
    LPBYTE      pBGRBmp
    );

VOID
GetMinHTSize(
    PPDEV   pPDev,
    SIZEL   *pszlPat
    );


#endif  // _PLOTBRUSH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\bitblt.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    bitblt.c


Abstract:

    This module contains functions which implement bitmap handling for the
    plotter driver.

Author:

    19:15 on Mon 15 Apr 1991    
        Created it

    15-Nov-1993 Mon 19:24:36 updated  
        fixed, clean up

    18-Dec-1993 Sat 10:52:07 updated  
        Move some functions from bitbltp.c and move others to htblt.c and
        bitmap.c.   This file mainly has DrvXXXXX() which related to the
        bitblt or drawing.

    27-Jan-1994 Thu 23:41:23 updated  
        Revised bitblt so it will handle better ROP3/Rop4 support, also it
        will check the PCD file's ROP caps

[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


#define DBG_PLOTFILENAME    DbgBitBlt


#define DBG_COPYBITS            0x00000001
#define DBG_BITBLT              0x00000002
#define DBG_DRVPAINT            0x00000004
#define DBG_DRVFILLPATH         0x00000008
#define DBG_DRVSTROKEANDFILL    0x00000010
#define DBG_MIXTOROP4           0x00000020
#define DBG_TEMPSRC             0x00000040
#define DBG_STRETCHBLT          0x00000080
#define DBG_BANDINGHTBLT        0x00000100
#define DBG_DOFILL              0x00000200
#define DBG_CSI                 0x00000400


DEFINE_DBGVAR(0);


//
// This is the default BANDING size (2MB) for the DrvStretchBlt()
//

#if DBG

LPSTR   pCSIName[] = { "SRC", "PAT", "TMP" };


DWORD   MAX_STRETCH_BLT_SIZE = (2 * 1024 * 1024);
#else
#define MAX_STRETCH_BLT_SIZE    (2 * 1024 * 1024)
#endif

//
// This table converts MIX-1 to ROP3 value
//
static BYTE amixToRop4[] = {
         0x00,             // R2_BLACK             0
         0x05,             // R2_NOTMERGEPEN      DPon
         0x0a,             // R2_MASKNOTPEN       DPna
         0x0f,             // R2_NOTCOPYPEN       PN
         0x50,             // R2_MASKPENNOT       PDna
         0x55,             // R2_NOT              Dn
         0x5a,             // R2_XORPEN           DPx
         0x5f,             // R2_NOTMASKPEN       DPan
         0xa0,             // R2_MASKPEN          DPa
         0xa5,             // R2_NOTXORPEN        DPxn
         0xaa,             // R2_NOP              D
         0xaf,             // R2_MERGENOTPEN      DPno
         0xf0,             // R2_COPYPEN          P
         0xf5,             // R2_MERGEPENNOT      PDno
         0xfa,             // R2_MERGEPEN         DPo
         0xff,             // R2_WHITE             1
};

extern const POINTL ptlZeroOrigin;





ROP4
MixToRop4(
   MIX  mix
   )

/*++

Routine Description:

    This function converts a MIX value to a ROP4 value

Arguments:

    mix      - MIX value to convert, this is defined in wingdi.h and represents
               one of 16 different ROP2 values
Return Value:

    ROP4     - the converted value


Author:

    18-Dec-1993 Sat 09:34:06 created  


Revision History:


--*/
{
   ROP4 rop4Return;

   //
   // Now pack the two new values by looking up the correct rop codes in our
   // table.
   //


   rop4Return =  amixToRop4[((mix & 0xff) - 1)];

   rop4Return |= ( amixToRop4[((( mix >> 8) & 0xff ) - 1 )] << 8 );


   PLOTDBG(DBG_MIXTOROP4, ("MixToRop4 before %x after %x", (int) mix,(int) rop4Return));

   return(rop4Return);
}





BOOL
BandingHTBlt(
    PPDEV           pPDev,
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    PRECTL          prclDst,
    PRECTL          prclSrc,
    PPOINTL         pptlMask,
    WORD            HTRop3,
    BOOL            InvertMask
    )

/*++

Routine Description:

    This is our internal version of StretchBlt() which always does halftoning
    and banding if the destination bitmap is too large. Since the target
    surface can pottentially be 3 feet by 3 feet, we don't want to
    have a bitmap created that large because of memory requirements. So
    we review the memory requirements and if they are too large we simply
    band, by setting a clip region that moves down the page via a loop. This
    effectively has the halftoning engine simply working on much smaller
    more manageable bitmaps, and we end up sending out virtually the same
    number of bytes.

Arguments:

    pPDev       - Pointer to our PDEV

    psoDst      - This is a pointer to a SURFOBJ.    It identifies the surface
                  on which to draw.

    psoSrc      - This SURFOBJ defines the source for the Blt operation.  The
                  driver must call GDI Services to find out if this is a device
                  managed  surface or a bitmap managed by GDI.

    psoMask     - This optional surface provides a mask for the source.  It is
                  defined by a logic map, i.e. a bitmap with one bit per pel.

                  The mask is used to limit the area of the source that is
                  copied.  When a mask is provided there is an implicit rop4 of
                  0xCCAA, which means that the source should be copied wherever
                  the mask is 1, but the destination should be left alone
                  wherever the mask is 0.

                  When this argument is NULL there is an implicit rop4 of
                  0xCCCC, which means that the source should be copied
                  everywhere in the source rectangle.

                  The mask will always be large enough to contain the source
                  rectangle, tiling does not need to be done.

    pco         - This is a pointer to a CLIPOBJ.    GDI Services are provided
                  to enumerate the clipping region as a set of rectangles or
                  trapezoids. This limits the area of the destination that will
                  be modified.

                  Whenever possible, GDI will simplify the clipping involved.
                  However, unlike DrvBitBlt, DrvStretchBlt may be called with a
                  single clipping rectangle.  This is necessary to prevent
                  roundoff errors in clipping the output.

    pxlo        - This is a pointer to an XLATEOBJ.  It tells how color indices
                  should be translated between the source and target surfaces.

                  The XLATEOBJ can also be queried to find the RGB color for
                  any source index.  A high quality stretching Blt will need
                  to interpolate colors in some cases.

    pca         - This is a pointer to COLORADJUSTMENT structure, if NULL it
                  specifies that appiclation did not set any color adjustment
                  for this DC, and it is up to the driver to provide a default
                  adjustment

    pptlBrushOrg- Pointer to the POINT structure which specifies the location
                  where the halftone brush should alignment to, if this pointer
                  is NULL, then we assume that (0, 0) is the brush origin.

    prclDst     - This RECTL defines the area in the coordinate system of the
                  destination surface that should be modified.

                  The rectangle is defined by two points.    These points are
                  not well ordered, i.e. the coordinates of the second point
                  are not necessarily larger than those of the first point.
                  The rectangle they describe does not include the lower and
                  right edges.  DrvStretchBlt will never be called with an
                  empty destination rectangle.

                  DrvStretchBlt can do inversions in both x and y, this happens
                  when the destination rectangle is not well ordered.

    prclSrc     - This RECTL defines the area in the coordinate system of the
                  source surface that will be copied.  The rectangle is defined
                  by two points, and will map onto the rectangle defined by
                  prclDst.  The points of the source rectangle are well
                  ordered.  DrvStretch will never be given an empty source
                  rectangle.

                  Note that the mapping to be done is defined by prclSrc and
                  prclDsst. To be precise, the given points in prclDst and
                  prclSrc lie on integer coordinates, which we consider to
                  correspond to pel centers.  A rectangle defined by two such
                  points should be considered a geometric rectangle with two
                  vertices whose coordinates are the given points, but with 0.5
                  subtracted from each coordinate.  (The POINTLs should just be
                  considered a shorthand notation for specifying these
                  fractional coordinate vertices.)  Note thate the edges of any
                  such rectangle never intersect a pel, but go around a set of
                  pels.  Note also that the pels that are inside the rectangle
                  are just what you would expect for a "bottom-right exclusive"
                  rectangle.  The mapping to be done by DrvStretchBlt will map
                  the geometric source rectangle exactly onto the geometric
                  destination rectangle.

    pptlMask    - This POINTL specifies which pel in the given mask corresponds
                  to the upper left pel in the source rectangle.  Ignore this
                  argument if there is no mask.

    HTRop3      - HIBYTE(HTRop3) when psoMask is not NULL and
                  LOBYTE(HTRop3) when psoMask is NULL

    InvertMask  - TRUE if the mask must be inverted


Return Value:


    TRUE if sucessful FALSE if failed

Author:

    07-Mar-1994 Mon 12:52:41 created  

Revision History:

    16-Mar-1994 Wed 15:20:42 updated  
        Updated for banding the mask so it will works correcly for the engine
        problem.

    04-May-1994 Wed 11:27:39 updated  
        Make rotate type (landscape mode) banding from right to left rather
        than top to bottom

    29-Nov-1995 Wed 13:00:30 updated  
        Mark not reentratable for the same PDEV, this is signal that called to
        the EngStretchBlt(HALFTONE) is failing for some reason


--*/

{
    CLIPOBJ *pcoNew;
    CLIPOBJ coSave;
    RECTL   rclMask;
    RECTL   rclBounds;
    DWORD   MaskRop3;
    UINT    Loop;
    BOOL    DoRotate;
    BOOL    Ok;



    if (!IS_RASTER(pPDev)) {

        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: Pen Plotter: IGNORE and return OK"));
        return(TRUE);
    }

    if (pPDev->pPlotGPC->ROPLevel < ROP_LEVEL_1) {

        PLOTDBG(DBG_BITBLT, ("BandingHTBlt: RopLevel < 1, Cannot Do it"));
        return(TRUE);
    }

    if (pPDev->Flags & PDEVF_IN_BANDHTBLT) {

        //
        // Something is wrong here
        //

        PLOTERR(("BandingHTBlt: Recursive is not allowed, FAILED"));
        return(FALSE);
    }

    //
    // Turn on the flag now
    //

    pPDev->Flags |= PDEVF_IN_BANDHTBLT;

    if ((!pca) || (pca->caFlags & ~(CA_NEGATIVE | CA_LOG_FILTER))) {

        //
        // If we have a NULL or invalid flag then use the default one
        //

        PLOTWARN(("DrvStretchBlt: INVALID ColorAdjustment Flags=%04lx, USE DEFAULT",
                   (pca) ? pca->caFlags : 0));

        pca = &(pPDev->PlotDM.ca);
    }

    if (!pptlBrushOrg) {

        pptlBrushOrg = (PPOINTL)&(ptlZeroOrigin);
    }

    if (pPDev->PlotDM.Flags & PDMF_PLOT_ON_THE_FLY) {

        if (psoMask) {

            PLOTWARN(("BandingHTBlt: PosterMode -> Ignored MASK"));
            psoMask = NULL;
        }
    }

    if (psoMask) {

        //
        // If we have a source mask then we will first do (S|D)=0xEE or
        // (~S|D)=0xBB to white out the mask area then use (S&D)=0x88 to AND
        // in the halftoned bitmap. This is done to simulate the desired ROP
        // since the target device can't handle this on its own.
        //

        rclMask.left   = pptlMask->x;
        rclMask.top    = pptlMask->y;
        rclMask.right  = rclMask.left + (prclSrc->right - prclSrc->left);
        rclMask.bottom = rclMask.top +  (prclSrc->bottom - prclSrc->top);
        HTRop3         = (WORD)HIBYTE(HTRop3);
        MaskRop3       = (DWORD)((InvertMask) ? 0xBB : 0xEE);
        Loop           = 2;

        //
        // We must call this function to set up the xlate table correctly
        //

        IsHTCompatibleSurfObj(pPDev,
                              psoMask,
                              NULL,
                              ISHTF_ALTFMT | ISHTF_HTXB | ISHTF_DSTPRIM_OK);

    } else {

        HTRop3   = (WORD)LOBYTE(HTRop3);
        Loop     = 1;
    }

    if (!HTRop3) {

        HTRop3 = 0xCC;
    }

    //
    // Now look at how we can modify the clipping rect, in case we need
    // to band.
    //

    if (pco) {

        //
        // Save the original clipping object so we can restore it before exiting
        //

        pcoNew = NULL;
        coSave = *pco;

    } else {

        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: Create NEW EMPTY pco"));

        if (!(pcoNew = pco = EngCreateClip())) {

            PLOTERR(("BandingHTBlt: EngCreateClip() FAILED, got NO CLIP"));

            pPDev->Flags &= ~PDEVF_IN_BANDHTBLT;
            return(FALSE);
        }

        pco->iDComplexity = DC_TRIVIAL;
    }

    PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: The pco->iDComplexity=%ld",
                                pco->iDComplexity));

    if (pco->iDComplexity == DC_TRIVIAL) {

        //
        // Since it is trivial, we just draw the whole destination
        //

        pco->iDComplexity = DC_RECT;
        pco->rclBounds    = *prclDst;
    }

    //
    // Now make sure our bounds will not go outside of the surface
    //

    rclBounds.left    =
    rclBounds.top     = 0;
    rclBounds.right   = psoDst->sizlBitmap.cx;
    rclBounds.bottom  = psoDst->sizlBitmap.cy;

    if (IntersectRECTL(&rclBounds, &(pco->rclBounds))) {

        PLOTDBG(DBG_BANDINGHTBLT,
                ("BandingHTBlt: rclBounds=(%ld, %ld)-(%ld, %ld), %ld x %ld, ROP=%02lx",
                    rclBounds.left, rclBounds.top,
                    rclBounds.right, rclBounds.bottom,
                    rclBounds.right - rclBounds.left,
                    rclBounds.bottom - rclBounds.top, (DWORD)HTRop3));

    } else {

        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: rclBounds=NULL, NOTHING TO DO"));
        Loop = 0;
    }

    //
    // Now let's band it through
    //

    DoRotate = (BOOL)(pPDev->PlotForm.BmpRotMode == BMP_ROT_RIGHT_90);
    Ok       = TRUE;

    while ((Ok) && (Loop--) && (!PLOT_CANCEL_JOB(pPDev))) {

        RECTL   rclDst;
        SIZEL   szlDst;
        LONG    cScan;
        DWORD   BmpFormat;
        DWORD   OHTFlags;

        //
        // When Loop = 1 then we are doing the MASK
        // When Loop = 0 then we are doing the SOURCE
        //
        // We will band only MAX_STRETCH_BLT_SIZE at once
        //

        rclDst    = *prclDst;
        szlDst.cx = rclDst.right - rclDst.left;
        szlDst.cy = rclDst.bottom - rclDst.top;
        BmpFormat = (DWORD)((Loop) ? BMF_1BPP : HTBMPFORMAT(pPDev));

        cScan = (LONG)(MAX_STRETCH_BLT_SIZE /
                           GetBmpDelta(BmpFormat, (DoRotate) ? szlDst.cy :
                                                               szlDst.cx));


        //
        // We always want at least 8 scan lines and also a multiple of 8.
        //


        if (!cScan) {

            cScan = 8;

        } else if (cScan & 0x07) {

            cScan = (LONG)((cScan + 7) & ~(DWORD)0x07);
        }


        PLOTDBG(DBG_BANDINGHTBLT, ("BandingHTBlt: cScan=%ld, Total=%ld",
                                cScan, (DoRotate) ? szlDst.cx : szlDst.cy));

        OHTFlags = 0;

        while ((Ok)                             &&
               (!PLOT_CANCEL_JOB(pPDev))        &&
               (rclDst.top < prclDst->bottom)   &&
               (rclDst.right > prclDst->left)) {

            if (DoRotate) {

                if ((rclDst.left = rclDst.right - cScan) < prclDst->left) {

                    rclDst.left = prclDst->left;
                }

            } else {

                if ((rclDst.bottom = rclDst.top + cScan) > prclDst->bottom) {

                    rclDst.bottom = prclDst->bottom;
                }
            }

            pco->rclBounds = rclBounds;

            if (IntersectRECTL(&(pco->rclBounds), &rclDst)) {

                PLOTDBG(DBG_BANDINGHTBLT,
                        ("BandingHTBlt: Banding RECTL=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                            pco->rclBounds.left, pco->rclBounds.top,
                            pco->rclBounds.right, pco->rclBounds.bottom,
                            pco->rclBounds.right - pco->rclBounds.left,
                            pco->rclBounds.bottom - pco->rclBounds.top));

                if (Loop) {

                    SURFOBJ *psoNew;
                    HBITMAP hNewBmp;
                    RECTL   rclNew;

                    //
                    // We have a mask, so create a 1BPP bitmap, and stretch it
                    // to the new destination size, then output it using
                    // MaskRop3
                    //

                    Ok = FALSE;

                    PLOTDBG(DBG_CSI, ("BandingHTBlt: CreateBitmapSURFOBJ(MASK)"));

                    if (psoNew = CreateBitmapSURFOBJ(pPDev,
                                                     &hNewBmp,
                                                     pco->rclBounds.right -
                                                        pco->rclBounds.left,
                                                     pco->rclBounds.bottom -
                                                        pco->rclBounds.top,
                                                     BMF_1BPP,
                                                     NULL)) {

                        rclNew.left   = prclDst->left - pco->rclBounds.left;
                        rclNew.top    = prclDst->top - pco->rclBounds.top;
                        rclNew.right  = rclNew.left + szlDst.cx;
                        rclNew.bottom = rclNew.top + szlDst.cy;

                        PLOTDBG(DBG_BANDINGHTBLT,
                                ("BandingHTBlt: Banding MASK RECTL=(%ld, %ld)-(%ld, %ld), %ld x %ld",
                                rclNew.left, rclNew.top,
                                rclNew.right, rclNew.bottom,
                                psoNew->sizlBitmap.cx,
                                psoNew->sizlBitmap.cy));

                        if (EngStretchBlt(psoNew,           // psoDst
                                          psoMask,          // psoSrc
                                          NULL,             // psoMask,
                                          NULL,             // pco
                                          NULL,             // pxlo
                                          NULL,             // pca
                                          pptlBrushOrg,     // pptlHTOrg
                                          &rclNew,          // prclDst
                                          &rclMask,         // prclSrc
                                          NULL,             // pptlMask
                                          BLACKONWHITE)) {


                            if (!(Ok = OutputHTBitmap(pPDev,
                                                      psoNew,
                                                      NULL,
                                                      (PPOINTL)&rclDst,
                                                      NULL,
                                                      MaskRop3,
                                                      &OHTFlags))) {

                                PLOTERR(("BandingHTBlt: OutputHTBitmap(M|D) FAILED"));
                            }

                        } else {

                            PLOTERR(("BandingHTBlt: EngStretchBlt(MASK B/W) FAILED"));
                        }

                        //
                        // Delete this band of the mask bitmap
                        //

                        EngUnlockSurface(psoNew);

                        PLOTDBG(DBG_CSI, ("BandingHTBlt: EngDeleteSuface(MASK)"));

                        if (!EngDeleteSurface((HSURF)hNewBmp)) {

                            PLOTERR(("PLOTTER: BandingHTBlt, EngDeleteSurface(%p) FAILED",
                                        (DWORD_PTR)hNewBmp));
                        }

                    } else {

                        PLOTERR(("BandingHTBlt: Create MASK SURFOBJ (%ld x %ld) failed",
                                    pco->rclBounds.right - pco->rclBounds.left,
                                    pco->rclBounds.bottom - pco->rclBounds.top));
                    }

                } else {


                    //
                    // We must pass the psoMask/pptlMask so the haltone
                    // operations will not overwrite the non masked
                    // area (erasing it).
                    //

                    pPDev->Rop3CopyBits = HTRop3;

                    if (!(Ok = EngStretchBlt(psoDst,        // psoDst
                                             psoSrc,        // psoSrc
                                             psoMask,       // psoMask,
                                             pco,           // pco
                                             pxlo,          // pxlo
                                             pca,           // pca
                                             pptlBrushOrg,  // pptlHTOrg
                                             prclDst,       // prclDst
                                             prclSrc,       // prclSrc
                                             pptlMask,      // pptlMask
                                             HALFTONE))) {

                        PLOTERR(("BandingHTBlt: EngStretchBlt(Halftone:S&D) FAILED"));
                    }
                }
            }

            if (DoRotate) {

                rclDst.right = rclDst.left;

            } else {

                rclDst.top = rclDst.bottom;
            }
        }


        //
        // We must do this in order to exit HPGL/2 mode. This is because the
        // next call for the source will go through EngStrecthBlt(HALFTONE)
        // which will re-enter RTL mode again.
        //

        if (OHTFlags & OHTF_MASK) {

            OHTFlags |= OHTF_EXIT_TO_HPGL2;

            OutputHTBitmap(pPDev, NULL, NULL, NULL, NULL, 0xAA, &OHTFlags);
        }
    }

    if (pcoNew) {

        EngDeleteClip(pcoNew);

    } else {

        *pco = coSave;
    }

    pPDev->Flags &= ~PDEVF_IN_BANDHTBLT;

    return(Ok);
}




BOOL
DoFill(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrush,
    ROP4        Rop4
    )

/*++

Routine Description:

    This function fills a RECT area with a brush and takes clipping into
    consideration

Arguments:

    psoDst      - Destination surface obj

    psoSrc      - source surface obj

    pco         - Clip obj

    pxlo        - translate obj

    prclDst     - destination rect area

    pptlSrc     - point where source starts

    pbo         - Brush obj to fill with

    pptlBrush   - Brush alignment origin

    Rop4        - ROP4 to use

Return Value:

    TRUE if ok, FALSE if failed


Author:

    Created - 

    18-Dec-1993 Sat 09:34:06 created  
        Clean up formal argumeneted, commented

    15-Jan-1994 Sat 01:41:48 updated  
        added rclDst to DoFill() in case pco is NULL

    10-Mar-1994 Thu 00:35:06 updated  
        Fixed so when we call DoPolygon it will take prclDst (if not NULL)
        into account by intersect it with the rclBounds in the pco first

    25-Mar-1994 update 
        Modified function to enumerate clipping region if destination
        rectangle exists.

Revision History:


--*/

{
    PPDEV   pPDev;
    RECTL   rclDst;


    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DoFill: Invalid pPDev in psoDst"));
        return(FALSE);
    }

    //
    // Here we have to see if the clip obj is trivial or non existant, in which
    // case we pass this directly to fill rect.
    //

    if ((!pco)                          ||
        (pco->iDComplexity == DC_RECT)  ||
        (pco->iDComplexity == DC_TRIVIAL)) {

        if ((pco) && (pco->iDComplexity == DC_RECT)) {

            PLOTDBG(DBG_DOFILL,
              ("DoFill: pco = RECT %s", (prclDst) ? ", WITH dest rect" : "" ));

            //
            // First grab the destination as the bounding rect since,
            // we have a RECT clipping region
            //

            rclDst = pco->rclBounds;

            //
            // Now if we also had a destination rect passed in as well,
            // intersect down to the final rect
            //

            if (prclDst) {

                if ( !IntersectRECTL(&rclDst, prclDst)) {

                   return( TRUE );

                }
            }

            //
            // And finally point to the new rect for the fill
            //

            prclDst = &rclDst;

        } else if (!prclDst) {


            PLOTWARN(
              ("DoFill: No destination rectange and NULL or TRIVIAL pco!"));

            //
            // We don't have any clipping so fill the target rect
            //

            rclDst.left   =
            rclDst.top    = 0;
            rclDst.right  = psoDst->sizlBitmap.cx;
            rclDst.bottom = psoDst->sizlBitmap.cy;
            prclDst       = &rclDst;
        }

        return(DoRect(pPDev,
                      prclDst,
                      pbo,
                      NULL,
                      pptlBrush,
                      Rop4,
                      NULL,
                      FPOLY_FILL));

    } else {

        BOOL        Ok = TRUE;
        BOOL        bMore;
        HTENUMRCL   EnumRects;
        PRECTL      pCurClipRect;

        //
        // We have complex clipping but we also have a destination rect to
        // fill, this means we have to enum the clipping region as rects
        // so we can intersect each one with the target rect..
        //

        PLOTDBG(DBG_DOFILL,
                 ("DoFill: pco = COMPLEX %s", (prclDst) ? ", WITH dest rect" : "" ));

        if (prclDst) {


            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);
            bMore = TRUE;

            do {

                //
                // See if the job has been aborted
                //

                if (PLOT_CANCEL_JOB(pPDev)) {

                    break;
                }

                //
                // Grab the next batch of rectangles
                //

                if (bMore) {

                    bMore = CLIPOBJ_bEnum(pco, sizeof(EnumRects), (ULONG *)&EnumRects);
                }
                
                if (bMore == DDI_ERROR)
                {
                    bMore = FALSE;
                    Ok = FALSE;
                    break;
                }


                //
                /// Set up for enuming the clip rectangles
                //

                pCurClipRect = (PRECTL)&EnumRects.rcl[0];


                while ((Ok) && (EnumRects.c--)) {

                    rclDst = *pCurClipRect;

                    //
                    // Make sure we have something left to fill after the
                    // intersect
                    //

                    if( IntersectRECTL(&rclDst, prclDst) ) {

                        Ok = DoRect( pPDev,
                                     &rclDst,
                                     pbo,
                                     NULL,
                                     pptlBrush,
                                     Rop4,
                                     NULL,
                                     FPOLY_FILL );

                    }
                    pCurClipRect++;
                }


            } while ( bMore );


        } else {


            Ok = DoPolygon(pPDev,
                           NULL,
                           pco,
                           NULL,
                           pptlBrush,
                           pbo,
                           NULL,
                           Rop4,
                           NULL,
                           FPOLY_FILL);


       }

       return(Ok);
    }
}




BOOL
DrvPaint(
    SURFOBJ     *psoDst,
    CLIPOBJ     *pco,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrushOrg,
    MIX         Mix
    )

/*++

Routine Description:

    This function is the most basic drawing function in the driver. As graphic
    calls get failed, the NT graphics engine will reduce those other calls
    (if we fail them) down to DrvPaint. We cannot fail DrvPaint as the engine
    has nowhere else to go.

Arguments:

    Per DDI Spec.


Return Value:

    TRUE of OK, FALSE if falied

Author:

    Created 

    18-Dec-1993 Sat 09:27:29 updated  
        Updated, commented, change to correct formal header

    15-Jan-1994 Sat 00:38:41 updated  
        Re-arranged and call DrvBitBlt() if can do a damm thing.


Revision History:


--*/

{
    PPDEV       pPDev;
    RECTL       rclDst;
    DWORD       Rop4;

    //
    // get our PDEV from the SURFOBJ
    //

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvPaint: Invalid pPDev in pso"));
        return(FALSE);
    }

    PLOTASSERT(0, "DrvPaint: WARNING: pco [%08lx] is NULL or DC_TRIVIAL???",
                (pco) && (pco->iDComplexity != DC_TRIVIAL), pco);

    if ((pco)                               &&
        (pco->iDComplexity == DC_TRIVIAL)   &&
        (pco->iFComplexity == FC_RECT)) {

        PLOTWARN(("DrvPaint: <pco> DC_TRIVIAL but NOT FC_RECT, make DC_RECT ??? (%ld,%ld)-(%ld,%ld)",
                    pco->rclBounds.left,
                    pco->rclBounds.top,
                    pco->rclBounds.right,
                    pco->rclBounds.bottom));

        pco->iDComplexity = DC_RECT;
    }

    //
    // Make sure we don't pass a NULL rect.
    //

    if ((pco) && (pco->iDComplexity != DC_TRIVIAL)) {

        rclDst = pco->rclBounds;

    } else {

        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = psoDst->sizlBitmap.cx;
        rclDst.bottom = psoDst->sizlBitmap.cy;
    }

    Rop4 = MixToRop4(Mix);

    //
    // If we can actually draw the passed object with device brushes (etc)
    // then do it now. Otherwise, we will have to simulate it via DrvBitBlt
    //

    if (GetColor(pPDev, pbo, NULL, NULL, Rop4) > 0) {

        PLOTDBG(DBG_DRVPAINT, ("DrvPAINT: Calling DoFill()"));

        return(DoFill(psoDst,               // psoDst
                      NULL,                 // psoSrc
                      pco,                  // pco
                      NULL,                 // pxlo
                      NULL,                 // prclDest only fill based on pco
                      NULL,                 // prclSrc
                      pbo,                  // pbo
                      pptlBrushOrg,         // pptlBrushOrg
                      Rop4));               // Rop4

    } else {

        PLOTDBG(DBG_DRVPAINT, ("DrvPAINT: Can't do it Calling DrvBitBlt()"));

        return(DrvBitBlt(psoDst,            // psoDst
                         NULL,              // psoSrc
                         NULL,              // psoMask
                         pco,               // pco
                         NULL,              // pxlo
                         &rclDst,           // prclDst
                         (PPOINTL)&rclDst,  // pptlSrc
                         NULL,              // pptlMask
                         pbo,               // pbo,
                         pptlBrushOrg,      // pptlBrushOrg,
                         Rop4));            // Rop4
    }
}





BOOL
DrvFillPath(
    SURFOBJ     *pso,
    PATHOBJ     *ppo,
    CLIPOBJ     *pco,
    BRUSHOBJ    *pbo,
    POINTL      *pptlBrushOrg,
    MIX         Mix,
    FLONG       flOptions
    )

/*++

Routine Description:

    This function will take a PATHOBJ as a parameter and fill in
    the closed region with the specified brush.

Arguments:

    Per DDI spec.


Return Value:

    TRUE if ok, FALSE if error

Author:

    18-Dec-1993 Sat 09:27:29 created  
        Updated, commented


    Created 

Revision History:


--*/

{
    PPDEV    pPDev;
    ULONG    ulOptions;
    ROP4     rop4;
    BOOL     bRetVal;



    //
    // Convert the mix to a rop since we  use it more than once
    //

    rop4 = MixToRop4(Mix);

    PLOTDBG(DBG_DRVFILLPATH, ("DrvFillPath: Mix = %x, Rop4 = %x", Mix, rop4));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvFillPath: Invalid pPDev in pso"));
        return(FALSE);
    }


    //
    // Get color will tell us if the requested op can be done in HPGL2 mode
    // if it cant, we have to simulate via DrvBitBlt
    //

    if (GetColor(pPDev, pbo, NULL, NULL, rop4) > 0 ) {

       ulOptions = FPOLY_FILL;

       if (flOptions & FP_WINDINGMODE) {

          //
          // Set the flag to notify the generic path code about the fill type
          //

          ulOptions |= FPOLY_WINDING;
       }

       bRetVal = DoPolygon(pPDev,
                           NULL,
                           pco,
                           ppo,
                           pptlBrushOrg,
                           pbo,
                           NULL,
                           rop4,
                           NULL,
                           ulOptions);
    } else {

       bRetVal = FALSE;

       PLOTDBG(DBG_DRVFILLPATH, ("DrvFillPath: Failing because GetColor <= 0 "));

    }

    return( bRetVal );
}





BOOL
DrvStrokeAndFillPath(
    SURFOBJ     *pso,
    PATHOBJ     *ppo,
    CLIPOBJ     *pco,
    XFORMOBJ    *pxo,
    BRUSHOBJ    *pboStroke,
    LINEATTRS   *plineattrs,
    BRUSHOBJ    *pboFill,
    POINTL      *pptlBrushOrg,
    MIX         MixFill,
    FLONG       flOptions
    )

/*++

Routine Description:

    This function will take a PATHOBJ as a parameter, fill in
    the closed region with the FILL brush, and stroke the path with
    the STROKE brush.


Arguments:

    Per DDI

Return Value:

    TRUE if ok, FALSE if error


Author:

    18-Dec-1993 Sat 09:27:29 created  
        Updated, commented


    Created by 


Revision History:


--*/

{
    PPDEV       pPDev;
    ULONG       ulOptions;
    BOOL        bRetVal;
    ROP4        rop4;


    //
    // Convert the mix to a rop since we  use it more than once
    //

    rop4 = MixToRop4(MixFill);


    PLOTDBG(DBG_DRVSTROKEANDFILL, ("DrvStrokeAndFillPath: Mix = %x, Rop4 = %x", MixFill, rop4));

    if (!(pPDev = SURFOBJ_GETPDEV(pso))) {

        PLOTERR(("DrvStrokeAndFillPath: Invalid pPDev in pso"));
        return(FALSE);
    }




    if (GetColor(pPDev, pboFill, NULL, NULL, rop4) > 0 ) {


       ulOptions = FPOLY_STROKE | FPOLY_FILL;

       if (flOptions & FP_WINDINGMODE) {

          ulOptions |= FPOLY_WINDING;
       }

       bRetVal = DoPolygon(pPDev,
                           NULL,
                           pco,
                           ppo,
                           pptlBrushOrg,
                           pboFill,
                           pboStroke,
                           rop4,
                           plineattrs,
                           ulOptions);
    } else {


       bRetVal = FALSE;

       PLOTDBG(DBG_DRVSTROKEANDFILL,
                ("DrvStrokeAndFillPath: Failing because GetColor is <= 0",
                MixFill, rop4));

    }

    return(bRetVal);
}




BOOL
DrvCopyBits(
   SURFOBJ  *psoDst,
   SURFOBJ  *psoSrc,
   CLIPOBJ  *pco,
   XLATEOBJ *pxlo,
   RECTL    *prclDst,
   POINTL   *pptlSrc
   )

/*++

Routine Description:

    Convert between two bitmap formats

Arguments:

    Per Engine spec.

Return Value:

    BOOLEAN


Author:

    11-Feb-1993 Thu 21:00:43 created  

    09-Feb-1994 Wed 16:49:17 updated  
        Adding rclHTBlt to have psoHTBlt correctly tiled, also check if the
        pco is passed.

    19-Jan-1994 Wed 14:28:45 updated  
        Adding hack to handle EngStretchBlt() to our own temp surfobj

    06-Jan-1994 Thu 04:34:37 updated  
        Make sure we do not do this for pen plotter

    01-Mar-1994 Tue 10:51:58 updated  
        Make the call to BandingHTBlt() rather to EngStretchBlt()


Revision History:


--*/

{
    SURFOBJ *psoHTBlt;
    PPDEV   pPDev;
    RECTL   rclDst;


    //
    // Copy down the destination rectangle
    //

    rclDst = *prclDst;

    PLOTDBG(DBG_COPYBITS, ("DrvCopyBits: Dst=(%ld, %ld)-(%ld-%ld) [%ld x %ld]",
                rclDst.left, rclDst.top, rclDst.right, rclDst.bottom,
                rclDst.right - rclDst.left,
                rclDst.bottom - rclDst.top));

    //
    // The DrvCopyBits() function lets applicatiosn convert between bitmap and
    // device formats.
    //
    // BUT... for our plotter device we cannot read the printer surface
    //        bitmap back, so tell the caller that we cannot do it if they
    //        really called us with that sort of request.
    //

    if (psoSrc->iType != STYPE_BITMAP) {

        DWORD   Color = 0xFFFFFF;

        PLOTASSERT(1, "DrvCopyBits: psoSrc->iType not STYPE_DEVICE",
                    psoSrc->iType == STYPE_DEVICE, psoSrc->iType);

        //
        // Someone tried to copy from a non-bitmap surface, ie STYPE_DEVICE
        //

        if (pxlo) {

            Color = XLATEOBJ_iXlate(pxlo, Color);
        }

        //
        // If we doing XOR then we want to have all area = 0 first
        //

        if (!(pPDev = SURFOBJ_GETPDEV(psoSrc))) {

            PLOTERR(("DrvCopyBits: invalid pPDev"));
            return(FALSE);
        }

        if (pPDev->Rop3CopyBits == 0x66) {

            PLOTWARN(("DrvCopyBits: Rop3CopyBits = 0x66, Color = 0x0"));
            Color = 0;
        }

        PLOTWARN(("DrvCopyBits: Cannot copy from DEVICE, Do EngErase=(%ld,%ld)-(%ld, %ld), COLOR=%08lx)",
                rclDst.left, rclDst.top, rclDst.right, rclDst.bottom, Color));

        return(EngEraseSurface(psoDst, prclDst, Color));
    }

    if (psoDst->iType != STYPE_DEVICE) {

        //
        // Someone tried to copy to bitmap surface, ie STYPE_BITMAP
        //

        PLOTWARN(("DrvCopyBits: Cannot copy to NON-DEVICE destination"));

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvCopyBits: invalid pPDev"));
        return(FALSE);
    }

    //
    // If this is us calling ourselves during bitmap handling do it now.
    //

    if (psoHTBlt = pPDev->psoHTBlt) {

        PLOTDBG(DBG_TEMPSRC, ("DrvCopyBits: psoHTBlt=%ld x %ld, psoSrc=%ld x %ld, pptlSrc=(%ld, %ld)",
                    psoHTBlt->sizlBitmap.cx, psoHTBlt->sizlBitmap.cy,
                    psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy,
                    pptlSrc->x, pptlSrc->y));

        PLOTDBG(DBG_TEMPSRC, ("DrvCopyBits: szlHTBlt=(%ld, %ld)-(%ld, %ld) = %ld x %ld",
                        pPDev->rclHTBlt.left,  pPDev->rclHTBlt.top,
                        pPDev->rclHTBlt.right, pPDev->rclHTBlt.bottom,
                        pPDev->rclHTBlt.right - pPDev->rclHTBlt.left,
                        pPDev->rclHTBlt.bottom - pPDev->rclHTBlt.top));

        PLOTASSERT(1, "DrvCopyBits: psoHTBlt Type != psoSrc Type",
                    psoHTBlt->iType == psoSrc->iType, 0);

        PLOTASSERT(0, "DrvCopyBits: ??? pptlSrc [%08lx] != (0, 0)",
                    (pptlSrc->x == 0) && (pptlSrc->y == 0), pptlSrc);

        if ((!pco) || (pco->iDComplexity == DC_TRIVIAL)) {

            PLOTASSERT(1, "DrvCopyBits: psoHTBlt Size < psoSrc Size",
                    (psoHTBlt->sizlBitmap.cx >= psoSrc->sizlBitmap.cx) &&
                    (psoHTBlt->sizlBitmap.cy >= psoSrc->sizlBitmap.cy), 0);

            PLOTASSERT(1, "DrvCopyBits: rclHTBlt > psoHTBlt size",
                    (pPDev->rclHTBlt.left   <= psoHTBlt->sizlBitmap.cx) &&
                    (pPDev->rclHTBlt.right  <= psoHTBlt->sizlBitmap.cx) &&
                    (pPDev->rclHTBlt.top    <= psoHTBlt->sizlBitmap.cy) &&
                    (pPDev->rclHTBlt.bottom <= psoHTBlt->sizlBitmap.cy),
                    0);

            PLOTASSERT(1, "DrvCopyBits: pPDev->rclHTBlt Size != psoSrc Size",
                ((pPDev->rclHTBlt.right - pPDev->rclHTBlt.left) ==
                                                    psoSrc->sizlBitmap.cx) &&
                ((pPDev->rclHTBlt.bottom - pPDev->rclHTBlt.top) ==
                                                    psoSrc->sizlBitmap.cy),
                0);

        } else if (pco->iDComplexity == DC_RECT) {

            PLOTWARN(("DrvCopyBits: **** MAY BE EngStretchBlt(HALFTONE) FAILED but we got EngStretchBlt(COLORONCOLOR) instead"));

            PLOTASSERT(1, "DrvCopyBits: rclHTBlt != pco->rclBounds, pco=%08lx",
                ((pPDev->rclHTBlt.right - pPDev->rclHTBlt.left) ==
                 (pco->rclBounds.right - pco->rclBounds.left)) &&
                ((pPDev->rclHTBlt.bottom - pPDev->rclHTBlt.top) ==
                 (pco->rclBounds.bottom - pco->rclBounds.top)), pco);

        } else {

            PLOTASSERT(1, "DrvCopyBits: <psoHTBlt>, pco [%08lx] is Complex.",
                       pco->iDComplexity != DC_COMPLEX, pco);
        }

        if (!EngCopyBits(psoHTBlt,              // psoDst
                         psoSrc,                // psoSrc
                         pco,                   // pco
                         NULL,                  // pxlo
                         &(pPDev->rclHTBlt),    // prclDst
                         pptlSrc)) {            // pptlSrc

            PLOTERR(("DrvCopyBits: EngCopyBits(psoHTBlt, psoSrc) Failed"));
        }

        return(TRUE);
    }

    if (!IS_RASTER(pPDev)) {

        PLOTDBG(DBG_COPYBITS, ("DrvCopyBits: Pen Plotter: IGNORE and return OK"));
        return(TRUE);
    }

    //
    // First validate everything to see if this one is the halftoned result
    // or is compatible with halftoned result, otherwise we will call
    // EngStretchBlt(HALFTONE) halftone the sources then it will eventually
    // come back to this function to output the halftoned result.
    //

    if (IsHTCompatibleSurfObj(pPDev,
                              psoSrc,
                              pxlo,
                              ISHTF_ALTFMT | ISHTF_HTXB | ISHTF_DSTPRIM_OK)) {

        DWORD   Rop;

        if (!(Rop = (DWORD)(pPDev->Rop3CopyBits & 0xFF))) {

            Rop = 0xCC;
        }

        PLOTDBG(DBG_COPYBITS, ("DrvCopyBits: HTCompatible: Rop=%08lx", Rop));

        pPDev->Rop3CopyBits = 0xCC;     // RESET!!!

        return(OutputHTBitmap(pPDev,
                              psoSrc,
                              pco,
                              (PPOINTL)&rclDst,
                              NULL,
                              Rop,
                              NULL));

    } else {

        RECTL   rclSrc;


        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        //
        // Validate that we only BLT the available source size
        //

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy)) {

            PLOTWARN(("DrvCopyBits: Engine passed SOURCE != DEST size, CLIP IT"));

            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;

            rclDst.right  = (LONG)(rclSrc.right - rclSrc.left + rclDst.left);
            rclDst.bottom = (LONG)(rclSrc.bottom - rclSrc.top + rclDst.top);
        }

        PLOTDBG(DBG_COPYBITS, ("DrvCopyBits CALLING BandingHTBlt()"));

        return(BandingHTBlt(pPDev,          // pPDev
                            psoDst,         // psoDst
                            psoSrc,         // psoSrc
                            NULL,           // psoMask,
                            pco,            // pco
                            pxlo,           // pxlo
                            NULL,           // pca
                            NULL,           // pptlHTOrg
                            &rclDst,        // prclDst
                            &rclSrc,        // prclSrc
                            NULL,           // pptlMask
                            0xCCCC,         // HTRop3
                            FALSE));        // InvertMask
    }

}




BOOL
DrvStretchBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    PRECTL          prclDst,
    PRECTL          prclSrc,
    PPOINTL         pptlMask,
    ULONG           iMode
    )

/*++

Routine Description:

    This function halftones a source rectangle and optionally can invert
    the source and handle a mask.

    It also provides, StretchBlt capabilities between Device managed and
    GDI managed surfaces. We want the driver to be able to write on GDI
    managed bitmaps, especially when doing halftoning. This allows the same
    algorithm to be used for both GDI and device surfaces.

    This function is optional in drivers, it can return FALSE if it does
    not know how to handle the work.

Arguments:

    psoDst      - This is a pointer to a SURFOBJ.    It identifies the surface
                  on which to draw.

    psoSrc      - This SURFOBJ defines the source for the Blt operation.  The
                  driver must call GDI Services to find out if this is a device
                  managed  surface or a bitmap managed by GDI.

    psoMask     - This optional surface provides a mask for the source.  It is
                  defined by a logic map, i.e. a bitmap with one bit per pel.

                  The mask is used to limit the area of the source that is
                  copied.  When a mask is provided there is an implicit rop4 of
                  0xCCAA, which means that the source should be copied wherever
                  the mask is 1, but the destination should be left alone
                  wherever the mask is 0.

                  When this argument is NULL there is an implicit rop4 of
                  0xCCCC, which means that the source should be copied
                  everywhere in the source rectangle.

                  The mask will always be large enough to contain the source
                  rectangle, tiling does not need to be done.

    pco         - This is a pointer to a CLIPOBJ.    GDI Services are provided
                  to enumerate the clipping region as a set of rectangles or
                  trapezoids. This limits the area of the destination that will
                  be modified.

                  Whenever possible, GDI will simplify the clipping involved.
                  However, unlike DrvBitBlt, DrvStretchBlt may be called with a
                  single clipping rectangle.  This is necessary to prevent
                  roundoff errors in clipping the output.

    pxlo        - This is a pointer to an XLATEOBJ.  It tells how color indices
                  should be translated between the source and target surfaces.

                  The XLATEOBJ can also be queried to find the RGB color for
                  any source index.  A high quality stretching Blt will need
                  to interpolate colors in some cases.

    pca         - This is a pointer to COLORADJUSTMENT structure, if NULL it
                  specified that appiclation did not set any color adjustment
                  for this DC, and is up to the driver to provide default
                  adjustment

    pptlBrushOrg- Pointer to the POINT structure to specified the location
                  where halftone brush should alignment to, if this pointer is
                  NULL then it assume that (0, 0) as origin of the brush

    prclDst     - This RECTL defines the area in the coordinate system of the
                  destination surface that can be modified.

                  The rectangle is defined by two points.    These points are
                  not well ordered, i.e. the coordinates of the second point
                  are not necessarily larger than those of the first point.
                  The rectangle they describe does not include the lower and
                  right edges.  DrvStretchBlt will never be called with an
                  empty destination rectangle.

                  DrvStretchBlt can do inversions in both x and y, this happens
                  when the destination rectangle is not well ordered.

    prclSrc     - This RECTL defines the area in the coordinate system of the
                  source surface that will be copied.  The rectangle is defined
                  by two points, and will map onto the rectangle defined by
                  prclDst.  The points of the source rectangle are well
                  ordered.  DrvStretch will never be given an empty source
                  rectangle.

                  Note that the mapping to be done is defined by prclSrc and
                  prclDsst. To be precise, the given points in prclDst and
                  prclSrc lie on integer coordinates, which we consider to
                  correspond to pel centers.  A rectangle defined by two such
                  points should be considered a geometric rectangle with two
                  vertices whose coordinates are the given points, but with 0.5
                  subtracted from each coordinate.  (The POINTLs should just be
                  considered a shorthand notation for specifying these
                  fractional coordinate vertices.)  Note thate the edges of any
                  such rectangle never intersect a pel, but go around a set of
                  pels.  Note also that the pels that are inside the rectangle
                  are just what you would expect for a "bottom-right exclusive"
                  rectangle.  The mapping to be done by DrvStretchBlt will map
                  the geometric source rectangle exactly onto the geometric
                  destination rectangle.

    pptlMask    - This POINTL specifies which pel in the given mask corresponds
                  to the upper left pel in the source rectangle.  Ignore this
                  argument if there is no given mask.


    iMode       - This defines how source pels should be combined to get output
                  pels. The methods SB_OR, SB_AND, and SB_IGNORE are all simple
                  and fast.  They provide compatibility for old applications,
                  but don't produce the best looking results for color surfaces.


                  SB_OR         On a shrinking Blt the pels should be combined
                                with an OR operation.  On a stretching Blt pels
                                should be replicated.

                  SB_AND        On a shrinking Blt the pels should be combined
                                with an AND operation.  On a stretching Blt
                                pels should be replicated.

                  SB_IGNORE     On a shrinking Blt enough pels should be
                                ignored so that pels don't need to be combined.
                                On a stretching Blt pels should be replicated.

                  SB_BLEND      RGB colors of output pels should be a linear
                                blending of the RGB colors of the pels that get
                                mapped onto them.

                  SB_HALFTONE   The driver may use groups of pels in the output
                                surface to best approximate the color or gray
                                level of the input.

                  For this function we will ignored this parameter and always
                  output the SB_HALFTONE result

Return Value:


    TRUE if sucessful FALSE if failed

Author:

    11-Feb-1993 Thu 19:52:29 created  

    06-Jan-1994 Thu 04:34:37 updated  
        Make sure we do not do this for pen plotter

    23-Feb-1994 Wed 11:02:45 updated  
        Re-write and take banding the bitmap into account

    01-Mar-1994 Tue 10:55:03 updated  
        spawan out to a separate function and Make call to BandingHTBlt()

Revision History:


--*/

{
    PPDEV   pPDev;

    UNREFERENCED_PARAMETER(iMode);          // we always do HALFTONE

    //
    // get the pointer to our DEVDATA structure and make sure it is ours.
    //

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvStretchBlt: invalid pPDev"));
        return(FALSE);
    }

    return(BandingHTBlt(pPDev,          // pPDev
                        psoDst,         // psoDst
                        psoSrc,         // psoSrc
                        psoMask,        // psoMask,
                        pco,            // pco
                        pxlo,           // pxlo
                        pca,            // pca
                        pptlBrushOrg,   // pptlHTOrg
                        prclDst,        // prclDst
                        prclSrc,        // prclSrc
                        pptlMask,       // pptlMask
                        0x88CC,         // HTRo3
                        FALSE));        // InvertMask
}





BOOL
DrvBitBlt(
    SURFOBJ     *psoDst,
    SURFOBJ     *psoSrc,
    SURFOBJ     *psoMask,
    CLIPOBJ     *pco,
    XLATEOBJ    *pxlo,
    PRECTL      prclDst,
    PPOINTL     pptlSrc,
    PPOINTL     pptlMask,
    BRUSHOBJ    *pbo,
    PPOINTL     pptlBrushOrg,
    ROP4        Rop4
    )

/*++

Routine Description:

    Provides general Blt capabilities to device managed surfaces.  The Blt
    might be from an Engine managed bitmap.  In that case, the bitmap is
    one of the standard format bitmaps.    The driver will never be asked
    to Blt to an Engine managed surface.

    This function is required if any drawing is done to device managed
    surfaces.  The basic functionality required is:

      1    Blt from any standard format bitmap or device surface to a device
           surface,

      2    with any ROP,

      3    optionally masked,

      4    with color index translation,

      5    with arbitrary clipping.

    Engine services allow the clipping to be reduced to a series of clip
    rectangles.    A translation vector is provided to assist in color index
    translation for palettes.

    This is a large and complex function.  It represents most of the work
    in writing a driver for a raster display device that does not have
    a standard format frame buffer.  The Microsoft VGA driver provides
    example code that supports the basic function completely for a planar
    device.

    NOTE: Plotters do not support copying from device bitmaps. Nor can they
          perform raster operations on bitmaps.  Therefore, it is not possible
          to support ROPs which interact with the destination (ie inverting
          the destination).  The driver will do its best to map these ROPs
          into ROPs utilizing functions on the Source or Pattern.

          This driver supports the bitblt cases indicated below:

          Device -> Memory  No
          Device -> Device  No
          Memory -> Memory  No
          Memory -> Device  Yes
          Brush  -> Memory  No
          Brush  -> Device  Yes


Arguments:


    psoDest         - This is a pointer to a device managed SURFOBJ.  It
                      identifies the surface on which to draw.

    psoSrc          - If the rop requires it, this SURFOBJ defines the source
                      for the Blt operation.  The driver must call the Engine
                      Services to find out if this is a device managed surface
                      or a bitmap managed by the Engine.

    psoMask         - This optional surface provides another input for the
                      Rop4.  It is defined by a logic map, i.e. a bitmap with
                      one bit per pel.  The mask is typically used to limit the
                      area of the destination that should be modified.  This
                      masking is accomplished by a Rop4 whose lower byte is AA,
                      leaving the destination unaffected when the mask is 0.

                      This mask, like a brush, may be of any size and is
                      assumed to tile to cover the destination of the Blt.  If
                      this argument is NULL and a mask is required by the Rop4,
                      the implicit mask in the brush will be used.

    pco             - This is a pointer to a CLIPOBJ.    Engine Services are
                      provided to enumerate the clipping region as a set of
                      rectangles or trapezoids.  This limits the area of the
                      destination that will be modified.  Whenever possible,
                      the Graphics Engine will simplify the clipping involved.
                      For example, BitBlt will never be called with exactly one
                      clipping rectangle.    The Engine will have clipped the
                      destination rectangle before calling, so that no clipping
                      needs to be considered.

    pxlo            - This is a pointer to an XLATEOBJ.  It tells how color
                      indices should be translated between the source and
                      target surfaces.

                      If the source surface is palette managed, then its colors
                      are represented by indices into a list of RGB colors.
                      In this case, the XLATEOBJ can be queried to get a
                      translate vector that will allow the device driver to
                      quickly translate any source index into a color index for
                      the destination.

                      The situation is more complicated when the source is, for
                      example, RGB but the destination is palette managed.  In
                      this case a closest match to each source RGB must be
                      found in the destination palette.  The XLATEOBJ provides
                      a service routine to do this matching.  (The device
                      driver is allowed to do the matching itself when the
                      target palette is the default device palette.)

    prclDst         - This RECTL defines the area in the coordinate system of
                      the destination surface that will be modified.  The
                      rectangle is defined as two points, upper left and lower
                      right.  The lower and right edges of this rectangle are
                      not part of the Blt, i.e. the rectangle is lower right
                      exclusive.  vBitBlt will never be called with an empty
                      destination rectangle, and the two points of the
                      rectangle will always be well ordered.

    pptlSrc         - This POINTL defines the upper left corner of the source
                      rectangle, if there is a source.  Ignore this argument
                      if there is no source.

    pptlMask        - This POINTL defines which pel in the mask corresponds to
                      the upper left corner of the destination rectangle.
                      Ignore this argument if no mask is provided with psoMask.

    pdbrush         - This is a pointer to the device's realization of the
                      brush to be used in the Blt.  The pattern for the Blt is
                      defined by this brush.  Ignore this argument if the Rop4
                      does not require a pattern.

    pptlBrushOrg    - This is a pointer to a POINTL which defines the origin of
                      the brush.  The upper left pel of the brush is aligned
                      here and the brush repeats according to its dimensions.
                      Ignore this argument if the Rop4 does not require a
                      pattern.

    Rop4            - This raster operation defines how the mask, pattern,
                      source, and destination pels should be combined to
                      determine an output pel to be written on the destination
                      surface.

                      This is a quaternary raster operation, which is a natural
                      extension of the usual ternary rop3.  There are 16
                      relevant bits in the Rop4,  these are like the 8 defining
                      bits of a rop3.  (We ignore the other bits of the rop3,
                      which are redundant.)    The simplest way to implement a
                      Rop4 is to consider its two bytes separately.  The lower
                      byte specifies a rop3 that should be computed wherever
                      the mask is 0.  The high byte specifies a rop3 that
                      should then be computed and applied wherever the mask
                      is 1.


Return Value:

    TRUE if sucessfule FALSE otherwise


Author:

    04-Dec-1990     
        Wrote it.

    27-Mar-1992 Fri 00:08:43 updated  
        1) Remove 'pco' parameter and replaced it with prclClipBound parameter,
           since pco is never referenced, prclClipBound is used for the
           halftone.
        2) Add another parameter to do NOTSRCCOPY

    11-Feb-1993 Thu 21:29:15 updated  
        Modified so that it call DrvStretchBlt(HALFTONE) when it can.

    18-Dec-1993 Sat 09:08:16 updated  
        Clean up for plotter driver

    06-Jan-1994 Thu 04:34:37 updated  
        Make sure we do not do this for pen plotter

    15-Jan-1994 Sat 04:02:22 updated  
        Re-write

    17-Mar-1994 Thu 22:36:42 updated  
        Changed it so we only use PATTERN=psoMask if the ROP4 do not required
        PATTERNs and a MASK is required


Revision History:


--*/

{
    PPDEV       pPDev;
    DWORD       Rop3FG;
    DWORD       Rop3BG;
    RECTL       rclSrc;
    RECTL       rclPat;
    UINT        i;
    BOOL        Ok = TRUE;


    //
    // if the source is NULL it must be a fill, so call the fill code,
    //

    PLOTDBG(DBG_BITBLT, ("DrvBitBlt: ROP4  = %08lx", Rop4));

    PLOTASSERT(1, "DrvBitBlt: Invalid ROP code = %08lx",
                                            (Rop4 & 0xffff0000) == 0, Rop4);

    //
    // get the pointer to our DEVDATA structure and make sure it is ours.
    //

    if (!(pPDev = SURFOBJ_GETPDEV(psoDst))) {

        PLOTERR(("DrvBithBlt: invalid pPDev"));
        return(FALSE);
    }

    if (IS_RASTER(pPDev)) {

        i = (UINT)pPDev->pPlotGPC->ROPLevel;

    } else {

        PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Pen Plotter: TRY ROP_LEVEL_0"));

        i = ROP_LEVEL_0;
    }

    Rop3BG = (DWORD)ROP4_BG_ROP(Rop4);
    Rop3FG = (DWORD)ROP4_FG_ROP(Rop4);

    switch (i) {

    case ROP_LEVEL_0:

        //
        // For RopLevel 0, or Pen Plotter we will only process the pattern
        // which is compatible with our device
        //

        if (ROP3_NEED_PAT(Rop3FG)) {

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device ROP_LEVEL_0, NEED PAT"));

            if (GetColor(pPDev, pbo, NULL, NULL, Rop3FG) <= 0) {

                PLOTWARN(("DrvBitBlt: NOT Device Comptible PAT"));
                return(TRUE);
            }

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device ROP_LEVEL_0, TRY COMPATIBLE PAT"));

        } else {

            PLOTWARN(("DrvBitBlt: Device ROP_LEVEL_0, CANNOT Do RASTER BLT"));
            return(TRUE);
        }

        //
        // Make it PAT Copy
        //

        Rop4   = 0xF0F0;
        Rop3BG =
        Rop3FG = 0xF0;

        break;

    case ROP_LEVEL_1:

        //
        // Can only do ROP1 SRC COPY/NOT SRCCOPY
        //

        PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device ROP_LEVEL_1, Rop4=%08lx", Rop4));

        switch(Rop4 = ROP4_FG_ROP(Rop4)) {

        case 0xAA:
        case 0xCC:
        case 0x33:

            break;

        default:

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Make ROP4 = 0xCC"));

            Rop4 = 0xCC;
            break;
        }

        Rop4 |= (Rop4 << 8);
        break;


    case ROP_LEVEL_2:
    case ROP_LEVEL_3:

        break;

    default:

        PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Device RopLevel=%ld, do nothing",
                                (DWORD)pPDev->pPlotGPC->ROPLevel));
        return(TRUE);
    }

    //
    // Do DrvStrethcBlt (HALFTONE) first if we can. Since there is no way
    // for us to read back the device surface we can only try our best
    // to simulate the requested drawing operation.
    //

    if (pptlSrc) {

        rclSrc.left = pptlSrc->x;
        rclSrc.top  = pptlSrc->y;

    } else {

        rclSrc.left =
        rclSrc.top  = 0;
    }

    rclSrc.right  = rclSrc.left + (prclDst->right - prclDst->left);
    rclSrc.bottom = rclSrc.top  + (prclDst->bottom - prclDst->top);

    switch (Rop4) {

    case 0xAAAA:    //  D

        return(TRUE);

    case 0xAACC:
    case 0xCCAA:
    case 0xAA33:
    case 0x33AA:

        //
        // If we have ~S (NOT SOURCE) then we want to make the non-mask area
        // black , we do this using S^D (0x66).
        //

        if ((Rop4 == 0xAA33) || (Rop4 == 0x33AA)) {

            Rop4 = 0x6666;

        } else {

            Rop4 = 0x8888;
        }

        return(BandingHTBlt(pPDev,                      // pPDev
                            psoDst,                     // psoDst
                            psoSrc,                     // psoSrc
                            psoMask,                    // psoMask,
                            pco,                        // pco
                            pxlo,                       // pxlo
                            NULL,                       // pca
                            pptlBrushOrg,               // pptlHTOrg
                            prclDst,                    // prclDst
                            &rclSrc,                    // prclSrc
                            pptlMask,                   // pptlMask
                            (WORD)Rop4,                 // HTRo3
                            Rop3FG == 0xAA));          // InvertMask

    case 0x3333:    // ~S
    case 0xCCCC:    //  S

        //
        // We will output the bitmap directly to the surface if the following
        // conditions are all met
        //
        //  1. SRC = STYPE_BITMAP
        //  2. Format is compatible with HT
        //

        if ((psoSrc->iType == STYPE_BITMAP) &&
            (IsHTCompatibleSurfObj(pPDev,
                                   psoSrc,
                                   pxlo,
                                   ISHTF_ALTFMT     |
                                    ISHTF_HTXB      |
                                    ISHTF_DSTPRIM_OK))) {

            return(OutputHTBitmap(pPDev,
                                  psoSrc,
                                  pco,
                                  (PPOINTL)prclDst,
                                  &rclSrc,
                                  Rop4 & 0xFF,
                                  NULL));

        } else {

            //
            // Call BandingHTBlt(Rop4) to do the job
            //

            return(BandingHTBlt(pPDev,                  // pPDev
                                psoDst,                 // psoDst
                                psoSrc,                 // psoSrc
                                NULL,                   // psoMask,
                                pco,                    // pco
                                pxlo,                   // pxlo
                                NULL,                   // pca
                                pptlBrushOrg,           // pptlHTOrg
                                prclDst,                // prclDst
                                &rclSrc,                // prclSrc
                                NULL,                   // pptlMask
                                (WORD)Rop4,             // HTRo3
                                FALSE));                // InvertMask
        }

        break;

    default:

        if ((Rop3BG != Rop3FG)          &&          // NEED MASK?
            (!ROP3_NEED_DST(Rop3BG))    &&
            (!ROP3_NEED_DST(Rop3FG))) {

            PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Not required DEST, Calling  EngBitBlt()"));

            if (!(Ok = EngBitBlt(psoDst,            // psoDst
                                 psoSrc,            // psoSrc
                                 psoMask,           // psoMask
                                 pco,               // pco
                                 pxlo,              // pxlo
                                 prclDst,           // prclDst
                                 pptlSrc,           // pptlSrc
                                 pptlMask,          // pptlMask
                                 pbo,               // pbo
                                 pptlBrushOrg,      // pptlBrushOrg ZERO
                                 Rop4))) {

                PLOTERR(("DrvBitBlt: EngBitBlt(%04lx) FAILED", Rop4));
            }

        } else {

            CLONESO CloneSO[CSI_TOTAL];

            //
            // Clear all the clone surface memory
            //

            ZeroMemory(CloneSO, sizeof(CloneSO));

            //
            // We will using psoMask as Pattern ONLY IF
            //
            //  1. ROP4 required a MASK
            //  2. Forground NOT required a PATTERN
            //  3. Background NOT reauired a PATTERN
            //

            if ((Rop3BG != Rop3FG)          &&
                (!ROP3_NEED_PAT(Rop3BG))    &&
                (!ROP3_NEED_PAT(Rop3FG))) {

                //
                // We will condense the ROP4 to a ROP3 and use the psoMAsk
                // as the Pattern. We must make sure the pptlBrushOrg is NULL
                // so we DON'T align rclPat on the destination.
                //

                Rop3FG = (Rop3BG & 0xF0) | (Rop3FG & 0x0F);
                Rop3BG = 0xAA;

                PLOTDBG(DBG_BITBLT, ("DrvBitBlt: Rop4=%04lx, Pattern=psoMask=%08lx, Rop3=%02lx/%02lx",
                                                Rop4, psoMask, Rop3BG, Rop3FG));

                rclPat.left   = pptlMask->x;
                rclPat.top    = pptlMask->y;
                rclPat.right  = rclPat.left + (rclSrc.right - rclSrc.left);
                rclPat.bottom = rclPat.top + (rclSrc.bottom - rclSrc.top);
                pptlBrushOrg  = NULL;

            } else {

                //
                // We will NOT do the background operation for now
                //

                if (Rop3FG == 0xAA) {

                    Rop3FG = Rop3BG;

                } else {

                    Rop3BG = Rop3FG;
                }

                //
                // We have a real pattern so make sure we aligned rclPat on
                // the destination correctly by passing a valid pptlBrushOrg,
                // NOTE: The rclPat will be setup by CloneBitBltSURFOBJ()
                //

                psoMask = NULL;

                if (!pptlBrushOrg) {

                    pptlBrushOrg = (PPOINTL)&ptlZeroOrigin;
                }
            }

            if (!(Ok = CloneBitBltSURFOBJ(pPDev,
                                          psoDst,
                                          psoSrc,
                                          psoMask,
                                          pxlo,
                                          prclDst,
                                          &rclSrc,
                                          &rclPat,
                                          pbo,
                                          CloneSO,
                                          Rop3BG,
                                          Rop3FG))) {

                PLOTDBG(DBG_BITBLT, ("DrvBitBlt: CloneBitbltSURFOBJ: failed"));
            }

            if (CloneSO[CSI_SRC].pso) {

                psoSrc = CloneSO[CSI_SRC].pso;
                pxlo   = NULL;
            }

            //
            // Only do background if BG != FG, and BG != DEST
            //

            if ((Ok) && (Rop3BG != Rop3FG) && (Rop3BG != 0xAA)) {

                if (!(Ok = DoRop3(pPDev,
                                  psoDst,
                                  psoSrc,
                                  CloneSO[CSI_PAT].pso,
                                  CloneSO[CSI_TMP].pso,
                                  pco,
                                  pxlo,
                                  prclDst,
                                  &rclSrc,
                                  &rclPat,
                                  pptlBrushOrg,
                                  pbo,
                                  Rop3BG))) {

                    PLOTERR(("DrvBitBlt(Rop3BG=%02lx) FAILED", Rop3BG));
                }
            }

            if ((Ok) && (Rop3FG != 0xAA)) {

                if (!(Ok = DoRop3(pPDev,
                                  psoDst,
                                  psoSrc,
                                  CloneSO[CSI_PAT].pso,
                                  CloneSO[CSI_TMP].pso,
                                  pco,
                                  pxlo,
                                  prclDst,
                                  &rclSrc,
                                  &rclPat,
                                  pptlBrushOrg,
                                  pbo,
                                  Rop3FG))) {

                    PLOTERR(("DrvBitBlt(Rop3FG=%02lx) FAILED", Rop3FG));
                }
            }

            //
            // Release all cloned objects
            //

            for (i = 0; i < CSI_TOTAL; i++) {

                if (CloneSO[i].pso) {

                    PLOTDBG(DBG_CSI, ("DrvBitBlt: EngUnlockSuface(%hs)", pCSIName[i]));

                    EngUnlockSurface(CloneSO[i].pso);
                }

                if (CloneSO[i].hBmp) {

                    PLOTDBG(DBG_CSI, ("DrvBitBlt: EngDeleteSurface(%hs)", pCSIName[i]));

                    if (!EngDeleteSurface((HSURF)CloneSO[i].hBmp)) {

                        PLOTERR(("PLOTTER: DrvBitBlt, EngDeleteSurface(%ld:%p) FAILED",
                                            (DWORD)i, (DWORD_PTR)CloneSO[i].hBmp));
                    }
                }
            }
        }

        break;
    }

    return(Ok);
}



ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

/*++

Routine Description:

    This is the hooked brush creation function, it asks CreateHalftoneBrush()
    to do the actual work (By returning DCR_HALFTONE).


Arguments:

    dhpdev      - DHPDEV passed, it is our pDEV

    iMode       - Not used

    rgbColor    - Solid rgb color to be used

    pulDither   - buffer to put the halftone brush.

Return Value:

    BOOLEAN

Author:

    02-May-1995 Tue 10:34:10 created  


Revision History:



--*/

{
    UNREFERENCED_PARAMETER(dhpdev);
    UNREFERENCED_PARAMETER(iMode);
    UNREFERENCED_PARAMETER(rgbColor);
    UNREFERENCED_PARAMETER(pulDither);

    return(DCR_HALFTONE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\compress.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    compress.c


Abstract:

    This module contains all data compression functions which analyze source
    scan line data and determines which compressin method (if any) is best to
    send the RTL data to the target device with a minimum number of bytes.

Author:

    18-Feb-1994 Fri 09:50:08 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgCompress

#define DBG_TIFF            0x00000001
#define DBG_DELTA           0x00000002
#define DBG_COMPRESS        0x00000004
#define DBG_OUTRTLSCAN      0x00000008
#define DBG_FLUSHADAPTBUF   0x00000010
#define DBG_ENTERRTLSCANS   0x00000020
#define DBG_DELTA_OFFSET0   0x00000040
#define DBG_NO_DELTA        0x40000000
#define DBG_NO_TIFF         0x80000000

DEFINE_DBGVAR(0);


#define TIFF_MIN_REPEATS            3
#define TIFF_MAX_REPEATS            128
#define TIFF_MAX_LITERAL            128
#define DELTA_MAX_ONE_REPLACE       8
#define DELTA_MAX_1ST_OFFSET        31
#define MIN_BLOCK_MODE_SIZE         8

//
// The MAX_ADAPT_SIZE is used to leave room for SET_ADAPT_CONTROL
//

#if (OUTPUT_BUFFER_SIZE >= (1024 * 32))
    #define MAX_ADAPT_SIZE              ((1024 * 32) - 16)
#else
    #define MAX_ADAPT_SIZE              (OUTPUT_BUFFER_SIZE - 16)
#endif


#define ADAPT_METHOD_ZERO           4
#define ADAPT_METHOD_DUP            5

#define SIZE_ADAPT_CONTROL          3

#define SET_ADAPT_CONTROL(pPDev, m, c)                                      \
{                                                                           \
    BYTE    bAdaptCtrl[4];                                                  \
                                                                            \
    bAdaptCtrl[0] = (BYTE)(m);                                              \
    bAdaptCtrl[1] = (BYTE)(((c) >> 8) & 0xFF);                              \
    bAdaptCtrl[2] = (BYTE)(((c)     ) & 0xFF);                              \
    OutputBytes(pPDev, bAdaptCtrl, 3);                                      \
}



BOOL
FlushAdaptBuf(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    BOOL        FlushEmptyDup
    )

/*++

Routine Description:

    This function flushes the adaptive encoding buffer mode.

Arguments:

    pPDev           - Pointer to our PDEV

    pRTLScans       - Pointer to the RTLSCANS data structure

    FlushEmptyDup   - TRUE if cEmptyDup need to be flush out also


Return Value:

    TRUE if OK,

Author:

    09-Mar-1994 Wed 20:32:31 created  


Revision History:


--*/

{
    DWORD   Count;
    WORD    cEmptyDup;
    BOOL    Ok = TRUE;


    Count = pPDev->cbBufferBytes;

    if (cEmptyDup = (FlushEmptyDup) ? pRTLScans->cEmptyDup : 0) {

        Count += SIZE_ADAPT_CONTROL;
    }

    if (Count) {

        DWORD   cbBufferBytes;
        BYTE    TmpBuf[32];


        PLOTDBG(DBG_FLUSHADAPTBUF, ("FlushAdaptBuf: Flush total %ld byte block",
                                Count));

        //
        // SAVE the OutputBuffer for this temporary header
        //

        CopyMemory(TmpBuf, pPDev->pOutBuffer, sizeof(TmpBuf));

        cbBufferBytes        = pPDev->cbBufferBytes;
        pPDev->cbBufferBytes = 0;

        //
        // Now output the header
        //

        OutputBytes(pPDev, "\033*b", 3);

        if (!pRTLScans->cAdaptBlk) {

            pRTLScans->cAdaptBlk++;
            OutputBytes(pPDev, "5m", 2);
        }

        OutputFormatStr(pPDev, "#dW", Count);

        //
        // FLUSH OUTPUT BUFFER AND RESTORE BACK the OutputBuffer for this
        // temporary header
        //

        PLOTDBG(DBG_FLUSHADAPTBUF, ("FlushAdaptBuf: Flush TmpBuf[%ld] bytes of HEADER",
                                pPDev->cbBufferBytes));

        FlushOutBuffer(pPDev);

        CopyMemory(pPDev->pOutBuffer, TmpBuf, sizeof(TmpBuf));
        pPDev->cbBufferBytes = cbBufferBytes;

        if (cEmptyDup) {

            PLOTDBG(DBG_FLUSHADAPTBUF, ("FlushAdaptBuf: Add %ld EmptyDup [%ld]",
                            (DWORD)cEmptyDup, (DWORD)pRTLScans->AdaptMethod));

            SET_ADAPT_CONTROL(pPDev, pRTLScans->AdaptMethod, cEmptyDup);

            pRTLScans->cEmptyDup = 0;
        }

        Ok = FlushOutBuffer(pPDev);

        //
        // After the block been sent the seed row is back to zero
        //

        ZeroMemory(pRTLScans->pbSeedRows[0],
                   (DWORD)pRTLScans->cxBytes * (DWORD)pRTLScans->Planes);
    }

    return(Ok);
}




VOID
ExitRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans
    )
/*++

Routine Description:

    This function completes processing of the SCANS data.

Arguments:

    pPDev       - Pointer to our PDEV

    pRTLScans   - Pointer to the RTLSCANS data structure to be initialized

Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    22-Feb-1994 Tue 12:14:17 created  


Revision History:


--*/

{
    if (pRTLScans->CompressMode == COMPRESS_MODE_ADAPT) {

        FlushAdaptBuf(pPDev, pRTLScans, TRUE);
    }

    if (pRTLScans->pbCompress) {

        LocalFree(pRTLScans->pbCompress);
    }

    ZeroMemory(pRTLScans, sizeof(RTLSCANS));
}



VOID
EnterRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    DWORD       cx,
    DWORD       cy,
    BOOL        MonoBmp
    )

/*++

Routine Description:


    This function initializes the RTLSCANS structure and determines which
    compression of the available compressions is best.

Arguments:

    pPDev       - Pointer to our PDEV

    pRTLScans   - Pointer to the RTLSCANS data structure to be initialized

    cx          - Width of pixel per scans

    cy          - Height of pixel data

    MonoBmp     - True if a monochrome bitmap.

Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    22-Feb-1994 Tue 12:14:17 created  

    11-Mar-1994 Fri 19:23:34 updated  
        Only flush the output buffer if we are really in ADAPTIVE mode


Revision History:


--*/

{
    RTLSCANS    RTLScans;
    DWORD       AllocSize;
    DWORD       MinBlkSize;


    RTLScans.Flags           = (RTLScans.cScans = cy) ? RTLSF_MORE_SCAN : 0;
    RTLScans.pbCompress      =
    RTLScans.pbSeedRows[0]   =
    RTLScans.pbSeedRows[1]   =
    RTLScans.pbSeedRows[2]   = NULL;
    RTLScans.cEmptyDup       = 0;
    RTLScans.AdaptMethod     = 0xFF;
    RTLScans.cAdaptBlk       = 0;
    RTLScans.cxBytes         = (DWORD)((cx + 7) >> 3);
    RTLScans.CompressMode    = COMPRESS_MODE_ROW;
    RTLScans.MaxAdaptBufSize = MAX_ADAPT_SIZE;

    if (!(RTLScans.Mask = (BYTE)(~(0xFF >> (cx & 0x07))))) {

        //
        // Exact at byte boundary
        //

        RTLScans.Mask = 0xFF;
    }

    MinBlkSize = 8;

    if (MonoBmp) {

        RTLScans.Planes = 1;
        AllocSize       = (DWORD)(RTLScans.cxBytes << 1);

        if (RTLMONOENCODE_5(pPDev)) {

            PLOTDBG(DBG_ENTERRTLSCANS, ("EnterRTLScans: Using Adaptive Mode Compression"));

            RTLScans.CompressMode = COMPRESS_MODE_ADAPT;
            MinBlkSize            = 4;
        }

    } else {

        RTLScans.Planes = 3;
        AllocSize       = (DWORD)(RTLScans.cxBytes << 2);
    }

    if ((RTLScans.cxBytes <= MinBlkSize)   ||
        (!(RTLScans.pbCompress = (LPBYTE)LocalAlloc(LPTR, AllocSize)))) {

        BYTE    Buf[4];

        RTLScans.CompressMode = COMPRESS_MODE_BLOCK;

        OutputFormatStr(pPDev,
                        "\033*b4m#dW",
                        4 + (RTLScans.cxBytes * RTLScans.Planes * cy));

        Buf[0] = (BYTE)((cx >> 24) & 0xFF);
        Buf[1] = (BYTE)((cx >> 16) & 0xFF);
        Buf[2] = (BYTE)((cx >>  8) & 0xFF);
        Buf[3] = (BYTE)((cx      ) & 0xFF);

        OutputBytes(pPDev, Buf, 4);

    } else if (RTLScans.CompressMode == COMPRESS_MODE_ADAPT) {

        //
        // We first need to flush the current output buffer in order to make
        // room for the Adaptive method
        //

        FlushOutBuffer(pPDev);
    }

    if (RTLScans.pbCompress) {

        RTLScans.pbSeedRows[0] = RTLScans.pbCompress + RTLScans.cxBytes;

        if (!MonoBmp) {

            RTLScans.pbSeedRows[1] = RTLScans.pbSeedRows[0] + RTLScans.cxBytes;
            RTLScans.pbSeedRows[2] = RTLScans.pbSeedRows[1] + RTLScans.cxBytes;
        }
    }

    *pRTLScans = RTLScans;
}



LONG
CompressToDelta(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size
    )

/*++

Routine Description:

    This function compresses the input scan data with delta encoding, by
    determining the differences from the current seed row.

Arguments:

    pbSrc       - Pointer to the source to be compressed

    pbSeedRow   - Pointer to the previous seed row

    pbDst       - Pointer to the compress buffer

    Size        - Size of the pointers


Return Value:

    LONG    - the compress buffer size

    >0      - Size of the buffer
    =0      - The data is same as previouse line
    <0      - Size is larger than the Size passed

Author:

    22-Feb-1994 Tue 14:41:18 created  


Revision History:


--*/

{
    LPBYTE  pbDstBeg;
    LPBYTE  pbDstEnd;
    LPBYTE  pbTmp;
    LONG    cSrcBytes;
    LONG    Offset;
    UINT    cReplace;
    BOOL    DoReplace;


#if DBG
    if (DBG_PLOTFILENAME & DBG_NO_DELTA) {

        return(-Size);
    }
#endif

    cSrcBytes = Size;
    pbDstBeg  = pbDst;
    pbDstEnd  = pbDst + Size;
    cReplace  = 0;
    pbTmp     = pbSrc;


    while (cSrcBytes--) {

        //
        // We need to do byte replacement now
        //

        if (*pbSrc != *pbSeedRow) {

            if (++cReplace == 1) {

                //
                // The pbTmp is the next byte to the last replacement byte.
                // After we find the first difference, between the seed row
                // and the current row pbTmp becomes the first byte of the
                // source data that is different than the seed.
                //

                Offset = (LONG)(pbSrc - pbTmp);
                pbTmp  = pbSrc;
            }

            DoReplace = (BOOL)((cReplace >= DELTA_MAX_ONE_REPLACE) ||
                               (!cSrcBytes));

        } else {

            DoReplace = (BOOL)cReplace;
        }

        if (DoReplace) {

            //
            // At the very least we need one command byte and a replace count
            // byte.
            //


            if ((LONG)(pbDstEnd - pbDst) <= (LONG)cReplace) {

                PLOTDBG(DBG_DELTA, ("CompressToDelta: 1ST_OFF: Dest Size is larger, give up"));

                return(-Size);
            }

            PLOTDBG(DBG_DELTA, ("CompressToDelta: Replace=%ld, Offset=%ld",
                        (DWORD)cReplace, (DWORD)Offset));


            //
            // Set commmand byte to replacement count
            //

            *pbDst = (BYTE)((cReplace - 1) << 5);

            //
            // Add in the offset to the same destination byte
            //

            if (Offset < DELTA_MAX_1ST_OFFSET) {

                *pbDst++ |= (BYTE)Offset;

            } else {

                //
                // We need to send more than one offset, NOTE: We must
                // send an extra 0 if the offset is equal to 31 or 255
                //

                *pbDst++ |= (BYTE)DELTA_MAX_1ST_OFFSET;
                Offset   -= DELTA_MAX_1ST_OFFSET;

                do {

                    if (!Offset) {

                        PLOTDBG(DBG_DELTA_OFFSET0,
                                ("CompressToDelta: Extra 0 offset SENT"));
                    }

                    if (pbDst >= pbDstEnd) {

                        PLOTDBG(DBG_DELTA, ("CompressToDelta: Dest Size is larger, give up"));

                        return(-Size);
                    }

                    *pbDst++ = (BYTE)((Offset >= 255) ? 255 : Offset);

                } while ((Offset -= 255) >= 0);
            }

            //
            // Now copy down the replacement bytes, if we mess up then this
            // pb1stDiff will be NULL
            //

            CopyMemory(pbDst, pbTmp, cReplace);

            pbDst    += cReplace;
            pbTmp    += cReplace;
            cReplace  = 0;
        }

        //
        // Advanced source/seed row pointers
        //

        ++pbSrc;
        ++pbSeedRow;
    }

    PLOTDBG(DBG_DELTA, ("CompressToDelta: Compress from %ld to %ld, save=%ld",
                        Size, (DWORD)(pbDst - pbDstBeg),
                        Size - (DWORD)(pbDst - pbDstBeg)));


    return((LONG)(pbDst - pbDstBeg));
}





LONG
CompressToTIFF(
    LPBYTE  pbSrc,
    LPBYTE  pbDst,
    LONG    Size
    )

/*++

Routine Description:


    This function takes the source data and compresses it into the TIFF
    packbits format into the destination buffer pbDst.

    The TIFF packbits compression format consists of a CONTROL byte followed
    by the BYTE data. The CONTROL byte has the following range.

    -1 to -127  = The data byte followed by the control byte is repeated
                  ( -(Control Byte) + 1 ) times.

    0 to 127    = There are 1 to 128 literal bytes following the CONTROL byte.
                  The count is = (Control Byte + 1)

    -128        = NOP

Arguments:

    pbSrc   - The source data to be compressed

    pbDst   - The compressed TIFF packbits format data

    Size    - Count of the data in the source and destination

Return Value:

    >0  - Compress sucessful and return value is the total bytes in pbDst
    =0  - All bytes are zero nothing to be compressed.
    <0  - Compress data is larger than the source, compression failed and
          pbDst has no valid data.

Author:

    18-Feb-1994 Fri 09:54:47 created  

    24-Feb-1994 Thu 10:43:01 updated  
        Changed the logic so when multiple MAX repeats count is sent and last
        repeat chunck is less than TIFF_MIN_REPEATS then we will treat that as
        literal to save more space


Revision History:


--*/

{
    LPBYTE  pbSrcBeg;
    LPBYTE  pbSrcEnd;
    LPBYTE  pbDstBeg;
    LPBYTE  pbDstEnd;
    LPBYTE  pbLastRepeat;
    LPBYTE  pbTmp;
    LONG    RepeatCount;
    LONG    LiteralCount;
    LONG    CurSize;
    BYTE    LastSrc;

#if DBG
    if (DBG_PLOTFILENAME & DBG_NO_TIFF) {

        return(-Size);
    }
#endif


    pbSrcBeg     = pbSrc;
    pbSrcEnd     = pbSrc + Size;
    pbDstBeg     = pbDst;
    pbDstEnd     = pbDst + Size;
    pbLastRepeat = pbSrc;

    while (pbSrcBeg < pbSrcEnd) {

        pbTmp   = pbSrcBeg;
        LastSrc = *pbTmp++;

        while ((pbTmp < pbSrcEnd) &&
               (*pbTmp == LastSrc)) {

            ++pbTmp;
        }

        if (((RepeatCount = (LONG)(pbTmp - pbSrcBeg)) >= TIFF_MIN_REPEATS) ||
            (pbTmp >= pbSrcEnd)) {

            //
            // Check to see if we are repeating ZERO's to the end of the
            // scan line, if such is the case. Simply mark the line as
            // autofill ZERO to the end, and exit.
            //

            LiteralCount = (LONG)(pbSrcBeg - pbLastRepeat);

            if ((pbTmp >= pbSrcEnd) &&
                (RepeatCount)       &&
                (LastSrc == 0)) {

                if (RepeatCount == Size) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: All data = 0, size=%ld", Size));

                    return(0);
                }

                PLOTDBG(DBG_TIFF,
                        ("CompressToTIFF: Last Chunck of Repeats (%ld) is Zeros, Skip it",
                        RepeatCount));

                RepeatCount = 0;

            } else if (RepeatCount < TIFF_MIN_REPEATS) {

                //
                // If we have repeating data, but not enough to make it
                // worthwhile to encode, then treat the data as literal and
                // don't compress.

                LiteralCount += RepeatCount;
                RepeatCount   = 0;
            }

            PLOTDBG(DBG_TIFF, ("CompressToTIFF: Literal=%ld, Repeats=%ld",
                                                    LiteralCount, RepeatCount));

            //
            // Setting literal count
            //

            while (LiteralCount) {

                if ((CurSize = LiteralCount) > TIFF_MAX_LITERAL) {

                    CurSize = TIFF_MAX_LITERAL;
                }

                if ((pbDstEnd - pbDst) <= CurSize) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: [LITERAL] Dest Size is larger, give up"));
                    return(-Size);
                }

                //
                // Set literal control bytes from 0-127
                //

                *pbDst++ = (BYTE)(CurSize - 1);

                CopyMemory(pbDst, pbLastRepeat, CurSize);

                pbDst        += CurSize;
                pbLastRepeat += CurSize;
                LiteralCount -= CurSize;
            }

            //
            // Setting repeat count if any
            //

            while (RepeatCount) {

                if ((CurSize = RepeatCount) > TIFF_MAX_REPEATS) {

                    CurSize = TIFF_MAX_REPEATS;
                }

                if ((pbDstEnd - pbDst) < 2) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: [REPEATS] Dest Size is larger, give up"));
                    return(-Size);
                }

                //
                // Set Repeat Control bytes from -1 to -127
                //

                *pbDst++ = (BYTE)(1 - CurSize);
                *pbDst++ = (BYTE)LastSrc;

                //
                // If we have more than TIFF_MAX_REPEATS then we want to make
                // sure we used the most efficient method to send.  If we have
                // remaining repeated bytes less than TIFF_MIN_REPEATS then
                // we want to skip those bytes and use literal for the next run
                // since that is more efficient.
                //

                if ((RepeatCount -= CurSize) < TIFF_MIN_REPEATS) {

                    PLOTDBG(DBG_TIFF,
                            ("CompressToTIFF: Replaced Last REPEATS (%ld) for LITERAL",
                                                RepeatCount));

                    pbTmp       -= RepeatCount;
                    RepeatCount  = 0;
                }
            }

            pbLastRepeat = pbTmp;
        }

        pbSrcBeg = pbTmp;
    }

    PLOTDBG(DBG_TIFF, ("CompressToTIFF: Compress from %ld to %ld, save=%ld",
                        Size, (DWORD)(pbDst - pbDstBeg),
                        Size - (DWORD)(pbDst - pbDstBeg)));

    return((LONG)(pbDst - pbDstBeg));
}




LONG
RTLCompression(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size,
    LPBYTE  pCompressMode
    )

/*++

Routine Description:

    This function determines which RTL compression method results in the
    least number of bytes to send to the target device and uses that method.

Arguments:

    pbSrc           - pointer to the source scan

    pbSeedRow       - Pointer to the seed row for the current source scan

    pbDst           - Pointer to the compressed result will be stored

    Size            - size in bytes for pbSrc/pbSeedRow/pbDst

    pCompressMode   - Pointer to current compression mode, it will ALWAYS be
                      updated to a new compression mode upon return


Return Value:

    >0  - Use *pCompressMode returned and output that many bytes
    =0  - Use *pCompressMode returned and output ZERO byte
    <0  - Use *pCompressMode returned and output original source and size

Author:

    25-Feb-1994 Fri 12:49:29 created  


Revision History:


--*/

{
    LONG    cDelta;
    LONG    cTiff;
    LONG    RetSize;
    BYTE    CompressMode;


    if ((cDelta = CompressToDelta(pbSrc, pbSeedRow, pbDst, Size)) == 0) {

        //
        // Exact duplicate of the previous row, and seed row remained the same
        //

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Duplicate the ROW"));

        *pCompressMode = (BYTE)COMPRESS_MODE_DELTA;
        return(0);
    }

    if ((cTiff = CompressToTIFF(pbSrc, pbDst, Size)) == 0) {

        //
        // Since a '*0W' for the delta means repeat last row so we must change
        // to other mode, but we just want reset seed rows to all zeros
        //

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Row is all ZEROs"));

        if (*pCompressMode == (BYTE)COMPRESS_MODE_DELTA) {

            *pCompressMode = (BYTE)COMPRESS_MODE_ROW;
        }

        ZeroMemory(pbSeedRow, Size);
        return(0);
    }

    if (cTiff < 0) {

        if (cDelta < 0) {

            PLOTDBG(DBG_COMPRESS, ("RTLCompression: Using COMPRESS_MODE_ROW"));

            CompressMode = (BYTE)COMPRESS_MODE_ROW;
            RetSize      = -Size;

        } else {

            CompressMode = (BYTE)COMPRESS_MODE_DELTA;
        }

    } else {

        //
        // If we are here, cTiff is greater than zero
        //

        CompressMode = (BYTE)(((cDelta < 0) || (cTiff <= cDelta)) ?
                                    COMPRESS_MODE_TIFF : COMPRESS_MODE_DELTA);
    }

    if ((*pCompressMode = CompressMode) == COMPRESS_MODE_DELTA) {

        //
        // We must redo the DELTA again, since pbDst was destroyed by the
        // TIFF compression
        //

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Using COMPRESS_MODE_DELTA"));

        RetSize = CompressToDelta(pbSrc, pbSeedRow, pbDst, Size);

    } else if (CompressMode == COMPRESS_MODE_TIFF) {

        PLOTDBG(DBG_COMPRESS, ("RTLCompression: Using COMPRESS_MODE_TIFF"));

        RetSize = cTiff;
    }

    //
    // We need to have current source (Original SIZE) as the new seed row
    //

    CopyMemory(pbSeedRow, pbSrc, Size);

    return(RetSize);
}




BOOL
AdaptCompression(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    LPBYTE      pbSrc,
    LPBYTE      pbSeedRow,
    LPBYTE      pbDst,
    LONG        Size
    )

/*++

Routine Description:

    This function implements adaptive compression, which allows the mixing
    of different compression types in a higher level compression mode that
    is defined ahead of time.

Arguments:

    pPDev           - Pointer to our PDEV

    pRTLScans       - Pointer to the RTLSCANS data structure

    pbSrc           - pointer to the source scan

    pbSeedRow       - Pointer to the seed row for the current source scan

    pbDst           - Pointer to the compressed result will be stored

    Size            - size in bytes for pbSrc/pbSeedRow/pbDst


Return Value:

    >0  - Use *pCompressMode returned and output that many bytes
    =0  - Use *pCompressMode returned and output ZERO byte
    <0  - Use *pCompressMode returned and output original source and size

Author:

    25-Feb-1994 Fri 12:49:29 created  


Revision History:


--*/

{
    LPBYTE  pbOrgDst;
    LONG    Count;
    BOOL    Ok;
    BYTE    AdaptMethod;


    pbOrgDst    = pbDst;
    AdaptMethod = COMPRESS_MODE_ROW;

    if (Count = RTLCompression(pbSrc, pbSeedRow, pbDst, Size, &AdaptMethod)) {

        if (Count < 0) {

            pbDst = pbSrc;
            Count = -Count;
        }

    } else {

        AdaptMethod = (AdaptMethod == COMPRESS_MODE_DELTA) ? ADAPT_METHOD_DUP :
                                                             ADAPT_METHOD_ZERO;
    }

    if ((Ok = (BOOL)(pRTLScans->cEmptyDup == 0xFFFF))   ||
        ((pPDev->cbBufferBytes + Count) > MAX_ADAPT_SIZE)) {

        if (!(Ok = FlushAdaptBuf(pPDev, pRTLScans, Ok))) {

            return(FALSE);
        }

        //
        // Because the Seed ROW was reset to zero, we must recalculate it.
        //

        if (Count = RTLCompression(pbSrc,
                                   pbSeedRow,
                                   pbOrgDst,
                                   Size,
                                   &AdaptMethod)) {

            if (Count < 0) {

                pbDst = pbSrc;
                Count = -Count;
            }

        } else {

            AdaptMethod = (AdaptMethod == COMPRESS_MODE_DELTA) ?
                                        ADAPT_METHOD_DUP : ADAPT_METHOD_ZERO;
        }

    } else {

        Ok = TRUE;
    }


    //
    // If we are switching compression modes, do it now.
    //

    if (AdaptMethod != pRTLScans->AdaptMethod) {

        if (pRTLScans->cEmptyDup) {

            SET_ADAPT_CONTROL(pPDev,
                              pRTLScans->AdaptMethod,
                              pRTLScans->cEmptyDup);

            pRTLScans->cEmptyDup = 0;
        }

        pRTLScans->AdaptMethod = AdaptMethod;
    }

    if (Count) {

        SET_ADAPT_CONTROL(pPDev, pRTLScans->AdaptMethod, Count);
        OutputBytes(pPDev, pbDst, Count);

    } else {

        ++(pRTLScans->cEmptyDup);
    }

    return(Ok);
}




BOOL
OutputRTLScans(
    PPDEV       pPDev,
    LPBYTE      pbPlane1,
    LPBYTE      pbPlane2,
    LPBYTE      pbPlane3,
    PRTLSCANS   pRTLScans
    )

/*++

Routine Description:

    This function will output one scan line of RTL data and compress it if
    it can.

Arguments:

    pPDev           - Pointer to our PDEV

    pbPlane1        - First plane of scan data

    pbPlane2        - 2nd plane of scan data

    pbPlane3        - 3rd plane of scan data

    pRTLScans       - Pointer to the RTLSCANS data structure

Return Value:

    BOOLEAN


Author:

    18-Feb-1994 Fri 15:52:42 created  

    21-Feb-1994 Mon 13:20:00 updated  
        Make if output faster in scan line output

    16-Mar-1994 Wed 15:38:23 updated  
        Update so the source mask so it is restored after mask

Revision History:


--*/

{
    LPBYTE      pbCurScan;
    LPBYTE      pbCompress;
    LPBYTE      pbScans[3];
    RTLSCANS    RTLScans;
    LONG        Count;
    UINT        i;
    BYTE        EndGrafCH;
    static BYTE BegGrafCmd[] = { 0x1B, '*', 'b' };


    if (PLOT_CANCEL_JOB(pPDev)) {

        PLOTWARN(("OutputRTLScans: JOB CANCELD. exit NOW"));

        pRTLScans->Flags &= ~RTLSF_MORE_SCAN;
        return(TRUE);
    }


    //
    // If we are at the last scan line, turn the flag off so we are forced to
    // exit.
    //

    if (!(--pRTLScans->cScans)) {

        pRTLScans->Flags &= ~RTLSF_MORE_SCAN;
    }

    RTLScans             = *pRTLScans;
    Count                = (LONG)(RTLScans.cxBytes - 1);
    *(pbPlane1 + Count) &= RTLScans.Mask;

    if ((i = (UINT)RTLScans.Planes) > 1) {

        *(pbPlane2 + Count) &= RTLScans.Mask;
        *(pbPlane3 + Count) &= RTLScans.Mask;
        pbScans[2]           = pbPlane1;
        pbScans[1]           = pbPlane2;
        pbScans[0]           = pbPlane3;

    } else {

        pbScans[0] = pbPlane1;
    }

    while (i--) {

        EndGrafCH = (i) ? 'V' : 'W';
        pbCurScan = pbScans[i];

        if (RTLScans.CompressMode == COMPRESS_MODE_BLOCK) {

            OutputBytes(pPDev, pbCurScan, RTLScans.cxBytes);

        } else if (RTLScans.CompressMode == COMPRESS_MODE_ADAPT) {

            AdaptCompression(pPDev,
                             pRTLScans,
                             pbCurScan,
                             RTLScans.pbSeedRows[i],
                             RTLScans.pbCompress,
                             RTLScans.cxBytes);

        } else {

            if ((Count = RTLCompression(pbCurScan,
                                        RTLScans.pbSeedRows[i],
                                        pbCompress = RTLScans.pbCompress,
                                        RTLScans.cxBytes,
                                        &(pRTLScans->CompressMode))) < 0) {

                pbCompress = pbCurScan;
                Count      = RTLScans.cxBytes;
            }

            //
            // Now output graphic header
            //

            OutputBytes(pPDev, BegGrafCmd, sizeof(BegGrafCmd));


            //
            // If we changed compression modes then send the command out
            // and record the change.
            //

            if (pRTLScans->CompressMode != RTLScans.CompressMode) {

                PLOTDBG(DBG_OUTRTLSCAN, ("OutputRTLScan: Switch CompressMode from %ld to %ld",
                                (DWORD)RTLScans.CompressMode,
                                (DWORD)pRTLScans->CompressMode));

                RTLScans.CompressMode = pRTLScans->CompressMode;

                OutputFormatStr(pPDev, "#dm", (LONG)RTLScans.CompressMode);
            }

            OutputLONGParams(pPDev, &Count, 1, 'd');
            OutputBytes(pPDev, &EndGrafCH, 1);

            if (Count) {

                OutputBytes(pPDev, pbCompress, Count);
            }
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\compress.h ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    compress.h


Abstract:

    This module contains #defines and prototypes for the compress.c module.


Author:

    18-Feb-1994 Fri 09:50:29 created  


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#ifndef _COMPRESS_
#define _COMPRESS_

#define COMPRESS_MODE_NONE      (DWORD)0xFFFFFFFF
#define COMPRESS_MODE_ROW       0
#define COMPRESS_MODE_RUNLENGTH 1
#define COMPRESS_MODE_TIFF      2
#define COMPRESS_MODE_DELTA     3
#define COMPRESS_MODE_BLOCK     4
#define COMPRESS_MODE_ADAPT     5


#define RTLSF_MORE_SCAN         0x01


typedef struct _RTLSCANS {
    LPBYTE  pbCompress;
    LPBYTE  pbSeedRows[3];
    DWORD   MaxAdaptBufSize;
    WORD    cEmptyDup;
    BYTE    AdaptMethod;
    BYTE    cAdaptBlk;
    DWORD   cxBytes;
    DWORD   cScans;
    BYTE    Flags;
    BYTE    Planes;
    BYTE    Mask;
    BYTE    CompressMode;
    } RTLSCANS, FAR *PRTLSCANS;


//
// The function protypes
//

VOID
ExitRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans
    );

VOID
EnterRTLScans(
    PPDEV       pPDev,
    PRTLSCANS   pRTLScans,
    DWORD       cx,
    DWORD       cy,
    BOOL        MonoBmp
    );

LONG
CompressToDelta(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size
    );

LONG
CompressToTIFF(
    LPBYTE  pbSrc,
    LPBYTE  pbDst,
    LONG    Size
    );

LONG
RTLCompression(
    LPBYTE  pbSrc,
    LPBYTE  pbSeedRow,
    LPBYTE  pbDst,
    LONG    Size,
    LPBYTE  pCompressMode
    );

BOOL
OutputRTLScans(
    PPDEV       pPDev,
    LPBYTE      pbPlane1,
    LPBYTE      pbPlane2,
    LPBYTE      pbPlane3,
    PRTLSCANS   pRTLScans
    );


#endif  // _COMPRESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\msplot\plotter\brush.c ===
/*++

Copyright (c) 1990-2003  Microsoft Corporation


Module Name:

    brush.c


Abstract:

    This module implements the code to realize brushes. BRUSHOBJS, are
    representations of logical objects. These objects are created in the
    win32 world and eventually need to be converted (or realized) to
    something that makes sense in the target device. This is done by realizing
    a brush. We look at the logical representation of the brush, then based
    on physical device characteristics, do the best job we can of simulating
    it on the target device. This conversion is done once, and the result
    is stored in the structure that represents the REALIZED brush. This
    is optimal since brushes tend to get re-used, and REALIZING them
    once, keeps us from having to execute the code every time a brush is used.


Author:

    19:15 on Mon 15 Apr 1991    
        Created it

    15-Nov-1993 Mon 19:29:07 updated  
        clean up / fixed

    27-Jan-1994 Thu 23:39:34 updated  
        Add fill type cache. which we do not have to send FT if same one
        already on the plotter


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define DBG_PLOTFILENAME    DbgBrush

#define DBG_RBRUSH          0x00000001
#define DBG_HATCHTYPE       0x00000002
#define DBG_SHOWSTDPAT      0x00000004
#define DBG_COPYUSERPATBGR  0x00000008
#define DBG_MINHTSIZE       0x00000010
#define DBG_FINDDBCACHE     0x00000020


DEFINE_DBGVAR(0);

//
// The pHSFillType's #d is the line spacing param
//
// for hatch brushes, we want the lines to be .01" thick and .0666666666667"
// this is 15 LPI according to DC. That is, .254mm thick and 2.54mm apart.
// for now, assume the pen is the correct thickness (.3 is right) to figure
// out the separation, in device coordinates, we do 2.54 mm * (device units /
// mm), or  (254 * resolution / 100) where resolution is in device units /
// milimeter.
//

#define PATLINESPACE(pPDev) FXTODEVL(pPDev,LTOFX(pPDev->lCurResolution+7)/15)

static const BYTE   CellSizePrims[10][4] = {

                                { 2, 0, 0, 0 },     //  2x 2
                                { 2, 2, 0, 0 },     //  4x 4
                                { 2, 3, 0, 0 },     //  6x 6
                                { 2, 2, 2, 0 },     //  8x 8
                                { 2, 5, 0, 0 },     // 10x10
                                { 2, 2, 3, 0 },     // 12x12
                                { 2, 7, 0, 0 },     // 14x14
                                { 2, 2, 2, 2 },     // 16x16
                                { 91,0, 0, 0 },     // 91x91
                                { 91,0, 0, 0 }      // 91x91
                              };



VOID
ResetDBCache(
    PPDEV   pPDev
    )

/*++

Routine Description:

    This function clears the Device brush cach mechanism.


Arguments:

    pPDev   - Pointer to our PDEV


Return Value:

    VOID


Author:

    27-Jan-1994 Thu 20:30:35 created  


Revision History:


--*/

{
    PDBCACHE    pDBCache;
    UINT        i;


    pDBCache = (PDBCACHE)&pPDev->DBCache[0];


    for (i = RF_MAX_IDX; i; i--, pDBCache++) {

        pDBCache->RFIndex = (WORD)i;
        pDBCache->DBUniq  = 0;
    }
}




LONG
FindDBCache(
    PPDEV   pPDev,
    WORD    DBUniq
    )

/*++

Routine Description:

    This function finds the RF Index number, if not there then it will add it
    to the cache.


Arguments:

    pPDev   - Pointer to our PDEV

    DBUniq  - Uniq number to be search for


Return Value:

    LONG value >0 found and RetVal is the RFIndex
               <0 NOT Found and -RetVal is the new RFIndex


Author:

    27-Jan-1994 Thu 20:32:12 created  


Revision History:


--*/

{
    PDBCACHE    pDBCache;
    DBCACHE     DBCache;
    LONG        RetVal;
    UINT        i;


    PLOTASSERT(1, "FindDevBrushCache: DBUniq is 0", DBUniq, 0);

    pDBCache = (PDBCACHE)&pPDev->DBCache[0];

    for (i = 0; i < RF_MAX_IDX; i++, pDBCache++) {

        if (pDBCache->DBUniq == DBUniq) {

            break;
        }
    }

    if (i < RF_MAX_IDX) {

        DBCache = *pDBCache;
        RetVal  = (LONG)DBCache.RFIndex;

        PLOTDBG(DBG_FINDDBCACHE, ("FindDBCache: Found Uniq=%lu, RFIdx=%ld",
                                (DWORD)DBCache.DBUniq, (DWORD)DBCache.RFIndex));

    } else {

        //
        // Since we did not find the pattern in the cache, we will add it
        // to the beggining and move the rest of the entries down the list.
        // We need to remember the last one.
        //

        pDBCache       = (PDBCACHE)&pPDev->DBCache[i = (RF_MAX_IDX - 1)];
        DBCache        = *pDBCache;
        DBCache.DBUniq = DBUniq;
        RetVal         = -(LONG)DBCache.RFIndex;

        PLOTDBG(DBG_FINDDBCACHE, ("FindDBCache: NOT Found, NEW DBCache: Uniq=%lu, RFIdx=%ld",
                                (DWORD)DBCache.DBUniq, (DWORD)DBCache.RFIndex));
    }

    PLOTASSERT(1, "FindDBCache: Invalid RFIndex=%ld in the cache",
                (DBCache.RFIndex > 0) && (DBCache.RFIndex <= RF_MAX_IDX),
                (DWORD)DBCache.RFIndex);

    //
    // Move everything down by one slot, so the first one is the most
    // recently used.
    //

    while (i--) {

        *pDBCache = *(pDBCache - 1);
        --pDBCache;
    }

    //
    // Save the current cach back and return the RF index.
    //

    *pDBCache = DBCache;

    return(RetVal);
}





BOOL
CopyUserPatBGR(
    PPDEV       pPDev,
    SURFOBJ     *psoPat,
    XLATEOBJ    *pxlo,
    LPBYTE      pBGRBmp
    )

/*++

Routine Description:

    This function take a pattern surface and converts it to a form suitable,
    for downloading to the target device. The target device in this case,
    expects a pattern made up of different pens that define the color of each
    individual pixel. This conversion is done by first creating a
    BitmapSurface (24 bpp) of the passed in size, then EngBitBliting, the
    passed surface (that defines the pattern) into that 24 bpp surface, and
    finally copying the color data into the passed buffer.


Arguments:

    pPDev   - Pointer to our PDEV

    psoSrc  - source surface object

    pxlo    - translate object

    pBGRBmp - Pointer a 8x8 palette location for the bitmap


Return Value:

    TRUE if sucessful, FALSE if failed

Author:

    18-Jan-1994 Tue 03:20:10 created  


Revision History:


--*/

{
    SURFOBJ *pso24;
    HBITMAP hBmp24;


    if (pso24 = CreateBitmapSURFOBJ(pPDev,
                                    &hBmp24,
                                    psoPat->sizlBitmap.cx,
                                    psoPat->sizlBitmap.cy,
                                    BMF_24BPP,
                                    NULL)) {
        LPBYTE  pbSrc;
        RECTL   rclDst;
        DWORD   SizeBGRPerScan;
        BOOL    Ok;


        rclDst.left   =
        rclDst.top    = 0;
        rclDst.right  = pso24->sizlBitmap.cx;
        rclDst.bottom = pso24->sizlBitmap.cy;

        if (!(Ok = EngBitBlt(pso24,             // psoDst
                             psoPat,            // psoSrc
                             NULL,              // psoMask
                             NULL,              // pco
                             pxlo,              // pxlo
                             &rclDst,           // prclDst
                             (PPOINTL)&rclDst,  // pptlSrc
                             NULL,              // pptlMask
                             NULL,              // pbo
                             NULL,              // pptlBrushOrg
                             0xCCCC))) {

            PLOTERR(("CopyUserPatBGR: EngBitBlt() FALIED"));
            return(FALSE);
        }

        SizeBGRPerScan = (DWORD)(pso24->sizlBitmap.cx * 3);
        pbSrc          = (LPBYTE)pso24->pvScan0;

        PLOTDBG(DBG_COPYUSERPATBGR, ("CopyUserPatBGR: PerScan=%ld [%ld], cy=%ld",
                        SizeBGRPerScan, pso24->lDelta, rclDst.bottom));

        while (rclDst.bottom--) {

            CopyMemory(pBGRBmp, pbSrc, SizeBGRPerScan);

            pBGRBmp += SizeBGRPerScan;
            pbSrc   += pso24->lDelta;
        }

        if (pso24)  {

            EngUnlockSurface(pso24);
        }

        if (hBmp24) {

            EngDeleteSurface((HSURF)hBmp24);
        }

        return(Ok);

    } else {

        PLOTERR(("CopyUserPatBGR: CANNOT Create 24BPP for UserPat"));
        return(FALSE);
    }
}



VOID
GetMinHTSize(
    PPDEV   pPDev,
    SIZEL   *pszlPat
    )

/*++

Routine Description:

    This function computes and returns the minimum pattern size in pszlPat for
    a halftone tile-able pattern size. This is required in order to tile a
    repeating pattern correctly when filling an object. If the original
    brush wasn't useable, we create a composite of that original bitmap, by
    halftoning into a surface. In order for the result to be tile-able,
    we must take into account the different Cell/Patter sizes for our
    halftone data.

Arguments:

    pPDev   - Point to our PDEV

    pszlPat - Points to a SIZEL structure for the original pattern size


Return Value:

    VOID


Author:

    26-Jan-1994 Wed 10:10:15 created  


Revision History:


--*/

{
    LPBYTE  pCellPrims;
    LPBYTE  pPrims;
    LONG    Prim;
    SIZEL   szlPat;
    LONG    CellSize;
    UINT    i;

    if (0 == pszlPat->cx || 0 == pszlPat->cy)
    {
        return;
    }

    szlPat     = *pszlPat;
    CellSize   = (LONG)HTPATSIZE(pPDev);
    pCellPrims = (LPBYTE)&CellSizePrims[(CellSize >> 1) - 1][0];

    if (!(CellSize % szlPat.cx)) {

        szlPat.cx = CellSize;

    } else if (szlPat.cx % CellSize) {

        //
        // Since it's not an exact fit, calculate the correct number now.
        //

        i      = 4;
        pPrims = pCellPrims;

        while ((i--) && (Prim = (LONG)*pPrims++)) {

            if (!(szlPat.cx % Prim)) {

                szlPat.cx /= Prim;
            }
        }

        szlPat.cx *= CellSize;
    }

    if (!(CellSize % szlPat.cy)) {

        szlPat.cy = CellSize;

    } else if (szlPat.cy % CellSize) {

        //
        // Since it's not an exact fit, calculate the correct number now.
        //

        i      = 4;
        pPrims = pCellPrims;

        while ((i--) && (Prim = (LONG)*pPrims++)) {

            if (!(szlPat.cy % Prim)) {

                szlPat.cy /= Prim;
            }
        }

        szlPat.cy *= CellSize;
    }

    PLOTDBG(DBG_MINHTSIZE, ("GetMinHTSize: PatSize=%ld x %ld, HTSize=%ld x %ld, MinSize=%ld x %ld",
                        pszlPat->cx, pszlPat->cy, CellSize, CellSize,
                        szlPat.cx, szlPat.cy));

    *pszlPat = szlPat;
}




BOOL
DrvRealizeBrush(
    BRUSHOBJ    *pbo,
    SURFOBJ     *psoDst,
    SURFOBJ     *psoPattern,
    SURFOBJ     *psoMask,
    XLATEOBJ    *pxlo,
    ULONG       iHatch
    )

/*++

Routine Description:

    DrvRealizeBrush requests the driver to realize a specified brush for a
    specified surface. NT's GDI will usually realize a brush before using it.
    Realing a brush allows our driver to take a logical representation of
    a brush, and convert it to something that makes sense in the tar