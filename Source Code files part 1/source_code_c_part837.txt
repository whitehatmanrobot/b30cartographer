nHeaderSize != sizeof(BITMAPCOREHEADER) &&
        nHeaderSize != sizeof(BITMAPINFOHEADER) &&
        nHeaderSize != sizeof(BITMAPV4HEADER)   &&
        nHeaderSize != sizeof(BITMAPV5HEADER))
    {
        return;
    }

    // is this an old style BITMAPCOREHEADER?

    if (nHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        PBITMAPCOREHEADER pbmch = (PBITMAPCOREHEADER) pDib;

        // fix the height value if necessary

        if (pbmch->bcHeight == 0)
        {
            // start the calculation with the header size

            DWORD dwSizeImage = dwSize - nHeaderSize;

            // subtract the color table size

            if (pbmch->bcBitCount <= 8)
            {
                dwSizeImage -= sizeof(RGBTRIPLE) * (1 << pbmch->bcBitCount);
            }

            // calculate the height

            pbmch->bcHeight = (WORD) (dwSizeImage / LineWidth(pbmch->bcWidth, pbmch->bcBitCount));
        }
    }
    else
    {
        // this is at least a BITMAPINFOHEADER

        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) pDib;

        // fix the height value if necessary

        if (pbmih->biHeight == 0)
        {
            // find the size of the image data

            DWORD dwSizeImage;

            if (pbmih->biSizeImage != 0)
            {
                // if the size is specified in the header, take it

                dwSizeImage = pbmih->biSizeImage;
            }
            else
            {
                // start the calculation with the header size

                dwSizeImage = dwSize - nHeaderSize;

                // subtract the color table size

                if (pbmih->biClrUsed != 0)
                {
                    dwSizeImage -= sizeof(RGBQUAD) * pbmih->biClrUsed;
                }
                else if (pbmih->biBitCount <= 8)
                {
                    dwSizeImage -= sizeof(RGBQUAD) * (1 << pbmih->biBitCount);
                }

                // Consider special cases

                if (nHeaderSize == sizeof(BITMAPINFOHEADER))
                {     
                    // If this is a 16 or 32 bit bitmap and BI_BITFIELDS is used, 
                    // bmiColors member contains three DWORD color masks.
                    // For V4 or V5 headers, this info is included the header

                    if (pbmih->biCompression == BI_BITFIELDS)
                    {
                        dwSizeImage -= 3 * sizeof(DWORD);
                    }
                }
                else if (nHeaderSize >= sizeof(BITMAPV5HEADER))
                {
                    // If this is a V5 header and an ICM profile is specified,
                    // we need to consider the profile data size
            
                    PBITMAPV5HEADER pbV5h = (PBITMAPV5HEADER) pDib;

                    // add the profile data size

                    dwSizeImage -= pbV5h->bV5ProfileSize;
                }

                // store the image size

                pbmih->biSizeImage = dwSizeImage;
            }

            // finally, calculate the height

            pbmih->biHeight = -(LONG) (dwSizeImage / LineWidth(pbmih->biWidth, pbmih->biBitCount));
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CDataCallback::UpdateStatus(LONG lStatus, LONG lPercentComplete)
{
    if (m_pProgress)
    {
        m_pProgress->SetPercentComplete(lPercentComplete);

        CString strFormat;

        switch (lStatus)
        {
            case IT_STATUS_TRANSFER_FROM_DEVICE:
                strFormat.LoadString(IDS_STATUS_TRANSFER_FROM_DEVICE);
                break;

            case IT_STATUS_PROCESSING_DATA:
                strFormat.LoadString(IDS_STATUS_PROCESSING_DATA);
                break;

            case IT_STATUS_TRANSFER_TO_CLIENT:
                strFormat.LoadString(IDS_STATUS_TRANSFER_TO_CLIENT);
                break;
        }

        CString strStatusText;
        strStatusText.Format(strFormat, lPercentComplete);

        USES_CONVERSION;
        m_pProgress->SetMessage(T2CW(strStatusText));
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifdef DBG

void CDataCallback::QueryStartTimes(LONG lStatus, LONG  lPercentComplete)
{
    if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE &&
        (lPercentComplete == 0 || m_TimeDeviceBegin.QuadPart == 0))
    {
        QueryPerformanceCounter(&m_TimeDeviceBegin);
    }

    if (lStatus & IT_STATUS_PROCESSING_DATA &&
        (lPercentComplete == 0 || m_TimeProcessBegin.QuadPart == 0))
    {
        QueryPerformanceCounter(&m_TimeProcessBegin);
    }

    if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT &&
        (lPercentComplete == 0 || m_TimeClientBegin.QuadPart == 0))
    {
        QueryPerformanceCounter(&m_TimeClientBegin);
    }
}

void CDataCallback::QueryStopTimes(LONG lStatus, LONG  lPercentComplete)
{
    if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE && lPercentComplete == 100)
    {
        QueryPerformanceCounter(&m_TimeDeviceEnd);
    }

    if (lStatus & IT_STATUS_PROCESSING_DATA && lPercentComplete == 100)
    {
        QueryPerformanceCounter(&m_TimeProcessEnd);
    }

    if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT && lPercentComplete == 100)
    {
        QueryPerformanceCounter(&m_TimeClientEnd);
    }
}

void CDataCallback::PrintTimes()
{
    LARGE_INTEGER Freq;
    QueryPerformanceFrequency(&Freq);

    double nTimeDevice =
        (double) (m_TimeDeviceEnd.QuadPart - m_TimeDeviceBegin.QuadPart) /
        (double) Freq.QuadPart;

    double nTimeProcess =
        (double) (m_TimeProcessEnd.QuadPart - m_TimeProcessBegin.QuadPart) /
        (double) Freq.QuadPart;

    double nTimeClient =
        (double) (m_TimeClientEnd.QuadPart - m_TimeClientBegin.QuadPart) /
        (double) Freq.QuadPart;

    Trace(
        _T("TRANSFER_FROM_DEVICE = %.02lf secs\n")
        _T("PROCESSING_DATA      = %.02lf secs\n")
        _T("TRANSFER_TO_CLIENT   = %.02lf secs\n")
        _T("\n"),
        nTimeDevice,
        nTimeProcess,
        nTimeClient
    );
}

#else //DBG

inline void CDataCallback::QueryStartTimes(LONG, LONG)
{
}

inline void CDataCallback::QueryStopTimes(LONG, LONG)
{
}

inline void CDataCallback::PrintTimes()
{
}

#endif //DBG

//////////////////////////////////////////////////////////////////////////
//
//
//

CProgressDialog::CProgressDialog()
{
    m_cRef = 0;
}

CProgressDialog::~CProgressDialog()
{
    // remove the "downloading..." message from the status bar

    if (g_pStatBarWnd)
    {
        g_pStatBarWnd->SetPaneText(0, _T(""));
    }
}

STDMETHODIMP CProgressDialog::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
        return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = (IUnknown*) this;
        return S_OK;
    }

    if (iid == IID_IWiaProgressDialog)
    {
        AddRef();
        *ppvObj = (IWiaProgressDialog *) this;
        return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProgressDialog::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CProgressDialog::Release()
{
    ASSERT( 0 != m_cRef );
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

STDMETHODIMP CProgressDialog::Create(HWND hwndParent, LONG lFlags)
{
    if (g_pStatBarWnd)
    {
        RECT r;
        g_pStatBarWnd->GetItemRect(1, &r);

        m_ProgressCtrl.Create(WS_CHILD | WS_VISIBLE, r, g_pStatBarWnd, 1);
        m_ProgressCtrl.SetRange(0, 100);
    }

    return S_OK;
}

STDMETHODIMP CProgressDialog::Show()
{
    m_ProgressCtrl.UpdateWindow();

    return S_OK;
}

STDMETHODIMP CProgressDialog::Hide()
{
    return S_OK;
}

STDMETHODIMP CProgressDialog::Cancelled(BOOL *pbCancelled)
{
    *pbCancelled = FALSE;

    return S_OK;
}

STDMETHODIMP CProgressDialog::SetTitle(LPCWSTR pszMessage)
{
    return S_OK;
}

STDMETHODIMP CProgressDialog::SetMessage(LPCWSTR pszTitle)
{
    if (g_pStatBarWnd)
    {
        USES_CONVERSION;
        g_pStatBarWnd->SetPaneText(0, W2CT(pszTitle));
    }

    return S_OK;
}

STDMETHODIMP CProgressDialog::SetPercentComplete(UINT nPercent)
{
    m_ProgressCtrl.SetPos(nPercent);

    return S_OK;
}

STDMETHODIMP CProgressDialog::Destroy()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imaging.h ===
#ifndef IMAGING_H
#define IMAGING_H

//////////////////////////////////////////////////////////////////////////
//
// CImagingMgr
//

class CImagingMgr
{
public:
    virtual ~CImagingMgr() = 0;

    virtual
    HRESULT
    SelectSource(
        HWND hWndParent,
        LONG lFlags
    ) = 0;

    virtual
    HRESULT
    Acquire(
        HWND     hWndParent,
        HGLOBAL *phDib
    ) = 0;

    virtual
    HRESULT
    Select(
        LPCTSTR pDeviceId
    ) = 0;

    virtual
    int
    NumDevices(
        HWND hWndParent
    ) = 0;

    virtual
    BOOL
    IsAvailable() = 0;
};

//////////////////////////////////////////////////////////////////////////
//
// TWAIN
//

#ifdef USE_TWAIN

#include <twain.h>

//////////////////////////////////////////////////////////////////////////
//
// CTwainMgr
//

class CTwainMgr : public CImagingMgr
{
public:
    CTwainMgr();
    ~CTwainMgr();

    HRESULT
    SelectSource(
        HWND hWndParent,
        LONG lFlags
    );

    HRESULT
    Acquire(
        HWND     hWndParent,
        HGLOBAL *phDib
    );

    HRESULT
    Select(
        LPCTSTR pDeviceId
    );

    int
    NumDevices(
        HWND hWndParent
    );

    BOOL
    IsAvailable()
    {
        return m_DSM_Entry != 0;
    }

private:
    TW_UINT16 SetCapability(TW_UINT16 Cap, TW_UINT16 ItemType, TW_UINT32 Item);
    TW_UINT16 GetCapability(TW_UINT16 Cap, pTW_UINT16 pItemType, pTW_UINT32 pItem);

private:
    enum eTwainState 
    {
        State_1_Pre_Session           = 1,
        State_2_Source_Manager_Loaded = 2,
        State_3_Source_Manager_Open   = 3,
        State_4_Source_Open           = 4,
        State_5_Source_Enabled        = 5,
        State_6_Transfer_Ready        = 6,
        State_7_Transferring          = 7
    };

private:
    eTwainState  m_TwainState;

    TW_IDENTITY  m_AppId;
    TW_IDENTITY  m_SrcId;

    HINSTANCE    m_hTwainDll;
    DSMENTRYPROC m_DSM_Entry;
};

#endif //USE_TWAIN

//////////////////////////////////////////////////////////////////////////
//
// WIA
//

#include <atlbase.h>

//////////////////////////////////////////////////////////////////////////
//
// CEventCallback
//

class CEventCallback : public IWiaEventCallback
{
public:
    CEventCallback();

    // IUnknown interface

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IWiaEventCallback interface

    STDMETHOD(ImageEventCallback)(
        LPCGUID pEventGuid,
        BSTR    bstrEventDescription,
        BSTR    bstrDeviceID,
        BSTR    bstrDeviceDescription,
        DWORD   dwDeviceType,
        BSTR    bstrFullItemName,
        ULONG  *pulEventType,
        ULONG   ulReserved
    );

    // CEventCallback methods

    HRESULT Register();

    ULONG GetNumDevices() const;

private:
    LONG               m_cRef;
    ULONG              m_nNumDevices;
    CComPtr<IUnknown>  m_pConnectEventObject;
    CComPtr<IUnknown>  m_pDisconnectEventObject;
};

//////////////////////////////////////////////////////////////////////////
//
// CDataCallback
//

class CDataCallback : public IWiaDataCallback
{
public:
    CDataCallback(IWiaProgressDialog *pProgress);
    ~CDataCallback();

    // IUnknown interface

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IWiaDataCallback interface

    STDMETHOD(BandedDataCallback) (
        LONG  lReason,
        LONG  lStatus,
        LONG  lPercentComplete,
        LONG  lOffset,
        LONG  lLength,
        LONG  lReserved,
        LONG  lResLength,
        PBYTE pbBuffer
    );

    // CDataCallback methods

    HGLOBAL GetBuffer();

    // Debugging / performance functions

    void QueryStartTimes(LONG lStatus, LONG lPercentComplete);
    void QueryStopTimes(LONG lStatus, LONG lPercentComplete);
    void PrintTimes();

private:
    HRESULT ReAllocBuffer(LONG lBufferSize);
    void    UpdateStatus(LONG lStatus, LONG lPercentComplete);

private:
    LONG                m_cRef;
    HGLOBAL             m_hBuffer;
    LONG                m_lBufferSize;
    LONG                m_lDataSize;
    IWiaProgressDialog *m_pProgress;

#ifdef DBG
    HANDLE              m_hDumpFile;
    LARGE_INTEGER       m_TimeDeviceBegin;
    LARGE_INTEGER       m_TimeDeviceEnd;
    LARGE_INTEGER       m_TimeProcessBegin;
    LARGE_INTEGER       m_TimeProcessEnd;
    LARGE_INTEGER       m_TimeClientBegin;
    LARGE_INTEGER       m_TimeClientEnd;
#endif //DBG
};

//////////////////////////////////////////////////////////////////////////
//
// CWIAMgr
//

class CWIAMgr : public CImagingMgr
{
public:
    CWIAMgr();

    HRESULT
    SelectSource(
        HWND hWndParent,
        LONG lFlags
    );

    HRESULT
    Acquire(
        HWND     hWndParent,
        HGLOBAL *phDib
    );

    HRESULT
    Select(
        LPCTSTR pDeviceId
    );

    int
    NumDevices(
        HWND hWndParent
    );

    BOOL
    IsAvailable()
    {
        return m_pEventCallback != 0;
    }

private:
    struct CGetBandedDataThreadData
    {
        CGetBandedDataThreadData(
            IWiaDataTransfer       *pIWiaDataTransfer,
            WIA_DATA_TRANSFER_INFO *pWiaDataTransferInfo,
            IWiaDataCallback       *pIWiaDataCallback
        );

        ~CGetBandedDataThreadData()
        {
        }

        HRESULT Marshal();
        HRESULT Unmarshal();

        CComPtr<IStream>          m_pIWiaDataTransferStream;
        CComPtr<IStream>          m_pIWiaDataCallbackStream;
        CComPtr<IWiaDataTransfer> m_pIWiaDataTransfer;
        PWIA_DATA_TRANSFER_INFO   m_pWiaDataTransferInfo;
        CComPtr<IWiaDataCallback> m_pIWiaDataCallback;
    };

    HRESULT GetBandedData(CGetBandedDataThreadData &ThreadData);

    static unsigned WINAPI GetBandedDataThread(PVOID pVoid);

private:
    CComPtr<CEventCallback>  m_pEventCallback;
    CComBSTR                 m_bstrDeviceID;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CProgressDialog : public IWiaProgressDialog
{
public:
    CProgressDialog();
    virtual ~CProgressDialog();

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    STDMETHOD(Create)(HWND hwndParent, LONG lFlags);
    STDMETHOD(Show)();
    STDMETHOD(Hide)();
    STDMETHOD(Cancelled)(BOOL *pbCancelled);
    STDMETHOD(SetTitle)(LPCWSTR pszMessage);
    STDMETHOD(SetMessage)(LPCWSTR pszTitle);
    STDMETHOD(SetPercentComplete)(UINT nPercent);
    STDMETHOD(Destroy)();

private:
    LONG           m_cRef;    
    CProgressCtrl  m_ProgressCtrl;
};

//////////////////////////////////////////////////////////////////////////
//
// CComPtrArray
//
// helper class for automatically releasing an array of interface pointers
//

template <class T>
class CComPtrArray
{
public:
    CComPtrArray()
    {
        m_pArray = 0;
        m_nItemCount = 0;
    }

    ~CComPtrArray()
    {
        if (m_pArray)
        {
            for (int i = 0; i < m_nItemCount; ++i)
            {
                if (m_pArray[i])
                {
                    m_pArray[i]->Release();
                }
            }

            CoTaskMemFree(m_pArray);
        }
    }

    operator T**()
    {
        return m_pArray;
    }

    bool operator!()
    {
        return m_pArray == 0;
    }

    T*** operator&()
    {
        ASSERT(m_pArray == 0);
        return &m_pArray;
    }

    LONG &ItemCount()
    {
        return m_nItemCount;
    }

private:
    T**  m_pArray;
    LONG m_nItemCount;
};

//////////////////////////////////////////////////////////////////////////
//
// 
//

ULONG FindDibSize(LPCVOID pDib);
ULONG FindDibOffBits(LPCVOID pDib);
VOID  FixDibHeader(LPVOID pDib, DWORD dwSize);

#endif //IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgcolor.h ===
#ifndef __IMGCOLOR_H__
#define __IMGCOLOR_H__

/******************************************************************************/

class CImgWnd;

#ifdef CUSTOMFLOAT
class CDocking;
#endif

/******************************************************************************/

class CImgColorsWnd : public CControlBar
    {
    public:

   
    CImgColorsWnd();

    enum HitZone
        {
        none       = -2,
        curColor   = -1,
        firstColor =  0
        };

    int         m_nDisplayColorsInitial;
    int         m_nDisplayColors;
    int         m_nOffsetY;
    int         m_nCols;
    int         m_nRows;
#ifdef CUSTOMFLOAT
    CDocking*   m_pDocking;
#endif
    CRect       m_rectColors;

    BOOL        Create( const TCHAR* pWindowName, DWORD dwStyle, CWnd* pParentWnd );

    void        InvalidateCurColors();

    WORD        GetHelpOffset();

    HitZone     HitTest(const CPoint& point);
    BOOL        GetHitRect(HitZone hitZone, CRect& rect);

    void        PaintCurColorBox(CDC* pDC, BOOL bRight);
    void        PaintCurColors(CDC* pDC, const CRect* pPaintRect);
    void        PaintColors(CDC* pDC, const CRect* pPaintRect);

    void        CancelDrag();

    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    virtual void  OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler );

#ifdef _DEBUG
    virtual void AssertValid() const
    {
	    CWnd::AssertValid();
    }
#endif //_DEBUG

    //{{AFX_MSG(CImgColorsWnd)
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnPaint();
        afx_msg void OnClose();
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

/******************************************************************************/

#ifdef CUSTOMFLOAT

class CFloatImgColorsWnd : public CMiniFrmWnd
    {
    DECLARE_DYNAMIC(CFloatImgColorsWnd)

    public:

    virtual ~CFloatImgColorsWnd(void);
    virtual BOOL Create(const TCHAR* pWindowName, DWORD dwStyle,
                        const RECT& rect, CWnd* pParentWnd);
    virtual WORD GetHelpOffset() { return ID_WND_GRAPHIC; }
    afx_msg void OnClose();

    DECLARE_MESSAGE_MAP()

    };
#endif

extern void InvalColorCache();

extern CImgColorsWnd* NEAR g_pImgColorsWnd;

/***************************************************************************/

#endif // __IMGCOLOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgcpyps.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "tedit.h"
#include "t_text.h"
#include "t_fhsel.h"
#include "toolbox.h"
#include "props.h"
#include "undo.h"
#include "srvritem.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

BOOL GetMFDimensions(
    HANDLE hMF,     /* handle to the CF_METAFILEPICT object from clipbrd */
    HDC hDC,        /* display context */
    long *pWidth,    /* width of picture in pixels, OUT param */
    long *pHeight,   /* height of picture in pixels, OUT param */
    long *pcXPelsPerMeter,    /* horizontal resolution, OUT param */
    long *pcYPelsPerMeter,    /* vertical resolution, OUT param */
    IMG* pImg)
    ;
BOOL PlayMetafileIntoDC(
    HANDLE hMF,
    RECT *pRect,
    HDC hDC)
    ;

/***************************************************************************/

void CImgWnd::OnDestroyClipboard()
    {
    if (m_hPoints)
        {
        ::GlobalFree( m_hPoints );
        m_hPoints = NULL;
        }
    }

/***************************************************************************/

void CImgWnd::CopyBMAndPal(HBITMAP *pBM, CPalette ** ppPal)
    {
    IMG* pImg = m_pImg;

    CRect copyRect;

    if (theImgBrush.m_pImg == NULL)
        {
        HideBrush();
        copyRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        copyRect = rcDragBrush;
        copyRect.right  -= 1;
        copyRect.bottom -= 1;
        }

    BOOL bRegion = (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL);

#ifdef FHSELCLIP
    if (bRegion)
        {
        if (! m_wClipboardFormat)
            m_wClipboardFormat = RegisterClipboardFormat( TEXT("MSPaintFreehand") );

        if (theImgBrush.m_bFirstDrag)
//          PickupSelection(); but no way to tell if we do it twice...
            PrepareForBrushChange( TRUE, FALSE );

        CFreehandSelectTool* pTool = (CFreehandSelectTool*)CImgTool::GetCurrent();

        ASSERT( pTool );

        if (m_wClipboardFormat && pTool)
            {
            CPoint* pptArray;
            int     iEntries;
            BOOL    bData = pTool->CopyPointsToMemArray( &pptArray, &iEntries );

            if (bData && iEntries)
                {
                HGLOBAL hMem = ::GlobalAlloc( GHND | GMEM_MOVEABLE | GMEM_DDESHARE,
                                                    iEntries * sizeof( POINT )
                                                             + sizeof( short ));
                if (hMem)
                    {
                    short* pShort = (short*)::GlobalLock( hMem );

                    *pShort++ = iEntries;

                    LPPOINT pPts = (LPPOINT)pShort;

                    for (int iPt = 0; iPt < iEntries; iPt++, pPts++)
                        {
                        pPts->x = pptArray[iPt].x - pTool->m_cRectBounding.left;
                        pPts->y = pptArray[iPt].y - pTool->m_cRectBounding.top;
                        }

                    ::GlobalUnlock( hMem );

                    if (m_hPoints)
                        {
                        ::GlobalFree( m_hPoints );
                        m_hPoints = NULL;
                        }

                    m_hPoints = SetClipboardData( m_wClipboardFormat, hMem );
                    }
                else
                    theApp.SetMemoryEmergency();

                delete [] pptArray;
                }
            }
        else
            theApp.SetGdiEmergency();
        }
#endif // FHSELCLIP

    if ( theImgBrush.m_pImg )
        {
        CPalette* ppalOld = SetImgPalette( &theImgBrush.m_dc );

        // Copy the selection...
        CRect rc( 0, 0, theImgBrush.m_size.cx, theImgBrush.m_size.cy );

        *pBM = CopyDC( &theImgBrush.m_dc, &rc );

        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, TRUE );
        }
    else
        // Copy the whole image...
        *pBM = CopyDC( CDC::FromHandle( m_pImg->hDC ), &copyRect );

    if (theApp.m_pPalette && (*ppPal=new CPalette)!=NULL)
        {
        LOGPALETTE256 logPal;

        logPal.palVersion = 0x300;
        logPal.palNumEntries = (WORD)theApp.m_pPalette->GetPaletteEntries( 0, 256,
                                                     &logPal.palPalEntry[0]);

                if ( logPal.palNumEntries )
                        {
                theApp.m_pPalette->GetPaletteEntries( 0, logPal.palNumEntries,
                                                             &logPal.palPalEntry[0] );

                (*ppPal)->CreatePalette( (LPLOGPALETTE)&logPal );
                        }
        }
    }

void CImgWnd::CmdCopy()
{
        if (TextToolProcessed( ID_EDIT_COPY ))
        {
                return;
        }

        CBitmapObj* pResObject = new CBitmapObj;
        if (pResObject)
        {
                IMG* pImgStruct = new IMG;

                if (pImgStruct)
                {
                        if (FillBitmapObj(c_pImgWndCur, pResObject, pImgStruct))
                        {
                                pImgStruct->m_pFirstImgWnd = NULL;
                                pImgStruct->m_pBitmapObj = pResObject;

                                HDC hDCSave = pImgStruct->hDC;

                                pImgStruct->hDC = NULL;
                                pImgStruct->hMaskDC = NULL;

                                pImgStruct->hMaskBitmap = NULL;
                                pImgStruct->hMaskBitmapOld = NULL;

                                pImgStruct->hBitmap = NULL;
                                pImgStruct->m_pPalette = NULL;
                                CopyBMAndPal(&pImgStruct->hBitmap, &pImgStruct->m_pPalette);

                                if (pImgStruct->hBitmap)
                                {
                                        pImgStruct->hDC = CreateCompatibleDC(hDCSave);
                                        if (pImgStruct->hDC)
                                        {
                                                pImgStruct->hBitmapOld = (HBITMAP)SelectObject(
                                                        pImgStruct->hDC, pImgStruct->hBitmap);
                                                pImgStruct->m_hPalOld = pImgStruct->m_pPalette
                                                        ? SelectPalette(pImgStruct->hDC,
                                                        (HPALETTE)pImgStruct->m_pPalette->m_hObject, FALSE)
                                                        : NULL;

                                                // get a server item suitable to generate the clipboard data
                                                CPBView* pView = (CPBView*)
                                                        ((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
                                                CPBSrvrItem* pItem = new CPBSrvrItem(pView->GetDocument(),
                                                        pResObject);

                                                if (pItem)
                                                {
                                                        pItem->CopyToClipboard(FALSE);

                                                        delete pItem;

                                                        return;
                                                }
                                        }
                                }
                        }
                        else
                        {
                                // the IMG and all it contains will get cleaned up when
                                // pResObject is deleted, but only if FillBitmapObj succeeded
                                delete pImgStruct;
                        }
                }

                delete pResObject;
        }
}

/***************************************************************************/

void CImgWnd::CmdCut()
    {
    if (TextToolProcessed( ID_EDIT_CUT ))
        return;

    // BOGUS:
    // CmdCopy doesn't just copy -- it can change the state of the selection
    // this forces the CmdClear to act in the context of the new state
    // save off a flag for CmdClear to special-case like 'first-drag'
    BOOL *pFlag;
    if (theImgBrush.m_pImg && theImgBrush.m_bFirstDrag)
        {
        pFlag = &theImgBrush.m_bCuttingFromImage;
        }
    else
        pFlag = NULL;

    CmdCopy();

    TRY
        {
        if (pFlag)
            *pFlag = TRUE;

        CmdClear();
        }
    CATCH_ALL(e)
        {
        // don't leave the flag set
        if (pFlag)
            *pFlag = FALSE;

        THROW_LAST();
        }
    END_CATCH_ALL

    // normal execution path
    if (pFlag)
        *pFlag = FALSE;
    }

/***************************************************************************/

void CImgWnd::CmdPaste()
    {
    if (TextToolProcessed( ID_EDIT_PASTE ))
        return;

    CancelToolMode(FALSE);

    CommitSelection(TRUE);

    HideBrush();
    SetupRubber( m_pImg );
    EraseTracker();
    theImgBrush.m_pImg = NULL;
    DrawTracker();
    SetUndo( m_pImg );

    if (! PasteImageClip())
        AfxMessageBox( IDS_ERROR_CLIPBOARD, MB_OK | MB_ICONHAND );
    }

/***************************************************************************/

HBITMAP CImgWnd::CopyDC( CDC* pImgDC, CRect* prcClip )
    {
    // BLOCK: copy the image to hStdBitmap for the clipboard
    CDC       dc;
    CBitmap   bm;
    CBitmap*  pOldStdBitmap;
    int       cxWidth  = prcClip->Width();
    int       cyHeight = prcClip->Height();

    if (! dc.CreateCompatibleDC    ( pImgDC                    )
    ||  ! bm.CreateCompatibleBitmap( pImgDC, cxWidth, cyHeight ))
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    pOldStdBitmap = dc.SelectObject( &bm );

    CPalette* pOldPalette = SetImgPalette( &dc );

    dc.BitBlt( 0, 0, cxWidth, cyHeight, pImgDC, prcClip->left, prcClip->top, SRCCOPY );
    dc.SelectObject( pOldStdBitmap );

    if (pOldPalette)
        dc.SelectPalette( pOldPalette, FALSE );

    // return the standard format (bitmap) data
    return (HBITMAP)bm.Detach();
    }

/***************************************************************************/

BOOL CImgWnd::IsPasteAvailable()
    {
    BOOL bPasteIsAvailable = FALSE;
    BOOL bBitmapAvailable  = IsClipboardFormatAvailable( CF_BITMAP );
    BOOL bDIBAvailable     = IsClipboardFormatAvailable( CF_DIB );
    BOOL bTextAvailable    = IsClipboardFormatAvailable( CF_TEXT );
    BOOL bMFAvailable      = IsClipboardFormatAvailable( CF_METAFILEPICT );

    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        if (pTextTool                     != NULL
        &&  pTextTool->GetTextEditField() != NULL)
            bPasteIsAvailable = bTextAvailable;
        }
    else
        {
        bPasteIsAvailable = bBitmapAvailable || bDIBAvailable || bMFAvailable;
        }

    return bPasteIsAvailable;
    }

/***************************************************************************/

BOOL CImgWnd::IsSelectionAvailable( void )
    {
    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        if (pTextTool != NULL
        &&  pTextTool->IsKindOf( RUNTIME_CLASS( CTextTool ) ))
            {
            CTedit* pTextEdit = pTextTool->GetTextEditField();

            if (pTextEdit != NULL
            &&  pTextEdit->IsKindOf( RUNTIME_CLASS( CTedit ) ))
                {
                DWORD dwSel = pTextEdit->GetEditWindow()->GetSel();
                BOOL bReturn = (HIWORD( dwSel) != LOWORD( dwSel ));

                if (! bReturn)
                    bReturn = (pTextEdit->GetEditWindow()->GetWindowTextLength()
                           != (int)LOWORD( dwSel ));

                return bReturn;
                }
            }
        }

    if (CImgTool::GetCurrentID() == IDMB_PICKTOOL
    ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        return (theImgBrush.m_pImg != NULL && ! g_bCustomBrush);
        }
    return FALSE;
    }

/***************************************************************************/

int PASCAL CheckPastedSize(int nWidth, int nHeight, IMG* pImg)
{
        int nRet = IDNO;

        // If the image is a bitmap and the bitmap in the clipboard is larger,
        // then give the suer the option2 of growing the image...
        if (nWidth  > pImg->cxWidth
                ||  nHeight > pImg->cyHeight)
        {
                CSize size( max(nWidth, pImg->cxWidth),
                        max(nHeight, pImg->cyHeight) );

                theUndo.BeginUndo( TEXT("Resize Bitmap") );
                VERIFY( pImg->m_pBitmapObj->SetSizeProp( P_Size, size ) );

                theUndo.EndUndo();

                // PSS says users don't want to see this dialog
#if 0
                // WARNING!!! MB_SYSTEMMODAL is _necessary_.  No message boxes should
                // be run while the clipboard is opened.  Loss of focus to other apps
                // can be disasterous! The clipboard will be hung or if the clipboard
                // is closed, the contents could be changed by another app.

                nRet = AfxMessageBox( IDS_ENLAGEBITMAPFORCLIP,
                        MB_YESNOCANCEL | MB_ICONQUESTION | MB_SYSTEMMODAL );
                switch (nRet)
                {
                        case IDYES:
                        {
                                CSize size( max(nWidth, pImg->cxWidth),
                                        max(nHeight, pImg->cyHeight) );

                                theUndo.BeginUndo( TEXT("Resize Bitmap") );
                                VERIFY( pImg->m_pBitmapObj->SetSizeProp( P_Size, size ) );

                                theUndo.EndUndo();
                        }
                        break;
                }
#endif
        }

        return(nRet);
}

struct CStgMedium : public STGMEDIUM
{
    CStgMedium()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CStgMedium()
    {
        ReleaseStgMedium(this);
    }
};

HGLOBAL
_GetClipboardData (CLIPFORMAT cf, TYMED tymed, STGMEDIUM *pMedium)
{
    IDataObject *pdo = NULL;
    HANDLE hRet = NULL;

    if (SUCCEEDED(OleGetClipboard (&pdo)))
    {
        FORMATETC fmt = { 0 };

        fmt.cfFormat = cf;
        fmt.lindex   = -1;
        fmt.tymed    = tymed;
        fmt.dwAspect = DVASPECT_CONTENT;

        pMedium->tymed = tymed;

        if (SUCCEEDED(pdo->GetData (&fmt, pMedium)))
        {
            hRet = pMedium->hGlobal;
        }
        else
        {
            ReleaseStgMedium(pMedium);
        }

        pdo->Release ();
    }
    else
    {
        TRACE( TEXT("Cannot open clipboard!\n") );
    }

    return hRet;
}

BOOL CImgWnd::PasteImageClip()
    {
    CWaitCursor wait;
    /////////////////////////////////////////////////////////////////////////
    // Find out what format is available on the clipboard. if it is
    //   A. CF_BITMAP only - Set the mask bits opaque and blt the bitmap
    //      into ICimageDC
    // In both cases, if the destination bitmap differs in size from
    // source bitmap, user is asked if he/she wants the src bitmap
    // stretched/clipped to new size
    /////////////////////////////////////////////////////////////////////////
    if (! m_wClipboardFormat)
        m_wClipboardFormat = (WORD)RegisterClipboardFormat( TEXT("MSPaintFreehand") );


    // Enumerate the cliboard contents to determine what is available.
    // If a CF_BITMAP is seen, set a flag and proceed. If a SDKPAINT
    // private format is seen, stop looking further
    BOOL bBitmapAvailable  = FALSE;
#ifdef FHSELCLIP
    BOOL bPrivateAvailable = FALSE;
#endif // FHSELCLIP
    BOOL bPaletteAvailable = FALSE;
    BOOL bDIBAvailable     = FALSE;
    BOOL bMFAvailable      = FALSE;
    WORD wClipFmt          = 0;

    BITMAP    bmData;
    LONG      cXPelsPerMeter = 0;
    LONG      cYPelsPerMeter = 0;
    BOOL      bResizedBitmap = FALSE;
    CPalette* ppalClipboard  = NULL;
    CBitmap*  pbmClipboard   = NULL;
    LPSTR     lpDib          = NULL;
    HPALETTE  hPal           = NULL;
    HBITMAP   hBitmap        = NULL;
    HGLOBAL   hDIB           = NULL;
    HGLOBAL   hMF            = NULL;

    CStgMedium stgMedium;

        BOOL bGotClip = FALSE;

        hPal = (HPALETTE)_GetClipboardData( CF_PALETTE, TYMED_GDI, &stgMedium );
        if (hPal)
        {
                bPaletteAvailable = TRUE;
                ppalClipboard = CPalette::FromHandle( hPal );

                ReleaseStgMedium(&stgMedium);
        }

    if (!bGotClip)
        {
        hDIB = (HGLOBAL)_GetClipboardData( CF_DIB, TYMED_HGLOBAL, &stgMedium );

        if (hDIB)
            {
            lpDib = (LPSTR)::GlobalLock( hDIB );

            if (lpDib)
                {
                bmData.bmWidth  = DIBWidth ( lpDib );
                bmData.bmHeight = DIBHeight( lpDib );

                if (bmData.bmWidth && bmData.bmHeight)
                    {
                    bDIBAvailable = TRUE;
                    bPaletteAvailable = FALSE;

                    PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER) lpDib;

                    if (pbmih->biSize >= sizeof(BITMAPINFOHEADER))
                        {
                        cXPelsPerMeter = pbmih->biXPelsPerMeter;
                        cYPelsPerMeter = pbmih->biYPelsPerMeter;
                        }
                    }
                }
            }
        #ifdef _DEBUG
        TRACE1( "Loaded the DIB %s.\n", (bDIBAvailable? TEXT("Yes"): TEXT("No")) );
        #endif

        bGotClip = bDIBAvailable;
        }

    if (!bGotClip)
        {
        hBitmap = (HBITMAP)_GetClipboardData( CF_BITMAP, TYMED_GDI, &stgMedium );

        if (hBitmap)
            {
            pbmClipboard = CBitmap::FromHandle( hBitmap );

            if (pbmClipboard->GetObject( sizeof( BITMAP ), &bmData ))
                {
                bBitmapAvailable = TRUE;

                DIBSECTION ds;

                if (pbmClipboard->GetObject( sizeof( ds ), &ds ))
                    {
                    cXPelsPerMeter = ds.dsBmih.biXPelsPerMeter;
                    cYPelsPerMeter = ds.dsBmih.biYPelsPerMeter;
                    }

                if (bPaletteAvailable)
                    {
                    if (!ppalClipboard)
                        bBitmapAvailable = FALSE;
                    }
                }
            }

        #ifdef _DEBUG
        TRACE1( "Loaded the Bitmap %s.\n", (bBitmapAvailable? TEXT("Yes"): TEXT("No")) );
        #endif

        bGotClip = bBitmapAvailable;
        }

        if (!bGotClip)
        {
                hMF = (HGLOBAL)_GetClipboardData(CF_METAFILEPICT, TYMED_MFPICT, &stgMedium);
                if (hMF)
                {
                        CDC dcMF;

                        if (dcMF.CreateCompatibleDC( NULL ))
                        {
                                if (GetMFDimensions(hMF, dcMF.m_hDC, &bmData.bmWidth,
                                        &bmData.bmHeight, &cXPelsPerMeter, &cYPelsPerMeter, m_pImg))
                                {
                                        bMFAvailable = TRUE;
                                }
                        }
                }

                bGotClip = bMFAvailable;
        }

    if (!bGotClip)
        {
        return FALSE;
        }

    switch (CheckPastedSize(bmData.bmWidth, bmData.bmHeight, m_pImg))
        {
        default:
            return TRUE;

        case IDYES:
            bResizedBitmap = TRUE;
            break;

        case IDNO:
            break;
        }

    CDC       stdDC;
    BOOL      bOkay   = FALSE;
    CBitmap*  pbmOld  = NULL;
    CPalette* ppalOld = NULL;

    if (bBitmapAvailable)
        {
        CBitmap   bmClipboard;
        CBitmap*  pbmOldCopy  = NULL;
        CPalette* ppalOldCopy = NULL;
        CDC*      pdcCopy     = NULL;

        if (! stdDC.CreateCompatibleDC( NULL ))
            {
            theApp.SetGdiEmergency();
            goto LReturn;
            }

        pbmOld = stdDC.SelectObject( pbmClipboard );

        if (! pbmOld)
            {
            theApp.SetGdiEmergency();
            goto LReturn;
            }

        if (ppalClipboard)
            {
            ppalOld = stdDC.SelectPalette( ppalClipboard, FALSE );
            stdDC.RealizePalette();
            }

        // duplicate the bitmap
        if (! bmClipboard.CreateBitmap( bmData.bmWidth, bmData.bmHeight,
                                        bmData.bmPlanes, bmData.bmBitsPixel, NULL ))
            {
            theApp.SetMemoryEmergency();
            goto LReturn;
            }

        pdcCopy = new CDC;

        if (pdcCopy == NULL)
            {
            theApp.SetMemoryEmergency();
            goto LReturn;
            }

        if (! pdcCopy->CreateCompatibleDC( NULL ))
            {
            delete pdcCopy;
            theApp.SetGdiEmergency();
            goto LReturn;
            }

        pbmOldCopy = pdcCopy->SelectObject( &bmClipboard );

        if (ppalClipboard)
            {
            ppalOldCopy = pdcCopy->SelectPalette( ppalClipboard, FALSE );
            pdcCopy->RealizePalette();
            }

        pdcCopy->BitBlt( 0, 0, bmData.bmWidth, bmData.bmHeight, &stdDC, 0, 0, SRCCOPY );

        if (ppalOldCopy)
            pdcCopy->SelectPalette( ppalOldCopy, FALSE );

        pdcCopy->SelectObject( pbmOldCopy );
        delete pdcCopy;

        stdDC.SelectObject( &bmClipboard );

        // Unload the bitmap
        stdDC.SelectObject( pbmOld );
        pbmOld = NULL;

        if (ppalOld)
            {
            stdDC.SelectPalette( ppalOld, FALSE );
            ppalOld = NULL;
            }

        // if we still do not know the image resolution, use the display resolution
        if (cXPelsPerMeter == 0 && cYPelsPerMeter == 0)
            {
            cXPelsPerMeter = MulDiv(::GetDeviceCaps(stdDC, LOGPIXELSX),10000, 254);
            cYPelsPerMeter = MulDiv(::GetDeviceCaps(stdDC, LOGPIXELSY),10000, 254);
            }

        stdDC.DeleteDC();
        // Now we convert our nice DDB to a DIB and back so we can
        // convert color bitmaps to monochrome nicely and deal with
        // palette differences...
        DWORD dwSize;

        lpDib = (LPSTR) DibFromBitmap( 
            (HBITMAP)bmClipboard.GetSafeHandle(), 
            BI_RGB, 
            0,                                     
            ppalClipboard, 
            NULL, 
            dwSize,
            cXPelsPerMeter, 
            cYPelsPerMeter );
        }

        if (bMFAvailable)
        {
                CDC dcMF;

                if (dcMF.CreateCompatibleDC(CDC::FromHandle(m_pImg->hDC)))
                {
                        CBitmap bmMF;

                        if (bmMF.CreateCompatibleBitmap(CDC::FromHandle(m_pImg->hDC),
                                bmData.bmWidth, bmData.bmHeight))
                        {
                                dcMF.SelectObject(&bmMF);
                                //not needed for DIBSection!!!
                                if (ppalClipboard)
                                {
                                        dcMF.SelectPalette(ppalClipboard, FALSE);
                                }

                                CRect rc(0, 0, bmData.bmWidth, bmData.bmHeight);

                                PlayMetafileIntoDC(hMF, &rc, dcMF.m_hDC);

                                // Select out the bitmap and palette
                                dcMF.DeleteDC();

                                DWORD dwSize;

                                lpDib = (LPSTR) DibFromBitmap(
                                    (HBITMAP)bmMF.m_hObject, BI_RGB, 0,
                                    ppalClipboard, NULL, dwSize,
                                    cXPelsPerMeter, cYPelsPerMeter );
                        }
                }
        }

    if (lpDib)
        {
        CPalette* ppalDib = CreateDIBPalette( lpDib );

        ppalDib = FixupDibPalette( lpDib, ppalDib );

        HBITMAP hbmDib = DIBToBitmap( lpDib, theApp.m_pPalette, m_pImg->hDC );

        if (bDIBAvailable)
            ::GlobalUnlock( hDIB );
        else
            FreeDib( lpDib );

        if (hbmDib != NULL
        && stdDC.CreateCompatibleDC( CDC::FromHandle( m_pImg->hDC ) ))
            {
            CRect   rtBrush( 0, 0, bmData.bmWidth, bmData.bmHeight );
            BOOL    bBrushMade = FALSE;
            CBitmap bmDib;

            bmDib.Attach( hbmDib );

            pbmOld = stdDC.SelectObject( &bmDib );

            if (m_pImg->m_pPalette)
                {
                ppalOld = stdDC.SelectPalette( m_pImg->m_pPalette, FALSE );
                stdDC.RealizePalette();
                }

#ifdef FHSELCLIP
            if (bPrivateAvailable)
                {
                HGLOBAL hPts = (HGLOBAL)_GetClipboardData( m_wClipboardFormat );

                if (hPts)
                    {
                    short* lpShort = (short*)::GlobalLock( hPts );

                    if (lpShort)
                        {
                        BOOL bError   = FALSE;
                        int  iEntries = *lpShort++;
                        LPPOINT lpPts = (LPPOINT)lpShort;

                        CImgTool::Select( IDMB_PICKRGNTOOL );
                        CFreehandSelectTool* pTool = (CFreehandSelectTool*)CImgTool::GetCurrent();

                        if (pTool)
                            {
                            if (pTool->CreatePolyRegion( GetZoom(), lpPts, iEntries )
                            &&  MakeBrush( stdDC.m_hDC, rtBrush ))
                                {
                                bBrushMade = TRUE;
                                }
                            }
                        ::GlobalUnlock( hPts );
                        }
                    }
                }
#endif // FHSELCLIP

            if (! bBrushMade)
                {
                if (CImgTool::GetCurrentID() != IDMB_PICKTOOL)
                    CImgTool::Select( IDMB_PICKTOOL );

                bBrushMade = MakeBrush( stdDC.m_hDC, rtBrush );
                }

            if (bBrushMade)
                {
                // We have to "move" the brush so it appears...
                CRect rect( 0, 0, theImgBrush.m_rcSelection.Width(),
                                  theImgBrush.m_rcSelection.Height() );

                if (! bResizedBitmap)
                    {
                    // Move the brush so that it is in the upper-left corner of
                    // the view (in case it's scrolled)...
                    rect.OffsetRect( -m_xScroll, -m_yScroll );
                    }
                MoveBrush( rect );

                DirtyImg( m_pImg );

                theImgBrush.m_bFirstDrag = FALSE;

                bOkay = TRUE;
                }
            else
                {
                TRACE( TEXT("Paste: MakeBrush failed!\n") );
                }
            if (ppalOld)
                {
                ppalOld = stdDC.SelectPalette( ppalOld, FALSE );
                ppalOld = NULL;
                }

            stdDC.SelectObject( pbmOld );
            pbmOld = NULL;
            bmDib.Detach();
            }

        if (hbmDib != NULL)
            ::DeleteObject( hbmDib );

        if (ppalDib != NULL)
            delete ppalDib;
        }
LReturn:
    if (pbmOld != NULL)
        stdDC.SelectObject( pbmOld );

    if (ppalOld != NULL)
        stdDC.SelectPalette( ppalOld, FALSE );

    return bOkay;
    }

/***************************************************************************/
/* very similar to PasteImageClip, but this will paste into an existing    */
/* selection (theImgBrush), resizing it if necessary, and not moving it    */
/***************************************************************************/

BOOL CImgWnd::PasteImageFile( LPSTR lpDib )
    {
    CDC   stdDC;
    CRect cRectSelection = theImgBrush.m_rcSelection;
    BOOL bOkay = FALSE;

    if (lpDib == NULL)
        return bOkay;

    int iWidth  = (int)DIBWidth ( lpDib );
    int iHeight = (int)DIBHeight( lpDib );

    if (CImgTool::GetCurrentID()==IDMB_PICKTOOL && theImgBrush.m_bFirstDrag)
    {
        if (iWidth < theImgBrush.m_size.cx)
            {
            cRectSelection.right = cRectSelection.left + iWidth - 1;
            }
        if (iHeight < theImgBrush.m_size.cy)
            {
            cRectSelection.bottom = cRectSelection.top + iHeight - 1;
            }

        // If the image is a bitmap and the bitmap in the clipboard is larger,
        // then give the user the option of growing the image...
        if (iWidth  > theImgBrush.m_size.cx
        ||  iHeight > theImgBrush.m_size.cy)
            {
                cRectSelection.right  = cRectSelection.left + iWidth  - 1;
                cRectSelection.bottom = cRectSelection.top  + iHeight - 1;

                // PSS says users don't want to see this dialog
#if 0
            switch (AfxMessageBox( IDS_ENLAGEBITMAPFORCLIP,
                                    MB_YESNOCANCEL | MB_ICONQUESTION ))
                {
                default:
                    return bOkay;
                    break;

                case IDYES:
                    cRectSelection.right  = cRectSelection.left + iWidth  - 1;
                    cRectSelection.bottom = cRectSelection.top  + iHeight - 1;
                    break;

                case IDNO:
                    break;
                }
#endif
            }
    }
    else
    {
                int xPos = -m_xScroll;
                int yPos = -m_yScroll;

                switch (CheckPastedSize(iWidth, iHeight, m_pImg))
                {
                case IDYES:
                        xPos = yPos = 0;
                        break;

                case IDNO:
                        break;

                default:
                        return(bOkay);
                }

                CImgTool::Select(IDMB_PICKTOOL);
                cRectSelection = CRect(xPos, yPos, xPos+iWidth, yPos+iHeight);
    }

    MakeBrush( m_pImg->hDC, cRectSelection );
    // MakeBrush sets this
    theImgBrush.m_bFirstDrag = FALSE;

    if (! stdDC.CreateCompatibleDC( CDC::FromHandle( m_pImg->hDC ) ))
        {
        theApp.SetGdiEmergency();
        return bOkay;
        }

    CPalette* ppalDib = CreateDIBPalette( lpDib );

    ppalDib = FixupDibPalette( lpDib, ppalDib );

    HBITMAP hbmDib = DIBToBitmap( lpDib, theApp.m_pPalette, m_pImg->hDC );

    SetUndo( m_pImg );

    if (hbmDib != NULL)
        {
        CBitmap   bmDib;
        CPalette* ppalOld = NULL;
        CBitmap*  pbmOld  = NULL;

        bmDib.Attach( hbmDib );

        pbmOld = stdDC.SelectObject( &bmDib );

        if (m_pImg->m_pPalette)
            {
            ppalOld = stdDC.SelectPalette( m_pImg->m_pPalette, FALSE );
            stdDC.RealizePalette();
            }

        if (MakeBrush( stdDC.m_hDC, CRect( CPoint( 0, 0 ), cRectSelection.Size() ) ))
            {
            theImgBrush.m_bFirstDrag = FALSE;

            // We have to "move" the brush so it appears...
            MoveBrush( cRectSelection );

            DirtyImg( m_pImg );

            bOkay = TRUE;
            }
        else
            {
            TRACE( TEXT("Paste: MakeBrush failed!\n") );
            }

        if (ppalOld != NULL)
            {
            ppalOld = stdDC.SelectPalette( ppalOld, FALSE );
            }

        stdDC.SelectObject( pbmOld );
        bmDib.Detach();

        ::DeleteObject( hbmDib );
        }

    if (ppalDib != NULL)
        delete ppalDib;

    return bOkay;
    }

/***************************************************************************/
// Stolen from PBrush
//
/****************************Module*Header******************************\
* Module Name: metafile.c                                               *
* Routines to paste a metafile as a bitmap.                             *
* Copyright (c) 1987 - 1991  Microsoft Corporation                      *
\***********************************************************************/

/* Computes dimensions of a metafile picture in pixels */
BOOL GetMFDimensions(
    HANDLE hMF,     /* handle to the CF_METAFILEPICT object from clipbrd */
    HDC hDC,        /* display context */
    long *pWidth,    /* width of picture in pixels, OUT param */
    long *pHeight,   /* height of picture in pixels, OUT param */
    long *pcXPelsPerMeter,    /* horizontal resolution, OUT param */
    long *pcYPelsPerMeter,    /* vertical resolution, OUT param */
    IMG* pImg)
{
    METAFILEPICT FAR *lpMfp, Picture;
    int MapModeOld=0;
    RECT Rect;
    long xScale, yScale, Scale;
    int hRes, vRes;     /* horz and vert resolution, in pixels */
    int hSize, vSize;   /* horz and vert size, in mm */
    int fResult = FALSE;

    if (!hMF || !(lpMfp = (METAFILEPICT FAR *)GlobalLock(hMF)))
        return FALSE;
    /* copy metafile picture hdr */
    Picture = *lpMfp;
    GlobalUnlock(hMF);

    /* Do not modify given DC's attributes */
    SaveDC(hDC);

    /* set the mapping mode */
    MapModeOld = SetMapMode(hDC, Picture.mm);
    if (Picture.mm != MM_ISOTROPIC && Picture.mm != MM_ANISOTROPIC)
    {
        /* For modes other than ISOTROPIC and ANISOTROPIC the picture
         * dimensions are given in logical units.
        /* Convert logical units to pixels. */
        Rect.left = 0; Rect.right = Picture.xExt;
        Rect.top = 0;  Rect.bottom = Picture.yExt;
        if (!LPtoDP(hDC, (LPPOINT)&Rect, 2))
            goto Error;
        *pWidth = Rect.right - Rect.left + 1;
        *pHeight = Rect.bottom - Rect.top + 1;
        fResult = TRUE;
    }
    else    /* ISOTROPIC or ANISOTROPIC mode,
             * using the xExt and yExt, determine pixel width and height of
             * the image */
    {
        hRes = GetDeviceCaps(hDC, HORZRES);
        vRes = GetDeviceCaps(hDC, VERTRES);
        hSize = GetDeviceCaps(hDC, HORZSIZE);
        vSize = GetDeviceCaps(hDC, VERTSIZE);
        *pcXPelsPerMeter = hRes * 1000 / hSize;
        *pcYPelsPerMeter = vRes * 1000 / vSize;
        if (Picture.xExt == 0)  /* assume default size, aspect ratio */
        {
            *pWidth = pImg->cxWidth;
            *pHeight = pImg->cyHeight;
        }
        else if (Picture.xExt > 0)  /* use suggested size in HIMETRIC units */
        {
            // convert suggested extents(in .01 mm units) for picture to pixel units.

            // xPixelsPermm = hRes/hSize;, yPixelsPermm = vRes/vSize;
            // Use Pixels Per logical unit.
            // *pWidth = Picture.xExt*xPixelsPermm/100;
            // *pHeight = Picture.yExt*yPixelsPermm/100;
            *pWidth = ((long)Picture.xExt * hRes/hSize/100);
            *pHeight = ((long)Picture.yExt * vRes/vSize/100);
        }
        else if (Picture.xExt < 0)  /* use suggested aspect ratio, default size */
        {
            // 1 log unit = .01 mm.
            // (# of log units in imageWid pixels)/xExt;
            xScale = 100L * (long) pImg->cxWidth *
                            hSize/hRes/-Picture.xExt;
            // (# of log units in imageHgt pixels)/yExt;
            yScale = 100L * (long) pImg->cyHeight *
                            vSize/vRes/-Picture.yExt;
            // choose the minimum to accomodate the entire image
            Scale = min(xScale, yScale);
            // use scaled Pixels Per log unit.
            *pWidth = ((long)-Picture.xExt * Scale *
                            hRes/hSize / 100);
            *pHeight = ((long)-Picture.yExt * Scale *
                            vRes/vSize / 100);
        }
        fResult = TRUE;
    }

Error:
    if (MapModeOld)
        SetMapMode(hDC, MapModeOld);    /* select the old mapping mode */
    RestoreDC(hDC, -1);
    return fResult;
}

BOOL PlayMetafileIntoDC(
    HANDLE hMF,
    RECT *pRect,
    HDC hDC)
{
    HBRUSH      hbrBackground;
    METAFILEPICT FAR *lpMfp;

    if (!(lpMfp = (METAFILEPICT FAR *)GlobalLock(hMF)))
        return FALSE;

    SaveDC(hDC);

        /* Setup background color for the bitmap */
    hbrBackground = CreateSolidBrush(crRight);

    if (hbrBackground)
    {
        FillRect(hDC, pRect, hbrBackground);
        DeleteObject(hbrBackground);
    }

    SetMapMode(hDC, lpMfp->mm);
    if (lpMfp->mm == MM_ISOTROPIC || lpMfp->mm == MM_ANISOTROPIC)
        SetViewportExtEx(hDC, pRect->right-pRect->left, pRect->bottom-pRect->top,
            NULL);
    PlayMetaFile(hDC, lpMfp->hMF);
    GlobalUnlock(hMF);
    RestoreDC(hDC, -1);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgbrush.h ===
#ifndef __IMGBRUSH_H__
#define __IMGBRUSH_H__

class CImgBrush : public CObject
    {
    public: /******************************************************************/

    CImgBrush();
    virtual ~CImgBrush();


    BOOL CopyTo( CImgBrush& destImgBrush );

    CPalette* SetBrushPalette( CDC* pdc, BOOL bForce = FALSE );
    HPALETTE  SetBrushPalette( HDC  hdc, BOOL bForce = FALSE );

    BOOL SetSize   ( CSize newSize, BOOL bStretchToFit=TRUE );
    void ColorToMonoBitBlt(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
        CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF transparentColor);
    void RecalcMask( COLORREF transparentColor );

    void BltMatte  ( IMG* pimg, CPoint topLeft );
    void BltReplace( IMG* pimg, CPoint topLeft );
    void BltColor  ( IMG* pimg, CPoint topLeft, COLORREF color );

    void CenterHandle();
    void TopLeftHandle();

    CRgn      m_cRgnPolyFreeHandSelBorder;
    CRgn      m_cRgnPolyFreeHandSel;

    CDC       m_dc;
    CBitmap   m_bitmap;
    CSize     m_size;
    CDC       m_maskDC;
    CBitmap   m_maskBitmap;

    HBITMAP   m_hbmOld;
    HBITMAP   m_hbmMaskOld;

    BOOL      m_bFirstDrag;
    BOOL      m_bLastDragWasASmear;
    BOOL      m_bLastDragWasFirst;
    BOOL      m_bCuttingFromImage;
    BOOL      m_bMakingSelection;
    BOOL      m_bMoveSel;
    BOOL      m_bSmearSel;
    BOOL      m_bOpaque;

    CRect     m_rcDraggedFrom;
    CSize     m_dragOffset;

    IMG*      m_pImg;

    CRect     m_rcSelection;
    CSize     m_handle;
    };


extern CImgBrush NEAR theImgBrush;

void GetMonoBltColors(HDC hDC, HBITMAP hBM, COLORREF& crNewBk, COLORREF& crNewText);
BOOL QuickColorToMono(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
	CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF crTrans);

// #define DEBUGSHOWBITMAPS
#if defined(DEBUGSHOWBITMAPS)
void DebugShowBitmap(HDC hdcSrc, int x, int y, int wid, int hgt);
#else
#define DebugShowBitmap(hdc,x,y,w,h)
#endif

#endif // __IMGBRUSH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgcolor.cpp ===
/******************************************************************************/
/*                                                                            */
/* Class Implementations in this file                                         */
/*      CFloatImgColorsWnd                                                    */
/*      CImgColorsWnd                                                         */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "docking.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "props.h"
#include "colorsrc.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

#define cxColorBox 16
#define cyColorBox 16

#define TRYANYTHING



/******************************************************************************/

CImgColorsWnd* NEAR g_pImgColorsWnd = NULL;

/******************************************************************************/
//
// MonoRect -- draw a dithered monochrome rectangle with any intensity
//

BOOL MonoRect( CDC* pDC, const CRect& rect, COLORREF rgb, BOOL bFrame )
    {
    CDC      monoDC;
    CBitmap  monoBitmap;
    CBrush   brush;
    CBrush*  pOldBrush;
    CBitmap* pOldBitmap;
        CPen*    pOldPen = NULL;

        //REARCHITECT -This can leak DCs and Bitmaps
    if (! monoDC.CreateCompatibleDC( pDC )
    ||  ! monoBitmap.CreateBitmap( rect.Width(), rect.Height(), 1, 1, NULL )
    ||  ! brush.CreateSolidBrush( rgb ))
        {
        return FALSE;
        }

    pOldBitmap = monoDC.SelectObject( &monoBitmap );
    pOldBrush  = monoDC.SelectObject( &brush      );

    if (! bFrame)
        pOldPen = (CPen *)monoDC.SelectStockObject( NULL_PEN );

    monoDC.Rectangle( 0, 0, rect.Width(), rect.Height() );

    pDC->BitBlt( rect.left, rect.top, rect.Width(), rect.Height(),
                                         &monoDC, 0, 0, SRCCOPY );
    monoDC.SelectObject( pOldBrush  );
    monoDC.SelectObject( pOldBitmap );
        if ( pOldPen )
                monoDC.SelectObject(pOldPen);
    monoBitmap.DeleteObject();
    brush.DeleteObject();

    return TRUE;
    }

/******************************************************************************/


/******************************************************************************/

CImgColorsWnd::CImgColorsWnd()
{
    ASSERT( g_pColors );  // just to make sure

    m_nOffsetY       = cyColorBox / 2;
    m_nDisplayColorsInitial = 28;
    m_nDisplayColors = min( g_pColors->GetColorCount(), m_nDisplayColorsInitial );
    m_rectColors.SetRectEmpty();

    // Number of colors / 2 rows + 2 for fore/back area (which is size of 2 wide 2 high)
    //        * size of color  see below for + 3
    // 2 rows * hight for 1 row   +3 is 1 for border above 1st row, 1 for border 2nd row 1 for border on bottom
    m_rectColors.right  = (m_nDisplayColors / 2 + 2) * cxColorBox + 3;
    m_rectColors.bottom = 2 * cyColorBox + 3;

    m_nCols = m_rectColors.Width()  / cxColorBox;
    m_nRows = m_rectColors.Height() / cyColorBox;

}

/******************************************************************************/

BEGIN_MESSAGE_MAP(CImgColorsWnd, CControlBar)
    //{{AFX_MSG_MAP(CImgColorsWnd)
    ON_WM_ERASEBKGND()
    ON_WM_PAINT()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_LBUTTONDOWN()
    ON_WM_RBUTTONDBLCLK()
    ON_WM_RBUTTONDOWN()
    ON_WM_GETMINMAXINFO()
        ON_WM_MOUSEMOVE()
        ON_WM_KEYDOWN()
        ON_WM_LBUTTONUP()
        ON_WM_CLOSE()
        //}}AFX_MSG_MAP

    ON_WM_WINDOWPOSCHANGING()
END_MESSAGE_MAP()

/******************************************************************************/

BOOL CImgColorsWnd::Create( const TCHAR* pWindowName, DWORD dwStyle, CWnd* pParentWnd )
    {
        // save the style
        m_dwStyle  = (UINT)dwStyle;
      dwStyle &= ~WS_VISIBLE;

    m_rectColors.bottom += (2 * m_nOffsetY);

        // Create the window offscreen initially, since it will get moved to the
        // proper location later
        CRect rcInit(-m_rectColors.right, -m_rectColors.bottom, 0, 0);

        BOOL bCreate = CControlBar::Create( NULL, pWindowName, dwStyle, rcInit,
                                pParentWnd, ID_VIEW_COLOR_BOX, NULL );

        if (m_dwStyle & WS_VISIBLE)
        {
        g_pImgColorsWnd->ShowWindow(SW_SHOW);
        g_pImgColorsWnd->UpdateWindow();
        }

        return bCreate;
    }

/******************************************************************************/

void CImgColorsWnd::OnClose()
    {
#ifdef TRYANYTHING
        CControlBar::OnClose();
#endif
    }

/******************************************************************************/

void CImgColorsWnd::OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler )
    {
    }

/******************************************************************************/

WORD CImgColorsWnd::GetHelpOffset()
    {
    return 0; // REVIEW: NYI!
    }

/******************************************************************************/

CImgColorsWnd::HitZone CImgColorsWnd::HitTest(const CPoint& point)
    {
    CRect rect;

    for (HitZone hitZone = curColor;
                 hitZone < (HitZone)(firstColor + m_nDisplayColors);
                 hitZone = (HitZone)(hitZone + 1))
        if (GetHitRect( hitZone, rect ) && rect.PtInRect( point ))
            return hitZone;

    return none;
    }

/******************************************************************************/

BOOL CImgColorsWnd::GetHitRect( HitZone hitZone, CRect& rect )
    {
    CRect client = m_rectColors;

    client.InflateRect( -1, -(m_nOffsetY + 1) );

    switch (hitZone)
        {
        case none:
            return FALSE;

        case curColor:
            rect.SetRect( client.left, client.top,
                          client.left + cxColorBox * 2 + 1,
                          client.top  + cyColorBox * 2 + 1);
            break;

        default:
            {
            int nColor = (int)hitZone;

            if (nColor < 0 || nColor > m_nDisplayColors)
                return FALSE;

            int row = nColor / (m_nCols - 2);
            int col = nColor % (m_nCols - 2);

            rect.SetRect( client.left + (2 + col    ) * cxColorBox,
                          client.top  +      row      * cyColorBox,
                          client.left + (2 + col + 1) * cxColorBox,
                          client.top  + (    row + 1) * cyColorBox );
            }
            break;
        }

    return TRUE;
    }

/******************************************************************************/

BOOL CImgColorsWnd::OnEraseBkgnd( CDC* pDC )
    {
    CRect rect;

    GetClientRect( rect );

    pDC->FillRect( rect, GetSysBrush( COLOR_BTNFACE ) );

    rect = m_rectColors;

    rect.InflateRect( -1, -(m_nOffsetY + 1) );

    pDC->FillRect( rect, GetSysBrush( COLOR_BTNSHADOW ) );

    GetHitRect( curColor, rect );

    pDC->FillRect(rect, GetSysBrush( COLOR_BTNFACE ) );

        return CControlBar::OnEraseBkgnd( pDC );
    }

/******************************************************************************/

void CImgColorsWnd::OnPaint()
    {
    CPaintDC dc( this );
    CPalette *pcOldPalette = NULL;
    m_nDisplayColors = min( g_pColors->GetColorCount(), m_nDisplayColorsInitial );
    m_rectColors.right  = (m_nDisplayColors / 2 + 2) * cxColorBox + 3;
    m_nCols = m_rectColors.Width()  / cxColorBox;

    if (! dc.m_hDC)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (theApp.m_pPalette)
        {
                BOOL bForce = FALSE;

                // If we do not realize as a background brush when in-place, we can get
                // an infinite recursion of the container and us trying to realize the
                // palette
                if (theApp.m_pwndInPlaceFrame)
                {
                        bForce = TRUE;
                }

        pcOldPalette = dc.SelectPalette( theApp.m_pPalette, bForce );
        dc.RealizePalette();
        }
    dc.FillRect( (CRect*)&dc.m_ps.rcPaint, GetSysBrush(COLOR_BTNFACE) );
    PaintCurColors( &dc, (CRect*)&dc.m_ps.rcPaint );
    PaintColors   ( &dc, (CRect*)&dc.m_ps.rcPaint );

    if (pcOldPalette)
        dc.SelectPalette( pcOldPalette, FALSE );
    }

/******************************************************************************/

CSize CImgColorsWnd::CalcFixedLayout( BOOL bStretch, BOOL bHorz )
    {
#ifdef TRYANYTHING
        return m_rectColors.Size();
#else
    CSize size = CControlBar::CalcFixedLayout( bStretch, bHorz );

    size.cy = m_rectColors.Height();

    return size;
#endif
    }

/******************************************************************************/

void CImgColorsWnd::OnLButtonDown(UINT nFlags, CPoint point)
    {
    HitZone hitZone = HitTest( point );

    switch (hitZone)
       {
       case none:
          CControlBar::OnLButtonDown(nFlags,point);
          break;

       case curColor:
          break;

       default:
          if (nFlags & MK_CONTROL)
          {
             SetTransColor (hitZone);
          }
          else
          {
             SetDrawColor( (int)hitZone );
          }

          break;
        }
    }

/******************************************************************************/

void CImgColorsWnd::OnRButtonDown(UINT nFlags, CPoint point)
 {
    if (GetCapture() == this)
        {
        CancelDrag();

        return;
        }

    HitZone hitZone = HitTest( point );

    switch (hitZone)
    {
       case none:
       case curColor:
          break;

       default:
          if (nFlags & MK_CONTROL)
          {
             SetTransColor( hitZone );
          }
          else
          {
             SetEraseColor( hitZone );
          }

            break;
    }
 }

/******************************************************************************/

void CImgColorsWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
    {
    HitZone hitZone = HitTest( point );

    switch (hitZone)
        {
        case none:
        case curColor:
            break;

        default:
            if (g_pColors)
                g_pColors->EditColor( TRUE, nFlags&MK_CONTROL );
            break;
        }
    }

/******************************************************************************/

void CImgColorsWnd::OnRButtonDblClk(UINT nFlags, CPoint point)
    {
    HitZone hitZone = HitTest( point );

    switch (hitZone)
        {
        case none:
        case curColor:
            break;

        default:
            if (g_pColors)
                g_pColors->EditColor( FALSE, nFlags&MK_CONTROL );
            break;
        }
    }

/******************************************************************************/

void CImgColorsWnd::OnLButtonUp( UINT nFlags, CPoint point )
    {
    CControlBar::OnLButtonUp( nFlags, point );
    }

/******************************************************************************/

void CImgColorsWnd::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
    {
    CWnd::OnGetMinMaxInfo(lpMMI);

    lpMMI->ptMinTrackSize.x = 37;
    lpMMI->ptMinTrackSize.y = 37;
    lpMMI->ptMaxTrackSize.x = 37 + 128 * 16;
    lpMMI->ptMaxTrackSize.y = 37 + 128 * 16;
    }

/******************************************************************************/

void CImgColorsWnd::PaintCurColors(CDC* pDC, const CRect* pPaintRect)
    {
        CBrush  highlight(GetSysColor(COLOR_BTNHIGHLIGHT));
        CBrush  lowlight(GetSysColor(COLOR_BTNTEXT));
        CBrush  shadow(GetSysColor(COLOR_BTNSHADOW));
        CBrush  face(GetSysColor(COLOR_BTNFACE));

    CRect rect;

    GetHitRect( curColor, rect );

    // Draw current color indicators

#ifdef OLDBORDER
    // Box around colors
    rect.InflateRect( -2, -2 );

    Draw3dRect( pDC->m_hDC, &rect );
    CBrush* pOldBrush = (CBrush*)pDC->SelectStockObject( NULL_BRUSH );

    rect.InflateRect( -1, -1 );

    pDC->Rectangle( &rect );
    pDC->SelectObject( pOldBrush );

#else
    rect.InflateRect( -1, -1 ); rect.top--;
        pDC->FrameRect(&rect,&highlight);
        rect.right--; rect.bottom--;
        pDC->FrameRect(&rect,&shadow);
        rect.left++; rect.top++;
        pDC->FrameRect(&rect,&face);
        rect.right--; rect.bottom--;
        pDC->FrameRect(&rect,&lowlight);
        rect.left++; rect.top++;


        COLORREF        oldTextColor = pDC->SetTextColor(GetSysColor(COLOR_BTNFACE));
        COLORREF        oldBkColor = pDC->SetBkColor(GetSysColor(COLOR_BTNHIGHLIGHT));
        // Draw the transparent color box if set
        if (crTrans != TRANS_COLOR_NONE) // not default
        {
           if (g_pColors->GetMonoFlag())
           {
              MonoRect ( pDC, rect, crTrans, TRUE);
           }
           else
           {
              CBrush brTrans(crTrans);
              pDC->FillRect(&rect, &brTrans);
           }
        }
        else
        {
           pDC->FillRect(&rect,GetHalftoneBrush());
        }
        pDC->SetTextColor(oldTextColor);
        pDC->SetBkColor(oldBkColor);
#endif


    // Draw the overlapping foreground/background color boxes...

    PaintCurColorBox( pDC, TRUE  ); // Background color
    PaintCurColorBox( pDC, FALSE ); // Foreground color
    }

/******************************************************************************/

void CImgColorsWnd::PaintColors(CDC* pDC, const CRect* pPaintRect)
    {
    BOOL bMono = g_pColors->GetMonoFlag();

    CRect    r( 0, 0, 0, 0 );
    COLORREF color;

        CBrush  highlight(GetSysColor(COLOR_BTNHIGHLIGHT));
        CBrush  lowlight(GetSysColor(COLOR_BTNTEXT));
        CBrush  shadow(GetSysColor(COLOR_BTNSHADOW));
        CBrush  face(GetSysColor(COLOR_BTNFACE));

    for (int iLoop = 0; iLoop < m_nDisplayColors; iLoop++)
        if (GetHitRect( (HitZone)iLoop, r ))
            {
               color = g_pColors->GetColor( iLoop );

               pDC->FrameRect(&r,&highlight);
               r.right--; r.bottom--;
               pDC->FrameRect(&r,&shadow);
               r.left++; r.top++;
               pDC->FrameRect(&r,&face);
               r.right--; r.bottom--;
               pDC->FrameRect(&r,&lowlight);

            if (bMono)
                MonoRect( pDC, r, color, TRUE );
            else
                {
                   r.left++; r.top++;
                   CBrush   brush(color);
                   pDC->FillRect( &r, &brush );
                }
            }
    }

/******************************************************************************/

void CImgColorsWnd::InvalidateCurColors()
    {
    CRect rect;

    GetHitRect( curColor, rect );
    InvalidateRect( &rect, FALSE );

    if (CImgTool::GetCurrent()->IsFilled())
        g_pImgToolWnd->InvalidateOptions( FALSE );
    }

/******************************************************************************/

void CImgColorsWnd::PaintCurColorBox(CDC* pDC, BOOL bRight)
    {
    BOOL bMono = g_pColors->GetMonoFlag();

        CBrush  highlight(GetSysColor(COLOR_BTNHIGHLIGHT));
        CBrush  shadow(GetSysColor(COLOR_BTNSHADOW));
        CBrush  face(GetSysColor(COLOR_BTNFACE));

    CRect rc(0, 0, 15, 15);

    COLORREF rgb;
    CBrush   brush;
    CRect    curColorRect;

    GetHitRect( curColor, curColorRect );

    if (bRight)
        {
        rgb = crRight;
        rc.OffsetRect( curColorRect.left + 12, curColorRect.top + 12 );
        }
    else
        {
        rgb = crLeft;
        rc.OffsetRect( curColorRect.left + 5, curColorRect.top + 5 );
        }

        rc.right--; rc.bottom--;
        pDC->FrameRect(&rc,&highlight);
        rc.OffsetRect(1,1);
        pDC->FrameRect(&rc,&shadow);
        rc.right--; rc.bottom--;
        pDC->FrameRect(&rc,&face);
    rc.InflateRect( -1, -1 );

    if (bMono)
        {
        MonoRect( pDC, rc, rgb, TRUE );
                }
    else
                {
                CBrush  colorWell(rgb);
                pDC->FillRect(&rc,&colorWell);
                }
    }

/******************************************************************************/

void CImgColorsWnd::OnMouseMove(UINT nFlags, CPoint point)
    {
    CControlBar::OnMouseMove( nFlags, point );
    }

/******************************************************************************/

void CImgColorsWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
    {
    CControlBar::OnKeyDown( nChar, nRepCnt, nFlags );
    }

/******************************************************************************/

void CImgColorsWnd::CancelDrag()
    {
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgbrush.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "t_fhsel.h"
#include "toolbox.h"

#include "mmsystem.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

CImgBrush theImgBrush;

CImgBrush::CImgBrush() : m_bCuttingFromImage(FALSE), m_bOpaque(TRUE)
    {
    }

CImgBrush::~CImgBrush()
    {
    // cleanup old region if exists
    if (m_cRgnPolyFreeHandSel.GetSafeHandle() != NULL)
        m_cRgnPolyFreeHandSel.DeleteObject();

    if (m_cRgnPolyFreeHandSelBorder.GetSafeHandle() != NULL)
        m_cRgnPolyFreeHandSelBorder.DeleteObject();

    if (m_hbmOld)
        m_dc.SelectObject( CBitmap::FromHandle( m_hbmOld ) );

    if (m_hbmMaskOld)
        m_dc.SelectObject( CBitmap::FromHandle( m_hbmMaskOld ) );

    m_dc.DeleteDC();
    m_bitmap.DeleteObject();
    m_maskDC.DeleteDC();
    m_maskBitmap.DeleteObject();
    }

BOOL CImgBrush::CopyTo(CImgBrush& destBrush)
    {
    if (destBrush.m_hbmOld)
        destBrush.m_dc.SelectObject( CBitmap::FromHandle( destBrush.m_hbmOld ) );

    if (destBrush.m_hbmMaskOld)
        destBrush.m_maskDC.SelectObject( CBitmap::FromHandle( destBrush.m_hbmMaskOld ) );

    destBrush.m_hbmOld     = NULL;
    destBrush.m_hbmMaskOld = NULL;

    destBrush.m_dc.DeleteDC();
    destBrush.m_bitmap.DeleteObject();
    destBrush.m_maskDC.DeleteDC();
    destBrush.m_maskBitmap.DeleteObject();

    if (m_dc.m_hDC != NULL)
        {
        if (! destBrush.m_dc.CreateCompatibleDC( NULL )
        ||  ! destBrush.m_bitmap.CreateCompatibleBitmap(&m_dc, m_size.cx, m_size.cy))
            {
            theApp.SetGdiEmergency(FALSE);
            return FALSE;
            }

        destBrush.m_hbmOld = (HBITMAP)((destBrush.m_dc.SelectObject( &destBrush.m_bitmap ))->GetSafeHandle());

        CPalette* ppalOldSrc  = SetBrushPalette(           &m_dc, TRUE ); // Background ??
        CPalette* ppalOldDest = SetBrushPalette( &destBrush.m_dc, TRUE ); // Background ??

        destBrush.m_dc.BitBlt( 0, 0, m_size.cx, m_size.cy, &m_dc, 0, 0, SRCCOPY );

        if (ppalOldSrc)
            m_dc.SelectPalette( ppalOldSrc, TRUE ); // Background ??

        if (ppalOldDest)
            destBrush.m_dc.SelectPalette( ppalOldDest, TRUE ); // Background ??
        }

    if (m_maskDC.m_hDC != NULL)
        {
        if (! destBrush.m_maskDC.CreateCompatibleDC(NULL)
        ||  ! destBrush.m_maskBitmap.CreateCompatibleBitmap(&m_maskDC, m_size.cx,
                                                                       m_size.cy))
            {
            theApp.SetGdiEmergency(FALSE);
            return FALSE;
            }

        destBrush.m_hbmMaskOld = (HBITMAP)((destBrush.m_maskDC.SelectObject(
                                           &destBrush.m_maskBitmap))->GetSafeHandle());
        destBrush.m_maskDC.BitBlt(0, 0, m_size.cx, m_size.cy, &m_maskDC, 0, 0, SRCCOPY);
        }

    destBrush.m_size               = m_size;
    destBrush.m_bFirstDrag         = m_bFirstDrag;
    destBrush.m_bLastDragWasASmear = m_bLastDragWasASmear;
    destBrush.m_bLastDragWasFirst  = m_bLastDragWasFirst;
    destBrush.m_bMakingSelection   = m_bMakingSelection;
    destBrush.m_bMoveSel           = m_bMoveSel;
    destBrush.m_bSmearSel          = m_bSmearSel;
    destBrush.m_bOpaque            = m_bOpaque;
    destBrush.m_rcDraggedFrom      = m_rcDraggedFrom;
    destBrush.m_pImg               = m_pImg;
    destBrush.m_rcSelection        = m_rcSelection;
    destBrush.m_handle             = m_handle;

    return TRUE;
    }


void CImgBrush::CenterHandle()
    {
    m_handle.cx = m_size.cx / 2;
    m_handle.cy = m_size.cy / 2;
    }


void CImgBrush::TopLeftHandle()
    {
    m_handle.cx = 0;
    m_handle.cy = 0;
    }

CPalette* CImgBrush::SetBrushPalette( CDC* pdc, BOOL bForce )
    {
    CPalette* ppal    = NULL;
    CPalette* ppalOld = NULL;

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        ppal = theApp.m_pPalette;

    if (ppal != NULL)
        {
        ppalOld = pdc->SelectPalette( ppal, bForce );

        pdc->RealizePalette();
        }
    return ppalOld;
    }

HPALETTE CImgBrush::SetBrushPalette( HDC hdc, BOOL bForce )
    {
    CPalette* ppal    = NULL;
    HPALETTE  hpalOld = NULL;

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        ppal = theApp.m_pPalette;

    if (ppal != NULL)
        {
        hpalOld = ::SelectPalette( hdc, (HPALETTE)ppal->m_hObject, bForce );

        RealizePalette( hdc );
        }
    return hpalOld;
    }

BOOL CImgBrush::SetSize( CSize newSize, BOOL bStretchToFit )
    {
    BOOL bFlipX;
    BOOL bFlipY;

    if (newSize.cx == m_size.cx
    &&  newSize.cy == m_size.cy)
        return TRUE;

    if (bFlipX = (newSize.cx < 0))
        newSize.cx = -newSize.cx;

    if (bFlipY = (newSize.cy < 0))
        newSize.cy = -newSize.cy;

    if (newSize.cx == 0)
        newSize.cx  = 1;

    if (newSize.cy == 0)
        newSize.cy  = 1;

    if (CImgTool::GetCurrentID() != IDMX_TEXTTOOL)
        {
        CDC     newDC;
        CBitmap newBitmap;
        CDC     newMaskDC;
        CBitmap newMaskBitmap;

                //REARCHITECT Potential for DC && Bitmap leaks here on partial failure!!
        if (!         newDC.CreateCompatibleDC    ( &m_dc )
        ||  !     newBitmap.CreateCompatibleBitmap( &m_dc, newSize.cx, newSize.cy )
        ||  !     newMaskDC.CreateCompatibleDC    ( &m_dc )
        ||  ! newMaskBitmap.CreateBitmap(newSize.cx, newSize.cy, 1, 1, NULL ))
            return FALSE;

        CBitmap*  pbmOld      = newDC.SelectObject( &newBitmap );
        CPalette* ppalOldSrc  = SetBrushPalette(  &m_dc, FALSE );
        CPalette* ppalOldDest = SetBrushPalette( &newDC, FALSE );

        newDC.SetStretchBltMode(COLORONCOLOR);


        if (bStretchToFit)
            {
            StretchCopy( newDC.m_hDC, bFlipX ?  newSize.cx : 0,
                                      bFlipY ?  newSize.cy : 0,
                                      bFlipX ? -newSize.cx : newSize.cx,
                                      bFlipY ? -newSize.cy : newSize.cy,
                          m_dc.m_hDC, 0, 0, m_size.cx, m_size.cy );
            }
        else
            {
            StretchCopy( newDC.m_hDC, bFlipX ? newSize.cx : 0,
                                      bFlipY ? newSize.cy : 0,
                                      m_size.cx, m_size.cy,
                    m_dc.m_hDC, 0, 0, m_size.cx, m_size.cy );
            }


        COLORREF crOldBk    = newDC.SetBkColor( crRight );
        CBitmap* pbmOldMask = newMaskDC.SelectObject( &newMaskBitmap );

        if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
            {
            CFreehandSelectTool* pTool = (CFreehandSelectTool*)CImgTool::GetCurrent();

            if (pTool->ExpandPolyRegion( newSize.cx, newSize.cy ))
                {
                newMaskDC.PatBlt( 0, 0, newSize.cx, newSize.cy, BLACKNESS );

                if (m_cRgnPolyFreeHandSel.GetSafeHandle())
                    newMaskDC.FillRgn( &m_cRgnPolyFreeHandSel,
                                        CBrush::FromHandle( (HBRUSH)::GetStockObject( WHITE_BRUSH ) ) );
                }
            }
        else
            {
            newMaskDC.PatBlt( 0, 0, newSize.cx, newSize.cy, WHITENESS );
            }

        newMaskDC.BitBlt( 0, 0, newSize.cx, newSize.cy, &newDC, 0, 0, DSna );
        newDC.SetBkColor( crOldBk );

        if (ppalOldSrc)
            m_dc.SelectPalette( ppalOldSrc, FALSE );

        if (ppalOldDest)
            newDC.SelectPalette( ppalOldDest, FALSE );

        if (m_hbmOld)
            m_dc.SelectObject( CBitmap::FromHandle( m_hbmOld ) );

        if (m_hbmMaskOld)
            m_maskDC.SelectObject( CBitmap::FromHandle( m_hbmMaskOld ) );

                m_dc.DeleteDC();
            m_maskDC.DeleteDC();
            m_bitmap.DeleteObject();
        m_maskBitmap.DeleteObject();

                m_dc.Attach(         newDC.Detach() );
            m_bitmap.Attach(     newBitmap.Detach() );
            m_maskDC.Attach(     newMaskDC.Detach() );
        m_maskBitmap.Attach( newMaskBitmap.Detach() );

        m_hbmOld     = (HBITMAP)(pbmOld->GetSafeHandle());
        m_hbmMaskOld = (HBITMAP)(pbmOldMask->GetSafeHandle());
        }

    m_size.cx = newSize.cx;
    m_size.cy = newSize.cy;

    return TRUE;
    }


#if defined(DEBUGSHOWBITMAPS)
void DebugShowBitmap(HDC hdcSrc, int x, int y, int wid, int hgt)
{
        HDC hdcDst = GetDC(NULL);
        BitBlt(hdcDst, 0, 0, wid, hgt, hdcSrc, x, y, SRCCOPY);
        ReleaseDC(NULL, hdcDst);
}
#endif


BOOL QuickColorToMono(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
        CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF crTrans)
{
        RGBQUAD rgb[256];
        int nColors = GetDIBColorTable(pdcColor->m_hDC, 0, 256, &rgb[0]);
        if (nColors == 0)
        {
                return(FALSE);
        }

        RGBQUAD rgbWhite;
        rgbWhite.rgbRed   = 255;
        rgbWhite.rgbGreen = 255;
        rgbWhite.rgbBlue  = 255;
        rgbWhite.rgbReserved = 0;

        RGBQUAD rgbBlack;
        rgbBlack.rgbRed   = 0;
        rgbBlack.rgbGreen = 0;
        rgbBlack.rgbBlue  = 0;
        rgbBlack.rgbReserved = 0;

        RGBQUAD rgbTemp[256];

        switch ((BYTE)((crTrans)>>24))
        {
        case 0:
        case 2:
        {
                RGBQUAD rgbTrans;
                rgbTrans.rgbRed   = GetRValue(crTrans);
                rgbTrans.rgbGreen = GetGValue(crTrans);
                rgbTrans.rgbBlue  = GetBValue(crTrans);
                rgbTrans.rgbReserved = 0;

                for (int nColor=nColors-1; nColor>=0; --nColor)
                {
                        if (memcmp(&rgb[nColor], &rgbTrans, sizeof(rgbTrans)) == 0)
                        {
                                rgbTemp[nColor] = rgbWhite;
                        }
                        else
                        {
                                rgbTemp[nColor] = rgbBlack;
                        }
                }

                break;
        }

        // We can put support for different COLORREF formats here

        default:
                return(FALSE);
        }

        SetDIBColorTable(pdcColor->m_hDC, 0, nColors, &rgbTemp[0]);
        pdcMono->BitBlt(xMono, yMono, cx, cy, pdcColor, xColor, yColor, dwROP);
        SetDIBColorTable(pdcColor->m_hDC, 0, nColors, &rgb[0]);

        return(TRUE);
}


#define COLORTOMONOBUG
#ifdef  COLORTOMONOBUG
void CImgBrush::ColorToMonoBitBlt(CDC* pdcMono, int xMono, int yMono, int cx, int cy,
        CDC *pdcColor, int xColor, int yColor, DWORD dwROP, COLORREF transparentColor)
{
        if (QuickColorToMono(pdcMono, xMono, yMono, cx, cy,
                pdcColor, xColor, yColor, dwROP, transparentColor))
        {
                return;
        }

        CDC dcColor;
        CTempBitmap bmColor;
        CBitmap* pbmOldColor = NULL;

        // Use a moderate-sized intermediate bitmap
        int cyStep = 0xffff / cx;
        cyStep = max(1, min(cy, cyStep));

        HDC hdcScreen = GetDC(NULL);
        BOOL bError = (!dcColor.CreateCompatibleDC(NULL)
                        || !bmColor.CreateCompatibleBitmap(CDC::FromHandle(hdcScreen), cx, cyStep)
                        || (pbmOldColor = dcColor.SelectObject(&bmColor))==NULL);
        ReleaseDC(NULL, hdcScreen);

        if (bError)
        {
                theApp.SetGdiEmergency(FALSE);
                return;
        }

        CPalette* ppalOld  = SetBrushPalette( pdcColor, FALSE );
        CPalette* ppalOldColor  = SetBrushPalette( &dcColor, FALSE );
        dcColor.SetBkColor( transparentColor );

        int yStep;
        for (yStep=0; yStep<cy; yStep+=cyStep)
        {
                if (cyStep > cy - yStep)
                {
                        cyStep = cy - yStep;
                }

                dcColor.BitBlt(0, 0, cx, cyStep, pdcColor, xColor, yColor+yStep, SRCCOPY);
                pdcMono->BitBlt(xMono, yMono+yStep, cx, cyStep, &dcColor, 0, 0, dwROP);

                DebugShowBitmap(pdcMono->m_hDC, xMono, yMono, cx, cy);
        }

        if (ppalOld)
        {
                pdcColor->SelectPalette( ppalOld, FALSE );
        }

        dcColor.SelectObject(pbmOldColor);

        if (ppalOldColor)
        {
                dcColor.SelectPalette( ppalOldColor, FALSE );
        }
}
#endif  // COLORTOMONOBUG

void CImgBrush::RecalcMask( COLORREF transparentColor )
    {
    if (! m_dc.GetSafeHdc() || ! m_maskDC.m_hDC)
        return;

#ifndef COLORTOMONOBUG
    CPalette* ppalOld  = SetBrushPalette( &m_dc, FALSE );
    COLORREF oldBkColor = m_dc.SetBkColor( transparentColor );
#endif  // COLORTOMONOBUG

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        m_maskDC.PatBlt( 0, 0, m_size.cx, m_size.cy, BLACKNESS );

        if (m_cRgnPolyFreeHandSel.GetSafeHandle())
            m_maskDC.FillRgn( &m_cRgnPolyFreeHandSel,
                            CBrush::FromHandle( (HBRUSH)::GetStockObject( WHITE_BRUSH ) ) );

        if (! m_bOpaque) // can't test true, since bitfield
#ifdef  COLORTOMONOBUG
            ColorToMonoBitBlt(&m_maskDC, 0, 0, m_size.cx, m_size.cy,
                &m_dc, 0, 0, DSna, transparentColor);
#else   // COLORTOMONOBUG
            m_maskDC.BitBlt( 0, 0, m_size.cx, m_size.cy, &m_dc, 0, 0, DSna );
#endif  // COLORTOMONOBUG
        }
    else
        {
#ifdef  COLORTOMONOBUG
        ColorToMonoBitBlt(&m_maskDC, 0, 0, m_size.cx, m_size.cy,
            &m_dc, 0, 0, NOTSRCCOPY, transparentColor);
#else   // COLORTOMONOBUG
        m_maskDC.BitBlt( 0, 0, m_size.cx, m_size.cy, &m_dc, 0, 0, NOTSRCCOPY );
#endif  // COLORTOMONOBUG
        }

#ifndef COLORTOMONOBUG
    m_dc.SetBkColor( oldBkColor );

    if (ppalOld)
        m_dc.SelectPalette( ppalOld, FALSE );
#endif  // COLORTOMONOBUG
    }


void GetMonoBltColors(HDC hDC, HBITMAP hBM, COLORREF& crNewBk, COLORREF& crNewText)
{
        crNewBk   = RGB(0xff, 0xff, 0xff);
        crNewText = RGB(0x00, 0x00, 0x00);

        RGBQUAD rq;
        if (GetDIBColorTable(hDC, 0, 1, &rq) == 1)
        {
                if (hBM == NULL)
                {
                        hBM = (HBITMAP) GetCurrentObject(hDC, OBJ_BITMAP);
                }

                WORD nMaxIndex = 0xff;

                BITMAP bm;
                if (GetObject(hBM, sizeof(bm), &bm))
                {
                        nMaxIndex = (1 << bm.bmBitsPixel) - 1;
                }

                crNewBk   = DIBINDEX(nMaxIndex);
                crNewText = DIBINDEX(0x00);
        }
}


// This handles drawing the brush with Draw Opaque turned off.
//
void CImgBrush::BltMatte(IMG* pimg, CPoint topLeft)
    {
        COLORREF crNewBk, crNewText;
        GetMonoBltColors(pimg->hDC, pimg->hBitmap, crNewBk, crNewText);

    COLORREF crOldBk = SetBkColor(pimg->hDC, crNewBk);
    COLORREF crOldText = SetTextColor(pimg->hDC, crNewText);
    CPalette* ppalOld = SetBrushPalette( &m_dc, FALSE ); // Background ??

    // Copying from a bitmap...

DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);
    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
          m_dc.m_hDC, 0, 0, DSx);
DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSna);
DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
          m_dc.m_hDC, 0, 0, DSx);
DebugShowBitmap(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy);

    if (ppalOld)
        m_dc.SelectPalette( ppalOld, FALSE ); // Background ??

    SetBkColor(pimg->hDC, crOldBk);
    SetTextColor(pimg->hDC, crOldText);
    }

// This handles drawing the brush with Draw Opaque turned on.
//
void CImgBrush::BltReplace(IMG* pimg, CPoint topLeft)
    {
    int iToolID =  CImgTool::GetCurrentID();

    if (iToolID == IDMB_PICKRGNTOOL)
        {
        BltMatte( pimg, topLeft );
        }
    else
        {
        CPalette* ppalOld = SetBrushPalette( &m_dc, FALSE ); // Background ??

        BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
               m_dc.m_hDC, 0, 0, SRCCOPY);

        if (ppalOld)
            m_dc.SelectPalette( ppalOld, FALSE ); // Background ??
        }
    }


// This handles erasing with the brush (draws mask in solid color).
//
void CImgBrush::BltColor(IMG* pimg, CPoint topLeft, COLORREF color)
    {
    COLORREF crOldBk = SetBkColor(pimg->hDC, color);
    COLORREF crOldText = SetTextColor(pimg->hDC, RGB(0, 0, 0));

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSx);

    SetBkColor(pimg->hDC, RGB(255, 255, 255));

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSna);

    SetBkColor(pimg->hDC, color);

    BitBlt(pimg->hDC, topLeft.x, topLeft.y, m_size.cx, m_size.cy,
      m_maskDC.m_hDC, 0, 0, DSx);

    SetTextColor(pimg->hDC, crOldText);
    SetBkColor(pimg->hDC, crOldBk);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgdlgs.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "docking.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "colorsrc.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "cmpmsg.h"
#include "imgdlgs.h"
#include "ferr.h"

#include <colordlg.h>
#include <direct.h>

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

CSize NEAR g_defaultTileGridSize(16, 15);
BOOL  NEAR g_bDefaultTileGrid = FALSE;


BEGIN_MESSAGE_MAP(C3dDialog, CDialog)
    ON_COMMAND(IDOK, OnRobustOK)
    ON_WM_CTLCOLOR()
END_MESSAGE_MAP()

C3dDialog::C3dDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
          : CDialog(lpszTemplateName, pParentWnd)
    {
    }

C3dDialog::C3dDialog(UINT nTemplateID, CWnd* pParentWnd)
          : CDialog(nTemplateID, pParentWnd)
    {
    }


BOOL C3dDialog::OnInitDialog()
    {
    // automatically center the dialog relative to it's parent
    CenterWindow(CmpCenterParent());

    return CDialog::OnInitDialog();
    }

void C3dDialog::OnRobustOK()
    {
    OnOK(); // ok to call "real" OnOK
    }

HBRUSH C3dDialog::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
    {
    HBRUSH hbrush = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

    return hbrush;
    }

BEGIN_MESSAGE_MAP(CImgGridDlg, C3dDialog)
    ON_BN_CLICKED(IDC_PIXELGRID, OnClickPixelGrid)
    ON_BN_CLICKED(IDC_TILEGRID, OnClickTileGrid)
END_MESSAGE_MAP()


CImgGridDlg::CImgGridDlg() : C3dDialog(IDD_IMGGRIDOPT)
    {
    m_bPixelGrid = theApp.m_bShowGrid;
    m_bTileGrid  = g_bDefaultTileGrid;
    m_nWidth     = g_defaultTileGridSize.cx;
    m_nHeight    = g_defaultTileGridSize.cy;
    }


BOOL CImgGridDlg::OnInitDialog()
    {
    C3dDialog::OnInitDialog();

    CheckDlgButton(IDC_PIXELGRID, m_bPixelGrid);
    CheckDlgButton(IDC_TILEGRID, m_bTileGrid);
    SetDlgItemInt(IDC_WIDTH, m_nWidth, FALSE);
    SetDlgItemInt(IDC_HEIGHT, m_nHeight, FALSE);

    GetDlgItem(IDC_TILEGRID)->EnableWindow(m_bPixelGrid);
    GetDlgItem(IDC_WIDTH)->EnableWindow(m_bPixelGrid && m_bTileGrid);
    GetDlgItem(IDC_HEIGHT)->EnableWindow(m_bPixelGrid && m_bTileGrid);

    return TRUE;
    }


void CImgGridDlg::OnClickPixelGrid()
    {
    m_bPixelGrid = !m_bPixelGrid;
    CheckDlgButton(IDC_PIXELGRID, m_bPixelGrid);

    GetDlgItem(IDC_TILEGRID)->EnableWindow(m_bPixelGrid);
    GetDlgItem(IDC_WIDTH)->EnableWindow(m_bPixelGrid);
    GetDlgItem(IDC_HEIGHT)->EnableWindow(m_bPixelGrid);
    }


void CImgGridDlg::OnClickTileGrid()
    {
    m_bTileGrid = !m_bTileGrid;
    CheckDlgButton(IDC_TILEGRID, m_bTileGrid);

    GetDlgItem(IDC_WIDTH)->EnableWindow(m_bTileGrid);
    GetDlgItem(IDC_HEIGHT)->EnableWindow(m_bTileGrid);
    }

void CImgGridDlg::OnOK()
    {
    m_bPixelGrid = IsDlgButtonChecked(IDC_PIXELGRID);
    m_bTileGrid = IsDlgButtonChecked(IDC_TILEGRID);

    if (m_bTileGrid)
        {
        BOOL bTranslated;

        if (GetDlgItem(IDC_WIDTH)->GetWindowTextLength() == 0)
            {
            m_nWidth = 1;
            }
        else
            {
            m_nWidth = GetDlgItemInt(IDC_WIDTH, &bTranslated, FALSE);
            if (!bTranslated || m_nWidth < GRIDMIN || m_nWidth > GRIDMAX)
                {
                CmpMessageBoxPrintf(IDS_ERROR_GRIDRANGE, AFX_IDS_APP_TITLE,
                    MB_OK | MB_ICONEXCLAMATION, GRIDMIN, GRIDMAX);      // LOCALIZATION
                GetDlgItem(IDC_WIDTH)->SetFocus();
                return;
                }
            }

        if (GetDlgItem(IDC_HEIGHT)->GetWindowTextLength() == 0)
            {
            m_nHeight = 1;
            }
        else
            {
            m_nHeight = GetDlgItemInt(IDC_HEIGHT, &bTranslated, FALSE);
            if (!bTranslated || m_nHeight < GRIDMIN || m_nHeight > GRIDMAX)
                {
                CmpMessageBoxPrintf(IDS_ERROR_GRIDRANGE, AFX_IDS_APP_TITLE,
                    MB_OK | MB_ICONEXCLAMATION, GRIDMIN, GRIDMAX);      // LOCALIZATION
                GetDlgItem(IDC_HEIGHT)->SetFocus();
                return;
                }
            }

        g_defaultTileGridSize.cx = m_nWidth;
        g_defaultTileGridSize.cy = m_nHeight;
        }

    g_bDefaultTileGrid = m_bTileGrid;

    C3dDialog::OnOK();
    }


/***************************************************************************/
// CColorTable dialog

CColorTable::CColorTable( CWnd* pParent /*=NULL*/ )
            : CDialog( CColorTable::IDD, pParent )
    {
    m_bLeft  = TRUE;
    m_iColor = 0;
    }

/***************************************************************************/

void CColorTable::DoDataExchange( CDataExchange* pDX )
    {
        CDialog::DoDataExchange( pDX );
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CColorTable, CDialog)
    //{{AFX_MSG_MAP(CColorTable)
    ON_WM_DRAWITEM()
    ON_WM_MEASUREITEM()
    ON_LBN_DBLCLK(IDC_COLORLIST, OnDblclkColorlist)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/***************************************************************************/
// CColorTable message handlers

void CColorTable::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    if ((int) lpDrawItemStruct->itemID >= 0)
        {
        CDC       dcCombo;
        CBrush    brColor;
        CPalette* pPalOld = NULL;
        CRect     rect    = lpDrawItemStruct->rcItem;

        dcCombo.Attach( lpDrawItemStruct->hDC );

        if (theApp.m_pPalette)
            {
            pPalOld = dcCombo.SelectPalette( theApp.m_pPalette, FALSE );
            dcCombo.RealizePalette();
            }

        brColor.CreateSolidBrush( (COLORREF)lpDrawItemStruct->itemData );

        if ((lpDrawItemStruct->itemState & ODS_SELECTED) == ODS_SELECTED)
            {
            dcCombo.FillRect( &(lpDrawItemStruct->rcItem), &brColor );
            rect.InflateRect( -theApp.m_cxFrame, -theApp.m_cyFrame );
            }

        dcCombo.FillRect( &(lpDrawItemStruct->rcItem), &brColor );

        brColor.DeleteObject();

        if ((lpDrawItemStruct->itemState & ODS_FOCUS) == ODS_FOCUS)
            dcCombo.DrawFocusRect( &(lpDrawItemStruct->rcItem) );

        if (pPalOld != NULL)
            dcCombo.SelectPalette( pPalOld, FALSE );
        }

    CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
    }

/***************************************************************************/

BOOL CColorTable::OnInitDialog()
    {
    CDialog::OnInitDialog();

    int iColorCnt   = g_pColors->GetColorCount();
    CListBox* pList = (CListBox*)GetDlgItem( IDC_COLORLIST );

    for (int iLoop = 0; iLoop < iColorCnt; iLoop++)
        {
        pList->AddString( TEXT("") );
        pList->SetItemData( iLoop, g_pColors->GetColor( iLoop ) );
        }


    return TRUE;  // return TRUE  unless you set the focus to a control
    }

/***************************************************************************/

void CColorTable::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
    {
    lpMeasureItemStruct->itemHeight = theApp.m_cyCaption;

    CDialog::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
    }

/***************************************************************************/

void CColorTable::OnDblclkColorlist()
    {


    }

/***************************************************************************/

void CColorTable::OnOK()
    {
//  m_iColor = ;

        CDialog::OnOK();
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgfile.cpp ===
// File import/export for icons, cursors, and bitmaps

#include "stdafx.h"

#include <direct.h>
#include <sys\stat.h>

#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgfile.h"
#include "ferr.h"
#include "cmpmsg.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

// base for temp file names
const TCHAR BASED_CODE CFileSaver::c_szAps [] = TEXT("TMP");

/***************************************************************************/

BOOL FileExists(const TCHAR* szFileName)
    {
    CFileStatus fs;
    return CFile::GetStatus(szFileName, fs) != 0;
    }

/***************************************************************************/

BOOL RenameFile(const TCHAR* szOldName, const TCHAR* szNewName)
    {
    TRACE2("RenameFile: \"%s\" to \"%s\"\n", szOldName, szNewName);

    TRY
        {
        if (FileExists(szNewName))
            CFile::Remove(szNewName);
        CFile::Rename(szOldName, szNewName);
        }
    CATCH(CFileException, e)
        {
        TRACE(TEXT("Rename failed!\n"));
        theApp.SetFileError( IDS_ERROR_EXPORT, e->m_cause );
        return FALSE;
        }
    END_CATCH

    return TRUE;
    }

/***************************************************************************/

CFileSaver::CFileSaver(const TCHAR* szFileName)
    {
    CString strDir = StripName(szFileName);
    CString strTempDir;

    GetTempPath( _MAX_PATH, strTempDir.GetBuffer( _MAX_PATH ) );

    strTempDir.ReleaseBuffer();

    GetTempFileName( strTempDir, c_szAps, 0, m_strTempName.GetBuffer( _MAX_PATH ));
    GetTempFileName( strTempDir, c_szAps, 0, m_strBackupName.GetBuffer( _MAX_PATH ));

    CFile::Remove( m_strTempName );
    CFile::Remove( m_strBackupName );

    m_strName = szFileName;
    m_strTempName = strDir + StripPath( m_strTempName );
    m_strBackupName = strDir + StripPath( m_strBackupName );
    }

/***************************************************************************/

CFileSaver::~CFileSaver()
    {
    if (FileExists(m_strTempName))
        CFile::Remove(m_strTempName);

    if (FileExists(m_strBackupName))
        CFile::Remove(m_strBackupName);
    }

/***************************************************************************/

BOOL CFileSaver::CanSave() const
    {
    CFileStatus fs;

    if ( CFile::GetStatus(m_strName, fs) != 0 )
                {
                if ((fs.m_attribute & CFile::readOnly) != 0)
                {
                theApp.SetFileError( IDS_ERROR_SAVE, ferrCantSaveReadOnly);
                return FALSE;
                }
                }

    return TRUE;
    }

/***************************************************************************/

BOOL CFileSaver::Finish()
    {
    if (FileExists(m_strName) != 0)
        {
        if (!RenameFile(m_strName, m_strBackupName))
            {
            CFile::Remove(m_strTempName);
            return FALSE;
            }
        }
    else
        {
        // no backup was made since the "original" didn't exists,
        // wipe out the name so we don't delete the file later...

        m_strBackupName.Empty();
        }

    if (!RenameFile(m_strTempName, m_strName))
        {
        if (!m_strBackupName.IsEmpty() &&
            RenameFile(m_strBackupName, m_strName))
            {
            CFile::Remove(m_strTempName);
            }

        return FALSE;
        }

    if (!m_strBackupName.IsEmpty())
        CFile::Remove(m_strBackupName);

    return TRUE;
    }

/***************************************************************************/
/* strrchrs() -- find the last instance in a string of any one of
**  a set of characters.  Return a pointer into the string at
**  the matchpoint.  Analogous to strrchr() in the CRT.
*/

TCHAR *strrchrs(TCHAR *szText, TCHAR * szSSet)
    {
    register TCHAR *pchSSet;
    register TCHAR *pchStep;
    register TCHAR *pchLast = NULL;

    if ((NULL == szText) || (NULL == szSSet))
        return NULL;
    for (pchStep = szText; TEXT('\0') != *pchStep; pchStep = CharNext(pchStep))
        for (pchSSet = szSSet; TEXT('\0') != *pchSSet; pchSSet = CharNext(pchSSet))
            if ((pchSSet[0] == pchStep[0]) && (
               #ifndef UNICODE
                !IsDBCSLeadByte((CHAR)pchSSet[0]) ||
               #endif // UNICODE
               (pchSSet[1] == pchStep[1])))
                    pchLast = pchStep;
    return pchLast;
    }

/***************************************************************************/
/* MkPath() -- Make any directories necessary to ensure that a
**  directory name passed in exists.  Essentially, if the
**  argument exists and is a directory, return success.  If
**  not, strip off the last path component and recurse,
**  creating the directories on returning up the stack.
*/
int MkPath(TCHAR *szPath)
    {
    TCHAR *pchSlash;
    TCHAR chSep;
    DWORD dwAtts;

    //Does it exist?
    if ( (dwAtts = GetFileAttributes(szPath)) & FILE_ATTRIBUTE_DIRECTORY )
        {
        return 0;
        }
    else if (-1 != dwAtts)
        {
        return -1;
        }

    //Can we create it?
    else
        {
        if ( CreateDirectory(szPath, NULL))
            return 0;
        // are we out of path components?
        else
            {
            if (NULL == (pchSlash = strrchrs(szPath, TEXT("\\/"))))
                return -1;
            // Can we make its parent directory?
            else
                                {
                if ((chSep = *pchSlash), (*pchSlash = TEXT('\0')), MkPath(szPath))
                    {
                    #ifndef DEBUG
                    *pchSlash = chSep;
                    #endif
                    return -1;
                    }
                // Can we make it now that we've made its parent?
                else
                                        {
                    if ((*pchSlash = chSep), (TEXT('\0') != pchSlash[1]))
                        {
                        if (!CreateDirectory (szPath, NULL))
                        {
                           return -1;
                        }
                        return 0;
                        }
                    else //don't try trailing slash
                        return 0;
                                        }
                                }
                        }
                }
    }

/***************************************************************************/

void MkFullPath(CString& strFullPath, const CString& strRelPath,
    BOOL bPathOnly)
    {
    strFullPath.Empty();

    ASSERT(strRelPath.GetLength() > 0);
    if (strRelPath[0] != TEXT('\\') &&
        (strRelPath.GetLength() <= 1 || (
        #ifndef UNICODE
        !IsDBCSLeadByte((CHAR)strRelPath[0]) &&
        #endif // UNICODE
         strRelPath[1] != TEXT(':'))))
        {
        CHAR *szPathName = _getdcwd(0, NULL, 1);
        #ifdef UNICODE
        WCHAR *szPW = new WCHAR[lstrlenA (szPathName)+1];
        AtoW (szPathName, szPW);
        strFullPath = szPW;
        delete [] szPW;
        #else
        strFullPath = szPathName;
        #endif //UNICODE
        free(szPathName);

        if (strFullPath.Right(1) != TEXT('\\'))
            strFullPath += (TCHAR)TEXT('\\');
        }

    if (bPathOnly)
        {
        int iLastSep = strRelPath.ReverseFind(TEXT('\\'));
        if (iLastSep == -1)
            iLastSep = strRelPath.GetLength();
        strFullPath += strRelPath.Left(iLastSep);
        }
    else
        {
        strFullPath += strRelPath;
        }
    }

/***************************************************************************/

BOOL OpenSubFile(CFile& file, const CFileSaver& saver, UINT nOpenFlags,
                CFileException* pError)
    {
    BOOL bResult = file.Open(saver.GetSafeName(), nOpenFlags, pError);

    if (!bResult && (pError->m_cause == CFileException::badPath ||
            pError->m_cause == CFileException::accessDenied))
        {
        CString strFileName = saver.GetRealName();
        CString strPathName;

        MkFullPath(strPathName, strFileName, TRUE);
        strPathName.MakeUpper();

        // suppress the message box upon return, but keep error info!
        // (ie. user only needs one message box)
        pError->m_cause = -pError->m_cause;

        strFileName.MakeUpper();
        int nResult = CmpMessageBoxPrintf(IDS_QUERY_MKDIR, AFX_IDS_APP_TITLE,
            MB_YESNO | MB_ICONQUESTION,
            (LPCTSTR)strPathName, (LPCTSTR) strFileName);
        if (nResult == IDYES)
            {
            MkPath(strPathName.GetBuffer(strPathName.GetLength()));
            strPathName.ReleaseBuffer();
            bResult = file.Open(saver.GetSafeName(), nOpenFlags, pError);
            }
        }

    return bResult;
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgdlgs.h ===
#ifndef __IMGDLGS_H__
#define __IMGDLGS_H__

#define GRIDMIN     1           // Minimum grid coordinate value
#define GRIDMAX     1024        // Maximum grid coordinate value

// All App Studio dialog boxes should derive from this class...
//
class C3dDialog : public CDialog
    {
    public:

    C3dDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    C3dDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnRobustOK();

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
// CColorTable dialog

class CColorTable : public CDialog
    {
    // Construction
    public:

    CColorTable(CWnd* pParent = NULL);    // standard constructor

	enum { IDD = IDD_COLORTABLE };

    void SetLeftFlag( BOOL bLeft) { m_bLeft = bLeft; }
    void SetColorIndex( int iColor ) { m_iColor = iColor; }
    int  GetColorIndex() { return m_iColor; }

    // Implementation

    protected:

    BOOL m_bLeft;
    int  m_iColor;

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CColorTable)
    afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual BOOL OnInitDialog();
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg void OnDblclkColorlist();
    virtual void OnOK();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/

class CImgGridDlg : public C3dDialog
    {
    public:

    CImgGridDlg();

    BOOL OnInitDialog();
    void OnOK();
    void OnClickPixelGrid();
    void OnClickTileGrid();

    BOOL m_bPixelGrid;
    BOOL m_bTileGrid;
    int m_nWidth;
    int m_nHeight;

    DECLARE_MESSAGE_MAP()
    };

extern CSize NEAR g_defaultTileGridSize;
extern BOOL  NEAR g_bDefaultTileGrid;

#endif // __IMGDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgsuprt.h ===
#ifndef __IMGSUPRT_H__
#define __IMGSUPRT_H__

#define MAX_PALETTE_COLORS 256

#define WM_CANCEL WM_USER + 0

// Brush Shapes
#define roundBrush          0
#define squareBrush         1
#define slantedLeftBrush    2
#define slantedRightBrush   3


// Combine Modes
#define combineColor        0
#define combineMatte        1
#define combineReplace      2


// Non-standard Raster Ops
#define DSx                 0x00660046L
#define DSa                 0x008800C6L
#define DSna                0x00220326L
#define DSPao               0x00ea02e9L
#define DSo                 0x00ee0086L
#define DSno                0x00bb0226L
#define DSPDxax             0x00e20746L
#define SPxn                0x00c3006aL

// Indices of the screen and inverse colors in color table.
#define IDScreen    -1
#define IDInvScreen -2

// NOTE: These structures mirror the LOGPALETTE structure in WINDOWS.H

struct LOGPALETTE16
    {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[16];
    };


struct LOGPALETTE256
    {
    WORD         palVersion;
    WORD         palNumEntries;
    PALETTEENTRY palPalEntry[MAX_PALETTE_COLORS];
    };

// Note: this bogus structure is not my fault!  It's stolen from
// the old Windows SDK ImagEdit program...
#pragma pack(1)

struct COLORFILEHEADER
    {
    char  tag; // this is a 'C'
    short colors;
    char  reserved[47]; // fill with 0
    // DWORD rgrgb [colors];
    };

#pragma pack()

/*************************************************************************/

//extern int FileTypeFromExtension( const TCHAR FAR* lpcExt );

void InitCustomData();          // see customiz.cpp
void CustomExit();

class CImgWnd;

// IMGSUPRT.CPP

extern IMG*     CreateImg          (int cxWidth, int cyHeight,
                                    int cPlanes, int cBitCount, 
                                    int cXPelsPerMeter, int cYPelsPerMeter,
                                    BOOL bPalette = TRUE );
extern void     SelectImg          (IMG* pImg);
extern BOOL     ClearImg           (IMG* pImg);
extern void     FreeImg            (IMG* pImg);
extern void     DirtyImg           (IMG* pImg);
extern void     AddImgWnd          (IMG* pImg, CImgWnd* pImgWnd);
extern BOOL     UpdateCurIcoImg    (IMG* pImg);
extern BOOL     ChangeICBackground (IMG* pImg, COLORREF rgbNewScr);
extern BOOL     SetImgSize         (IMG* pImg, CSize newSize, BOOL bStretch);
extern void     GetImgSize         (IMG* pImg, CSize& size);
extern BOOL     ReplaceImgPalette  (IMG* pImg, LPLOGPALETTE lpLogPal);
extern int      AddNewColor        (IMG* pImg,  COLORREF crNew );

// IMGED.CPP
extern void     Draw3dRect         (HDC hDC, RECT* prc);

// DRAW.CPP
extern void     InvalImgRect       (IMG* pImg, CRect* prc);
extern void     CommitImgRect      (IMG* pImg, CRect* prc);
extern void     FixRect            (RECT* prc);
extern void     StandardiseCoords  (CPoint* s, CPoint* e);
extern void     DrawBrush          (IMG* pImg, CPoint pt, BOOL bDraw);
extern void     HideBrush          ();
extern void     SetCombineMode     (int wNewCombineMode);
extern BOOL     SetupRubber        (IMG* pImg);
extern void     PolyTo             (CDC* pDC, CPoint fromPt,
                                              CPoint toPt, CSize size);
extern BOOL     GetTanPt           (CSize size, CPoint delta, CRect& tan);

extern void     SetDrawColor       (COLORREF cr);
extern void     SetEraseColor      (COLORREF cr);
extern void     SetTransColor      (COLORREF cr);
extern void     SetDrawColor       (int iColor);
extern void     SetEraseColor      (int iColor);
extern void     SetTransColor      (int iColor);
extern void     InvalColorWnd      ();
extern BOOL     SetUndo            (IMG* pImg);
extern void     SetLeftColor       (int nColor);
extern void     SetRightColor      (int nColor);
extern void     CommitSelection    (BOOL bSetUndo);
extern void     PickupSelection    ();

extern BOOL     EnsureUndoSize     (IMG* pimg);

extern void     CleanupImages   ();
extern void     CleanupImgRubber();
extern void     CleanupImgUndo  ();

extern IMG*      pImgCur;

#define TRANS_COLOR_NONE 0x87654321 // undefined

extern BOOL      fDraggingBrush;
extern BOOL      g_bCustomBrush;
extern BOOL      g_bDriverCanStretch;
extern BOOL      g_bUseTrans;

extern int       theLeft;
extern int       theRight;
extern int       theTrans;
extern COLORREF  crLeft;
extern COLORREF  crRight;
extern COLORREF  crTrans;
extern int       wCombineMode;

struct DINFO
    {
    TCHAR* m_szDesc;
    UINT  m_nColors;
    SIZE  m_size;
    };

extern COLORREF  std2Colors[];

extern CPalette* GetStd256Palette();
extern CPalette* GetStd16Palette();
extern CPalette* GetStd2Palette();
extern CPalette* PaletteFromDS(HDC hdc);

#define IS_WIN30_DIB(lpbi) ((*(LPDWORD)(lpbi)) >= sizeof (BITMAPINFOHEADER))

extern WORD      DIBNumColors      ( LPSTR lpbi, BOOL bJustUsed=TRUE );
extern DWORD     DIBWidth          ( LPSTR lpDIB );
extern DWORD     DIBHeight         ( LPSTR lpDIB );
extern CPalette* CreateDIBPalette  ( LPSTR lpbi );
extern HBITMAP   DIBToBitmap       ( LPSTR lpDIBHdr, CPalette* pPal, HDC hdc = NULL );
extern HBITMAP   DIBToDS           ( LPSTR lpDIBHdr, DWORD dwOffBits, HDC hdc );
extern HGLOBAL   DibFromBitmap     ( HBITMAP hBitmap, DWORD dwStyle, WORD wBits,
                                     CPalette* pPal, HBITMAP hMaskBitmap, DWORD& dwSize, 
                                     LONG cXPelsPerMeter, LONG cYPelsPerMeter );
extern LPSTR     FindDIBBits       ( LPSTR lpbi, DWORD dwOffBits = 0 );
extern WORD      PaletteSize       ( LPSTR lpbi );
extern void      FreeDib           ( HGLOBAL hDib );
extern CPalette* CreatePalette     ( const COLORREF* colors, int nColors );
extern CPalette* MergePalettes     ( CPalette *pPal1, CPalette *pPal2, int& iAdds );
extern void      AdjustPointForGrid( CPoint *ptPointLocation );

// drawing support functions
extern void      StretchCopy (HDC, int, int, int, int, HDC, int, int, int, int);
extern void      FillImgRect (HDC hDC, CRect * prc, COLORREF cr );
extern void      BrushLine   (CDC* pDC, CPoint fromPt, CPoint toPt,
                             int nWidth, int nShape);
extern void      DrawDCLine  (HDC hDC, CPoint pt1, CPoint pt2,
                              COLORREF color, int nWidth, int nShape,
                              CRect& rc);
extern void      DrawImgLine (IMG* pimg, CPoint pt1, CPoint pt2,
                              COLORREF color, int nWidth, int nShape,
                              BOOL bCommit);
extern void      Mylipse     (HDC hDC, int x1, int y1, int x2, int y2, BOOL bFilled);

// PATSTENCIL:
// This is a ternary raster operation, listed in the SDK ref as "PSDPxax",
// but I prefer to think of it as "DSaPSnao".  More practically, this rop
// is useful to apply the color of the current brush to only those pixels
// where the source bitmap is zero (black).  That is, a binary bitmap as the
// source will be drawn onto the destination in the color of the current
// brush.
//
#define PATSTENCIL 0xB8074AL

// DrawBitmap:
// This draws a bitmap on a display context with a given raster operation.
//   CDC* dc         The target display context.
//   CBitmap* bmSrc  The bitmap to be drawn.
//   CRect* rc       A position rectangle.
//                   If NULL, bitmap drawn with the upper-left at 0, 0.
//                   Otherwise, bitmap drawn centered in this rectangle.
//                   Result is not clipped to the rectangle.
//   DWORD dwROP     Raster operation.  See table 11.3 of the Win30 SDK ref.
//   CDC* memdc      A memory context for the BitBlt process to use.
//                   If NULL, DrawBitmap creates and destroys its own.
//
void DrawBitmap(CDC* dc, CBitmap* bmSrc, CRect* rc,
                DWORD dwROP = SRCCOPY, CDC* memdc = NULL);

extern HDC       hRubberDC;
extern HBITMAP   hRubberBM;
extern HBITMAP   g_hUndoImgBitmap;
extern HPALETTE  g_hUndoPalette;
extern int       cxRubberWidth;
extern int       cyRubberHeight;
extern IMG*      pRubberImg;
extern WORD      gwClipboardFormat;
extern CBrush    g_brSelectHorz;
extern CBrush    g_brSelectVert;

CPalette *PBSelectPalette(CDC *pDC, CPalette *pPalette, BOOL bForceBk);

class CTempBitmap : public CBitmap
{
public:
        ~CTempBitmap() { DeleteObject(); } // DeleteObject checks for NULL
} ;

#endif // __IMGSUPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgtools.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "t_text.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "undo.h"
#include "props.h"
#include "colorsrc.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CImgTool, CObject)
IMPLEMENT_DYNAMIC(CRubberTool, CImgTool)
IMPLEMENT_DYNAMIC(CClosedFormTool, CRubberTool)
IMPLEMENT_DYNAMIC(CFreehandTool, CImgTool)
IMPLEMENT_DYNAMIC(CSketchTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CBrushTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CPencilTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CEraserTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CAirBrushTool, CFreehandTool)
IMPLEMENT_DYNAMIC(CLineTool, CRubberTool)
IMPLEMENT_DYNAMIC(CRectTool, CClosedFormTool)
IMPLEMENT_DYNAMIC(CRoundRectTool, CClosedFormTool)
IMPLEMENT_DYNAMIC(CEllipseTool, CClosedFormTool)
IMPLEMENT_DYNAMIC(CPickColorTool, CImgTool)
IMPLEMENT_DYNAMIC(CFloodTool, CImgTool)
IMPLEMENT_DYNAMIC(CSelectTool, CImgTool)
IMPLEMENT_DYNAMIC(CZoomTool, CImgTool)

#include "memtrace.h"

extern CRect  rcDragBrush;

extern HDC  hRubberDC;


BOOL  g_bBrushVisible;
BOOL  g_bPickingColor;
UINT  g_nStrokeWidth = 1;

/***************************************************************************/
//
// Drawing Tool Classes
//

CRectTool             g_rectTool;
CRoundRectTool        g_roundRectTool;
CEllipseTool          g_ellipseTool;
CLineTool             g_lineTool;
CSelectTool           g_selectTool;
CBrushTool            g_brushTool;
CSketchTool           g_sketchTool;
CPencilTool           g_pencilTool;
CEraserTool           g_eraserTool;
CAirBrushTool         g_airBrushTool;
CFloodTool            g_floodTool;
CPickColorTool        g_pickColorTool;
CZoomTool             g_zoomTool;

/***************************************************************************/

CImgTool*  CImgTool::c_pHeadImgTool     = NULL;
CImgTool*  CImgTool::c_pCurrentImgTool  = &g_pencilTool;
CImgTool*  CImgTool::c_pPreviousImgTool = &g_pencilTool;
BOOL       CImgTool::c_bDragging        = FALSE;
int        CImgTool::c_nHideCount       = 0;

/***************************************************************************/

CImgTool::CImgTool()
    {
    m_bUsesBrush          = FALSE;
    m_bIsUndoable         = TRUE;
    m_bCanBePrevTool      = TRUE;
    m_bToggleWithPrev     = FALSE;
    m_bFilled             = FALSE;
    m_bBorder             = TRUE;
    m_bMultPtOpInProgress = FALSE;
    m_eDrawDirection      = eFREEHAND;

    m_nStrokeWidth = 0;
    m_nStrokeShape = roundBrush;

    m_nCursorID = LOWORD(IDC_CROSSHAIR);
    m_nCmdID    = NULL;

    // Link into the list of tools...
    m_pNextImgTool = c_pHeadImgTool;
    c_pHeadImgTool = this;
    }

/******************************************************************************/

eDRAWCONSTRAINTDIRECTION CImgTool::DetermineDrawDirection(MTI *pmti)
    {
    eDRAWCONSTRAINTDIRECTION eDrawDirection;

    // 45 is dominant, test first
    if ( (pmti->pt.x > pmti->ptPrev.x) &&
         (pmti->pt.y > pmti->ptPrev.y) )
        {
            eDrawDirection = eSOUTH_EAST;
        }
    else
        {
        if ( (pmti->pt.x > pmti->ptPrev.x) &&
             (pmti->pt.y < pmti->ptPrev.y) )
            {
                eDrawDirection = eNORTH_EAST;
            }
        else
            {
            if ( (pmti->pt.x < pmti->ptPrev.x) &&
                 (pmti->pt.y > pmti->ptPrev.y) )
                {
                    eDrawDirection = eSOUTH_WEST;
                }
            else
                {
                if ( (pmti->pt.x < pmti->ptPrev.x) &&
                     (pmti->pt.y < pmti->ptPrev.y) )
                    {
                        eDrawDirection = eNORTH_WEST;
                    }
                else
                    {
                    // Horizontal is the next dominant, test before vertical
                    if (pmti->ptPrev.x != pmti->pt.x)
                        {
                        eDrawDirection = eEAST_WEST;
                        pmti->pt.y = pmti->ptPrev.y;
                        }
                    else
                        {
                        if (pmti->ptPrev.y != pmti->pt.y)
                            {
                            eDrawDirection = eNORTH_SOUTH;
                            pmti->pt.x = pmti->ptPrev.x;
                            }
                        else
                            {
                            // we should never fall into here, but in any case...
                            eDrawDirection = eFREEHAND;
                            }
                        }
                    }
                }
            }
        }
    return eDrawDirection;
    }

/******************************************************************************/

void CImgTool::AdjustPointsForConstraint(MTI *pmti)
    {
    }

/******************************************************************************/

void CImgTool::PreProcessPoints(MTI *pmti)
    {
    if (pmti != NULL)
        {
        if ((GetKeyState(VK_SHIFT) & 0x8000) != 0) //still in constrain mode
            {
            switch (m_eDrawDirection)
                {
                case eEAST_WEST:
                case eNORTH_SOUTH:
                case eNORTH_WEST:
                case eSOUTH_EAST:
                case eNORTH_EAST:
                case eSOUTH_WEST:
                     AdjustPointsForConstraint(pmti);
                     break;
                default: // not in constraint mode yet If shift down, check for
                         // mode and save mode else nothing.  Default is freehand
                     m_eDrawDirection = DetermineDrawDirection(pmti);
                     AdjustPointsForConstraint(pmti);
                    break;
                }
            }
        else
            {
            // shift not down
            m_eDrawDirection = eFREEHAND;
            }
        }
    }

/***************************************************************************/

void CImgTool::HideDragger(CImgWnd* pImgWnd)
    {
    ASSERT(c_pCurrentImgTool != NULL);

    if (c_nHideCount == 0)
        c_pCurrentImgTool->OnShowDragger(pImgWnd, FALSE);
    c_nHideCount++;
    }

/***************************************************************************/

void CImgTool::ShowDragger(CImgWnd* pImgWnd)
    {
    ASSERT(c_pCurrentImgTool != NULL);

    if (--c_nHideCount == 0)
        c_pCurrentImgTool->OnShowDragger(pImgWnd, TRUE);
    }

/***************************************************************************/

void CImgTool::Select(UINT nCmdID)
    {
    CImgTool* p = FromID(nCmdID);
    if (p)
        {
        p->Select();
        }
    }

/***************************************************************************/

void CImgTool::Select()
    {
    ASSERT(this != NULL);

    if (this == c_pCurrentImgTool && m_bToggleWithPrev)
        {
        SelectPrevious();
        return;
        }

    if (g_bCustomBrush)
        {
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);
        }

    HideBrush();

    if (c_pCurrentImgTool->m_bCanBePrevTool && c_pCurrentImgTool != this)
        c_pPreviousImgTool = c_pCurrentImgTool;

    // Make sure to Deactivate the old one BEFORE activating the new one, so
    // globals (like g_nStrokeWidth) get set correctly
    if (c_pCurrentImgTool != NULL)
        c_pCurrentImgTool->OnActivate(FALSE);

    c_pCurrentImgTool = this;

    OnActivate(TRUE);

    if (c_pCurrentImgTool != this)
        {
        // Some tools may give up activation...
        ASSERT(!m_bCanBePrevTool);
        return;
        }

    SetCombineMode(combineColor);

    if (g_pImgToolWnd)
    {
        g_pImgToolWnd->SelectTool( (WORD)m_nCmdID );

        if (g_pImgToolWnd->m_hWnd)
            g_pImgToolWnd->InvalidateOptions();
    }

    CImgWnd::SetToolCursor();
    }

/***************************************************************************/

CImgTool* CImgTool::FromID(UINT nCmdID)
    {
    CImgTool* pImgTool = c_pHeadImgTool;
    while (pImgTool != NULL && pImgTool->m_nCmdID != nCmdID)
        pImgTool = pImgTool->m_pNextImgTool;
    return pImgTool;
    }

/***************************************************************************/

void CImgTool::SetStrokeWidth(UINT nNewStrokeWidth)
    {
    if (nNewStrokeWidth == m_nStrokeWidth)
        return;

    HideBrush();
    g_bCustomBrush = FALSE;
    m_nStrokeWidth = nNewStrokeWidth;
    g_pImgToolWnd->InvalidateOptions();

    extern MTI  mti;

    if (mti.fLeft || mti.fRight)
        OnDrag(CImgWnd::GetCurrent(), &mti);
    }

/***************************************************************************/

void CImgTool::SetStrokeShape(UINT nNewStrokeShape)
    {
    if (m_nStrokeShape == nNewStrokeShape)
        return;

    HideBrush();
    g_bCustomBrush = FALSE;
    m_nStrokeShape = nNewStrokeShape;
    g_pImgToolWnd->InvalidateOptions(FALSE);
    }

/***************************************************************************/

void CImgTool::OnActivate(BOOL bActivate)
    {
    if (bActivate)
        OnShowDragger(CImgWnd::GetCurrent(), TRUE);
    }

/***************************************************************************/

void CImgTool::OnEnter(CImgWnd* pImgWnd, MTI* pmti)
    {
    // No default action
    }

/***************************************************************************/

void CImgTool::OnLeave(CImgWnd* pImgWnd, MTI* pmti)
    {
    // No default action
    }

/***************************************************************************/

void CImgTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShowDragger)
    {
    // No default action
    }

/***************************************************************************/

void CImgTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_bDragging = TRUE;
    }

/***************************************************************************/

void CImgTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_bDragging = FALSE;

    if (m_bIsUndoable)
        DirtyImg(pImgWnd->m_pImg);
    }

/***************************************************************************/

void CImgTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    ASSERT(c_bDragging);
    }

/***************************************************************************/

void CImgTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
//   ASSERT(!c_bDragging);

    if (UsesBrush())
        {
        fDraggingBrush = TRUE;
        pImgWnd->ShowBrush(pmti->pt);
        }

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CImgTool::OnTimer(CImgWnd* pImgWnd, MTI* pmti)
    {
    // Tools should not have started a timer unless it overrides this!
    ASSERT(FALSE);
    }

/***************************************************************************/

void CImgTool::OnCancel(CImgWnd* pImgWnd)
    {
    c_bDragging = FALSE;
    }

/***************************************************************************/

void CImgTool::OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                        const CRect& optionsRect)
    {
    }

/***************************************************************************/

void CImgTool::PaintStdPattern(CDC* pDC, const CRect& paintRect,
                                         const CRect& optionsRect)
    {
    CBrush brush;
    CPalette *pcPaletteOld = NULL;
    CPalette *pcPaletteOld2 = NULL;

    CDC dc;
    if (!dc.CreateCompatibleDC(pDC))
        return;

    CBitmap bitmap, * pOldBitmap;
    if (!bitmap.CreateCompatibleBitmap(pDC, 8, 8))
        return;

    pOldBitmap = dc.SelectObject(&bitmap);

    if (theApp.m_pPalette)
        {
        pcPaletteOld = pDC->SelectPalette( theApp.m_pPalette, FALSE );
        pDC->RealizePalette();

        pcPaletteOld2 = dc.SelectPalette( theApp.m_pPalette, FALSE );
        dc.RealizePalette();
        }

    CBrush* pOldBrush = NULL;

    COLORREF rgb = crLeft;

    if (pImgCur->m_pBitmapObj->m_nColors == 0)
        {
        BOOL MonoRect(CDC* pDC, const CRect& rect, COLORREF rgb, BOOL bFrame);
        MonoRect(&dc, CRect(0, 0, 9, 9), rgb, FALSE);
        }
    else
        {
        brush.CreateSolidBrush(rgb);
        pOldBrush = dc.SelectObject(&brush);
        dc.PatBlt(0, 0, 8, 8, PATCOPY);
        dc.SelectObject(pOldBrush);
        brush.DeleteObject();
        }


    // Draw a black grid...
    for (int i = 0; i < 9; i++)
        {
        pDC->PatBlt(optionsRect.left + 2 + i * 7, optionsRect.top + 3,
            1, 8 * 7 + 1, BLACKNESS);
        pDC->PatBlt(optionsRect.left + 2, optionsRect.top + 3 + i * 7,
            8 * 7 + 1, 1, BLACKNESS);
        }


    // Fill in the boxes...
    COLORREF curColor = (COLORREF)0xffffffff;

    for (int y = 0; y < 8; y++)
        {
        for (int x = 0; x < 8; x++)
            {
            COLORREF color = dc.GetPixel(x, y) | 0x02000000L;

            if (color != curColor)
                {
                if (pOldBrush != NULL)
                    pDC->SelectObject(pOldBrush);

                brush.DeleteObject();
                brush.CreateSolidBrush(color);

                pOldBrush = pDC->SelectObject(&brush);
                curColor = color;
                }

            pDC->PatBlt(optionsRect.left + 2 + 1 + x * 7,
                        optionsRect.top  + 3 + 1 + y * 7, 6, 6, PATCOPY);
            }
        }

    ASSERT(pOldBrush != NULL);
    pDC->SelectObject(pOldBrush);

    dc.SelectObject(pOldBitmap);

    if (pcPaletteOld)
        pDC->SelectPalette(pcPaletteOld, FALSE);

    if (pcPaletteOld2)
        dc.SelectPalette(pcPaletteOld2, FALSE);
    }

/***************************************************************************/

void CImgTool::ClickStdPattern(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    CImgTool::OnClickOptions(pWnd, optionsRect, clickPoint);
    }

/***************************************************************************/

void CImgTool::PaintStdBrushes(CDC* pDC, const CRect& paintRect,
                                         const CRect& optionsRect)
    {
    int cxBrush = optionsRect.Width() / 3;
    int cyBrush = optionsRect.Height() / 4;

    for (UINT nBrushShape = 0; nBrushShape < 4; nBrushShape++)
        {
        int x = 0;
        for (UINT nStrokeWidth = 8 - (nBrushShape == 0);
            (int)nStrokeWidth > 0; nStrokeWidth -= 3, x += cxBrush)
            {
            CRect rect;
            rect.left = optionsRect.left + x;
            rect.top = optionsRect.top + cyBrush * nBrushShape;
            rect.right = rect.left + cxBrush;
            rect.bottom = rect.top + cyBrush;
            rect.InflateRect(-3, -3);

            if ((paintRect & rect).IsRectEmpty())
                continue;

            BOOL bCur = (nStrokeWidth == m_nStrokeWidth
                       && nBrushShape == m_nStrokeShape);

            CBrush* pOldBrush = pDC->SelectObject(GetSysBrush(bCur ?
                                        COLOR_HIGHLIGHT : COLOR_BTNFACE));
            if ((nStrokeWidth & 1) != 0)
                {
                // Adjust hilight rect so brush will be centered
                rect.right -= 1;
                rect.bottom -= 1;
                }
            pDC->PatBlt(rect.left + 1, rect.top - 1,
                rect.Width() - 2, rect.Height() + 2, PATCOPY);
            pDC->SelectObject(pOldBrush);

            CPoint pt(optionsRect.left + (cxBrush - nStrokeWidth) / 2 + x,
                      optionsRect.top +
                      (cyBrush - nStrokeWidth) / 2 + nBrushShape * cyBrush);

            pOldBrush = pDC->SelectObject(GetSysBrush(bCur ?
                                      COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
            BrushLine(pDC, pt, pt, nStrokeWidth, nBrushShape);
            pDC->SelectObject(pOldBrush);
            }
        }
    }

/***************************************************************************/

void CImgTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    MessageBeep(0);
    }

/******************************************************************************/

void CImgTool::OnUpdateColors (CImgWnd* pImgWnd)
    {
    }

/******************************************************************************/

BOOL CImgTool::CanEndMultiptOperation(MTI* pmti )
    {
    return (! m_bMultPtOpInProgress);  // if not in progress (FALSE) => can end (TRUE)
    }

/******************************************************************************/

void CImgTool::EndMultiptOperation(BOOL bAbort)
    {
    m_bMultPtOpInProgress = FALSE;
    }

/******************************************************************************/

BOOL CImgTool::IsToolModal(void)
{
        return(IsDragging() || m_bMultPtOpInProgress || m_bToggleWithPrev);
}

/******************************************************************************/

BOOL CImgTool::IsUndoable()
    {
    if (m_bMultPtOpInProgress)
        {
        return FALSE;  // cannot undo in the middle of a multi-point operation.
        }
    else
        {
        return m_bIsUndoable;
        }
    }

/******************************************************************************/

void CImgTool::ClickStdBrushes(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    HideBrush();

    g_bCustomBrush = FALSE;
    m_nStrokeWidth = 2 + 3 * (2 - (clickPoint.x / (optionsRect.Width() / 3)));
    m_nStrokeShape = clickPoint.y / (optionsRect.Height() / 4);

    if (m_nStrokeShape == 0)
        m_nStrokeWidth -= 1;

    pWnd->InvalidateOptions(FALSE);
    }

/******************************************************************************/

UINT CImgTool::GetCursorID()
    {
    return m_nCursorID;
    }

/******************************************************************************/

CRect  CRubberTool::rcPrev;
// UINT       CRubberTool::m_nStrokeWidth;

CRubberTool::CRubberTool()
    {
    }

/******************************************************************************/

void CRubberTool::OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                           const CRect& optionsRect)
    {
    if (m_bFilled)
        {
        PaintStdPattern(pDC, paintRect, optionsRect);
        return;
        }

    #define nLineWidths 5

    int cyEach = (optionsRect.Height() - 4) / nLineWidths;

    for (int i = 0; i < nLineWidths; i++)
        {
        UINT cyHeight = i + 1;

        CBrush* pOldBrush;
        BOOL bCur = (cyHeight == GetStrokeWidth());

        pOldBrush = pDC->SelectObject( GetSysBrush(bCur ?
                                       COLOR_HIGHLIGHT : COLOR_BTNFACE));
        pDC->PatBlt(optionsRect.left + 2,
                    optionsRect.top  + 3 + i * cyEach,
                    optionsRect.Width() - 4, cyEach - 2, PATCOPY);
        pDC->SelectObject(pOldBrush);

        pOldBrush = pDC->SelectObject(GetSysBrush(bCur ?
                                      COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
        pDC->PatBlt(optionsRect.left + 6,
                    optionsRect.top + 2 + cyEach * i + (cyEach - cyHeight) / 2,
                    optionsRect.Width() - 12, cyHeight, PATCOPY);

        pDC->SelectObject(pOldBrush);
        }
    }

/******************************************************************************/

void CRubberTool::OnClickOptions( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                     const CPoint& clickPoint )
    {
    if (m_bFilled)
        {
        CImgTool::OnClickOptions( pWnd, optionsRect, clickPoint );
        return;
        }

    m_nStrokeWidth =  1 + clickPoint.y /
        ((optionsRect.Height() - 4) / nLineWidths);

    // fix for rounding errors
    if (m_nStrokeWidth > nLineWidths)
        {
        m_nStrokeWidth = nLineWidths;
        }

    pWnd->InvalidateOptions(FALSE);
    }

/******************************************************************************/

void CClosedFormTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                                const CRect& optionsRect )
    {

    // Option 0 is Outlined Shape (border and no fill)
    // Option 1 is Filled Shape with border
    // Option 2 is Filled Shape NO border

    #define NUM_CLOSED_FORM_OPTIONS 3 //number of options high

    //*DK* Select Palette into DC
    CBrush*   pOldBrush;
    CRect     cRectOptionSel; // selection rectangle
    CRect     cRectOption;    //rectangle
    int       cyEach = (optionsRect.Height() - 4) / NUM_CLOSED_FORM_OPTIONS; // max height of each option
    int       cyHeight = cyEach - cyEach/2;  //rectangle is 1/2 max height
    int       bCurrSelected = FALSE;
    BOOL      bFilled = CImgTool::GetCurrent()->IsFilled();
    BOOL      bBorder = CImgTool::GetCurrent()->HasBorder();
    int       i;

    for (i = 0; i < NUM_CLOSED_FORM_OPTIONS; i++)
        {
        // Setup the Rectangles for painting and for selection
        //Selection Rectangle
        cRectOptionSel.SetRect(optionsRect.left + 2,
                               optionsRect.top  + 3  + (i * cyEach),
                              (optionsRect.left + 2) + optionsRect.Width() - 4,
                              (optionsRect.top  + 3  + (i* cyEach)) + cyEach - 2);

        //Option Rectangle
        cRectOption.SetRect(optionsRect.left + 6,
                  optionsRect.top  + 2  + i * cyEach + (cyEach - cyHeight) / 2,
                 (optionsRect.left + 6) + optionsRect.Width() - 12,
                 (optionsRect.top  + 2  + i * cyEach + (cyEach - cyHeight) / 2)
                         + cyHeight);

        // Determine the Selection state for the current item.
        bCurrSelected = FALSE;

        switch (i)
            {
            case 0: //Outlined Shape (border, no fill)
                if (! bFilled && bBorder)
                    {
                    bCurrSelected = TRUE;
                    }
                break;

            case 1: // Filled Shape (border and fill)
                if ( (bFilled) && (bBorder) )
                    {
                    bCurrSelected = TRUE;
                    }
                break;
            case 2: // Filled Shape No Border (no border, fill)
                if (bFilled && ! bBorder)
                    {
                    bCurrSelected = TRUE;
                    }
                break;
            default:
                bCurrSelected = FALSE;
                break;
            }
        // Draw the selection State
        // If selected, use COLOR_HIGHLIGHT else use CMP_COLOR_LTGRAY
        pOldBrush = pDC->SelectObject( GetSysBrush( bCurrSelected ?
                                       COLOR_HIGHLIGHT : COLOR_BTNFACE ) );
        pDC->PatBlt( cRectOptionSel.left, cRectOptionSel.top,
                     cRectOptionSel.Width(),cRectOptionSel.Height(), PATCOPY );
        pDC->SelectObject(pOldBrush);


        CBrush* pborderBrush;
        CBrush* pfillBrush;

        pborderBrush = GetSysBrush(bCurrSelected ?
                                   COLOR_BTNHIGHLIGHT : COLOR_BTNTEXT);
        pfillBrush = GetSysBrush(COLOR_BTNSHADOW);

        // Draw the Option
        switch (i)
            {
            case 0: //Outlined Shape (no border, no fill)
                pDC->FrameRect(&cRectOption, pborderBrush);
                break;

            case 1: // Filled Shape (border and fill)
                // using fillrect then frame rect instead of rectangle, since
                // don't have getsyspen facility in this program.
                pDC->FillRect(&cRectOption, pfillBrush);
                pDC->FrameRect(&cRectOption, pborderBrush);
                break;

            case 2: // Filled Shape No Border (no border, fill)
                pDC->FillRect(&cRectOption, pfillBrush);
                break;

            default:
                break;
            }
        }
    }


/******************************************************************************/
// clickpoint is from top of optionsrect (i.e. clickpoint if from 0 to optionsrect.height()
// and thus clickpoint is always less than optionsrec.top

void CClosedFormTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                     const CPoint& clickPoint)
    {
    int  cyEach = (optionsRect.Height() - 4) / NUM_CLOSED_FORM_OPTIONS; // max height of each option
//  BOOL bCurrSelected = FALSE;
    int       i;

    for (i = 0; i < NUM_CLOSED_FORM_OPTIONS; i++)
        {
        if ( clickPoint.y <  3 + ((i+1) * cyEach) )
            {
//          bCurrSelected = TRUE;

            switch (i)
                {
                default: // default is same as initial
                case 0: //Outlined Shape (border, no fill)
                    m_bFilled = FALSE;
                    m_bBorder = TRUE;
                    break;

                case 1: // Filled Shape (border and fill)
                    m_bFilled = TRUE;
                    m_bBorder = TRUE;
                    break;

                case 2: // Filled Shape No Border (no border, fill)
                    m_bFilled = TRUE;
                    m_bBorder = FALSE;
                    break;
                }

            break;   // point found, break out of loop test
            }
        }

    pWnd->InvalidateOptions(FALSE);
    }

/******************************************************************************/

void CRubberTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    SetupRubber(pImgWnd->m_pImg);
    OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CRubberTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    OnDrag(pImgWnd, pmti);


    CRect rc(pmti->ptDown.x, pmti->ptDown.y, pmti->pt.x, pmti->pt.y);

    Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), rc, pmti->fLeft, TRUE, pmti->fCtrlDown);
    InvalImgRect(pImgWnd->m_pImg, &rc);
    CommitImgRect(pImgWnd->m_pImg, &rc);
    pImgWnd->FinishUndo(rc);

    ClearStatusBarSize();

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CRubberTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    HPALETTE hpalOld = NULL;

    if (theApp.m_pPalette &&  theApp.m_pPalette->m_hObject)
        {
        hpalOld = SelectPalette( hRubberDC,
                       (HPALETTE)theApp.m_pPalette->m_hObject, FALSE ); // Background ??
        RealizePalette( hRubberDC );
        }

    BitBlt(pImgWnd->m_pImg->hDC, rcPrev.left   , rcPrev.top,
                                 rcPrev.Width(), rcPrev.Height(),
                      hRubberDC, rcPrev.left   , rcPrev.top, SRCCOPY);

    if (hpalOld != NULL)
        SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??

    InvalImgRect(pImgWnd->m_pImg, &rcPrev);

    PreProcessPoints(pmti);

    CRect rc(pmti->ptDown.x, pmti->ptDown.y, pmti->pt.x, pmti->pt.y);

    Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), rc, pmti->fLeft, FALSE, pmti->fCtrlDown);
    InvalImgRect(pImgWnd->m_pImg, &rc);
    rcPrev = rc;

    if (m_nCmdID != IDMB_POLYGONTOOL)
        {
        CSize size( pmti->pt - pmti->ptDown );

        if (size.cx < 0)
            size.cx -= 1;
        else
            size.cx += 1;
        if (size.cy < 0)
            size.cy -= 1;
        else
            size.cy += 1;

        SetStatusBarPosition( pmti->ptDown );
        SetStatusBarSize    ( size );
        }
    }

/******************************************************************************/

void CRubberTool::AdjustPointsForConstraint(MTI *pmti)
    {
    if (pmti != NULL)
        {
        int iWidthHeight = min( abs(pmti->ptDown.x - pmti->pt.x),
                                abs(pmti->ptDown.y - pmti->pt.y));
        // Set the x value
        if (pmti->pt.x < pmti->ptDown.x)
            {
            pmti->pt.x = pmti->ptDown.x - iWidthHeight;
            }
        else
            {
            pmti->pt.x = pmti->ptDown.x + iWidthHeight;
            }

        // Set the y value
        if (pmti->pt.y < pmti->ptDown.y)
            {
            pmti->pt.y = pmti->ptDown.y - iWidthHeight;
            }
        else
            {
            pmti->pt.y = pmti->ptDown.y + iWidthHeight;
            }

        }
    }

/******************************************************************************/

void CRubberTool::Render( CDC* pDC, CRect& rect, BOOL bLeft, BOOL bCommit, BOOL bCtrlDown )
    {
    int    sx;
    int    sy;
    int    ex;
    int    ey;
    HBRUSH hBr     = NULL;
    HPEN   hPen    = NULL;
    HPEN   hOldPen = NULL;
    HBRUSH hOldBr  = NULL;
    CPoint pt1;
    CPoint pt2;
    HDC    hDC = pDC->m_hDC;

    enum SHAPE { rectangle, roundRect, ellipse } shape;

    switch (m_nCmdID)
        {
        default:
            ASSERT(FALSE);

        case IDMB_RECTTOOL:
            shape = rectangle;
            break;

        case IDMB_FRECTTOOL:
            shape = rectangle;
            break;

        case IDMB_RNDRECTTOOL:
            shape = roundRect;
            break;

        case IDMB_FRNDRECTTOOL:
            shape = roundRect;
            break;

        case IDMB_ELLIPSETOOL:
            shape = ellipse;
            break;

        case IDMB_FELLIPSETOOL:
            shape = ellipse;
            break;
        }

    FixRect(&rect);

    pt1.x = rect.left;
    pt1.y = rect.top;
    pt2.x = rect.right;
    pt2.y = rect.bottom;

    StandardiseCoords(&pt1, &pt2);

    sx = pt1.x;
    sy = pt1.y;
    ex = pt2.x;
    ey = pt2.y;

    SetupPenBrush(hDC, bLeft, TRUE, bCtrlDown);

    CRect rc(sx, sy, ex, ey);

    switch (shape)
        {
        case rectangle:
            Rectangle(hDC, sx, sy, ex, ey);
            break;

        case roundRect:
            RoundRect(hDC, sx, sy, ex, ey, 16, 16);
// The below draws an RoundRect with a mask first then bitblt
//          MyRoundRect(hDC, sx, sy, ex, ey, 16, 16, m_bFilled);
//          // if border and fill, draw border after fill
//          if ( (m_bBorder) && (m_bFilled) )
//          {
//              MyRoundRect(hDC, sx, sy, ex, ey, 16, 16, !m_bFilled);
//          }
            break;

        case ellipse:
            Ellipse(hDC, sx, sy, ex, ey);
// The below draws an Elipse with a mask first then bitblt
//          Mylipse(hDC, sx, sy, ex, ey, m_bFilled);
//          // if border and fill, draw border after fill
//          if ( (m_bBorder) && (m_bFilled) )
//          {
//              Mylipse(hDC, sx, sy, ex, ey, !m_bFilled);
//          }
            break;
        }

    SetupPenBrush(hDC, bLeft, FALSE, bCtrlDown);
    }


void CRubberTool::OnActivate( BOOL bActivate )
    {
        if (bActivate)
        {
                m_nStrokeWidth = g_nStrokeWidth;
        }
        else
        {
                g_nStrokeWidth = m_nStrokeWidth;
        }

    CImgTool::OnActivate( bActivate );
    }


/******************************************************************************/
/*bSetup is true to setup, False to Cleanup                                   */

BOOL CImgTool::SetupPenBrush(HDC hDC, BOOL bLeft, BOOL bSetup, BOOL bCtrlDown)
    {

    COLORREF colorBorder;
    COLORREF colorFill;

    if (bCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       if (HasBorder ())
       {
          colorBorder = bLeft ? crTrans : crRight;
          colorFill   = bLeft ? crRight : crTrans;
       }
       else
       {
          colorBorder = bLeft ? crRight : crTrans;
          colorFill   = bLeft ? crTrans : crRight;
       }

    }
    else
    {
       if (HasBorder())
       {
          colorBorder = bLeft ? crLeft : crRight;
          colorFill   = bLeft ? crRight: crLeft;
       }
       else
       {
          colorBorder = bLeft ? crRight : crLeft;
          colorFill   = bLeft ? crLeft: crRight;
       }

    }

    static HBRUSH hBr             = NULL;
    static HPEN   hPen            = NULL;
    static HPEN   hOldPen         = NULL;
    static HBRUSH hOldBr          = NULL;
    static BOOL   bCurrentlySetup = FALSE;
    BOOL bRC = TRUE;

    if (bSetup)
        {
        if (! bCurrentlySetup)
            {
            bCurrentlySetup = TRUE;
            // select null objects into DC.  Depending on drawing mode,
            // either or both will be re-selected in to override
            hPen    = NULL;
            hBr     = NULL;
            hOldPen =   (HPEN)SelectObject( hDC, GetStockObject( NULL_PEN ) );
            hOldBr  = (HBRUSH)SelectObject( hDC, GetStockObject( NULL_BRUSH ) );

            if (m_bFilled)
                {
                hBr = CreateSolidBrush( colorFill );
                SelectObject( hDC, hBr );
                }

            if (m_bBorder)
                {
                hPen = CreatePen( PS_INSIDEFRAME, m_nStrokeWidth, colorBorder );
                SelectObject(hDC, hPen);
                }
            else
                {
                //simulate no border by drawing the border the same as the fill.
                // since GDI does not draw small elipses, roundrects correctly
                // with NULL brush for no border.
                // Note the width is 2 so we will dither correctly
                hPen = CreatePen(PS_INSIDEFRAME, 2, colorFill);
                SelectObject(hDC, hPen);
                }
            }
        else
            {
            // Error: Will lose allocated Brush/Pen
            bRC = FALSE;
            }
        }
    else
        {
        if (bCurrentlySetup)
            {
            bCurrentlySetup = FALSE;

            SelectObject(hDC, hOldPen);

            if (hPen != NULL)
                {
                DeleteObject(hPen);
                }

            SelectObject(hDC, hOldBr);

            if (hBr != NULL)
                {
                DeleteObject( hBr );
                }
            }
        else
            {
            // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
            bRC = FALSE;
            }
        }

    return bRC;
    }

#if 0 // unused code
/******************************************************************************/
/*bSetup is true to setup, False to Cleanup                                   */

BOOL CRubberTool::SetupMaskPenBrush(HDC hDC, BOOL bLeft, BOOL bSetup)
    {
    BOOL bRC = TRUE;

    static HBRUSH hBr = NULL;
    static HPEN hPen = NULL;
    static HPEN hOldPen = NULL;
    static HBRUSH hOldBr = NULL;
    static BOOL bCurrentlySetup = FALSE;

    if (bSetup)
        {
        if (bCurrentlySetup)
            {
            // Error: Will lose allocated Brush/Pen
            bRC = FALSE;
            }
        else
            {
            bCurrentlySetup = TRUE;
            // draw the shape on the mask:
            // select null objects into DC.  Depending on drawing mode,
            // either or both will be re-selected in to override
            hPen = NULL;
            hBr  = NULL;
            hOldPen = (HPEN)SelectObject(hDC, GetStockObject(NULL_PEN));
            hOldBr  = (HBRUSH)SelectObject(hDC, GetStockObject(NULL_BRUSH));


            if (m_bFilled)
                {
                SelectObject(hDC, GetStockObject( BLACK_BRUSH ));
                }
            if (m_bBorder)
                {
                hPen = CreatePen(PS_INSIDEFRAME, m_nStrokeWidth, (COLORREF)0L );
                SelectObject(hDC, hPen);
                }
            }
        }
    else
        {
        if (bCurrentlySetup)
            {
            bCurrentlySetup = FALSE;

            SelectObject(hDC, hOldPen);
            if (hPen != NULL)
                {
                DeleteObject(hPen);
                }

            SelectObject(hDC, hOldBr);
            if (hBr != NULL)
                {
                DeleteObject(hBr);
                }
            }
        else
            {
            // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
            bRC = FALSE;
            }
        }

    return bRC;
    }
  #endif // unused code
/******************************************************************************/

CRect  CFreehandTool::c_undoRect;

/***************************************************************************/

CFreehandTool::CFreehandTool()
    {
    m_bUsesBrush = TRUE;
    }

/******************************************************************************/

void CFreehandTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    c_undoRect.TopLeft() = c_undoRect.BottomRight() = pmti->pt;
    OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CFreehandTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (g_bCustomBrush)
        {
        c_undoRect.left   -= theImgBrush.m_size.cx + theImgBrush.m_handle.cx;
        c_undoRect.top    -= theImgBrush.m_size.cy + theImgBrush.m_handle.cy;
        c_undoRect.right  += theImgBrush.m_size.cx - theImgBrush.m_handle.cx;
        c_undoRect.bottom += theImgBrush.m_size.cy - theImgBrush.m_handle.cy;
        }
    else
        {
        // HACK: +1s are to cover bug in slanted line brushes
        c_undoRect.left   -=  m_nStrokeWidth / 2 + 1;
        c_undoRect.top    -=  m_nStrokeWidth / 2 + 1;
        c_undoRect.right  += (m_nStrokeWidth + 1) / 2 + 1;
        c_undoRect.bottom += (m_nStrokeWidth + 1) / 2 + 1;
        }

    pImgWnd->FinishUndo(c_undoRect);

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/

CSketchTool::CSketchTool()
    {
    m_nCursorID      = IDC_BRUSH;
    m_nCmdID         = IDMZ_BRUSHTOOL;
    m_bCanBePrevTool = FALSE;
    }

/******************************************************************************/

void CSketchTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    fDraggingBrush = FALSE;

    DrawBrush( pImgWnd->m_pImg, pmti->pt, pmti->fLeft );

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else
        if (pmti->pt.x > c_undoRect.right)
            c_undoRect.right = pmti->pt.x;

    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else
        if (pmti->pt.y > c_undoRect.bottom)
            c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition( pmti->pt );
    }

/******************************************************************************/

void CSketchTool::OnCancel(CImgWnd* pImgWnd)
    {
    HideBrush();
    g_bCustomBrush = FALSE;
    SelectPrevious();
    CImgTool::OnCancel( pImgWnd );
    }

/******************************************************************************/

CBrushTool::CBrushTool()
    {
    m_nCursorID    = IDC_BRUSH;
    m_nCmdID       = IDMB_CBRUSHTOOL;
    m_nStrokeWidth = 4;
    }

/***************************************************************************/

void CBrushTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                           const CRect& optionsRect )
    {
    PaintStdBrushes(pDC, paintRect, optionsRect);
    }

/***************************************************************************/

void CBrushTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    ClickStdBrushes(pWnd, optionsRect, clickPoint);
    }

/***************************************************************************/

void CBrushTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    g_bCustomBrush = FALSE;

    CPoint pt1, pt2;

    fDraggingBrush = FALSE;

    pt1 = pmti->ptPrev;
    pt2 = pmti->pt;

    // use transparent color if defined
    if (pmti->fCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       DrawImgLine( pImgWnd->m_pImg, pt1, pt2, crTrans,
                    m_nStrokeWidth, m_nStrokeShape, TRUE);
    }
    else
    {
       DrawImgLine( pImgWnd->m_pImg, pt1, pt2,
                 pmti->fLeft ? crLeft : crRight,
                 m_nStrokeWidth, m_nStrokeShape, TRUE);

    }

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else if (pmti->pt.x > c_undoRect.right)
        c_undoRect.right = pmti->pt.x;
    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else if (pmti->pt.y > c_undoRect.bottom)
        c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CBrushTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
    g_bCustomBrush = FALSE;
    CImgTool::OnMove(pImgWnd, pmti);
    }

/***************************************************************************/

CPencilTool::CPencilTool()
    {
    m_nCursorID    = IDC_PENCIL;
    m_nCmdID       = IDMB_PENCILTOOL;
    m_bUsesBrush   = FALSE;
    m_nStrokeWidth = 1;
    }

/***************************************************************************/

void CPencilTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CFreehandTool::OnStartDrag(pImgWnd, pmti);
    m_eDrawDirection = eFREEHAND; // initialize to not have a direction

    }

/***************************************************************************/

void CPencilTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    g_bCustomBrush = FALSE;
    fDraggingBrush = FALSE;


    PreProcessPoints(pmti);

    // use transparent color if defined
    if (pmti->fCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       DrawImgLine (pImgWnd->m_pImg, pmti->ptPrev, pmti->pt,
                    crTrans, m_nStrokeWidth, m_nStrokeShape, TRUE);
    }
    else
    {
       DrawImgLine(pImgWnd->m_pImg, pmti->ptPrev, pmti->pt,
                                 pmti->fLeft ? crLeft : crRight,
                          m_nStrokeWidth, m_nStrokeShape, TRUE);
    }

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else if (pmti->pt.x > c_undoRect.right)
        c_undoRect.right = pmti->pt.x;
    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else if (pmti->pt.y > c_undoRect.bottom)
        c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CPencilTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_undoRect.right += 1;
    c_undoRect.bottom += 1;
    pImgWnd->FinishUndo(c_undoRect);

    CImgTool::OnEndDrag(pImgWnd, pmti); // Bypass CFreehandTool
    }

/******************************************************************************/

void CPencilTool::AdjustPointsForConstraint(MTI *pmti)
    {
    eDRAWCONSTRAINTDIRECTION eDrawDirection = DetermineDrawDirection(pmti);
    int iWidthHeight = min( abs(pmti->ptPrev.x - pmti->pt.x),
                            abs(pmti->ptPrev.y - pmti->pt.y));


    switch (m_eDrawDirection)
        {
        case eEAST_WEST:
             pmti->pt.y = pmti->ptPrev.y;
             break;
        case eNORTH_SOUTH:
             pmti->pt.x = pmti->ptPrev.x;
             break;

        case eNORTH_WEST:
        case eSOUTH_EAST:
             // Set the SE movement
             if ( (pmti->pt.x > pmti->ptPrev.x) ||
                  (pmti->pt.y > pmti->ptPrev.y)    )
                 {
                 pmti->pt.x = pmti->ptPrev.x + iWidthHeight;
                 pmti->pt.y = pmti->ptPrev.y + iWidthHeight;
                 }
             else
                 {
                 // Set the NW movement
                 if ( (pmti->pt.x < pmti->ptPrev.x) ||
                      (pmti->pt.y < pmti->ptPrev.y)    )
                     {
                     pmti->pt.x = pmti->ptPrev.x - iWidthHeight;
                     pmti->pt.y = pmti->ptPrev.y - iWidthHeight;
                     }
                 else
                    {
                    //invalid movement, set to last known position
                    pmti->pt.x = pmti->ptPrev.x;
                    pmti->pt.y = pmti->ptPrev.y;
                    }
                 }
             break;

        case eNORTH_EAST:
        case eSOUTH_WEST:
             // Set the NE movement
             if ( (pmti->pt.x > pmti->ptPrev.x) ||
                  (pmti->pt.y < pmti->ptPrev.y)    )
                 {
                 pmti->pt.x = pmti->ptPrev.x + iWidthHeight;
                 pmti->pt.y = pmti->ptPrev.y - iWidthHeight;
                 }
             else
                 {
                 // Set the SW movement
                 if ( (pmti->pt.x < pmti->ptPrev.x) ||
                      (pmti->pt.y > pmti->ptPrev.y)    )
                     {
                     pmti->pt.x = pmti->ptPrev.x - iWidthHeight;
                     pmti->pt.y = pmti->ptPrev.y + iWidthHeight;
                     }
                 else
                    {
                    //invalid movement, set to last known position
                    pmti->pt.x = pmti->ptPrev.x;
                    pmti->pt.y = pmti->ptPrev.y;
                    }
                 }
             break;


        default: // not in constraint mode yet => do nothing.
                 // Default is freehand
            break;
        }
    }

/***************************************************************************/

CEraserTool::CEraserTool()
    {
    m_nCmdID       = IDMB_ERASERTOOL;
    m_nStrokeWidth = 8;
    m_nStrokeShape = squareBrush;
    m_nCursorID    = NULL;
    }

/***************************************************************************/

void CEraserTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                            const CRect& optionsRect )
    {
    CRect rect;
    int cxOctant = (optionsRect.Width() + 1);
    int cyOctant = (optionsRect.Height() + 1) / 4;

    rect.left = optionsRect.left;
    rect.top = optionsRect.top;
    rect.right = rect.left + cxOctant;
    rect.bottom = rect.top + cyOctant;

    for (UINT nSize = 4; nSize <= 10; nSize += 2)
        {
        CBrush* pOldBrush;

        if (nSize == m_nStrokeWidth)
            {
            pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
            pDC->PatBlt(rect.left + (cxOctant - 14) / 2,
                rect.top + (cyOctant - 14) / 2, 14, 14, PATCOPY);
            pDC->SelectObject(pOldBrush);
            }

        pOldBrush = pDC->SelectObject(GetSysBrush(nSize == m_nStrokeWidth ?
            COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
        pDC->PatBlt(rect.left + (cxOctant - nSize) / 2,
            rect.top + (cyOctant - nSize) / 2, nSize, nSize, PATCOPY);
        pDC->SelectObject(pOldBrush);

        rect.top += cyOctant;
        rect.bottom += cyOctant;
        }
    }

/***************************************************************************/

void CEraserTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    int iOptionNumber;
    int cyOctant = (optionsRect.Height() + 1) / 4;
    iOptionNumber = (clickPoint.y / cyOctant);
    if (iOptionNumber > 3)  // there are 4 options, numbered 0,1,2,3
        {
        iOptionNumber = 3;
        }

    m_nStrokeWidth = 4 + 2 * iOptionNumber;

//    int cyOctant = (optionsRect.Height() + 1) / 4;
//    m_nStrokeWidth = 4 + 2 * (clickPoint.y / cyOctant);
    pWnd->InvalidateOptions();
    }


void CEraserTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (pmti->fLeft)
        {
        COLORREF crRealLeftColor = crLeft;
        COLORREF crRealRightColor = crRight;

        crLeft = crRight;

        g_bCustomBrush = FALSE;
        fDraggingBrush = FALSE;

        DrawImgLine(pImgWnd->m_pImg, pmti->ptPrev, pmti->pt, crRight,
                                  m_nStrokeWidth, squareBrush, TRUE);

        crLeft  = crRealLeftColor;
        crRight = crRealRightColor;
        }
    else
        {
        // Just erase pixels that match the drawing color...

        g_bCustomBrush = FALSE;
        fDraggingBrush = FALSE;

        HideBrush();

        CDC* pImageDC = CDC::FromHandle(pImgWnd->m_pImg->hDC);

        CRect rc;

        // Call with NULL DC to get the CRect to use
        DrawDCLine(NULL, pmti->ptPrev, pmti->pt, RGB(255, 255, 255),
            m_nStrokeWidth, squareBrush, rc);

        CTempBitmap monoBitmap;
        CDC monoDc;

         // Create the mono DC and bitmap
        if (!monoDc.CreateCompatibleDC(NULL) ||
            !monoBitmap.CreateBitmap(rc.Width(), rc.Height(), 1, 1, NULL))
            {
            theApp.SetGdiEmergency();
            return;
            }

        // Select the bitmap and change the window origin so the mono DC has
        // the same coordinate system as the image
        CBitmap* pOldMonoBitmap = monoDc.SelectObject(&monoBitmap);
        monoDc.SetWindowOrg(rc.left, rc.top);

        // Clear the mono DC and then draw the area that will be changed
        monoDc.PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), BLACKNESS);
        DrawDCLine(monoDc.m_hDC, pmti->ptPrev, pmti->pt, RGB(255, 255, 255),
            m_nStrokeWidth, squareBrush, rc);
        DebugShowBitmap(monoDc.m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

        // Select the proper palette, and make sure the brush origin is set
        // correctly for pattern brushes
        CPalette* pcPaletteOld = theImgBrush.SetBrushPalette(pImageDC, FALSE);
        pImageDC->SetBrushOrg(0, 0);

        CBrush rightBrush;
        rightBrush.CreateSolidBrush(crRight);

        if (!QuickColorToMono(&monoDc, rc.left, rc.top, rc.Width(), rc.Height(),
            pImageDC, rc.left, rc.top, SRCAND, crLeft))
        {
            // We will get her for DDB's (in which case we could be using a
            // dithered brush) or for high color images (so no palette problems)

            // Create the brush to erase
            CBrush leftBrush;
            leftBrush.CreateSolidBrush(crLeft);
            leftBrush.UnrealizeObject();

//#define DPSxna  0x00820c49L
// #define PSDPxax 0x00B8074AL

            // XOR with the pattern so black is where the pattern was
            CBrush* pOldBrush = pImageDC->SelectObject(&leftBrush);
            pImageDC->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATINVERT);
            DebugShowBitmap(pImageDC->m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

            // Color to mono bitblt to get the final mask
            // The ROP will take all pixels in the source that match the pattern
            // and and them with the white pixels in the dest
            theImgBrush.ColorToMonoBitBlt(&monoDc, rc.left, rc.top, rc.Width(), rc.Height(),
                pImageDC, rc.left, rc.top, SRCAND, RGB(0, 0, 0));
            DebugShowBitmap(monoDc.m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

            // XOR again to put the original back
            pImageDC->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATINVERT);
            DebugShowBitmap(pImageDC->m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

            pImageDC->SelectObject(pOldBrush);
        }

        // Copy the pattern back into the image where the bitmap has white
        CBrush *pOldBrush = pImageDC->SelectObject(&rightBrush);

        COLORREF crNewBk, crNewText;
        GetMonoBltColors(pImageDC->m_hDC, NULL, crNewBk, crNewText);
        COLORREF crOldBk = pImageDC->SetBkColor(crNewBk);
        COLORREF crOldText = pImageDC->SetTextColor(crNewText);
        pImageDC->BitBlt(rc.left, rc.top, rc.Width(), rc.Height(),
            &monoDc, rc.left, rc.top, DSPDxax);
        pImageDC->SetBkColor(crOldBk);
        pImageDC->SetTextColor(crOldText);
        DebugShowBitmap(pImageDC->m_hDC, rc.left, rc.top, rc.Width(), rc.Height());

        // Clean up stuff we have selected
        pImageDC->SelectObject(pOldBrush);

        monoDc.SelectObject(pOldMonoBitmap);

        if (pcPaletteOld)
            pImageDC->SelectPalette(pcPaletteOld, FALSE);

        InvalImgRect(pImgWnd->m_pImg, &rc);
        CommitImgRect(pImgWnd->m_pImg, &rc);
        }

    if (pmti->pt.x < c_undoRect.left)
        c_undoRect.left = pmti->pt.x;
    else if (pmti->pt.x > c_undoRect.right)
        c_undoRect.right = pmti->pt.x;
    if (pmti->pt.y < c_undoRect.top)
        c_undoRect.top = pmti->pt.y;
    else if (pmti->pt.y > c_undoRect.bottom)
        c_undoRect.bottom = pmti->pt.y;

    SetStatusBarPosition(pmti->pt);

    fDraggingBrush = TRUE;

    pImgWnd->ShowBrush(pmti->pt);
    }

/***************************************************************************/

void CEraserTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
    COLORREF crRealLeftColor;
    COLORREF crRealRightColor;

    crRealLeftColor  = crLeft;
    crRealRightColor = crRight;

    crLeft = crRight;

    g_bCustomBrush = FALSE;

    CImgTool::OnMove(pImgWnd, pmti);

    crLeft  = crRealLeftColor;
    crRight = crRealRightColor;
    }

/***************************************************************************/

void CEraserTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    c_undoRect.left   -=  m_nStrokeWidth / 2;
    c_undoRect.top    -=  m_nStrokeWidth / 2;
    c_undoRect.right  += (m_nStrokeWidth + 1) / 2;
    c_undoRect.bottom += (m_nStrokeWidth + 1) / 2;
    pImgWnd->FinishUndo(c_undoRect);

    CImgTool::OnEndDrag(pImgWnd, pmti); // Bypass CFreehandTool
    }

/***************************************************************************/

void CEraserTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShow)
    {
    if (bShow && g_bBrushVisible)
        {
        CClientDC dc(pImgWnd);

        CRect imageRect;
        pImgWnd->GetImageRect(imageRect);
        dc.IntersectClipRect(&imageRect);

        BOOL bGrid = pImgWnd->IsGridVisible();

        CRect rect = rcDragBrush;
        pImgWnd->ImageToClient(rect);
        dc.PatBlt(rect.left, rect.top,
            rect.Width() + bGrid, 1, BLACKNESS);
        dc.PatBlt(rect.left, rect.top + 1,
            1, rect.Height() - 2 + bGrid, BLACKNESS);
        dc.PatBlt(rect.right - 1 + bGrid, rect.top + 1,
            1, rect.Height() - 2 + bGrid, BLACKNESS);
        dc.PatBlt(rect.left, rect.bottom - 1 + bGrid,
            rect.Width() + bGrid, 1, BLACKNESS);
        }
    }

/***************************************************************************/

UINT CEraserTool::GetCursorID()
    {
    CPoint point;
    GetCursorPos(&point);

    CRect rc;

    CPBView* pcbView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
    CImgWnd* pImgWnd = pcbView->m_pImgWnd;

    pImgWnd->ScreenToClient(&point);
    pImgWnd->GetClientRect(&rc);
    if (!rc.PtInRect(point))
    {
        // Return crosshair outside the client rect of the image window
        return LOWORD(IDC_CROSSHAIR);
    }

    pImgWnd->ClientToImage(point);
    if (point.x > pImgWnd->m_pImg->cxWidth ||
        point.y > pImgWnd->m_pImg->cyHeight)
    {
        // Return crosshair outside the drawing area
        return LOWORD(IDC_CROSSHAIR);
    }

    return m_nCursorID;
    }

/***************************************************************************/

CImageWell  CAirBrushTool::c_imageWell(IDB_AIROPT, CSize(24, 24));

CAirBrushTool::CAirBrushTool()
    {
    m_nCmdID       = IDMB_AIRBSHTOOL;
    m_nStrokeWidth = 8;
    m_nCursorID    = IDCUR_AIRBRUSH;
    m_bUsesBrush   = FALSE;
    m_bFilled      = TRUE;
    }

/***************************************************************************/

void CAirBrushTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                              const CRect& optionsRect )
    {
    CPoint pt(optionsRect.left + (optionsRect.Width() / 2 - 24) / 2,
        optionsRect.top + (optionsRect.Height() / 2 - 24) / 2);

    c_imageWell.Open();

    pDC->SetTextColor(GetSysColor(
        m_nStrokeWidth == 8 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        m_nStrokeWidth == 8 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 0, SRCCOPY);
    pt.x += optionsRect.Width() / 2;

    pDC->SetTextColor(GetSysColor(
        m_nStrokeWidth == 16 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        m_nStrokeWidth == 16 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 1, SRCCOPY);
    pt.x = optionsRect.left + (optionsRect.Width() - 24) / 2;

    pDC->SetTextColor(GetSysColor(
        m_nStrokeWidth == 24 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        m_nStrokeWidth == 24 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    pt.y += optionsRect.Height() / 2;
    c_imageWell.DrawImage(pDC, pt, 2, SRCCOPY);

    c_imageWell.Close();
    }

/***************************************************************************/

void CAirBrushTool::OnClickOptions(CImgToolWnd* pWnd,
    const CRect& optionsRect, const CPoint& clickPoint)
    {
    UINT nNewStrokeWidth;

    if (clickPoint.y > optionsRect.Height() / 2)
        nNewStrokeWidth = 24;
    else if (clickPoint.x > optionsRect.Width() / 2)
        nNewStrokeWidth = 16;
    else
        nNewStrokeWidth = 8;

    if (nNewStrokeWidth != m_nStrokeWidth)
        SetStrokeWidth(nNewStrokeWidth);
    }

/***************************************************************************/

void CAirBrushTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    pImgWnd->SetTimer(1, 0, NULL); // FUTURE: rate should be adjustable
    CFreehandTool::OnStartDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CAirBrushTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CPoint pt;
    CRect rect;

    fDraggingBrush = FALSE;

    int nDiam = (m_nStrokeWidth + 1) & ~1; // nDiam must be even
    if (nDiam < 4)
        nDiam = 4;
    int nRadius = nDiam / 2;
    int nRadiusSquared = (nDiam / 2) * (nDiam / 2);

    // Start a bounding rect for changes made in the following loop
    rect.left = rect.right = pmti->pt.x;
    rect.top = rect.bottom = pmti->pt.y;

    m_bCtrlDown = pmti->fCtrlDown; // save it for the timer
    SetupPenBrush(pImgWnd->m_pImg->hDC, !pmti->fLeft, TRUE, m_bCtrlDown);

    for (int i = 0; i < 10; i++)
        {
        // Loop here until we randomly pick a point inside a circle
        // centered around the mouse with a diameter of m_nStrokeWidth...
#ifdef _DEBUG
        int nTrys = 0;
#endif
        do
            {
#ifdef _DEBUG
            if (nTrys++ > 10)
                {
                TRACE(TEXT("The airbrush is clogged!\n"));
                break;
                }
#endif
            pt = pmti->pt;
            pt.x += (rand() % (nDiam + 1)) - nRadius;
            pt.y += (rand() % (nDiam + 1)) - nRadius;
            }
        while (((pt.x - pmti->pt.x) * (pt.x - pmti->pt.x) +
                (pt.y - pmti->pt.y) * (pt.y - pmti->pt.y)) > nRadiusSquared);

        PatBlt(pImgWnd->m_pImg->hDC, pt.x, pt.y, 1, 1, PATCOPY);

        if (pt.x < rect.left)
            rect.left = pt.x;
        else if (pt.x + 1 > rect.right)
            rect.right = pt.x + 1;
        if (pt.y < rect.top)
            rect.top = pt.y;
        else if (pt.y + 1 > rect.bottom)
            rect.bottom = pt.y + 1;
        }

    SetupPenBrush(pImgWnd->m_pImg->hDC, !pmti->fLeft, FALSE, m_bCtrlDown);

    c_undoRect |= rect;

    InvalImgRect(pImgWnd->m_pImg, &rect);
    CommitImgRect(pImgWnd->m_pImg, &rect);

    SetStatusBarPosition(pmti->pt);
    }

/***************************************************************************/

void CAirBrushTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    ::KillTimer(pImgWnd->GetSafeHwnd(), 1);
    CFreehandTool::OnEndDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CAirBrushTool::OnTimer(CImgWnd* pImgWnd, MTI* pmti)
    {
       pmti->fCtrlDown = m_bCtrlDown;
    OnDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CAirBrushTool::OnCancel(CImgWnd* pImgWnd)
    {
    ::KillTimer(pImgWnd->GetSafeHwnd(), 1);
    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

CLineTool::CLineTool()
    {
    m_bUsesBrush   = FALSE;
    m_nStrokeWidth = 1;
    m_nCmdID       = IDMB_LINETOOL;
    }

/***************************************************************************/

void CLineTool::Render(CDC* pDC, CRect& rect, BOOL bLeft, BOOL bCommit, BOOL bCtrlDown)
    {

    COLORREF color;

    // use transparent color if defined
    if (bCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       color = crTrans;
    }
    else
    {
       color = bLeft ? crLeft : crRight;
    }

    int sx = rect.left;
    int sy = rect.top;
    int ex = rect.right;
    int ey = rect.bottom;

    DrawImgLine( pImgCur, rect.TopLeft(), rect.BottomRight(), color,
                  m_nStrokeWidth, m_nStrokeShape, FALSE );
    CRect rc;
    if (sx < ex)
        {
        rc.left = sx;
        rc.right = ex + 1;
        }
    else
        {
        rc.left = ex;
        rc.right = sx + 1;
        }

    if (sy < ey)
        {
        rc.top = sy;
        rc.bottom = ey + 1;
        }
    else
        {
        rc.top = ey;
        rc.bottom = sy + 1;
        }

    rc.left   -= m_nStrokeWidth;
    rc.top    -= m_nStrokeWidth;
    rc.right  += m_nStrokeWidth;
    rc.bottom += m_nStrokeWidth;

    rect = rc;
    }

/******************************************************************************/
// Given an x and y coordinate, we can calculate the angle from the x axis in
// the right triangle using the Tan(a) algorithm.  Where
// tan(a) = opposite/adjacent or y/x.
//
// In order to constrain the line drawing, we need to determine the angle
// from the x axis and constrain it to the nearest 45 degree line (0 degree,
// 45 degree, 90 degree,....).
//
// Thus we can use the following rule :
//
//         0 Degrees <=   Angle   <     45/2 Degrees  Constrained to  0 Degrees
//      45/2 Degrees <=   Angle   <  45+45/2 Degrees  Constrained to 45 Degrees
//   45+45/2 Degrees <=   Angle   <       90 Degrees  Constrained to 90 Degrees
//
//
// We can translate this rule into the below using tan(angle) = y/x and the
// fact that Tan(0) = 0, Tan(22.5) = .414, tan(67.5) = 2.414, tan(90) = infinity
//
//         0 <=   y/x   <     .414   Constrained to  0 Degrees
//      .414 <=   y/x   <    2.414   Constrained to 45 Degrees
//     2.414 <=   y/x                Constrained to 90 Degrees
//
// For more precision, we will multiply everything by 1000 to give us finally
// the following table
//
//         0 <=   (1000*y)/x  <     414   Constrained to  0 Degrees
//       414 <=   (1000*y)/x  <    2414   Constrained to 45 Degrees
//      2414 <=   (1000*y)/x              Constrained to 90 Degrees

void CLineTool::AdjustPointsForConstraint(MTI *pmti)
    {
    if (pmti != NULL)
        {
        int iAngle = 0;

        long lcy = abs( (pmti->ptDown).y - (pmti->pt).y );
        long lcx = abs( (pmti->ptDown).x - (pmti->pt).x );
        long lResult;

        if (lcx != 0)
            {
            lResult = (lcy*1000)/lcx;
            }
        else
            {
            lResult = 2414; // default to 90 degrees if x value is 0.
            }

        if (lResult >= 2414)
            {
            iAngle = 90;
            }
        else
            {
            if (lResult >= 414)
                {
                iAngle = 45;
                }
            else
                {
                iAngle = 0;
                }
            }


//      int iWidthHeight = min( abs(pmti->ptDown.x - pmti->pt.x),
//                              abs(pmti->ptDown.y - pmti->pt.y));
        int iWidthHeight = ( abs(pmti->ptDown.x - pmti->pt.x) +
                             abs(pmti->ptDown.y - pmti->pt.y) ) / 2 ;

        switch (iAngle)
            {
            default: //if for some reason, angle is not valid case, use 0
            case 0:
                pmti->pt.y = pmti->ptDown.y;
                break;

            case 45:
                if (pmti->pt.x < pmti->ptDown.x)
                    {
                    pmti->pt.x = pmti->ptDown.x - iWidthHeight;
                    }
                else
                    {
                    pmti->pt.x = pmti->ptDown.x + iWidthHeight;
                    }

                if (pmti->pt.y < pmti->ptDown.y)
                    {
                    pmti->pt.y = pmti->ptDown.y - iWidthHeight;
                    }
                else
                    {
                    pmti->pt.y = pmti->ptDown.y + iWidthHeight;
                    }

                break;

            case 90:
                pmti->pt.x = pmti->ptDown.x;
                break;
            }
        }
    }

/***************************************************************************/

CRectTool::CRectTool()
    {
    m_nCmdID = IDMB_RECTTOOL;
    }

/***************************************************************************/

CRoundRectTool::CRoundRectTool()
    {
    m_nCmdID = IDMB_RNDRECTTOOL;
    }

/***************************************************************************/

CEllipseTool::CEllipseTool()
    {
    m_nCmdID = IDMB_ELLIPSETOOL;
    }

/***************************************************************************/

CPickColorTool::CPickColorTool()
    {
    m_bIsUndoable     = FALSE;
    m_bCanBePrevTool  = FALSE;
    m_bToggleWithPrev = TRUE;
    m_Color           = ::GetSysColor( COLOR_BTNFACE );
    m_nCursorID       = IDC_EYEDROP;
    m_nCmdID          = IDMY_PICKCOLOR;
    }

/***************************************************************************/

void CPickColorTool::OnActivate(BOOL bActivate)
    {
    g_bPickingColor = bActivate;

    m_Color = ::GetSysColor( COLOR_BTNFACE );

    CImgTool::OnActivate(bActivate);
    }

/***************************************************************************/

void CPickColorTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);
    OnDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CPickColorTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    COLORREF cr = GetPixel(pImgWnd->m_pImg->hDC, pmti->pt.x, pmti->pt.y);

    BYTE red   = GetRValue( cr );
    BYTE green = GetGValue( cr );
    BYTE blue  = GetBValue( cr );

    if (theApp.m_bPaletted)
        m_Color = PALETTERGB( red, green, blue );
    else
        m_Color =        RGB( red, green, blue );

    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
        g_pImgToolWnd->InvalidateOptions();
    }

/***************************************************************************/

void CPickColorTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (pmti->fCtrlDown) // pick transparent color
    {
       SetTransColor (m_Color);
    }
    else if (pmti->fLeft)
        SetDrawColor ( m_Color );
    else
        SetEraseColor( m_Color );

    m_Color = ::GetSysColor( COLOR_BTNFACE );

    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
        g_pImgToolWnd->InvalidateOptions();

    SelectPrevious();
    CImgTool::OnEndDrag( pImgWnd, pmti );
    }

/***************************************************************************/

void CPickColorTool::OnCancel(CImgWnd* pImgWnd)
    {
    SelectPrevious();
    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

void CPickColorTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                               const CRect& optionsRect )
    {
    CPalette* pOldPal = NULL;

    if (theApp.m_pPalette)
        {
        pOldPal = pDC->SelectPalette( theApp.m_pPalette, FALSE );
        pDC->RealizePalette();
        }

    CBrush br;

    if (br.CreateSolidBrush( m_Color ))
        {
        pDC->FillRect( &paintRect, &br );

        br.DeleteObject();
        }

    if (pOldPal)
        pDC->SelectPalette( pOldPal, FALSE );
    }

/***************************************************************************/

CFloodTool::CFloodTool()
    {
    m_nCursorID = IDC_FLOOD;
    m_nCmdID    = IDMB_FILLTOOL;
    m_bFilled   = TRUE;
    }

/***************************************************************************/

void CFloodTool::OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect)
    {
//  PaintStdPattern(pDC, paintRect, optionsRect);
    }

/***************************************************************************/

void CFloodTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    CImgTool::OnClickOptions(pWnd, optionsRect, clickPoint);
    }

/***************************************************************************/

void CFloodTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag( pImgWnd, pmti );

    CPalette *pcPaletteOld = NULL;


    IMG* pimg  = pImgWnd->m_pImg;

    CDC* pDC = CDC::FromHandle( pimg->hDC );

    CBrush  brush;
    CBrush* pOldBrush = NULL;

    COLORREF color;
    if (pmti->fCtrlDown && crTrans != TRANS_COLOR_NONE)
    {
       color = crTrans;
    }
    else
    {
       color = pmti->fLeft ? crLeft : crRight;
    }
    if (theApp.m_pPalette)
        {
        pcPaletteOld = pDC->SelectPalette( theApp.m_pPalette, FALSE );
        pDC->RealizePalette();
        }

    if (brush.CreateSolidBrush( color ))
        {
        pOldBrush = pDC->SelectObject( &brush );

        COLORREF crFillThis = pDC->GetPixel( pmti->pt.x, pmti->pt.y );

        BYTE iRed   = GetRValue( crFillThis );
        BYTE iGreen = GetGValue( crFillThis );
        BYTE iBlue  = GetBValue( crFillThis );

        if (theApp.m_bPaletted)
            crFillThis = PALETTERGB( iRed, iGreen, iBlue );
        else
            crFillThis =        RGB( iRed, iGreen, iBlue );

        pDC->ExtFloodFill( pmti->pt.x,
                           pmti->pt.y, crFillThis, FLOODFILLSURFACE );

        pDC->SelectObject( pOldBrush );

        InvalImgRect ( pimg, NULL );
        CommitImgRect( pimg, NULL );
        }
    else
        {
        theApp.SetGdiEmergency();
        }

    if (pcPaletteOld)
        pDC->SelectPalette( pcPaletteOld, FALSE );
    }

/***************************************************************************/

void CFloodTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    pImgWnd->FinishUndo(CRect(0, 0,
         pImgWnd->m_pImg->cxWidth, pImgWnd->m_pImg->cyHeight));

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/***************************************************************************/

CRect  CSelectTool::c_selectRect;
CImageWell  CSelectTool::c_imageWell(IDB_SELOPT, CSize(37, 23));

CSelectTool::CSelectTool()
    {
    m_bIsUndoable    = FALSE;
    m_nCmdID         = IDMB_PICKTOOL;
    m_bCanBePrevTool = FALSE;
    }

/***************************************************************************/

void CSelectTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                            const CRect& optionsRect )
    {
    CPoint pt(optionsRect.left + (optionsRect.Width()      - 37) / 2,
              optionsRect.top  + (optionsRect.Height() / 2 - 23) / 2);

    CRect selRect(pt.x - 3, pt.y - 3, pt.x + 37 + 3, pt.y + 23 + 3);

    CBrush* pOldBrush;

    pOldBrush = pDC->SelectObject( GetSysBrush(theImgBrush.m_bOpaque ?
                                    COLOR_HIGHLIGHT : COLOR_BTNFACE));

    pDC->PatBlt(selRect.left, selRect.top,
                selRect.Width(), selRect.Height(), PATCOPY);

    pDC->SelectObject(pOldBrush);

    selRect.OffsetRect(0, optionsRect.Height() / 2);

    pOldBrush = pDC->SelectObject(GetSysBrush(theImgBrush.m_bOpaque ?
                                  COLOR_BTNFACE : COLOR_HIGHLIGHT));

    pDC->PatBlt(selRect.left, selRect.top,
                selRect.Width(), selRect.Height(), PATCOPY);

    pDC->SelectObject(pOldBrush);

    c_imageWell.Open();

    c_imageWell.DrawImage(pDC, pt, 0);

    pt.y += optionsRect.Height() / 2;

    c_imageWell.DrawImage(pDC, pt, 1);

    c_imageWell.Close();
    }

/***************************************************************************/

void CSelectTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                    const CPoint& clickPoint)
    {
    BOOL bNewOpaque = clickPoint.y < optionsRect.Height() / 2;

    if (bNewOpaque != theImgBrush.m_bOpaque)
        {
        HideBrush();

        theImgBrush.m_bOpaque = bNewOpaque;
        theImgBrush.RecalcMask(crRight);

        CImgWnd::GetCurrent()->MoveBrush(theImgBrush.m_rcSelection);

        pWnd->InvalidateOptions();
        }
    }

/***************************************************************************/

void CSelectTool::InvertSelectRect(CImgWnd* pImgWnd)
    {
    if (c_selectRect.IsRectEmpty())
        return;

    CClientDC dc( pImgWnd );

    CBrush* pOldBrush = NULL;
    int iLineWidth = pImgWnd->GetZoom();

    if (g_brSelectHorz.m_hObject != NULL)
        pOldBrush = dc.SelectObject( &g_brSelectHorz );
    else
        pOldBrush = (CBrush*)dc.SelectStockObject( BLACK_BRUSH );

    CRect invertRect = c_selectRect;

    pImgWnd->ImageToClient( invertRect );

    int iWidth  = invertRect.Width();
    int iHeight = invertRect.Height();

    dc.PatBlt( invertRect.left, invertRect.top, iWidth - iLineWidth, iLineWidth, PATINVERT );
    dc.PatBlt( invertRect.left, invertRect.top + iHeight - iLineWidth, iWidth - iLineWidth, iLineWidth, PATINVERT );

    if (g_brSelectVert.m_hObject != NULL)
        dc.SelectObject( &g_brSelectVert );

    dc.PatBlt( invertRect.left, invertRect.top + iLineWidth * 2, iLineWidth, iHeight - iLineWidth * 3, PATINVERT );
    dc.PatBlt( invertRect.right - iLineWidth, invertRect.top, iLineWidth, iHeight, PATINVERT );

    if (pOldBrush != NULL)
        dc.SelectObject( pOldBrush );
    }

/***************************************************************************/

void CSelectTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShow)
    {
    if (!bShow)
        {
        InvertSelectRect(pImgWnd);
        c_selectRect.SetRect(0, 0, 0, 0);
        }
    }

/***************************************************************************/

void CSelectTool::OnActivate(BOOL bActivate)
    {
    if (!bActivate)
        {
        if (theImgBrush.m_pImg != NULL)
            {
            if (! theImgBrush.m_bFirstDrag)
                CommitSelection(TRUE);

            InvalImgRect(theImgBrush.m_pImg, NULL); // erase selection tracker
            theImgBrush.m_pImg = NULL;
            }
        }

    CImgTool::OnActivate(bActivate);
    }

/***************************************************************************/

void CSelectTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    CommitSelection(TRUE);

    pImgWnd->EraseTracker();

    theImgBrush.m_bMakingSelection = TRUE;
    }

/***************************************************************************/

void CSelectTool::OnDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CRect newSelectRect(pmti->ptDown.x, pmti->ptDown.y,
        pmti->pt.x, pmti->pt.y);
    FixRect(&newSelectRect);
    newSelectRect.right += 1;
    newSelectRect.bottom += 1;

    if (newSelectRect.left < 0)
        newSelectRect.left = 0;
    if (newSelectRect.top < 0)
        newSelectRect.top = 0;
    if (newSelectRect.right > pImgWnd->GetImg()->cxWidth)
        newSelectRect.right = pImgWnd->GetImg()->cxWidth;
    if (newSelectRect.bottom > pImgWnd->GetImg()->cyHeight)
        newSelectRect.bottom = pImgWnd->GetImg()->cyHeight;

    if (newSelectRect != c_selectRect)
        {
        InvertSelectRect(pImgWnd);
        c_selectRect = newSelectRect;
        InvertSelectRect(pImgWnd);
        }

    SetStatusBarPosition(pmti->ptDown);
    SetStatusBarSize(c_selectRect.Size());
    }

/***************************************************************************/

void CSelectTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    InvertSelectRect(pImgWnd);
    c_selectRect.SetRect(0, 0, 0, 0);

    CRect rcPick;

    theImgBrush.m_bMakingSelection = FALSE;

    if (pmti->ptDown.x > pmti->pt.x)
        {
        rcPick.left = pmti->pt.x;
        rcPick.right = pmti->ptDown.x;
        }
    else
        {
        rcPick.left = pmti->ptDown.x;
        rcPick.right = pmti->pt.x;
        }

    if (pmti->ptDown.y > pmti->pt.y)
        {
        rcPick.top = pmti->pt.y;
        rcPick.bottom = pmti->ptDown.y;
        }
    else
        {
        rcPick.top = pmti->ptDown.y;
        rcPick.bottom = pmti->pt.y;
        }

    if (rcPick.left < 0)
        rcPick.left = 0;
    if (rcPick.top < 0)
        rcPick.top = 0;
    if (rcPick.right > pImgWnd->m_pImg->cxWidth - 1)
        rcPick.right = pImgWnd->m_pImg->cxWidth - 1;
    if (rcPick.bottom > pImgWnd->m_pImg->cyHeight - 1)
        rcPick.bottom = pImgWnd->m_pImg->cyHeight - 1;

    if (rcPick.Width() == 0 || rcPick.Height() == 0)
        {
        theImgBrush.TopLeftHandle();

        theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);

        InvalImgRect(pImgWnd->m_pImg, NULL);  // redraw selection
        theImgBrush.m_pImg = NULL;
        }
    else
        {
        rcPick.right += 1;
        rcPick.bottom += 1;

        pImgWnd->MakeBrush(pImgWnd->m_pImg->hDC, rcPick );
        }

    ClearStatusBarSize();

    CImgTool::OnEndDrag(pImgWnd, pmti);

    if (pmti->fRight && !pmti->fLeft)
    {
        CPoint pt = pmti->pt;

        pImgWnd->OnRButtonDownInSel(&pt);
    }

    }

/***************************************************************************/

void CSelectTool::OnCancel(CImgWnd* pImgWnd)
    {
    if (! theImgBrush.m_bMakingSelection && CWnd::GetCapture() != pImgWnd)
        {
        // We were not selecting or dragging, just cancel the select tool...
        CommitSelection(TRUE);

        theImgBrush.TopLeftHandle();

        theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);

        if (theImgBrush.m_pImg != NULL)
            InvalImgRect(theImgBrush.m_pImg, NULL);  // redraw selection

        theImgBrush.m_pImg = NULL;
        CImgTool::OnCancel(pImgWnd);
        return;
        }

    if (!theImgBrush.m_bMakingSelection && CWnd::GetCapture() == pImgWnd)
        {
        HideBrush();

        if (!theImgBrush.m_bMoveSel && !theImgBrush.m_bSmearSel)
            {
            if (g_bCustomBrush)
                {
                theImgBrush.TopLeftHandle();

                g_bCustomBrush = FALSE;
                SetCombineMode(combineColor);
                }
            else
                {
                if (theImgBrush.m_pImg)
                    CommitSelection(TRUE);
                InvalImgRect(pImgWnd->m_pImg, NULL); // erase the dragger
                }
            }
        }

    InvertSelectRect(pImgWnd);
    c_selectRect.SetRect(0, 0, 0, 0);

    theImgBrush.TopLeftHandle();

    g_bCustomBrush = FALSE;
    theImgBrush.m_pImg = NULL;
    theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
    theImgBrush.m_bMakingSelection = FALSE;

    InvalImgRect(pImgWnd->m_pImg, NULL);

    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

BOOL CSelectTool::IsToolModal(void)
{
        if (theImgBrush.m_pImg)
        {
                return(TRUE);
        }

        return(CImgTool::IsToolModal());
}

/***************************************************************************/

UINT CSelectTool::GetCursorID()
    {
    CPoint point;
    GetCursorPos(&point);
    CImgWnd* pImgWnd = (CImgWnd*)CWnd::WindowFromPoint(point);

    if (pImgWnd->IsKindOf(RUNTIME_CLASS(CImgWnd))
    &&  pImgWnd->GetImg() == pImgCur
    &&  theImgBrush.m_pImg != NULL)
        {
        pImgWnd->ScreenToClient(&point);
        pImgWnd->ClientToImage(point);

        if (theImgBrush.m_rcSelection.PtInRect(point))
            return IDCUR_MOVE;
        }

    return m_nCursorID;
    }

/***************************************************************************/

CRect  CZoomTool::c_zoomRect;
CImgWnd* CZoomTool::c_pImgWnd;
CImageWell  CZoomTool::c_imageWell(IDB_ZOOMOPT, CSize(23, 9));

/***************************************************************************/

CZoomTool::CZoomTool()
    {
    m_bIsUndoable     = FALSE;
    m_bCanBePrevTool  = FALSE;
    m_bToggleWithPrev = TRUE;

    m_nCursorID       = IDC_ZOOMIN;
    m_nCmdID          = IDMB_ZOOMTOOL;
    }

/***************************************************************************/

void CZoomTool::OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect )
    {
    int nCurZoom = CImgWnd::GetCurrent()->GetZoom();
    int dy = optionsRect.Height() / 4;
    CPoint pt(optionsRect.left + (optionsRect.Width() - 23) / 2,
        optionsRect.top + optionsRect.Height() / dy);

    c_imageWell.Open();

    if (nCurZoom == 1)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4,
            PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 1 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 1 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 0, SRCCOPY);
    pt.y += dy;

    if (nCurZoom == 2)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4, PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 2 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 2 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 1, SRCCOPY);
    pt.y += dy;

    if (nCurZoom == 6)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4, PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 6 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 6 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));
    c_imageWell.DrawImage(pDC, pt, 2, SRCCOPY);
    pt.y += dy;

    if (nCurZoom == 8)
        {
        CBrush* pOldBrush;
        pOldBrush = pDC->SelectObject(GetSysBrush(COLOR_HIGHLIGHT));
        pDC->PatBlt(pt.x - 8, pt.y - 2, 23 + 16, 9 + 4, PATCOPY);
        pDC->SelectObject(pOldBrush);
        }
    pDC->SetTextColor(GetSysColor(
        nCurZoom == 8 ? COLOR_HIGHLIGHTTEXT : COLOR_BTNTEXT));
    pDC->SetBkColor(GetSysColor(
        nCurZoom == 8 ? COLOR_HIGHLIGHT : COLOR_BTNFACE));;
    c_imageWell.DrawImage(pDC, pt, 3, SRCCOPY);

    c_imageWell.Close();
    }

/***************************************************************************/

void CZoomTool::OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
    const CPoint& clickPoint)
    {
    int nNewZoom = clickPoint.y / (optionsRect.Height() / 4) + 1;
    if (nNewZoom >= 3)
        nNewZoom *= 2;

    if (nNewZoom != CImgWnd::GetCurrent()->GetZoom())
        {
        CImgWnd::GetCurrent()->SetZoom(nNewZoom);
        CImgWnd::GetCurrent()->CheckScrollBars();

        pWnd->InvalidateOptions();
        }

    SelectPrevious();
    }

/***************************************************************************/

void CZoomTool::OnLeave(CImgWnd* pImgWnd, MTI* pmti)
    {
    InvertZoomRect();
    c_zoomRect.SetRect(0, 0, 0, 0);
    }

/***************************************************************************/

void CZoomTool::OnShowDragger(CImgWnd* pImgWnd, BOOL bShow)
    {
    InvertZoomRect();
    }

/***************************************************************************/

void CZoomTool::InvertZoomRect()
    {
    if (c_zoomRect.IsRectEmpty())
        return;

    CClientDC dc(c_pImgWnd);
    CBrush* pOldBrush = (CBrush*)dc.SelectStockObject(NULL_BRUSH);
    dc.SetROP2(R2_NOT);
    CRect invertRect = c_zoomRect;
    c_pImgWnd->ImageToClient(invertRect);
    dc.Rectangle(&invertRect);
    dc.SelectObject(pOldBrush);
    }

/***************************************************************************/

void CZoomTool::OnMove(CImgWnd* pImgWnd, MTI* pmti)
    {
    if (pImgWnd->GetZoom() > 1)
        return;

    CRect viewRect;
    pImgWnd->GetClientRect(&viewRect);
    int nPrevZoom = pImgWnd->GetPrevZoom();

    CRect newZoomRect;
    CSize viewSize = viewRect.Size();
    if (viewSize.cx > pImgWnd->m_pImg->cxWidth * nPrevZoom)
        viewSize.cx = pImgWnd->m_pImg->cxWidth * nPrevZoom;
    if (viewSize.cy > pImgWnd->m_pImg->cyHeight * nPrevZoom)
        viewSize.cy = pImgWnd->m_pImg->cyHeight * nPrevZoom;
    newZoomRect.left = pmti->pt.x;
    newZoomRect.top = pmti->pt.y;
    newZoomRect.right = newZoomRect.left + viewSize.cx / nPrevZoom;
    newZoomRect.bottom = newZoomRect.top + viewSize.cy / nPrevZoom;
    newZoomRect.OffsetRect(-newZoomRect.Width() / 2,
        -newZoomRect.Height() / 2);

    int xAdjust = 0;
    int yAdjust = 0;

    if (newZoomRect.left < 0)
        xAdjust = -newZoomRect.left;
    else if ((xAdjust = pImgWnd->m_pImg->cxWidth - newZoomRect.right) > 0)
        xAdjust = 0;

    if (newZoomRect.top < 0)
        yAdjust = -newZoomRect.top;
    else if ((yAdjust = pImgWnd->m_pImg->cyHeight - newZoomRect.bottom) > 0)
        yAdjust = 0;

    newZoomRect.OffsetRect(xAdjust, yAdjust);

    if (newZoomRect != c_zoomRect)
        {
        InvertZoomRect();
        c_pImgWnd = pImgWnd;
        c_zoomRect = newZoomRect;
        InvertZoomRect();
        }
    }

/***************************************************************************/

void CZoomTool::OnStartDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    CImgTool::OnStartDrag(pImgWnd, pmti);

    c_pImgWnd = pImgWnd;
    InvertZoomRect();

    if (pImgWnd->GetZoom() == 1)
        {
        pImgWnd->SetZoom( pImgWnd->GetPrevZoom() );
        pImgWnd->CheckScrollBars();
        pImgWnd->SetScroll(-c_zoomRect.left - 1, -c_zoomRect.top - 1);
        }
    else
        {
        pImgWnd->SetZoom(1);
        pImgWnd->CheckScrollBars();
        }

    c_zoomRect.SetRect(0, 0, 0, 0);
    }

/***************************************************************************/

void CZoomTool::OnEndDrag(CImgWnd* pImgWnd, MTI* pmti)
    {
    SelectPrevious();
    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/***************************************************************************/

void CZoomTool::OnCancel(CImgWnd* pImgWnd)
    {
    InvertZoomRect();
    c_zoomRect.SetRect(0, 0, 0, 0);
    SelectPrevious();
    CImgTool::OnCancel(pImgWnd);
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgwell.cpp ===
#include "stdafx.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

#define DSx     0x00660046L
#define DSna    0x00220326L


CImageWell::CImageWell()
    : m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(0, 0)
{
    m_nBitmapID = 0;
}


CImageWell::CImageWell(UINT nBitmapID, CSize imageSize)
    : m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(imageSize)
{
    m_nBitmapID = nBitmapID;
}


CImageWell::~CImageWell()
{
    // Destructor needed to ensure the DC is deleted before the bitmap
    m_dc.DeleteDC();
    m_bitmap.DeleteObject();
    m_maskDC.DeleteDC();
    m_mask.DeleteObject();
}


BOOL CImageWell::Load(UINT nBitmapID, CSize imageSize)
{
    ASSERT(m_bitmap.m_hObject == NULL);

    if (!m_bitmap.LoadBitmap(nBitmapID))
    {
        TRACE1("Could not load image well %d\n", nBitmapID);
        return FALSE;
    }

    m_nBitmapID = nBitmapID;
    m_imageSize = imageSize;

    return TRUE;
}


void CImageWell::Unload()
{
    ASSERT(m_dc.m_hDC == NULL); // can't unload if it's open!
    ASSERT(m_maskDC.m_hDC == NULL);
    ASSERT(m_bitmap.m_hObject != NULL);

    m_bitmap.DeleteObject();
    m_mask.DeleteObject();
}


BOOL CImageWell::CalculateMask()
{
    ASSERT(m_maskDC.m_hDC == NULL);
    ASSERT(m_dc.m_hDC != NULL);
    ASSERT(m_bitmap.m_hObject != NULL);

    if (!m_maskDC.CreateCompatibleDC(NULL))
    {
        theApp.SetGdiEmergency(FALSE);
        return FALSE;
    }

    if (m_mask.m_hObject != NULL)
    {
        VERIFY(m_maskDC.SelectObject(&m_mask) != NULL);
        return TRUE;
    }

    BITMAP bmp;
    m_bitmap.GetObject(sizeof (BITMAP), &bmp);

    if (!m_mask.CreateBitmap(bmp.bmWidth, bmp.bmHeight*2, 1, 1, NULL))
    {
        m_maskDC.DeleteDC();
        theApp.SetMemoryEmergency(FALSE);
        return FALSE;
    }

    VERIFY(m_maskDC.SelectObject(&m_mask) != NULL);

    COLORREF oldBkColor = m_dc.SetBkColor(m_dc.GetPixel(0, 0));
    m_maskDC.BitBlt(0, 0, bmp.bmWidth, bmp.bmHeight,
        &m_dc, 0, 0, NOTSRCCOPY);
    
    // store the pixels in "button text" color in the second part of the mask
    
    m_dc.SetBkColor(RGB(0, 0, 0));
    m_maskDC.BitBlt(0, bmp.bmHeight, bmp.bmWidth, bmp.bmHeight,
        &m_dc, 0, 0, SRCCOPY);
    
    m_dc.SetBkColor(oldBkColor);

    return TRUE;
}


BOOL CImageWell::Open()
{
    ASSERT(m_dc.m_hDC == NULL); // make sure this is not already open
    ASSERT(m_nBitmapID != 0);

    if (m_bitmap.m_hObject == NULL && !Load(m_nBitmapID, m_imageSize))
        return FALSE;

    if (!m_dc.CreateCompatibleDC(NULL))
    {
        theApp.SetGdiEmergency(FALSE);
        return FALSE;
    }

    VERIFY(m_dc.SelectObject(&m_bitmap));

    return TRUE;
}


void CImageWell::Close()
{
    ASSERT(m_dc.m_hDC != NULL);

    m_dc.DeleteDC();
    m_maskDC.DeleteDC();
}

BOOL CImageWell::DrawImage(CDC* pDestDC, CPoint destPoint,
    UINT nImage, DWORD rop)
{
    BOOL bClose = FALSE;
    if (m_dc.m_hDC == NULL)
    {
        ASSERT(rop != NULL); // must open first and calc mask for rop==0!

        if (!Open())
        {
            TRACE(TEXT("Could not open image well!\n"));
            return FALSE;
        }

        bClose = TRUE;
    }

    if (rop == 0)
    {
        if (m_maskDC.m_hDC == NULL && !CalculateMask())
            return FALSE;

        COLORREF oldBkColor = pDestDC->SetBkColor(RGB(255, 255, 255));
        COLORREF oldTextColor = pDestDC->SetTextColor(RGB(0, 0, 0));

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_dc, m_imageSize.cx * nImage, 0, DSx);

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_maskDC, m_imageSize.cx * nImage, 0, DSna);

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_dc, m_imageSize.cx * nImage, 0, DSx);

        pDestDC->SetBkColor(GetSysColor(COLOR_BTNTEXT));

        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_maskDC, m_imageSize.cx * nImage, m_imageSize.cy, SRCPAINT);

        pDestDC->SetBkColor(oldBkColor);
        pDestDC->SetTextColor(oldTextColor);
    }
    else
    {
        pDestDC->BitBlt(destPoint.x, destPoint.y,
            m_imageSize.cx, m_imageSize.cy,
            &m_dc, m_imageSize.cx * nImage, 0, rop);
    }

    if (bClose)
        Close();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgtools.h ===
#ifndef __IMGTOOLS_H__
#define __IMGTOOLS_H__

extern BOOL  g_bBrushVisible;
extern BOOL  g_bPickingColor;
extern UINT  g_nStrokeWidth;

typedef enum
    {
    eFREEHAND,
    eEAST_WEST,   //HORIZONTAL
    eNORTH_SOUTH, //VERTICAL
    eNORTH_WEST,  // 45 degree up to left
    eSOUTH_EAST,  // 45 degree down to right
    eNORTH_EAST,  // 45 degree up to right
    eSOUTH_WEST   // 45 degree down to left
    } eDRAWCONSTRAINTDIRECTION;

class CImgTool : public CObject
    {
    DECLARE_DYNAMIC( CImgTool )

    protected:

    eDRAWCONSTRAINTDIRECTION DetermineDrawDirection(MTI *pmti);
    virtual void AdjustPointsForConstraint(MTI *pmti);
    virtual void PreProcessPoints(MTI *pmti);

    eDRAWCONSTRAINTDIRECTION m_eDrawDirection;

    public:

    CImgTool();

    virtual void OnEnter        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnLeave        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnStartDrag    ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag      ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag         ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnMove         ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnTimer        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel       ( CImgWnd* pImgWnd);
    virtual void OnActivate     ( BOOL bActivate );
    virtual void OnShowDragger  ( CImgWnd* pImgWnd, BOOL bShow );
    virtual void OnPaintOptions ( CDC* pDC, const CRect& paintRect,
                                            const CRect& optionsRect );
    virtual void OnClickOptions ( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                     const CPoint& clickPoint );
    virtual void OnUpdateColors (CImgWnd* pImgWnd);
    virtual BOOL CanEndMultiptOperation(MTI* pmti );
    virtual void EndMultiptOperation(BOOL bAbort = FALSE);

    virtual BOOL IsToolModal(void);
    virtual BOOL SetupPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown);

    void PaintStdBrushes( CDC* pDC, const CRect& paintRect,
                          const CRect& optionsRect );


    void PaintStdPattern( CDC* pDC, const CRect& paintRect,
                                    const CRect& optionsRect );

    void ClickStdBrushes(CImgToolWnd* pWnd, const CRect& optionsRect,
                         const CPoint& clickPoint);

    void ClickStdPattern(CImgToolWnd* pWnd, const CRect& optionsRect,
                         const CPoint& clickPoint);

    static void   HideDragger(CImgWnd* pImgWnd);
    static void   ShowDragger(CImgWnd* pImgWnd);

    inline BOOL   UsesBrush()const { return m_bUsesBrush; }
    inline BOOL   IsToggle() const { return m_bToggleWithPrev; }
    inline BOOL   IsFilled() const { return m_bFilled; }
    inline BOOL   HasBorder()const { return m_bBorder; }
    inline UINT   GetCmdID() const { return m_nCmdID; }
    inline BOOL   IsMultPtOpInProgress() const { return m_bMultPtOpInProgress; }

    virtual BOOL   IsUndoable();
    virtual UINT  GetCursorID();

    void  SetStrokeWidth(UINT nNewStrokeWidth);

    inline UINT   GetStrokeWidth() const { return m_nStrokeWidth; }
    inline UINT   GetStrokeShape() const { return m_nStrokeShape; }
           void   SetStrokeShape(UINT nNewStrokeShape);

    static inline CImgTool* GetCurrent() { return c_pCurrentImgTool; }
    static inline UINT GetCurrentID()    { return c_pCurrentImgTool->m_nCmdID; }
    static inline BOOL IsDragging()      { return c_bDragging; }

    void   Select();

    static void Select(UINT nCmdID);
    static inline void SelectPrevious()     {
                                            ASSERT(c_pPreviousImgTool != NULL);
                                            c_pPreviousImgTool->Select();
                                            }
    static CImgTool* FromID(UINT nCmdID);

    protected:

    BOOL      m_bUsesBrush;
    BOOL      m_bIsUndoable;
    BOOL      m_bCanBePrevTool;
    BOOL      m_bToggleWithPrev;
    BOOL      m_bFilled;
    BOOL      m_bBorder;
    BOOL      m_bMultPtOpInProgress;

    UINT      m_nStrokeWidth;
    UINT      m_nStrokeShape;

    UINT      m_nCursorID;
    UINT      m_nCmdID;
    CImgTool* m_pNextImgTool;

    static CImgTool*  c_pHeadImgTool;
    static CImgTool*  c_pCurrentImgTool;
    static CImgTool*  c_pPreviousImgTool;
    static BOOL       c_bDragging;
    static int        c_nHideCount;
    };


class CRubberTool : public CImgTool
    {
    DECLARE_DYNAMIC(CRubberTool)

    protected:

    virtual void AdjustPointsForConstraint(MTI *pmti);
 //   virtual BOOL SetupMaskPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup);

    public:

    CRubberTool();

    virtual void OnPaintOptions( CDC* pDC, const CRect& paintRect,
                                           const CRect& optionsRect );

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);

    virtual void Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown);
    virtual void OnActivate    ( BOOL bActivate );

    static CRect  rcPrev;
    };

class CClosedFormTool : public CRubberTool
    {
    DECLARE_DYNAMIC(CClosedFormTool)

    public:

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    };


class CRectTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC(CRectTool)

    public:

    CRectTool();
    };

class CRoundRectTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC(CRoundRectTool)

    public:

    CRoundRectTool();
    };

class CEllipseTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC(CEllipseTool)

    public:

    CEllipseTool();
    };

class CLineTool : public CRubberTool
    {
    DECLARE_DYNAMIC(CLineTool)

    protected:

    virtual void AdjustPointsForConstraint(MTI *pmti);
    friend class CPolygonTool; // need to call AdjustPointsForContstraint from cPolygonTool
    friend class CCurveTool; // need to call AdjustPointsForContstraint from cPolygonTool

    public:

    CLineTool();

    virtual void Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown);
    };


class CSelectTool : public CImgTool
    {
    DECLARE_DYNAMIC(CSelectTool)

    protected:

    friend class CFreehandSelectTool; // need to call OnClickOptions and OnPaintOptions

    public:

    CSelectTool();

    virtual void OnActivate(BOOL bActivate);

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);
    virtual void OnShowDragger(CImgWnd* pImgWnd, BOOL bShow);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual BOOL IsToolModal(void);

    void InvertSelectRect(CImgWnd* pImgWnd);

    UINT GetCursorID();

    static CRect       c_selectRect;
    static CImageWell  c_imageWell;
    };


class CFreehandTool : public CImgTool
    {
    DECLARE_DYNAMIC(CFreehandTool)

    public:

    CFreehandTool();

    void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);

    static CRect  c_undoRect;
    };

class CSketchTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CSketchTool)

    public:

    CSketchTool();

    virtual void OnDrag  ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel( CImgWnd* pImgWnd );
    };


class CBrushTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CBrushTool)

    public:

    CBrushTool();

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnMove(CImgWnd* pImgWnd, MTI* pmti);
    };


class CPencilTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CPencilTool)
    protected:
        virtual void AdjustPointsForConstraint(MTI *pmti);

    public:

    CPencilTool();

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    };


class CEraserTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CEraserTool)

    public:

    CEraserTool();

    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnMove(CImgWnd* pImgWnd, MTI* pmti);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnShowDragger(CImgWnd* pImgWnd, BOOL bShow);
    virtual UINT GetCursorID();
    };


class CAirBrushTool : public CFreehandTool
    {
    DECLARE_DYNAMIC(CAirBrushTool)

    public:

    CAirBrushTool();

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnTimer(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    static CImageWell  c_imageWell;
    private:

    BOOL m_bCtrlDown;
    };


class CFloodTool : public CImgTool
    {
    DECLARE_DYNAMIC(CFloodTool)

    public:

    CFloodTool();

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);

    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    };


class CPickColorTool : public CImgTool
    {
    DECLARE_DYNAMIC(CPickColorTool)

    public:

    COLORREF m_Color;

    CPickColorTool();

    virtual void OnActivate(BOOL bActivate);
    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);
    };


class CZoomTool : public CImgTool
    {
    DECLARE_DYNAMIC(CZoomTool)

    protected:

    void InvertZoomRect();

    static CRect  c_zoomRect;
    static CImgWnd* c_pImgWnd;
    static CImageWell  c_imageWell;

    public:

    CZoomTool();

    virtual void OnLeave(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnMove(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti);
    virtual void OnCancel(CImgWnd* pImgWnd);
    virtual void OnShowDragger(CImgWnd* pImgWnd, BOOL bShow);

    virtual void OnPaintOptions(CDC* pDC, const CRect& paintRect,
                                          const CRect& optionsRect);

    virtual void OnClickOptions(CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint);
    };

#endif // __IMGTOOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgsuprt.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "t_fhsel.h"
#include "toolbox.h"
#include "imgbrush.h"
#include "imgdlgs.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG

#include "memtrace.h"

BOOL  g_bUseTrans = FALSE;
BOOL  g_bCustomBrush = FALSE;
BOOL  fDraggingBrush = FALSE;
IMG*  pImgCur = NULL;

#define NUM_DEF_COLORS 28
extern COLORREF  colorColorsDef[NUM_DEF_COLORS];

COLORREF  crLeft  = 0;
COLORREF  crRight = RGB( 0xff, 0xff, 0xff );
COLORREF  crTrans = TRANS_COLOR_NONE; // transparent color
int       theLeft;
int       theRight;
int       theTrans;
int       wCombineMode;

HDC       hRubberDC;
HBITMAP   hRubberBM;
int       cxRubberWidth;
int       cyRubberHeight;
IMG*      pRubberImg;

BOOL     EnsureUndoSize(IMG* pImg);

static int   cxUndoWidth, cyUndoHeight;
static BYTE  cUndoPlanes, cUndoBitCount;

HBITMAP   g_hUndoImgBitmap = NULL;
HPALETTE  g_hUndoPalette   = NULL;

COLORREF  std2Colors [] =
    {
    RGB(000, 000, 000), //  0 - black
    RGB(255, 255, 255)  //  1 - white
    };

COLORREF  std16Colors [] =
    {
    RGB(  0,   0,   0), // Black
    RGB(128,   0,   0), // Dark Red
    RGB(  0, 128,   0), // Dark Green
    RGB(128, 128,   0), // Pea Green
    RGB(  0,   0, 128), // Dark Blue
    RGB(128,   0, 128), // Lavender
    RGB(  0, 128, 128), // Slate
    RGB(192, 192, 192), // Light Gray
    RGB(128, 128, 128), // Dark Gray
    RGB(255,   0,   0), // Bright Red
    RGB(  0, 255,   0), // Bright Green
    RGB(255, 255,   0), // Yellow
    RGB(  0,   0, 255), // Bright Blue
    RGB(255,   0, 255), // Magenta
    RGB(  0, 255, 255), // Cyan
    RGB(255, 255, 255)  //  1 - white
    };

/***************************************************************************/

IMG* CreateImg(int cxWidth, int cyHeight, int cPlanes, int cBitCount, int cXPelsPerMeter, int cYPelsPerMeter, BOOL bPalette )
{
        IMG* pimg = NULL;
        CTempBitmap bmNew;
        HBITMAP hbmOld = NULL;

        CClientDC dcScreen(NULL);


        if (! cPlanes )
        {
                cPlanes = dcScreen.GetDeviceCaps( PLANES );
        }
        if (! cBitCount)
        {
                cBitCount = dcScreen.GetDeviceCaps( BITSPIXEL );
        }

        CDC cDC;
        cDC.CreateCompatibleDC( &dcScreen );
        if (!cDC.m_hDC)
        {
                return NULL;
        }

        if (cPlanes * cBitCount > 1)
        {
                cDC.SetStretchBltMode(HALFTONE);

        }

        // Set these to 0 to not create a bitmap
        if (cxWidth && cyHeight)
        {
                BOOL bMono = (cPlanes == 1 && cBitCount == 1);
                COLORREF* pcrColors = NULL;
                int nColors = 0;

                cBitCount *= cPlanes;
                if (cBitCount <= 1)
                {
                        cBitCount = 1;
                        pcrColors = std2Colors;
                        nColors = 2;
                }
                else if (cBitCount <= 4)
                {
                        cBitCount = 4;
                        pcrColors = std16Colors;
                        nColors = 16;
                }
                else if (cBitCount <= 8)
                {
                        cBitCount = 8;
                        pcrColors = colorColorsDef;
                        nColors = NUM_DEF_COLORS;
                }
                else
                {
                        // I don't want to deal with 15 or 16 bit images
                        cBitCount = 24;
                }

                HBITMAP hbmNew = NULL;

                if (cBitCount == 4)
                {
                        // Just create a DDB if in 16 colors
                        hbmNew = CreateCompatibleBitmap( dcScreen.m_hDC, cxWidth, cyHeight);
                }
                else
                {
                        struct BMHDR
                        {
                                BITMAPINFOHEADER bmInfo;
                                RGBQUAD          rgb[256];
                        } DIBHdr =
                        {
                                sizeof(BITMAPINFOHEADER),
                                cxWidth,
                                cyHeight,
                                1,
                                (WORD)cBitCount,
                                BI_RGB,
                                0,
                                0,
                                nColors,
                                nColors,
                        } ;

                        if (cBitCount <= 8)
                        {
                                RGBQUAD* prgb;
                                COLORREF* pcr;
                                int n;

                                pcr = pcrColors;
                                prgb = DIBHdr.rgb;

                                for (n=nColors; n>0; --n, ++pcr, ++prgb)
                                {
                                        prgb->rgbRed   = GetRValue(*pcr);
                                        prgb->rgbGreen = GetGValue(*pcr);
                                        prgb->rgbBlue  = GetBValue(*pcr);
                                        prgb->rgbReserved = 0;
                                }
                        }

                        LPVOID lpNewBits;
                        hbmNew = CreateDIBSection(cDC.m_hDC, (LPBITMAPINFO)&DIBHdr,
                                DIB_RGB_COLORS, &lpNewBits, NULL, 0);
                }

                if (!hbmNew)
                {
                        return NULL;
                }
                bmNew.Attach(hbmNew);
        }

        TRY
        {
                pimg = new IMG;
        }
        CATCH (CMemoryException, e)
        {
                TRACE( TEXT("CreateImg: Can't alloc an IMG\n") );
                return NULL;
        }
        END_CATCH

        pimg->cxWidth        = cxWidth;
        pimg->cyHeight       = cyHeight;
        pimg->cPlanes        = cPlanes;
        pimg->cBitCount      = cBitCount;
        pimg->cXPelsPerMeter = cXPelsPerMeter;
        pimg->cYPelsPerMeter = cYPelsPerMeter;
        pimg->hDC            = (HDC)cDC.Detach();
        pimg->hBitmap        = (HBITMAP)bmNew.Detach();
        pimg->hBitmapOld     = NULL;
        pimg->m_pFirstImgWnd = NULL;
        pimg->bDirty         = FALSE;
        pimg->m_hPalOld      = NULL;
        pimg->m_pPalette     = NULL;

        pimg->m_bTileGrid = g_bDefaultTileGrid;
        pimg->m_cxTile    = g_defaultTileGridSize.cx;
        pimg->m_cyTile    = g_defaultTileGridSize.cy;


        BYTE cRed   = GetRValue( crRight );
        BYTE cGreen = GetGValue( crRight );
        BYTE cBlue  = GetBValue( crRight );

        if (theApp.m_bPaletted)
        {
                crRight = PALETTERGB( cRed, cGreen, cBlue );
        }
        else
        {
                crRight =        RGB( cRed, cGreen, cBlue );
        }

        if (pimg->hBitmap)
        {
                pimg->hBitmapOld = (HBITMAP)SelectObject(pimg->hDC, pimg->hBitmap);
                ClearImg( pimg );
        }

        return(pimg);
}

/***************************************************************************/

BOOL ClearImg(IMG* pimg)
    {
#if 1
    HBRUSH   hNewBrush;
    HBRUSH   hOldBrush = NULL;
    HPALETTE hpalOld   = NULL;

    pimg->m_nLastChanged = -1;

    if ((hNewBrush = ::CreateSolidBrush( crRight )) == NULL)
        return FALSE;

    if (pimg->m_pPalette)
        {
        hpalOld = SelectPalette( pimg->hDC, (HPALETTE)pimg->m_pPalette->m_hObject, FALSE );
        RealizePalette( pimg->hDC );
        }

    hOldBrush = (HBRUSH)SelectObject( pimg->hDC, hNewBrush );

    PatBlt( pimg->hDC, 0, 0, pimg->cxWidth, pimg->cyHeight, PATCOPY );

    if (hOldBrush)
        SelectObject(pimg->hDC, hOldBrush);

    DeleteObject( hNewBrush );

    if (hpalOld)
        SelectPalette( pimg->hDC, hpalOld, FALSE );

    return TRUE;
#else
        BOOL    bResult = FALSE;
        HBRUSH  hNewBrush = ::CreateSolidBrush( crRight );

        if ( hNewBrush )
                {
                HBRUSH  hOldBrush = (HBRUSH)SelectObject( pimg->hDC, hNewBrush );
                if ( hOldBrush )
                        {
                        HPALETTE hpalOld = SelectPalette( pimg->hDC,
                                                                                          (HPALETTE)pimg->m_pPalette->m_hObject,
                                                                                          FALSE );
                        if ( hpalOld )
                                {
                                RealizePalette( pimg->hDC );

                            PatBlt( pimg->hDC, 0, 0, pimg->cxWidth, pimg->cyHeight, PATCOPY );
                                pimg->m_nLastChanged = -1;
                                bResult = TRUE;

                        SelectPalette( pimg->hDC, hpalOld, FALSE );
                                }
                SelectObject(pimg->hDC, hOldBrush);
                        }
                DeleteObject( hNewBrush );
                }
        return bResult;
#endif
    }

/***************************************************************************/

void FreeImg(IMG* pimg)
    {
    if (! pimg)
        return;

    if (pimg == theImgBrush.m_pImg)
        theImgBrush.m_pImg = NULL;

    if (pimg->hDC)
        {
        if (pimg->hBitmapOld)
            SelectObject( pimg->hDC, pimg->hBitmapOld );

        if (pimg->m_hPalOld)
            SelectPalette( pimg->hDC, pimg->m_hPalOld, FALSE ); // Background ??

        DeleteDC(pimg->hDC);
        }

    if (pimg->hBitmap)
        DeleteObject(pimg->hBitmap);

    if (theApp.m_pPalette == pimg->m_pPalette)
        theApp.m_pPalette = NULL;

    if (pimg->m_pPalette)
        delete pimg->m_pPalette;

    if (pimg->m_pBitmapObj->m_pImg == pimg)
        pimg->m_pBitmapObj->m_pImg = NULL;

    if (pImgCur == pimg)
        pImgCur = NULL;

    if (pRubberImg == pimg)
        pRubberImg = NULL;

    delete pimg;
    }

/***************************************************************************/

void SelectImg(IMG* pimg)
    {
    if (pimg == pImgCur)
        return;

    if (theImgBrush.m_pImg)
        HideBrush();

    pImgCur = pimg;

    SetupRubber(pimg);
    }

/***************************************************************************/

void DirtyImg( IMG* pimg )
    {
    CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

    if (pDoc)
        {
        pDoc->SetModifiedFlag( TRUE );

        if (theApp.m_bEmbedded)
            pDoc->NotifyChanged();
        }

    pimg->bDirty = TRUE;
    pimg->m_pBitmapObj->SetDirty( TRUE );
    }

/***************************************************************************/

void CleanupImages()
    {
    FreeImg( pImgCur );

    CleanupImgUndo();
    CleanupImgRubber();
    }

/***************************************************************************/

void InvalImgRect(IMG* pimg, CRect* prc)
    {
    CImgWnd* pImgWnd;
    CImgWnd* pNextImgWnd;

    CRect rc;

    rc.SetRect(0, 0, pimg->cxWidth, pimg->cyHeight);

    if (prc)
        rc &= *prc;

    for (pImgWnd = pimg->m_pFirstImgWnd; pImgWnd;
                                         pImgWnd = pNextImgWnd)
        {
        CRect rcWnd;

        pNextImgWnd = pImgWnd->m_pNextImgWnd;

        if (prc)
            {
            rcWnd = rc;
            pImgWnd->ImageToClient(rcWnd);

            if (pImgWnd->IsGridVisible())
                {
                rcWnd.right  += 1;
                rcWnd.bottom += 1;
                }
            }

        pImgWnd->InvalidateRect(prc == NULL ? NULL : &rcWnd, FALSE);
        }
    }

/***************************************************************************/

void CommitImgRect(IMG* pimg, CRect* prc)
    {
    ASSERT(hRubberDC);

    if (hRubberDC == NULL)
        return;

    CRect rc;

    if (prc == NULL)
        {
        SetRect( &rc, 0, 0, pimg->cxWidth, pimg->cyHeight );
        prc = &rc;
        }

    HPALETTE hpalOld = NULL;

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        {
        hpalOld = SelectPalette( hRubberDC, (HPALETTE)theApp.m_pPalette->m_hObject, FALSE ); // Background ??
        RealizePalette( hRubberDC );
        }

    BitBlt(hRubberDC, prc->left, prc->top,
                      prc->Width(), prc->Height(),
           pimg->hDC, prc->left, prc->top, SRCCOPY);

    if (hpalOld)
        SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??
    }

void SelInScreenFirst(CPalette* pPal)
{
        // HACK: Select into screen DC first for GDI bug
        CWindowDC hdcScreen(NULL);
        hdcScreen.SelectPalette(pPal, TRUE);
        hdcScreen.RealizePalette();
}

BOOL CreateSafePalette(CPalette* pPal, LPLOGPALETTE lpLogPal)
{
        if (!pPal->CreatePalette(lpLogPal))
        {
                return(FALSE);
        }

        SelInScreenFirst(pPal);
        return(TRUE);
}


/***************************************************************************/

BOOL ReplaceImgPalette( IMG* pImg, LPLOGPALETTE lpLogPal )
    {
    if (pImg->m_hPalOld)
        {
        ::SelectPalette( pImg->hDC, pImg->m_hPalOld, FALSE );
        pImg->m_hPalOld = NULL;
        }

    if (pImg->m_pPalette)
        delete pImg->m_pPalette;

    pImg->m_pPalette = new CPalette;

    if (pImg->m_pPalette
    &&  CreateSafePalette(pImg->m_pPalette, lpLogPal ))
        {
        pImg->m_hPalOld = ::SelectPalette( pImg->hDC,
                                 (HPALETTE)pImg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( pImg->hDC );
        InvalImgRect( pImg, NULL );
        }
    else
        {
        if (pImg->m_pPalette)
            delete pImg->m_pPalette;

        pImg->m_pPalette = NULL;
        }

    return (pImg->m_pPalette != NULL);
    }

/***************************************************************************/

void CleanupImgRubber()
    {
    if (hRubberDC)
        {
        DeleteDC(hRubberDC);
        hRubberDC = NULL;
        }

    if (hRubberBM)
        {
        DeleteObject(hRubberBM);
        hRubberBM = NULL;
        }

    pRubberImg = NULL;

    cxRubberWidth  = 0;
    cyRubberHeight = 0;
    }

/***************************************************************************/

void IdleImage()
    {
    if (g_pMouseImgWnd)
        {
        CRect rcImage(0, 0, g_pMouseImgWnd->GetImg()->cxWidth,
                            g_pMouseImgWnd->GetImg()->cyHeight);

        g_pMouseImgWnd->ImageToClient( rcImage );

        CRect rcClient;

        g_pMouseImgWnd->GetClientRect( &rcClient );

        rcClient &= rcImage;

        CPoint pt;
        GetCursorPos( &pt );

        CPoint ptClient = pt;

        g_pMouseImgWnd->ScreenToClient( &ptClient );

        if (CWnd::WindowFromPoint( pt ) != g_pMouseImgWnd
        ||  ! rcClient.PtInRect( ptClient ))
            {
            extern MTI  mti;

            CImgTool::GetCurrent()->OnLeave( g_pMouseImgWnd, &mti );

            g_pMouseImgWnd = NULL;

            if (! CImgTool::IsDragging() &&
                ::IsWindow(((CPBFrame*)theApp.m_pMainWnd)->m_statBar.m_hWnd) )
                ((CPBFrame*)theApp.m_pMainWnd)->m_statBar.ClearPosition();
            }
        }

    if (fDraggingBrush)
        {
        CPoint   pt;
        CRect    rcClient;
        CPoint   ptClient;
        CImgWnd* pImgWnd;

        GetCursorPos(&pt);

        pImgWnd = g_pDragBrushWnd;

        if (pImgWnd == NULL)
            return;

        CRect rcImage(0, 0, pImgWnd->GetImg()->cxWidth,
                            pImgWnd->GetImg()->cyHeight);

        pImgWnd->ImageToClient( rcImage   );
        pImgWnd->GetClientRect( &rcClient );

        rcClient &= rcImage;

        ptClient = pt;
        pImgWnd->ScreenToClient( &ptClient );

        if ( CWnd::WindowFromPoint(pt) != pImgWnd
        ||  ! rcClient.PtInRect(ptClient))
            {
            if (fDraggingBrush && theImgBrush.m_pImg == NULL)
                HideBrush();

            pImgWnd->UpdPos( CPoint(-1, -1) );
            }
        else
            if (GetCapture() == NULL)
                {
                CPoint imagePt = ptClient;

                pImgWnd->ClientToImage( imagePt );

                if (! g_bBrushVisible && fDraggingBrush
                &&    CImgTool::GetCurrent()->UsesBrush())
                    {
                    pImgWnd->ShowBrush( imagePt );
                    }
                }
        }
    }

/***************************************************************************/

void HideBrush()
    {
    if (! g_bBrushVisible)
        return;

    g_bBrushVisible = FALSE;

    CImgWnd* pImgWnd = g_pDragBrushWnd;

    ASSERT(pImgWnd);

    if (pImgWnd == NULL)
        return;

    IMG* pimg = pImgWnd->GetImg();

    if (pimg == NULL)
        return;

    HPALETTE hpalOld = pImgWnd->SetImgPalette( hRubberDC, FALSE ); // Background ??

    BitBlt( pimg->hDC, rcDragBrush.left,
                       rcDragBrush.top,
                       rcDragBrush.Width(),
                       rcDragBrush.Height(),
            hRubberDC, rcDragBrush.left,
                       rcDragBrush.top, SRCCOPY );

    if (hpalOld)
        SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??

    InvalImgRect( pimg, &rcDragBrush );
    }

/***************************************************************************/

void FixRect(RECT * prc)
    {
    int t;

    if (prc->left > prc->right)
        {
        t = prc->left;
        prc->left = prc->right;
        prc->right = t;
        }

    if (prc->top > prc->bottom)
        {
        t = prc->top;
        prc->top = prc->bottom;
        prc->bottom = t;
        }
    }

/***************************************************************************/

BOOL SetupRubber(IMG* pimg)
    {
    if (cxRubberWidth  < pimg->cxWidth
    ||  cyRubberHeight < pimg->cyHeight)
        {
        HBITMAP hOldBitmap, hNewBitmap;

        HideBrush();

        if (hRubberDC == NULL
        && (hRubberDC = CreateCompatibleDC( pimg->hDC )) == NULL)
            return FALSE;

        hNewBitmap = CreateCompatibleBitmap( pimg->hDC, pimg->cxWidth, pimg->cyHeight );

        if (hNewBitmap == NULL)
            {
            return FALSE;
            }

        hRubberBM = hNewBitmap;

        hOldBitmap = (HBITMAP) SelectObject( hRubberDC, hRubberBM );

        if (hOldBitmap)
            {
            DeleteObject( hOldBitmap );
            }

        cxRubberWidth  = pimg->cxWidth;
        cyRubberHeight = pimg->cyHeight;
        }

    if (pRubberImg != pimg)
        {
        HideBrush();

        HPALETTE hpalOld = NULL;

        if (theApp.m_pPalette
        &&  theApp.m_pPalette->m_hObject)
            {
            hpalOld = SelectPalette( hRubberDC, (HPALETTE)theApp.m_pPalette->m_hObject, FALSE );
            RealizePalette( hRubberDC );
            }

        BitBlt( hRubberDC, 0, 0, pimg->cxWidth,
                                 pimg->cyHeight, pimg->hDC, 0, 0, SRCCOPY );

        if (hpalOld)
            SelectPalette( hRubberDC, hpalOld, FALSE ); // Background ??
        }

    pRubberImg = pimg;

    return TRUE;
    }

/***************************************************************************/

CPalette* CreatePalette( const COLORREF* colors, int nColors )
    {
    CPalette* pPal = new CPalette;

    if (pPal)
        {
        LPLOGPALETTE pLogPal = (LPLOGPALETTE) LocalAlloc(
            LMEM_FIXED, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * nColors);

        if (pLogPal)
            {
            pLogPal->palVersion    = 0x300;
            pLogPal->palNumEntries = (WORD)nColors;

            for (int i = 0; i < nColors; i++)
                {
                pLogPal->palPalEntry[i] = *(PALETTEENTRY*)colors++;
                pLogPal->palPalEntry[i].peFlags = 0;
                }

            if (! CreateSafePalette(pPal, pLogPal ))
                {
                theApp.SetGdiEmergency();
                delete pPal;
                pPal = NULL;
                }

            LocalFree(pLogPal);
            }
        else
            {
            theApp.SetMemoryEmergency();
            delete pPal;
            pPal = NULL;
            }
        }
    return pPal;
    }

/***************************************************************************/

CPalette* GetStd16Palette()
    {
    return CreatePalette( std16Colors, 16 );
    }

/***************************************************************************/

CPalette* GetStd2Palette()
    {
    return CreatePalette( std2Colors, 2 );
    }

/***************************************************************************/

CPalette* GetStd256Palette()
    {
    return CreatePalette( colorColorsDef, NUM_DEF_COLORS );
    }

/***************************************************************************/

CPalette *PaletteFromDS(HDC hdc)
{
    DWORD adw[257];
    int i,n;
        CPalette        *pPal = new CPalette;

    if ( n = GetDIBColorTable(hdc, 0, 256, (LPRGBQUAD)&adw[1]) )
                {
            for (i=1; i<=n; i++)
                adw[i] = RGB(GetBValue(adw[i]),GetGValue(adw[i]),GetRValue(adw[i]));

            adw[0] = MAKELONG(0x300, n);

                CreateSafePalette(pPal, (LPLOGPALETTE)&adw[0]);
                }
        else
                {
                // No Palette in Bitmap! Use default half-tone palette
                pPal->Attach(CreateHalftonePalette( NULL ));
                }

        return pPal;
}

/////////////////////////////////////////////////////////////////////////////
//
// Packed-DIB Handling Functions
//
// A packed-DIB is a bucket of bits usually consisting of a BITMAPINFOHEADER
// structure followed by an array of RGBQUAD structures followed by the words
// that make up the image.  An alternate form consists of a BITMAPCOREHEADER
// structure followed by an array of RGBTRIPLE structures and the image words.
// This format is used by OS/2, but is supported by Windows.  The only way
// to tell which format the DIB is using is to check the first word against
// the sizes of the header structures (pretty clever eh?).
//
// This is very similar to a DIB as stored in a file.  In fact, a DIB file is
// a BITMAPFILEHEADER structure followed by a packed DIB.
//
// These functions make dealing with packed-DIBs in memory easier.
//
#define WIDTHBYTES(bits) ((((bits) + 31) / 32) * 4)

/***************************************************************************/

void FreeDib(HGLOBAL hDib)
    {
    ASSERT( hDib );

    if (hDib)
        GlobalFree(hDib);
    }

/***************************************************************************/

HGLOBAL DibFromBitmap( HBITMAP hBitmap, DWORD dwStyle, WORD wBits,
                       CPalette* pPal, HBITMAP hMaskBitmap, DWORD& dwLen, 
                       LONG cXPelsPerMeter, LONG cYPelsPerMeter )
    {
    ASSERT(hBitmap);

    if (hBitmap == NULL)
        return NULL;

     ASSERT(hMaskBitmap == NULL || dwStyle == BI_RGB);

    HBITMAP            hbm;
    BITMAP             bm;
    BITMAPINFOHEADER   bi;
    LPBITMAPINFOHEADER lpbi;
    HDC                hDC;
    DWORD              dwSmallLen;


    HPALETTE hPal = (HPALETTE)(pPal->GetSafeHandle());

    if (theApp.m_bPaletted && ! hPal)
        hPal = (HPALETTE)::GetStockObject( DEFAULT_PALETTE );

    GetObject( hBitmap, sizeof( bm ), (LPSTR)&bm );

    if (wBits == 0)
        wBits = bm.bmPlanes * bm.bmBitsPixel;

    if (wBits <= 1)
        wBits = 1;
    else
        if (wBits <= 4)
            wBits = 4;
        else
            if (wBits <= 8)
                wBits = 8;
            else
                wBits = 24;

    bi.biSize          = sizeof( BITMAPINFOHEADER );
    bi.biWidth         = bm.bmWidth;
    bi.biHeight        = bm.bmHeight;
    bi.biPlanes        = 1;
    bi.biBitCount      = wBits;
    bi.biCompression   = dwStyle;
    bi.biSizeImage     = 0;
//  bi.biXPelsPerMeter = theApp.ScreenDeviceInfo.ixPelsPerDM * 10;
//  bi.biYPelsPerMeter = theApp.ScreenDeviceInfo.iyPelsPerDM * 10;
//    HDC hdc = GetDC(NULL);
//    bi.biXPelsPerMeter = MulDiv(::GetDeviceCaps(hdc, LOGPIXELSX),10000, 254);
//    bi.biYPelsPerMeter = MulDiv(::GetDeviceCaps(hdc, LOGPIXELSY),10000, 254);
//    ReleaseDC (NULL, hdc);
    bi.biXPelsPerMeter = cXPelsPerMeter;
    bi.biYPelsPerMeter = cYPelsPerMeter;
    bi.biClrUsed       = 0;
    bi.biClrImportant  = 0;

    dwSmallLen = dwLen = bi.biSize + PaletteSize( (LPSTR) &bi );

    lpbi = (LPBITMAPINFOHEADER) GlobalAlloc(GPTR, dwLen);

    if (lpbi == NULL)
        {
        theApp.SetMemoryEmergency();
        return NULL;
        }

    *lpbi = bi;

    hbm = CreateBitmap( 2, 2, bm.bmPlanes, bm.bmBitsPixel, NULL );
    hDC = CreateCompatibleDC( NULL );

    if (hbm == NULL || hDC == NULL)
        {
        if (hbm)
            DeleteObject( hbm );

        theApp.SetGdiEmergency();
        return NULL;
        }
    HPALETTE hPalOld = NULL;
    HANDLE   hbmOld  = SelectObject( hDC, hbm );

    if (hPal)
        {
        hPalOld = SelectPalette( hDC, hPal, FALSE );
        RealizePalette( hDC );
        }

    // Compute the byte size of the DIB...
    GetDIBits( hDC, hBitmap, 0, (WORD)bi.biHeight, NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS );

    bi = *lpbi;

    // If the driver did not fill in the biSizeImage field, make one up
    // NOTE: This size will be too big if the bitmap is compressed!
    // NOTE: This happens with the Paradise 800x600x256 driver...
    if (bi.biSizeImage == 0)
        {
        TRACE( TEXT("Display driver bug!  We have to compute DIB size...") );

        bi.biSizeImage = WIDTHBYTES( (DWORD)bi.biWidth * wBits ) * bi.biHeight;

        if (dwStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
        }

    dwLen = bi.biSize + PaletteSize( (LPSTR)&bi ) + bi.biSizeImage;

    if (hMaskBitmap)
        dwLen += (LONG)WIDTHBYTES( bi.biWidth ) * bi.biHeight;

    CHAR* hpv = (CHAR*) GlobalAlloc(GPTR, dwLen);

    if (! hpv)
        {
        theApp.SetMemoryEmergency();

        GlobalFree(lpbi);

        if (hbmOld)
            DeleteObject( SelectObject( hDC, hbmOld ) );

        if (hPalOld)
            SelectPalette( hDC, hPalOld, FALSE );

        DeleteDC( hDC );

        return NULL;
        }

    memcpy( hpv, (void*)lpbi, dwSmallLen );

    GlobalFree(lpbi);

    lpbi = (LPBITMAPINFOHEADER)hpv;

    LPSTR lpBits = (LPSTR)lpbi + lpbi->biSize + PaletteSize((LPSTR)lpbi);
    DWORD biSizeImage = lpbi->biSizeImage;

    if (hMaskBitmap)
        {
        // Do the mask first so the dib ends up with the main bitmap's
        // size and palette when we're done...
        LONG cbAdjust     = ((LONG)WIDTHBYTES( bi.biWidth * wBits )) * bi.biHeight;
              lpBits     += cbAdjust;
        WORD biBitCount   = lpbi->biBitCount;
        lpbi->biBitCount  = 1;
        lpbi->biSizeImage = 0;

        if (GetDIBits( hDC, hMaskBitmap, 0, (WORD)bi.biHeight, lpBits,
                            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS ) == 0)
            {
            GlobalFree(hpv);

            if (hbmOld)
                DeleteObject( SelectObject( hDC, hbmOld ) );

            if (hPalOld)
                SelectPalette( hDC, hPalOld, FALSE );

            DeleteDC(hDC);

            return NULL;
            }

        biSizeImage     += lpbi->biSizeImage;
        lpbi->biBitCount = biBitCount;
        lpBits          -= cbAdjust;
        }

    if (GetDIBits( hDC, hBitmap, 0, (WORD)bi.biHeight, lpBits,
                    (LPBITMAPINFO)lpbi, DIB_RGB_COLORS ) == 0)
        {
        GlobalFree(hpv);

        if (hbmOld)
            DeleteObject( SelectObject( hDC, hbmOld ) );

        if (hPalOld)
            SelectPalette( hDC, hPalOld, FALSE );

        DeleteDC(hDC);

        return NULL;
        }

    lpbi->biSizeImage = biSizeImage;

    if (hMaskBitmap)
        lpbi->biHeight *= 2;

    if (hbmOld)
        DeleteObject( SelectObject( hDC, hbmOld ) );

    if (hPalOld)
        SelectPalette( hDC, hPalOld, FALSE );
    DeleteDC( hDC );

    return (LPSTR)lpbi;
    }

/***************************************************************************/

UINT DIBBitsPixel(LPSTR lpbi)
{
        // Calculate the number of colors in the color table based on
        //  the number of bits per pixel for the DIB.

        if (IS_WIN30_DIB(lpbi))
        {
                return(((LPBITMAPINFOHEADER)lpbi)->biBitCount);
        }
        else
        {
                return(((LPBITMAPCOREHEADER)lpbi)->bcBitCount);
        }
}

WORD DIBNumColors(LPSTR lpbi, BOOL bJustUsed)
    {
    WORD wBitCount;

    // If this is a Windows style DIB, the number of colors in the
    //  color table can be less than the number of bits per pixel
    //  allows for (i.e. lpbi->biClrUsed can be set to some value).
    //  If this is the case, return the appropriate value.

    if (IS_WIN30_DIB( lpbi ) && bJustUsed)
        {
        DWORD dwClrUsed = ((LPBITMAPINFOHEADER)lpbi)->biClrUsed;

        if (dwClrUsed != 0)
            return (WORD)dwClrUsed;
        }


    // Calculate the number of colors in the color table based on
    //  the number of bits per pixel for the DIB.

    wBitCount = (WORD)DIBBitsPixel(lpbi);

    switch (wBitCount)
        {
        case 1:
            return 2;

        case 4:
            return 16;

        case 8:
            return 256;

        default:
            return 0;
        }
    }


/***************************************************************************/

WORD PaletteSize(LPSTR lpbi)
    {


    if (IS_WIN30_DIB(lpbi) &&
                ((LPBITMAPINFOHEADER)lpbi)->biCompression==BI_BITFIELDS)
    {
            // Images with bitfields have 3 DWORD's that specify the RGB components
            // (respectively) of each pixel.
            if (((LPBITMAPINFOHEADER)lpbi)->biSize >= sizeof(BITMAPV4HEADER))
            {
               return 0;
            }
            else
               return(3 * sizeof(DWORD));
    }

    return DIBNumColors(lpbi,TRUE) *
        (IS_WIN30_DIB(lpbi) ? sizeof(RGBQUAD) : sizeof(RGBTRIPLE));
    }


/***************************************************************************/

LPSTR FindDIBBits(LPSTR lpbi, DWORD dwOffBits)
    {
    DWORD dwAfterHdr = *(LPDWORD)lpbi + PaletteSize(lpbi);
    DWORD dwOff;
#if 0
        if (dwOffBits && dwAfterHdr != dwOffBits)
        {
                MessageBeep(0);
        }
#endif
    dwOff = max(dwOffBits, dwAfterHdr);
    return(lpbi + dwOff);
    }


/***************************************************************************/

DWORD DIBWidth(LPSTR lpDIB)
    {

    LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpDIB;
    LPBITMAPCOREHEADER lpbmc = (LPBITMAPCOREHEADER)lpDIB;

    if (lpbmi->biSize >= sizeof (BITMAPINFOHEADER))
        return (DWORD) abs(lpbmi->biWidth);
    else
        return (DWORD) abs(lpbmc->bcWidth);
    }


/***************************************************************************/

DWORD DIBHeight(LPSTR lpDIB)
    {
    LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpDIB;
    LPBITMAPCOREHEADER lpbmc = (LPBITMAPCOREHEADER)lpDIB;

    if (lpbmi->biSize >= sizeof (BITMAPINFOHEADER))
        return (DWORD) abs(lpbmi->biHeight);
    else
        return (DWORD) abs(lpbmc->bcHeight);
    }


/***************************************************************************/

HBITMAP DIBToBitmap( LPSTR lpDIBHdr, CPalette* pPal, HDC hdc )
    {
    ASSERT( lpDIBHdr );
    ASSERT( hdc );

    if (! lpDIBHdr || ! hdc)
        return NULL;

    LPBYTE    lpDIBBits = (LPBYTE)FindDIBBits( lpDIBHdr,0 );
    CPalette* ppalOld = NULL;
    CBitmap*  pbmOld  = NULL;
    CBitmap   bmTemp;
    CDC       dc;

    dc.Attach( hdc );

    if (bmTemp.CreateCompatibleBitmap( &dc, 2, 2 ))
        pbmOld = dc.SelectObject( &bmTemp );

    if (pPal)
        {
        ASSERT( pPal->m_hObject );

#ifdef FORCEBACKPALETTE
        ppalOld = dc.SelectPalette( pPal, TRUE );
#else
        ppalOld = dc.SelectPalette( pPal, FALSE );
#endif

        dc.RealizePalette();
        }

    HBITMAP hBitmap = CreateDIBitmap( dc.m_hDC, (LPBITMAPINFOHEADER)lpDIBHdr,
                                      CBM_INIT, lpDIBBits,
                                      (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS );
    if (ppalOld)
        dc.SelectPalette( ppalOld, FALSE );

    if (pbmOld)
        dc.SelectObject( pbmOld );

    if (bmTemp.m_hObject)
        bmTemp.DeleteObject();

    dc.Detach();

    return hBitmap;
    }

/***************************************************************************/

BOOL ShouldUseDDB(HDC hdc, LPBITMAPINFO lpDIBHdr)
{
        if (!IS_WIN30_DIB(lpDIBHdr))
        {
                // I don't want to write special code to deal with this case
                return(FALSE);
        }

        if (lpDIBHdr->bmiHeader.biPlanes*lpDIBHdr->bmiHeader.biBitCount != 4)
        {
                // No DDB for mono or 8bit or more
                return(FALSE);
        }

        UINT cBitCount = GetDeviceCaps( hdc, BITSPIXEL )
                * GetDeviceCaps( hdc, PLANES );
        if (cBitCount > 4)
        {
                return(FALSE);
        }

        RGBQUAD *lpPal = lpDIBHdr->bmiColors;

        for (int i=DIBNumColors((LPSTR)lpDIBHdr, TRUE); i>0; --i, ++lpPal)
        {
                COLORREF cr = RGB(lpPal->rgbRed, lpPal->rgbGreen, lpPal->rgbBlue);
                if (GetNearestColor(hdc, cr) != cr)
                {
                        return(FALSE);
                }
        }

        // OK, so this is a WIN30 DIB, the screen is 16 or less colors, it is
        // either an uncompressed or RLE DIB, and all the colors in the DIB can
        // be shown on the screen.  I guess we can use a DDB.
        return(TRUE);
}

/***************************************************************************/


HBITMAP DIBToDS( LPSTR lpDIB, DWORD dwOffBits, HDC hdc )
{
        ASSERT( lpDIB );
        ASSERT( hdc );

        if (! lpDIB || ! hdc)
        {
                return NULL;
        }

        LPVOID lpNewBits;
        LPBITMAPINFO lpDIBHdr = (LPBITMAPINFO)lpDIB;
        LPBYTE lpDIBBits = (LPBYTE)FindDIBBits( lpDIB, dwOffBits );

        {
                // New block just to scope dcScreen
                CClientDC dcScreen(NULL);

                if (ShouldUseDDB(dcScreen.m_hDC, lpDIBHdr))
                {
                        return(CreateDIBitmap( dcScreen.m_hDC, &lpDIBHdr->bmiHeader,
                                CBM_INIT, lpDIBBits, lpDIBHdr, DIB_RGB_COLORS ));
                }
        }

        // Compressed DIB sections are not allowed
        DWORD dwCompression = lpDIBHdr->bmiHeader.biCompression;
        if (IS_WIN30_DIB(lpDIB))
        {
                lpDIBHdr->bmiHeader.biCompression = BI_RGB;
        }
        HBITMAP hBitmap = CreateDIBSection( hdc, lpDIBHdr, DIB_RGB_COLORS,
                &lpNewBits, NULL, 0);

        if (IS_WIN30_DIB(lpDIB))
        {
                lpDIBHdr->bmiHeader.biCompression = dwCompression;
        }

        if (hBitmap)
        {
                HBITMAP hbmOld = (HBITMAP)SelectObject(hdc, hBitmap);
                if (hbmOld)
                {
                        UINT uWid = DIBWidth(lpDIB);
                        UINT uHgt = DIBHeight(lpDIB);

                        // Fill with white in case the bitmap has any jumps in it.
                        PatBlt(hdc, 0, 0, uWid, uHgt, WHITENESS);

//                        StretchDIBits(hdc, 0, 0, uWid, uHgt, 0, 0, uWid, uHgt, lpDIBBits,
//                                (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS, SRCCOPY);
                        SetDIBitsToDevice (hdc,0,0,uWid, uHgt,0,0,0,abs(uHgt),lpDIBBits,
                                           (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS);
                        SelectObject(hdc, hbmOld);

                        return(hBitmap);
                }

                DeleteObject(hBitmap);
        }

        return(NULL);
}

//------------------------------------------------------------------------------
// SetNewPalette - Used solely by GetRainbowPalette below for initialization.
//------------------------------------------------------------------------------

static void SetNewPalette( PALETTEENTRY* const pPal, PWORD pwRainbowColors,
                                                     UINT R, UINT G, UINT B )
    {
    if (*pwRainbowColors < 256)
        {
        WORD wC;

        for (wC = 0;  wC < *pwRainbowColors;  wC++)
            if (((UINT)GetRValue( *(DWORD*)&pPal[ wC ] ) /* + 1 & ~1 */ ) == (R /* + 1 & ~1 */ )
            &&  ((UINT)GetGValue( *(DWORD*)&pPal[ wC ] ) /* + 1 & ~1 */ ) == (G /* + 1 & ~1 */ )
            &&  ((UINT)GetBValue( *(DWORD*)&pPal[ wC ] ) /* + 1 & ~1 */ ) == (B /* + 1 & ~1 */ ))
                return;

        pPal[*pwRainbowColors].peRed   = (BYTE)R;
        pPal[*pwRainbowColors].peGreen = (BYTE)G;
        pPal[*pwRainbowColors].peBlue  = (BYTE)B;
        pPal[*pwRainbowColors].peFlags = 0;

        (*pwRainbowColors)++;
        }
    }

/***************************************************************************/

CPalette* CreateDIBPalette(LPSTR lpbi)
    {
    LPLOGPALETTE     lpPal;
    CPalette*        pPal = NULL;
    int              iLoop;
    int              wNumColors;
    LPBITMAPINFO     lpbmi;
    LPBITMAPCOREINFO lpbmc;
    BOOL             bWinStyleDIB;
    BOOL             bGetDriverDefaults = FALSE;

    ASSERT( lpbi );

    if (lpbi == NULL)
        return NULL;

    lpbmi = (LPBITMAPINFO)lpbi;
    lpbmc = (LPBITMAPCOREINFO)lpbi;
    wNumColors = (int)DIBNumColors(lpbi, TRUE);
    bWinStyleDIB = IS_WIN30_DIB(lpbi);

    if (! wNumColors)
        {
        if (! theApp.m_bPaletted)
            return NULL;

        bGetDriverDefaults = TRUE;
        wNumColors = 256;
        }

    lpPal = (LPLOGPALETTE)new CHAR [sizeof( LOGPALETTE ) + sizeof( PALETTEENTRY ) * (wNumColors - 1)];

    if (lpPal == NULL)
        {
        theApp.SetMemoryEmergency();
        return NULL;
        }

    if (bGetDriverDefaults)
        {
        #define DIM( X ) (sizeof(X) / sizeof(X[0]))

        // GetRainbowPalette - Based on
        // Fran Finnegan's column in Microsoft Systems Journal, Sept.-Oct., 1991 (#5).
        static BYTE C[] = { 255, 238, 221,
                            204, 187, 170,
                            153, 136, 119,
                            102,  85,  68,
                             51,  34,  17,
                              0
                          };
        PALETTEENTRY* pPal = &(lpPal->palPalEntry[0]);
        WORD wColors = 0;
        int iC;
        int iR;
        int iG;
        int iB;

        for (iC = 0;  iC < DIM( C );  iC++)
            SetNewPalette( pPal, &wColors, C[ iC ], C[ iC ], C[ iC ] );
        for (iR = 0;  iR < DIM( C );  iR += 3)
        for (iG = 0;  iG < DIM( C );  iG += 3)
        for (iB = 0;  iB < DIM( C );  iB += 3)
            SetNewPalette( pPal, &wColors, C[ iR ], C[ iG ], C[ iB ] );
        for (iC = 0;  iC < DIM( C );  iC++)
            {
            SetNewPalette( pPal, &wColors, C[ iC ],       0,       0 );
            SetNewPalette( pPal, &wColors,       0, C[ iC ],       0 );
            SetNewPalette( pPal, &wColors,       0,       0, C[ iC ] );
            }
        }
    else
        for (iLoop = 0; iLoop < wNumColors; iLoop++)
            {
            if (bWinStyleDIB)
                {
                lpPal->palPalEntry[iLoop].peRed   = lpbmi->bmiColors[iLoop].rgbRed;
                lpPal->palPalEntry[iLoop].peGreen = lpbmi->bmiColors[iLoop].rgbGreen;
                lpPal->palPalEntry[iLoop].peBlue  = lpbmi->bmiColors[iLoop].rgbBlue;
                lpPal->palPalEntry[iLoop].peFlags = 0;
                }
            else
                {
                lpPal->palPalEntry[iLoop].peRed   = lpbmc->bmciColors[iLoop].rgbtRed;
                lpPal->palPalEntry[iLoop].peGreen = lpbmc->bmciColors[iLoop].rgbtGreen;
                lpPal->palPalEntry[iLoop].peBlue  = lpbmc->bmciColors[iLoop].rgbtBlue;
                lpPal->palPalEntry[iLoop].peFlags = 0;
                }
            }
    lpPal->palVersion = 0x300;
    lpPal->palNumEntries = (WORD)wNumColors;

    pPal = new CPalette;

    if (pPal == NULL || ! CreateSafePalette(pPal, lpPal ))
        {
        if (pPal)
            delete pPal;
        pPal = NULL;
        }

    delete [] (CHAR*)lpPal;

    return pPal;
    }

/***************************************************************************/

void Draw3dRect(HDC hDC, RECT * prc)
    {
    CDC* pDC = CDC::FromHandle(hDC);
    CBrush* pOldBrush = pDC->SelectObject( GetSysBrush( COLOR_BTNSHADOW ) );

    pDC->PatBlt(prc->left, prc->top, prc->right - prc->left - 1, 1, PATCOPY);
    pDC->PatBlt(prc->left, prc->top + 1, 1, prc->bottom - prc->top - 2, PATCOPY);

    pDC->SelectObject(GetSysBrush( COLOR_BTNHIGHLIGHT ));

    pDC->PatBlt(prc->left + 1, prc->bottom - 1,
                               prc->right - prc->left - 1, 1, PATCOPY);
    pDC->PatBlt(prc->right - 1, prc->top + 1,
                             1, prc->bottom - prc->top - 1, PATCOPY);

    pDC->SelectObject(pOldBrush);
    }

/***************************************************************************/
// DrawBitmap:
// See header file for usage.

void DrawBitmap(CDC* dc, CBitmap* bmSrc, CRect* rc,
    DWORD dwROP /* = SRCCOPY */, CDC* memdc /* = NULL */)
    {
    CBitmap* obm;
    CDC* odc = (memdc? memdc : (new CDC));

    if (!memdc)
        odc->CreateCompatibleDC(dc);

    obm = odc->SelectObject(bmSrc);

    BITMAP bms;
    bmSrc->GetObject(sizeof (BITMAP), (LPSTR)(LPBITMAP)(&bms));

    if (rc)
        {
        dc->BitBlt(rc->left + ((rc->right - rc->left - bms.bmWidth) >> 1),
            rc->top + ((rc->bottom - rc->top - bms.bmHeight) >> 1),
            bms.bmWidth, bms.bmHeight, odc, 0, 0, dwROP);
        }
    else
        {
        dc->BitBlt(0, 0, bms.bmWidth, bms.bmHeight, odc, 0, 0, dwROP);
        }

    odc->SelectObject(obm);
    if (!memdc)
        {
        odc->DeleteDC();
        delete odc;
        }
    }

/***************************************************************************/

BOOL EnsureUndoSize(IMG* pimg)
    {
    if (cxUndoWidth < pimg->cxWidth || cyUndoHeight < pimg->cyHeight ||
            (int)cUndoPlanes != pimg->cPlanes ||
            (int)cUndoBitCount != pimg->cBitCount)
        {
        HBITMAP  hNewUndoImgBitmap  = NULL;
 //       HBITMAP  hNewUndoMaskBitmap = NULL;
        HPALETTE hNewUndoPalette    = NULL;

        hNewUndoImgBitmap = CreateCompatibleBitmap( pimg->hDC, pimg->cxWidth, pimg->cyHeight );

        if (hNewUndoImgBitmap == NULL)
            {
            TRACE(TEXT("EnsureUndoSize: Create image bitmap failed!\n"));
            return FALSE;
            }

//        hNewUndoMaskBitmap = CreateBitmap( pimg->cxWidth, pimg->cyHeight, 1, 1, NULL );

//        if (hNewUndoMaskBitmap == NULL)
 //           {
//            TRACE(TEXT("EnsureUndoSize: Create mask bitmap failed!\n"));

//            DeleteObject( hNewUndoImgBitmap );

 //           return FALSE;
   //         }

//      if (theApp.m_pPalette)
//          {
//          LOGPALETTE256 logPal;

//          logPal.palVersion    = 0x300;
//          logPal.palNumEntries = theApp.m_pPalette->GetPaletteEntries( 0, 256,
//                                                                &logPal.palPalEntry[0] );
//          theApp.m_pPalette->GetPaletteEntries( 0, logPal.palNumEntries,
//                                                                &logPal.palPalEntry[0] );
//          hNewUndoPalette = ::CreatePalette( (LPLOGPALETTE)&logPal );

//          if (! hNewUndoPalette)
//              {
//              TRACE("EnsureUndoSize: Create palette bitmap failed!\n");

//              DeleteObject( hNewUndoImgBitmap  );
//              DeleteObject( hNewUndoMaskBitmap );

//              return FALSE;
//              }
//          }

        if (g_hUndoImgBitmap)
            DeleteObject(g_hUndoImgBitmap);

//      if (g_hUndoPalette)
//          DeleteObject(g_hUndoPalette);

        g_hUndoImgBitmap = hNewUndoImgBitmap;
//      g_hUndoPalette   = hNewUndoPalette;
        cxUndoWidth      = pimg->cxWidth;
        cyUndoHeight     = pimg->cyHeight;
        cUndoPlanes      = (BYTE)pimg->cPlanes;
        cUndoBitCount    = (BYTE)pimg->cBitCount;
        }

    return TRUE;
    }

/***************************************************************************/

void CleanupImgUndo()
    {
    if (g_hUndoImgBitmap)
        DeleteObject(g_hUndoImgBitmap);

    if (g_hUndoPalette)
        DeleteObject(g_hUndoPalette);

    g_hUndoImgBitmap = NULL;
    g_hUndoPalette   = NULL;
    cxUndoWidth      = 0;
    cyUndoHeight     = 0;
    cUndoPlanes      = 0;
    cUndoBitCount    = 0;
    }

/***************************************************************************/

BOOL SetUndo(IMG* pimg)
    {
    BOOL    bSuccess   = FALSE;
    HDC     hTempDC    = NULL;
    HBITMAP hOldBitmap = NULL;
    CRect   rect;

    if (! EnsureUndoSize( pimg ))
        goto LReturn;

    rect.SetRect( 0, 0, pimg->cxWidth, pimg->cyHeight );

    hTempDC = CreateCompatibleDC( pimg->hDC );

    if (hTempDC == NULL)
        {
        TRACE( TEXT("SetUndo: CreateCompatibleDC failed\n") );
        goto LReturn;
        }

    hOldBitmap = (HBITMAP)SelectObject( hTempDC, g_hUndoImgBitmap );

    BitBlt( hTempDC, 0, 0, rect.Width(), rect.Height(),
                pimg->hDC, rect.left, rect.top, SRCCOPY );

    SelectObject( hTempDC, hOldBitmap );
    DeleteDC( hTempDC );

    bSuccess = TRUE;

    LReturn:

    return bSuccess;
    }

/***************************************************************************/

void DrawBrush(IMG* pimg, CPoint pt, BOOL bDraw)
    {
    int nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();

    if (g_bCustomBrush)
        {
        CRect rc(pt.x, pt.y,
                pt.x + theImgBrush.m_size.cx, pt.y + theImgBrush.m_size.cy);
        rc -= (CPoint)theImgBrush.m_handle;

        theImgBrush.m_rcSelection = rc;

        int nCombineMode;
        COLORREF cr;

        if (bDraw)
            {
            nCombineMode = (theImgBrush.m_bOpaque) ? combineReplace : combineMatte;
            cr = crLeft;
            }
        else
            {
            nCombineMode = combineColor;
            cr = crRight;
            }

        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
//          extern CTextTool  g_textTool;
//          g_textTool.Render(CDC::FromHandle(pimg->hDC), rc, TRUE, TRUE);
            }
        else
            {
            switch (nCombineMode)
                {
#ifdef DEBUG
                default:
                    ASSERT(FALSE);
#endif

                case combineColor:
                    theImgBrush.BltColor(pimg, rc.TopLeft(), cr);
                    break;

                case combineMatte:
                    theImgBrush.BltMatte(pimg, rc.TopLeft());
                    break;

                case combineReplace:
                    theImgBrush.BltReplace(pimg, rc.TopLeft());
                    break;
                }
            }

            InvalImgRect (pimg, &rc);
            CommitImgRect(pimg, &rc);
        }
    else
        {
        DrawImgLine(pimg, pt, pt, bDraw ? crLeft : crRight,
                    CImgTool::GetCurrent()->GetStrokeWidth(),
                    CImgTool::GetCurrent()->GetStrokeShape(), TRUE);
        rcDragBrush.left = pt.x - nStrokeWidth / 2;
        rcDragBrush.top = pt.y - nStrokeWidth / 2;
        rcDragBrush.right = rcDragBrush.left + nStrokeWidth;
        rcDragBrush.bottom = rcDragBrush.top + nStrokeWidth;
        }
    }

/***************************************************************************/

void DrawDCLine(HDC hDC, CPoint pt1, CPoint pt2,
                 COLORREF color, int nWidth, int nShape,
                 CRect& rc)
{
        HPEN   hOldPen;
        HBRUSH hBrush;
        HBRUSH hOldBrush;
        int    sx;
        int    sy;
        int    ex;
        int    ey;
        int    nWidthD2 = nWidth / 2;

        sx = pt1.x;
        sy = pt1.y;
        ex = pt2.x;
        ey = pt2.y;

        if (hDC)
        {
                hBrush    = ::CreateSolidBrush( color );
                hOldBrush = (HBRUSH)SelectObject( hDC, hBrush );

                if (nWidth == 1)
                {
                        HPEN hPen = CreatePen(PS_SOLID, 1, (COLORREF)color);

                        if (hPen)
                        {
                            hOldPen = (HPEN)SelectObject(hDC, hPen);

                            ::MoveToEx(hDC, sx, sy, NULL);
                            LineTo(hDC, ex, ey);
                            SetPixel(hDC, ex, ey, color);
                            SelectObject(hDC, hOldPen);
                            DeleteObject(hPen);
                        }
                }
                else
                {
//                      hOldPen = (HPEN)SelectObject(hDC, GetStockObject( NULL_PEN ));

                        BrushLine( CDC::FromHandle(hDC),
                                CPoint(sx - nWidthD2, sy - nWidthD2),
                                CPoint(ex - nWidthD2, ey - nWidthD2), nWidth, nShape);
//                      SelectObject( hDC, hOldPen );
                }

                SelectObject(hDC, hOldBrush);
                DeleteObject(hBrush);
        }

        if (sx < ex)
        {
                rc.left = sx;
                rc.right = ex + 1;
        }
        else
        {
                rc.left = ex;
                rc.right = sx + 1;
        }

        if (sy < ey)
        {
                rc.top = sy;
                rc.bottom = ey + 1;
        }
        else
        {
                rc.top = ey;
                rc.bottom = sy + 1;
        }

        rc.left   -= nWidth * 2;
        rc.top    -= nWidth * 2;
        rc.right  += nWidth * 2;
        rc.bottom += nWidth * 2;
}


void DrawImgLine(IMG* pimg, CPoint pt1, CPoint pt2,
                 COLORREF color, int nWidth, int nShape,
                 BOOL bCommit)
{
        CRect  rc;

        DrawDCLine(pimg->hDC, pt1, pt2, color, nWidth, nShape, rc);

        InvalImgRect(pimg, &rc);

        if (bCommit)
        {
                CommitImgRect(pimg, &rc);
        }
}

/***************************************************************************/

void FillImgRect( HDC hDC, CRect* prc, COLORREF cr )
    {
    FixRect( prc );

    CPoint pt1 = prc->TopLeft();
    CPoint pt2 = prc->BottomRight();

    StandardiseCoords( &pt1, &pt2 );

    int sx = pt1.x;
    int sy = pt1.y;
    int ex = pt2.x;
    int ey = pt2.y;

    CRect rc( sx, sy, ex, ey );

    HBRUSH hBr = ::CreateSolidBrush( cr );

    if (! hBr)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        if (theImgBrush.m_cRgnPolyFreeHandSel.GetSafeHandle())
            {
            // offset bitmap in the imgwnd from selection boundary
            theImgBrush.m_cRgnPolyFreeHandSel.OffsetRgn( rc.left, rc.top );

            ::FillRgn( hDC, (HRGN)theImgBrush.m_cRgnPolyFreeHandSel.m_hObject,
                                                                        hBr );
            // offset back to selection boundary
            theImgBrush.m_cRgnPolyFreeHandSel.OffsetRgn( -rc.left, -rc.top );
            }
        }
    else
        {

        HPEN hPen = CreatePen( PS_NULL, 0, 0 );

        if (hPen)
            {
            HPEN   hOldPen =   (HPEN)SelectObject( hDC, hPen );
            HBRUSH hOldBr  = (HBRUSH)SelectObject( hDC, hBr );

            Rectangle( hDC, sx, sy, ex, ey );

            SelectObject( hDC, hOldPen);
            DeleteObject( hPen );
            SelectObject( hDC, hOldBr );
            }
        }

    DeleteObject( hBr );

    *prc = rc;
    }

/***************************************************************************/

void BrushLine(CDC* pDC, CPoint fromPt, CPoint toPt, int nWidth, int nShape)
    {
    CPen* pOldPen = (CPen*) pDC->SelectStockObject(NULL_PEN);
    CSize brushSize(nWidth, nWidth);

    int octant;

    if (nShape == slantedRightBrush || nShape == slantedLeftBrush)
        {
        int dx = abs(toPt.x - fromPt.x);
        int dy = abs(toPt.y - fromPt.y);

        if (toPt.x > fromPt.x)
            {
            if (toPt.y < fromPt.y)
                octant = (dx > dy) ? 0 : 1;
            else
                octant = (dx > dy) ? 7 : 6;
            }
        else
            {
            if (toPt.y < fromPt.y)
                octant = (dx > dy) ? 3 : 2;
            else
                octant = (dx > dy) ? 4 : 5;
            }
        }

    switch (nShape)
        {
        case squareBrush:
            PolyTo(pDC, fromPt, toPt, brushSize);
            break;

        case roundBrush:
            if (toPt != fromPt)
                {
                CRect tan;
                CPoint polyPts [4];

                if (!GetTanPt(brushSize, (CPoint)(toPt - fromPt), tan))
                    return;

                polyPts[0].x = fromPt.x + tan.left;
                polyPts[1].x = fromPt.x + tan.right;
                polyPts[2].x = toPt.x + tan.right;
                polyPts[3].x = toPt.x + tan.left;

                polyPts[0].y = fromPt.y + tan.top;
                polyPts[1].y = fromPt.y + tan.bottom;
                polyPts[2].y = toPt.y + tan.bottom;
                polyPts[3].y = toPt.y + tan.top;

                pDC->Polygon(polyPts, 4);

                Mylipse(pDC->m_hDC, fromPt.x, fromPt.y,
                        fromPt.x + brushSize.cx, fromPt.y + brushSize.cy, TRUE);
                }

            Mylipse(pDC->m_hDC, toPt.x, toPt.y,
                    toPt.x + brushSize.cx, toPt.y + brushSize.cy, TRUE);
            break;

        case slantedLeftBrush:
            {
            CPoint polyPts [6];

            fromPt.x -= 1;
            toPt.x -= 1;

            switch (octant)
                {
                case 0:
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = toPt.x + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = fromPt.x + brushSize.cy;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 1:
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = fromPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = toPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = fromPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = toPt.y + brushSize.cy;
                    break;

                case 2:
                case 3:
                    polyPts[0].x = fromPt.x + 1;
                    polyPts[1].x = fromPt.x;
                    polyPts[2].x = toPt.x;
                    polyPts[3].x = toPt.x + brushSize.cy;
                    polyPts[4].x = toPt.x + brushSize.cy + 1;
                    polyPts[5].x = fromPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 4:
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = toPt.x + brushSize.cy;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = fromPt.x + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;

                case 5:
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = fromPt.x;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = toPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = fromPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = toPt.y;
                    break;

                default:
                    polyPts[0].x = fromPt.x + brushSize.cy;
                    polyPts[1].x = fromPt.x + brushSize.cy + 1;
                    polyPts[2].x = toPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + 1;
                    polyPts[4].x = toPt.x;
                    polyPts[5].x = fromPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;
                }

            pDC->Polygon(polyPts, 6);
            }
            break;

        case slantedRightBrush:
            {
            CPoint polyPts [6];

            switch (octant)
                {
                case 0:
                case 1:
                    polyPts[0].x = fromPt.x + brushSize.cy;
                    polyPts[1].x = fromPt.x + brushSize.cy + 1;
                    polyPts[2].x = toPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + 1;
                    polyPts[4].x = toPt.x;
                    polyPts[5].x = fromPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 2 :
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = fromPt.x;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = toPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = fromPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = toPt.y + brushSize.cy;
                    break;

                case 3 :
                    polyPts[0].x = fromPt.x + brushSize.cy + 1;
                    polyPts[1].x = fromPt.x + brushSize.cy;
                    polyPts[2].x = toPt.x + brushSize.cy;
                    polyPts[3].x = toPt.x;
                    polyPts[4].x = toPt.x + 1;
                    polyPts[5].x = fromPt.x + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y + brushSize.cy;
                    polyPts[2].y = toPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y;
                    polyPts[5].y = fromPt.y;
                    break;

                case 4 :
                case 5 :
                    polyPts[0].x = fromPt.x + 1;
                    polyPts[1].x = fromPt.x;
                    polyPts[2].x = toPt.x;
                    polyPts[3].x = toPt.x + brushSize.cy;
                    polyPts[4].x = toPt.x + brushSize.cy + 1;
                    polyPts[5].x = fromPt.x + brushSize.cy + 1;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;

                case 6 :
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = fromPt.x + brushSize.cy + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = toPt.x;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = fromPt.y + brushSize.cy;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = toPt.y;
                    break;

                default :
                    polyPts[0].x = fromPt.x;
                    polyPts[1].x = fromPt.x + 1;
                    polyPts[2].x = toPt.x + 1;
                    polyPts[3].x = toPt.x + brushSize.cy + 1;
                    polyPts[4].x = toPt.x + brushSize.cy;
                    polyPts[5].x = fromPt.x + brushSize.cy;
                    polyPts[0].y = polyPts[1].y = fromPt.y;
                    polyPts[2].y = toPt.y;
                    polyPts[3].y = polyPts[4].y = toPt.y + brushSize.cy;
                    polyPts[5].y = fromPt.y + brushSize.cy;
                    break;
                }

            pDC->Polygon(polyPts, 6);
            }
            break;
        }

    pDC->SelectObject(pOldPen);
    }

/***************************************************************************/

void SetCombineMode(int wNewCombineMode)
    {
    wCombineMode = wNewCombineMode;
    }

/***************************************************************************/

static int      cxLastShape;
static int      cyLastShape;
static int      cxShapeBitmap;
static int      cyShapeBitmap;
static CBitmap  shapeBitmap;
static enum { ellipse, roundRect }  nLastShape;

void Mylipse(HDC hDC, int x1, int y1, int x2, int y2, BOOL bFilled)
    {
        COLORREF crNewBk, crNewText;
        GetMonoBltColors(hDC, NULL, crNewBk, crNewText);

    COLORREF crOldText = SetTextColor(hDC, crNewText);
    COLORREF crOldBk   = SetBkColor  (hDC, crNewBk);

    int cx = x2 - x1;
    int cy = y2 - y1;

    if (!bFilled)
        {
        Ellipse(hDC, x1, y1, x2, y2);
        }
    else
        if (cx == cy && cx > 0 && cx <= 8)
            {
            // HACK: The Windows Ellipse function is no good for small ellipses, so I
            // use some little bitmaps here for filled circles 1 to 8 pixels in
            // diameter.

            static CBitmap  g_ellipses [8];

            if (g_ellipses[cx - 1].m_hObject == NULL &&
                    ! g_ellipses[cx - 1].LoadBitmap(IDB_ELLIPSE1 + cx - 1))
                {
                theApp.SetMemoryEmergency();
                SetTextColor(hDC, crOldText);
                SetBkColor(hDC, crOldBk);
                return;
                }

            HDC hTempDC = CreateCompatibleDC(hDC);
            if (hTempDC == NULL)
                {
                theApp.SetGdiEmergency();
                SetTextColor(hDC, crOldText);
                SetBkColor(hDC, crOldBk);
                return;
                }

            HBITMAP hOldBitmap = (HBITMAP) SelectObject(hTempDC,
                    g_ellipses[cx - 1].m_hObject);
            BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSPDxax);
            SelectObject(hTempDC, hOldBitmap);
            DeleteDC(hTempDC);
            }
        else
            if (cx > 0 && cy > 0)
                {
                // Actually, Ellipse() is just no good...  Let's do as much
                // as possible our selves to fix it!  Here we draw the ellipse
                // into a monochrome bitmap to get the shape and then use that
                // as a mask to get the current pattern into the imge.

                HDC hTempDC = CreateCompatibleDC(hDC);
                if (hTempDC == NULL)
                    {
                    theApp.SetGdiEmergency();
                    SetTextColor(hDC, crOldText);
                    SetBkColor(hDC, crOldBk);
                    return;
                    }

                BOOL bRefill = FALSE;

                if (cx > cxShapeBitmap || cy > cyShapeBitmap)
                    {
                    shapeBitmap.DeleteObject();
                    if (shapeBitmap.CreateBitmap(cx, cy, 1, 1, NULL))
                        {
                        cxShapeBitmap = cx;
                        cyShapeBitmap = cy;
                        bRefill = TRUE;
                        }
                    }

                if (shapeBitmap.m_hObject == NULL)
                    {
                    theApp.SetMemoryEmergency();
                    DeleteDC(hTempDC);
                    SetTextColor(hDC, crOldText);
                    SetBkColor(hDC, crOldBk);
                    return;
                    }

                if (cx != cxLastShape || cy != cyLastShape || nLastShape != ellipse)
                    {
                    cxLastShape = cx;
                    cyLastShape = cy;
                    nLastShape = ellipse;
                    bRefill = TRUE;
                    }

                HBITMAP hOldBitmap = (HBITMAP)SelectObject(hTempDC,
                        shapeBitmap.m_hObject);

                if (bRefill)
                    {
                    PatBlt(hTempDC, 0, 0, cx, cy, BLACKNESS);
                    SelectObject(hTempDC, GetStockObject(WHITE_BRUSH));
                    SelectObject(hTempDC, GetStockObject(WHITE_PEN));
                    Ellipse(hTempDC, 0, 0, cx, cy);
                    }

                BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSPDxax);

                SelectObject(hTempDC, hOldBitmap);
                DeleteDC(hTempDC);
                }

    SetTextColor(hDC, crOldText);
    SetBkColor(hDC, crOldBk);
    }

/***************************************************************************/
#ifdef XYZZYZ
void MyRoundRect(HDC hDC, int x1, int y1, int x2, int y2,
                 int nEllipseWidth, int nEllipseHeight, BOOL bFilled)
    {
    int cx = x2 - x1;
    int cy = y2 - y1;

    if (!bFilled)
        {
        RoundRect(hDC, x1, y1, x2, y2, nEllipseWidth, nEllipseHeight);
        return;
        }

    if (cx > 0 && cy > 0)
        {
        HDC hTempDC = CreateCompatibleDC(hDC);

        if (hTempDC == NULL)
            {
            theApp.SetGdiEmergency();
            return;
            }

        BOOL bRefill = FALSE;

        if (cx > cxShapeBitmap || cy > cyShapeBitmap)
            {
            shapeBitmap.DeleteObject();
            if (shapeBitmap.CreateBitmap(cx, cy, 1, 1, NULL))
                {
                cxShapeBitmap = cx;
                cyShapeBitmap = cy;
                bRefill = TRUE;
                }
            }

        if (shapeBitmap.m_hObject == NULL)
            {
            theApp.SetMemoryEmergency();
            DeleteDC(hTempDC);
            return;
            }

        if (cx != cxLastShape || cy != cyLastShape || nLastShape != roundRect)
            {
            cxLastShape = cx;
            cyLastShape = cy;
            nLastShape = roundRect;
            bRefill = TRUE;
            }

        HBITMAP hOldBitmap = (HBITMAP)SelectObject(hTempDC,
                shapeBitmap.m_hObject);

        if (bRefill)
            {
            PatBlt(hTempDC, 0, 0, cx, cy, BLACKNESS);
            SelectObject(hTempDC, GetStockObject(WHITE_BRUSH));
            SelectObject(hTempDC, GetStockObject(WHITE_PEN));
            RoundRect(hTempDC, 0, 0, cx, cy, nEllipseWidth, nEllipseHeight);
            }

        BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSna);
        BitBlt(hDC, x1, y1, cx, cy, hTempDC, 0, 0, DSPao);

        SelectObject(hTempDC, hOldBitmap);
        DeleteDC(hTempDC);
        }
    }
#endif
/***************************************************************************/

void PolyTo(CDC* pDC, CPoint fromPt, CPoint toPt, CSize size)
    {
    CPoint polyPts [6];

    if (toPt.x > fromPt.x)
        {
        polyPts[0].x = polyPts[1].x = fromPt.x;
        polyPts[2].x = toPt.x;
        polyPts[3].x = polyPts[4].x = toPt.x + size.cx;
        polyPts[5].x = fromPt.x + size.cx;
        }
    else
        {
        polyPts[0].x = polyPts[1].x = fromPt.x + size.cx;
        polyPts[2].x = toPt.x + size.cx;
        polyPts[3].x = polyPts[4].x = toPt.x;
        polyPts[5].x = fromPt.x;
        }

    if (toPt.y > fromPt.y)
        {
        polyPts[0].y = polyPts[5].y = fromPt.y;
        polyPts[1].y = fromPt.y + size.cy;
        polyPts[2].y = polyPts[3].y = toPt.y + size.cy;
        polyPts[4].y = toPt.y;
        }
    else
        {
        polyPts[0].y = polyPts[5].y = fromPt.y + size.cy;
        polyPts[1].y = fromPt.y;
        polyPts[2].y = polyPts[3].y = toPt.y;
        polyPts[4].y = toPt.y + size.cy;
        }

    if (pDC)
        pDC->Polygon(polyPts, 6);
    }

/***************************************************************************/

BOOL GetTanPt(CSize size, CPoint delta, CRect& tan)
    {
    int x, y;
    int xExt, yExt, theExt, xTemp;
    CDC dc;
    CBitmap* pOldBitmap, bitmap;

    size.cx += 1;
    size.cy += 1;

    tan.SetRect(0, 0, 0, 0);

    if (!dc.CreateCompatibleDC(NULL))
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    if (!bitmap.CreateCompatibleBitmap(&dc, size.cx, size.cy))
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    VERIFY((pOldBitmap = dc.SelectObject(&bitmap)));

    TRY
        {
        CBrush cBrushWhite(PALETTERGB(0xff, 0xff, 0xff));
        CRect cRectTmp(0,0,size.cx, size.cy);
        dc.FillRect(&cRectTmp, &cBrushWhite);
//    dc.PatBlt(0, 0, size.cx, size.cy, WHITENESS);
        }
    CATCH(CResourceException, e)
        {
        }
    END_CATCH
    dc.SelectStockObject(NULL_PEN);
    dc.SelectStockObject(BLACK_BRUSH);
    Mylipse(dc.m_hDC, 0, 0, size.cx, size.cy, TRUE);

    yExt = 0;
    for (xExt = 0; xExt < size.cx - 1; xExt++)
        {
        if (dc.GetPixel(xExt, 0) == 0)
            break;
        }
    theExt = 10 * xExt;

    if (delta.y == 0)
        {
        tan.SetRect(xExt, 0, xExt, size.cy - 1);
        }
    else
        {
        for (y = 0; y < size.cy; y++)
            {
            for (x = 0; x < size.cx - 1; x++)
                {
                if (dc.GetPixel(x, y) == 0)
                    break;
                }

            xTemp = 10 * x - 10 * y * delta.x / delta.y;
            if (theExt > xTemp)
                {
                xExt = x;
                yExt = y;
                theExt = xTemp;
                }
            else
                if (theExt < xTemp)
                    {
                    break;
                    }
            }

        tan.left = xExt;
        tan.top = yExt;

        for (y = 0; y < size.cy; y++)
            {
            for (x = size.cx - 1; x > 0; x--)
                {
                if (dc.GetPixel(x, y) == 0)
                    break;
                }
            xTemp = 10 * x - 10 * y * delta.x / delta.y;
            if (theExt < xTemp)
                {
                xExt = x;
                yExt = y;
                theExt = xTemp;
                }
            else
                if (theExt > xTemp)
                    {
                    break;
                    }
            }

        tan.right = xExt;
        tan.bottom = yExt;
        }

    dc.SelectObject(pOldBitmap);

    return TRUE;
    }

/***************************************************************************/

void PickupSelection()
    {
    // Time to pick up the bits!
    ASSERT(theImgBrush.m_pImg);

    if (theImgBrush.m_pImg == NULL)
        return;

    CPalette* ppalOld = theImgBrush.SetBrushPalette( &theImgBrush.m_dc, FALSE ); // Background ??
    CDC* pImgDC = CDC::FromHandle( theImgBrush.m_pImg->hDC );

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        TRY {
            CBrush cBrushBk( crRight );
            CRect  cRectTmp( 0, 0, theImgBrush.m_size.cx,
                                   theImgBrush.m_size.cy );

            theImgBrush.m_dc.FillRect( &cRectTmp, &cBrushBk );
            }
        CATCH(CResourceException, e)
            {
            theApp.SetGdiEmergency();
            return;
            }
        END_CATCH

        if (theImgBrush.m_cRgnPolyFreeHandSel.GetSafeHandle())
            {
            theImgBrush.m_dc.SelectClipRgn(&theImgBrush.m_cRgnPolyFreeHandSel);

            theImgBrush.m_dc.StretchBlt( 0, 0, theImgBrush.m_size.cx,
                                               theImgBrush.m_size.cy,
                                       pImgDC, theImgBrush.m_rcSelection.left,
                                               theImgBrush.m_rcSelection.top,
                                               theImgBrush.m_rcSelection.Width(),
                                               theImgBrush.m_rcSelection.Height(),
                                               SRCCOPY );

            theImgBrush.m_dc.SelectClipRgn(NULL);
            }
        }
    else
        {
        theImgBrush.m_dc.BitBlt( 0, 0, theImgBrush.m_size.cx,
                                       theImgBrush.m_size.cy,
                               pImgDC, theImgBrush.m_rcSelection.left,
                                       theImgBrush.m_rcSelection.top, SRCCOPY );
        }

    if (ppalOld)
        theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

    theImgBrush.RecalcMask( crRight );
    }

/***************************************************************************/

void CommitSelection(BOOL bSetUndo)
    {
    if (theImgBrush.m_bMakingSelection)
        return;

    if (! theImgBrush.m_bSmearSel
    &&  ( theImgBrush.m_pImg == NULL
       || theImgBrush.m_bFirstDrag
       || theImgBrush.m_bLastDragWasASmear))
        {
        return;
        }

    if (theImgBrush.m_bLastDragWasFirst
    && (theImgBrush.m_bMoveSel
     || theImgBrush.m_bSmearSel))
        {
        return;
        }

    TRACE1( "CommitSelection(%d)\n", bSetUndo );

    if (bSetUndo)
        {
        HideBrush();
        CRect rectUndo = theImgBrush.m_rcSelection;

        if (theImgBrush.m_bLastDragWasFirst)
            {
            theImgBrush.m_bLastDragWasFirst = FALSE;
            rectUndo |= theImgBrush.m_rcDraggedFrom;
            }
        else
            {
            SetUndo(theImgBrush.m_pImg);
            }

        CImgWnd::c_pImgWndCur->FinishUndo(rectUndo);
        }

    if (CImgTool::GetCurrentID() != IDMX_TEXTTOOL)
        {
        if (theImgBrush.m_bOpaque)
            {
            theImgBrush.BltReplace( theImgBrush.m_pImg,
                                    theImgBrush.m_rcSelection.TopLeft() );
            }
        else
            {
            theImgBrush.BltMatte( theImgBrush.m_pImg,
                                  theImgBrush.m_rcSelection.TopLeft() );
            }
        }

    InvalImgRect ( theImgBrush.m_pImg, &theImgBrush.m_rcSelection );
    CommitImgRect( theImgBrush.m_pImg, &theImgBrush.m_rcSelection );

    DirtyImg( theImgBrush.m_pImg );
    }

/***************************************************************************/

void AddImgWnd(IMG* pimg, CImgWnd* pImgWnd)
    {
    ASSERT(pImgWnd->m_pNextImgWnd == NULL);
    pImgWnd->m_pNextImgWnd = pimg->m_pFirstImgWnd;
    pimg->m_pFirstImgWnd = pImgWnd;
    }

/***************************************************************************/

void GetImgSize(IMG* pImg, CSize& size)
    {
    size.cx = pImg->cxWidth;
    size.cy = pImg->cyHeight;
    }

/***************************************************************************/

BOOL SetImgSize(IMG* pImg, CSize newSize, BOOL bStretch)
    {
    if (newSize.cx != pImg->cxWidth
    ||  newSize.cy != pImg->cyHeight)
        {
        HBITMAP hNewBitmap = CreateCompatibleBitmap( pImg->hDC,
                                                     newSize.cx, newSize.cy );
        if (hNewBitmap == NULL)
            {
            return FALSE;
            }
        HDC hDC = CreateCompatibleDC( pImg->hDC );

        if (hDC == NULL)
            {
            DeleteObject( hNewBitmap );
            return FALSE;
            }
        HBITMAP hOldBitmap = (HBITMAP)SelectObject( hDC, hNewBitmap );

        ASSERT( hOldBitmap );

        HPALETTE hpalOld = NULL;

        if (theApp.m_pPalette
        &&  theApp.m_pPalette->m_hObject)
            {
            hpalOld = SelectPalette( hDC, (HPALETTE)theApp.m_pPalette->m_hObject, FALSE ); // Background ??
            RealizePalette( hDC );
            }

        if (bStretch)
            {
            UINT uStretch = HALFTONE;


            if (pImg->cPlanes * pImg->cBitCount == 1)
                {
                uStretch = BLACKONWHITE;

                if (GetRValue( crLeft )
                ||  GetGValue( crLeft )
                ||  GetBValue( crLeft ))
                    uStretch = WHITEONBLACK;
                }

            SetStretchBltMode( hDC, uStretch );

            StretchCopy( hDC, 0, 0, newSize.cx, newSize.cy,
                   pImg->hDC, 0, 0, pImg->cxWidth, pImg->cyHeight );
            }
        else
            {
            // Fill it with the background color first!
            HBRUSH hBrush  = ::CreateSolidBrush(crRight);

            ASSERT(hBrush);

            if (hBrush)
                {
                HBRUSH hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);

                ASSERT(hOldBrush);

                PatBlt(hDC, 0, 0, newSize.cx, newSize.cy, PATCOPY);

                VERIFY(SelectObject(hDC, hOldBrush) == hBrush);

                DeleteObject(hBrush);
                }

            BitBlt(hDC, 0, 0, newSize.cx, newSize.cy, pImg->hDC, 0, 0, SRCCOPY);
            }

        if (hpalOld)
            SelectPalette( hDC, hpalOld, FALSE ); // Background ??

        VERIFY( SelectObject(       hDC, hOldBitmap) ==    hNewBitmap );
        VERIFY( SelectObject( pImg->hDC, hNewBitmap) == pImg->hBitmap );

        DeleteObject( pImg->hBitmap );
        DeleteDC( hDC );

        pImg->hBitmap  = hNewBitmap;
        pImg->cxWidth  = newSize.cx;
        pImg->cyHeight = newSize.cy;

        pRubberImg = NULL;

        SetupRubber( pImg );

        InvalImgRect(pImg, NULL);

        CImgWnd* pImgWnd = pImg->m_pFirstImgWnd;

        while (pImgWnd)
            {
            pImgWnd->Invalidate( FALSE );
            pImgWnd->CheckScrollBars();

            pImgWnd = pImgWnd->m_pNextImgWnd;
            }
        }

    return TRUE;
    }

/***************************************************************************/

// This may be set to TRUE via the "DriverCanStretch" entry in the INI file.
// Doing so will speed up the graphics editor, but will cause some device
// drivers to crash (hence the FALSE default).
//
BOOL  g_bDriverCanStretch = TRUE;

void StretchCopy( HDC hdcDest, int xDest, int yDest, int cxDest, int cyDest,
                  HDC hdcSrc , int xSrc , int ySrc , int cxSrc , int cySrc )
    {
    if (cxDest == cxSrc && cyDest == cySrc)
        {
        // No point in using the trick if we're not really stretching...

        BitBlt(hdcDest, xDest, yDest, cxDest, cyDest,
               hdcSrc,  xSrc,  ySrc, SRCCOPY);
        }
    else
        if (g_bDriverCanStretch ||
            cxDest < 0 || cyDest < 0 || cxSrc < 0 || cySrc < 0)
            {
            // We can't use the following trick when flipping, but the
            // driver will usually pass things on to GDI here anyway...

            StretchBlt(hdcDest, xDest, yDest, cxDest, cyDest,
                       hdcSrc, xSrc, ySrc, cxSrc, cySrc, SRCCOPY);
            }
        else
            {
            // Some drivers (e.g. Paradise) crash on memory to memory stretches,
            // so we trick them into just using GDI here by not using SRCCOPY...

            PatBlt(hdcDest, xDest, yDest, cxDest, cyDest, BLACKNESS);

            StretchBlt(hdcDest, xDest, yDest, cxDest, cyDest,
                        hdcSrc, xSrc, ySrc, cxSrc, cySrc, DSo);
            }
    }

/***************************************************************************/

void StandardiseCoords(CPoint* s, CPoint* e)
    {
    if (s->x > e->x)
        {
        int tx;

        tx = s->x;
        s->x = e->x;
        e->x = tx;
        }

    if (s->y > e->y)
        {
        int ty;

        ty = s->y;
        s->y = e->y;
        e->y = ty;
        }
    }

/***************************************************************************/

CPalette* MergePalettes( CPalette *pPal1, CPalette *pPal2, int& iAdds )
    {
    int           iPal1NumEntries;
    int           iPal2NumEntries;
    LOGPALETTE256 LogPal1;
    LOGPALETTE256 LogPal2;
    CPalette*     pPalMerged = NULL;

    iAdds = 0;

    if (pPal1 == NULL ||  pPal2 == NULL)
        return NULL;

    iPal1NumEntries = pPal1->GetPaletteEntries( 0, 256, &LogPal1.palPalEntry[0] );
    pPal1->GetPaletteEntries( 0, iPal1NumEntries, &LogPal1.palPalEntry[0] );

    iPal2NumEntries = pPal2->GetPaletteEntries( 0, 256, &LogPal2.palPalEntry[0] );
    pPal2->GetPaletteEntries( 0, iPal2NumEntries, &LogPal2.palPalEntry[0] );

    // check if room left in 1st palette to merge.  If no room, then use 1st palette
    for (int i = 0; i < iPal2NumEntries
                     && iPal1NumEntries < MAX_PALETTE_COLORS; i++)
        {
        for (int j = 0; j < iPal1NumEntries; j++)
            {
            if (LogPal1.palPalEntry[j].peRed   == LogPal2.palPalEntry[i].peRed
            &&  LogPal1.palPalEntry[j].peGreen == LogPal2.palPalEntry[i].peGreen
            &&  LogPal1.palPalEntry[j].peBlue  == LogPal2.palPalEntry[i].peBlue)
                break;
            }

        if (j < iPal1NumEntries)
            continue;  // found one

        // color was not found in 1st palette add it if room
        LogPal1.palPalEntry[iPal1NumEntries++] = LogPal2.palPalEntry[i];
        iAdds++;
        }

    LogPal1.palVersion    = 0x300;
    LogPal1.palNumEntries = (WORD)iPal1NumEntries;

    pPalMerged = new CPalette();

    if (pPalMerged)
        if (! CreateSafePalette(pPalMerged, (LPLOGPALETTE)&LogPal1 ))
            {
            delete pPalMerged;
            pPalMerged = NULL;
            }

    return pPalMerged;
    }

/******************************************************************************/

void AdjustPointForGrid(CPoint *ptPointLocation)
    {
    if (theApp.m_iSnapToGrid != 0)
        {
        int iNextGridOffset;

        iNextGridOffset = ptPointLocation->x % theApp.m_iGridExtent;
        // if distance to next grid is less than 1/2 distance between grids
        // closer to previous grid
        if (iNextGridOffset <= theApp.m_iGridExtent/2)
            {
            iNextGridOffset *= -1; // closer to previous grid location
            }
        else
            {
            iNextGridOffset = theApp.m_iGridExtent -iNextGridOffset; // closer to next grid location
            }
        ptPointLocation->x = ptPointLocation->x + iNextGridOffset;

        // if distance to next grid is less than 1/2 distance between grids
        // closer to previous grid
        iNextGridOffset = ptPointLocation->y % theApp.m_iGridExtent;
        if (iNextGridOffset <= theApp.m_iGridExtent/2)
            {
            iNextGridOffset *= -1; // closer to previous grid location
            }
        else
            {
            iNextGridOffset = theApp.m_iGridExtent -iNextGridOffset; // closer to next grid location
            }

        ptPointLocation->y = ptPointLocation->y + iNextGridOffset;
        }
    }

static unsigned short  bmapHorzBorder [] =
                                { 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0 };

static unsigned short  bmapVertBorder [] =
                                { 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00 };

       CBrush   g_brSelectHorz;
       CBrush   g_brSelectVert;
static CBitmap  m_bmSelectHorz;
static CBitmap  m_bmSelectVert;

void InitCustomData()                           // called once in main
    {
    //
    // no windows critical error message box, return errors to open call
    //
    if (m_bmSelectHorz.CreateBitmap( 8, 8, 1, 1, (LPSTR)bmapHorzBorder ))
        g_brSelectHorz.CreatePatternBrush( &m_bmSelectHorz );

    if (m_bmSelectVert.CreateBitmap( 8, 8, 1, 1, (LPSTR)bmapVertBorder ))
        g_brSelectVert.CreatePatternBrush( &m_bmSelectVert );

    SetErrorMode( SEM_FAILCRITICALERRORS );
    }

//
// make sure global resoures are freed
//
void CustomExit()
    {
    if (g_brSelectHorz.m_hObject)
        g_brSelectHorz.DeleteObject();

    if (m_bmSelectHorz.m_hObject)
        m_bmSelectHorz.DeleteObject();

    if (g_brSelectVert.m_hObject)
        g_brSelectVert.DeleteObject();

    if (m_bmSelectVert.m_hObject)
        m_bmSelectVert.DeleteObject();
    }

/*
int FileTypeFromExtension( const TCHAR far* lpcExt )
    {
    if (*lpcExt == TEXT('.'))        // skip the . in .*
        lpcExt++;

    // must be redone
    return NULL;
    }
*/

CPalette *PBSelectPalette(CDC *pDC, CPalette *pPalette, BOOL bForceBk)
{
        if (!pPalette)
        {
                return(NULL);
        }

        if (IsInPlace())
        {
                bForceBk = TRUE;
        }

        CPalette *ppalOld = pDC->SelectPalette( theApp.m_pPalette, bForceBk );
        pDC->RealizePalette();

        return(ppalOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgfile.h ===
#ifndef __IMGFILE_H__
#define __IMGFILE_H__

// This is a little helper class for writing things to temporary files
// and giving them the correct name after the save suceeds...
//
class CFileSaver
    {
    public:

     CFileSaver(const TCHAR* szFileName); // setup and create temp names
    ~CFileSaver();                       // make sure temp files are gone

    BOOL CanSave() const;               // checks for R/O
    const TCHAR* GetSafeName() const     // return name of file to create
                                    { return m_strTempName; }
    const TCHAR* GetRealName() const     // return name of final file
                                    { return m_strName; }
    BOOL Finish();                      // rename new file as original

    private:

    CString m_strName;
    CString m_strBackupName;
    CString m_strTempName;

    static const TCHAR BASED_CODE c_szAps [];
    };

struct ICONFILEHEADER
    {
    WORD icoReserved;
    WORD icoResourceType;
    WORD icoResourceCount;
    };


struct ICONDIRENTRY
    {
    BYTE nWidth;
    BYTE nHeight;
    BYTE nColorCount;
    BYTE bReserved;
    WORD wReserved1;
    WORD wReserved2;
    DWORD icoDIBSize;
    DWORD icoDIBOffset;
    };

struct CURSORFILEHEADER
    {
    WORD curReserved;
    WORD curResourceType;
    WORD curResourceCount;
    };


struct CURSORDIRENTRY
    {
    BYTE nWidth;
    BYTE nHeight;
    WORD wReserved;
    WORD curXHotspot;
    WORD curYHotspot;
    DWORD curDIBSize;
    DWORD curDIBOffset;
    };



extern int MkPath(TCHAR *szPath);
extern void MkFullPath(CString& strFullPath, const CString& strRelPath,
    BOOL bPathOnly = FALSE);
extern BOOL OpenSubFile(CFile& file, const CFileSaver& saver, UINT nOpenFlags,
    CFileException* pError = NULL);



/////////////////////////////////////////////////////////////////////////

#endif // __IMGFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgwnd.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "tedit.h"
#include "t_text.h"
#include "t_fhsel.h"
#include "toolbox.h"
#include "undo.h"
#include "props.h"
#include "cmpmsg.h"
#include "imgdlgs.h"
#include "ferr.h"
#include "thumnail.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CImgWnd, CWnd)

#include "memtrace.h"

/***************************************************************************/
// helper fns

static CTedit *_GetTextEdit()
{
    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        if ((pTextTool != NULL) &&
            pTextTool->IsKindOf(RUNTIME_CLASS( CTextTool )))
            {
            CTedit* pTextEdit = pTextTool->GetTextEditField();

            if ((pTextEdit != NULL) &&
                pTextEdit->IsKindOf(RUNTIME_CLASS( CTedit )))
                {
                    return pTextEdit;
                }
            }
        }
    return NULL;
}

BOOL IsUserEditingText()
    {
    return (_GetTextEdit() != NULL);
    }

BOOL TextToolProcessed( UINT nMessage )
    {
    CTedit *pTextEdit = _GetTextEdit();
    if (pTextEdit)
        {
        pTextEdit->SendMessage( WM_COMMAND, nMessage );
        return TRUE;
        }
    return FALSE;
    }

/***************************************************************************/

BEGIN_MESSAGE_MAP(CImgWnd, CWnd)
    ON_WM_CREATE()
#if 0
    ON_WM_DESTROY()
#endif
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_WM_PAINT()
    ON_WM_SIZE()
    ON_WM_HSCROLL()
    ON_WM_VSCROLL()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_LBUTTONUP()
    ON_WM_RBUTTONDOWN()
    ON_WM_RBUTTONDBLCLK()
    ON_WM_RBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_KEYDOWN()
    ON_WM_KEYUP()
    ON_WM_TIMER()
    ON_WM_CANCELMODE()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_DESTROYCLIPBOARD()
    ON_WM_PALETTECHANGED()
    ON_WM_SETCURSOR()
    ON_WM_MOUSEWHEEL ()
END_MESSAGE_MAP()

/***************************************************************************/

CRect  rcDragBrush;

CImgBrush  theBackupBrush;

CImgWnd*  g_pMouseImgWnd  = NULL;
CImgWnd*  g_pDragBrushWnd = NULL;

// Current Image Viewer
CImgWnd*          CImgWnd::c_pImgWndCur     = NULL;
CDragger*         CImgWnd::c_pResizeDragger = NULL;
CTracker::STATE   CImgWnd::c_dragState      = CTracker::nil;

// Mouse Tracking Information
MTI   mti;
BOOL  bIgnoreMouse;

/***************************************************************************/

CImgWnd::CImgWnd(IMG* pImg)
    {
    m_pNextImgWnd = NULL;
    m_nZoom       = 1;
    m_nZoomPrev   = 4;
    m_xScroll     = 0;
    m_yScroll     = 0;
    m_LineX       = 1;
    m_LineY       = 1;
    m_ptDispPos.x = -1;
    m_ptDispPos.y = -1;
    c_pImgWndCur  = this;
    m_pwndThumbNailView = NULL;
    m_wClipboardFormat = 0;
    m_hPoints     = NULL;
    m_WheelDelta = 0;
    ASSERT(pImg != NULL);
    m_pImg = pImg;
    m_pImg->m_nLastChanged = -1;
    }

/***************************************************************************/

CImgWnd::CImgWnd(CImgWnd *pImgWnd)
    {
    m_pImg        = pImgWnd->m_pImg;
    m_pNextImgWnd = pImgWnd->m_pNextImgWnd;
    m_nZoom       = pImgWnd->m_nZoom;
    m_nZoomPrev   = pImgWnd->m_nZoomPrev;
    m_xScroll     = pImgWnd->m_xScroll,
    m_yScroll     = pImgWnd->m_yScroll;
    m_ptDispPos   = pImgWnd->m_ptDispPos;
    m_pwndThumbNailView = NULL;
    m_wClipboardFormat = 0;
    m_hPoints     = NULL;
    }

/***************************************************************************/

CImgWnd::~CImgWnd()
    {
    if (c_pImgWndCur == this)
        c_pImgWndCur = NULL;

    if (g_pMouseImgWnd == this)
        g_pMouseImgWnd = NULL;

    HideBrush();
    fDraggingBrush = FALSE;

    g_bBrushVisible = FALSE;

    if (g_pDragBrushWnd == this)
        {
        g_pDragBrushWnd = NULL;
        }

    if (m_hPoints)
        {
        ::GlobalFree( m_hPoints );
        m_hPoints = NULL;
        }
    }

/***************************************************************************/

BOOL CImgWnd::Create( DWORD dwStyle, const RECT& rect,
                      CWnd* pParentWnd, UINT nID)
    {
    static CString  sImgWndClass;

    if (sImgWndClass.IsEmpty())
        sImgWndClass = AfxRegisterWndClass( CS_DBLCLKS );

    ASSERT( ! sImgWndClass.IsEmpty() );

    dwStyle |= WS_CLIPSIBLINGS;

    return CWnd::Create( sImgWndClass, NULL, dwStyle, rect, pParentWnd, nID );
    }

/***************************************************************************/

int CImgWnd::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    if (m_pImg)
        AddImgWnd( m_pImg, this );

    return CWnd::OnCreate(lpCreateStruct);
    }

/***************************************************************************/

#if 0
void CImgWnd::OnDestroy()
    {
    if (c_pImgWndCur == this)
        c_pImgWndCur = NULL;

    HideBrush();
    fDraggingBrush = FALSE;

    CWnd::OnDestroy();
    }
#endif

/***************************************************************************/

void CImgWnd::OnPaletteChanged(CWnd *pPaletteWnd)
{
#if 0
    // obviously this never gets hit or somebody would have realized by now...
    CImgWnd::OnPaletteChanged(pPaletteWnd);
#endif
    Invalidate();
}


/***************************************************************************/

BOOL CImgWnd::OnSetCursor(CWnd *pWnd, UINT nHitTest, UINT message)
{
        if (nHitTest==HTCLIENT && pWnd->m_hWnd==m_hWnd)
        {
                // We do our own cursor stuff in our own client area, but not in the
                // text box
                return(TRUE);
        }

        return((BOOL)Default());
}

/***************************************************************************/

void CImgWnd::OnWindowPosChanging( WINDOWPOS FAR* lpwndpos )
    {
    CWnd::OnWindowPosChanging( lpwndpos );
    }

/***************************************************************************/
// Image View Painting Functions
//

void CImgWnd::OnPaint()
    {
    CPaintDC dc(this);

    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (m_pImg == NULL)
        return;

    if (g_pMouseImgWnd == this)
        CImgTool::HideDragger( this );

    CPalette* ppalOld = SetImgPalette( &dc, FALSE );

    DrawBackground( &dc, (CRect*)&dc.m_ps.rcPaint );
    DrawImage     ( &dc, (CRect*)&dc.m_ps.rcPaint );
    DrawTracker   ( &dc, (CRect*)&dc.m_ps.rcPaint );

    if (g_pMouseImgWnd == this)
        CImgTool::ShowDragger( this );

    if (m_pwndThumbNailView != NULL)
        m_pwndThumbNailView->RefreshImage();

    if (ppalOld)
        dc.SelectPalette( ppalOld, FALSE );
    }

/***************************************************************************/

BOOL CImgWnd::OnCmdMsg( UINT nID, int nCode, void* pExtra,
                        AFX_CMDHANDLERINFO* pHandlerInfo )
    {
    if (nCode == CN_COMMAND)
        {
        switch (nID)
            {
            case IDMX_VS_PAGEUP:
                SendMessage( WM_VSCROLL, SB_PAGEUP, 0L );
                return TRUE;


            case IDMX_VS_PAGEDOWN:
                SendMessage( WM_VSCROLL, SB_PAGEDOWN, 0L );
                return TRUE;


            case IDMX_HS_PAGEUP:
                SendMessage( WM_HSCROLL, SB_PAGEUP, 0L );
                return TRUE;


            case IDMX_HS_PAGEDOWN:
                SendMessage( WM_HSCROLL, SB_PAGEDOWN, 0L );
                return TRUE;

            }

        CImgTool* pImgTool = CImgTool::FromID( nID );

        if (pImgTool != NULL)
            {
            pImgTool->Select();
            return TRUE;
            }
        }
    return CWnd::OnCmdMsg( nID, nCode, pExtra, pHandlerInfo );
    }


void CImgWnd::GetDrawRects(const CRect* pPaintRect, const CRect* pReqDestRect,
                CRect& srcRect, CRect& destRect)
{
        // Find the sub-rectangle of srcRect that corresponds to
        // the pPaintRect sub-rectangle of destRect.
        srcRect         = *pPaintRect;
        srcRect.right  += m_nZoom - 1;
        srcRect.bottom += m_nZoom - 1;

        ClientToImage( srcRect );

        srcRect.left = max(0, srcRect.left);
        srcRect.top  = max(0, srcRect.top );

        srcRect.right  = min(m_pImg->cxWidth , srcRect.right );
        srcRect.bottom = min(m_pImg->cyHeight, srcRect.bottom);

        if (pReqDestRect == NULL)
        {
                destRect = srcRect;
                ImageToClient( destRect );
        }
        else
        {
                destRect = *pReqDestRect;
        }
}


/***************************************************************************/
// Draw the actual image 'a bitmap'.  Drawing is
// optimized to only deal with the pixels inside paintRect.  This function
// reduces flashing by drawing the image and optional grid in an off-screen
// bitmap and then transfering that bitmap to the screen.
//
void CImgWnd::DrawImage( CDC* pDC, const CRect* pPaintRect,
                                         CRect* pDestRect, BOOL bDoGrid )
    {
    ASSERT(    pDC != NULL );
    ASSERT( m_pImg != NULL );

    CRect destRect;
    CRect srcRect;

    GetDrawRects(pPaintRect, pDestRect, srcRect, destRect);

    if (srcRect.Width() <= 0 || srcRect.Height() <= 0)
        {
        // Nothing to paint...
        return;
        }

    if (! IsGridVisible() && m_nZoom == 1)
        {
        // Optimize the easy case...  (Can't speed up magnified views
        // because of the bogus hack we have to do in StretchCopy.)

        if (theApp.m_pPalette
        && ((m_pImg->cPlanes * m_pImg->cBitCount) == 1))
            {
            pDC->SetTextColor( PALETTEINDEX( 0 ) );
            pDC->SetBkColor  ( PALETTEINDEX( 1 ) );
            }


        BitBlt(pDC->m_hDC, destRect.left   , destRect.top,
                           destRect.Width(), destRect.Height(),
              m_pImg->hDC,  srcRect.left   , srcRect.top, SRCCOPY);

        return;
        }

    CDC tempDC;
    CBitmap      tempBitmap;
    CBitmap* pOldTempBitmap;

    if (! tempDC.CreateCompatibleDC(pDC)
    ||  ! tempBitmap.CreateCompatibleBitmap(pDC, destRect.Width() + 1,
                                                 destRect.Height() + 1))
        {
        theApp.SetGdiEmergency(FALSE);
        return;
        }

    pOldTempBitmap = tempDC.SelectObject(&tempBitmap);

    ASSERT(pOldTempBitmap != NULL);

    CPalette* pOldPalette = SetImgPalette( &tempDC, FALSE ); // Background ??

    // If we're zoomed in, use COLORONCOLOR for easy pixel-by-pixel editing
    // Otherwise use HALFTONE for nice appearance
    if (m_nZoom < 2)
    {
        tempDC.SetStretchBltMode(HALFTONE);
    }
    else
    {
        tempDC.SetStretchBltMode(COLORONCOLOR);
    }


    if (m_pImg->cPlanes * m_pImg->cBitCount == 1)
        {
        tempDC.SetTextColor( RGB( 0x00, 0x00, 0x00 ));
        tempDC.SetBkColor  ( RGB( 0xFF, 0xFF, 0xFF ));
        }

    // Bitmaps...
    StretchCopy(tempDC.m_hDC, 0, 0, destRect.Width(), destRect.Height(),
                 m_pImg->hDC,       srcRect.left, srcRect.top,
                                    srcRect.Width(), srcRect.Height());
    // Draw the grid...
    if (IsGridVisible() && bDoGrid)
        DrawGrid( &tempDC, srcRect, destRect );

    // Transfer to the screen...
    pDC->BitBlt(destRect.left, destRect.top, destRect.Width(),
                               destRect.Height(), &tempDC, 0, 0, SRCCOPY);
    // Cleanup...
    if (pOldPalette)
        tempDC.SelectPalette( pOldPalette, FALSE ); // Background ??

    tempDC.SelectObject(pOldTempBitmap);
    }

/***************************************************************************/
// Draw a border and bevel around the image and fill the rest of
// the window with gray.  If pPaintRect is not NULL, painting is
// optimized to only draw with the rectangle.
//
void CImgWnd::DrawBackground(CDC* pDC, const CRect* pPaintRect)
    {
    ASSERT( pDC != NULL );

    CRect clientRect;

    if (pPaintRect == NULL)
        {
        // Draw everything...
        GetClientRect( &clientRect );
        pPaintRect = &clientRect;
        }

    CRect srcRect;
    CRect imageRect;

    GetDrawRects(pPaintRect, NULL, srcRect, imageRect);

    // Erase area around image, border, and bevel...
    CBrush* pOldBrush = pDC->SelectObject( GetSysBrush( COLOR_APPWORKSPACE ) );

    if (imageRect.top > pPaintRect->top)
        {
        // Top...

        pDC->PatBlt(pPaintRect->left, pPaintRect->top, pPaintRect->Width(),
                      imageRect.top - pPaintRect->top, PATCOPY);
        }

    if (imageRect.left > pPaintRect->left)
        {
        // Left...

        pDC->PatBlt(pPaintRect->left, imageRect.top,
            imageRect.left - pPaintRect->left, imageRect.Height(), PATCOPY);
        }

    if (imageRect.right < pPaintRect->right)
        {
        // Right...

        pDC->PatBlt(imageRect.right, imageRect.top,
            pPaintRect->right - imageRect.right, imageRect.Height(), PATCOPY);
        }

    if (imageRect.bottom < pPaintRect->bottom)
        {
        // Bottom...

        pDC->PatBlt(pPaintRect->left, imageRect.bottom, pPaintRect->Width(),
            pPaintRect->bottom - imageRect.bottom, PATCOPY);
        }

    pDC->SelectObject(pOldBrush);
    }

/***************************************************************************/

void CImgWnd::SetImg(IMG* pImg)
    {
    m_pNextImgWnd = pImg->m_pFirstImgWnd;
    pImg->m_pFirstImgWnd = this;
    m_pImg = pImg;
    }

/***************************************************************************/

CPalette* CImgWnd::SetImgPalette( CDC* pdc, BOOL bForce )
    {
    CPalette* ppal = NULL;

        // If we do not realize as a background brush when in-place, we can get
        // an infinite recursion of the container and us trying to realize the
        // palette
        if (theApp.m_pwndInPlaceFrame)
        {
                bForce = TRUE;
        }

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        {
        ppal = pdc->SelectPalette( theApp.m_pPalette, bForce );

        pdc->RealizePalette();
        }
    return ppal;
    }

/***************************************************************************/

HPALETTE CImgWnd::SetImgPalette( HDC hdc, BOOL bForce )
    {
    HPALETTE hpal = NULL;

        // If we do not realize as a background brush when in-place, we can get
        // an infinite recursion of the container and us trying to realize the
        // palette
        if (theApp.m_pwndInPlaceFrame)
        {
                bForce = TRUE;
        }

    if (theApp.m_pPalette
    &&  theApp.m_pPalette->m_hObject)
        {
        hpal = ::SelectPalette( hdc, (HPALETTE)theApp.m_pPalette->m_hObject, bForce );

        ::RealizePalette( hdc );
        }
    return hpal;
    }

/***************************************************************************/

void CImgWnd::SetZoom(int nZoom)
    {
    if (m_nZoom > 1)
        m_nZoomPrev = m_nZoom;

    CommitSelection(TRUE);

    if (nZoom > 1)
        {
        // deselect the text tool if it's around
        CImgTool* pImgTool = CImgTool::GetCurrent();

        if (pImgTool != NULL && CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
            CImgTool::Select(IDMB_PENCILTOOL);
            }
        }

    HideBrush();
    SetupRubber( m_pImg );
    EraseTracker();
    theImgBrush.m_pImg = NULL;
    DrawTracker();

    CPBView* pView = (CPBView*)GetParent();

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        if (nZoom == 1)
            pView->HideThumbNailView();
        else
            pView->ShowThumbNailView();

        Invalidate(FALSE);

    m_nZoom = nZoom;
    }

/***************************************************************************/

void CImgWnd::SetScroll(int xPos, int yPos)
    {
    if (xPos > 0)
        xPos = 0;
    else
        if (xPos < -m_pImg->cxWidth)
            xPos = -m_pImg->cxWidth;

    if (yPos > 0)
        yPos = 0;
    else
        if (yPos < -m_pImg->cyHeight)
            yPos = -m_pImg->cyHeight;

    m_xScroll = xPos;
    m_yScroll = yPos;

    Invalidate( FALSE );

    CheckScrollBars();
    }

/***************************************************************************/

void CImgWnd::CheckScrollBars()
    {
    // Tacky recursion blocker is required because this is called from
    // the OnSize handler and turning scroll bars on or off changes
    // the size of our window...
    static BOOL  bInHere = FALSE;

    if (bInHere)
        return;

    bInHere = TRUE;

    int cxVScrollBar = GetSystemMetrics( SM_CXVSCROLL );
    int cyHScrollBar = GetSystemMetrics( SM_CYHSCROLL );

    // Figure the client area size if there were no scroll bars...
    CRect clientRect;

    GetClientRect( &clientRect );

    int cxWidth  = clientRect.Width();
    int cyHeight = clientRect.Height();

    BOOL hHasHBar = ((GetStyle() & WS_HSCROLL) != 0);
    BOOL bHasVBar = ((GetStyle() & WS_VSCROLL) != 0);

    if (hHasHBar)
        cyHeight += cyHScrollBar;

    if (bHasVBar)
        cxWidth += cxVScrollBar;

    // Figure the size of the thing we are scrolling (the subject)...
    CSize subjectSize;

    GetImgSize( m_pImg, subjectSize );

    int iTrackerSize = 2 * CTracker::HANDLE_SIZE;

    subjectSize.cx = (subjectSize.cx * m_nZoom ) + iTrackerSize;
    subjectSize.cy = (subjectSize.cy * m_nZoom ) + iTrackerSize;

    m_LineX = (subjectSize.cx + 31) / 32;
    m_LineY = (subjectSize.cy + 31) / 32;

    // Nasty loop takes care of case where we only need a vertical
    // scroll bar because we added a horizontal scroll bar and
    // vice versa...  (Will only ever loop twice.)
    BOOL bNeedHBar = FALSE;
    BOOL bNeedVBar = FALSE;
    BOOL bChange;

    do  {
        bChange = FALSE;

        if (! bNeedVBar && subjectSize.cy > cyHeight)
            {
            bChange   = TRUE;
            bNeedVBar = TRUE;
            cxWidth  -= cxVScrollBar;
            }

        if (! bNeedHBar && subjectSize.cx > cxWidth)
            {
            bChange   = TRUE;
            bNeedHBar = TRUE;
            cyHeight -= cyHScrollBar;
            }
        } while (bChange);

    SetRedraw( FALSE );

    SCROLLINFO si;

    si.cbSize = sizeof( si );
    si.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS;
    si.nMin   = 0;

    // We subtract 1 because subjectSize is the size we want, so the range
    // should be 0 to subjectSize-1
    si.nMax   = (subjectSize.cx - 1) / m_nZoom;
    si.nPage  = cxWidth / m_nZoom;
    si.nPos   = -m_xScroll;
    SetScrollInfo( SB_HORZ, &si, FALSE );

    si.nMax   = (subjectSize.cy - 1) / m_nZoom;
    si.nPage  = cyHeight / m_nZoom;
    si.nPos   = -m_yScroll;
    SetScrollInfo( SB_VERT, &si, FALSE );

        si.fMask = SIF_POS;
        GetScrollInfo( SB_HORZ, &si );
        if ( -m_xScroll != si.nPos )
                m_xScroll = -si.nPos ;
        GetScrollInfo( SB_VERT, &si );
        if ( -m_yScroll != si.nPos )
                m_yScroll = -si.nPos;

    SetRedraw ( TRUE  );
    Invalidate( FALSE );

    bInHere = FALSE;
    }

/***************************************************************************/

void CImgWnd::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar*)
    {
    OnScroll(FALSE, nSBCode, nPos);
    }

/***************************************************************************/

void CImgWnd::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar*)
    {
    OnScroll(TRUE, nSBCode, nPos);
    }

/***************************************************************************/

void CImgWnd::OnScroll(BOOL bVert, UINT nSBCode, UINT nPos)
    {
    SCROLLINFO ScrollInfo;

    ScrollInfo.cbSize = sizeof( ScrollInfo );
    ScrollInfo.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS;

    GetScrollInfo( (bVert? SB_VERT: SB_HORZ), &ScrollInfo );
        int iScroll = ScrollInfo.nPage/4;
    int iNewPos = ScrollInfo.nPos;

    switch (nSBCode)
        {
        case SB_TOP:
            iNewPos = 0;
            break;

        case SB_BOTTOM:
            iNewPos = ScrollInfo.nMax;
            break;

        case SB_LINEDOWN:
            iNewPos += iScroll;
            break;

        case SB_LINEUP:
            iNewPos -= iScroll;
            break;

        case SB_PAGEDOWN:
            iNewPos += iScroll * 4;
            break;

        case SB_PAGEUP:
            iNewPos -= iScroll * 4;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            iNewPos = nPos;
            break;
        }

    if (iNewPos < ScrollInfo.nMin)
        iNewPos = 0;
    else
        if (iNewPos > ScrollInfo.nMax-(int)ScrollInfo.nPage+1)
            iNewPos = ScrollInfo.nMax-(int)ScrollInfo.nPage+1;

    iScroll = -(iNewPos - ScrollInfo.nPos);
        Invalidate(FALSE);

    if (bVert)
        m_yScroll = -iNewPos;
    else
        m_xScroll = -iNewPos;

    ScrollInfo.fMask = SIF_POS;
    ScrollInfo.nPos  = iNewPos;
    SetScrollInfo( (bVert? SB_VERT: SB_HORZ), &ScrollInfo, TRUE );
    }

/***************************************************************************/
BOOL CImgWnd::OnMouseWheel (UINT nFlags, short zDelta, CPoint pt)
    {
    //
    // Don't handle zoom and datazoom.
    //

    if (nFlags & (MK_SHIFT | MK_CONTROL))
        {
        return FALSE;
        }

    int nBar;
    int *pScroll;

    if (GetWindowLong(GetSafeHwnd(), GWL_STYLE) & WS_VSCROLL)
    {
        nBar = SB_VERT;
        pScroll = &m_yScroll;
    }
    else
    {
        nBar = SB_HORZ;
        pScroll = &m_xScroll;
    }

    SCROLLINFO ScrollInfo;

    ScrollInfo.cbSize = sizeof( ScrollInfo );
    ScrollInfo.fMask  = SIF_RANGE | SIF_PAGE | SIF_POS;

    GetScrollInfo( nBar, &ScrollInfo );
    m_WheelDelta -= zDelta;
    if (abs(m_WheelDelta) >= WHEEL_DELTA)
        {
        int iScroll = ScrollInfo.nPage/4 * (m_WheelDelta/WHEEL_DELTA);
        int iNewPos = ScrollInfo.nPos + iScroll;


        if (iNewPos < ScrollInfo.nMin)
           iNewPos = 0;
        else if (iNewPos > ScrollInfo.nMax-(int)ScrollInfo.nPage+1)
           iNewPos = ScrollInfo.nMax-(int)ScrollInfo.nPage+1;

        Invalidate(FALSE);

        *pScroll = -iNewPos;

        ScrollInfo.fMask = SIF_POS;
        ScrollInfo.nPos  = iNewPos;
        SetScrollInfo( nBar, &ScrollInfo, TRUE );
        m_WheelDelta= m_WheelDelta % WHEEL_DELTA;
        CImgTool* pImgTool = CImgTool::GetCurrent();
        mti.ptPrev = mti.pt;
        mti.pt = pt;
        pImgTool->OnMove (this, &mti);
    }


    return TRUE;
    }
/***************************************************************************/

void CImgWnd::PrepareForBrushChange(BOOL bPickup, BOOL bErase)
    {
    if (theImgBrush.m_pImg != NULL
    &&  theImgBrush.m_bFirstDrag)
        {
        if (bPickup)
            PickupSelection();

        SetUndo(m_pImg);

        theImgBrush.m_bLastDragWasFirst = TRUE;
        theImgBrush.m_bFirstDrag        = FALSE;
        theImgBrush.m_rcDraggedFrom     = rcDragBrush;

        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
            HideBrush();
            bErase = FALSE;
            }

        if (bErase)
            {
            // Clear the background...
            HideBrush();

            FillImgRect( m_pImg->hDC, &theImgBrush.m_rcDraggedFrom, crRight );

            CommitImgRect(m_pImg, &theImgBrush.m_rcDraggedFrom);
            InvalImgRect (m_pImg, &theImgBrush.m_rcDraggedFrom);

            FinishUndo(theImgBrush.m_rcDraggedFrom);

            MoveBrush(theImgBrush.m_rcSelection);
            }
        }
    }

/***************************************************************************/

void CImgWnd::OnCancelMode()
    {
    CmdCancel();
    }

/***************************************************************************/

void CImgWnd::CmdCancel()
    {
    // This will:
    //  Erase the size indicator on the status bar.
    //  Reset the mouse cursor to an arrow.
    //  Release the capture.
    //  Cancel (and undo) any drawing operation in progress.
    //  Cancel the Pick Color command if it's active.
    //  If there's a selection, will set to whole image and select prev tool
    ClearStatusBarSize();

    mti.fLeft = mti.fRight = FALSE;

    if (c_pResizeDragger != NULL)
        {
        EndResizeOperation();
        bIgnoreMouse = TRUE;
        return;
        }

    CImgTool* pImgTool = CImgTool::GetCurrent();

    if (GetCapture() == this || pImgTool->IsMultPtOpInProgress())
        {
        // Cancel dragging or multi-point operation in progress
        BOOL bWasMakingSelection = theImgBrush.m_bMakingSelection;

        ZoomedInDP(WM_CANCEL, 0, CPoint(0, 0));

        SetCursor(LoadCursor(NULL, IDC_ARROW + 11));

        if (! bWasMakingSelection)
            CancelPainting();

        bIgnoreMouse = TRUE;
        }
    else
        if (pImgTool->IsToggle()
        ||  CImgTool::GetCurrentID() == IDMB_PICKTOOL
        ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL
        ||  CImgTool::GetCurrentID() == IDMZ_BRUSHTOOL
        ||  CImgTool::GetCurrentID() == IDMB_POLYGONTOOL
        ||  CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
            pImgTool->OnCancel( this );
            }

    if (GetKeyState( VK_LBUTTON ) < 0 || GetKeyState( VK_RBUTTON) < 0 )
        bIgnoreMouse = TRUE;

    SetToolCursor();
    }

/***************************************************************************/

void CImgWnd::CmdSel2Bsh()
    {
    if (! g_bCustomBrush)
        {
        if (theImgBrush.m_pImg == NULL)
            {
            // No selection, turn the whole image into a brush!
            MakeBrush( m_pImg->hDC, CRect( 0, 0, m_pImg->cxWidth,
                                                 m_pImg->cyHeight ) );
            }

        if (theImgBrush.m_bFirstDrag)
            {
            // Time to pick up the bits!
            ASSERT(theImgBrush.m_pImg == m_pImg);

            PickupSelection();
            }

        InvalImgRect(theImgBrush.m_pImg, NULL); // erase the selection tracker
        CImgTool::Select(IDMZ_BRUSHTOOL);
        SetCombineMode(combineMatte);

        g_bCustomBrush = TRUE;

        theImgBrush.m_pImg = NULL;
        theImgBrush.CenterHandle();
        }
    else
        if (CImgTool::GetCurrentID() == IDMZ_BRUSHTOOL)
            {
            CImgTool::GetCurrent()->OnCancel(this);
            }
    }

/***************************************************************************/
// Coordinate Translation and Calculation Functions
//
//
// Convert a point or rect in image view client coordinates to image
// coordinates taking magnification and scrolling into account.
//
void CImgWnd::ClientToImage(CPoint& point)
    {
    int iHandleSize = CTracker::HANDLE_SIZE;

    point.x = (point.x - iHandleSize) / m_nZoom - m_xScroll;
    point.y = (point.y - iHandleSize) / m_nZoom - m_yScroll;
    }

/***************************************************************************/

void CImgWnd::ClientToImage(CRect& rect)
    {
    ClientToImage(rect.TopLeft());
    ClientToImage(rect.BottomRight());
    }

/***************************************************************************/
// Convert a point or rect in image coordinates to image view client
// coordinates taking magnification and scrolling into account.
//
void CImgWnd::ImageToClient(CPoint& point)
    {
    int iHandleSize = CTracker::HANDLE_SIZE;

    point.x = (point.x + m_xScroll) * m_nZoom + iHandleSize;
    point.y = (point.y + m_yScroll) * m_nZoom + iHandleSize;
    }

/***************************************************************************/

void CImgWnd::ImageToClient(CRect& rect)
    {
    ImageToClient(rect.TopLeft());
    ImageToClient(rect.BottomRight());
    }

/***************************************************************************/
// Return a rectangle in image view coordinates surrounding the image
// taking magnification, scrolling, and the grid into account.

void CImgWnd::GetImageRect( CRect& imageRect )
    {
    imageRect.SetRect( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight );

    ImageToClient( imageRect );

    if (IsGridVisible())
        {
        imageRect.right  += 1;
        imageRect.bottom += 1;
        }
    }

/***************************************************************************/

CRect CImgWnd::GetDrawingRect( void )
    {
    CRect rectImage;
    CRect rectClient;

    GetImageRect (  rectImage );
    GetClientRect( &rectClient );

    rectImage &= rectClient;
    rectImage.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

    return ( rectImage );
    }

/***************************************************************************/

void CImgWnd::OnSetFocus(CWnd* pOldWnd)
    {
    if (m_pImg == NULL)
        {
        // Time to die...  (Our img was deleted, so we'll be disappearing
        // soon.  Don't bother to do any of the rest of this function...
        return;
        }

        Invalidate();
        BringWindowToTop(); // so updates happen here first

    if (c_pImgWndCur != this
    &&  c_pImgWndCur != NULL)
        c_pImgWndCur->EraseTracker();

    c_pImgWndCur = this;

    SelectImg( m_pImg );
        UpdateWindow();

    CWnd::OnSetFocus( pOldWnd );

    DrawTracker();
    }

/***************************************************************************/

void CImgWnd::OnKillFocus(CWnd* pNewWnd)
    {
        Invalidate();

    if (theImgBrush.m_pImg == NULL)
        HideBrush();

    if (GetCapture() == this)
        CmdCancel();

    CWnd::OnKillFocus(pNewWnd);
    }

/***************************************************************************/

void CImgWnd::OnSize(UINT nType, int cx, int cy)
    {
    CheckScrollBars();

    CWnd::OnSize(nType, cx, cy);
    }

/***************************************************************************/

BOOL CImgWnd::OnMouseDown(UINT nFlags)
    {
    if (GetFocus() != this)
        {
        SetFocus();
        SetActiveWindow();
        }

    if ((nFlags & (MK_LBUTTON | MK_RBUTTON)) == (MK_LBUTTON | MK_RBUTTON))
        {
        ClearStatusBarSize();

        BOOL bWasMakingSelection = theImgBrush.m_bMakingSelection;

        ZoomedInDP(WM_CANCEL, 0, CPoint(0, 0));

        SetCursor(LoadCursor(NULL, IDC_ARROW + 11));

        if (! bWasMakingSelection)
            CancelPainting();

        bIgnoreMouse = TRUE;
        return FALSE;
        }

    return TRUE;
    }

/***************************************************************************/

BOOL CImgWnd::OnMouseMessage( UINT nFlags )
    {
    if (bIgnoreMouse /*|| GetFocus() != this*/)
        {
        if ((nFlags & (MK_LBUTTON | MK_RBUTTON)) == 0)
            {
            bIgnoreMouse = FALSE;
            SetToolCursor();
            }
        else
            {
            SetCursor( LoadCursor( NULL, IDC_ARROW ) );
            }

        return FALSE;
        }

    if ((CImgTool::GetCurrentID() != IDMB_PICKTOOL)
    &&  (CImgTool::GetCurrentID() != IDMB_PICKRGNTOOL))
        SetupRubber(m_pImg);

    const MSG* pMsg = GetCurrentMessage();
    mti.fCtrlDown = (nFlags & MK_CONTROL);
    ZoomedInDP( pMsg->message, (DWORD)pMsg->wParam, CPoint( (DWORD)pMsg->lParam ) );

    return TRUE;
    }

/***************************************************************************/

void CImgWnd::OnLButtonDown( UINT nFlags, CPoint point )
    {
    CWnd::OnLButtonDown( nFlags, point );

    if (OnMouseDown( nFlags ))
        {
        OnMouseMessage( nFlags );
        }
    }

/***************************************************************************/

void CImgWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
    {
    CRect rect;
    GetImageRect(rect);

    // When inside the image, a double click is the same as a single click
    OnLButtonDown(nFlags, point);
    }

/***************************************************************************/

void CImgWnd::OnLButtonUp(UINT nFlags, CPoint point)
    {
    CWnd::OnLButtonUp(nFlags, point);

    OnMouseMessage(nFlags);
    }

/***************************************************************************/

void CImgWnd::OnRButtonDown(UINT nFlags, CPoint point)
    {
    CWnd::OnRButtonDown(nFlags, point);

    if (OnMouseDown(nFlags))
        {
        OnMouseMessage(nFlags);
        }
    }


/***************************************************************************/

void CImgWnd::OnRButtonDblClk(UINT nFlags, CPoint point)
    {
    // A right button double click is the same as a right button single click
    OnRButtonDown(nFlags, point);
    }


/***************************************************************************/

void CImgWnd::OnRButtonUp(UINT nFlags, CPoint point)
    {
    CWnd::OnRButtonUp(nFlags, point);

    OnMouseMessage(nFlags);
    }


/***************************************************************************/

void CImgWnd::OnMouseMove(UINT nFlags, CPoint point)
    {
    CWnd::OnMouseMove(nFlags, point);

    if (g_pMouseImgWnd != this
    &&  g_pMouseImgWnd != NULL)
        {
        CImgTool::GetCurrent()->OnLeave( g_pMouseImgWnd, &mti );
        g_pMouseImgWnd = NULL;
        }

    ClientToImage( point );
    m_ptDispPos = point;

    if (g_pMouseImgWnd == NULL)
        {
        MTI mtiEnter;

        mtiEnter.pt        = point;
        mtiEnter.ptDown    = point;
        mtiEnter.ptPrev    = point;
        mtiEnter.fLeft     = FALSE;
        mtiEnter.fRight    = FALSE;
        mtiEnter.fCtrlDown = FALSE;

        CImgTool::GetCurrent()->OnEnter( g_pMouseImgWnd, &mtiEnter );

        g_pMouseImgWnd  = this;
        }
    OnMouseMessage( nFlags );
    }

/***************************************************************************/

void CImgWnd::OnTimer(UINT nIDEvent)
    {
    OnMouseMessage( 0 );
    }

/***************************************************************************/

void CImgWnd::SetToolCursor()
    {
    UINT nCursorID = CImgTool::GetCurrent()->GetCursorID();
    HCURSOR hCursor = NULL;

    if (nCursorID != 0)
        {
        hCursor = LoadCursor(nCursorID < 32512 ?
            AfxGetResourceHandle() : NULL, MAKEINTRESOURCE( nCursorID ));
        }

    SetCursor(hCursor);
    }


/***************************************************************************/

void CImgWnd::EndResizeOperation()
    {
    ReleaseCapture();
    delete c_pResizeDragger;
    c_pResizeDragger = NULL;
    c_dragState = CTracker::nil;
    ClearStatusBarSize();
    }


/***************************************************************************/

void CImgWnd::ResizeMouseHandler(unsigned code, CPoint imagePt)
    {
    CRect imageRect = c_pResizeDragger->m_rect;
    ClientToImage(imageRect);

    switch (code)
        {
        case WM_CANCEL:
            EndResizeOperation();
            return;

        case WM_LBUTTONUP:
            // resizing whole bitmap
            if  (m_pImg != theImgBrush.m_pImg
            &&   m_pwndThumbNailView)
                {
                m_pwndThumbNailView->Invalidate();
                }

            EndResizeOperation();

            if (theImgBrush.m_pImg == NULL)
                {
                // User was resizing the whole image...
                CPBView* pView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();
                CPBDoc*  pDoc  = (pView == NULL)? NULL: pView->GetDocument();

                if (pDoc != NULL)
                    {
                    theUndo.BeginUndo( TEXT("Property Edit") );

                    if (GetKeyState( VK_SHIFT ) < 0)
                        pDoc->m_pBitmapObj->SetIntProp( P_Shrink, 1 );

                    theApp.m_sizeBitmap = imageRect.Size();

                    pDoc->m_pBitmapObj->SetSizeProp( P_Size, theApp.m_sizeBitmap );
                    pDoc->m_pBitmapObj->SetIntProp ( P_Shrink, 0 );

                    theUndo.EndUndo();
                    }
                }
            else
                {
                // User was resizing the selection...
                HideBrush();
                theImgBrush.SetSize( imageRect.Size(), TRUE );
                MoveBrush( imageRect );
                }
            return;

        case WM_MOUSEMOVE:
            switch (c_dragState)
                {
                default:
                    ASSERT(FALSE);

                case CTracker::resizingTop:
                    imageRect.top = imagePt.y;
                    if (imageRect.top >= imageRect.bottom)
                        imageRect.top = imageRect.bottom - 1;
                    break;

                case CTracker::resizingLeft:
                    imageRect.left = imagePt.x;
                    if (imageRect.left >= imageRect.right)
                        imageRect.left = imageRect.right - 1;
                    break;

                case CTracker::resizingRight:
                    imageRect.right = imagePt.x;
                    if (imageRect.right <= imageRect.left)
                        imageRect.right = imageRect.left + 1;
                    break;

                case CTracker::resizingBottom:
                    imageRect.bottom = imagePt.y;
                    if (imageRect.bottom <= imageRect.top)
                        imageRect.bottom = imageRect.top + 1;
                    break;

                case CTracker::resizingTopLeft:
                    imageRect.left = imagePt.x;
                    imageRect.top = imagePt.y;
                    if (imageRect.top >= imageRect.bottom)
                        imageRect.top = imageRect.bottom - 1;
                    if (imageRect.left >= imageRect.right)
                        imageRect.left = imageRect.right - 1;
                    break;

                case CTracker::resizingTopRight:
                    imageRect.top = imagePt.y;
                    imageRect.right = imagePt.x;
                    if (imageRect.top >= imageRect.bottom)
                        imageRect.top = imageRect.bottom - 1;
                    if (imageRect.right <= imageRect.left)
                        imageRect.right = imageRect.left + 1;
                    break;

                case CTracker::resizingBottomLeft:
                    imageRect.left = imagePt.x;
                    imageRect.bottom = imagePt.y;
                    if (imageRect.left >= imageRect.right)
                        imageRect.left = imageRect.right - 1;
                    if (imageRect.bottom <= imageRect.top)
                        imageRect.bottom = imageRect.top + 1;
                    break;

                case CTracker::resizingBottomRight:
                    imageRect.right = imagePt.x;
                    imageRect.bottom = imagePt.y;
                    if (imageRect.right <= imageRect.left)
                        imageRect.right = imageRect.left + 1;
                    if (imageRect.bottom <= imageRect.top)
                        imageRect.bottom = imageRect.top + 1;
                    break;
                }

            if (theImgBrush.m_pImg == NULL && m_pImg->m_bTileGrid)
                {
                // Snap to tile grid...

                int cxTile = m_pImg->m_cxTile;
                if (cxTile != 1 && cxTile <= m_pImg->cxWidth)
                    {
                    imageRect.right = ((imageRect.right + cxTile / 2) /
                        cxTile) * cxTile;
                    }

                int cyTile = m_pImg->m_cyTile;
                if (cyTile != 1 && cyTile <= m_pImg->cyHeight)
                    {
                    imageRect.bottom = ((imageRect.bottom + cyTile / 2) /
                        cyTile) * cyTile;
                    }
                }

            SetStatusBarSize(imageRect.Size());

            ImageToClient(imageRect);

            c_pResizeDragger->Move(imageRect, TRUE);
            break;
        }
    }


/***************************************************************************/

void CImgWnd::StartSelectionDrag(unsigned code, CPoint newPt)
    {
    theImgBrush.CopyTo(theBackupBrush);

    newPt.x /= m_nZoom;
    newPt.y /= m_nZoom;

    mti.pt = mti.ptDown = mti.ptPrev = newPt;

    SetCapture();
    SetCombineMode(theImgBrush.m_bOpaque ? combineReplace : combineMatte);

    if (theImgBrush.m_bFirstDrag)
        {
        ASSERT(theImgBrush.m_pImg == m_pImg);

        PickupSelection();
        }
    else
        if (! theImgBrush.m_bOpaque)
            theImgBrush.RecalcMask( crRight );

    theImgBrush.TopLeftHandle();
    theImgBrush.m_dragOffset = mti.pt - theImgBrush.m_rcSelection.TopLeft();

    EraseTracker();

    if (GetKeyState(VK_CONTROL) < 0)
        {
        // Copy the selection and start moving...

        if (theImgBrush.m_bFirstDrag)
            {
            // The first time, the bits are already in
            // the bitmap, so just copy them to the
            // selection (which has already been done).

            theImgBrush.m_bFirstDrag = FALSE;
            theImgBrush.m_bLastDragWasFirst = TRUE;
            }
        else
            {
            CommitSelection(TRUE);
            }

        theImgBrush.m_bMoveSel = TRUE;
        }
    else
        if (GetKeyState(VK_SHIFT) < 0)
            {
            // Start a smear operation...
            HideBrush();

            if (theImgBrush.m_bLastDragWasFirst)
                CommitSelection(TRUE);

            SetUndo(m_pImg);
            theImgBrush.m_bSmearSel = TRUE;
            theImgBrush.m_bFirstDrag = FALSE;
            theImgBrush.m_bLastDragWasFirst = TRUE;
            }
        else
            {
            // Start a move operation...
            theImgBrush.m_bMoveSel = TRUE;
            }

    g_bCustomBrush = TRUE;
    }

/***************************************************************************/

void CImgWnd::CancelSelectionDrag()
    {
    if (!theImgBrush.m_bSmearSel && !theImgBrush.m_bMoveSel)
        {
        TRACE(TEXT("Extraneous CancelSelectionDrag!\n"));
        return;
        }

    ReleaseCapture();

    theImgBrush.m_rcSelection = theImgBrush.m_rcDraggedFrom;

    theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
    g_bCustomBrush = FALSE;
    SetCombineMode(combineColor);

    theBackupBrush.CopyTo(theImgBrush);
    rcDragBrush = theImgBrush.m_rcSelection;
    rcDragBrush.right += 1;
    rcDragBrush.bottom += 1;

    CancelPainting();

    InvalImgRect(theImgBrush.m_pImg, NULL); // draw selection tracker

    // "Opaque" mode may have changed...
    if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
    ||  (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
        g_pImgToolWnd->InvalidateOptions(FALSE);

    // Cancel all the way now...
    theImgBrush.m_pImg = NULL;
    }


/***************************************************************************/

void CImgWnd::SelectionDragHandler(unsigned code, CPoint newPt)
    {
    switch (code)
        {
        case WM_CANCEL:
            CancelSelectionDrag();
            break;

        case WM_MOUSEMOVE:
            if (theImgBrush.m_bMoveSel)
                PrepareForBrushChange(FALSE);

            mti.ptPrev = mti.pt;
            mti.pt = newPt;

            theImgBrush.m_rcSelection.OffsetRect(
                        -theImgBrush.m_rcSelection.TopLeft()
                           + (CSize)mti.pt - theImgBrush.m_dragOffset);

            // Make sure the selection stays at least along the edge
            // of the actual image so we don't lose the tracker...
            if (theImgBrush.m_rcSelection.left > m_pImg->cxWidth)
                theImgBrush.m_rcSelection.OffsetRect(-theImgBrush.m_rcSelection.left + m_pImg->cxWidth, 0);
            if (theImgBrush.m_rcSelection.top > m_pImg->cyHeight)
                theImgBrush.m_rcSelection.OffsetRect(0, -theImgBrush.m_rcSelection.top + m_pImg->cyHeight);
            if (theImgBrush.m_rcSelection.right < 0)
                theImgBrush.m_rcSelection.OffsetRect(-theImgBrush.m_rcSelection.right, 0);
            if (theImgBrush.m_rcSelection.bottom < 0)
                theImgBrush.m_rcSelection.OffsetRect(0, -theImgBrush.m_rcSelection.bottom);

            if (theImgBrush.m_bSmearSel)
                DrawBrush(m_pImg, theImgBrush.m_rcSelection.TopLeft(), TRUE);
            else
                ShowBrush(theImgBrush.m_rcSelection.TopLeft());
            break;

        case WM_LBUTTONUP:
            theImgBrush.m_bLastDragWasASmear = theImgBrush.m_bSmearSel;

            if (theImgBrush.m_bSmearSel)
                {
                IMG* pImg = m_pImg;

                CommitSelection(FALSE);

                FinishUndo(CRect(0, 0, pImg->cxWidth, pImg->cyHeight));
                }
            ReleaseCapture();

            theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;

            g_bCustomBrush = FALSE;
            SetCombineMode(combineColor);

            InvalImgRect(theImgBrush.m_pImg, NULL); // draw selection tracker
            break;
        }
    }

/******************************************************************************/

BOOL CImgWnd::PtInTracker( CPoint cptLocation )
    {
    CRect selRect = theImgBrush.m_rcSelection;
    BOOL  bPtInTracker = FALSE;

    selRect.left   *= m_nZoom;
    selRect.top    *= m_nZoom;
    selRect.right  *= m_nZoom;
    selRect.bottom *= m_nZoom;

    selRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

    bPtInTracker = selRect.PtInRect( cptLocation );

    return bPtInTracker;
    }

/******************************************************************************/

void CImgWnd::OnRButtonDownInSel(CPoint *pcPointDown)
    {
    CMenu cMenuPopup;
    BOOL bRC = cMenuPopup.LoadMenu(IDR_SELECTION_POPUP);

    ASSERT(bRC);
    if (bRC)
        {
        CMenu *pcContextMenu = cMenuPopup.GetSubMenu(0);
        ASSERT(pcContextMenu != NULL);
        if (pcContextMenu != NULL)
            {
            CPoint cPointDown = *pcPointDown;
            ImageToClient(cPointDown);
            ClientToScreen(&cPointDown);

            CRect cRectClient;
            GetClientRect(&cRectClient);
            ClientToScreen(&cRectClient);

            // the frame actually has a clue about what items to enable...
            CWnd *notify = GetParentFrame();

            if (!notify)
                notify = GetParent(); // oh well...

            pcContextMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                cPointDown.x, cPointDown.y, notify, &cRectClient);
            }
        }
    }

/***************************************************************************/

void CImgWnd::ZoomedInDP(unsigned code, unsigned mouseKeys, CPoint newPt)
    {
    CPoint clientPt = newPt;
    CPoint imagePt  = clientPt;

    ClientToImage( imagePt );

    if (c_pResizeDragger != NULL)
        {
        ResizeMouseHandler( code, imagePt );
        return;
        }

    int iHandleSize = CTracker::HANDLE_SIZE;

    newPt.x -= iHandleSize + m_xScroll * m_nZoom;
    newPt.y -= iHandleSize + m_yScroll * m_nZoom;

//  AdjustPointForGrid(&newPt);

    IMG* pImg = m_pImg;

    int cxImage = pImg->cxWidth;
    int cyImage = pImg->cyHeight;

    CRect imageRect;

    GetImageRect( imageRect );

    // Check for selection manipulations...
    if (GetCapture() != this
    &&  c_pImgWndCur == this
    &&  theImgBrush.m_pImg == m_pImg)
        {
        CRect selRect = theImgBrush.m_rcSelection;
        BOOL bPtInTracker = FALSE;

        selRect.left   *= m_nZoom;
        selRect.top    *= m_nZoom;
        selRect.right  *= m_nZoom;
        selRect.bottom *= m_nZoom;

        selRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

        bPtInTracker = PtInTracker(newPt);

        if (bPtInTracker)
            {
            // Mouse is within the outer border of the tracker...


            // We don't set the rubber for every mouse message when the
            // selection tool is active, but we'd better set it up now!
            if (pRubberImg != m_pImg)
                SetupRubber(m_pImg);

            ClearStatusBarPosition();

            CTracker::STATE state;

            selRect.InflateRect( -CTracker::HANDLE_SIZE,
                                 -CTracker::HANDLE_SIZE );

            state = CTracker::HitTest(selRect, newPt, CTracker::nil);

            if (bPtInTracker && state == CTracker::nil)
                {
                // Actually inside the selection...
                SetCursor(theApp.LoadCursor(IDCUR_MOVE));

                if (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK)
                    {
                    StartSelectionDrag(code, newPt);
                    }
                else
                    {
                    if (code == WM_RBUTTONDOWN || code == WM_RBUTTONDBLCLK)
                        // some of the menu commands don't work for free form selections
                        OnRButtonDownInSel( &imagePt );
                    }
                }
            else
                {
                // In the tracker frame...

                SetCursor(HCursorFromTrackerState(state));

                if (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK)
                    {
                    // Start a resize operation...
                    SetCapture();
                    PrepareForBrushChange();

                    ASSERT(c_pResizeDragger == NULL);
                    CRect rect = theImgBrush.m_rcSelection;
                    ImageToClient(rect);

                    c_pResizeDragger = new CDragger(this, &rect);
                    ASSERT(c_pResizeDragger != NULL);
                    c_dragState = state;
                    }
                }

            return;
            }
        }

    if (! imageRect.PtInRect( clientPt )
    &&    code         != WM_CANCEL
    &&    GetCapture() == NULL)
        {
        // The mouse is not inside the image and we're not in any
        // special mode, so hide the brush...
        if (g_pDragBrushWnd    == this
        &&  theImgBrush.m_pImg == NULL)
            HideBrush();

        CRect selRect = imageRect;

        selRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

        if (theImgBrush.m_pImg != NULL || ! selRect.PtInRect( clientPt ))
            {
            // The mouse is not in the whole image tracker
            if (WM_LBUTTONDOWN == code)
            {
               if (CImgTool::GetCurrentID() != IDMX_TEXTTOOL)
               {
                  CmdCancel ();
               }

            }
            else
            {
               SetCursor( LoadCursor(NULL, IDC_ARROW ));
            }

            return;
            }

        // The mouse is in the whole image tracker, so set the cursor
        // as appropriate
        CTracker::STATE state = CTracker::nil;

        if (c_pImgWndCur == this)
            state = CTracker::HitTest(imageRect, clientPt, CTracker::nil);

        switch (state)
            {
            case CTracker::resizingTop:
            case CTracker::resizingLeft:
            case CTracker::resizingTopLeft:
            case CTracker::resizingTopRight:
            case CTracker::resizingBottomLeft:
               state = CTracker::nil;
               break;
            }

        SetCursor( HCursorFromTrackerState( state ) );

        // Handle mouse messages for tracker...
        if (state != CTracker::nil
        &&  (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK))
            {
            SetCapture();

            ASSERT( c_pResizeDragger == NULL );

            c_pResizeDragger = new CDragger( this, &imageRect );

            ASSERT( c_pResizeDragger != NULL );

            c_dragState = state;
            }

        return;
        }

    newPt.x /= m_nZoom;
    newPt.y /= m_nZoom;

    if (! CImgTool::IsDragging())
        SetStatusBarPosition( m_ptDispPos );

    // Moving the selection??

    if (theImgBrush.m_bMoveSel
    ||  theImgBrush.m_bSmearSel)
        {
        SelectionDragHandler( code, newPt );

        return;
        }

    AdjustPointForGrid( &newPt );

    // Dispatch the event off to the current tool...

    CImgTool* pImgTool = CImgTool::GetCurrent();

    switch (code)
        {
        case WM_CANCEL:
            ReleaseCapture();
            pImgTool->OnCancel(this);
            mti.fLeft = mti.fRight = FALSE;
            break;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            // We don't set the rubber for every mouse message when the
            // selection tool is active, but we'd better set it up now!
            if (pRubberImg != m_pImg)
                SetupRubber( m_pImg );

            mti.fLeft  = (code == WM_LBUTTONDOWN || code == WM_LBUTTONDBLCLK);
            mti.fRight = (code == WM_RBUTTONDOWN || code == WM_RBUTTONDBLCLK);

            mti.pt = mti.ptDown = mti.ptPrev = newPt;

            // if in the polygon tool, double clicks will end operation

            if (CImgTool::GetCurrentID() == IDMB_POLYGONTOOL
            &&  ((code == WM_LBUTTONDBLCLK) || (code == WM_RBUTTONDBLCLK)))
                {
                mti.ptPrev = mti.pt;
                mti.pt     = newPt;

                pImgTool->EndMultiptOperation(); // end the multipt operation
                pImgTool->OnEndDrag( this, &mti );

                mti.fLeft  = FALSE;
                mti.fRight = FALSE;

                break;
                }

            SetCapture();

            if (CImgTool::GetCurrentID() != IDMB_PICKRGNTOOL)
                HideBrush();

            if (pImgTool->IsUndoable())
                SetUndo(m_pImg);

            pImgTool->OnStartDrag( this, &mti );
            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            mti.ptPrev = mti.pt;
            mti.pt     = newPt;

            if (GetCapture() != this)
                break;

            ReleaseCapture();

            pImgTool->CanEndMultiptOperation( &mti );
            pImgTool->OnEndDrag( this, &mti );

            if (code == WM_LBUTTONUP)
                {
                mti.fLeft = FALSE;
                }
            if (code == WM_RBUTTONUP)
                {
                mti.fRight = FALSE;
                }
            break;

        case WM_MOUSEMOVE:
            mti.ptPrev = mti.pt;
            mti.pt = newPt;

            if (mti.fLeft || mti.fRight)
                pImgTool->OnDrag(this, &mti);
            else
                pImgTool->OnMove(this, &mti);
            break;

        case WM_TIMER:
            pImgTool->OnTimer( this, &mti );
            break;
        }

    UpdateWindow(); // For immediate feedback in active window
    SetToolCursor();
    }

/***************************************************************************/

void CImgWnd::FinishUndo(const CRect& rectUndo)
    {
        if ( EnsureUndoSize(m_pImg) )
        m_pImg->m_pBitmapObj->FinishUndo(&rectUndo);
        else
        {
        TRACE(TEXT("Problem: Can NOT ensure undo capability!\n"));
        MessageBeep(0);
        }
    }

/***************************************************************************/

void CImgWnd::CancelPainting()
    {
    if (g_hUndoImgBitmap == NULL)
        return; // nothing to cancel!

    IMG*     pimg;
    HDC      hTempDC;
    HBITMAP  hOldBM;
    HPALETTE hOldPalette = NULL;

    pimg = m_pImg;

    if ((hTempDC = CreateCompatibleDC( pimg->hDC )) == NULL)
        {
        TRACE(TEXT("Not enough memory to undo!\n"));
        MessageBeep(0);
        return;
        }

    HideBrush();

    if (g_hUndoPalette)
        {
        if (pimg->m_hPalOld)
            {
            ::SelectPalette( pimg->hDC, pimg->m_hPalOld, FALSE );
            pimg->m_hPalOld = NULL;
            }

        if (pimg->m_pPalette)
            pimg->m_pPalette->DeleteObject();

        pimg->m_pPalette->Attach( g_hUndoPalette );
        g_hUndoPalette = NULL;

        pimg->m_hPalOld = ::SelectPalette( pimg->hDC,
                                 (HPALETTE)pimg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( pimg->hDC );
        }

    hOldBM = (HBITMAP)SelectObject( hTempDC, g_hUndoImgBitmap );

    if (pimg->m_pPalette)
        {
        hOldPalette = ::SelectPalette( hTempDC,
                            (HPALETTE)pimg->m_pPalette->GetSafeHandle(), FALSE );
        ::RealizePalette( hTempDC );
        }

    ASSERT( hOldBM != NULL );

    BitBlt( pimg->hDC, 0, 0, pimg->cxWidth, pimg->cyHeight, hTempDC, 0, 0, SRCCOPY );

    if (hOldPalette != NULL)
        ::SelectPalette( hTempDC,  hOldPalette, FALSE );

    SelectObject( hTempDC, hOldBM );
    DeleteDC    ( hTempDC );

    InvalImgRect ( m_pImg, NULL );
    CommitImgRect( m_pImg, NULL );
    }

#ifdef  GRIDOPTIONS
/***************************************************************************/

void CImgWnd::CmdGridOptions()
    {
    CImgGridDlg dlg;

    dlg.m_bPixelGrid = theApp.m_bShowGrid;
    dlg.m_bTileGrid  = m_pImg->m_bTileGrid;
    dlg.m_nWidth     = m_pImg->m_cxTile;
    dlg.m_nHeight    = m_pImg->m_cyTile;

    if (dlg.DoModal() != IDOK)
        return;

    // Hide the current is dependant on the state of the grid...

    BOOL bOldShowGrid = theApp.m_bShowGrid;
    theApp.m_bShowGrid = dlg.m_bPixelGrid;
    m_pImg->m_bTileGrid = dlg.m_bTileGrid;
    m_pImg->m_cxTile = dlg.m_nWidth;
    m_pImg->m_cyTile = dlg.m_nHeight;

    InvalImgRect(m_pImg, NULL);

    if (bOldShowGrid != theApp.m_bShowGrid)
        {
        if (c_pImgWndCur != NULL)
            c_pImgWndCur->Invalidate(FALSE); // Redraw tracker
        }
    }
#endif  // GRIDOPTIONS

/***************************************************************************/

void CImgWnd::CmdShowGrid()
    {
    // Hide the current cross hair since the width of the lines
    // is dependant on the state of the grid...
    theApp.m_bShowGrid = ! theApp.m_bShowGrid;

    InvalImgRect(m_pImg, NULL);

    if (c_pImgWndCur != NULL)
        c_pImgWndCur->Invalidate(FALSE); // Redraw tracker
    }

/***************************************************************************/
// Draw a grid over the image already in the bitmap in pDC.  Drawing
// is optimized by restricting it to destRect.
//
void CImgWnd::DrawGrid(CDC* pDC, const CRect& srcRect, CRect& destRect)
    {
    ASSERT(pDC != NULL);
    ASSERT(m_pImg != NULL);

    pDC->SetTextColor(RGB(192, 192, 192));
    pDC->SetBkColor(RGB(128, 128, 128));

    CBrush* pOldBrush = pDC->SelectObject(GetHalftoneBrush());

    CRect gridRect(0, 0, m_pImg->cxWidth * m_nZoom + 1,
        m_pImg->cyHeight * m_nZoom + 1);

    for (int x = gridRect.left; x <= gridRect.right; x += m_nZoom)
        pDC->PatBlt(x, gridRect.top, 1, gridRect.Height(), PATCOPY);

    for (int y = gridRect.top; y <= gridRect.bottom; y += m_nZoom)
        pDC->PatBlt(gridRect.left, y, gridRect.Width(), 1, PATCOPY);

    if (m_pImg->m_bTileGrid)
        {
        pDC->SetTextColor(RGB(0, 0, 255));
        pDC->SetBkColor(RGB(0, 0, 128));

        int nWidth = destRect.Width();
        int nHeight = destRect.Height();
        int nStep;

        if (m_pImg->m_cxTile > 1 && m_pImg->m_cxTile <= m_pImg->cxWidth)
            {
            nStep = m_nZoom * m_pImg->m_cxTile;
            for (x = (m_pImg->m_cxTile - srcRect.left % m_pImg->m_cxTile -
                m_pImg->m_cxTile) * m_nZoom; x <= nWidth; x += nStep)
                {
                pDC->PatBlt(x, 0, 1, nHeight, PATCOPY);
                }
            }

        if (m_pImg->m_cyTile > 1 && m_pImg->m_cyTile <= m_pImg->cyHeight)
            {
            nStep = m_nZoom * m_pImg->m_cyTile;
            for (y = (m_pImg->m_cyTile - srcRect.top % m_pImg->m_cyTile -
            m_pImg->m_cyTile) * m_nZoom; y <= nHeight; y += nStep)
                {
                pDC->PatBlt(0, y, nWidth, 1, PATCOPY);
                }
            }
        }

    pDC->SelectObject(pOldBrush);

    destRect.right += 1;
    destRect.bottom += 1;
    }

#ifdef  GRIDOPTIONS
/***************************************************************************/

void CImgWnd::CmdShowTileGrid()
    {
    extern BOOL  g_bDefaultTileGrid;
    // If neither grid is visible, show both.  Otherwise leave the pixel
    // grid alone and toggle the tile grid.

    if (! theApp.m_bShowGrid)
        {
        m_pImg->m_bTileGrid = TRUE;
        theApp.m_bShowGrid = TRUE;
        }
    else
        {
        m_pImg->m_bTileGrid = !m_pImg->m_bTileGrid;
        }

    g_bDefaultTileGrid = m_pImg->m_bTileGrid;

    InvalImgRect(m_pImg, NULL);

    if (c_pImgWndCur != NULL)
        c_pImgWndCur->Invalidate(FALSE); // Redraw tracker
    }
#endif  // GRIDOPTIONS

/***************************************************************************/

void CImgWnd::MoveBrush( const CRect& newSelRect )
    {
    if (! theImgBrush.m_pImg)
        return;

    theImgBrush.m_rcSelection = newSelRect;
    InvalImgRect( theImgBrush.m_pImg, NULL );


    theImgBrush.m_handle.cx = theImgBrush.m_handle.cy = 0;

    BOOL bOldCustomBrush = g_bCustomBrush;

    g_bCustomBrush = TRUE;

    int wOldCombineMode = wCombineMode;

    SetCombineMode( theImgBrush.m_bOpaque ? combineReplace : combineMatte );
    ShowBrush( theImgBrush.m_rcSelection.TopLeft() );

    g_bCustomBrush = bOldCustomBrush;

    SetCombineMode( wOldCombineMode );
    }

/***************************************************************************/

BOOL CImgWnd::MakeBrush( HDC hSourceDC, CRect rcSource )
    {
    int       cxWidth;
    int       cyHeight;
    int       iToolID = CImgTool::GetCurrentID();


    if (rcSource.IsRectEmpty())
        {
        ASSERT( FALSE );

        return FALSE;
        }

    theImgBrush.m_size = rcSource.Size();

    cxWidth  = theImgBrush.m_size.cx;
    cyHeight = theImgBrush.m_size.cy;

    if (theImgBrush.m_hbmOld)
        ::SelectObject( theImgBrush.m_dc.m_hDC, theImgBrush.m_hbmOld );

    if (theImgBrush.m_hbmMaskOld)
        ::SelectObject( theImgBrush.m_dc.m_hDC, theImgBrush.m_hbmMaskOld );

    theImgBrush.m_hbmOld     = NULL;
    theImgBrush.m_hbmMaskOld = NULL;

    theImgBrush.m_dc.DeleteDC();
    theImgBrush.m_bitmap.DeleteObject();
    theImgBrush.m_maskDC.DeleteDC();
    theImgBrush.m_maskBitmap.DeleteObject();

    CDC* pdcSource = CDC::FromHandle( hSourceDC );
    CDC* pdcBitmap = CDC::FromHandle( m_pImg->hDC );

    if (! theImgBrush.m_bitmap.CreateCompatibleBitmap( pdcBitmap, cxWidth, cyHeight )
    ||  ! theImgBrush.m_dc.CreateCompatibleDC        ( pdcBitmap )
    ||  ! theImgBrush.m_maskBitmap.CreateBitmap      (            cxWidth, cyHeight, 1, 1, NULL)
    ||  ! theImgBrush.m_maskDC.CreateCompatibleDC    ( pdcBitmap ))
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    theImgBrush.m_pImg       = m_pImg;
    theImgBrush.m_hbmOld     = (HBITMAP)((theImgBrush.m_dc.SelectObject(
                                         &theImgBrush.m_bitmap ))->GetSafeHandle());
    theImgBrush.m_hbmMaskOld = (HBITMAP)((theImgBrush.m_maskDC.SelectObject(
                                         &theImgBrush.m_maskBitmap ))->GetSafeHandle());

    CPalette* pcOldPalette = SetImgPalette( &theImgBrush.m_dc, FALSE );

    if (iToolID == IDMB_PICKRGNTOOL)
        {
        // Using StretchBlt to ensure palette mapping occurs
        TRY {
            CBrush cBrushWhite( PALETTERGB( 0xff, 0xff, 0xff ) );
            CRect  cRectTmp( 0, 0, cxWidth, cyHeight );

            theImgBrush.m_dc.FillRect( &cRectTmp, &cBrushWhite );
            }
        CATCH(CResourceException, e)
            {
            theApp.SetGdiEmergency();
            return FALSE;
            }
        END_CATCH

        if (theImgBrush.m_cRgnPolyFreeHandSel.GetSafeHandle())
            theImgBrush.m_dc.FillRgn( &theImgBrush.m_cRgnPolyFreeHandSel,
                                      CBrush::FromHandle( (HBRUSH)::GetStockObject( BLACK_BRUSH ) ) );

        theImgBrush.m_dc.StretchBlt( 0, 0, cxWidth, cyHeight,
                                        pdcSource,
                                        rcSource.left, rcSource.top,
                                        cxWidth, cyHeight, SRCERASE);
        }
    else
        {
        // Using StretchBlt to ensure palette mapping occurs
        theImgBrush.m_dc.StretchBlt( 0, 0, cxWidth, cyHeight,
                                           pdcSource,
                                           rcSource.left, rcSource.top,
                                           cxWidth, cyHeight, SRCCOPY );
        }

    theImgBrush.RecalcMask( crRight );

    if (pcOldPalette)
        theImgBrush.m_dc.SelectPalette( pcOldPalette, FALSE );

    theImgBrush.m_rcSelection = rcSource;

    rcSource.right  += 1;
    rcSource.bottom += 1;

    InvalImgRect( m_pImg, NULL ); // Redraw selection tracker

    rcDragBrush     = rcSource;
    g_bBrushVisible = TRUE;
    g_pDragBrushWnd = this;

    theImgBrush.m_bFirstDrag        = TRUE;
    theImgBrush.m_bLastDragWasFirst = FALSE;

    return TRUE;
    }

/***************************************************************************/

void CImgWnd::CmdClear()
    {
    if (TextToolProcessed( ID_EDIT_CLEAR ))
        return;

    HPALETTE hOldPalette = NULL;
    HBRUSH hNewBrush, hOldBrush;
    IMG* pImg = m_pImg;

    if ((hNewBrush = CreateSolidBrush( crRight )) == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }

    HideBrush();

    CRect clearRect;

    if (theImgBrush.m_pImg == NULL)
        clearRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
    else
        {
        clearRect         = rcDragBrush;
        clearRect.right  -= 1;
        clearRect.bottom -= 1;
        }

    BOOL bUndo = FALSE;

    if (!theImgBrush.m_pImg || theImgBrush.m_bFirstDrag
            || theImgBrush.m_bCuttingFromImage)
        {
        bUndo = TRUE;
        SetUndo(m_pImg);

        if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
            {
            int     iPoints;
            CPoint* pptArray;
            BOOL    bData = ((CFreehandSelectTool*)CImgTool::GetCurrent())->CopyPointsToMemArray( &pptArray, &iPoints );
            if (bData && iPoints)
                {

                HRGN hrgn = ::CreatePolygonRgn( pptArray, iPoints, ALTERNATE );

                if (hrgn)
                    ::FillRgn( pImg->hDC, hrgn, hNewBrush );

                delete [] pptArray;
                }
            else
                {
                DeleteObject ( hNewBrush );
                theApp.SetMemoryEmergency();
                return;
                }
            }
        else
            {
            hOldBrush = (HBRUSH)SelectObject(pImg->hDC, hNewBrush);

            PatBlt( pImg->hDC, clearRect.left,
                            clearRect.top,
                            clearRect.Width(),
                            clearRect.Height(), PATCOPY );
            SelectObject( pImg->hDC, hOldBrush );
            }
        }

    InvalImgRect ( m_pImg, &clearRect );
    CommitImgRect( m_pImg, &clearRect );

    if (bUndo)
        FinishUndo(clearRect);

    DirtyImg     ( m_pImg );
    DeleteObject ( hNewBrush );

    // If we have a selection, nuke it since it's useless now...
    if (theImgBrush.m_pImg != NULL)
        {
        if (theImgBrush.m_bLastDragWasFirst)
            {
            theImgBrush.m_bLastDragWasFirst = FALSE;
            FinishUndo(theImgBrush.m_rcDraggedFrom);
            }

        theImgBrush.m_handle.cx = 0;
        theImgBrush.m_handle.cy = 0;
        theImgBrush.m_bMoveSel = theImgBrush.m_bSmearSel = FALSE;
        g_bCustomBrush = FALSE;
        SetCombineMode(combineColor);

        InvalImgRect(theImgBrush.m_pImg, NULL);  // redraw selection
        theImgBrush.m_pImg = NULL;
        }
    }


/***************************************************************************/

void CImgWnd::CmdFlipBshH()
    {
    IMG* pImg = m_pImg;

    HideBrush();

    CRect flipRect;

    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        {
        flipRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        flipRect = rcDragBrush;
        flipRect.right -= 1;
        flipRect.bottom -= 1;
        }

    if (  theImgBrush.m_pImg != NULL
    &&  ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        CPalette* ppal = SetImgPalette( &theImgBrush.m_dc, FALSE );
        //
        // Don't do halftone blts when just moving bits around
        //
        theImgBrush.m_dc.SetStretchBltMode (COLORONCOLOR);

        StretchCopy(theImgBrush.m_dc.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_dc.m_hDC,
                    theImgBrush.m_size.cx - 1, 0,
                   -theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy);

        StretchCopy(theImgBrush.m_maskDC.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_maskDC.m_hDC,
                    theImgBrush.m_size.cx - 1, 0,
                   -theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy);

        if (ppal)
            theImgBrush.m_dc.SelectPalette( ppal, FALSE ); // Background ??

        MoveBrush(theImgBrush.m_rcSelection);
        }
    else
        {
        SetUndo(m_pImg);
        SetStretchBltMode (pImg->hDC, COLORONCOLOR);
        StretchCopy(pImg->hDC, flipRect.left,
                               flipRect.top,
                               flipRect.Width(),
                               flipRect.Height(),
                    pImg->hDC, flipRect.left + flipRect.Width() - 1,
                               flipRect.top,
                              -flipRect.Width(),
                               flipRect.Height());

        InvalImgRect (m_pImg, &flipRect);
        CommitImgRect(m_pImg, &flipRect);
        FinishUndo   (flipRect);
        DirtyImg     (m_pImg);
        }
    }

/***************************************************************************/

void CImgWnd::CmdFlipBshV()
    {
    IMG* pImg = m_pImg;

    HideBrush();

    CRect flipRect;

    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        {
        flipRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        flipRect = rcDragBrush;
        flipRect.right -= 1;
        flipRect.bottom -= 1;
        }

    if (  theImgBrush.m_pImg != NULL
    &&  ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        CPalette* ppal = SetImgPalette( &theImgBrush.m_dc, FALSE ); // Background ??
        theImgBrush.m_dc.SetStretchBltMode (COLORONCOLOR);
        StretchCopy(theImgBrush.m_dc.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_dc.m_hDC, 0,
                    theImgBrush.m_size.cy - 1,
                    theImgBrush.m_size.cx,
                   -theImgBrush.m_size.cy);

        StretchCopy(theImgBrush.m_maskDC.m_hDC, 0, 0,
                    theImgBrush.m_size.cx,
                    theImgBrush.m_size.cy,
                    theImgBrush.m_maskDC.m_hDC, 0,
                    theImgBrush.m_size.cy - 1,
                    theImgBrush.m_size.cx,
                   -theImgBrush.m_size.cy);

        if (ppal)
            theImgBrush.m_dc.SelectPalette( ppal, FALSE ); // Background ??

        MoveBrush(theImgBrush.m_rcSelection);
        }
    else
        {
        SetUndo(m_pImg);
        SetStretchBltMode (pImg->hDC, COLORONCOLOR);
        StretchCopy(pImg->hDC, flipRect.left,    flipRect.top,
                               flipRect.Width(), flipRect.Height(),
                    pImg->hDC, flipRect.left,    flipRect.top + flipRect.Height() - 1,
                               flipRect.Width(), -flipRect.Height());

        InvalImgRect (m_pImg, &flipRect);
        CommitImgRect(m_pImg, &flipRect);
        FinishUndo   (flipRect);
        DirtyImg     (m_pImg);
        }
    }

/***************************************************************************/

void CImgWnd::CmdDoubleBsh()
    {
    if (!g_bCustomBrush && theImgBrush.m_pImg == NULL)
        {
        MessageBeep(0);
        return;
        }

    PrepareForBrushChange(TRUE, FALSE);

    CRect rc  =           theImgBrush.m_rcSelection;
    rc.left  -=           theImgBrush.m_size.cx / 2;
    rc.right  = rc.left + theImgBrush.m_size.cx * 2;
    rc.top   -=           theImgBrush.m_size.cy / 2;
    rc.bottom = rc.top  + theImgBrush.m_size.cy * 2;

    HideBrush();

    theImgBrush.SetSize( CSize( theImgBrush.m_size.cx * 2,
                                theImgBrush.m_size.cy * 2 ) );
    MoveBrush(rc);

    if (g_bCustomBrush)
        theImgBrush.CenterHandle();
    }

/***************************************************************************/

void CImgWnd::CmdHalfBsh()
    {
    if (! g_bCustomBrush
    &&  ! theImgBrush.m_pImg)
        {
        MessageBeep(0);
        return;
        }

    PrepareForBrushChange( TRUE, FALSE );

    CRect rc  =            theImgBrush.m_rcSelection;
    rc.left  +=            theImgBrush.m_size.cx / 4;
    rc.right  = rc.left + (theImgBrush.m_size.cx + 1) / 2;
    rc.top   +=            theImgBrush.m_size.cy / 4;
    rc.bottom = rc.top  + (theImgBrush.m_size.cy + 1) / 2;

    HideBrush();

    theImgBrush.SetSize( CSize( (theImgBrush.m_size.cx + 1) / 2,
                                (theImgBrush.m_size.cy + 1) / 2 ) );
    MoveBrush( rc );

    if (g_bCustomBrush)
        theImgBrush.CenterHandle();
    }

/***************************************************************************/

CPalette* CImgWnd::FixupDibPalette( LPSTR lpDib, CPalette* ppalDib )
    {
    CPBView* pView = (CPBView*)GetParent();
    CPBDoc*  pDoc  = pView->GetDocument();

    if (pDoc == NULL || lpDib == NULL || ppalDib == NULL || pDoc->m_pBitmapObj->m_pImg == NULL)
        return ppalDib;

    IMG* pImg         = pDoc->m_pBitmapObj->m_pImg;
    int  iColorBits   = pImg->cBitCount * pImg->cPlanes;
    BOOL bFixupDib    = TRUE;
    BOOL bSwapPalette = TRUE;

    // only if dealing with palettes
    if (iColorBits != 8)
        return ppalDib;

    CPalette* ppalPic = theApp.m_pPalette;
    CPalette* ppalNew = NULL;
        BOOL      bMergedPalette = FALSE;

    if (ppalPic)
        {
        int iAdds;

        if ( ppalNew = MergePalettes( ppalPic, ppalDib, iAdds ) )
                        bMergedPalette = TRUE;

        if (ppalNew)
            {
            if (! iAdds)
                {
                bSwapPalette = FALSE;
                                if ( bMergedPalette )
                                        {
                                        delete ppalNew;
                                        ppalNew = FALSE;
                                        bMergedPalette = FALSE;
                                        }
                ppalNew = ppalPic;
                }
            }
        else
            {
            bSwapPalette = FALSE;
                        if ( bMergedPalette )
                                {
                                delete ppalNew;
                                ppalNew = FALSE;
                                bMergedPalette = FALSE;
                                }
            ppalNew = ppalPic;
            }
        }
    else
        {
                if ( bMergedPalette )
                        {
                        delete ppalNew;
                        ppalNew = FALSE;
                        bMergedPalette = FALSE;
                        }
        ppalNew   = ppalDib;
        bFixupDib = FALSE;
        }

    if (bFixupDib)
        {
        LOGPALETTE256    palette;
        COLORREF         crCurColor;
        UINT             uColorIndex;
        int              iDibColors   = DIBNumColors( lpDib );
        BOOL             bWinStyleDIB = IS_WIN30_DIB( lpDib );
        LPBITMAPINFO     lpDibInfo    = (LPBITMAPINFO)lpDib;
        LPBITMAPCOREINFO lpCoreInfo   = (LPBITMAPCOREINFO)lpDib;

        palette.palVersion    = 0x300;
        palette.palNumEntries = (WORD)ppalNew->GetPaletteEntries( 0, 256,
                                                              &palette.palPalEntry[0] );
                                ppalNew->GetPaletteEntries( 0, palette.palNumEntries,
                                                              &palette.palPalEntry[0] );
        for (int iLoop = 0; iLoop < iDibColors; iLoop++)
            {
            if (bWinStyleDIB)
                {
                crCurColor = PALETTERGB( lpDibInfo->bmiColors[iLoop].rgbRed,
                                         lpDibInfo->bmiColors[iLoop].rgbGreen,
                                         lpDibInfo->bmiColors[iLoop].rgbBlue );
                }
            else
                {
                crCurColor = PALETTERGB( lpCoreInfo->bmciColors[iLoop].rgbtRed,
                                         lpCoreInfo->bmciColors[iLoop].rgbtGreen,
                                         lpCoreInfo->bmciColors[iLoop].rgbtBlue );
                }
            uColorIndex = ppalNew->GetNearestPaletteIndex( crCurColor );

            if (bWinStyleDIB)
                {
                lpDibInfo->bmiColors[iLoop].rgbRed   = palette.palPalEntry[uColorIndex].peRed;
                lpDibInfo->bmiColors[iLoop].rgbGreen = palette.palPalEntry[uColorIndex].peGreen;
                lpDibInfo->bmiColors[iLoop].rgbBlue  = palette.palPalEntry[uColorIndex].peBlue;
                }
            else
                {
                lpCoreInfo->bmciColors[iLoop].rgbtRed   = palette.palPalEntry[uColorIndex].peRed;
                lpCoreInfo->bmciColors[iLoop].rgbtGreen = palette.palPalEntry[uColorIndex].peGreen;
                lpCoreInfo->bmciColors[iLoop].rgbtBlue  = palette.palPalEntry[uColorIndex].peBlue;
                }
            }
        if (! bSwapPalette)
                        {
                        if ( bMergedPalette )
                                {
                                delete ppalNew;
                                bMergedPalette = FALSE;
                                }
            ppalNew = NULL;
                        }
        }

    if (bSwapPalette)
        {
        if (pImg->m_hPalOld)
            {
            ::SelectPalette( pImg->hDC, pImg->m_hPalOld, FALSE );
            pImg->m_hPalOld = NULL;
            }

        if (pImg->m_pPalette)
            delete pImg->m_pPalette;

        pImg->m_pPalette = ppalNew;
        pImg->m_hPalOld  = ::SelectPalette( pImg->hDC,
                                     (HPALETTE)ppalNew->GetSafeHandle(), FALSE );
        ::RealizePalette( pImg->hDC );
        InvalImgRect( pImg, NULL );

        // Return NULL since we swapped the new palette into the pImg!
        ppalNew = NULL;

        theApp.m_pPalette = pImg->m_pPalette;

        //
        // now that we changed the app palette update the DIB Section
        // color table too.
        //
        DWORD rgb[256];
        int i,n;

        n = theApp.m_pPalette->GetPaletteEntries(0, 256, (LPPALETTEENTRY)rgb);
        for (i=0; i<n; i++)
            rgb[i] = RGB(GetBValue(rgb[i]),GetGValue(rgb[i]),GetRValue(rgb[i]));
        SetDIBColorTable(pImg->hDC, 0, n, (LPRGBQUAD)rgb);
        }

        // Delete any orphaned ppalDib pointers.
        if ( ppalDib && ppalDib != ppalNew )
                delete ppalDib;

    return ppalNew;
    }

/***************************************************************************/

void CImgWnd::ShowBrush(CPoint ptHandle)
    {
    IMG * pimg = m_pImg;

    HideBrush();

    COLORREF crRealLeftColor;
    COLORREF crRealRightColor;

    int nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();
    int nStrokeShape = CImgTool::GetCurrent()->GetStrokeShape();

    if (CImgTool::GetCurrentID() == IDMB_ERASERTOOL)
        {
        crRealRightColor = crRight;
        crRealLeftColor  = crLeft;

        crLeft = crRight;
        }

    g_pDragBrushWnd = this;

    if (g_bCustomBrush)
        {
        int nCombineMode = (theImgBrush.m_bOpaque) ? combineReplace : combineMatte;

        rcDragBrush.SetRect(ptHandle.x, ptHandle.y,
                            ptHandle.x + theImgBrush.m_size.cx,
                            ptHandle.y + theImgBrush.m_size.cy);
        rcDragBrush -= (CPoint)theImgBrush.m_handle;

        theImgBrush.m_rcSelection = rcDragBrush;
        rcDragBrush.right  += 1;
        rcDragBrush.bottom += 1;

        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
            {
//          extern CTextTool g_textTool;
//          g_textTool.Render(CDC::FromHandle(pimg->hDC),
//                          rcDragBrush, TRUE, FALSE);
            }
        else
            {
            switch (nCombineMode)
                {
                case combineColor:
                    theImgBrush.BltColor(pimg, rcDragBrush.TopLeft(), crLeft);
                    break;

                case combineMatte:
                    theImgBrush.BltMatte(pimg, rcDragBrush.TopLeft());
                    break;

                case combineReplace:
                    theImgBrush.BltReplace(pimg, rcDragBrush.TopLeft());
                    break;
                }
            }

        InvalImgRect(m_pImg, &rcDragBrush);
        }
    else
        {
        DrawImgLine(m_pImg, ptHandle, ptHandle, crLeft,
                                          nStrokeWidth, nStrokeShape, FALSE);
        rcDragBrush.left   = ptHandle.x - nStrokeWidth / 2;
        rcDragBrush.top    = ptHandle.y - nStrokeWidth / 2;
        rcDragBrush.right  = rcDragBrush.left + nStrokeWidth;
        rcDragBrush.bottom = rcDragBrush.top  + nStrokeWidth;
        }

    if (CImgTool::GetCurrentID() == IDMB_ERASERTOOL)
        {
        crLeft  = crRealLeftColor;
        crRight = crRealRightColor;
        }

    g_bBrushVisible = TRUE;
    }

/***************************************************************************/

void CImgWnd::CmdSmallBrush()
    {
    if (CImgTool::GetCurrent()->GetStrokeWidth() != 0)
        CImgTool::GetCurrent()->SetStrokeWidth(1);
    }

/***************************************************************************/

void CImgWnd::CmdSmallerBrush()
    {
    if (theImgBrush.m_pImg != NULL || g_bCustomBrush)
        {
        CmdHalfBsh();
        return;
        }

    UINT nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();

    if (nStrokeWidth > 1)
        CImgTool::GetCurrent()->SetStrokeWidth(nStrokeWidth - 1);
    }

/***************************************************************************/

void CImgWnd::CmdLargerBrush()
    {
    if (theImgBrush.m_pImg != NULL || g_bCustomBrush)
        {
        CmdDoubleBsh();
        return;
        }

    UINT nStrokeWidth = CImgTool::GetCurrent()->GetStrokeWidth();

    CImgTool::GetCurrent()->SetStrokeWidth(nStrokeWidth + 1);
    }

/***************************************************************************/

void CImgWnd::CmdOK()
    {
    if (GetCapture() != NULL)
        {
        MessageBeep(0);
        return;
        }
    }

/***************************************************************************/
// Draw the tracker for this view (if it's the active one) into pDC.
// If pDC is NULL, one will be provided.  Optimize drawing by limiting
// it to pPaintRect.  If pPaintRect is NULL, draw the whole tracker.
//
void CImgWnd::DrawTracker( CDC* pDC, const CRect* pPaintRect )
    {
    BOOL bDrawTrackerRgn = FALSE;

    if (c_pImgWndCur != this
    ||  theImgBrush.m_bMoveSel
    ||  theImgBrush.m_bSmearSel
    ||  theImgBrush.m_bMakingSelection)
        {
        // This is not the active view, or the user is doing something
        // to prevent the tracker from appearing.
        return;
        }

    BOOL bReleaseDC = FALSE;
    CRect clientRect;

    if (pDC == NULL)
        {
        pDC = GetDC();

        if (pDC == NULL)
            {
            theApp.SetGdiEmergency(FALSE);
            return;
            }
        bReleaseDC = TRUE;
        }

   if (pPaintRect == NULL)
        {
        GetClientRect(&clientRect);
        pPaintRect = &clientRect;
        }

    CRect trackerRect;

    GetImageRect( trackerRect );

    trackerRect.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );

    CTracker::EDGES edges = (CTracker::EDGES)(CTracker::right | CTracker::bottom);

    if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        bDrawTrackerRgn = TRUE;
        }

    if (m_pImg == theImgBrush.m_pImg)
        {
        edges = CTracker::all;

        trackerRect = theImgBrush.m_rcSelection;

        trackerRect.left   *= m_nZoom;
        trackerRect.top    *= m_nZoom;
        trackerRect.right  *= m_nZoom;
        trackerRect.bottom *= m_nZoom;

        trackerRect.InflateRect( CTracker::HANDLE_SIZE,
                                 CTracker::HANDLE_SIZE);
        trackerRect.OffsetRect(  CTracker::HANDLE_SIZE + m_xScroll * m_nZoom,
                                 CTracker::HANDLE_SIZE + m_yScroll * m_nZoom);

        if (IsGridVisible())
            {
            trackerRect.right  += 1;
            trackerRect.bottom += 1;
            }
        }

    CTracker::DrawBorder (pDC, trackerRect, edges );
    CTracker::DrawHandles(pDC, trackerRect, edges );

    if (bReleaseDC)
        ReleaseDC(pDC);
    }

/***************************************************************************/
// Erase the tracker from this window.  Handles whole image as well
// as selection trackers.
//
void CImgWnd::EraseTracker()
    {
    if (m_pImg == NULL)
        return;

    CClientDC dc(this);

    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency(FALSE);
        return;
        }

    CRect trackerRect;

    if (m_pImg == theImgBrush.m_pImg)
        {
        // Tracker is a selection within the image

        trackerRect = theImgBrush.m_rcSelection;
        ImageToClient(trackerRect);
        trackerRect.InflateRect(CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE);

        if (IsGridVisible())
            {
            trackerRect.right += 1;
            trackerRect.bottom += 1;
            }

        InvalidateRect( &trackerRect, FALSE );
        }
    else
        {
        // Tracker is around entire image

        GetImageRect(trackerRect);
        trackerRect.InflateRect(CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE);
        DrawBackground(&dc, &trackerRect);
        }
    }

/***************************************************************************/

void CImgWnd::CmdTglOpaque()
    {
    HideBrush();
    theImgBrush.m_bOpaque = !theImgBrush.m_bOpaque;
    theImgBrush.RecalcMask( crRight );

    MoveBrush( theImgBrush.m_rcSelection );

    if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
    ||  (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
        g_pImgToolWnd->InvalidateOptions( FALSE );
    }

/***************************************************************************/

void CImgWnd::CmdInvertColors()
    {
    IMG* pImg = m_pImg;

    HideBrush();

    CRect invertRect;
    if (theImgBrush.m_pImg == NULL && !g_bCustomBrush)
        {
        invertRect.SetRect(0, 0, pImg->cxWidth, pImg->cyHeight);
        }
    else
        {
        invertRect = rcDragBrush;
        invertRect.right -= 1;
        invertRect.bottom -= 1;
        }

    if (theImgBrush.m_pImg != NULL && ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        CPalette* ppal = SetImgPalette( &theImgBrush.m_dc, FALSE );

        theImgBrush.m_dc.PatBlt(0, 0, theImgBrush.m_size.cx,
                                      theImgBrush.m_size.cy, DSTINVERT);

        if (ppal)
            theImgBrush.m_dc.SelectPalette( ppal, FALSE ); // Background ??

        theImgBrush.RecalcMask( crRight );
        MoveBrush( theImgBrush.m_rcSelection );
        }
    else
        {
        SetUndo( m_pImg );

        PatBlt( pImg->hDC, invertRect.left, invertRect.top,
                invertRect.Width(), invertRect.Height(), DSTINVERT );

        InvalImgRect ( m_pImg, &invertRect );
        CommitImgRect( m_pImg, &invertRect );
        FinishUndo( invertRect );
        DirtyImg( m_pImg );
        }
    }

/***************************************************************************/

void CImgWnd::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
    {
    CWnd::OnKeyDown( nChar, nRepCnt, nFlags );
    }

/***************************************************************************/

void CImgWnd::OnKeyUp( UINT nChar, UINT nRepCnt, UINT nFlags )
    {
    CWnd::OnKeyUp( nChar, nRepCnt, nFlags );
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgwell.h ===
#ifndef __IMGWELL_H__
#define __IMGWELL_H__

// The CImageWell class provides a convenient way to handle "tiled"
// bitmaps.

class CImageWell
    {
    public:

    CImageWell();
    CImageWell( UINT nBitmapID, CSize imageSize );

    ~CImageWell();
    
    BOOL Open  ();
    BOOL IsOpen() { return m_dc.m_hDC != NULL; }
    void Close ();
    BOOL Load  ( UINT nBitmapID, CSize imageSize );
    void Unload();
    
    BOOL CalculateMask();
    
    BOOL DrawImage( CDC* pDestDC, CPoint destPoint, UINT nImage, 
                    DWORD rop = 0); // rop==0 means image is drawn through a mask
    
    protected:

    UINT    m_nBitmapID;
    CSize   m_imageSize;
    
    CBitmap m_bitmap;
    CDC     m_dc;
    CBitmap m_mask;
    CDC     m_maskDC;
    };

#endif // __IMGWELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\ipframe.h ===
// ipframe.h : interface of the CInPlaceFrame class
//

class CInPlaceFrame : public COleIPFrameWnd
    {
    DECLARE_DYNCREATE(CInPlaceFrame)

    public:

    CInPlaceFrame();

    // Attributes
    public:

    // Operations
    public:

    // Implementation
    public:

    virtual ~CInPlaceFrame();

	virtual CWnd* GetMessageBar();
    virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
    virtual void RepositionFrame( LPCRECT lpPosRect, LPCRECT lpClipRect );

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

    protected:

    CStatBar    	m_statBar;
    CImgToolWnd 	m_toolBar;
	CImgColorsWnd 	m_colorBar;

    COleResizeBar	m_wndResizeBar;
    COleDropTarget	m_dropTarget;

    // Generated message map functions
    protected:

    //{{AFX_MSG(CInPlaceFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSysColorChange();
	afx_msg void OnClose();
	afx_msg void OnHelpIndex();
	//}}AFX_MSG

	afx_msg LRESULT OnContextMenu(WPARAM wParam, LPARAM lParam);

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\interlac.cpp ===
/*********************************************************************
   Interlace.cpp

   Definition file for interlace module.
 *********************************************************************/
#include "stdafx.h"
#include "Image.h"
#include "Interlac.h"

/*--------------------------------------------------------------------
            Data Structures and Definitions.
 --------------------------------------------------------------------*/
#define  ADAM7_BLOCK_SIZE    8

short kgacPassScanLines[NUM_PASSES] = { 1, 1, 1, 2, 2, 4, 4 };
short kgacPassStartHorzPosn[NUM_PASSES] = { 0, 4, 0, 2, 0, 1, 0 };
short kgacPassStartVertPosn[NUM_PASSES] = { 0, 0, 4, 0, 2, 0, 1 };
short kgacPassVertIncrements[NUM_PASSES] = { 8, 8, 8, 4, 4, 2, 2 };
short kgacPassHorzIncrements[NUM_PASSES] = { 8, 8, 4, 4, 2, 2, 1 };

/*--------------------------------------------------------------------
            Local Function Prototypes.
 --------------------------------------------------------------------*/

long iFindPass(pADAM7_STRUCT);
long iFindImageLine(pADAM7_STRUCT);

/*--------------------------------------------------------------------
            Export Function Definitions.
 --------------------------------------------------------------------*/

//************************************************************************************
// Given an image described by the parameters of the ADAM7_STRUCT, calculate the
// number of scan lines in the image file which has been interlaced using the Adam7
// scheme.
//************************************************************************************
int iADAM7CalculateNumberOfScanLines(pADAM7_STRUCT ptAdam7)
{
   if (ptAdam7 == NULL)
   {
      return 0;
   }

   if (ptAdam7->iImageHeight == 0 || ptAdam7->iImageWidth == 0)
   {
      return 0;
   }

   if (ptAdam7->iImageHeight < ADAM7_BLOCK_SIZE)
   {
      switch(ptAdam7->iImageHeight)
      {
      case 1:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 1;
         ptAdam7->cPassScanLines[6] = 0;
         ptAdam7->cTotalScanLines  =  6;
         break;

      case 2:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 1;
         ptAdam7->cPassScanLines[6] = 1;
         ptAdam7->cTotalScanLines  =  7;
         break;

      case 3:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 2;
         ptAdam7->cPassScanLines[6] = 1;
         ptAdam7->cTotalScanLines  =  8;
         break;

      case 4:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 1;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 2;
         ptAdam7->cPassScanLines[6] = 2;
         ptAdam7->cTotalScanLines  =  9;
         break;

      case 5:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 2;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 3;
         ptAdam7->cPassScanLines[6] = 2;
         ptAdam7->cTotalScanLines  = 11;
         break;

      case 6:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 2;
         ptAdam7->cPassScanLines[4] = 1;
         ptAdam7->cPassScanLines[5] = 3;
         ptAdam7->cPassScanLines[6] = 3;
         ptAdam7->cTotalScanLines  = 12;
         break;

      case 7:
         ptAdam7->cPassScanLines[0] = 1;
         ptAdam7->cPassScanLines[1] = 1;
         ptAdam7->cPassScanLines[2] = 1;
         ptAdam7->cPassScanLines[3] = 2;
         ptAdam7->cPassScanLines[4] = 2;
         ptAdam7->cPassScanLines[5] = 4;
         ptAdam7->cPassScanLines[6] = 3;
         ptAdam7->cTotalScanLines  = 14;
         break;
      }

      return ptAdam7->cTotalScanLines;
   }


   ptAdam7->cScanBlocks = ptAdam7->iImageHeight / ADAM7_BLOCK_SIZE;
   int iExtraLines = ptAdam7->iImageHeight % ADAM7_BLOCK_SIZE;

   ptAdam7->cTotalScanLines = 0;

   for (int i = 0; i < NUM_PASSES; i++)
   {
      ptAdam7->cPassScanLines[i] = ptAdam7->cScanBlocks * kgacPassScanLines[i];
      ptAdam7->cTotalScanLines += ptAdam7->cPassScanLines[i];
   }

   switch(iExtraLines)
   {
   case 0:
      break;

   case 1:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;  // Yes, I could have left these out: hopefully
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 0;  // these will help someone else figure out the
      ptAdam7->cPassScanLines[5] += 1;
      ptAdam7->cPassScanLines[6] += 0;  // Adam7 de-interlacing scheme.
      ptAdam7->cTotalScanLines +=  4;
      break;

   case 2:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 0;
      ptAdam7->cPassScanLines[5] += 1;
      ptAdam7->cPassScanLines[6] += 1;
      ptAdam7->cTotalScanLines +=  5;
      break;

   case 3:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 2;
      ptAdam7->cPassScanLines[6] += 1;
      ptAdam7->cTotalScanLines += 7;
      break;

  case 4:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 0;
      ptAdam7->cPassScanLines[3] += 1;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 2;
      ptAdam7->cPassScanLines[6] += 2;
      ptAdam7->cTotalScanLines += 8;
      break;

   case 5:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 1;
      ptAdam7->cPassScanLines[3] += 2;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 3;
      ptAdam7->cPassScanLines[6] += 2;
      ptAdam7->cTotalScanLines += 11;
      break;

   case 6:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 1;
      ptAdam7->cPassScanLines[3] += 2;
      ptAdam7->cPassScanLines[4] += 1;
      ptAdam7->cPassScanLines[5] += 3;
      ptAdam7->cPassScanLines[6] += 3;
      ptAdam7->cTotalScanLines += 12;
      break;

   case 7:
      ptAdam7->cPassScanLines[0] += 1;
      ptAdam7->cPassScanLines[1] += 1;
      ptAdam7->cPassScanLines[2] += 1;
      ptAdam7->cPassScanLines[3] += 2;
      ptAdam7->cPassScanLines[4] += 2;
      ptAdam7->cPassScanLines[5] += 4;
      ptAdam7->cPassScanLines[6] += 3;
      ptAdam7->cTotalScanLines += 14;
      break;

   default: /* Should never, ever get here!  */
      break;
   }

   return ptAdam7->cTotalScanLines;
}


//************************************************************************************
// Functions to generate a deinterlaced DIB; i.e., each pixel is in BGR in the case
// of RGB/RGBA image classes, and raster line data is stored in a contiguous block.
//************************************************************************************
LPBYTE *ppbADAM7InitDIBPointers(LPBYTE pbDIB, pADAM7_STRUCT ptAdam7, DWORD cbImageLine)
{
   if (ptAdam7 == NULL)
   {
      return NULL;
   }

   if (ptAdam7->iImageHeight == 0 || ptAdam7->iImageWidth == 0)
   {
      return NULL;
   }

   BYTE **ppbRowPtrs = (BYTE **)HeapAlloc(GetProcessHeap(),
           0, sizeof(BYTE *) * ptAdam7->iImageHeight);
   if (ppbRowPtrs == NULL)
   {
      return NULL;
   }

   /*  DIBs are bottom up  */
   for (int i = 0; i < ptAdam7->iImageHeight; i++)
   {
      ppbRowPtrs[i] = pbDIB +
                         ((DWORD)(ptAdam7->iImageHeight - i - 1) * (DWORD)cbImageLine);
   }

   int iScanLines = iADAM7CalculateNumberOfScanLines(ptAdam7);

   ptAdam7->iPassLine = 0;

   return ppbRowPtrs;
}

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToDIB(LPBYTE *ppbDIBPtrs, LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7)
{
   BYTE *pbScan;
   BYTE *pbImage;
   BYTE *pbCurrentImageLine;

   long iCurrentPass = iFindPass(ptAdam7);
   long iImageLine = iFindImageLine(ptAdam7);
   long  i;
   if (iImageLine < ptAdam7->iImageHeight)
   {

      pbCurrentImageLine = ppbDIBPtrs[iImageLine];
      for (pbImage = pbCurrentImageLine + (kgacPassStartHorzPosn[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan = pbScanLine, i = kgacPassStartHorzPosn[iCurrentPass];
           i < ptAdam7->iImageWidth;
           pbImage += (kgacPassHorzIncrements[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan += ptAdam7->cbPixelSize,
           i += kgacPassHorzIncrements[iCurrentPass])
      {
         {
            switch (ptAdam7->Class)
            {
               case IFLCL_GRAY:
               case IFLCL_GRAYA:
               case IFLCL_PALETTE:
                                 memcpy(pbImage, pbScan, ptAdam7->cbPixelSize);
                                 break;
               case IFLCL_RGBA:
                  *(pbImage + 3) = *(pbScan + 3); // And fall through . . .
               case IFLCL_RGB:
                  *pbImage = *(pbScan + 2);
                  *(pbImage + 1) = *(pbScan + 1);
                  *(pbImage + 2) = *pbScan;
                            break;
               default:
                  return TRUE;
            }
         }
      }
      return FALSE;
   }
   else
   {
      return TRUE;
   }
}

//************************************************************************************
// Generate a deinterlaced image; i.e., each pixel is in RGB in the case
// of RGB/RGBA image classes, and raster line data may not necessarily be stored
// in one contiguous block of memory.
//************************************************************************************

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToImageBuffer(LPBYTE ppbImageBuffer[], LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7)
{
   BYTE *pbScan;
   BYTE *pbImage;
   BYTE *pbCurrentImageLine;

   long iCurrentPass = iFindPass(ptAdam7);
   long iImageLine = iFindImageLine(ptAdam7);
   long i;
   if (iImageLine < ptAdam7->iImageHeight)
   {

      pbCurrentImageLine = ppbImageBuffer[iImageLine];
      for (pbImage = pbCurrentImageLine + (kgacPassStartHorzPosn[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan = pbScanLine, i = kgacPassStartHorzPosn[iCurrentPass];
           i < ptAdam7->iImageWidth;
           pbImage += (kgacPassHorzIncrements[iCurrentPass] * ptAdam7->cbPixelSize),
           pbScan += ptAdam7->cbPixelSize,
           i += kgacPassHorzIncrements[iCurrentPass])
      {
         {
            switch (ptAdam7->Class)
            {
               case IFLCL_GRAY:
               case IFLCL_GRAYA:
               case IFLCL_PALETTE:
                                 memcpy(pbImage, pbScan, ptAdam7->cbPixelSize);
                                 break;
                       case IFLCL_RGBA:
                  *(pbImage + 3) = *(pbScan + 3); // And fall through . . .
               case IFLCL_RGB:
                  *pbImage = *pbScan;
                  *(pbImage + 1) = *(pbScan + 1);
                  *(pbImage + 2) = *(pbScan + 2);
                            break;
               default:
                  return TRUE;
            }
         }
      }
      return FALSE;
   }
   else
   {
      return TRUE;
   }
}

//************************************************************************************
// Generate a deinterlaced alpha channel data block.
//************************************************************************************
BOOL ADAM7RMFDeinterlaceAlpha(LPWORD *ppwInterlaced, LPWORD *ppwDeinterlaced,
                              IFL_ALPHA_CHANNEL_INFO  *ptAlphaInfo)
{
   ADAM7_STRUCT tAdam7;

   if (ppwInterlaced == NULL || ppwDeinterlaced == NULL || ptAlphaInfo == NULL)
   {
      return FALSE;
   }

   tAdam7.iImageHeight = ptAlphaInfo->dwHeight;
   tAdam7.iImageWidth = ptAlphaInfo->dwWidth;
   tAdam7.cbPixelSize = sizeof(WORD);
   tAdam7.iPassLine = 0;
   /* Simulate a class so we can use the AddRowToDIB function above. */
   tAdam7.Class = IFLCL_GRAYA;

   tAdam7.cTotalScanLines = iADAM7CalculateNumberOfScanLines(&tAdam7);

   for (tAdam7.iScanLine = 0; tAdam7.iScanLine < tAdam7.cTotalScanLines; tAdam7.iScanLine++)
   {
      ADAM7AddRowToDIB((BYTE **)ppwDeinterlaced, (BYTE *)(ppwInterlaced[tAdam7.iScanLine]), &tAdam7);
   }

   return TRUE;
}

/*--------------------------------------------------------------------
            Local Function Definitions.
 --------------------------------------------------------------------*/

long iFindPass(pADAM7_STRUCT ptAdam7)
{
   BOOL fFound = FALSE;

   ptAdam7->iPass = 0;
   int iSubTotal = ptAdam7->cPassScanLines[ptAdam7->iPass];
   while (!fFound)
   {
      if (ptAdam7->iScanLine < iSubTotal)
      {
         fFound = TRUE;
         ptAdam7->iPassLine = ptAdam7->iScanLine -
                             (iSubTotal - ptAdam7->cPassScanLines[ptAdam7->iPass]);
      }
      else
      {
         ptAdam7->iPass += 1;
         iSubTotal += ptAdam7->cPassScanLines[ptAdam7->iPass];
      }
   }

   return ptAdam7->iPass;
}

long iFindImageLine(pADAM7_STRUCT ptAdam7)
{
   if (kgacPassStartHorzPosn[ptAdam7->iPass] >= ptAdam7->iImageWidth)
   {
      return (ptAdam7->iImageHeight + 1);
   }

   ptAdam7->iImageLine = kgacPassStartVertPosn[ptAdam7->iPass] +
                         ptAdam7->iPassLine * kgacPassVertIncrements[ptAdam7->iPass];
   return ptAdam7->iImageLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\imgwnd.h ===
#ifndef __IMGWND_H__
#define __IMGWND_H__

#include "tracker.h"

// #define GRIDOPTIONS

class CBitmapObj;

// helper fns
BOOL IsUserEditingText();
BOOL TextToolProcessed( UINT nMessage );

// Mouse Tracking Information

typedef struct _mti
    {
    CPoint ptDown;
    CPoint ptPrev;
    CPoint pt;
    BOOL   fLeft;
    BOOL   fRight;
    BOOL   fCtrlDown;
    } MTI;

class CImgWnd;
class CThumbNailView;

// Image
struct IMG
    {
    class CImgWnd* m_pFirstImgWnd;

    CBitmapObj* m_pBitmapObj;

    BOOL bDirty;

    HDC hDC;
    HDC hMaskDC; // May be NULL (for normal bitmaps)

    // These are usually selected into hDC and hMaskDC respecively
    HBITMAP hBitmap;
    HBITMAP hBitmapOld;
    HBITMAP hMaskBitmap;
    HBITMAP hMaskBitmapOld;

    CPalette* m_pPalette;
    HPALETTE  m_hPalOld;

    int cxWidth;
    int cyHeight;
    int cPlanes;
    int cBitCount;
    int cXPelsPerMeter;
    int cYPelsPerMeter;
    int nResType;
    int m_nLastChanged;

    BOOL m_bTileGrid;
    int  m_cxTile;
    int  m_cyTile;
    };

// Image Editor Window

class CImgWnd : public CWnd
    {
    protected:

    static CImgWnd*         c_pImgWndCur;
    static CDragger*        c_pResizeDragger;
    static CTracker::STATE  c_dragState;

    DECLARE_DYNAMIC( CImgWnd )

    public:

     CImgWnd( IMG* pImg );
     CImgWnd( CImgWnd *pImgWnd );
    ~CImgWnd();

    BOOL Create( DWORD dwStyle, const RECT& rect,
                 CWnd* pParentWnd, UINT nID = 0 );

    BOOL OnCmdMsg( UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo );

    void ClientToImage(CPoint& point );
    void ClientToImage(CRect&  rect  );
    void ImageToClient(CPoint& point );
    void ImageToClient(CRect&  rect  );

    IMG* m_pImg;

    inline IMG*  GetImg() { return m_pImg; }
           void  SetImg( IMG* pImg );
    inline CSize GetScrollPos() { return CSize( m_xScroll, m_yScroll ); }
           void  SetScroll( int xScroll, int yScroll );
           void  ShowBrush( CPoint ptHandle );
           void  PrepareForBrushChange( BOOL bPickup = TRUE, BOOL bErase = TRUE );
    inline int   GetZoom()           { return m_nZoom; }
    inline int   GetPrevZoom() const { return m_nZoomPrev; }
           void  SetZoom( int nZoom );
           BOOL  MakeBrush( HDC hSourceDC, CRect rcSource );
           void  UpdPos(const CPoint& pt) { m_ptDispPos = pt; }
    inline BOOL  IsGridVisible() { return theApp.m_bShowGrid && m_nZoom > 3; }
           void  FinishUndo( const CRect& rect );
           void  RubberBandRect( HDC hDC, MTI* pmti, BOOL bErase );
           void  EraseTracker();
           void  CheckScrollBars();
           void  GetImageRect( CRect& rect );
       CPalette* SetImgPalette( CDC* pdc, BOOL bForce = FALSE );
       HPALETTE  SetImgPalette( HDC hdc, BOOL bForce = FALSE );
       CPalette* FixupDibPalette( LPSTR lpDib, CPalette* ppalDib );
           BOOL  IsSelectionAvailable( void );
           BOOL  IsPasteAvailable( void );
           CRect GetDrawingRect( void );

    static        void     SetToolCursor();
    static inline CImgWnd* GetCurrent() { return c_pImgWndCur; }
    BOOL                   PtInTracker(CPoint cptLocation);

    protected:

    void RubberMouse         (unsigned code, MTI* pmti);
    void OnRButtonDownInSel  (CPoint *pcPointDown);
    void ZoomedInDP          ( unsigned code, unsigned mouseKeys, CPoint newPt );
    void StartSelectionDrag  ( unsigned code, CPoint newPt );
    void CancelSelectionDrag ();
    void SelectionDragHandler( unsigned code, CPoint newPt );
    void ResizeMouseHandler  ( unsigned code, CPoint newPt );
    void EndResizeOperation  ();
    void MoveBrush           ( const CRect& newSelRect );
    void OnScroll            ( BOOL bVert, UINT nSBCode, UINT nPos );
    BOOL OnMouseDown         ( UINT nFlags );
    BOOL OnMouseMessage      ( UINT nFlags );
    void CancelPainting      ();

    afx_msg int  OnCreate       ( LPCREATESTRUCT lpCreateStruct );
#if 0
    afx_msg void OnDestroy      ();
#endif
    afx_msg void OnSetFocus     ( CWnd* pOldWnd );
    afx_msg void OnKillFocus    ( CWnd* pNewWnd );
    afx_msg void OnSize         ( UINT nType, int cx, int cy );
    afx_msg void OnLButtonDown  ( UINT nFlags, CPoint point );
    afx_msg void OnLButtonDblClk( UINT nFlags, CPoint point );
    afx_msg void OnLButtonUp    ( UINT nFlags, CPoint point );
    afx_msg void OnRButtonDown  ( UINT nFlags, CPoint point );
    afx_msg void OnRButtonDblClk( UINT nFlags, CPoint point );
    afx_msg void OnRButtonUp    ( UINT nFlags, CPoint point );
    afx_msg void OnKeyDown      ( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg void OnKeyUp        ( UINT nChar, UINT nRepCnt, UINT nFlags );
    afx_msg void OnMouseMove    ( UINT nFlags, CPoint point );
    afx_msg void OnTimer        ( UINT nIDEvent );
    afx_msg void OnVScroll      ( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
    afx_msg void OnHScroll      ( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
    afx_msg void OnPaint        ();
    afx_msg void OnCancelMode   ();
    afx_msg void OnWindowPosChanging( WINDOWPOS FAR* lpwndpos );
    afx_msg void OnDestroyClipboard();
    afx_msg void OnPaletteChanged(CWnd *);
    afx_msg BOOL OnSetCursor        (CWnd *pWnd, UINT nHitTest, UINT message);
    afx_msg BOOL OnMouseWheel   (UINT nFlags, short zDelta, CPoint pt);
    void CmdSmallBrush();
    void CmdSmallerBrush();
    void CmdLargerBrush();
    void CmdClearImage();
    void CmdShowGrid();
#ifdef  GRIDOPTIONS
    void CmdGridOptions();
    void CmdShowTileGrid();
#endif  // GRIDOPTIONS
    void CmdInvMode();
    void CmdTransMode();

    void CmdCopy();
    void CmdCut();
    void CmdPaste();
    void CmdClear();

    void CmdInvertColors();
    void CmdTglOpaque();
    void CmdFlipBshH();
    void CmdFlipBshV();
    void CmdRot90();
    void CmdSkewBrush( int wAngle, BOOL bHorz );
    void CmdDoubleBsh();
    void CmdHalfBsh();
    void CmdSel2Bsh();

    void CmdExport();

    void CmdCancel();
    void CmdOK();

    void GetDrawRects(const CRect* pPaintRect, const CRect* pReqDestRect,
        CRect& srcRect, CRect& destRect);

    void DrawGrid(CDC* pDC, const CRect& srcRect, CRect& destRect);
    void DrawBackground(CDC* pDC, const CRect* pPaintRect = NULL);
    void DrawTracker(CDC* pDC = NULL, const CRect* pPaintRect = NULL);
    void DrawImage(CDC* pDC, const CRect* pPaintRect,
                                   CRect* pDestRect = NULL, BOOL bDoGrid = TRUE);
    void SetThumbnailView( CThumbNailView* pwndNewThumbnailView )
                   { m_pwndThumbNailView = pwndNewThumbnailView; }

    BOOL PasteImageClip();
    BOOL PasteImageFile( LPSTR lpDib );
    HBITMAP CopyDC( CDC* pImgDC, CRect* prcClip );
    void CopyBMAndPal(HBITMAP *pBM, CPalette ** ppPal);

    CImgWnd* m_pNextImgWnd; // next viewer link

    int      m_nZoom;
    int      m_nZoomPrev;

    int      m_xScroll;
    int      m_yScroll;
    int      m_LineX;     // this is 1/32 of the bitmap height
    int      m_LineY;     // this is 1/32 of the bitmap width

    CPoint   m_ptDispPos;

    WORD     m_wClipboardFormat;

    HGLOBAL  m_hPoints;

    CThumbNailView* m_pwndThumbNailView;

    DECLARE_MESSAGE_MAP()

    friend class CPBFrame;
    friend class CPBView;
    friend class CBitmapObj;
    friend class CSelectTool;
    friend class CTextTool;
    friend class CCurveTool;
    friend class CTedit;
    friend class CAttrEdit;
    friend class CImgToolWnd; // for key message forwarding
    friend class CImgColorsWnd;
    friend class CCursorIconToolWnd;
    friend BOOL  SetImgSize(IMG*, CSize, BOOL);
    friend void  SetDrawColor(COLORREF);
    friend void  SetEraseColor(COLORREF);
    friend void  SetTransColor(COLORREF);
    friend void  FreeImg(IMG* pImg);
    friend void  AddImgWnd(IMG*, CImgWnd*);
    friend void  InvalImgRect(IMG* pImg, CRect* prc);
    friend void  CommitSelection(BOOL);

    private:
    short m_WheelDelta;
    };

BOOL FillBitmapObj(CImgWnd* pImgWnd, CBitmapObj* pResObject, IMG* pImgStruct,
        int iColor = -1);

extern CImgWnd*  g_pMouseImgWnd;
extern CImgWnd*  g_pDragBrushWnd;

extern CRect   rcDragBrush;

#endif // __IMGWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\ipframe.cpp ===
// ipframe.cpp : implementation of the CInPlaceFrame class
//

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "minifwnd.h"
#include "imgwell.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "global.h"
#include "colorsrc.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

#include "memtrace.h"

/***************************************************************************/
// CInPlaceFrame

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
    //{{AFX_MSG_MAP(CInPlaceFrame)
    ON_WM_CREATE()
        ON_WM_SIZE()
        ON_WM_SYSCOLORCHANGE()
        ON_WM_CLOSE()
        //}}AFX_MSG_MAP

    ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)

    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, OnHelpIndex)
    ON_COMMAND(ID_HELP_USING, OnHelpUsing)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelpIndex)
    ON_COMMAND(ID_CONTEXT_HELP, OnContextHelp)
   

        ON_UPDATE_COMMAND_UI(ID_VIEW_TOOL_BOX, COleIPFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_TOOL_BOX, COleIPFrameWnd::OnBarCheck)
        ON_UPDATE_COMMAND_UI(ID_VIEW_COLOR_BOX, COleIPFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_COLOR_BOX, COleIPFrameWnd::OnBarCheck)
END_MESSAGE_MAP()

/***************************************************************************/
// CInPlaceFrame construction/destruction

CInPlaceFrame::CInPlaceFrame()
    {
    theApp.m_pwndInPlaceFrame = this;
    }

/***************************************************************************/

CInPlaceFrame::~CInPlaceFrame()
    {
    theApp.m_pwndInPlaceFrame = NULL;
    theApp.m_hwndInPlaceApp   = NULL;

    g_pStatBarWnd = 0;
    g_pImgToolWnd = 0;
    g_pImgColorsWnd = 0;
    }

/***************************************************************************/

CWnd* CInPlaceFrame::GetMessageBar()
    {
    CPBFrame* pwndMain = (CPBFrame*)theApp.m_pMainWnd;

    if (pwndMain                   != NULL
    &&  pwndMain->m_statBar.m_hWnd != NULL)
        return &(pwndMain->m_statBar);

    return NULL;
    }

/***************************************************************************/

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
    {
    if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    // CResizeBar implements in-place resizing.
    if (! m_wndResizeBar.Create( this ))
        {
        TRACE(TEXT("MSPaint Failed to create resize bar\n"));
        return -1;      // fail to create
        }

    // By default, it is a good idea to register a drop-target that does
    //  nothing with your frame window.  This prevents drops from
    //  "falling through" to a container that supports drag-drop.
    m_dropTarget.Register( this );

    return 0;
    }

/******************************************************************************/

BOOL CInPlaceFrame::OnCreateControlBars( CFrameWnd* pWndFrame, CFrameWnd* pWndDoc )
    {
    theApp.m_hwndInPlaceApp = pWndFrame->GetSafeHwnd();

    CPBView* pView = (CPBView*)GetActiveView();

    ASSERT( pView != NULL );

    if (pView == NULL || ! pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        return FALSE;

        g_pStatBarWnd = &m_statBar;
        g_pImgToolWnd = &m_toolBar;
        g_pImgColorsWnd = &m_colorBar;

    pView->SetTools();

    return TRUE;
    }

/***************************************************************************/

void CInPlaceFrame::RepositionFrame( LPCRECT lpPosRect, LPCRECT lpClipRect )
    {
    COleIPFrameWnd::RepositionFrame( lpPosRect, lpClipRect );

        // The other control bars can overlap and result in mispaints
    if ( IsWindow(m_wndResizeBar.m_hWnd) )
                m_wndResizeBar.Invalidate();
    }

/***************************************************************************/

void CInPlaceFrame::OnSize(UINT nType, int cx, int cy)
    {
    COleIPFrameWnd::OnSize( nType, cx, cy );


        TRACE( TEXT("MSPaint New Size %d x %d\n"), cx, cy );
    }

/***************************************************************************/
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
    {
    COleIPFrameWnd::AssertValid();
    }

/***************************************************************************/

void CInPlaceFrame::Dump(CDumpContext& dc) const
    {
    COleIPFrameWnd::Dump(dc);
    }
#endif //_DEBUG

/***************************************************************************/

void CInPlaceFrame::OnSysColorChange()
{
        COleIPFrameWnd::OnSysColorChange();

        ResetSysBrushes();
}

/***************************************************************************/


void CInPlaceFrame::OnClose()
{
        // TODO: Add your message handler code here and/or call default
        SaveBarState(TEXT("General"));
        CancelToolMode (FALSE);
        COleIPFrameWnd::OnClose();
}

void CInPlaceFrame::OnHelpIndex()
{
    ::HtmlHelpA( ::GetDesktopWindow(), "mspaint.chm", HH_DISPLAY_TOPIC, 0L );
}

LRESULT CInPlaceFrame::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
        // Just make sure this message does not get passed to the parent
        return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\interlac.h ===
/*********************************************************************
   Interlace.h

   Header file for interlace module.
 *********************************************************************/
#ifndef  _INTERLACE_H
#define  _INTERLACE_H

#include "Image.h"

#define  NUM_PASSES  7

#pragma pack(2)      /* Apparently, this is reasonably important  */

/* The primary state data structure.           */
typedef struct
{
	IFLCLASS Class;
	long     iImageHeight;
	long     iImageWidth;
	long     cbPixelSize;

	long     cScanBlocks;
	long     cPassScanLines[NUM_PASSES];
	long     cTotalScanLines;
	long     iPass;
	long     iPassLine;
	long     iScanLine;
	long     iImageLine;

} ADAM7_STRUCT, *pADAM7_STRUCT;


//************************************************************************************
// Given an image described by the parameters of the ADAM7_STRUCT, calculate the
// number of scan lines in the image file which has been interlaced using the Adam7 
// scheme.
//************************************************************************************
int iADAM7CalculateNumberOfScanLines(pADAM7_STRUCT ptAdam7);

//************************************************************************************
// Generate a deinterlaced DIB; i.e., each pixel is in BGR in the case
// of RGB/RGBA image classes, and raster line data is stored in a contiguous block.
//************************************************************************************
// The CALLING application is responsible for deallocating the structure created by
// this function.
LPBYTE *ppbADAM7InitDIBPointers(LPBYTE pbDIB, pADAM7_STRUCT ptAdam7, DWORD cbImageLine);

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToDIB(LPBYTE *ppbDIBPtrs, LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7);

//************************************************************************************

//************************************************************************************
// Generate a deinterlaced image; i.e., each pixel is in RGB in the case
// of RGB/RGBA image classes, and raster line data may not necessarily be stored 
// in one contiguous block of memory.
//************************************************************************************

// The following returns TRUE if the scan line was an empty scan line.
BOOL ADAM7AddRowToImageBuffer(LPBYTE ppbInmageBuffer[], LPBYTE pbScanLine, pADAM7_STRUCT ptAdam7);
//************************************************************************************

//************************************************************************************
// Generate a deinterlaced alpha channel data block.
//************************************************************************************
BOOL ADAM7RMFDeinterlaceAlpha(LPWORD *ppwInterlaced, LPWORD *ppwDeinterlaced,
                              IFL_ALPHA_CHANNEL_INFO *ptIFLAlphaInfo);

#endif // _INTERLACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\loadimag.cpp ===
//
// loadimag.cpp
//
// implementation of loading a file from disk via an installed graphic filter
//

#include "stdafx.h"
#include "pbrush.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "loadimag.h"
#include "bmpstrm.h"
#include "imaging.h"

#include <atlbase.h>

// must define one of the following:
//#define _USE_FLT_API
#ifdef _X86_
#define _USE_IFL_API
#endif

#ifdef _USE_FLT_API
#include "filtapi.h"
#endif

#ifdef _USE_IFL_API
#include "image.h"
#include "interlac.h"
#define MAX_PAL_SIZE 256

#ifdef PNG_SUPPORT // for Portable Network Graphics. As of 12/10/1996 the support was broken

//----------------------------------------------------------------------------
//    Places a line of image data from an ADAM 7 interlaced file (i.e., currently
//    a PNG file) into its correct position in a memory buffer: this memory
//    buffer is essentially an array of pointers to the rows of the image in
//    which the pixel data is to be set.
//----------------------------------------------------------------------------
 IFLERROR ReadADAM7InterlacedImage(LPBYTE apbImageBuffer[], IFLHANDLE pfpbFROM,
                                         int ImageHeight, int ImageWidth, int cbPixelSize,
                                         IFLCLASS ImageClass)
{


        int cRasterLines = iflGetRasterLineCount(pfpbFROM);

        ADAM7_STRUCT stAdam7;
        stAdam7.iImageHeight = ImageHeight;
        stAdam7.iImageWidth = ImageWidth;
        stAdam7.Class = ImageClass;
        stAdam7.cbPixelSize = iflGetBitsPerPixel (pfpbFROM)/8;//cbPixelSize;
        stAdam7.iPassLine = 0;
        LPBYTE pbScanLine = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, ImageWidth * stAdam7.cbPixelSize);
        wsprintf (buf, TEXT("Pixel size: %d, Size of a scan line: %d\n"), stAdam7.cbPixelSize,
                          ImageWidth*stAdam7.cbPixelSize);

        if (pbScanLine == NULL)
                return IFLERR_MEMORY;

        int cTotalScanLines = iADAM7CalculateNumberOfScanLines(&stAdam7);

        int iLine;
        IFLERROR idErr;
        BOOL fEmptyLine;

        for (iLine = 0, idErr = IFLERR_NONE, fEmptyLine = FALSE;
                idErr == IFLERR_NONE && iLine < (int)cRasterLines;
                iLine++)
        {
                if (!fEmptyLine)
                        idErr = iflRead(pfpbFROM, pbScanLine, 1);

                stAdam7.iScanLine = iLine;
                fEmptyLine = ADAM7AddRowToImageBuffer(apbImageBuffer, pbScanLine, &stAdam7);
        }

        HeapFree(GetProcessHeap(), 0, pbScanLine);
        return idErr;
}

//----------------------------------------------------------------------------
//    Deallocates the image space allocated in the function AllocateImageSpace()
//----------------------------------------------------------------------------
 LPBYTE *FreeImageSpace(HANDLE hHeap, LPBYTE ppImageSpace[], int height)
{
        if (ppImageSpace != NULL)
        {
                for (int i = 0; i < height; i++)
                {
                        if (ppImageSpace[i] != NULL)
                        {
                                HeapFree(hHeap, 0, ppImageSpace[i]);
                                ppImageSpace[i] = NULL;
                        }
                }

                HeapFree(hHeap, 0, ppImageSpace);
                ppImageSpace = NULL;
        }

        return ppImageSpace;
}

//----------------------------------------------------------------------------
//    Allocate some image space: this function will create a dynamic array
//    of "height" pointers which each point to an allocated row of bytes of
//    size "width".
//----------------------------------------------------------------------------
 LPBYTE *AllocateImageSpace(HANDLE hHeap, int height, int width, int cbSize)
{
        LPBYTE *ppImageSpace = (LPBYTE *)HeapAlloc(hHeap, 0, height * sizeof(void *));
        TCHAR buf[200];
        wsprintf (buf, TEXT("Size of image line: %d\n"), width*cbSize);


        if (ppImageSpace != NULL)
        {
                // Init the pointers to NULL: this makes error recovery easier
                for (int i = 0; i < height; i++)
                        ppImageSpace[i] = NULL;

                // NOW allocate the pointer space for the image
                for (i = 0; i < height; i++)
                {
                        ppImageSpace[i] = (LPBYTE)HeapAlloc(hHeap, 0, width * cbSize);
                        if (ppImageSpace[i] == NULL)
                                break;
                }

                if (i < height) // We weren't able to allocate the required space
                        ppImageSpace = FreeImageSpace(hHeap, ppImageSpace, height);
        }

        return ppImageSpace;
}
#endif // PNG_SUPPORT

#endif // _USE_IFL_API



// returns a pointer to the extension of a file.
//
// in:
//      qualified or unqualfied file name
//
// returns:
//      pointer to the extension of this file.  if there is no extension
//      as in "foo" we return a pointer to the NULL at the end
//      of the file
//
//      foo.txt     ==> ".txt"
//      foo         ==> ""
//      foo.        ==> "."
//

LPCTSTR FindExtension(LPCTSTR pszPath)
{
        for (LPCTSTR pszDot = NULL; *pszPath; pszPath = CharNext(pszPath))
        {
                switch (*pszPath)
                {
                        case TEXT('.'):
                                pszDot = pszPath;       // remember the last dot
                                break;
                        case TEXT('\\'):
                        case TEXT(' '):                               // extensions can't have spaces
                                pszDot = NULL;          // forget last dot, it was in a directory
                                break;
                }
        }

        // if we found the extension, return ptr to the dot, else
        // ptr to end of the string (NULL extension)
        return pszDot ? pszDot : pszPath;
}

//
// GetFilterInfo
//
//  32-bit import filters are listed in the registry...
//
//  HKLM\SOFTWARE\Microsoft\Shared Tools\Graphics Filters\Import\XXX
//      Path        = filename
//      Name        = friendly name
//      Extenstions = file extenstion list
//
#pragma data_seg(".text")
static const TCHAR c_szImpHandlerKey[] = TEXT("SOFTWARE\\Microsoft\\Shared Tools\\Graphics Filters\\Import");
static const TCHAR c_szExpHandlerKey[] = TEXT("SOFTWARE\\Microsoft\\Shared Tools\\Graphics Filters\\Export");
static const TCHAR c_szName[] = TEXT("Name");
static const TCHAR c_szPath[] = TEXT("Path");
static const TCHAR c_szExts[] = TEXT("Extensions");
static const TCHAR c_szImageAPI[] = TEXT("Image API Enabled Filters");
#pragma data_seg()

BOOL GetInstalledFilters(BOOL bOpenFileDialog, int i, LPTSTR szName, UINT cbName,
                LPTSTR szExt, UINT cbExt, LPTSTR szHandler, UINT cbHandler, BOOL& bImageAPI)
{
        HKEY hkey;
        HKEY hkeyT;
        TCHAR ach[80];
        BOOL rc = FALSE;        // return code

        bImageAPI = FALSE;

        if (RegOpenKey(HKEY_LOCAL_MACHINE,
                bOpenFileDialog ? c_szImpHandlerKey : c_szExpHandlerKey, &hkey) == 0)
        {
                if (RegEnumKey(hkey, i, ach, sizeof(ach)/sizeof(ach[0]))==0)
                {
                        if (RegOpenKey(hkey, ach, &hkeyT) == 0)
                        {
                                if (szName)
                                {
                                        szName[0] = 0;
                                        RegQueryValueEx(hkeyT, c_szName, NULL, NULL,
                                                (LPBYTE)szName, (LPDWORD)&cbName);
                                }
                                if (szExt)
                                {
                                        szExt[0] = 0;
                                        RegQueryValueEx(hkeyT, c_szExts, NULL, NULL,
                                                (LPBYTE)szExt, (LPDWORD)&cbExt);
                                }
                                if (szHandler)
                                {
                                        szHandler[0] = 0;
                                        RegQueryValueEx(hkeyT, c_szPath, NULL, NULL,
                                                (LPBYTE)szHandler, (LPDWORD)&cbHandler);
                                }

                                RegCloseKey(hkeyT);
                                rc = TRUE;
                        }

                        TCHAR szEnabledFilters[1024];
                        DWORD dwEnabledFiltersSize = sizeof(szEnabledFilters);

                        // Does the filter support Image Library Files API ?

                        if (RegQueryValueEx(hkey, c_szImageAPI, NULL, NULL,
                                (LPBYTE)szEnabledFilters, &dwEnabledFiltersSize) == 0)
                        {
                            for (
                                LPCTSTR pExt = _tcstok(szEnabledFilters, _T(" "));
                                pExt != NULL && bImageAPI != TRUE;
                                pExt = _tcstok(NULL, _T(" "))) 
                            {
                                if (_tcsicmp(pExt, ach) == 0) 
                                {
                                    bImageAPI = TRUE;
                                }
                            }
                        }
                }
                RegCloseKey(hkey);
        }

        return rc;
}

#ifdef _USE_FLT_API
//
//  GetHandlerForFile
//
//  find an import/export filter for the given file.
//
BOOL GetHandlerForFile(BOOL bImport, LPCTSTR szFile, LPTSTR szHandler, UINT cb)
{
        TCHAR    buf[40];
        BOOL    rc = FALSE;     // return code

        *szHandler = 0;

        if (szFile == NULL)
                return FALSE;

        // find the extension
        LPCTSTR ext = FindExtension(szFile);

        BOOL bImageAPI;

        for (int i = 0;
                GetInstalledFilters(bImport, i, NULL, 0, buf, sizeof(buf), szHandler, cb, bImageAPI);
                i++)
        {
                if (lstrcmpi(ext+1, buf) == 0)
                        break;
                else
                        *szHandler = 0;
        }

        // make sure the handler file does exist
        if (*szHandler && GetFileAttributes(szHandler) != -1)
                rc = TRUE;

        return rc;
}

//
// FindBitmapInfo
//
// find the DIB bitmap in a memory meta file...
//
LPBITMAPINFOHEADER FindBitmapInfo(LPMETAHEADER pmh)
{
        for (LPMETARECORD pmr = (LPMETARECORD)((LPBYTE)pmh + pmh->mtHeaderSize*2);
                pmr < (LPMETARECORD)((LPBYTE)pmh + pmh->mtSize*2);
                pmr = (LPMETARECORD)((LPBYTE)pmr + pmr->rdSize*2))
        {
                switch (pmr->rdFunction)
                {
                        case META_DIBBITBLT:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[8]);

                        case META_DIBSTRETCHBLT:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[10]);

                        case META_STRETCHDIB:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[11]);

                        case META_SETDIBTODEV:
                                return (LPBITMAPINFOHEADER)&(pmr->rdParm[9]);
                }
        }

        return NULL;
}

#endif // _USE_FLT_API

#ifdef _USE_IFL_API
  IFLERROR ReadGIFInterlacedImage(BYTE *ppbImageBuffer,
                                      IFLHANDLE pfpbFROM,
                                      int ImageHeight, DWORD dwWidthInBytes)
{
    int          iLine, iPass, iIntLine, iTempLine;
    IFLERROR   idErr;


    WORD       InterlaceMultiplier[] = { 8, 8, 4, 2 };
    WORD       InterlaceOffset[]     = { 0, 4, 2, 1 };

    idErr = IFLERR_NONE;

    iPass = 0;
    iIntLine = InterlaceOffset[iPass];
    iLine = 0;
    while (idErr == IFLERR_NONE && iLine < ImageHeight)
    {
       iTempLine = InterlaceMultiplier[iPass] * iIntLine + InterlaceOffset[iPass];
       if (iTempLine >= ImageHeight)
       {
           iPass++;
           iIntLine = 0;
           iTempLine = InterlaceOffset[iPass];
       }

       if (iTempLine < ImageHeight)
       {
           idErr = iflRead(pfpbFROM,
                     (LPBYTE)ppbImageBuffer+((ImageHeight-iTempLine-1)*dwWidthInBytes),
                           1);
           iLine++;
       }
       iIntLine++;
    }

    return idErr;
}
#endif // _USE_IFL_API

//
//  LoadDIBFromFile
//
//  load a image file using a image import filter. The filters use ANSI strings.
//

HGLOBAL LoadDIBFromFileA(LPCSTR szFileName, GUID *pguidFltTypeUsed)
{
#ifdef _USE_IFL_API

        IFLTYPE iflType;

        iflImageType((LPSTR)szFileName, &iflType);

        // make sure the image is of a type we know how to import
        if (iflType == IFLT_PNG)
        {
           return NULL;
        }

        IFLHANDLE iflHandle = iflCreateReadHandle(iflType);
        if (!iflHandle)
        {
           //
           // No filter installed for this type
           //
           return NULL;
        }

        LPBYTE lpStart = 0;

    __try 
    {

        IFLERROR iflErr = iflOpen(iflHandle, (LPSTR)szFileName, IFLM_READ);
        if (iflErr != IFLERR_NONE)
        {
                iflFreeHandle(iflHandle);
                return NULL;
        }

        ASSERT(pguidFltTypeUsed);

        switch (iflType)
        {
            case IFLT_GIF:  *pguidFltTypeUsed = WiaImgFmt_GIF;       break;
            case IFLT_BMP:  *pguidFltTypeUsed = WiaImgFmt_BMP;       break;
            case IFLT_JPEG: *pguidFltTypeUsed = WiaImgFmt_JPEG;      break;
            case IFLT_TIFF: *pguidFltTypeUsed = WiaImgFmt_TIFF;      break;
            case IFLT_PNG:  *pguidFltTypeUsed = WiaImgFmt_PNG;       break;
            case IFLT_PCD:  *pguidFltTypeUsed = WiaImgFmt_PHOTOCD;   break;
            default:        *pguidFltTypeUsed = WiaImgFmt_UNDEFINED; break;
        }

        IFLCLASS        iflClass = iflGetClass(iflHandle);
        IFLSEQUENCE     iflSequence = iflGetSequence(iflHandle);
        IFLCOMPRESSION  iflCompression = iflGetCompression(iflHandle);
        WORD            iBPS = (WORD) iflGetBitsPerChannel(iflHandle);

        if (iflClass != IFLCL_RGB && iflClass != IFLCL_PALETTE &&
            iflClass != IFLCL_GRAY && iflClass != IFLCL_BILEVEL)
        {
#ifdef _DEBUG
           TRACE(TEXT("LoadDIBFromFile: Not a RGB/PALETTE/GRAY/BW image.\n"));
           MessageBox (NULL, TEXT("Not a RGB/PALETTE/GRAY/BW image."),
                             TEXT("Loadimag.cpp"), MB_OK);
#endif
           iflClose(iflHandle);
           iflFreeHandle(iflHandle);
           return NULL;
        }

        // get the transparent color
        if (iflClass == IFLCL_RGB)
        {
                IFLCOLOR iflTransColor;
                g_bUseTrans = (IFLERR_NONE ==
                        iflControl(iflHandle, IFLCMD_TRANS_RGB, 0, 0, &iflTransColor));
                if (g_bUseTrans)
                        crTrans = RGB(iflTransColor.wRed,
                                                  iflTransColor.wGreen,
                                                  iflTransColor.wBlue);
        }
        else // must be IFLCL_PALETTE or IFLCL_GRAY or IFLCL_BILEVEL
        {
                BYTE byTransIdx;
                g_bUseTrans = (IFLERR_NONE ==
                        iflControl(iflHandle, IFLCMD_TRANS_IDX, 0, 0, &byTransIdx));
                if (g_bUseTrans)
                        crTrans = byTransIdx; // need to convert to COLORREF below
        }

        BITMAPINFOHEADER bi;
        memset(&bi, 0, sizeof(BITMAPINFOHEADER));

        bi.biSize = sizeof(BITMAPINFOHEADER); // should be 0x28 or 40 decimal
        bi.biWidth = iflGetWidth(iflHandle);
        bi.biHeight = iflGetHeight(iflHandle);
        bi.biPlanes = 1;




        if (iflClass == IFLCL_RGB)
        {
#ifdef PNG_SUPPORT
           if (iflType == IFLT_PNG)
           {
              bi.biBitCount = iBPS*3;
           }
           else
#endif // PNG_SUPPORT
           {
              bi.biBitCount = (WORD) iflGetBitsPerPixel (iflHandle);
           }
        }
        else // must be IFLCL_PALETTE or IFLCL_GRAY or IFLCL_BILEVEL
        {
           bi.biBitCount = 8;
        }



        bi.biCompression = 0;
        // convert width in pixels to bytes after rounding it up first
        DWORD dwWidthInBytes = ((bi.biWidth * bi.biBitCount + 31) & ~31)/8;
        bi.biSizeImage = abs(bi.biHeight) * dwWidthInBytes;
//      bi.biXPelsPerMeter = 0;
//      bi.biYPelsPerMeter = 0;
        if (iflClass == IFLCL_PALETTE || iflClass == IFLCL_GRAY
             || iflClass == IFLCL_BILEVEL)
                bi.biClrUsed = MAX_PAL_SIZE;
//      bi.biClrImportant = 0;

        LPBYTE lpBMP;

        if ((lpBMP = lpStart = (LPBYTE) GlobalAlloc(GMEM_FIXED, 
                bi.biSize + bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage)) == NULL)
                goto exit;

        memcpy(lpBMP, &bi, bi.biSize);
        lpBMP += bi.biSize;

        BYTE    byTemp;
        int             i, j;

        switch (iflSequence)
        {
           case IFLSEQ_TOPDOWN:
              switch (iflClass)
              {
                 case IFLCL_RGB:

                    lpBMP += bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage -
                    dwWidthInBytes;
                    for (i = 0; i < abs(bi.biHeight); lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                       // need to swap RED with BLUE for internal DIB display
                       for (j = 0; j < bi.biWidth*3; j+=3)
                       {
                          byTemp = *(lpBMP+j);
                          *(lpBMP+j) = *(lpBMP+j+2);
                          *(lpBMP+j+2) = byTemp;
                       }
                    }
                    break;

                 case IFLCL_PALETTE:

                    // get palette info first...
                    RGBTRIPLE Pal3[MAX_PAL_SIZE];
                    RGBQUAD   Pal4[MAX_PAL_SIZE];
                    ZeroMemory (Pal3, MAX_PAL_SIZE*(sizeof(RGBTRIPLE)));
                    iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

                    for (i = 0; i < MAX_PAL_SIZE; i++)
                    {
                       Pal4[i].rgbBlue     = Pal3[i].rgbtRed;
                       Pal4[i].rgbGreen    = Pal3[i].rgbtGreen;
                       Pal4[i].rgbRed      = Pal3[i].rgbtBlue;
                       Pal4[i].rgbReserved = 0;
                    }
                    memcpy(lpBMP, Pal4, sizeof(Pal4));

                    if (g_bUseTrans)
                    // convert the transparent color index to COLORREF
                       crTrans = RGB(Pal4[crTrans].rgbRed,Pal4[crTrans].rgbGreen,
                                             Pal4[crTrans].rgbBlue);

                    lpBMP += sizeof(Pal4) + bi.biSizeImage - dwWidthInBytes;

                    for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }

                    break;

                 case IFLCL_GRAY:

                    // get palette info first...
                    //BYTE PalGray[MAX_PAL_SIZE];
                    //iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &PalGray);

                    for (i = 0; i < MAX_PAL_SIZE; i++)
                    {
                       Pal4[i].rgbBlue     = (BYTE) i;//PalGray[i];
                       Pal4[i].rgbGreen    = (BYTE) i;//PalGray[i];
                       Pal4[i].rgbRed      = (BYTE) i;//PalGray[i];
                       Pal4[i].rgbReserved = 0;
                    }
                    memcpy(lpBMP, Pal4, sizeof(Pal4));

                    if (g_bUseTrans)
                    // convert the transparent color index to COLORREF
                       crTrans = RGB(Pal4[crTrans].rgbRed, Pal4[crTrans].rgbGreen,
                                                   Pal4[crTrans].rgbBlue);

                    lpBMP += sizeof(Pal4) + bi.biSizeImage - dwWidthInBytes;

                    for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }

                    break;

                 case IFLCL_BILEVEL:

                    // set color Black
                    Pal4[0].rgbBlue     = 0;
                    Pal4[0].rgbGreen    = 0;
                    Pal4[0].rgbRed      = 0;
                    Pal4[0].rgbReserved = 0;

                    // set color White
                    Pal4[1].rgbBlue     = 255;
                    Pal4[1].rgbGreen    = 255;
                    Pal4[1].rgbRed      = 255;
                    Pal4[1].rgbReserved = 0;

                    memcpy(lpBMP, Pal4, sizeof(Pal4));

                    if (g_bUseTrans)
                       // convert the transparent color index to COLORREF
                       crTrans = RGB(Pal4[crTrans].rgbRed,
                                     Pal4[crTrans].rgbGreen,
                                     Pal4[crTrans].rgbBlue);

                    lpBMP += sizeof(Pal4) + bi.biSizeImage - dwWidthInBytes;

                    for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }
                    break;

                 default:
                 // currently not supported
                    break;
              }
              break;

           case IFLSEQ_BOTTOMUP:

              lpBMP += bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage - dwWidthInBytes;

              for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
              {
                 // read in one line at a time
                 iflRead(iflHandle, (LPBYTE)lpBMP, 1);

                 // need to swap RED with BLUE for internal DIB display
                 for (j = 0; j < bi.biWidth*3; j+=3)
                 {
                    byTemp = *(lpBMP+j);
                    *(lpBMP+j) = *(lpBMP+j+2);
                    *(lpBMP+j+2) = byTemp;
                 }
              }
              break;

           case IFLSEQ_GIF_INTERLACED:
           {

              // get color palette info first...
              RGBTRIPLE Pal3[MAX_PAL_SIZE];
              RGBQUAD   Pal4[MAX_PAL_SIZE];
              iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

              for (i = 0; i < MAX_PAL_SIZE; i++)
                 {
                    Pal4[i].rgbBlue     = Pal3[i].rgbtRed;
                    Pal4[i].rgbGreen    = Pal3[i].rgbtGreen;
                    Pal4[i].rgbRed      = Pal3[i].rgbtBlue;
                    Pal4[i].rgbReserved = 0;
                 }
                 memcpy(lpBMP, Pal4, sizeof(Pal4));

                 if (g_bUseTrans)
                 // convert the transparent color index to COLORREF
                    crTrans = RGB(Pal4[crTrans].rgbRed,Pal4[crTrans].rgbGreen,
                                                       Pal4[crTrans].rgbBlue);

              LPBYTE lpTemp = lpBMP + sizeof(Pal4);
              ReadGIFInterlacedImage (lpTemp, iflHandle, bi.biHeight, dwWidthInBytes);

           }
           break;
/*         case 1010101:
              {

                 int IM[] = { 8, 8, 4, 2 }; // interlace multiplier
                 //int IO[] = { 1, 5, 3 ,2 }; // interface offset
                 int IO[] = { 0, 4, 2,1 };

                 for (j = 0; j < 4; j++)
                 {
                    lpBMP = lpTemp + bi.biSizeImage - dwWidthInBytes*IO[j];
                    for (i = 0; i < abs(bi.biHeight) && lpBMP >= lpTemp;
                                 lpBMP-=dwWidthInBytes*IM[j], i+=8)
                    {
                       // read in one line at a time
                       iflRead(iflHandle, (LPBYTE)lpBMP, 1);
                    }
                 }

                 break;
              }*/
#ifdef PNG_SUPPORT
           case IFLSEQ_ADAM7_INTERLACED:
           {

              // get color palette info first...
              RGBTRIPLE Pal3[MAX_PAL_SIZE];
              RGBQUAD   Pal4[MAX_PAL_SIZE];
              iflErr = iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

              for (i = 0; i < MAX_PAL_SIZE; i++)
              {
                 Pal4[i].rgbBlue     = Pal3[i].rgbtRed;
                 Pal4[i].rgbGreen    = Pal3[i].rgbtGreen;
                 Pal4[i].rgbRed      = Pal3[i].rgbtBlue;
                 Pal4[i].rgbReserved = 0;
              }
              memcpy(lpBMP, Pal4, sizeof(Pal4));

              if (g_bUseTrans)
                 // convert the transparent color index to COLORREF
                 crTrans = RGB(Pal4[crTrans].rgbRed,
                               Pal4[crTrans].rgbGreen,
                               Pal4[crTrans].rgbBlue);
/////////////////////////////
                HANDLE hHeap = GetProcessHeap();
                LPBYTE *ppbRGBRowPtrs =(LPBYTE *)AllocateImageSpace(hHeap,
                                      bi.biHeight, dwWidthInBytes, /*bi.biWidth, */sizeof(BYTE));

                if (ppbRGBRowPtrs != NULL)
                {
                // First get the image. This function will de-interlace the image
                // AND any alpha channel information: it will also resize the alpha
                // channel data structure to the image height from the number of
                // raster lines, if necessary.
                   iflErr = ReadADAM7InterlacedImage(ppbRGBRowPtrs, iflHandle,
                                                    bi.biHeight, bi.biWidth,
                                                    sizeof(BYTE)*3, iflClass);
/////////////////////////////

                   if (iflErr == IFLERR_NONE)
                   {
                      lpBMP += bi.biClrUsed*sizeof(RGBQUAD) + bi.biSizeImage -
                                             dwWidthInBytes;
                      for (i = 0;i < abs(bi.biHeight);lpBMP-=dwWidthInBytes, i++)
                      {
                         // read in one line at a time
                         memcpy((LPBYTE)lpBMP, ppbRGBRowPtrs[i], dwWidthInBytes);

                         // need to swap RED with BLUE for internal DIB display
                         for (j = 0; j < bi.biWidth*3; j+=3)
                         {
                            byTemp = *(lpBMP+j);
                            *(lpBMP+j) = *(lpBMP+j+2);
                            *(lpBMP+j+2) = byTemp;
                         }
                     }
                  }

                  ppbRGBRowPtrs = (LPBYTE *)FreeImageSpace(hHeap,
                                                           ppbRGBRowPtrs,
                                                           bi.biHeight);
                }
                break;

             }
#endif // PNG_SUPPORT
             default:
                break;
        }

    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

exit:
        iflClose(iflHandle);
        iflFreeHandle(iflHandle);

        return (HGLOBAL)lpStart;

#endif // _USE_IFL_API

//////////////////////////////////////////////////////////////////////////////

#ifdef _USE_FLT_API

        HINSTANCE           hLib = NULL;
        FILESPEC            fileSpec;               // file to load
        GRPI                            pict;
        UINT                rc;                     // return code
        HANDLE              hPrefMem = NULL;        // filter-supplied preferences
        UINT                wFilterType;            // 2 = graphics filter
        char                szHandler[128];
        HGLOBAL             hDib = NULL;

        PFNGetFilterInfo lpfnGetFilterInfo;
        PFNImportGr lpfnImportGr;

        if (!GetHandlerForFile(TRUE, szFileName, szHandler, sizeof(szHandler)))
        return FALSE;

    if (szHandler[0] == 0)
        return FALSE;

    if ((hLib = LoadLibrary(szHandler)) == NULL)
        goto exit;

    // get a pointer to the ImportGR function
    lpfnGetFilterInfo = (PFNGetFilterInfo)GetProcAddress(hLib, "GetFilterInfo");
    lpfnImportGr = (PFNImportGr)GetProcAddress(hLib, "ImportGr");

    if (lpfnGetFilterInfo == NULL)
        lpfnGetFilterInfo = (PFNGetFilterInfo)GetProcAddress(hLib, "GetFilterInfo@16");

    if (lpfnImportGr == NULL)
        lpfnImportGr = (PFNImportGr)GetProcAddress(hLib, "ImportGr@16");

    if (lpfnImportGr == NULL)
        goto exit;

    if (lpfnGetFilterInfo != NULL)
    {
        wFilterType = (*lpfnGetFilterInfo)
            ((short) 2,                 // interface version no.
            (char *)NULL,               // unused
            (HANDLE *) &hPrefMem,       // fill in: preferences
            (DWORD) 0x00020000);        // unused in Windows

        // the return value is the type of filter: 0=error,
        // 1=text-filter, 2=graphics-filter
        if (wFilterType != 2)
            goto exit;
    }

    fileSpec.slippery = FALSE;      // TRUE if file may disappear
    fileSpec.write = FALSE;         // TRUE if open for write
    fileSpec.unnamed = FALSE;       // TRUE if unnamed
    fileSpec.linked = FALSE;        // Linked to an FS FCB
    fileSpec.mark = FALSE;          // Generic mark bit
    fileSpec.dcbFile = 0L;
    //the converters need a pathname without spaces...

    GetShortPathName(szFileName, fileSpec.szName, sizeof(fileSpec.szName));

    pict.hmf = NULL;

    rc = (*lpfnImportGr)
        (NULL,                      // "the target DC" (printer?)
        (FILESPEC *) &fileSpec,     // file to read
        (GRPI *) &pict,             // fill in: result metafile
        (HANDLE) hPrefMem);         // preferences memory

    if (pict.hmf != NULL)
    {
        if (rc == 0)
        {
            // find the BITMAPINFO in the returned metafile

            LPMETAHEADER lpMetaHeader = (LPMETAHEADER) GlobalLock(pict.hmf);

            LPBITMAPINFOHEADER lpbi = FindBitmapInfo(lpMetaHeader);

            if (lpbi != NULL)
            {
                // copy the DIB

                SIZE_T nSize = FindDibSize(lpbi);

                hDib = GlobalAlloc(GMEM_FIXED, nSize);

                CopyMemory(hDib, lpbi, nSize);
            }

            GlobalUnlock(pict.hmf);
        }

        GlobalFree(pict.hmf);
    }

exit:
    if (hPrefMem != NULL)
        GlobalFree(hPrefMem);

    if (hLib)
        FreeLibrary(hLib);

    return hDib;

#endif // _USE_FLT_API
   return NULL;
}

CGdiplusInit::CGdiplusInit(
    Gdiplus::DebugEventProc debugEventCallback       /*= 0*/,
    BOOL                    suppressBackgroundThread /*= FALSE*/,
    BOOL                    suppressExternalCodecs   /*= FALSE*/
)
{
    Gdiplus::GdiplusStartupInput StartupInput(
        debugEventCallback,
        suppressBackgroundThread,
        suppressExternalCodecs
    );

    StartupStatus = GdiplusSafeStartup(&Token, &StartupInput, this);
}

CGdiplusInit::~CGdiplusInit()
{
    if (StartupStatus == Gdiplus::Ok)
    {
        Gdiplus::GdiplusShutdown(Token);
    }
}

Gdiplus::Status
CGdiplusInit::GdiplusSafeStartup(
    ULONG_PTR                          *token,
    const Gdiplus::GdiplusStartupInput *input,
    Gdiplus::GdiplusStartupOutput      *output
)
{
    __try
    {
        return Gdiplus::GdiplusStartup(token, input, output);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return Gdiplus::GdiplusNotInitialized;
    }
}

BOOL GetGdiplusDecoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs)
{
    ASSERT(pnCodecs);
    ASSERT(ppCodecs);

    *ppCodecs = 0;
    *pnCodecs = 0;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            UINT cbCodecs;

            if (Gdiplus::GetImageDecodersSize(pnCodecs, &cbCodecs) == Gdiplus::Ok)
            {
                if (*pnCodecs > 0)
                {
                    *ppCodecs = (Gdiplus::ImageCodecInfo *) LocalAlloc(LMEM_FIXED, cbCodecs);

                    if (*ppCodecs != 0)
                    {
                        if (Gdiplus::GetImageDecoders(*pnCodecs, cbCodecs, *ppCodecs) == Gdiplus::Ok)
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

        LocalFree(*ppCodecs);

        *ppCodecs = 0;
        *pnCodecs = 0;
    }

    return FALSE;
}

BOOL GetGdiplusEncoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs)
{
    ASSERT(pnCodecs);
    ASSERT(ppCodecs);

    *ppCodecs = 0;
    *pnCodecs = 0;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            UINT cbCodecs;

            if (Gdiplus::GetImageEncodersSize(pnCodecs, &cbCodecs) == Gdiplus::Ok)
            {
                if (*pnCodecs > 0)
                {
                    *ppCodecs = (Gdiplus::ImageCodecInfo *) LocalAlloc(LMEM_FIXED, cbCodecs);

                    if (*ppCodecs != 0)
                    {
                        if (Gdiplus::GetImageEncoders(*pnCodecs, cbCodecs, *ppCodecs) == Gdiplus::Ok)
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

        LocalFree(*ppCodecs);

        *ppCodecs = 0;
        *pnCodecs = 0;
    }

    return FALSE;
}

BOOL GetClsidOfEncoder(REFGUID guidFormatID, CLSID *pClsid)
{
    Gdiplus::ImageCodecInfo *pCodecs = 0;
    UINT                     nCodecs = 0;

    GetGdiplusEncoders(&nCodecs, &pCodecs);

    for (UINT i = 0; i < nCodecs; ++i)
    {
        if (pCodecs[i].FormatID == guidFormatID)
        {
            if (pClsid)
            {
                *pClsid = pCodecs[i].Clsid;
            }

            LocalFree(pCodecs);

            return TRUE;
        }
    }

    LocalFree(pCodecs);

    return FALSE;
}

HGLOBAL LoadDIBGdiplus(LPCTSTR szFileName, GUID *pguidFltTypeUsed)
{
    // check that the BMP encoder exists

    CLSID ClsidBmpEncoder;

    if (GetClsidOfEncoder(WiaImgFmt_BMP, &ClsidBmpEncoder))
    {
         // let GDI+ import the file

        USES_CONVERSION;

        Gdiplus::Bitmap image(T2CW(szFileName));

        if (image.GetLastStatus() == Gdiplus::Ok)
        {
            // read the image type

            ASSERT(pguidFltTypeUsed);

            image.GetRawFormat(pguidFltTypeUsed);

            // create a stream that emulates a bmp file

            CComPtr<CBmpStream> pStream;
            
            if (CBmpStream::Create(&pStream) == S_OK)
            {
                // convert the image into a BMP

                if (image.Save(pStream, &ClsidBmpEncoder, 0) == Gdiplus::Ok)
                {
                    return pStream->GetBuffer();
                }

                pStream->FreeBuffer();
            }
        }
    }

    return 0;
}

HGLOBAL LoadDIBFromFile(LPCTSTR szFileName, GUID *pguidFltTypeUsed)
{
    // Try GDI+ filters first. If it fails to convert the image or 
    // if it's not available, try the old method

    HGLOBAL hResult = 0;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            hResult = LoadDIBGdiplus(szFileName, pguidFltTypeUsed);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    if (!hResult)
    {
        USES_CONVERSION;

        hResult = LoadDIBFromFileA(T2CA(szFileName), pguidFltTypeUsed);
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\loadimag.h ===
//
//  LoadImag.h
//
//  routines to load and decompress a graphics file using a MS Office
//  graphic import filter.
//

#ifndef _LOADIMAG_H_ 
#define _LOADIMAG_H_ 

class CGdiplusInit : public Gdiplus::GdiplusStartupOutput
{
public:
    CGdiplusInit(
        Gdiplus::DebugEventProc debugEventCallback       = 0,
        BOOL                    suppressBackgroundThread = FALSE,
        BOOL                    suppressExternalCodecs   = FALSE
    );

    ~CGdiplusInit();

private:
    static
    Gdiplus::Status
    GdiplusSafeStartup(
        ULONG_PTR                          *token,
        const Gdiplus::GdiplusStartupInput *input,
        Gdiplus::GdiplusStartupOutput      *output
    );

public:
    Gdiplus::Status StartupStatus;

private:
    ULONG_PTR Token;
};


#define GIF_SUPPORT
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//  GetClsidOfEncoder
//

BOOL GetClsidOfEncoder(REFGUID guidFormatID, CLSID *pClsid);

//
//  LoadDIBFromFile
//
//  load a image file using a image import filter.
//

HGLOBAL LoadDIBFromFile(LPCTSTR szFileName, GUID *pguidFltTypeUsed);

//
// GetFilterInfo
//
BOOL GetInstalledFilters (BOOL bOpenFileDialog,int i,
                          LPTSTR szName, UINT cbName,
                          LPTSTR szExt, UINT cbExt,
                          LPTSTR szHandler, UINT cbHandler,
                          BOOL& bImageAPI);

//
// Get GDI+ codecs
//

BOOL GetGdiplusDecoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs);
BOOL GetGdiplusEncoders(UINT *pnCodecs, Gdiplus::ImageCodecInfo **ppCodecs);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_LOADIMAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\mapi.h ===
/*
 *  m a p i . h
 *    
 *  Messaging Applications Programming Interface.
 *    
 *  Copyright (c) 1992-1993, Microsoft Corporation.  All rights reserved.
 *    
 *  Purpose:
 *    This file defines the structures and constants used by
 *    that subset of the messaging applications programming
 *    interface which will be supported under Windows by
 *    Microsoft Mail for PC Networks vesion 3.2.
 */



/*
 *  Types.
 */



typedef unsigned long       ULONG;
typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;
typedef unsigned long		LHANDLE, FAR *LPLHANDLE;
#define	lhSessionNull	((LHANDLE)0)

typedef struct
  {
    ULONG ulReserved;    /* Reserved for future use (must be 0) */
	ULONG flFlags;		 /* Flags */
    ULONG nPosition;     /* character in text to be replaced by attachment */
    LPTSTR lpszPathName;  /* Full path name of attachment file */
    LPTSTR lpszFileName;  /* Original file name (optional) */
    LPVOID lpFileType;   /* Attachment file type (optional) */
  } MapiFileDesc, FAR * lpMapiFileDesc;

#define	MAPI_OLE						0x00000001
#define	MAPI_OLE_STATIC					0x00000002




typedef struct
  {
    ULONG ulReserved;           /* Reserved for future use */
    ULONG ulRecipClass;         /* Recipient class */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG */
    LPTSTR lpszName;             /* Recipient name */
    LPTSTR lpszAddress;          /* Recipient address (optional) */
    ULONG ulEIDSize;	        /* Count in bytes of size of pEntryID */
    LPVOID lpEntryID;           /* System-specific recipient reference */
  } MapiRecipDesc, FAR * lpMapiRecipDesc;

#define MAPI_ORIG   0           /* Recipient is message originator */
#define MAPI_TO     1           /* Recipient is a primary recipient */
#define MAPI_CC     2           /* Recipient is a copy recipient */
#define MAPI_BCC    3           /* Recipient is blind copy recipient */



typedef struct
  {
    ULONG ulReserved;                   /* Reserved for future use (M.B. 0) */
    LPTSTR lpszSubject;                  /* Message Subject */
    LPTSTR lpszNoteText;                 /* Message Text */
    LPTSTR lpszMessageType;              /* Message Class */
    LPTSTR lpszDateReceived;             /* in YYYY/MM/DD HH:MM format    */
	LPTSTR lpszConversationID;			/* conversation thread ID */
    FLAGS flFlags;                      /* unread,return receipt */
    lpMapiRecipDesc lpOriginator;       /* Originator descriptor */
    ULONG nRecipCount;                  /* Number of recipients */
    lpMapiRecipDesc lpRecips;           /* Recipient descriptors */
    ULONG nFileCount;                   /* # of file attachments */
    lpMapiFileDesc lpFiles;             /* Attachment descriptors */
  } MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004



/*
 *  Entry points.
 */



#define MAPI_LOGON_UI                   0x00000001  /* Display logon UI */
#define MAPI_NEW_SESSION                0x00000002  /* Do not use default. */
#define MAPI_DIALOG                     0x00000008  /* Display a send note UI */
#define MAPI_UNREAD_ONLY                0x00000020  /* Only unread messages */
#define MAPI_ENVELOPE_ONLY              0x00000040  /* Only header information */
#define MAPI_PEEK                       0x00000080  /* Do not mark as read. */
#define MAPI_GUARANTEE_FIFO				0x00000100	/* use date order */
#define	MAPI_BODY_AS_FILE				0x00000200
#define MAPI_AB_NOMODIFY				0x00000400	/* Don't allow mods of AB entries */
#define	MAPI_SUPPRESS_ATTACH			0x00000800	/* header + body, no files */
#define	MAPI_FORCE_DOWNLOAD				0x00001000	/* force download of new mail during MAPILogon */

ULONG FAR PASCAL MAPILogon(ULONG ulUIParam, LPTSTR lpszName, LPTSTR lpszPassword,
                           FLAGS flFlags, ULONG ulReserved,
                           LPLHANDLE lplhSession);

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession, ULONG ulUIParam, FLAGS flFlags,
                            ULONG ulReserved);

ULONG FAR PASCAL MAPISendMail(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessage lpMessage, FLAGS flFlags,
                              ULONG ulReserved);

ULONG FAR PASCAL MAPISendDocuments(ULONG ulUIParam, LPTSTR lpszDelimChar,
                                   LPTSTR lpszFilePaths, LPTSTR lpszFileNames,
                                   ULONG ulReserved);

ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession, ULONG ulUIParam,
                              LPTSTR lpszMessageType, LPTSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPTSTR lpszMessageID);

ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession, ULONG ulUIParam,
                              LPTSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessage FAR *lppMessageOut);

ULONG FAR PASCAL MAPISaveMail(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessage pMessage, FLAGS flFlags,
                              ULONG ulReserved, LPTSTR lpszMessageID);

ULONG FAR PASCAL MAPIDeleteMail(LHANDLE lhSession, ULONG ulUIParam,
                                LPTSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);

ULONG FAR PASCAL MAPIFreeBuffer( LPVOID pv );
							
ULONG FAR PASCAL MAPIAddress(LHANDLE lhSession, ULONG ulUIParam,
					LPTSTR plszCaption, ULONG nEditFields,
					LPTSTR lpszLabels, ULONG nRecips,
					lpMapiRecipDesc lpRecips, FLAGS flFlags, ULONG ulReserved, 
					LPULONG lpnNewRecips, lpMapiRecipDesc FAR *lppNewRecips);

ULONG FAR PASCAL MAPIDetails(LHANDLE lhSession, ULONG ulUIParam,
					lpMapiRecipDesc lpRecip, FLAGS flFlags, ULONG ulReserved);

ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession, ULONG ulUIParam,
						LPTSTR lpszName, FLAGS flFlags,
						ULONG ulReserved, lpMapiRecipDesc FAR *lppRecip);



#define SUCCESS_SUCCESS                     0
#define MAPI_USER_ABORT                     1
#define MAPI_E_FAILURE                      2
#define MAPI_E_LOGIN_FAILURE                3
#define MAPI_E_DISK_FULL                    4
#define MAPI_E_INSUFFICIENT_MEMORY          5
#define MAPI_E_ACCESS_DENIED				6
#define MAPI_E_TOO_MANY_SESSIONS            8
#define MAPI_E_TOO_MANY_FILES               9
#define MAPI_E_TOO_MANY_RECIPIENTS          10
#define MAPI_E_ATTACHMENT_NOT_FOUND         11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE      12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE     13
#define MAPI_E_UNKNOWN_RECIPIENT            14
#define MAPI_E_BAD_RECIPTYPE                15
#define MAPI_E_NO_MESSAGES                  16
#define MAPI_E_INVALID_MESSAGE              17
#define MAPI_E_TEXT_TOO_LARGE               18
#define	MAPI_E_INVALID_SESSION				19
#define	MAPI_E_TYPE_NOT_SUPPORTED			20
#define	MAPI_E_AMBIGUOUS_RECIPIENT			21
#define MAPI_E_MESSAGE_IN_USE				22
#define MAPI_E_NETWORK_FAILURE				23
#define	MAPI_E_INVALID_EDITFIELDS			24
#define	MAPI_E_INVALID_RECIPS				25
#define	MAPI_E_NOT_SUPPORTED				26
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\memtrace.h ===
// Enable memory leak detection in non-CObject based code.

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\msffdefs.h ===
/*----------------------------------------------------------------------------
| Module    : hildefs.h
|
| Purpose   : platform dependent include file for HALO Imaging Library for
|             Microsoft Windows NT
|
| History   : 4/21/94
|
| Copyright 1990-1994 Media Cybernetics, Inc.
|-----------------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*-----------------------------------------------------------------
| Define the platform
|------------------------------------------------------------------*/
#define HIL_WINDOWS32     1

#ifndef _WINDOWS_
#define	WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

#define	DllExport	__declspec(dllexport)
#define DllImport	__declspec(dllimport)

#ifdef	_X86_
#define FLTAPI			__stdcall
#else
#define FLTAPI			__cdecl
#endif
#define HILAPI			__cdecl

typedef float *                 LPFLOAT;
typedef double *                LPDOUBLE;
typedef void *                  HPVOID;
typedef LPBYTE *                LPLPBYTE;
#ifndef	LPBOOL
typedef BOOL *                  LPBOOL;
#endif

typedef short *                 LPSHORT;

#ifndef S_IRUSR
#define S_IRUSR		00400
#endif
#ifndef S_IWUSR
#define S_IWUSR		00200
#endif
#ifndef S_IRGRP
#define S_IRGRP		00040
#endif
#ifndef S_IWGRP
#define	S_IWGRP		00020
#endif
#ifndef S_IROTH
#define S_IROTH		00004
#endif
#ifndef S_IWOTH
#define S_IWOTH		00002
#endif	
#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\ofn.cpp ===
#if      !defined(WINVER) || (WINVER < 0x0500)
#undef   WINVER
#pragma message("Defining WINVER as 0x0500")
#define  WINVER 0x0500
#endif //WINVER

#if      !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
#undef   _WIN32_WINNT
#pragma message("Defining _WIN32_WINNT as 0x0500")
#define  _WIN32_WINNT 0x0500
#endif //_WIN32_WINNT

#if      !defined(_WIN32_WINDOWS) || (_WIN32_WINDOWS < 0x0500)
#undef   _WIN32_WINDOWS
#pragma message("Defining _WIN32_WINDOWS as 0x0500")
#define  _WIN32_WINDOWS 0x0500
#endif //_WIN32_WINDOWS

#if      !defined(_WIN32_IE) || (_WIN32_IE < 0x0500)
#undef   _WIN32_IE
#pragma message("Defining _WIN32_IE as 0x0500")
#define  _WIN32_IE 0x0500
#endif //_WIN32_IE

#include <windows.h>
#include <commdlg.h>
#include <cderr.h>

#include "ofn.h"

////////////////////////////////////////////////////////////////////////////
// 

COpenFileName::COpenFileName(BOOL bOpenFileDialog)
{
    m_bOpenFileDialog = bOpenFileDialog;

    m_pofn = new OPENFILENAME;

    if (m_pofn) 
    {
        ZeroMemory(m_pofn, sizeof(OPENFILENAME));
        m_pofn->lStructSize = sizeof(OPENFILENAME);
    }
}

COpenFileName::~COpenFileName()
{
    delete m_pofn;
}

int COpenFileName::DoModal()
{
	int nResult;

	if (m_bOpenFileDialog)
    {
		nResult = ::GetOpenFileName(m_pofn);
    }
	else
    {
		nResult = ::GetSaveFileName(m_pofn);
    }

	if (!nResult && (CDERR_STRUCTSIZE == CommDlgExtendedError())) 
    {
        // if comdlg32 does not recognize the OPENFILENAME size 
        // retry with the old (ver 4) struct size

        m_pofn->lStructSize = OPENFILENAME_SIZE_VERSION_400;
		
	    if (m_bOpenFileDialog)
        {
		    nResult = ::GetOpenFileName(m_pofn);
        }
	    else
        {
		    nResult = ::GetSaveFileName(m_pofn);
        }
	}

	return nResult ? nResult : IDCANCEL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\minifwnd.h ===
// minifwnd.h : Declares the interface to the CMiniFrmWnd class.
//

#ifndef __MINIFWND_H__
#define __MINIFWND_H__

/////////////////////////////////////////////////////////////////////////////

class CDocking;

class CMiniFrmWnd : public CFrameWnd
    {
    DECLARE_DYNAMIC( CMiniFrmWnd )

    public:

    CMiniFrmWnd();

    BOOL Create( const TCHAR FAR* lpWindowName, DWORD dwStyle,
                 const RECT& rect, CWnd* pParentWnd );

    afx_msg void    OnNcLButtonDown( UINT nHitTest, CPoint pt );
    afx_msg void    OnLButtonUp    ( UINT nFlags, CPoint pt );
    afx_msg int     OnCreate       ( LPCREATESTRUCT lpCreateStruct);
    afx_msg void    OnSysCommand   ( UINT nID, LONG lParam);
    afx_msg LRESULT OnHelpHitTest  ( WPARAM wParam, LPARAM lParam);
    afx_msg void    OnRButtonDown  ( UINT nFlags, CPoint point);
    afx_msg void    OnKeyDown      ( UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg LRESULT OnMoving       ( WPARAM fwSide, LPARAM lprc );
    afx_msg void    OnMove         ( int x, int y );
    afx_msg BOOL    OnNcActivate   ( BOOL bActive );

    virtual BOOL OnCommand( UINT wParam, LONG lParam );

    virtual WORD GetHelpOffset() = 0;       // All of our minifwnds need help.

    DECLARE_MESSAGE_MAP()

    protected:

    CDocking*   m_pDocking;
    CPBView::DOCKERS m_Dockable;

    void CancelDrag();
    };

/////////////////////////////////////////////////////////////////////////////

#endif // __MINIFWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\minifwnd.cpp ===
// minifwnd.cpp : Defines the behaviors for the CMiniFrmWnd class.
//

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "docking.h"
#include "minifwnd.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CMiniFrmWnd, CFrameWnd )

#include "memtrace.h"

/***************************************************************************/

BEGIN_MESSAGE_MAP( CMiniFrmWnd, CFrameWnd )
    ON_WM_NCLBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_RBUTTONDOWN()
    ON_WM_KEYDOWN()
    ON_WM_CREATE()
    ON_WM_SYSCOMMAND()
    ON_WM_MOVE()
    ON_WM_NCACTIVATE()
    ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
    ON_MESSAGE(WM_MOVING, OnMoving)
END_MESSAGE_MAP()

static CString NEAR szClass;

/***************************************************************************/

CMiniFrmWnd::CMiniFrmWnd()
    {
    if (szClass.IsEmpty())
        {
        // NOTE: we create this brush for use in WNDCLASS.hbrBackground.
        //      We intentionally don't delete it.  It will be deleted by Windows
        //      when the class gets deleted (after app termination).
//      HBRUSH hbrGrayBack = ::CreateSolidBrush( ::GetSysColor( COLOR_BTNTEXT ) );

        szClass = AfxRegisterWndClass( CS_DBLCLKS, ::LoadCursor( NULL, IDC_ARROW ),
                              (HBRUSH)(COLOR_BTNFACE + 1)/* hbrGrayBack */, NULL );
        }

    m_Dockable = CPBView::unknown;
    m_pDocking = NULL;
    }

/***************************************************************************/

BOOL CMiniFrmWnd::Create( const TCHAR FAR* lpWindowName, DWORD dwStyle,
                            const RECT& rect, CWnd* pParentWnd )
    {
    return CFrameWnd::Create( szClass, lpWindowName,
                              dwStyle | WS_POPUPWINDOW | WS_CAPTION,
                              rect, pParentWnd, NULL,
                              WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE, NULL );
    }

/***************************************************************************/

void CMiniFrmWnd::OnNcLButtonDown( UINT nHitTest, CPoint pt )
    {
    if (nHitTest  == HTCAPTION
    && m_Dockable != CPBView::unknown)
        {
        m_pDocking = new CDocking;

        ASSERT( m_pDocking );

        if (m_pDocking)
            {
            CRect rect;

            GetWindowRect( &rect );

            if (! m_pDocking->Create( pt, rect, FALSE, m_Dockable ))
                {
                delete m_pDocking;
                m_pDocking = NULL;
                }
            }
        }

    CFrameWnd::OnNcLButtonDown( nHitTest, pt );
    }

/***************************************************************************/

void CMiniFrmWnd::OnLButtonUp( UINT nFlags, CPoint pt )
    {
    CFrameWnd::OnLButtonUp( nFlags, pt );
    }

/***************************************************************************/

int CMiniFrmWnd::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    CMenu* pMenu = GetSystemMenu(FALSE);

    if (pMenu != NULL)
        {
        pMenu->RemoveMenu(          7, MF_BYPOSITION);
        pMenu->RemoveMenu(          5, MF_BYPOSITION);
        pMenu->RemoveMenu(SC_RESTORE , MF_BYCOMMAND);
        pMenu->RemoveMenu(SC_MINIMIZE, MF_BYCOMMAND);
        pMenu->RemoveMenu(SC_MAXIMIZE, MF_BYCOMMAND);
        pMenu->RemoveMenu(SC_TASKLIST, MF_BYCOMMAND);
        }

    return CFrameWnd::OnCreate(lpCreateStruct);
    }

/***************************************************************************/

BOOL CMiniFrmWnd::OnCommand(UINT wParam, LONG lParam)
    {
    if (LOWORD(lParam) == 0 && wParam >= SC_SIZE)
        {
        PostMessage(WM_SYSCOMMAND, wParam, lParam);
        return TRUE;
        }

    return CFrameWnd::OnCommand(wParam, lParam);
    }

/***************************************************************************/

void CMiniFrmWnd::OnSysCommand(UINT nID, LONG lParam)
    {
    switch (nID & 0xfff0)
        {
        case SC_PREVWINDOW:
        case SC_NEXTWINDOW:
            if (LOWORD( lParam ) == VK_F6)
                {
                GetParent()->SetFocus();
                return;
                }
            break;

        case SC_KEYMENU:
            if (LOWORD(lParam) != TEXT('-'))
                {
                GetParent()->SetActiveWindow();
                GetParent()->SendMessage( WM_SYSCOMMAND, nID, lParam );
                SetActiveWindow();
                }
            return;
        }

    CFrameWnd::OnSysCommand( nID, lParam );
    }

/***************************************************************************/

LRESULT CMiniFrmWnd::OnHelpHitTest( WPARAM, LPARAM )
    {
    ASSERT( GetHelpOffset() );

    return HID_BASE_RESOURCE + GetHelpOffset();
    }

/******************************************************************************/

void CMiniFrmWnd::OnRButtonDown( UINT nFlags, CPoint point )
    {
    if (m_pDocking)
        PostMessage( WM_COMMAND, VK_ESCAPE );

    CFrameWnd::OnRButtonDown( nFlags, point );
    }

/******************************************************************************/

void CMiniFrmWnd::OnKeyDown( UINT nChar, UINT nRepCnt, UINT nFlags )
    {
    if (nChar == VK_ESCAPE && m_pDocking)
        CancelDrag();

    CFrameWnd::OnKeyDown( nChar, nRepCnt, nFlags );
    }

/***************************************************************************/

void CMiniFrmWnd::CancelDrag()
    {
    m_pDocking->Clear();

    delete m_pDocking;

    m_pDocking = NULL;
    }

/******************************************************************************/

LRESULT CMiniFrmWnd::OnMoving( WPARAM, LPARAM lprc )
    {
    LRESULT lResult = 0;

    if (m_pDocking)
        {
        CPoint pt;
        CRect  rect( (LPRECT)lprc );

        GetCursorPos( &pt );

        m_pDocking->Move( pt, rect );

        *((LPRECT)lprc) = rect;
        }

    return lResult;
    }

/******************************************************************************/

void CMiniFrmWnd::OnMove( int x, int y )
    {
    CFrameWnd::OnMove( x, y );

    if (! m_pDocking)
        return;

    CRect rect;
    BOOL bDocked = m_pDocking->Clear( &rect );

    delete m_pDocking;
    m_pDocking = NULL;

    CPBView* pView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();

    if (pView == NULL || ! pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        return;

    if (! bDocked)
        {
        pView->SetFloatPos( m_Dockable, rect );
        return;
        }


    }

/******************************************************************************/

BOOL CMiniFrmWnd::OnNcActivate(BOOL bActive)
{
    //
    // Work-around MFC bug - CMiniFrmWnd inherits from CFrameWnd,
    // so it inherits the intentional bug in CFrameWnd::OnActivate
    // MFC's CMiniFrameWnd has this hack, so does CMiniFrmWnd now...
    //

    if (m_nFlags & WF_KEEPMINIACTIVE)
	    {
		return FALSE;
	    }

    return CFrameWnd::OnNcActivate(bActive);
}

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\ofn.h ===
#ifndef OFN_H
#define OFN_H

#pragma pack(push, 8)

class COpenFileName
{
public:

    COpenFileName(BOOL bOpenFileDialog);
    ~COpenFileName();

    int DoModal();

    BOOL m_bOpenFileDialog;

    OPENFILENAME *m_pofn;
};

#pragma pack(pop)

#endif //OFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrusdoc.h ===
// pbrusdoc.h : interface of the CPBDoc class
//
/***************************************************************************/

class CPBSrvrItem;
class CBitmapObj;

class CPBDoc : public COleServerDoc
    {
    protected: // create from serialization only

    CPBDoc();

    DECLARE_DYNCREATE( CPBDoc )

    // Attributes

    public:

    CBitmapObj* m_pBitmapObj;
    CBitmapObj* m_pBitmapObjNew;
    CString     m_sName;
    BOOL        m_bNewDoc;
    BOOL        m_bObjectLoaded;
    BOOL        m_bPaintFormat;
    BOOL        m_bNonBitmapFile;   // TRUE if we loaded a non .BMP file.
    BOOL        m_bSaveViaFilter;   // TRUE if using an installed filter
    BOOL        m_bManualTruncate;
    BOOL        m_bHasSeenAFileError;
    LONG        m_wChangeNotifyEventId;
    // Operations
    public:

    CPBSrvrItem* GetEmbeddedItem()
                    { return (CPBSrvrItem*)COleServerDoc::GetEmbeddedItem(); }
    BOOL CreateNewDocument();
    BOOL SaveTheDocument();
    BOOL Finish();

    void OLESerialize(CArchive& ar);   // overridden for document i/o
    BOOL SerializeBitmap(CArchive& ar, CBitmapObj* pBitmapCur,
        CBitmapObj* pBitmapNew, BOOL bOLEObject);
    void SetDibHandle (HGLOBAL hDib);
    // Implementation
    public:

    virtual ~CPBDoc();
    virtual void Serialize(CArchive& ar);   // overridden for document i/o

    virtual void SaveToStorage(CObject* pObject);
    virtual void LoadFromStorage();
    virtual     BOOL OnOpenDocument( const TCHAR* pszPathName );
    virtual     BOOL OnSaveDocument( const TCHAR* pszPathName );
    virtual     CFile* GetFile(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError);
    virtual     void ReleaseFile(CFile* pFile, BOOL bAbort);
    virtual BOOL CanCloseFrame( CFrameWnd* pFrame );
    virtual BOOL SaveModified(); // return TRUE if ok to continue
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace=TRUE);
    virtual BOOL OnUpdateDocument ();
    virtual COleServerItem* OnGetEmbeddedItem();
    virtual COleServerItem* OnGetLinkedItem( LPCTSTR lpszItemName );

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

        // Must be public so it can be called from Escape handler
        virtual void OnDeactivateUI(BOOL bUndoable);

protected:
        DECLARE_INTERFACE_MAP()

        BEGIN_INTERFACE_PART(PBPersistStg, IPersistStorage)
                INIT_INTERFACE_PART(CPBDoc, PBPersistStg)
                STDMETHOD(GetClassID)(LPCLSID);
                STDMETHOD(IsDirty)();
                STDMETHOD(InitNew)(LPSTORAGE);
                STDMETHOD(Load)(LPSTORAGE);
                STDMETHOD(Save)(LPSTORAGE, BOOL);
                STDMETHOD(SaveCompleted)(LPSTORAGE);
                STDMETHOD(HandsOffStorage)();
        END_INTERFACE_PART(PBPersistStg)

    protected:

    virtual BOOL OnNewDocument();
        virtual void OnShowControlBars(CFrameWnd *pFrame, BOOL bShow);

    // Generated message map functions
    protected:

    //{{AFX_MSG(CPBDoc)
        afx_msg void MyOnFileUpdate();
        //}}AFX_MSG

    virtual void ReportSaveLoadException(LPCTSTR, CException*, BOOL, UINT);

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrusfrm.cpp ===
// pbrusfrm.cpp : implementation of the CPBFrame class
//

#include "stdafx.h"
#include "resource.h"
#include "global.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "docking.h"
#include "minifwnd.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgdlgs.h"
#include "cmpmsg.h"
#include "props.h"
#include "colorsrc.h"
#include <htmlhelp.h>
#include "imaging.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CPBFrame, CFrameWnd )

#include "memtrace.h"

#define UM_FILE_ERROR     WM_USER + 1001

/*************************** CPBFrame **************************************/

BEGIN_MESSAGE_MAP( CPBFrame, CFrameWnd )
    //{{AFX_MSG_MAP(CPBFrame)
        ON_WM_ACTIVATEAPP()
        ON_WM_CREATE()
        ON_WM_DESTROY()
        ON_WM_SETFOCUS()
        ON_WM_PALETTECHANGED()
        ON_WM_QUERYNEWPALETTE()
        ON_WM_GETMINMAXINFO()
        ON_WM_MOVE()
        ON_WM_SIZE()
        ON_WM_ERASEBKGND()
        ON_WM_DEVMODECHANGE()
        ON_WM_WININICHANGE()
        ON_COMMAND(ID_HELP, OnHelp)
        ON_WM_SYSCOLORCHANGE()
        ON_WM_CLOSE()
        ON_UPDATE_COMMAND_UI(ID_FILE_SCAN_NEW, OnUpdateAcquire)
        ON_COMMAND(ID_FILE_SCAN_NEW, OnAcquire)
        ON_UPDATE_COMMAND_UI(ID_FILE_SELECT_SOURCE, OnUpdateSelectSource)
        ON_COMMAND(ID_FILE_SELECT_SOURCE, OnSelectSource)
        //}}AFX_MSG_MAP

    ON_MESSAGE(UM_FILE_ERROR, OnFileError)

    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CFrameWnd::OnHelpIndex)
    ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpIndex)

        ON_UPDATE_COMMAND_UI(ID_VIEW_TOOL_BOX, CFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_TOOL_BOX, CFrameWnd::OnBarCheck)
        ON_UPDATE_COMMAND_UI(ID_VIEW_COLOR_BOX, CFrameWnd::OnUpdateControlBarMenu)
        ON_COMMAND_EX(ID_VIEW_COLOR_BOX, CFrameWnd::OnBarCheck)
END_MESSAGE_MAP()

/***************************************************************************/

/*********************** CPBFrame construction/destruction *****************/

CPBFrame::CPBFrame()
    {
    // Just small enough so that the control bars fit
    m_szFrameMin = CSize( 275, 410 );
    m_pMgr = new CWIAMgr;
#ifdef USE_TWAIN
    if (!m_pMgr || !m_pMgr->IsAvailable()) 
        {
        delete m_pMgr;
        m_pMgr = new CTwainMgr;
        }
#endif //USE_TWAIN
    }

/***************************************************************************/

CPBFrame::~CPBFrame()
    {
    // also can't delete objects  derived from class cframewnd, must destroy their
    // window => deletion indirectly
    delete m_pMgr;
    }

/*************************** CPBFrame diagnostics **************************/

#ifdef _DEBUG
void CPBFrame::AssertValid() const
    {
    CFrameWnd::AssertValid();
    }

/***************************************************************************/

void CPBFrame::Dump(CDumpContext& dc) const
    {
    CFrameWnd::Dump(dc);
    }

#endif //_DEBUG

/***************************************************************************/

TCHAR mszMSPaintClass[] = TEXT("MSPaintApp");

BOOL CPBFrame::PreCreateWindow( CREATESTRUCT& cs )
    {
        cs.dwExStyle |= WS_EX_WINDOWEDGE;
    cs.style |= WS_CLIPCHILDREN;
    BOOL bResult = CFrameWnd::PreCreateWindow( cs );

    if (bResult)
        {
        WINDOWPLACEMENT& wpSaved = theApp.m_wpPlacement;
        RECT& rcSaved = wpSaved.rcNormalPosition;

        CPoint ptPBrush(rcSaved.left, rcSaved.top);
        CSize sizePBrush(rcSaved.right - rcSaved.left, rcSaved.bottom - rcSaved.top);

        CPoint pt = theApp.CheckWindowPosition( ptPBrush, sizePBrush );
        if (pt.x || pt.y)
        {
            cs.x = pt.x;
            cs.y = pt.y;
        }

        sizePBrush.cx = max(sizePBrush.cx, m_szFrameMin.cx);
        sizePBrush.cy = max(sizePBrush.cy, m_szFrameMin.cy);
        if (sizePBrush.cx && sizePBrush.cy)
        {
            cs.cx = sizePBrush.cx;
            cs.cy = sizePBrush.cy;
        }

        rcSaved.left = cs.x;
        rcSaved.top  = cs.y;
        rcSaved.right = rcSaved.left + cs.cx;
        rcSaved.bottom = rcSaved.top + cs.cy;

        WNDCLASS  wndcls;
        HINSTANCE hInst = AfxGetInstanceHandle();

        // see if the class already exists
        if (! ::GetClassInfo( hInst, mszMSPaintClass, &wndcls ))
            {
            // get default stuff
            ::GetClassInfo( hInst, cs.lpszClass, &wndcls );

            // register a new class
            wndcls.lpszClassName = mszMSPaintClass;
            wndcls.hIcon         = ::LoadIcon( hInst, MAKEINTRESOURCE( ID_MAINFRAME ) );

            ASSERT( wndcls.hIcon != NULL );

            if (! AfxRegisterClass( &wndcls ))
                AfxThrowResourceException();
            }
        cs.lpszClass = mszMSPaintClass;
        }
    return bResult;
    }

/***************************************************************************/

CWnd* CPBFrame::GetMessageBar()
    {
    if (m_statBar.m_hWnd != NULL)
        return &m_statBar;

    return NULL;
    }

/***************************************************************************/

void CPBFrame::OnHelp()
    {
    if (m_dwPromptContext)
        CFrameWnd::OnHelp();
    else
        ::HtmlHelpA( ::GetDesktopWindow(), "mspaint.chm", HH_DISPLAY_TOPIC, 0L );
    }

/***************************************************************************/

int CPBFrame::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    if (CFrameWnd::OnCreate( lpCreateStruct ) == -1)
        return -1;
    g_pStatBarWnd = &m_statBar;
    g_pImgToolWnd = &m_toolBar;
    g_pImgColorsWnd = &m_colorBar;
    return 0;
    }

/***************************************************************************/

void CPBFrame::OnDestroy()
    {
    CFrameWnd::OnDestroy();

    theApp.m_wpPlacement.length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(&theApp.m_wpPlacement);

    theApp.SaveProfileSettings();
    }

/***************************************************************************/

BOOL CPBFrame::OnEraseBkgnd(CDC* pDC)
    {


        if ( !m_pViewActive )   //fix gray background on screen while IME disappear problem
        {


    CRect cRectClient;

    GetClientRect( &cRectClient );
    pDC->FillRect( &cRectClient, GetSysBrush( COLOR_BTNFACE ) );


    }


    return CFrameWnd::OnEraseBkgnd( pDC );
    }

/***************************************************************************/

void CPBFrame::OnActivateApp(BOOL bActive, HTASK hTask)
    {
    theApp.m_bActiveApp = bActive;

    CFrameWnd::OnActivateApp(bActive, hTask);
    }

/***************************************************************************/

void CPBFrame::OnMove( int x, int y )
    {
    CRect cRectWindow;

    GetWindowRect( &cRectWindow );
    m_ptPosition.x = cRectWindow.left;
    m_ptPosition.y = cRectWindow.top;

    CWnd::OnMove( x, y );
    }

/***************************************************************************/

void CPBFrame::OnSize( UINT nType, int cx, int cy )
    {
    CFrameWnd::OnSize( nType, cx, cy );

    CRect rect;

    GetWindowRect( &rect );

    m_szFrame = rect.Size();
    }

/***************************************************************************/

void CPBFrame::OnSetFocus(CWnd* pOldWnd)
    {
    CFrameWnd::OnSetFocus( pOldWnd );

        // We need to update the window here because the SetFocus below will update
        // the image window, and then some async paints can come after that which
        // will cause us to put the background color over parts of the window (see
        // WIN95C bug #4080).
    UpdateWindow();

    CPBView* pView = (CPBView*)GetActiveView();

    if (pView
    &&  pView->IsKindOf( RUNTIME_CLASS( CPBView ) )
    &&  pView->m_pImgWnd != NULL
    &&  ::IsWindow(pView->m_pImgWnd->m_hWnd) )
        pView->m_pImgWnd->SetFocus();
    }

/***************************************************************************/

void CPBFrame::OnPaletteChanged( CWnd* pFocusWnd )
    {
    CFrameWnd::OnPaletteChanged( pFocusWnd );

    CPBView* pView = (CPBView*)GetActiveView();

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        {
        pView->OnPaletteChanged( pFocusWnd );
        }
    }

/***************************************************************************/

BOOL CPBFrame::OnQueryNewPalette()
    {
    CPBView* pView = (CPBView*)GetActiveView();

    if (pView != NULL && ::IsWindow(pView->m_hWnd) && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        {
        pView->OnQueryNewPalette();
        }

    return CFrameWnd::OnQueryNewPalette();
    }

/***************************************************************************/

void CPBFrame::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
    {
    lpMMI->ptMinTrackSize.x = m_szFrameMin.cx;
    lpMMI->ptMinTrackSize.y = m_szFrameMin.cy;

    CFrameWnd::OnGetMinMaxInfo(lpMMI);
    }

/*****************************************************************************/

void CPBFrame::OnDevModeChange( LPTSTR lpDeviceName )
    {
    CClientDC dc( this );

    if (dc.m_hDC != NULL)
        theApp.GetSystemSettings( &dc );

    CFrameWnd::OnDevModeChange( lpDeviceName );
    }

/*****************************************************************************/

void CPBFrame::OnWinIniChange( LPCTSTR lpszSection )
    {
    CClientDC dc( this );
    CDocument *pDoc;

    if (dc.m_hDC != NULL)
        theApp.GetSystemSettings( &dc );

    if (         m_statBar.m_hWnd    != NULL
    &&  theApp.m_fntStatus.m_hObject != NULL)
        m_statBar.SetFont( &theApp.m_fntStatus, FALSE );

    CFrameWnd::OnWinIniChange( lpszSection );

    if (pDoc = GetActiveDocument())
         {
         pDoc->UpdateAllViews( NULL );
         GetActiveView()->UpdateWindow();
         }
    }

/*****************************************************************************/

void CPBFrame::ActivateFrame( int nCmdShow )
{
        WINDOWPLACEMENT& wpSaved = theApp.m_wpPlacement;

        if (theApp.m_bPrintOnly)
        {
                nCmdShow = SW_HIDE;
        }
        else if (!IsWindowVisible())
        {
                switch (nCmdShow)
                {
                case SW_SHOW:
                case SW_SHOWNORMAL:
                        switch (wpSaved.showCmd)
                        {
                        case SW_HIDE:
                        case SW_MINIMIZE:
                        case SW_SHOWMINIMIZED:
                        case SW_SHOWMINNOACTIVE:
                                break;

                        default:
                                nCmdShow = wpSaved.showCmd;
                                break;
                        }
                        break;
                }

                wpSaved.showCmd = nCmdShow;

                wpSaved.length = sizeof(WINDOWPLACEMENT);
                SetWindowPlacement(&wpSaved);
        }
        //
        // We have to reassign the global toolbar pointers here, in case
        // they were pointing to the inplace frame's toolbars and that window
        // was deleted.
        //
        g_pStatBarWnd = &m_statBar;
        g_pImgToolWnd = &m_toolBar;
        g_pImgColorsWnd = &m_colorBar;
        CFrameWnd::ActivateFrame( nCmdShow );
}

/*****************************************************************************/
#ifdef xyzzyz
void CPBFrame::OnUpdateFrameTitle( BOOL bAddToTitle )
    {
    if (theApp.m_bEmbedded && ! theApp.m_bLinked)
        {
        CFrameWnd::OnUpdateFrameTitle( bAddToTitle );
        return;
        }

    // get old text for comparison against new text
    CString sOld;
    CString sText;

    GetWindowText( sOld );

    CPBDoc* pDocument = (CPBDoc*)GetActiveDocument();

    if (bAddToTitle && pDocument != NULL)
        {
        const TCHAR* psTitle = pDocument->GetTitle();

        if (psTitle != NULL)
            {
            sText += GetName( psTitle );
            sText += TEXT(" - ");

            sText.MakeLower();
            }
        }
    sText += m_strTitle;

    // set title if changed, but don't remove completely
    if (sText != sOld)
        SetWindowText( sText );
    }
#endif
/*****************************************************************************/

LRESULT CPBFrame::OnFileError( WPARAM, LPARAM )
    {
    theApp.FileErrorMessageBox();

    return 0;
    }

/***************************************************************************/

void CPBFrame::OnSysColorChange()
{
        CFrameWnd ::OnSysColorChange();

        ResetSysBrushes();
}

void CPBFrame::OnClose()
{
        SaveBarState(TEXT("General"));
        CFrameWnd ::OnClose();
}

/***************************************************************************/

void CPBFrame::OnSelectSource()
{
    CWaitCursor DisplayWaitCursor;

    // if m_pMgr == 0, "Select Source" menu item will not be available anyway

    ASSERT(m_pMgr != 0); 

    HRESULT hr = m_pMgr->SelectSource(
        GetSafeHwnd(), 
        WIA_SELECT_DEVICE_NODEFAULT
    );

    if (!SUCCEEDED(hr)) 
    {
        CmpMessageBox(IDS_ERROR_SELECT_SCAN, 
            AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION);
    }
}

void CPBFrame::OnAcquire()
{
    CWaitCursor DisplayWaitCursor;

    // if m_pMgr == 0, "Scan New" menu item will not be available anyway

    ASSERT(m_pMgr != 0); 

    // call the WIA interface to acquire the image

    HGLOBAL hDib = 0;

    HRESULT hr = m_pMgr->Acquire(GetSafeHwnd(), &hDib);

    if (!SUCCEEDED(hr)) 
    {
        // if the interface has failed, display the generic error message
        CmpMessageBox(IDS_ERROR_SCAN_NEW, 
            AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION);
    }
    else if (hr == S_OK) 
    {
        // if the user has not cancelled the operation, get the image

        CPBView *pView = (CPBView*)GetActiveView();
        if (pView)
        {
            CPBDoc *pDoc = (CPBDoc *)pView->GetDocument();

            // prompt to save the current document if it was modified
            if (pDoc && pDoc->SaveModified()) 
            {
	            pDoc->SetModifiedFlag(FALSE);
                // and set this as the new image
                theApp.OnFileNew ();
                pDoc->SetDibHandle (hDib);
                pView->m_pImgWnd->Invalidate();
                pView->m_pImgWnd->CheckScrollBars();
            }
        }
    }
}

void CPBFrame::OnUpdateSelectSource(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_pMgr && m_pMgr->NumDevices(GetSafeHwnd()) > 0);
}

void CPBFrame::OnUpdateAcquire(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_pMgr && m_pMgr->NumDevices(GetSafeHwnd()) > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrusfrm.h ===
#ifndef __PBRUSFRM_H__
#define __PBRUSFRM_H__

#include "toolbox.h"

class CImagingMgr;

// pbrusfrm.h : interface of the CPBFrame class
//
/***************************************************************************/

class CPBFrame : public CFrameWnd
    {
    protected: /****** create from serialization only *************************/

    CPBFrame();

    DECLARE_DYNCREATE( CPBFrame )

    public: /*** Attributes ***************************************************/

    CPoint      m_ptPosition;
    CSize       m_szFrame;
    CSize       m_szFrameMin;

    CStatBar            m_statBar;
    CImgToolWnd         m_toolBar;
        CImgColorsWnd   m_colorBar;

    CImagingMgr *m_pMgr;

    public: /*** Implementation ***********************************************/

    virtual ~CPBFrame();

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump( CDumpContext& dc ) const;
    #endif

    protected: /***************************************************************/

    virtual BOOL PreCreateWindow( CREATESTRUCT& cs );
        virtual CWnd* GetMessageBar();
    virtual void ActivateFrame( int nCmdShow = -1 );
//  virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    afx_msg LRESULT OnFileError( WPARAM wParam, LPARAM lParam );

    // Generated message map functions
    //{{AFX_MSG(CPBFrame)
    afx_msg void OnUpdateAcquire (CCmdUI *pCmdUI);
    afx_msg void OnAcquire ();
    afx_msg void OnUpdateSelectSource(CCmdUI* pCmdUI);
    afx_msg void OnSelectSource();
    afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
        afx_msg void OnMove(int x, int y);
        afx_msg void OnSize(UINT nType, int cx, int cy);
        afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
    afx_msg void OnWinIniChange(LPCTSTR lpszSection);
        afx_msg void OnHelp();
        afx_msg void OnSysColorChange();
        afx_msg void OnClose();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/
#endif // __PBRUSHFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrusvw.cpp ===
// pbrusvw.cpp : implementation of the CPBView class
//

#include "stdafx.h"

#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imageatt.h"
#include "undo.h"
#include "props.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgdlgs.h"
#include "toolbox.h"
#include "thumnail.h"
#include "t_text.h"
#include "cmpmsg.h"
#include "printres.h"
#include "settings.h"
#include "colorsrc.h"
#include "cderr.h"
#include "srvritem.h"

#include <regstr.h>

#ifdef USE_PRINTDLGEX
#include <afxprntx.h>
#include <dlgprnt2.cpp>
#endif //USE_PRINTDLGEX

#if 0 // THIS_FILE is already declared in dlgprnt2.cpp

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#endif 

IMPLEMENT_DYNCREATE(CPBView, CView)

#include "memtrace.h"


/***************************************************************************/
// CPBView

BEGIN_MESSAGE_MAP(CPBView, CView)
    //{{AFX_MSG_MAP(CPBView)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_VIEW_GRID, OnViewGrid)
    ON_COMMAND(ID_VIEW_ZOOM_100, OnViewZoom100)
    ON_COMMAND(ID_VIEW_ZOOM_400, OnViewZoom400)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOM_100, OnUpdateViewZoom100)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOM_400, OnUpdateViewZoom400)
    ON_UPDATE_COMMAND_UI(ID_VIEW_GRID, OnUpdateViewGrid)
    ON_COMMAND(ID_IMAGE_INVERT_COLORS, OnImageInvertColors)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_INVERT_COLORS, OnUpdateImageInvertColors)
    ON_COMMAND(IDM_TGLOPAQUE, OnTglopaque)
    ON_UPDATE_COMMAND_UI(IDM_TGLOPAQUE, OnUpdateTglopaque)
    ON_COMMAND(ID_IMAGE_ATTRIBUTES, OnImageAttributes)
    ON_COMMAND(IDMX_SEL2BSH, OnSel2bsh)
    ON_COMMAND(IDMX_LARGERBRUSH, OnLargerbrush)
    ON_COMMAND(IDMX_SMALLERBRUSH, OnSmallerbrush)
    ON_COMMAND(ID_VIEW_ZOOM, OnViewZoom)
    ON_COMMAND(ID_IMAGE_FLIP_ROTATE, OnImageFlipRotate)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_FLIP_ROTATE, OnUpdateImageFlipRotate)
    ON_COMMAND(IDM_EDITCOLORS, OnEditcolors)
    ON_UPDATE_COMMAND_UI(IDM_EDITCOLORS, OnUpdateEditcolors)
#if 0
    ON_COMMAND(IDM_LOADCOLORS, OnLoadcolors)
    ON_UPDATE_COMMAND_UI(IDM_LOADCOLORS, OnUpdateLoadcolors)
    ON_COMMAND(IDM_SAVECOLORS, OnSavecolors)
    ON_UPDATE_COMMAND_UI(IDM_SAVECOLORS, OnUpdateSavecolors)
#endif
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_COMMAND(ID_EDIT_PASTE_FROM, OnEditPasteFrom)
    ON_COMMAND(ID_EDIT_COPY_TO, OnEditCopyTo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY_TO, OnUpdateEditCopyTo)
    ON_COMMAND(ID_IMAGE_STRETCH_SKEW, OnImageStretchSkew)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_STRETCH_SKEW, OnUpdateImageStretchSkew)
    ON_COMMAND(ID_VIEW_VIEW_PICTURE, OnViewViewPicture)
    ON_UPDATE_COMMAND_UI(ID_VIEW_VIEW_PICTURE, OnUpdateViewViewPicture)
    ON_COMMAND(ID_VIEW_TEXT_TOOLBAR, OnViewTextToolbar)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TEXT_TOOLBAR, OnUpdateViewTextToolbar)
    ON_COMMAND(ID_FILE_SETASWALLPAPER_T, OnFileSetaswallpaperT)
    ON_UPDATE_COMMAND_UI(ID_FILE_SETASWALLPAPER_T, OnUpdateFileSetaswallpaperT)
    ON_COMMAND(ID_FILE_SETASWALLPAPER_C, OnFileSetaswallpaperC)
    ON_UPDATE_COMMAND_UI(ID_FILE_SETASWALLPAPER_C, OnUpdateFileSetaswallpaperC)
    ON_COMMAND(ID_VIEW_THUMBNAIL, OnViewThumbnail)
    ON_UPDATE_COMMAND_UI(ID_VIEW_THUMBNAIL, OnUpdateViewThumbnail)
    ON_UPDATE_COMMAND_UI(ID_IMAGE_ATTRIBUTES, OnUpdateImageAttributes)
    ON_COMMAND(ID_ESCAPE, OnEscape)
    ON_COMMAND(ID_ESCAPE_SERVER, OnEscapeServer)
    ON_WM_SHOWWINDOW()
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditSelection)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateEditClearSel)
        ON_COMMAND(ID_FILE_PAGE_SETUP, OnFilePageSetup)
        ON_COMMAND(ID_IMAGE_CLEAR_IMAGE, OnImageClearImage)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditClearSel)
        ON_UPDATE_COMMAND_UI(ID_IMAGE_CLEAR_IMAGE, OnUpdateImageClearImage)
        //}}AFX_MSG_MAP

        ON_WM_DESTROY()



    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)

END_MESSAGE_MAP()

/***************************************************************************/
// CPBView construction/destruction

CPBView::CPBView()
    {
    m_pImgWnd             = NULL;

    m_pwndThumbNailFloat  = NULL;
    m_pwndThumbNailView   = NULL;
    }

/***************************************************************************/

CPBView::~CPBView()
    {
    // reset the toolbar
    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
    {
        g_pImgToolWnd->SelectTool( IDMB_ARROW );
        g_pImgToolWnd->InvalidateOptions();
    }

    DestroyThumbNailView();

    if (m_pImgWnd)
        {
        delete m_pImgWnd;
        m_pImgWnd = NULL;
        }
    }

/***************************************************************************/

BOOL CPBView::PreCreateWindow( CREATESTRUCT& cs )
    {
    cs.style     |= WS_CLIPCHILDREN;
    cs.dwExStyle |= WS_EX_CLIENTEDGE;

    return CView::PreCreateWindow( cs );
    }


/***************************************************************************/

BOOL CPBView::PreTranslateMessage(MSG *pMsg)
        {
        // Handle a bug in MFC regarding enabling of accelerators on Popup menus.
        if ( pMsg->message == WM_KEYDOWN )
                {
                // Find the app menu for this window.
                CWnd    *pWnd = this;
                CMenu   *pMenu = NULL;
                while( pWnd )
                        {
                        if ( (pMenu = pWnd->GetMenu()) && IsMenu(pMenu->m_hMenu) )
                                break;
                        else
                                pMenu = NULL;
                        pWnd = pWnd->GetParent();
                        }

                if ( pMenu )
                        {
                        pMenu->EnableMenuItem( ID_VIEW_ZOOM_100, MF_BYCOMMAND |
                                (m_pImgWnd && m_pImgWnd->GetZoom() != 1 ? MF_ENABLED : MF_DISABLED) );
                        pMenu->EnableMenuItem( ID_VIEW_ZOOM_400, MF_BYCOMMAND |
                                (m_pImgWnd && m_pImgWnd->GetZoom() != 4 ? MF_ENABLED : MF_DISABLED) );
                        pMenu->EnableMenuItem( ID_VIEW_GRID, MF_BYCOMMAND |
                                (m_pImgWnd && m_pImgWnd->GetZoom() > 2 ? MF_ENABLED : MF_DISABLED) );
                        }
                }

        return CView::PreTranslateMessage(pMsg);
        }

/***************************************************************************/
// CPBView drawing

void CPBView::OnDraw( CDC* pDC )
    {
    if (m_pImgWnd)
        {
        CRect rectPaint;
        CPalette* ppal = m_pImgWnd->SetImgPalette( pDC, FALSE );

        // if the dc passed in is a CPaint DC use the rcPaint rect to optimize
        // painting to only paint the invalid area.  ELSE use the whole image
        // size.
        if (pDC->IsKindOf( RUNTIME_CLASS( CPaintDC ) )  )
            {
            rectPaint = ((CPaintDC *)pDC)->m_ps.rcPaint;
            if ( theApp.m_bEmbedded )
                                m_pImgWnd->Invalidate();
            }
        else
            {
            m_pImgWnd->GetImageRect( rectPaint );
            }

        m_pImgWnd->DrawImage( pDC, &rectPaint );

        if (ppal)
            pDC->SelectPalette( ppal, FALSE );
        }
    }

/***************************************************************************/
// CPBView printing

BOOL CPBView::GetPrintToInfo(CPrintInfo* pInfo)
{

        ASSERT(pInfo != NULL);
        ASSERT(pInfo->m_pPD != NULL);

        if (theApp.m_strPrinterName.IsEmpty())
                return FALSE;

        ASSERT(pInfo->m_pPD->m_pd.hDC == NULL);
        pInfo->m_pPD->m_pd.hDC = ::CreateDC(NULL,
                                            theApp.m_strPrinterName,
                                            NULL, NULL);

        // set up From and To page range from Min and Max
        pInfo->m_pPD->m_pd.nFromPage = (WORD)pInfo->GetMinPage();
        pInfo->m_pPD->m_pd.nToPage = (WORD)pInfo->GetMaxPage();

        ASSERT(pInfo->m_pPD != NULL);
        ASSERT(pInfo->m_pPD->m_pd.hDC != NULL);

        pInfo->m_nNumPreviewPages = theApp.m_nNumPreviewPages;
        VERIFY(pInfo->m_strPageDesc.LoadString(AFX_IDS_PREVIEWPAGEDESC));
        return TRUE;
}

BOOL CPBView::OnPreparePrinting( CPrintInfo* pInfo )
    {
#ifdef USE_PRINTDLGEX


    //
    // Create a C_PrintDialogEx structure to replace the PrintDialog in the
    // CPrintInfo
    //


    m_pdRestore= pInfo->m_pPD;
    m_pdexSub = new C_PrintDialogEx (FALSE, PD_RETURNDC | 
        PD_ALLPAGES | PD_NOCURRENTPAGE | PD_NOPAGENUMS | 
        PD_NOSELECTION | PD_USEDEVMODECOPIESANDCOLLATE);
    pInfo->m_pPD = m_pdexSub;

    // These next 2 lines copied from mfc42 source to initialize the printdialog
    //
    pInfo->SetMinPage (1);
    pInfo->SetMaxPage (0xffff);

    pInfo->m_pPD->m_pd.nFromPage = 1;
    pInfo->m_pPD->m_pd.nToPage = 1;

#endif //USE_PRINTDLGEX

    new CPrintResObj( this, pInfo );

    if (pInfo->m_lpUserData == NULL)
        return FALSE;

    if (theApp.m_bPrintOnly)
        {
        if (GetPrintToInfo(pInfo))
        {
            return(TRUE);
        }

        if (! theApp.GetPrinterDeviceDefaults( &pInfo->m_pPD->m_pd ))
            {
            // bring up dialog to alert the user they need to install a printer.
            if (theApp.DoPrintDialog( pInfo->m_pPD ) != IDOK)
                return FALSE;
            }

        if (! pInfo->m_pPD->m_pd.hDC)
            {
            // call CreatePrinterDC if DC was not created by above
            if (! pInfo->m_pPD->CreatePrinterDC())
                return FALSE;
            }

        // set up From and To page range from Min and Max
        pInfo->m_pPD->m_pd.nFromPage = (WORD)pInfo->GetMinPage();
        pInfo->m_pPD->m_pd.nToPage   = (WORD)pInfo->GetMaxPage();
            pInfo->m_nNumPreviewPages    = theApp.m_nNumPreviewPages;
        return TRUE;
        }

    // default preparation
    if (! DoPreparePrinting( pInfo ))
        {
        ((CPrintResObj*)pInfo->m_lpUserData)->EndPrinting( NULL, pInfo );
        pInfo->m_lpUserData = NULL;
        return FALSE;
        }
    return TRUE;
    }

/***************************************************************************/

void CPBView::OnBeginPrinting( CDC* pDC, CPrintInfo* pInfo )
    {

    if (pInfo               != NULL
    &&  pInfo->m_lpUserData != NULL)
        ((CPrintResObj*)pInfo->m_lpUserData)->BeginPrinting( pDC, pInfo );
    else
        CView::OnBeginPrinting( pDC, pInfo );
    }

/***************************************************************************/

void CPBView::OnPrepareDC( CDC* pDC, CPrintInfo* pInfo )
    {

#ifdef USE_MIRRORING
    //
    // Disable RTL mirroring
    //
    if (PBGetLayout(pDC->GetSafeHdc()) & LAYOUT_RTL)
    {
        PBSetLayout(pDC->GetSafeHdc(), 0);
    }
#endif

    CView::OnPrepareDC( pDC, pInfo );

    if (pInfo               != NULL
    &&  pInfo->m_lpUserData != NULL)
        ((CPrintResObj*)pInfo->m_lpUserData)->PrepareDC( pDC, pInfo );
    }

/***************************************************************************/

void CPBView::OnPrint( CDC* pDC, CPrintInfo* pInfo )
    {

    BOOL bProcessed = FALSE;

    if (pInfo               != NULL
    &&  pInfo->m_lpUserData != NULL)
        bProcessed = ((CPrintResObj*)pInfo->m_lpUserData)->PrintPage( pDC, pInfo );

    if (! bProcessed)
        CView::OnPrint( pDC, pInfo );
    }

/***************************************************************************/

void CPBView::OnEndPrinting( CDC* pDC, CPrintInfo* pInfo )
    {

    if (pInfo == NULL)
        return;

    if (pInfo->m_lpUserData != NULL)
        {
        ((CPrintResObj*)pInfo->m_lpUserData)->EndPrinting( pDC, pInfo );
        pInfo->m_lpUserData = NULL;
        }
#ifdef USE_PRINTDLGEX
    //
    // Restore the original dialog pointer
    //
    pInfo->m_pPD = m_pdRestore;
    delete m_pdexSub;
#endif //USE_PRINTDLGEX
    }

/******************************************************************************/

// CPBView diagnostics

#ifdef _DEBUG
void CPBView::AssertValid() const
    {
    CView::AssertValid();
    }

/***************************************************************************/

void CPBView::Dump( CDumpContext& dc ) const
    {
    CView::Dump( dc );
    }

/***************************************************************************/

CPBDoc* CPBView::GetDocument() // non-debug version is inline
    {
    ASSERT( m_pDocument->IsKindOf( RUNTIME_CLASS( CPBDoc ) ) );
    return (CPBDoc*)m_pDocument;
    }
#endif //_DEBUG

/***************************************************************************/
// CPBView message handlers
int CPBView::OnCreate( LPCREATESTRUCT lpCreateStruct )
    {
    if (CView::OnCreate( lpCreateStruct ) == -1)
        return -1;

#ifdef USE_MIRRORING
    //
    // Disable RTL mirroring on client drawing area. [samera]
    //
    if (lpCreateStruct->dwExStyle & WS_EX_LAYOUTRTL)
    {
        SetWindowLong( GetSafeHwnd(), GWL_EXSTYLE, lpCreateStruct->dwExStyle & ~WS_EX_LAYOUTRTL );
    }
#endif

    return 0;
    }

/***************************************************************************/

void CPBView::OnShowWindow( BOOL bShow, UINT nStatus )
    {
    if (theApp.m_bPrintOnly)
        return;

    CView::OnShowWindow( bShow, nStatus );
    }

/***************************************************************************/

void CPBView::OnDestroy()
    {
    // reset the toolbar
    if (g_pImgToolWnd && g_pImgToolWnd->m_hWnd &&
        IsWindow(g_pImgToolWnd->m_hWnd) )
    {
        g_pImgToolWnd->SelectTool( IDMB_ARROW );
        g_pImgToolWnd->InvalidateOptions();
    }

    DestroyThumbNailView();

    if (m_pImgWnd)
        {
        if ( ::IsWindow(m_pImgWnd->m_hWnd) )
            m_pImgWnd->DestroyWindow();

        delete m_pImgWnd;
        m_pImgWnd = NULL;
        }

    CView::OnDestroy();
    }

/***************************************************************************/

void CPBView::OnInitialUpdate( void )
    {
    CPBDoc* pDoc = GetDocument();

    if (SetObject())
        {
        if (theApp.m_bPrintOnly)
            {
            if (pDoc->m_bObjectLoaded)
                {
                OnFilePrint();

                GetParentFrame()->PostMessage( WM_CLOSE );
                return;
                }
            theApp.m_bPrintOnly = FALSE;
            }

        theUndo.SetMaxLevels( 3 );

        SetTools();
                }
    else
        {
        if (pDoc->m_pBitmapObjNew != NULL)
            {
            delete pDoc->m_pBitmapObjNew;
            pDoc->m_pBitmapObjNew = NULL;
            }

        TRACE( TEXT("OnInitialUpdate SetObject Failed!\n") );
        }
    }

/***************************************************************************/

void CPBView::OnActivateView( BOOL bActivate, CView* pActivateView,
                                              CView* pDeactiveView )
    {
    CView::OnActivateView( bActivate, pActivateView, pDeactiveView );
    }

/***************************************************************************/

BOOL CPBView::OnCmdMsg( UINT nID, int nCode, void* pExtra,
                       AFX_CMDHANDLERINFO* pHandlerInfo )
    {
    if (nCode == CN_COMMAND)
        {
        if (m_pImgWnd
        &&  m_pImgWnd->OnCmdMsg( nID, nCode, pExtra, pHandlerInfo ))
            return TRUE;
        }

    return CView::OnCmdMsg( nID, nCode, pExtra, pHandlerInfo );
    }

/***************************************************************************/


void CPBView::OnSize(UINT nType, int cx, int cy)
    {
    CView::OnSize( nType, cx, cy );

    // TODO: Add your message handler code here
    if (m_pImgWnd)
        m_pImgWnd->MoveWindow( 0, 0, cx, cy );
    }

/***************************************************************************/

BOOL CPBView::SetObject()
    {
    CPBDoc* pDoc = GetDocument();

    ASSERT( pDoc );
    ASSERT( pDoc->m_pBitmapObjNew );

    if (! pDoc || ! pDoc->m_pBitmapObjNew)
        return FALSE;

    CBitmapObj* pBitmapObj = pDoc->m_pBitmapObjNew;

    // see if a bad file was loaded, but not an empty file, which is OK
    if (! pDoc->m_bObjectLoaded
    &&  ! pBitmapObj->m_bTempName
    &&    pBitmapObj->m_hThing
    &&    pBitmapObj->m_lMemSize)
        {
        delete pBitmapObj;
                pBitmapObj = NULL;

        CString strDocName;
        CString strFilterExt;

        if (! pDoc->GetDocTemplate()->GetDocString( strDocName, CDocTemplate::docName )
        ||                                          strDocName.IsEmpty())
            // use generic 'untitled'
            VERIFY( strDocName.LoadString( AFX_IDS_UNTITLED ) );

        if (! pDoc->GetDocTemplate()->GetDocString( strFilterExt, CDocTemplate::filterExt )
        ||                                          strFilterExt.IsEmpty())
            pDoc->SetPathName( strDocName );
        else
            pDoc->SetPathName( strDocName + strFilterExt );

        // do settitle after setpathname.
        pDoc->SetTitle( strDocName );

        pDoc->m_sName.Empty();
        pDoc->m_bNewDoc = TRUE;

        if (! pDoc->CreateNewDocument())
            return FALSE;

        pBitmapObj = pDoc->m_pBitmapObjNew;
        }

    if (! pBitmapObj->m_pImg
    &&  ! pBitmapObj->CreateImg())
        return FALSE;

    if (pBitmapObj->m_pImg->cxWidth  < 1
    ||  pBitmapObj->m_pImg->cyHeight < 1)
        {
        CmpMessageBox( IDS_ERROR_BITMAPSIZE, AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION );
        return FALSE;
        }

    CleanupImgUndo();
    CleanupImgRubber();

    if (! SetView( pBitmapObj ))
        return FALSE;

    if (pDoc->m_pBitmapObj)
                {
        delete pDoc->m_pBitmapObj;
                pDoc->m_pBitmapObj = NULL;
                }

    pDoc->m_pBitmapObj    = pBitmapObj;
    pDoc->m_pBitmapObjNew = NULL;

    return TRUE;
    }

/***************************************************************************/

BOOL CPBView::SetView( CBitmapObj* pBitmapObj )
    {
    IMG* pImg = pBitmapObj->m_pImg;

    ASSERT( pImg );

    CImgWnd* pImgWnd = new CImgWnd( pImg );

    if (pImgWnd == NULL)
        {
        theApp.SetMemoryEmergency();

        TRACE( TEXT("Create CImgWnd faild\n") );

        return FALSE;
        }

    RECT rectPos;

    GetClientRect( &rectPos );

    if (! pImgWnd->Create( WS_CHILD | WS_VISIBLE, rectPos, this ))
        {
        TRACE( TEXT("Create img wnd failed\n") );
        return FALSE;
        }

    if (m_pImgWnd)
                {
                if ( ::IsWindow( m_pImgWnd->m_hWnd) )
                        m_pImgWnd->DestroyWindow();
        delete m_pImgWnd;
                m_pImgWnd = NULL;
                }

    m_pImgWnd = pImgWnd;

    if (m_pwndThumbNailView != NULL)
        {
        m_pImgWnd->SetThumbnailView( m_pwndThumbNailView );
        m_pwndThumbNailView->UpdateThumbNailView();
        }

    m_pImgWnd->SetZoom( 1 );
    // m_pImgWnd->SetFocus(); // Commented out to prevent focus problems w/OLE

    return TRUE;
    }

/***************************************************************************/

int CPBView::SetTools()
    {
    CFrameWnd* pOwnerWindow    = GetParentFrame();
    CFrameWnd* pParentWindow   = pOwnerWindow;
    BOOL       bRestoreState   = FALSE;

    ASSERT( pOwnerWindow != NULL );

    if (! theApp.m_bLinked && theApp.m_pwndInPlaceFrame != NULL)
        {
        pOwnerWindow = theApp.m_pwndInPlaceFrame;

        if (theApp.m_hwndInPlaceApp != NULL)
            pParentWindow = (CFrameWnd*)CFrameWnd::FromHandle( theApp.m_hwndInPlaceApp );
        }


        ASSERT(g_pStatBarWnd);
        ASSERT(g_pImgToolWnd);
        ASSERT(g_pImgColorsWnd);

        // Create the status bar
        if ( !g_pStatBarWnd->m_hWnd )
                {
                if ( g_pStatBarWnd->Create(pParentWindow) )
                        {
                        if (theApp.m_fntStatus.m_hObject != NULL)
                                g_pStatBarWnd->SetFont( &theApp.m_fntStatus, FALSE );
                        g_pStatBarWnd->SetOwner(pOwnerWindow);
                        ShowStatusBar(TRUE);

                        bRestoreState = TRUE;
                        }
                else
                        {
                        TRACE0("Failed to create status bar\n");
                        return -1;
                        }
                }

        pParentWindow->EnableDocking(CBRS_ALIGN_ANY);

        // Create and dock the tool bar
        if ( !g_pImgToolWnd->m_hWnd || !IsWindow(g_pImgToolWnd->m_hWnd) )
                {
        CString strToolWnd;
        strToolWnd.LoadString(IDS_PAINT_TOOL);
                if ( g_pImgToolWnd->Create( strToolWnd,
                                            WS_CHILD|WS_VISIBLE|CBRS_LEFT,
                                            CRect(0, 0, 0, 0),
                                            CPoint(25, 25),
                                            2,
                                            pParentWindow ) )
                        {
                        g_pImgToolWnd->SetOwner(pOwnerWindow);
                        g_pImgToolWnd->EnableDocking(CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT);
                        pParentWindow->DockControlBar(g_pImgToolWnd,
                                                      AFX_IDW_DOCKBAR_LEFT);

                        bRestoreState = TRUE;
                        }
                else
                {
                        TRACE0("Failed to create toolbar\n");
                        return -1;
                        }
                }

        // Create and dock the color bar
        if ( !g_pImgColorsWnd->m_hWnd || !IsWindow(g_pImgColorsWnd->m_hWnd) )
                {
        CString strColorsWnd;
        strColorsWnd.LoadString(IDS_COLORS);
                if ( g_pImgColorsWnd->Create(strColorsWnd,
                                            WS_CHILD|WS_VISIBLE|CBRS_BOTTOM,
                                            pParentWindow) )
                        {
                        g_pImgColorsWnd->SetOwner(pOwnerWindow);
                        g_pImgColorsWnd->EnableDocking(CBRS_ALIGN_BOTTOM|CBRS_ALIGN_TOP);
                        pParentWindow->DockControlBar(g_pImgColorsWnd,
                                                     AFX_IDW_DOCKBAR_BOTTOM);

                        bRestoreState = TRUE;
                        }
                else
                        {
                        TRACE0("Failed to create colorbar\n");
                        return -1;
                        }
                }

    if ( bRestoreState && !theApp.m_bLinked && !theApp.m_bEmbedded && !theApp.m_pwndInPlaceFrame )
        pOwnerWindow->LoadBarState(TEXT("General")); // Dangerous in-place!

    pOwnerWindow->DelayRecalcLayout( TRUE );
        return 0;
    }

/******************************************************************************/
BOOL CPBView::DestroyThumbNailView()
        {
        BOOL    bResult = FALSE;
        BOOL    bOriginalSetting = theApp.m_bShowThumbnail;

    theApp.m_bShowThumbnail = FALSE;

    if (m_pwndThumbNailFloat != NULL)
        {
        if ( ::IsWindow(m_pwndThumbNailFloat->m_hWnd) )
                m_pwndThumbNailFloat->DestroyWindow();
                delete m_pwndThumbNailFloat;
                m_pwndThumbNailFloat = NULL;
                bResult = TRUE;
                }


    theApp.m_bShowThumbnail = bOriginalSetting;
    m_pwndThumbNailView = NULL;

        if (m_pImgWnd)
        m_pImgWnd->SetThumbnailView( NULL );

        return bResult;
        }

BOOL CPBView::CreateThumbNailView()
    {
    if (m_pImgWnd == NULL)
        return FALSE;

        DestroyThumbNailView();


        m_pwndThumbNailFloat = new CFloatThumbNailView( m_pImgWnd );

        if (m_pwndThumbNailFloat != NULL)
            {
            if (m_pwndThumbNailFloat->Create( this ))
                m_pwndThumbNailView = m_pwndThumbNailFloat->GetThumbNailView();

            if (m_pwndThumbNailView)
                {
                m_pImgWnd->SetThumbnailView( m_pwndThumbNailView );
                m_pwndThumbNailFloat->ShowWindow( SW_SHOWNOACTIVATE );
                }
            else
                                {
                                delete m_pwndThumbNailFloat;
                m_pwndThumbNailFloat = NULL;
                                }
            }


    if (m_pwndThumbNailView == NULL)
        {
        theApp.m_bShowThumbnail = FALSE;
        theApp.SetMemoryEmergency();

        TRACE( TEXT("Create CThumbNailView failed\n") );
        return FALSE;
        }

    m_pwndThumbNailView->ShowWindow( SW_SHOWNOACTIVATE );
    m_pwndThumbNailView->UpdateWindow();
    UpdateWindow();

    return TRUE;
    }

/***************************************************************************/

void CPBView::ToggleThumbNailVisibility( void )
    {
        theApp.m_bShowThumbnail = !IsThumbNailVisible();

        if ( theApp.m_bShowThumbnail )
                ShowThumbNailView();
        else if (m_pwndThumbNailView)
                HideThumbNailView();
    }

/***************************************************************************/

void CPBView::HideThumbNailView(void)
    {
    if (IsThumbNailVisible())
                {
            if (m_pwndThumbNailFloat)
                m_pwndThumbNailFloat->ShowWindow( SW_HIDE );


            theApp.m_bShowThumbnail = FALSE;
                }
    }

/***************************************************************************/

void CPBView::ShowThumbNailView(void)
    {
        if ( theApp.m_bShowThumbnail
          && !IsThumbNailVisible() )
                {
                if ( m_pwndThumbNailView )
                        {
                    if (m_pwndThumbNailFloat)
                        m_pwndThumbNailFloat->ShowWindow( SW_SHOWNOACTIVATE );

                        }
                else
                        CreateThumbNailView();
                }
    }

/***************************************************************************/

BOOL CPBView::IsThumbNailVisible(void)
    {
    BOOL bVisible = FALSE;


    if (m_pwndThumbNailFloat != NULL)
        bVisible = m_pwndThumbNailFloat->IsWindowVisible();

    return bVisible;
    }


/***************************************************************************/

CPoint CPBView::GetDockedPos( DOCKERS tool, CSize& sizeTool )
    {
    CPoint      pt;
    CRect       rectClient;
    CRect       rectView;
    CFrameWnd*  pFrame = GetParentFrame();

    pFrame->GetClientRect( &rectClient );
    pFrame->NegotiateBorderSpace( CFrameWnd::borderGet, &rectView );

    switch (tool)
        {
        case toolbox:
                        ASSERT(0);
            break;

        case colorbox:
                        ASSERT(0);
            break;

        }
    pt = rectView.TopLeft();
    pFrame->ClientToScreen( &pt );
    return pt;
    }

/***************************************************************************/

void CPBView::GetFloatPos( DOCKERS tool, CRect& rectPos )
    {
       // removed docked thumbnail code
    }

/***************************************************************************/

void CPBView::SetFloatPos( DOCKERS tool, CRect& rectPos )
    {
       //removed docked thumbnail code
     }

/***************************************************************************/

void CPBView::OnViewThumbnail()
    {
    ToggleThumbNailVisibility();
    }

/***************************************************************************/

void CPBView::OnUpdateViewThumbnail(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL
    &&  m_pImgWnd->GetZoom() > 1)
        {
        bEnable = TRUE;
        }

    pCmdUI->Enable( bEnable );
    pCmdUI->SetCheck( theApp.m_bShowThumbnail );
    }

/***************************************************************************/

void CPBView::OnEditUndo()
    {
    if (!TextToolProcessed( ID_EDIT_UNDO ))
        {
        CancelToolMode(FALSE);

        CommitSelection(TRUE);

        theUndo.DoUndo();
        DirtyImg (m_pImgWnd->m_pImg);
        }
    }

/***************************************************************************/

void CPBView::OnEditRedo()
    {
    CancelToolMode(FALSE);

    theUndo.DoRedo();
    DirtyImg (m_pImgWnd->m_pImg);
    }

/***************************************************************************/

void CPBView::OnEditCut()
    {
    m_pImgWnd->CmdCut();
    }

/***************************************************************************/

void CPBView::OnEditClear()
    {
    m_pImgWnd->CmdClear();
    }


/***************************************************************************/

void CPBView::OnEditCopy()
{
        m_pImgWnd->CmdCopy();
}

/***************************************************************************/

void CPBView::OnEditPaste()
    {
    m_pImgWnd->CmdPaste();
    }

/***************************************************************************/


void CPBView::OnUpdateEditUndo(CCmdUI* pCmdUI)
    {
    // the text tool has no idea if it can undo and neither do we
    pCmdUI->Enable(IsUserEditingText() || theUndo.CanUndo());
    }

/***************************************************************************/

void CPBView::OnUpdateEditRedo(CCmdUI* pCmdUI)
    {
    // the text tool does not have a redo stack
    pCmdUI->Enable(!IsUserEditingText() && theUndo.CanRedo());
    }

/***************************************************************************/

void CPBView::OnUpdateEditSelection(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        {
        bEnable = m_pImgWnd->IsSelectionAvailable();
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateEditClearSel(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        bEnable = m_pImgWnd->IsSelectionAvailable();

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateEditPaste(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        {
        bEnable = m_pImgWnd->IsPasteAvailable();
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnViewGrid()
    {
    m_pImgWnd->CmdShowGrid();
    }

/***************************************************************************/

void CPBView::OnViewZoom100()
    {
    if (m_pImgWnd->GetZoom() != 1)
                {
                m_pImgWnd->SetZoom        ( 1 );
            m_pImgWnd->CheckScrollBars();
                }
    }

/***************************************************************************/

void CPBView::OnViewZoom400()
    {
    if (m_pImgWnd->GetZoom() != 4)
                {
            m_pImgWnd->SetZoom        ( 4 );
            m_pImgWnd->CheckScrollBars();
                }
    }

/***************************************************************************/

void CPBView::OnViewZoom()
    {
    CZoomViewDlg dlg;

    dlg.m_nCurrent = m_pImgWnd->GetZoom();

    if (dlg.DoModal() != IDOK)
        return;

    m_pImgWnd->SetZoom( dlg.m_nCurrent );
    m_pImgWnd->CheckScrollBars();
    }

/***************************************************************************/

void CPBView::OnUpdateViewZoom100(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        bEnable = (m_pImgWnd->GetZoom() != 1);

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateViewZoom400(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        bEnable = (m_pImgWnd->GetZoom() != 4);

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnUpdateViewGrid(CCmdUI* pCmdUI)
    {
    BOOL bCheck  = FALSE;
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        {
        bEnable = (m_pImgWnd->GetZoom() > 2);
        bCheck  =  m_pImgWnd->IsGridVisible();
        }
    pCmdUI->Enable  ( bEnable );
    pCmdUI->SetCheck( bCheck  );
    }

/***************************************************************************/

void CPBView::OnImageInvertColors()
    {
    CancelToolMode(TRUE);

    m_pImgWnd->CmdInvertColors();
    }

/***************************************************************************/
// Don't show the Invert Colors menu item if we're using a palette
void CPBView::OnUpdateImageInvertColors(CCmdUI* pCmdUI)
    {

    BOOL bEnable = FALSE;

    if (m_pImgWnd)
       {
       bEnable = (!theApp.m_bPaletted);
       }
   pCmdUI->Enable  ( bEnable );
   }

/***************************************************************************/

void CPBView::OnTglopaque()
    {
    m_pImgWnd->CmdTglOpaque();
    }

/***************************************************************************/

void CPBView::OnUpdateTglopaque(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    pCmdUI->SetCheck( theImgBrush.m_bOpaque );
    }

/***************************************************************************/

void CPBView::OnImageAttributes()
    {
    CancelToolMode(FALSE);

    CPBDoc* pDoc = GetDocument();

    ASSERT( pDoc );
    ASSERT( m_pImgWnd );

    CBitmapObj* pBitmapRes = pDoc->m_pBitmapObj;

    CImageAttr dlg;

    BOOL bMono = (pBitmapRes->m_pImg->cPlanes   == 1
               && pBitmapRes->m_pImg->cBitCount == 1);

    dlg.m_bMonochrome = bMono;
    dlg.SetWidthHeight( pBitmapRes->m_pImg->cxWidth,
                        pBitmapRes->m_pImg->cyHeight,
                        pBitmapRes->m_pImg->cXPelsPerMeter,
                        pBitmapRes->m_pImg->cYPelsPerMeter);

    if (dlg.DoModal() != IDOK)
        return;

    CSize size = dlg.GetWidthHeight();

    if (size.cx != pBitmapRes->m_pImg->cxWidth
    ||  size.cy != pBitmapRes->m_pImg->cyHeight)
        {
        theUndo.BeginUndo( TEXT("Property Edit") );

        BOOL bSuccess = pBitmapRes->SetSizeProp( P_Size, size );

        theUndo.EndUndo();

        if (bSuccess)
            theApp.m_sizeBitmap = size;
        }

    if (dlg.m_bMonochrome != bMono
        && (!dlg.m_bMonochrome
            || AfxMessageBox(IDS_WARNING_MONO, MB_YESNO|MB_ICONEXCLAMATION)==IDYES))
        {
        theUndo.BeginUndo( TEXT("Property Edit") );

        pBitmapRes->SetIntProp( P_Colors, dlg.m_bMonochrome );

        theUndo.EndUndo();
        }
    }

/***************************************************************************/

void CPBView::OnImageClearImage()
    {
    CancelToolMode(FALSE);

    m_pImgWnd->CmdClear();
    }

/***************************************************************************/

void CPBView::OnFilePrint()
    {
    CancelToolMode(FALSE);

    CView::OnFilePrint();

    }

/***************************************************************************/

void CPBView::OnFilePrintPreview()
    {
    CancelToolMode(FALSE);

    CView::OnFilePrintPreview();
    }

/***************************************************************************/

void CPBView::OnUpdateImageClearImage( CCmdUI* pCmdUI )
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd)
        bEnable = (CImgTool::GetCurrentID() != IDMX_TEXTTOOL
                      && ! m_pImgWnd->IsSelectionAvailable() );
    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnSel2bsh()
    {
    m_pImgWnd->CmdSel2Bsh();
    }

/***************************************************************************/

void CPBView::OnLargerbrush()
    {
    m_pImgWnd->CmdLargerBrush();
    }

/***************************************************************************/

void CPBView::OnSmallerbrush()
    {
    m_pImgWnd->CmdSmallerBrush();
    }

/***************************************************************************/

void CPBView::OnImageFlipRotate()
    {
    CancelToolMode(TRUE);

    CFlipRotateDlg dlg;

    if (dlg.DoModal() != IDOK)
        return;

    if (dlg.m_bAngle)
        {
        switch (dlg.m_nAngle)
            {
            case 90:
                m_pImgWnd->CmdRot90();
                break;

            case 180:
                theUndo.BeginUndo( TEXT("Rotate 180") );

                m_pImgWnd->CmdFlipBshH();
                m_pImgWnd->CmdFlipBshV();

                theUndo.EndUndo();
                break;

            case 270:
                theUndo.BeginUndo( TEXT("Rotate 270") );

                m_pImgWnd->CmdRot90();
                m_pImgWnd->CmdFlipBshH();
                m_pImgWnd->CmdFlipBshV();

                theUndo.EndUndo();
                break;
            }
        }
    else
        if (dlg.m_bHorz)
            m_pImgWnd->CmdFlipBshH();
        else
            m_pImgWnd->CmdFlipBshV();
    }

/***************************************************************************/

void CPBView::OnUpdateImageFlipRotate(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    }

/***************************************************************************/

void CPBView::OnEditcolors()
    {
    g_pColors->CmdEditColor();
    }

/***************************************************************************/

void CPBView::OnUpdateEditcolors(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( g_pColors != NULL );
    }

/***************************************************************************/
#if 0
void CPBView::OnLoadcolors()
    {
    CancelToolMode(FALSE);

    g_pColors->CmdLoadColors();
    }

/***************************************************************************/

void CPBView::OnUpdateLoadcolors(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (g_pColors && m_pImgWnd && m_pImgWnd->m_pImg &&
        m_pImgWnd->m_pImg->m_pBitmapObj)
        {
        // not allowed except on 24 bit images
        bEnable = ( m_pImgWnd->m_pImg->m_pBitmapObj->m_nColors == 3 );
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnSavecolors()
    {
    g_pColors->CmdSaveColors();
    }

/***************************************************************************/

void CPBView::OnUpdateSavecolors(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( g_pColors != NULL );
    }

/***************************************************************************/
#endif
void CPBView::OnEditSelectAll()
    {
    if (m_pImgWnd)
        {
        if (!TextToolProcessed( ID_EDIT_SELECT_ALL ))
            {
            IMG *img = m_pImgWnd? m_pImgWnd->GetImg() : NULL;

            if (img)
                {
                CImgTool::Select(IDMB_PICKTOOL);
                m_pImgWnd->MakeBrush( img->hDC,
                    CRect( 0, 0, img->cxWidth, img->cyHeight ) );
                }
            }
        }
    }

/***************************************************************************/

void CPBView::OnEditPasteFrom()
    {
    CBitmapObj *pResObject = new CBitmapObj();

    ASSERT(pResObject != NULL);

    if (pResObject != NULL)
        {
        ASSERT( m_pImgWnd != NULL );

        pResObject->MakeEmpty();

        CString newName;
        int iColor = 0;

        if (theApp.DoPromptFileName( newName, IDS_EDIT_PASTE_FROM,
                                     OFN_PATHMUSTEXIST, TRUE, iColor, FALSE ))
            {
            if (pResObject->Import( newName ))
                {
                LPSTR lpDib = (LPSTR) GlobalLock(pResObject->m_hThing);
                m_pImgWnd->PasteImageFile( lpDib );
                GlobalUnlock(pResObject->m_hThing);
                }
            }

        pResObject->m_pImg = NULL;
        delete pResObject;
                pResObject = NULL;
        }
    }


/***************************************************************************/

BOOL FillBitmapObj(CImgWnd* pImgWnd, CBitmapObj* pResObject, IMG* pImgStruct,
        int iColor)
{
        ASSERT(pImgWnd != NULL);

        pResObject->MakeEmpty();

        if (pImgWnd->m_pImg                           == NULL
                ||  pImgWnd->m_pImg->m_pBitmapObj         == NULL
                ||  pImgWnd->m_pImg->m_pBitmapObj->m_pImg == NULL)
        {
                return(FALSE);
        }

        if (iColor < 0)
        {
                iColor = pImgWnd->m_pImg->m_pBitmapObj->m_nColors;
        }

        if (theImgBrush.m_bFirstDrag)
        {
                PickupSelection();
        }

        *pImgStruct = *theImgBrush.m_pImg;

        pImgStruct->hDC        = theImgBrush.m_dc.GetSafeHdc();
        pImgStruct->hBitmap    = (HBITMAP)theImgBrush.m_bitmap.GetSafeHandle();
        pImgStruct->hBitmapOld = theImgBrush.m_hbmOld;
        pImgStruct->bDirty     = TRUE;
        pImgStruct->m_pPalette = theApp.m_pPalette;
        pImgStruct->cxWidth    = theImgBrush.m_size.cx;
        pImgStruct->cyHeight   = theImgBrush.m_size.cy;

        if (iColor < 4 && iColor >= 0)
        {
                pResObject->m_nSaveColors = iColor;
        }

#ifdef PCX_SUPPORT
        pResObject->m_bPCX        = (iColor == 4);
#endif
#ifdef ICO_SUPPORT
        pResObject->m_bSaveIcon   = (iColor == 5);
#endif
        pResObject->m_nWidth      = pImgStruct->cxWidth;
        pResObject->m_nHeight     = pImgStruct->cyHeight;
        pResObject->m_nColors     = pImgWnd->m_pImg->m_pBitmapObj->m_nColors;
        pResObject->m_bCompressed = pImgWnd->m_pImg->m_pBitmapObj->m_bCompressed;

        pResObject->m_pImg = pImgStruct;

        return(TRUE);
}

void CPBView::OnEditCopyTo()
{
        CString newName;
        int iColor = m_pImgWnd->m_pImg->m_pBitmapObj->m_nColors;

        if (theApp.DoPromptFileName( newName, IDS_EDIT_COPY_TO,
                OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, iColor, TRUE ))
        {
                BeginWaitCursor();

                CBitmapObj cResObject;

                IMG imgStruct;

                if (!FillBitmapObj(m_pImgWnd, &cResObject, &imgStruct, iColor))
                {
                        // FEATURE: Need an error message
                        // Actually, can this ever happen?
                        return;
                }

                cResObject.SaveResource( FALSE );
                cResObject.Export( newName );

                EndWaitCursor();

                // Don't delete this on destructor
                cResObject.m_pImg = NULL;
        }
}

/***************************************************************************/

void CPBView::OnUpdateEditCopyTo(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (CImgTool::GetCurrentID() == IDMB_PICKTOOL
    ||  CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
        {
        ASSERT( m_pImgWnd != NULL );

        if (m_pImgWnd != NULL)
            {
            if (m_pImgWnd->m_pImg != NULL)
                {
                if (m_pImgWnd->m_pImg == theImgBrush.m_pImg)
                    {
                    bEnable = TRUE;
                    }
                }
            }
        }

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnImageStretchSkew()
    {
    CancelToolMode(TRUE);

    CStretchSkewDlg dlg;

    if (dlg.DoModal() != IDOK)
        return;

    int iStretchHorz = dlg.GetStretchHorz();
    int iStretchVert = dlg.GetStretchVert();

    if (iStretchVert
    ||  iStretchHorz)
        {
        CPBDoc* pDoc = GetDocument();

        ASSERT( pDoc );

        int iWidthImg    = pDoc->m_pBitmapObj->m_pImg->cxWidth;
        int iHeightImg   = pDoc->m_pBitmapObj->m_pImg->cyHeight;

        if (theImgBrush.m_pImg == NULL)
            {
            int lX = iWidthImg  + (iWidthImg  * iStretchHorz) / 100;
            int lY = iHeightImg + (iHeightImg * iStretchVert) / 100;

            CBitmap bmWork;
            CDC     dcWork;
            CDC*    pdcImg = CDC::FromHandle( pDoc->m_pBitmapObj->m_pImg->hDC );
            CSize   sizeBMP( (UINT)lX, (UINT)lY );
            CRect   rect( 0, 0, lX, lY );

            if (! dcWork.CreateCompatibleDC    ( pdcImg )
            ||  ! bmWork.CreateCompatibleBitmap( pdcImg, iWidthImg, iHeightImg ))
                {
                theApp.SetGdiEmergency( TRUE );
                return;
                }

            CBitmap*   pbmOld = dcWork.SelectObject( &bmWork );
            CPalette* ppalOld = m_pImgWnd->SetImgPalette( &dcWork, FALSE );

            BeginWaitCursor();

            dcWork.BitBlt( 0, 0, iWidthImg, iHeightImg, pdcImg, 0, 0, SRCCOPY );

            theUndo.BeginUndo( TEXT("Property Edit") );

            pDoc->m_pBitmapObj->SetSizeProp( P_Size, sizeBMP );

            StretchCopy( pdcImg->m_hDC, 0, 0, lX, lY,
                          dcWork.m_hDC, 0, 0, iWidthImg, iHeightImg );

            InvalImgRect ( m_pImgWnd->m_pImg, NULL );
            CommitImgRect( m_pImgWnd->m_pImg, NULL );
            theUndo.EndUndo();
            DirtyImg(m_pImgWnd->m_pImg);

            dcWork.SelectObject( pbmOld );
            bmWork.DeleteObject();

            if (ppalOld)
                dcWork.SelectPalette( ppalOld, FALSE );

            dcWork.DeleteDC();

            theApp.m_sizeBitmap = sizeBMP;

            EndWaitCursor();
            }
        else
            {
            CRect rect = theImgBrush.m_rcSelection;
            long  lX   = theImgBrush.m_size.cx;
            long  lY   = theImgBrush.m_size.cy;

            lX += (lX * iStretchHorz) / 100;
            lY += (lY * iStretchVert) / 100;

            rect.right  = rect.left + (UINT)lX;
            rect.bottom = rect.top  + (UINT)lY;

            // If the image is a bitmap and the bitmap in the clipboard is larger,
            // then give the suer the option2 of growing the image...
//          if (lX > iWidthImg || lY > iHeightImg)
//              {
//              switch (AfxMessageBox( IDS_ENLAGEBITMAPFORSTRETCH,
//                                     MB_YESNOCANCEL | MB_ICONQUESTION ))
//                  {
//                  default:
//                      return;
//                      break;

//                  case IDYES:
//                      {
//                      CSize size( max( lX, iWidthImg  ),
//                                  max( lY, iHeightImg ) );

//                      theUndo.BeginUndo( "Resize Bitmap" );
//                      VERIFY( pDoc->m_pBitmapObj->SetSizeProp( P_Size, size ) );

//                      theUndo.EndUndo();
//                      }
//                      break;

//                  case IDNO:
//                      break;
//                  }
//              }

            m_pImgWnd->PrepareForBrushChange();

            HideBrush();

            theImgBrush.SetSize( CSize( (UINT)lX, (UINT)lY ) );

            SetCombineMode( combineColor );

            InvalImgRect( theImgBrush.m_pImg, NULL ); // draw selection tracker
            m_pImgWnd->MoveBrush( rect );
            }
        }

    int wSkewHorz = (int)dlg.GetSkewHorz();
    int wSkewVert = (int)dlg.GetSkewVert();

    if (wSkewHorz)
        m_pImgWnd->CmdSkewBrush( wSkewHorz, TRUE );

    if (wSkewVert)
        m_pImgWnd->CmdSkewBrush( wSkewVert, FALSE );
    }

/***************************************************************************/

void CPBView::OnUpdateImageStretchSkew(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    }

/***************************************************************************/

void CPBView::OnViewViewPicture()
    {
    CPBDoc *pDoc;
    CString strCaption;

    ASSERT(! theApp.m_bEmbedded);
    pDoc = GetDocument();

    CFullScreenThumbNailView *pcThumbNailView = new CFullScreenThumbNailView( m_pImgWnd );

    if (  pcThumbNailView == NULL
    ||  ! pcThumbNailView->Create((LPCTSTR)pDoc->GetPathName()))
        {
        theApp.SetMemoryEmergency();

        TRACE( TEXT("Create CThumbNailView faild\n") );
        }
    }

/***************************************************************************/

void CPBView::OnUpdateViewViewPicture(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_pImgWnd != NULL );
    }

/***************************************************************************/

void CPBView::OnViewTextToolbar()
    {
    ASSERT( CImgTool::GetCurrentID() == IDMX_TEXTTOOL );

    CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

    ASSERT( pTextTool->IsKindOf( RUNTIME_CLASS( CTextTool ) ) );

    pTextTool->ToggleFontPalette();
    }

/***************************************************************************/

void CPBView::OnUpdateViewTextToolbar(CCmdUI* pCmdUI)
    {
    BOOL bEnable = FALSE;

    if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();

        ASSERT( pTextTool );
        ASSERT( pTextTool->IsKindOf( RUNTIME_CLASS( CTextTool ) ) );

        if (pTextTool
        &&  pTextTool->IsSlectionVisible())
            bEnable = TRUE;
        }

    pCmdUI->SetCheck( theApp.m_bShowTextToolbar );
    pCmdUI->Enable  ( bEnable );
    }

/***************************************************************************/

void CPBView::OnFileSetaswallpaperT()
    {
    SetTheWallpaper( TRUE );
    }

/***************************************************************************/

void CPBView::OnUpdateFileSetaswallpaperT( CCmdUI* pCmdUI )
    {
    pCmdUI->Enable( CanSetWallpaper() );
    }

/***************************************************************************/

void CPBView::OnFileSetaswallpaperC()
    {
    SetTheWallpaper( FALSE );
    }

/***************************************************************************/

void CPBView::OnUpdateFileSetaswallpaperC(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( CanSetWallpaper() );
    }

/***************************************************************************/

BOOL CPBView::CanSetWallpaper()
    {
    BOOL bEnable = FALSE;

    if (m_pImgWnd != NULL)
        {
        CPBDoc* pDoc = GetDocument();

        ASSERT( pDoc );

        bEnable = (! pDoc->GetPathName().IsEmpty() || pDoc->IsModified());

        // read the user policy key to see whether we should disable wallpaper setting

        if (bEnable)
            {
            HKEY hKey = 0;

            if (RegOpenKeyEx( HKEY_CURRENT_USER, REGSTR_PATH_POLICIES _T("\\ActiveDesktop"), 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
                {
                BOOL  bNoChangingWallpaper = FALSE;
                DWORD cbData = sizeof(bNoChangingWallpaper);

                if (RegQueryValueEx(hKey, _T("NoChangingWallpaper"), 0, 0, (PBYTE) &bNoChangingWallpaper, &cbData) == ERROR_SUCCESS)
                    {
                    bEnable = !bNoChangingWallpaper;
                    }

                RegCloseKey(hKey);
                }            
            }
        }
    return bEnable;
    }

/***************************************************************************/

void CPBView::SetTheWallpaper( BOOL bTiled /* = FALSE */ )
    {
    CPBDoc* pDoc = GetDocument();
    ASSERT( pDoc != NULL );

    CString cStrFileName = pDoc->GetPathName();

    BOOL bSetWallpaper = ! (cStrFileName.IsEmpty() || pDoc->IsModified() || pDoc->m_bNonBitmapFile);

    if (! bSetWallpaper)
        switch (AfxMessageBox( IDS_MUST_SAVE_WALLPAPER, MB_OKCANCEL | MB_ICONEXCLAMATION ))
            {
            case IDOK:
                // If so, either Save or Update, as appropriate
                bSetWallpaper = pDoc->SaveTheDocument();
                cStrFileName = pDoc->GetPathName();
                break;

            case IDCANCEL:
                break;

            default:
                theApp.SetMemoryEmergency();
                break;
            }

    if (bSetWallpaper)
        {
        DWORD dwDisp;
        HKEY  hKey = 0;

        if (RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"),
                            REG_OPTION_RESERVED, TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &hKey, &dwDisp ) == ERROR_SUCCESS)
            {
            RegSetValueEx( hKey, TEXT("TileWallpaper"), 0, REG_SZ,
                            (BYTE *)(bTiled? TEXT("1"): TEXT("0")), 2*sizeof(TCHAR) );
            RegCloseKey( hKey );
            }

        SystemParametersInfo( SPI_SETDESKWALLPAPER, bTiled? 1: 0,
                         (LPVOID)(cStrFileName.GetBuffer( cStrFileName.GetLength() )),
                         SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );

        cStrFileName.ReleaseBuffer();
        }
    }

/***************************************************************************/

void CPBView::OnPaletteChanged(CWnd* pFocusWnd)
    {
    // If this application did not change the palette, select
    // and realize this application's palette
    if ((pFocusWnd         != m_pImgWnd)
    &&  (m_pImgWnd         != NULL)
    &&  (m_pImgWnd->m_pImg != NULL))
        {
        if (theApp.m_pPalette)
            {
            // Redraw the entire client area
            m_pImgWnd->InvalidateRect(NULL);
            m_pImgWnd->UpdateWindow();

                if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
                {
                InvalColorWnd();
                // g_pImgColorsWnd->UpdateWindow();
                }
            }
        }
    }

/***************************************************************************/

BOOL CPBView::OnQueryNewPalette()
    {
    HPALETTE hOldPal = NULL;

    if (m_pImgWnd && ::IsWindow(m_pImgWnd->m_hWnd)
    &&  m_pImgWnd->m_pImg)
        {
        if (theApp.m_pPalette)
            {
            // Redraw the entire client area
            m_pImgWnd->InvalidateRect(NULL);
            m_pImgWnd->UpdateWindow();

                if (g_pImgColorsWnd && g_pImgColorsWnd->m_hWnd && IsWindow(g_pImgColorsWnd->m_hWnd))
                {
                InvalColorWnd();
                g_pImgColorsWnd->UpdateWindow();
                }
            }
        }
    return TRUE;
    }

/***************************************************************************/

void CPBView::OnUpdateImageAttributes( CCmdUI* pCmdUI )
    {
    BOOL bEnable = (m_pImgWnd != NULL);

    pCmdUI->Enable( bEnable );
    }

/***************************************************************************/

void CPBView::OnEscape()
{
        if (m_pImgWnd != NULL)
        {
                m_pImgWnd->CmdCancel();
        }

        OnCancelMode();
}

/***************************************************************************/

void CPBView::OnEscapeServer()
{
        CImgTool* pImgTool = CImgTool::GetCurrent();

        if (pImgTool->IsToolModal())
        {
                OnEscape();
                return;
        }
        else
        {
                // Tell the OLE client (if there is one) we are all done
                GetDocument()->OnDeactivateUI(FALSE);
        }
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrush.cpp ===
// pbrush.cpp : Defines the class behaviors for the application.
//
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "ipframe.h"
#include "pbrusdoc.h"
#include "pbrusvw.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "ferr.h"
#include "cmpmsg.h"
#include "settings.h"
#include "undo.h"
#include "colorsrc.h"
#include "printres.h"
#include "loadimag.h"
#include "image.h"
#include <dlgs.h>
#include <shlobj.h>
#include "ofn.h"
#include "imaging.h"

// turn on visibility of GIF filter

#define GIF_SUPPORT

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


typedef BOOL(WINAPI* SHSPECPATH)(HWND,LPTSTR,int,BOOL);

#include "memtrace.h"

BOOL NEAR g_bShowAllFiles = FALSE;


#ifdef USE_MIRRORING
HINSTANCE ghInstGDI32=NULL;

DWORD WINAPI PBGetLayoutPreNT5(HDC hdc) {
    return 0;   // No mirroring on systems before NT5 or W98-CS
}

DWORD (WINAPI *PBGetLayout) (HDC hdc) = &PBGetLayoutInit;

DWORD WINAPI PBGetLayoutInit(HDC hdc) {

    PBGetLayout = (DWORD (WINAPI *) (HDC hdc)) GetProcAddress(ghInstGDI32, "GetLayout");

    if (!PBGetLayout) {
        PBGetLayout = PBGetLayoutPreNT5;
    }

    return PBGetLayout(hdc);

}


////    RESetLayout - Set layout of DC
//
//      Sets layout flags in an NT5/W98 or later DC.


DWORD WINAPI PBSetLayoutPreNT5(HDC hdc, DWORD dwLayout) {
    return 0;   // No mirroring on systems before NT5 or W98-CS
}

DWORD (WINAPI *PBSetLayout) (HDC hdc, DWORD dwLayout) = &PBSetLayoutInit;

DWORD WINAPI PBSetLayoutInit(HDC hdc, DWORD dwLayout) {

    PBSetLayout = (DWORD (WINAPI *) (HDC hdc, DWORD dwLayout)) GetProcAddress(ghInstGDI32, "SetLayout");

    if (!PBSetLayout) {
        PBSetLayout = PBSetLayoutPreNT5;
    }

    return PBSetLayout(hdc, dwLayout);

}
#endif

/***************************************************************************/
// CPBApp

BEGIN_MESSAGE_MAP(CPBApp, CWinApp)
    //{{AFX_MSG_MAP(CPBApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/***************************************************************************/
// CPBApp construction

CPBApp::CPBApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
    #ifdef _DEBUG
    m_bLogUndo = FALSE;
    #endif

    // This is the minimum amount of free memory we like to have
    // (NOTE: These are overwritten by ReadInitFile)
    m_dwLowMemoryBytes = 1024L * 2200;
    m_nLowGdiPercent   = 10;
    m_nLowUserPercent  = 10;

    m_nFileErrorCause  = 0;  // from CFileException::m_cause
    m_wEmergencyFlags  = 0;
    m_tickLastWarning  = 0;
    m_iCurrentUnits    = 0;

    m_bShowStatusbar   = TRUE;

    m_bShowThumbnail   = FALSE;
    m_bShowTextToolbar = TRUE;
    m_bShowIconToolbar = TRUE;


    m_bEmbedded        = FALSE;
    m_bLinked          = FALSE;
    m_bHidden          = FALSE;
    m_bActiveApp       = FALSE;
    m_bPenSystem       = FALSE;
    m_bPaletted        = FALSE;
    m_pPalette         = NULL;
    m_bPrintOnly       = FALSE;
#ifdef PCX_SUPPORT
    m_bPCXfile         = FALSE;
#endif

    m_rectFloatThumbnail.SetRectEmpty();

    m_rectMargins.SetRect(MARGINS_DEFAULT, MARGINS_DEFAULT, MARGINS_DEFAULT,
        MARGINS_DEFAULT);

    m_bCenterHorizontally = TRUE;
    m_bCenterVertically   = TRUE;
    m_bScaleFitTo         = FALSE;
    m_nAdjustToPercent    = 100;
    m_nFitToPagesWide     = 1;
    m_nFitToPagesTall     = 1;

    m_pwndInPlaceFrame = NULL;
    m_hwndInPlaceApp   = NULL;

    m_pColors = NULL;
    m_iColors = 0;

    for (int index = 0; index < nSysBrushes + nOurBrushes; index++)
    {
       m_pbrSysColors[index] = NULL;
    }

    m_nFilters        = 0;
    m_guidFltType     = NULL;
    m_guidFltTypeUsed = WiaImgFmt_UNDEFINED;
    m_nFilterInIdx    = -1; // default is All Pictures
    m_nFilterOutIdx   = 1;

#ifdef USE_MIRRORING
    ghInstGDI32 = GetModuleHandle(TEXT("gdi32.dll"));
#endif
}

/***************************************************************************/
// CPBApp destruction

CPBApp::~CPBApp()
{
    delete [] m_guidFltType;
}

/***************************************************************************/
// The one and only CPBApp object

CPBApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.
const CLSID BASED_CODE CLSID_Paint =
{ 0xd3e34b21, 0x9d75, 0x101a, { 0x8c, 0x3d, 0x0, 0xaa, 0x0, 0x1a, 0x16, 0x52 } };
const CLSID BASED_CODE CLSID_PaintBrush =
{ 0x0003000A, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };

/***************************************************************************/
// Stolen from WordPad
BOOL MatchOption(LPTSTR lpsz, LPTSTR lpszOption)
{
        if (lpsz[0] == TEXT('-') || lpsz[0] == TEXT('/'))
        {
                lpsz++;
                if (lstrcmpi(lpsz, lpszOption) == 0)
                        return TRUE;
        }
        return FALSE;
}

void CPBApp::ParseCommandLine()
{
        BOOL bPrintTo = FALSE;

        // start at 1 -- the first is the exe
        for (int i=1; i< __argc; i++)
        {
                if (MatchOption(__targv[i], TEXT("pt")))
                        bPrintTo = m_bPrintOnly = TRUE;
                else if (MatchOption(__targv[i], TEXT("p")))
                        m_bPrintOnly = TRUE;
                else if (MatchOption(__targv[i], TEXT("wia")))
                        m_bWiaCallback = TRUE;
                else if (m_bWiaCallback && m_strWiaDeviceId.IsEmpty())
                        m_strWiaDeviceId = __targv[i];
                else if (m_bWiaCallback && m_strWiaEventId.IsEmpty())
                        m_strWiaEventId = __targv[i];
//              else if (MatchOption(__targv[i], TEXT("Embedding")))
//                      m_bEmbedded = TRUE;
//              else if (MatchOption(__targv[i], TEXT("Automation")))
//                      m_bEmbedded = TRUE;
                else if (m_strDocName.IsEmpty())
                        m_strDocName = __targv[i];
                else if (bPrintTo && m_strPrinterName.IsEmpty())
                        m_strPrinterName = __targv[i];
                else if (bPrintTo && m_strDriverName.IsEmpty())
                        m_strDriverName = __targv[i];
                else if (bPrintTo && m_strPortName.IsEmpty())
                        m_strPortName = __targv[i];
                else
                {
                        ASSERT(FALSE);
                }
        }
}


void GetShortModuleFileName(HINSTANCE hInst, LPTSTR pszName, UINT uLen)
{
        TCHAR szLongName[_MAX_PATH];

        GetModuleFileName(hInst, szLongName, _MAX_PATH);

        // APPCOMPAT GSPN sometimes fails on UNC's.  Try this until that is tracked down
        lstrcpyn(pszName, szLongName, uLen);

        if (!GetShortPathName(szLongName, pszName, uLen))
        {
                GetLastError();
        }
}


#if 0

// Pulling self-registration out. This is to be done once during setup only

void CPBApp::RegisterShell(CSingleDocTemplate *pDocTemplate)
{
        const struct
        {
                LPCTSTR pszActionID;
                LPCTSTR pszCommand;
        } aActions[] =
        {
                { TEXT("Open")   , TEXT("\"%s\" \"%%1\"") },
                { TEXT("Print")  , TEXT("\"%s\" /p \"%%1\"") },
                { TEXT("PrintTo"), TEXT("\"%s\" /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"") },
        } ;

        // We now need quotes around the file name, and MFC doesn't do this
        CString strTypeID;
        if (!pDocTemplate->GetDocString(strTypeID, CDocTemplate::regFileTypeId))
        {
                return;
        }

        strTypeID += TEXT("\\shell");

        CRegKey rkShellInfo(HKEY_CLASSES_ROOT, strTypeID);
        if (!(HKEY)rkShellInfo)
        {
                return;
        }

        TCHAR szFile[MAX_PATH];
        ::GetShortModuleFileName(AfxGetInstanceHandle(), szFile, ARRAYSIZE(szFile));

        int i;
        for (i=0; i<ARRAYSIZE(aActions); ++i)
        {
                CRegKey rkAction(rkShellInfo, aActions[i].pszActionID);
                if (!(HKEY)rkAction)
                {
                        continue;
                }

                // Note I do not set the name of the action;  I will need to add this
                // if I use anything other than "Open", "Print", or "PrintTo"

                TCHAR szCommand[MAX_PATH + 80];
                wsprintf(szCommand, aActions[i].pszCommand, szFile);

                RegSetValue(rkAction, TEXT("command"), REG_SZ, szCommand, 0);
        }

        // Set the OLE server for PBrush objects
        CRegKey rkPBrushInfo(HKEY_CLASSES_ROOT, TEXT("PBrush\\protocol\\StdFileEditing\\server"));
        if ((HKEY)rkPBrushInfo)
        {
                RegSetValue(rkPBrushInfo, TEXT(""), REG_SZ, szFile, 0);
        }
}

#endif

/***************************************************************************/
// CPBApp initialization

BOOL CPBApp::InitInstance()
    {
    SetRegistryKey( IDS_REGISTRY_PATH );
    if (m_pszProfileName)
    {
       free((void*)m_pszProfileName);
    }
    m_pszProfileName = _tcsdup(TEXT("Paint"));

    HDC hdc = ::GetDC( NULL );

    ASSERT( hdc != NULL );

    GetSystemSettings( CDC::FromHandle( hdc ) );

    ::ReleaseDC( NULL, hdc );

    // Because we cannot LoadString when these strings are needed (in
    // WarnUserOfEmergency) load them here in private member variables
    // of CTheApp...
    //
    m_strEmergencyNoMem.LoadString ( IDS_ERROR_NOMEMORY );
    m_strEmergencyLowMem.LoadString( IDS_ERROR_LOWMEMORY );

    // Initialize OLE 2.0 libraries
    if (! AfxOleInit())
        {
        AfxMessageBox( IDP_OLE_INIT_FAILED );
        return FALSE;
        }

    // disable the annoying "server busy" dialog that pops up
    // during long blocking WIA calls

    COleMessageFilter* pFilter = AfxOleGetMessageFilter();

    ASSERT( pFilter );

    if (pFilter)
        {
        pFilter->EnableNotRespondingDialog(FALSE); 
        pFilter->EnableBusyDialog(FALSE);
        }

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    // SetDialogBkColor();        // Set dialog background color to gray
    LoadProfileSettings();     // Load standard INI file options (including MRU)
    InitCustomData();

    if (! g_pColors)
            {
            g_pColors = new CColors;

            if (! g_pColors->GetColorCount())
                {
                theApp.SetMemoryEmergency();
                return -1;
                }
            }
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;

    pDocTemplate = new CSingleDocTemplate( ID_MAINFRAME,
                                 RUNTIME_CLASS( CPBDoc ),
                                 RUNTIME_CLASS( CPBFrame ), // main SDI frame window
                                 RUNTIME_CLASS( CPBView ) );

    pDocTemplate->SetServerInfo( IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
                                 RUNTIME_CLASS( CInPlaceFrame ),
                                 RUNTIME_CLASS( CPBView ) );

    AddDocTemplate( pDocTemplate );

    // Connect the COleTemplateServer to the document template.
    //  The COleTemplateServer creates new documents on behalf
    //  of requesting OLE containers by using information
    //  specified in the document template.
    m_server.ConnectTemplate( CLSID_Paint, pDocTemplate, TRUE );
        // Note: SDI applications register server objects only if /Embedding
        //   or /Automation is present on the command line.

#if 0
    // Pulling self-registration out. This is to be done once during setup only
    RegisterShell(pDocTemplate);
#endif

    m_bEmbedded = RunEmbedded();

    // Parse the command line to see if launched as OLE server
    if (m_bEmbedded || RunAutomated())
        {
        // Register all OLE server (factories) as running.  This enables the
        //  OLE 2.0 libraries to create objects from other applications.
        COleTemplateServer::RegisterAll();

        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        return TRUE;
        }

#if 0
    // Pulling self-registration out. This is to be done once during setup only

    // When a server application is launched stand-alone, it is a good idea
    //  to update the system registry in case it has been damaged.
    m_server.UpdateRegistry( OAT_INPLACE_SERVER );
#endif

    ParseCommandLine();

    if (m_bWiaCallback)
    {
        USES_CONVERSION;
        GUID guidEventId;

        ASSERT(!m_strWiaEventId.IsEmpty() && !m_strWiaDeviceId.IsEmpty());

        // check that we have received the WIA_EVENT_DEVICE_CONNECTED event and
        // a valid device id. If not, we should exit before going any further

        if (m_strWiaEventId.IsEmpty() ||
            m_strWiaDeviceId.IsEmpty() ||
            CLSIDFromString((LPOLESTR) T2COLE(m_strWiaEventId), &guidEventId) != S_OK ||
            guidEventId != WIA_EVENT_DEVICE_CONNECTED)
        {
            return FALSE;
        }
    }

    // simple command line parsing
    if (m_strDocName.IsEmpty())
        {
        // create a new (empty) document
        OnFileNew();
        }
    else
        {
        CString sExt = GetExtension( m_strDocName );

        if (sExt.IsEmpty())
            {
            if (pDocTemplate->GetDocString( sExt, CDocTemplate::filterExt )
            &&                            ! sExt.IsEmpty())
                m_strDocName += sExt;
            }

        WIN32_FIND_DATA finddata;
        HANDLE hFind = FindFirstFile(m_strDocName, &finddata);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            // Find the file name and replace it with the long file name
            int iBS = m_strDocName.ReverseFind(TEXT('\\'));
            if (iBS == -1)
            {
                iBS = m_strDocName.ReverseFind(TEXT(':'));
            }

            // HACK: Notice this is correct even if iBS==-1
            ++iBS;

            // Resize the memory string
            m_strDocName.GetBuffer(iBS);
            m_strDocName.ReleaseBuffer(iBS);

            m_strDocName += finddata.cFileName;
        }

        OpenDocumentFile( m_strDocName );
        }

    if (m_pMainWnd)
    {
        m_pMainWnd->DragAcceptFiles();

        if (m_bWiaCallback)
        {
            // select the device and post a message to popup the WIA dialog
            ((CPBFrame*)m_pMainWnd)->m_pMgr->Select(m_strWiaDeviceId);
            m_pMainWnd->PostMessage(WM_COMMAND, ID_FILE_SCAN_NEW, 0);
        }
    }


    return TRUE;
    }

/***************************************************************************/

int CPBApp::ExitInstance()
    {
    CustomExit();   // clean up in customiz
    CleanupImages();

    if (g_pColors)
        {
        delete g_pColors;
        g_pColors = NULL;
        }

    if (m_fntStatus.m_hObject != NULL)
        m_fntStatus.DeleteObject();

    ResetSysBrushes();

    CTracker::CleanUpTracker();

    return CWinApp::ExitInstance();
    }

/***************************************************************************/

void CPBApp::GetSystemSettings( CDC* pdc )
    {
    NONCLIENTMETRICS ncMetrics;

    ncMetrics.cbSize = sizeof( NONCLIENTMETRICS );

    if (SystemParametersInfo( SPI_GETNONCLIENTMETRICS,
                              sizeof( NONCLIENTMETRICS ),
                              &ncMetrics, 0 ))
        {
        if (m_fntStatus.m_hObject != NULL)
            m_fntStatus.DeleteObject();

        m_fntStatus.CreateFontIndirect( &ncMetrics.lfMenuFont );
        }

    ScreenDeviceInfo.iWidthinMM    = pdc->GetDeviceCaps( HORZSIZE   );
    ScreenDeviceInfo.iHeightinMM   = pdc->GetDeviceCaps( VERTSIZE   );
    ScreenDeviceInfo.iWidthinPels  = pdc->GetDeviceCaps( HORZRES    );
    ScreenDeviceInfo.iHeightinPels = pdc->GetDeviceCaps( VERTRES    );
    ScreenDeviceInfo.ixPelsPerINCH = pdc->GetDeviceCaps( LOGPIXELSX );
    ScreenDeviceInfo.iyPelsPerINCH = pdc->GetDeviceCaps( LOGPIXELSY );

    /* get the pels per decameter '.1' rounded */
    ScreenDeviceInfo.ixPelsPerDM   = (int)(((((long)ScreenDeviceInfo.iWidthinPels  * 1000L) / (long)ScreenDeviceInfo.iWidthinMM ) + 5L) / 10);
    ScreenDeviceInfo.iyPelsPerDM   = (int)(((((long)ScreenDeviceInfo.iHeightinPels * 1000L) / (long)ScreenDeviceInfo.iHeightinMM) + 5L) / 10);
    ScreenDeviceInfo.ixPelsPerMM   = (ScreenDeviceInfo.ixPelsPerDM + 50) / 100;
    ScreenDeviceInfo.iyPelsPerMM   = (ScreenDeviceInfo.iyPelsPerDM + 50) / 100;
    ScreenDeviceInfo.iWidthinINCH  = (int)(((long)ScreenDeviceInfo.iWidthinMM  * 100L / 245L + 5L) / 10L);  //24.5 mm to the inch
    ScreenDeviceInfo.iHeightinINCH = (int)(((long)ScreenDeviceInfo.iHeightinMM * 100L / 245L + 5L) / 10L);

    ScreenDeviceInfo.iBitsPixel    = pdc->GetDeviceCaps( BITSPIXEL );
    ScreenDeviceInfo.iPlanes       = pdc->GetDeviceCaps( PLANES    );

    m_cxFrame    = GetSystemMetrics( SM_CXFRAME );
    m_cyFrame    = GetSystemMetrics( SM_CYFRAME );
    m_cxBorder   = GetSystemMetrics( SM_CXBORDER );
    m_cyBorder   = GetSystemMetrics( SM_CYBORDER );
    m_cyCaption  = GetSystemMetrics( SM_CYSMCAPTION );
    m_bPenSystem = GetSystemMetrics( SM_PENWINDOWS )? TRUE: FALSE;
    m_bPaletted  = (pdc->GetDeviceCaps( RASTERCAPS ) & RC_PALETTE);

    m_bMonoDevice = ((ScreenDeviceInfo.iBitsPixel
                  *   ScreenDeviceInfo.iPlanes) == 1);

    SetErrorMode( SEM_NOOPENFILEERRORBOX );
    }

/***************************************************************************/

CPoint CPBApp::CheckWindowPosition( CPoint ptPosition, CSize& sizeWindow )
    {
    CPoint ptNew = ptPosition;

    sizeWindow.cx = max( sizeWindow.cx, 0 );
    sizeWindow.cy = max( sizeWindow.cy, 0 );

    if (sizeWindow.cx
    &&  sizeWindow.cy)
        {
        sizeWindow.cx = min( sizeWindow.cx, ScreenDeviceInfo.iWidthinPels  );
        sizeWindow.cy = min( sizeWindow.cy, ScreenDeviceInfo.iHeightinPels );
        }

    ptNew.x = max( ptNew.x, 0 );
    ptNew.y = max( ptNew.y, 0 );

    if (ptNew.x
    &&  ptNew.y)
        {
        if (ptNew.x >= ScreenDeviceInfo.iWidthinPels)
            ptNew.x  = ScreenDeviceInfo.iWidthinPels - sizeWindow.cx;

        if (ptNew.y >= ScreenDeviceInfo.iHeightinPels)
            ptNew.y  = ScreenDeviceInfo.iHeightinPels - sizeWindow.cy;
        }

    return ptNew;
    }

/***************************************************************************/

void CPBApp::WinHelp( DWORD dwData, UINT nCmd /* = HELP_CONTEXT */ )
    {
    // This app has been converted to use HtmlHelp.  This is a safety to prevent someone
    // from accidentally adding WinHelp calls for proceedural help
    ASSERT( (nCmd != HELP_FINDER) && (nCmd != HELP_INDEX) && (nCmd != HELP_CONTENTS) );

    CWinApp::WinHelp( dwData, nCmd );
    }

/***************************************************************************/

BOOL CPBApp::OnIdle( LONG lCount )
    {
    if (m_bHidden)
        return CWinApp::OnIdle( lCount );

    if (! lCount)
        {
        if (CheckForEmergency())
            {
            TryToFreeMemory();
            WarnUserOfEmergency();
            }
        if (m_nFileErrorCause != CFileException::none && m_pMainWnd)
            {
            CWnd* pWnd = AfxGetMainWnd();

            pWnd->PostMessage( WM_USER + 1001 );
            }
        }
    extern void IdleImage();

    IdleImage();

    return CWinApp::OnIdle(lCount) || lCount <= 4;
    }

/***************************************************************************/
// Map a file error code to a string id.

struct FERRID
    {
    int ferr;
    int ids;
    } mpidsferr[] =
    {
        { ferrIllformedGroup,    IDS_ERROR_BOGUSFILE    },
        { ferrReadFailed,        IDS_ERROR_BOGUSFILE    }, // error while reading a file or file corupt
        { ferrIllformedFile,     IDS_ERROR_BOGUSFILE    }, // not a valid palette file or zero length pcx file
        { ferrCantProcNewExeHdr, IDS_ERROR_EXE_HDR      },
        { ferrCantProcOldExeHdr, IDS_ERROR_EXE_HDR      },
        { ferrBadMagicNewExe,    IDS_ERROR_EXE_HDRMZ    },
        { ferrBadMagicOldExe,    IDS_ERROR_EXE_HDRMZ    },
        { ferrNotWindowsExe,     IDS_ERROR_EXE_HDRNW    },
        { ferrExeWinVer3,        IDS_ERROR_EXE_HDRWV    },
        { ferrNotValidRc,        IDS_ERROR_NOTVALID_RC  },
        { ferrNotValidExe,       IDS_ERROR_NOTVALID_EXE },
        { ferrNotValidRes,       IDS_ERROR_NOTVALID_RES },
        { ferrNotValidBmp,       IDS_ERROR_NOTVALID_BMP }, // invalid bitmap
        { ferrNotValidIco,       IDS_ERROR_NOTVALID_ICO },
        { ferrNotValidCur,       IDS_ERROR_NOTVALID_CUR },
        { ferrRcInvalidExt,      IDS_ERROR_RCPROB       },
        { ferrFileAlreadyOpen,   IDS_ERROR_COMPEX       },
        { ferrExeTooLarge,       IDS_ERROR_EXE_ALIGN    },
        { ferrCantCopyOldToNew,  IDS_ERROR_EXE_SAVE     },
        { ferrReadLoad,          IDS_ERROR_READLOAD     },
        { ferrExeAlloc,          IDS_ERROR_EXE_ALLOC    },
        { ferrExeInUse,          IDS_ERROR_EXE_INUSE    },
        { ferrExeEmpty,          IDS_ERROR_EXE_EMPTY    },
        { ferrGroup,             IDS_ERROR_GROUP        },
        { ferrResSave,           IDS_ERROR_RES_SAVE     },
        { ferrSaveOverOpen,      IDS_ERROR_SAVEOVEROPEN },
        { ferrSaveOverReadOnly,  IDS_ERROR_SAVERO       },
        { ferrCantDetermineType, IDS_ERROR_WHAAAT       }, // bad pcx file
        { ferrSameName,          IDS_ERROR_SAMENAME     },
        { ferrSaveAborted,       IDS_ERROR_SAVE_ABORTED },
        { ferrLooksLikeNtRes,    IDS_ERROR_NT_RES       },
        { ferrCantSaveReadOnly,  IDS_ERROR_CANT_SAVERO  }, // trying to save over a read only file
    };

int IdsFromFerr(int ferr)
    {
    if (ferr < ferrFirst)
        return IDS_ERROR_FILE + ferr; // was an exception cause

    for (int i = 0; i < sizeof (mpidsferr) / sizeof (FERRID); i++)
        {
        if (mpidsferr[i].ferr == ferr)
            return mpidsferr[i].ids;
        }

    ASSERT(FALSE); // You forgot to stick an entry in the above table!
    return 0;
    }

/***************************************************************************/
// Display a message box informing the user of a file related exception.
// The format of the box is something like:
//
//     <file name>
//     <operation failed>
//     <reason>
//
// <file name> describes what file has the problem, <operation files>
// indicated what kind of thing failed (e.g. "Cannot save file"), and
// <reason> provides more information about why the operation failed
// (e.g. "Disk full").
//
// All the parameters must have been setup previously via a call to
// CWinApp::SetFileError().
//
void CPBApp::FileErrorMessageBox( void )
    {
    static BOOL bInUse = FALSE;

    if (m_nFileErrorCause != CFileException::none && ! bInUse)
        {
        bInUse = TRUE;

        CString strOperation;
        VERIFY( strOperation.LoadString( m_uOperation ) );

        CString strReason;
        VERIFY( strReason.LoadString( IdsFromFerr( m_nFileErrorCause ) ) );

        CString strFmt;
        CString strMsg;

        if (m_sLastFile.IsEmpty())
            { 
            strFmt.LoadString(IDS_FORMATERR_NOFILE);
            strMsg.Format(strFmt, (LPCTSTR)strOperation, (LPCTSTR)strReason);
            }
        else
            {
            strFmt.LoadString(IDS_FORMATERR_FILE);
            strMsg.Format(strFmt, (LPCTSTR)m_sLastFile, (LPCTSTR)strOperation, (LPCTSTR)strReason);
            }
        AfxMessageBox( strMsg, MB_TASKMODAL | MB_OK | MB_ICONEXCLAMATION );

        bInUse = FALSE;
        }
    m_nFileErrorCause = CFileException::none;
    }

/***************************************************************************/

void CPBApp::SetFileError( UINT uOperation, int nCause, LPCTSTR lpszFile )
    {
    m_nFileErrorCause = nCause;
    m_uOperation      = uOperation;

    if (lpszFile)
        m_sLastFile = lpszFile;
    }

/***************************************************************************/
//  Memory/resource emergency handling functions

void CPBApp::SetMemoryEmergency(BOOL bFailed)
    {
    TRACE(TEXT("Memory emergency!\n"));

    m_wEmergencyFlags |= memoryEmergency | warnEmergency;

    if (bFailed)
        m_wEmergencyFlags |= failedEmergency;
    }

/***************************************************************************/

void CPBApp::SetGdiEmergency(BOOL bFailed)
    {
    TRACE(TEXT("GDI emergency!\n"));

    m_wEmergencyFlags |= gdiEmergency | warnEmergency;

    if (bFailed)
        m_wEmergencyFlags |= failedEmergency;
    }

/***************************************************************************/

void CPBApp::SetUserEmergency(BOOL bFailed)
    {
    TRACE(TEXT("USER emergency!\n"));

    m_wEmergencyFlags |= userEmergency | warnEmergency;

    if (bFailed)
        m_wEmergencyFlags |= failedEmergency;
    }

/***************************************************************************/

void CPBApp::WarnUserOfEmergency()
    {
    if ((m_wEmergencyFlags & warnEmergency) == 0)
        {
        // We have nothing to warn the user about!
        return;
        }

    if ((m_wEmergencyFlags & failedEmergency) == 0 &&
         GetTickCount() < m_tickLastWarning + ticksBetweenWarnings)
        {
        // We've warned the user recently, so keep quiet for now...
        // The warning flag is cleared so we don't just warn the
        // user after the delay is up unless another emergency
        // occurs AFTER then...

        m_wEmergencyFlags &= ~warnEmergency;
        return;
        }

    // Don't go invoking message boxes when we're not the active app!
    if (! m_bActiveApp)
        return;

    const TCHAR* szMsg = (m_wEmergencyFlags & failedEmergency) != 0 ?
        m_strEmergencyNoMem : m_strEmergencyLowMem;

    if (AfxMessageBox(szMsg, MB_TASKMODAL | MB_OK | MB_ICONSTOP) == IDOK)
        {
        m_wEmergencyFlags &= ~(warnEmergency | failedEmergency);
        m_tickLastWarning = GetTickCount();
        }
    #ifdef _DEBUG
    else
        TRACE(TEXT("Emergency warning message box failed!\n"));
    #endif

    // Update status bar warning message...
    if ( ::IsWindow( ((CPBFrame*)m_pMainWnd)->m_statBar.m_hWnd ) )
        ((CPBFrame*)m_pMainWnd)->m_statBar.Invalidate(FALSE);
    }

/***************************************************************************/

void CPBApp::TryToFreeMemory()
    {
    // We are in a memory/resource emergency state!  Add things to this
    // function to flush caches and do anything else to free up memory
    // we don't really need to be using right now...
    if (m_wEmergencyFlags & memoryEmergency)
        {
        CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

        if (pDoc && pDoc->m_pBitmapObj && ! pDoc->m_pBitmapObj->IsDirty()
                                       &&   pDoc->m_pBitmapObj->m_hThing)
            pDoc->m_pBitmapObj->Free();
        }

    if (m_wEmergencyFlags & gdiEmergency)
        {
//      theUndo.Flush();
        ResetSysBrushes();
        }
    }

/***************************************************************************/

// App command to run the dialog
void CPBApp::OnAppAbout()
    {
    CString sTitle;
    CString sBrag;
    HICON   hIcon = LoadIcon( ID_MAINFRAME );

    sTitle.LoadString( AFX_IDS_APP_TITLE );
    sBrag.LoadString( IDS_PerContractSoDontChange );

    ShellAbout( AfxGetMainWnd()->GetSafeHwnd(), sTitle, sBrag, hIcon );

    if (hIcon != NULL)
        ::DestroyIcon( hIcon );
    }

/***************************************************************************/

void CPBApp::SetDeviceHandles(HANDLE hDevNames, HANDLE hDevMode)
{
        // The old ones should already be freed
        m_hDevNames = hDevNames;
        m_hDevMode = hDevMode;
}

/***************************************************************************/

#if 0 

class CFileOpenSaveDlg : public CFileDialog
    {
    public:

    BOOL m_bOpenFile;

    CFileOpenSaveDlg( BOOL bOpenFileDialog );

    virtual void OnLBSelChangedNotify( UINT nIDBox, UINT iCurSel, UINT nCode );

    DECLARE_MESSAGE_MAP()
    };

/***************************************************************************/

BEGIN_MESSAGE_MAP(CFileOpenSaveDlg, CFileDialog)
END_MESSAGE_MAP()

/***************************************************************************/

CFileOpenSaveDlg::CFileOpenSaveDlg( BOOL bOpenFileDialog )
                           :CFileDialog( bOpenFileDialog )
    {
    m_bOpenFile = bOpenFileDialog;
    }

/***************************************************************************/

void CFileOpenSaveDlg::OnLBSelChangedNotify( UINT nIDBox, UINT iCurSel, UINT nCode )
    {
    if (! m_bOpenFile && iCurSel <= 5 && nIDBox == cmb1
                                      &&  nCode == CD_LBSELCHANGE)
        {
        // change in the file type
        CWnd* pText = GetDlgItem( edt1 );
        CWnd* pType = GetDlgItem( cmb1 );
        CString sFname;
        CString sDfltExt;

        switch (iCurSel)
            {
#ifdef PCX_SUPPORT
            case 4:
                sDfltExt.LoadString( IDS_EXTENSION_PCX );
                break;
#endif
            case 5:
                sDfltExt.LoadString( IDS_EXTENSION_ICO );
                break;

            default:
                sDfltExt.LoadString( IDS_EXTENSION_BMP );
                break;
            }
        pText->GetWindowText( sFname );

        if (sDfltExt.CompareNoCase( GetExtension( sFname ) ))
            {
            sFname = StripExtension( sFname ) + sDfltExt;
            pText->SetWindowText( sFname );
            }
        }
    }

#endif //0

/***************************************************************************/

extern BOOL AFXAPI AfxFullPath( LPTSTR lpszPathOut, LPCTSTR lpszFileIn );

CDocument*
CPBApp::OpenDocumentFile(
    LPCTSTR lpszFileName
    )
{
    CancelToolMode(FALSE);

    TCHAR szPath[_MAX_PATH];

    AfxFullPath( szPath, lpszFileName );

    return(m_pDocManager->OpenDocumentFile(szPath));

//    CDocTemplate* pTemplate = (CDocTemplate*)m_templateList.GetHead();
//
//    ASSERT( pTemplate->IsKindOf( RUNTIME_CLASS( CDocTemplate ) ) );
//
//    return pTemplate->OpenDocumentFile( szPath );
}

void CancelToolMode(BOOL bSelectionCommand)
{
        if (bSelectionCommand)
        {
                // Check if a selection tool is the current one
                if ((CImgTool::GetCurrentID() == IDMB_PICKTOOL)
                        || (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL))
                {
                        // Don't try canceling the mode, since the command works on a
                        // selection
                        return;
                }
        }

        // Just select the current tool again to reset everything
        CImgTool *pImgTool = CImgTool::GetCurrent();
        if (pImgTool)
        {
                pImgTool->Select();
        }
}

/***************************************************************************/
// CPBApp commands

void CPBApp::OnFileNew()
{
    CancelToolMode(FALSE);

    CWinApp::OnFileNew();
    }

void CPBApp::OnFileOpen()
    {
    CancelToolMode(FALSE);

    // prompt the user (with all document templates)
    CString newName;

    int iColor = 0;

    if (! DoPromptFileName( newName, AFX_IDS_OPENFILE,
                                     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST,
                                     TRUE, iColor, FALSE ))
        return; // open cancelled

#ifdef PCX_SUPPORT
    m_bPCXfile = (iColor == 4);
#endif

    CPBDoc* pDoc = (CPBDoc*)((CFrameWnd*)AfxGetMainWnd())->GetActiveDocument();

    // prompt to save the current document if it was modified
    if (pDoc && pDoc->SaveModified()) 
    {
        pDoc->SetModifiedFlag(FALSE);

        if (OpenDocumentFile( newName )==NULL)
        {
           // attempt to open a file failed, so make sure any new doc just
           // created in the process gets destroyed
           POSITION tPos = GetFirstDocTemplatePosition();
           CDocTemplate* pTemplate = GetNextDocTemplate(tPos);
           POSITION dPos = pTemplate->GetFirstDocPosition ();
           CPBDoc *pDoc= (CPBDoc *)(pTemplate->GetNextDoc(dPos));

           if (pDoc->m_pBitmapObjNew)
           {
              delete pDoc->m_pBitmapObjNew;
              pDoc->m_pBitmapObjNew =NULL;
           }
           OnFileNew(); // then start anew...
        }
    }
}

/****************************************************************************/
// prompt for file name - used for open and save as

BOOL CPBApp::DoPromptFileName( CString& fileName, UINT nIDSTitle, DWORD lFlags,
                               BOOL bOpenFileDialog, int& iColors, BOOL bOnlyBmp )
    {
    COpenFileName dlgFile( bOpenFileDialog );

    ASSERT(dlgFile.m_pofn);

    if (!dlgFile.m_pofn)
        return FALSE;

    CString title;

    VERIFY( title.LoadString( nIDSTitle ) );

    lFlags |= OFN_EXPLORER;

    if (!bOpenFileDialog)
        lFlags |= OFN_OVERWRITEPROMPT;

    dlgFile.m_pofn->Flags |= lFlags;
    dlgFile.m_pofn->Flags &= ~OFN_SHOWHELP;

    CString strFilter;
//    CString strDefault;

    CDocTemplate* pTemplate = NULL;
    POSITION pos = m_pDocManager->GetFirstDocTemplatePosition();

    if (pos != NULL)
        pTemplate = m_pDocManager->GetNextDocTemplate(pos);

    CString strFilterExt;
    CString strFilterName;
    CString strAllPictureFiles;

    ASSERT(pTemplate != NULL);

    pTemplate->GetDocString( strFilterExt , CDocTemplate::filterExt  );
    pTemplate->GetDocString( strFilterName, CDocTemplate::filterName );

    ASSERT( strFilterExt[0] == TEXT('.') );

    // set the default extension
//    strDefault = ((const TCHAR*)strFilterExt) + 1;  // skip the '.'
//    dlgFile.m_pofn->nFilterIndex = iColors + 1; // 1 based number
    dlgFile.m_pofn->lpstrDefExt = ((LPCTSTR)strFilterExt) + 1; // skip the '.'

    if (bOpenFileDialog)
    {
        // add to filter
        strFilter = strFilterName;
        strFilter += _T('\0');       // next string please
        strFilter += _T("*") + strFilterExt;
        VERIFY(strFilterExt.LoadString(IDS_EXTENSION_DIB));
        strFilter += _T(";*") + strFilterExt;
        strAllPictureFiles += _T(";*") + strFilterExt;
        VERIFY(strFilterExt.LoadString(IDS_EXTENSION_BMP));
        strAllPictureFiles += _T(";*") + strFilterExt;
        VERIFY(strFilterExt.LoadString(IDS_EXTENSION_RLE));
        strFilter += _T(";*") + strFilterExt;
        strFilter += _T('\0');       // next string please

        dlgFile.m_pofn->nMaxCustFilter++;
    }
    else
    {
        for (int i = IDS_BMP_MONO; i <= IDS_BMP_TRUECOLOR; i++)
        {
            strFilterName.LoadString( i );

            // add to filter
            strFilter += strFilterName;

            strFilter += _T('\0');       // next string please
            strFilter += _T("*") + strFilterExt;
            strFilter += _T('\0');       // next string please

            dlgFile.m_pofn->nMaxCustFilter++;
        }
    }

    // get a list of GDI+ codecs (if available)

    Gdiplus::ImageCodecInfo *pCodecs = 0;
    UINT                     nCodecs = 0;

    if (bOpenFileDialog)
    {
        GetGdiplusDecoders(&nCodecs, &pCodecs);
    }
    else
    {
        GetGdiplusEncoders(&nCodecs, &pCodecs);
    }

    if (nCodecs && !bOnlyBmp)
    {
        delete [] m_guidFltType;
        m_guidFltType = new GUID[nCodecs];
        
        m_nFilters = 0;

        for (UINT i = 0; i < nCodecs; ++i)
        {
            if (pCodecs[i].FormatID != WiaImgFmt_BMP &&
                pCodecs[i].FormatID != WiaImgFmt_EMF &&
                pCodecs[i].FormatID != WiaImgFmt_WMF)  // GDI+ does not handle WMF/EMF well
            {
                m_guidFltType[m_nFilters++] = pCodecs[i].FormatID;

                strFilter += pCodecs[i].FormatDescription;
                strFilter += _T(" (");
                strFilter += pCodecs[i].FilenameExtension;
                strFilter += _T(')');
                strFilter += _T('\0');       // next string please
                strFilter += pCodecs[i].FilenameExtension;
                strFilter += _T('\0');       // next string please

                strAllPictureFiles += _T(';');
                strAllPictureFiles += pCodecs[i].FilenameExtension;

                dlgFile.m_pofn->nMaxCustFilter++;
            }
        }

        LocalFree(pCodecs);
    }
    else
    {
        //
        // get list of all installed filters and add those to the list...
        //

        delete [] m_guidFltType;
        m_guidFltType = new GUID[16]; // max # of filters

        TCHAR name[128];
        TCHAR ext[sizeof("jpg;*.jpeg") + 1];
        BOOL bImageAPI;

        for (int i=0, j=0; !bOnlyBmp && GetInstalledFilters(bOpenFileDialog,
            i, name, sizeof(name), ext, sizeof(ext), NULL, 0, bImageAPI); i++)
        {
            if (!bImageAPI)
            {
               continue;
            }
            if (ext[0] == 0 || name[0] == 0)
                continue;

            // if there are multiple extensions, take the first one...
            PTSTR pComma = _tcschr(ext, _T(','));
            
            if (pComma)
                *pComma = 0;

            PTSTR pSemiColon = _tcschr(ext, _T(';'));
            
            if (pSemiColon)
                *pSemiColon = 0;

            PTSTR pSpace = _tcschr(ext, _T(' '));
            
            if (pSpace)
                *pSpace = 0;

            if (lstrlen(ext) > 3)
                continue;

            // dont show these, we already handle these
            if (lstrcmpi(ext,_T("bmp")) == 0 ||
                lstrcmpi(ext,_T("dib")) == 0 ||
                lstrcmpi(ext,_T("rle")) == 0)
                continue;
            #ifndef GIF_SUPPORT
            if (lstrcmpi(ext, _T("gif") == 0)
            {
               continue;
            }

            #endif
#if 0 // only use known good filters
            if (!g_bShowAllFiles &&
                (GetKeyState(VK_SHIFT) & 0x8000) == 0 &&
                lstrcmpi(ext,_T("pcx")) != 0)
                continue;
#endif
            // save a list of available filter types
            if (lstrcmpi(ext,_T("gif")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_GIF;
            }
            else if (lstrcmpi(ext,_T("jpg")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_JPEG;
               _tcscat (ext, _T(";*.jpeg"));
            }
#ifdef SUPPORT_ALL_FILTERS
            else if (lstrcmpi(ext,_T("png")) == 0)
            {
#ifdef PNG_SUPPORT
               m_guidFltType[j++] = WiaImgFmt_PNG;
#else
               continue;
#endif // PNG_SUPPORT
            }

            else if (lstrcmpi(ext,_T("pcd")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_PHOTOCD;
            }
            /*else if (lstrcmpi(ext,_T("pic")) == 0)
            {
               m_guidFltType[j++] = IFLT_PICT;
               _tcscat(ext, _T(";*.pict"));
            }
            else if (lstrcmpi(ext,_T("tga")) == 0)
            {
               m_iflFltType[j++] = IFLT_TGA;
            }*/
            else if (lstrcmpi(ext,_T("tif")) == 0)
            {
               m_guidFltType[j++] = WiaImgFmt_TIFF;
               _tcscat(ext, _T(";*.tiff"));
            }
            else
            {
               m_guidFltType[j++] = WiaImgFmt_UNDEFINED;
            }
#else
            else continue;
#endif


            // add to filter
            strFilter += name;
            strFilter += _T(" ( *.");
            strFilter += ext;
            strFilter += _T(" )");
            strFilter += _T('\0');       // next string please
            strFilter += _T("*.");
            strFilter += ext;
            strFilter += _T('\0');       // next string please

            strAllPictureFiles = strAllPictureFiles + _T(";*.")+ext;
            dlgFile.m_pofn->nMaxCustFilter++;
        }
    }

    if (!bOnlyBmp && bOpenFileDialog)
    {
        // append "All Picture Files" only if opening a file
        VERIFY(strFilterName.LoadString(IDS_TYPE_ALLPICTURES));
        strFilter+= strFilterName;
        strFilter += _T('\0');
        strFilter += strAllPictureFiles;
        strFilter += _T('\0');
        dlgFile.m_pofn->nMaxCustFilter++;

        if (m_nFilterInIdx == -1)
        {
            m_nFilterInIdx = dlgFile.m_pofn->nMaxCustFilter;
        }

       // append the  "*.*" filter only if "Open"ing a file
        VERIFY( strFilterName.LoadString( IDS_TYPE_ALLFILES ) );

        strFilter += strFilterName;
        strFilter += _T('\0');        // next string please
        strFilter += _T("*.*");
        strFilter += _T('\0');        // last string

        dlgFile.m_pofn->nMaxCustFilter++;

    }

    // prompt the user with the appropriate filter pre-selected
    if (bOpenFileDialog)
    {
       dlgFile.m_pofn->nFilterIndex = m_nFilterInIdx;
    }
    else
    {
       DWORD dwIndex;
       if (m_guidFltTypeUsed != WiaImgFmt_UNDEFINED &&
                        (dwIndex = GetFilterIndex(m_guidFltTypeUsed))) // has an export filter?
            dlgFile.m_pofn->nFilterIndex = dwIndex + 4; // skip the first 4 BMP types
        else if (m_nFilterOutIdx >= 4)
            dlgFile.m_pofn->nFilterIndex = m_nFilterOutIdx;
        else
            dlgFile.m_pofn->nFilterIndex = iColors + 1; // 1 based number

    }
    dlgFile.m_pofn->lpstrFilter = strFilter;
    dlgFile.m_pofn->hwndOwner   = AfxGetMainWnd()->GetSafeHwnd();
    dlgFile.m_pofn->hInstance   = AfxGetResourceHandle();
    dlgFile.m_pofn->lpstrTitle  = title;
    dlgFile.m_pofn->lpstrFile   = fileName.GetBuffer(_MAX_PATH);
    dlgFile.m_pofn->nMaxFile    = _MAX_PATH;

    TCHAR szInitialDir[_MAX_PATH] = _T("");

    if (!theApp.GetLastFile() || !*(theApp.GetLastFile()))
    {
        // Try to set the initial directory to "My Pictures"

        HRESULT hr = SHGetFolderPath(
            NULL,
            CSIDL_MYPICTURES,
            NULL,
            SHGFP_TYPE_CURRENT,
            szInitialDir
        );

        if (hr != S_OK)
        {
            // If "My Pictures" doesn't exist, try "My Documents"

            hr = SHGetFolderPath(
                NULL,
                CSIDL_PERSONAL,
                NULL,
                SHGFP_TYPE_CURRENT,
                szInitialDir
            );
        }

        if (hr == S_OK)
        {
            dlgFile.m_pofn->lpstrInitialDir = szInitialDir;
        }
    }

    BOOL bRet = dlgFile.DoModal() == IDOK? TRUE : FALSE;
    fileName.ReleaseBuffer();

    // keep track of the filter selected by the user
    if (bOpenFileDialog)
        m_nFilterInIdx = dlgFile.m_pofn->nFilterIndex;
    else
        m_nFilterOutIdx = dlgFile.m_pofn->nFilterIndex;

    iColors = (int)dlgFile.m_pofn->nFilterIndex - 1;

    CString sExt = dlgFile.m_pofn->lpstrFile + dlgFile.m_pofn->nFileExtension;

#ifdef ICO_SUPPORT
    if (! bOpenFileDialog && dlgFile.m_pofn->nFileExtension)
        // did the user try to sneak a icon extension past us
        if (! sExt.CompareNoCase( ((const TCHAR *)strFilterExt) + 1 ))
            iColors = 5;
#endif

    return bRet;
    }

DWORD CPBApp::GetFilterIndex( REFGUID guidFltType )
{
    for (int i = 0; i < m_nFilters; i++)
        if (m_guidFltType[i] == guidFltType)
                        return i+1;

        return 0;
}

// fix the file extension based on export filter selected - used for save as

void CPBApp::FixExtension( CString& fileName, int iflFltType )
{
        CString sDfltExt;

        switch (iflFltType)
        {
                case IFLT_GIF:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_GIF ));
                        break;

                case IFLT_JPEG:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_JPEG ));
                        break;

                case IFLT_PCD:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PCD ));
                        break;


                case IFLT_PCX:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PCX ));
                        break;


                case IFLT_PICT:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PICT ));
                        break;
#ifdef PNG_SUPPORT
                case IFLT_PNG:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_PNG ));
                        break;
#endif // PNG_SUPPORT
                case IFLT_TGA:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_TGA ));
                        break;

                case IFLT_TIFF:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_TIFF ));
                        break;

                case IFLT_UNKNOWN:      // unknown or unsupported file type
                default:
                        VERIFY(sDfltExt.LoadString( IDS_EXTENSION_BMP ));
                        break;
        }

        if (sDfltExt.CompareNoCase( GetExtension( (LPCTSTR)fileName ) ))
        {
                fileName = StripExtension( fileName ) + sDfltExt;
        }
}

#if 0
// Pulling self-registration out. This is to be done once during setup only

/***************************************************************************/

// Mostly stolen from MFC
// I made no attempt to strip out stuff I do not actually use
// I just modified this so it used short module file name
//

//////////////////////////////////////////////////////////////////////////////
// data for UpdateRegistry functionality

// %1 - class ID
// %2 - class name
// %3 - executable path
// %4 - short type name
// %5 - long type name
// %6 - long application name
// %7 - icon index

static const TCHAR sz00[] = TEXT("%2\0") TEXT("%5");
static const TCHAR sz01[] = TEXT("%2\\CLSID\0") TEXT("%1");
static const TCHAR sz02[] = TEXT("%2\\Insertable\0") TEXT("");
static const TCHAR sz03[] = TEXT("%2\\protocol\\StdFileEditing\\verb\\0\0") TEXT("&Edit");
static const TCHAR sz04[] = TEXT("%2\\protocol\\StdFileEditing\\server\0") TEXT("%3");
static const TCHAR sz05[] = TEXT("CLSID\\%1\0") TEXT("%5");
static const TCHAR sz06[] = TEXT("CLSID\\%1\\ProgID\0") TEXT("%2");
#ifndef _USRDLL
static const TCHAR sz07[] = TEXT("CLSID\\%1\\InprocHandler32\0") TEXT("ole32.dll");
static const TCHAR sz08[] = TEXT("CLSID\\%1\\LocalServer32\0") TEXT("%3");
#else
static const TCHAR sz07[] = TEXT("\0") TEXT("");
static const TCHAR sz08[] = TEXT("CLSID\\%1\\InProcServer32\0") TEXT("%3");
#endif
static const TCHAR sz09[] = TEXT("CLSID\\%1\\Verb\\0\0") TEXT("&Edit,0,2");
static const TCHAR sz10[] = TEXT("CLSID\\%1\\Verb\\1\0") TEXT("&Open,0,2");
static const TCHAR sz11[] = TEXT("CLSID\\%1\\Insertable\0") TEXT("");
static const TCHAR sz12[] = TEXT("CLSID\\%1\\AuxUserType\\2\0") TEXT("%4");
static const TCHAR sz13[] = TEXT("CLSID\\%1\\AuxUserType\\3\0") TEXT("%6");
static const TCHAR sz14[] = TEXT("CLSID\\%1\\DefaultIcon\0") TEXT("%3,%7");
static const TCHAR sz15[] = TEXT("CLSID\\%1\\MiscStatus\0") TEXT("32");

// registration for OAT_INPLACE_SERVER
static const LPCTSTR rglpszInPlaceRegister[] =
{
        sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz12,
        sz13, sz15, NULL
};

// registration for OAT_SERVER
static const LPCTSTR rglpszServerRegister[] =
{
        sz00, sz02, sz03, sz05, sz09, sz11, sz12,
        sz13, sz15, NULL
};
// overwrite entries for OAT_SERVER & OAT_INPLACE_SERVER
static const LPCTSTR rglpszServerOverwrite[] =
{
        sz01, sz04, sz06, sz07, sz08, sz14, NULL
};

// registration for OAT_CONTAINER
static const LPCTSTR rglpszContainerRegister[] =
{
        sz00, sz05, NULL
};
// overwrite entries for OAT_CONTAINER
static const LPCTSTR rglpszContainerOverwrite[] =
{
        sz01, sz06, sz07, sz08, sz14, NULL
};

// registration for OAT_DISPATCH_OBJECT
static const LPCTSTR rglpszDispatchRegister[] =
{
        sz00, sz05, NULL
};
// overwrite entries for OAT_CONTAINER
static const LPCTSTR rglpszDispatchOverwrite[] =
{
        sz01, sz06, sz08, NULL
};

struct STANDARD_ENTRY
{
        const LPCTSTR* rglpszRegister;
        const LPCTSTR* rglpszOverwrite;
};

static const STANDARD_ENTRY rgStdEntries[] =
{
        { rglpszInPlaceRegister, rglpszServerOverwrite },
        { rglpszServerRegister, rglpszServerOverwrite },
        { rglpszContainerRegister, rglpszContainerOverwrite },
        { rglpszDispatchRegister, rglpszDispatchOverwrite }
};

/////////////////////////////////////////////////////////////////////////////
// Special registration for apps that wish not to use REGLOAD

BOOL AFXAPI PBOleRegisterServerClass(
        REFCLSID clsid, LPCTSTR lpszClassName,
        LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
        OLE_APPTYPE nAppType, LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite)
{
        ASSERT(AfxIsValidString(lpszClassName));
        ASSERT(AfxIsValidString(lpszShortTypeName));
        ASSERT(*lpszShortTypeName != 0);
        ASSERT(AfxIsValidString(lpszLongTypeName));
        ASSERT(*lpszLongTypeName != 0);
        ASSERT(nAppType == OAT_INPLACE_SERVER || nAppType == OAT_SERVER ||
                nAppType == OAT_CONTAINER || nAppType == OAT_DISPATCH_OBJECT);

        // use standard registration entries if non given
        if (rglpszRegister == NULL)
                rglpszRegister = (LPCTSTR*)rgStdEntries[nAppType].rglpszRegister;
        if (rglpszOverwrite == NULL)
                rglpszOverwrite = (LPCTSTR*)rgStdEntries[nAppType].rglpszOverwrite;

        LPTSTR rglpszSymbols[7];
                // 0 - class ID
                // 1 - class name
                // 2 - executable path
                // 3 - short type name
                // 4 - long type name
                // 5 - long application name
                // 6 - icon index

        // convert the CLSID to a string
        LPWSTR lpszClassID;
        ::StringFromCLSID(clsid, &lpszClassID);
        if (lpszClassID == NULL)
        {
                TRACE0("Warning: StringFromCLSID failed in AfxOleRegisterServerName --\n");
                TRACE0("\tperhaps AfxOleInit() has not been called.\n");
                return FALSE;
        }
        #ifdef UNICODE
        rglpszSymbols[0] = lpszClassID;
        #else
        int cc = WideCharToMultiByte (CP_ACP, 0, lpszClassID, -1,
                                      (LPSTR)&rglpszSymbols[0], 0,
                                      NULL, NULL);
        rglpszSymbols[0] = (LPSTR)new char[cc];
        WideCharToMultiByte (CP_ACP, 0, lpszClassID, -1,
                             rglpszSymbols[0], cc,
                             NULL, NULL);

        #endif // UNICODE
        rglpszSymbols[1] = (LPTSTR)lpszClassName;

        // get path name to server
        TCHAR szPathName[_MAX_PATH];
        LPTSTR pszTemp = szPathName;
        ::GetShortModuleFileName(AfxGetInstanceHandle(), pszTemp, _MAX_PATH);
        rglpszSymbols[2] = szPathName;

        // fill in rest of symbols
        rglpszSymbols[3] = (LPTSTR)lpszShortTypeName;
        rglpszSymbols[4] = (LPTSTR)lpszLongTypeName;
        rglpszSymbols[5] = (LPTSTR)AfxGetAppName(); // will usually be long, readable name

        LPCTSTR lpszIconIndex;
        HICON hIcon = ExtractIcon(AfxGetInstanceHandle(), szPathName, 1);
        if (hIcon != NULL)
        {
                lpszIconIndex = TEXT("1");
                DestroyIcon(hIcon);
        }
        else
        {
                lpszIconIndex = TEXT("0");
        }
        rglpszSymbols[6] = (LPTSTR)lpszIconIndex;

        // update the registry with helper function
        BOOL bResult;
        bResult = AfxOleRegisterHelper(rglpszRegister, (LPCTSTR*)rglpszSymbols, 7, FALSE);
        if (bResult && rglpszOverwrite != NULL)
                bResult = AfxOleRegisterHelper(rglpszOverwrite, (LPCTSTR*)rglpszSymbols, 7, TRUE);

        // free memory for class ID
        ASSERT(lpszClassID != NULL);
        AfxFreeTaskMem(lpszClassID);
        #ifndef UNICODE
        delete[](LPSTR)rglpszSymbols[0];
        #endif
        return bResult;
}

void CPBTemplateServer::UpdateRegistry(OLE_APPTYPE nAppType,
        LPCTSTR* rglpszRegister, LPCTSTR* rglpszOverwrite)
{
        ASSERT(m_pDocTemplate != NULL);

        // get registration info from doc template string
        CString strServerName;
        CString strLocalServerName;
        CString strLocalShortName;

        if (!m_pDocTemplate->GetDocString(strServerName,
           CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
        {
                TRACE0("Error: not enough information in DocTemplate to register OLE server.\n");
                return;
        }
        if (!m_pDocTemplate->GetDocString(strLocalServerName,
           CDocTemplate::regFileTypeName))
                strLocalServerName = strServerName;     // use non-localized name
        if (!m_pDocTemplate->GetDocString(strLocalShortName,
                CDocTemplate::fileNewName))
                strLocalShortName = strLocalServerName; // use long name

        ASSERT(strServerName.Find(TEXT(' ')) == -1);  // no spaces allowed

        // place entries in system registry
        if (!PBOleRegisterServerClass(m_clsid, strServerName, strLocalShortName,
                strLocalServerName, nAppType, rglpszRegister, rglpszOverwrite))
        {
                // not fatal (don't fail just warn)
                TRACE0("mspaint: Unable to register server class.\n");
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrusdoc.cpp ===
// pbrusdoc.cpp : implementation of the CPBDoc class
//

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "srvritem.h"
#include "bmobject.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgdlgs.h"
#include "tedit.h"
#include "t_text.h"
#include "undo.h"
#include "cmpmsg.h"
#include "ferr.h"
#include "loadimag.h"
#include "saveimag.h"
#include "colorsrc.h"
#include "props.h"
#include <shlobj.h>


#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CPBDoc, COleServerDoc)

#include "memtrace.h"


/***************************************************************************/
// CPBDoc

BEGIN_MESSAGE_MAP(CPBDoc, COleServerDoc)
    //{{AFX_MSG_MAP(CPBDoc)
        ON_COMMAND(ID_FILE_SAVE_COPY_AS, OnFileSaveCopyAs)
        ON_COMMAND(ID_FILE_SEND, OnFileSendMail)
        ON_COMMAND(ID_FILE_UPDATE, MyOnFileUpdate)
        ON_UPDATE_COMMAND_UI(ID_FILE_SEND, OnUpdateFileSendMail)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CPBDoc, COleServerDoc)
    INTERFACE_PART(CPBDoc, IID_IPersistStorage, PBPersistStg)
END_INTERFACE_MAP()

/***************************************************************************/
// CPBDoc construction/destruction

CPBDoc::CPBDoc()
    {
    m_bObjectLoaded = FALSE;
    m_pBitmapObj    = NULL;
    m_pBitmapObjNew = NULL;
    m_bNewDoc       = TRUE;
    m_bPaintFormat  = FALSE;
    m_bNonBitmapFile= FALSE;
    m_bSaveViaFilter= FALSE;
    m_bManualTruncate= FALSE;
    m_bHasSeenAFileError= FALSE;
    }

/***************************************************************************/

CPBDoc::~CPBDoc()
    {
    if (m_pBitmapObj)
        delete m_pBitmapObj;
    }

/***************************************************************************/
//
// SetDibHandle replaces the current image with the DIB
// indicated by hdib
//
void CPBDoc::SetDibHandle (HGLOBAL hDib)
{
     CWaitCursor DisplayWaitCursor;

     if (m_pBitmapObj->ReadResource (hDib)) 
     {
         m_pBitmapObj->ReLoadImage (this);

         LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) GlobalLock(hDib);

         if (lpbi)
         {
             if (lpbi->biBitCount == 1)
             {
                 m_pBitmapObj->SetIntProp (P_Colors, 1);
             }

             GlobalUnlock(hDib);
         }
    
         m_pBitmapObj->SetDirty( TRUE );
         SetModifiedFlag( TRUE );

         if (theApp.m_bEmbedded)
            NotifyChanged();
     }
}

BOOL CPBDoc::OnNewDocument()
    {
    if (! Finish())
        return FALSE;

    m_bObjectLoaded = FALSE;
    m_bNewDoc       = TRUE;
    m_bNonBitmapFile= FALSE;
    m_bSaveViaFilter= FALSE;
    m_sName.Empty();
    g_bUseTrans = FALSE;
    crTrans = TRANS_COLOR_NONE;
    theApp.m_sCurFile.Empty();

    if (! CreateNewDocument()
    ||  ! COleServerDoc::OnNewDocument())
        {
        if (m_pBitmapObjNew)
            {
            delete m_pBitmapObjNew;
            m_pBitmapObjNew = 0;
            }
        return FALSE;
        }
    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::OnOpenDocument( const TCHAR* pszPathName )
    {
    m_bObjectLoaded = FALSE;
    m_bNonBitmapFile= FALSE;
    m_bSaveViaFilter= FALSE;
    g_bUseTrans = FALSE;
    crTrans = TRANS_COLOR_NONE;
    theApp.m_sCurFile = pszPathName;


    if (pszPathName != NULL)
        {
        if (theApp.m_bEmbedded)
            theApp.m_bLinked = TRUE;

        m_bNewDoc = FALSE;
        m_sName   = pszPathName;

#ifdef PCX_SUPPORT
        if (! theApp.m_bPCXfile)
            {
            CString cStrExt = GetExtension( pszPathName );
            CString cStrPCXExt;

            cStrPCXExt.LoadString( IDS_EXTENSION_PCX );

            // is it a PCX extension?
            theApp.m_bPCXfile = ! cStrExt.CompareNoCase( cStrPCXExt );
            }
#endif

        // preset the file name in case of errors.
        theApp.SetFileError( IDS_ERROR_OPEN, CFileException::none, pszPathName );
        }
    else
        {
        m_bNewDoc = TRUE; /* not really but we don't have a name */
        m_sName.Empty();
        }

    #ifdef _DEBUG
    if (theApp.m_bEmbedded)
        TRACE( TEXT("MSPaint Open %s Document.\n"), (theApp.m_bLinked? TEXT("Linked"): TEXT("Embedded")) );
    #endif

    if (! CreateNewDocument())
        return FALSE;

    return COleServerDoc::OnOpenDocument( pszPathName );
    }

/***************************************************************************/

BOOL CPBDoc::OnSaveDocument( const TCHAR* pszPathName )
    {
    ASSERT( m_pBitmapObj != NULL );

    if (! Finish() || ! COleServerDoc::OnSaveDocument( pszPathName ))
        return FALSE;

    // Set the name if the thing doesn't have a name yet...
    if (m_pBitmapObj->m_bTempName && pszPathName != NULL)
        {
        m_pBitmapObj->m_bTempName   = FALSE;
        }

    m_pBitmapObj->SetDirty( FALSE );
    theApp.m_sCurFile = pszPathName;
    return TRUE;
    }

/***************************************************************************/

CFile* CPBDoc::GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
	CFileException* pError)
{
    // While saving a file, MFC opens the file with CREATE_ALWAYS flag.
    // But this wipes out the file summary info that the user has spent so much time editing (!)
    // We don't want that, so we will open the file with the OPEN_ALWAYS flag,
    // which does not disturb the summary info. But if the new file is shorter
    // than the old file, we need to manually truncate the file. So when we are 
    // done, we will SetEndOfFile() in CPBDoc::ReleaseFile()

    // modeCreate maps to CREATE_ALWAYS
    // modeCreate + modeNoTruncate maps to OPEN_ALWAYS
    // So if MFC calls us with modeCreate only, we will also set modeNoTruncate

    m_bManualTruncate = 
         (nOpenFlags & CFile::modeCreate) &&
        !(nOpenFlags & CFile::modeNoTruncate);

    if (m_bManualTruncate)
        nOpenFlags |= CFile::modeNoTruncate;

    // If we modify a file, the shell somehow cannot detect this and cannot
    // update the thumbnails view. So we will be nice and notify the shell

    if (nOpenFlags & (CFile::modeWrite | CFile::modeReadWrite))
    {
        // we should notify the shell if we are changing (writing to) a file

        // determine the type of notification

        WIN32_FIND_DATA fd;

        HANDLE hFind = FindFirstFile(lpszFileName, &fd);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            // If the file previously exists, this means we will be updating it

            m_wChangeNotifyEventId = SHCNE_UPDATEITEM;

            FindClose(hFind);
        }
        else
        {
            // otherwise we will be creating a new file

            m_wChangeNotifyEventId = SHCNE_CREATE;
        }
    }
    else
    {
        // if we are only reading the file, no need for a notification

        m_wChangeNotifyEventId = 0;
    }

    // Copy MFC's implementation of CDocument::GetFile()
    // With one exception, do not use the CMirrorFile mess...

	CFile* pFile = new CFile;
	ASSERT(pFile != NULL);

	if (!pFile->Open(lpszFileName, nOpenFlags, pError))
	{
		delete pFile;
		pFile = NULL;
	}

	return pFile;
}

void CPBDoc::ReleaseFile(CFile* pFile, BOOL bAbort)
{
    // manually set the end of file if needed

    if (m_bManualTruncate) 
    {
        SetEndOfFile((HANDLE) pFile->m_hFile);
    }

    // cache the file name before the file object gets deleted

    CString strFileName = pFile->GetFilePath();

    // call the parent

    CDocument::ReleaseFile(pFile, bAbort);

    // notify the shell if needed

    if (m_wChangeNotifyEventId != 0)
    {
        SHChangeNotify(m_wChangeNotifyEventId, SHCNF_PATH, strFileName, 0);
    }
}

/***************************************************************************/

void CPBDoc::ReportSaveLoadException(LPCTSTR lpszPathName, CException* e,
    BOOL bSaving, UINT nIDPDefault)
{
    if(m_bHasSeenAFileError) {

        m_bHasSeenAFileError = FALSE;

    } else {
        // the app doesn't know about the error so let mfc complain
        COleServerDoc::ReportSaveLoadException(lpszPathName, e, bSaving,
            nIDPDefault);
    }
}

/***************************************************************************/

BOOL CPBDoc::CanCloseFrame( CFrameWnd* pFrame )
    {
    TRACE3("CanCloseFrame: %d %s %s\n",m_bNonBitmapFile, (LPCTSTR)GetTitle(), (LPCTSTR)GetPathName());

    if (! Finish() || ! COleServerDoc::CanCloseFrame( pFrame ))
        return FALSE;

    theUndo.Flush();

    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::SaveModified()
{
    TRACE2("SaveModified %d %s\n", IsModified(), (LPCTSTR)GetPathName());
    return COleServerDoc::SaveModified();
}

/***************************************************************************/

BOOL CPBDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
{
    CancelToolMode(FALSE);

    BOOL bCannotSaveInCurrentFormat = m_bNonBitmapFile && 
        !GetClsidOfEncoder(theApp.m_guidFltTypeUsed, NULL);

    int iColors = m_pBitmapObj->m_nColors;
    int iOldColors = iColors;

    CString newName = lpszPathName;
    if (bCannotSaveInCurrentFormat || newName.IsEmpty())
    {
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);

		newName = m_strPathName;
		if (bReplace && newName.IsEmpty())
		{
			newName = m_strTitle;
			// check for dubious filename
			int iBad = newName.FindOneOf(_T("#%;/\\"));
			if (iBad != -1)
				newName.ReleaseBuffer(iBad);

            // append the default suffix if there is one
            CString strExt;
			if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) &&
			  !strExt.IsEmpty())
			{
				ASSERT(strExt[0] == '.');
				newName += strExt;
			}
        }

        // If the filename is not null, 
        // drop the extension in prompt a la Internet Explorer, and let
        // the Save As dialog append one appropriately.
        if (GetName(newName) != _T(""))
        {
            newName = StripExtension(newName);
        }

		if (!theApp.DoPromptFileName(newName,
		  bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
		  OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, iColors, FALSE))
			return FALSE;       // don't even attempt to save

        // check if any color reduction will be performed, including the
        // case of saving any 24-bit image to 8 bit GIF.
        if (((iOldColors < 4 && iColors < iOldColors)||
            (iOldColors == 3 && iColors >=4 &&
            WiaImgFmt_GIF == theApp.m_guidFltType[iColors-4])) &&
            AfxMessageBox(IDS_WARNING_COLORSAVE, MB_YESNO|MB_ICONEXCLAMATION)==IDNO)
        {
            // abort immediately if the user didn't confirm the operation
            return FALSE;
        }

        if (iColors < 4 && iColors >= 0)
        {
           m_bNonBitmapFile = FALSE;
           m_bSaveViaFilter = FALSE;
           m_pBitmapObj->m_nSaveColors = iColors;
           theApp.m_guidFltTypeUsed = WiaImgFmt_UNDEFINED;
        }
        else
        {
           m_bNonBitmapFile = TRUE;
           m_bSaveViaFilter = TRUE;
           theApp.m_guidFltTypeUsed = theApp.m_guidFltType[iColors-4];
           //theApp.FixExtension (newName, theApp.m_guidFltTypeUsed);
        }
    }

    CWaitCursor wait;

#ifdef ICO_SUPPORT

    m_pBitmapObj->m_bSaveIcon = (iColors == 5);

    if (m_pBitmapObj->m_bSaveIcon)
    {
        m_pBitmapObj->Free();
        m_pBitmapObj->Export(newName);
        m_pBitmapObj->m_bSaveIcon = FALSE; // always reset after use
        m_pBitmapObj->Free();

        return TRUE;
    }

#endif

    BOOL bSavedDifferentFormat = (iColors != m_pBitmapObj->m_nColors);

    if (bSavedDifferentFormat)
        m_pBitmapObj->Free();

    if (!OnSaveDocument(newName))
    {
		if (lpszPathName == NULL)
		{
            // be sure to delete the file
            TRY
            {
                CFile::Remove( newName );
            }
            CATCH_ALL(e)
            {
                TRACE0( "Warning: failed to delete file after failed SaveAs\n" );
            }
            END_CATCH_ALL
		}
		return FALSE;
    }

    if (bSavedDifferentFormat)
    {
        m_pBitmapObj->ReLoadImage( this );
        //
        // We only want the first 16 color chips for 16 color images
        //
        g_pColors->ResetColors ((iColors==1)?16:256);
    }

    // reset the title and change the document name
    if (bReplace)
        SetPathName(newName);


    //
    // MFC sets the modified flag when user invokes OnFileSaveCopyAs.
    // Then if the user exits paint the storage in the container is never
    // updated because paint thinks it's already done it.
    // So after saving, set the dirty flag to true
    if (!lpszPathName && !bReplace)
    {
       SetModifiedFlag(TRUE);
    }

    return TRUE;
}

/***************************************************************************/
// CPBDoc server implementation

COleServerItem* CPBDoc::OnGetEmbeddedItem()
    {
    // OnGetEmbeddedItem is called by the framework to get the COleServerItem
    //  that is associated with the document.  It is only called when necessary.

    CPBSrvrItem* pItem = new CPBSrvrItem( this );

    ASSERT_VALID( pItem );

    return pItem;
    }

/***************************************************************************/

COleServerItem* CPBDoc::OnGetLinkedItem( LPCTSTR lpszItemName )
    {
    ASSERT_VALID( m_pBitmapObj );

    // look in current list first
    COleServerItem* pItem = COleServerDoc::OnGetLinkedItem( lpszItemName );

    if (pItem)
        return pItem;

    pItem = new CPBSrvrItem( this );

    ASSERT_VALID( pItem );

    // return new item that matches lpszItemName
    return pItem;
    }

/***************************************************************************/
// CPBDoc serialization

BOOL CPBDoc::SerializeBitmap(CArchive& ar, CBitmapObj* pBitmapCur,
        CBitmapObj* pBitmapNew, BOOL bOLEObject)
{
   BOOL success = FALSE;

   if (ar.IsStoring())
   {
      // Always write the PBrush OLE format
      CBitmapObj::PBResType rtType = !bOLEObject ? CBitmapObj::rtFile :
                       CBitmapObj::rtPBrushOLEObj;
      if (!m_bSaveViaFilter)
      {
         success = pBitmapCur->WriteResource( ar.GetFile(), rtType );
      }
      else if (!bOLEObject && theApp.m_guidFltTypeUsed != WiaImgFmt_UNDEFINED)
      {
         // in order for the filter export interface to work, here we
         // close the file first after saving its name, so that a filter
         // can open it later to do the export...
         CString str = ar.GetFile()->GetFilePath();
         ar.GetFile()->Close();
         success = SaveDIBToFile( str, theApp.m_guidFltTypeUsed, pBitmapCur );
         if (!success)
         {
            theApp.SetFileError (IDS_ERROR_SAVE, ferrSaveAborted);
         }
         // now reopen the file again as if nothing had really happened
         // (any mode option can be used since the file will be closed
         // immediately after return)
         CFileException fe;
         ar.GetFile()->Open(str, CFile::modeRead | CFile::shareExclusive, &fe);

      }


   }
   else
   {
      CBitmapObj::PBResType rtType = !bOLEObject ? CBitmapObj::rtFile :
                     m_bPaintFormat ? CBitmapObj::rtPaintOLEObj :
                     CBitmapObj::rtPBrushOLEObj;

      success = pBitmapNew->ReadResource( ar.GetFile(), rtType );

      //
      // if we cant open the file, lets try using a filter.
      //
      if (success)
      {
         m_bNonBitmapFile = FALSE;
         m_bSaveViaFilter = FALSE;
      }
      else if (!bOLEObject)
         {
            HGLOBAL hDib;

            if (hDib = LoadDIBFromFile(theApp.GetLastFile(), &theApp.m_guidFltTypeUsed))
            {
                success = pBitmapNew->ReadResource(hDib);

                if (success)
                {
                    // we loaded a non .bmp file
                    m_bNonBitmapFile = TRUE;
                    m_bSaveViaFilter = TRUE;
                    // set no error
                    theApp.SetFileError(0, CFileException::none);
                }
            }
            else
            {
               theApp.SetFileError(IDS_ERROR_READLOAD,
                                   ferrNotValidBmp);

            }

         }

    }


    return(success);
}

void CPBDoc::Serialize( CArchive& ar )
{
        m_bObjectLoaded = SerializeBitmap(ar, m_pBitmapObj, m_pBitmapObjNew, FALSE);

        if (!m_bObjectLoaded)  // much less than ideal but oh well
        {

                theApp.FileErrorMessageBox ();
                m_bHasSeenAFileError = TRUE;
                // let mfc know so it can tidy up internally...
                AfxThrowFileException(CFileException::invalidFile);

        }
}

void CPBDoc::OLESerialize( CArchive& ar )
{
        m_bObjectLoaded = SerializeBitmap(ar, m_pBitmapObj, m_pBitmapObjNew, TRUE);

        if (!m_bObjectLoaded)  // much less than ideal but oh well
        {
                // let mfc know so it can tidy up internally...
                AfxThrowFileException(CFileException::invalidFile);
        }
}


STDMETHODIMP CPBDoc::XPBPersistStg::QueryInterface(
        REFIID iid, LPVOID* ppvObj)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(ULONG) CPBDoc::XPBPersistStg::AddRef()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CPBDoc::XPBPersistStg::Release()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return pThis->ExternalRelease();
}

STDMETHODIMP CPBDoc::XPBPersistStg::GetClassID(LPCLSID pclsid)
{
        // Always return the CLSID for PBrush
        *pclsid = CLSID_PaintBrush;
        return(NOERROR);
}

STDMETHODIMP CPBDoc::XPBPersistStg::IsDirty()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.IsDirty());
}

STDMETHODIMP CPBDoc::XPBPersistStg::InitNew(LPSTORAGE pstg)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.InitNew(pstg));
}

STDMETHODIMP CPBDoc::XPBPersistStg::Load(LPSTORAGE pstg)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.Load(pstg));
}

STDMETHODIMP CPBDoc::XPBPersistStg::Save(LPSTORAGE pstg, BOOL bSameAsLoad)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.Save(pstg, bSameAsLoad));
}

STDMETHODIMP CPBDoc::XPBPersistStg::SaveCompleted(LPSTORAGE pstg)
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.SaveCompleted(pstg));
}

STDMETHODIMP CPBDoc::XPBPersistStg::HandsOffStorage()
{
        METHOD_PROLOGUE_EX(CPBDoc, PBPersistStg)
        return(pThis->m_xPersistStorage.HandsOffStorage());
}


#define NO_CPP_EXCEPTION(x) x
static const TCHAR szOle10Native[] = TEXT("\1Ole10Native");
static const TCHAR szOle10ItemName[] = TEXT("\1Ole10ItemName");

/////////////////////////////////////////////////////////////////////////////
// Helpers for saving to IStorage based files
//  (these are used in the 'docfile' implementation as well as for servers)

static const TCHAR szContents[] = TEXT("Contents");

void CPBDoc::SaveToStorage(CObject* pObject)
{
        ASSERT(m_lpRootStg != NULL);

        // create Contents stream
        COleStreamFile file;
        CFileException fe;
        if (!file.CreateStream(m_lpRootStg, szOle10Native,
                CFile::modeWrite|CFile::shareExclusive|CFile::modeCreate, &fe))
        {
                AfxThrowFileException(fe.m_cause, fe.m_lOsError);
        }

        // save to Contents stream
        CArchive saveArchive(&file, CArchive::store | CArchive::bNoFlushOnDelete);
        saveArchive.m_pDocument = this;
        saveArchive.m_bForceFlat = FALSE;

        TRY
        {
                // save the contents
                if (pObject != NULL)
                        pObject->Serialize(saveArchive);
                else
                        OLESerialize(saveArchive);
                saveArchive.Close();
                file.Close();

                if (pObject != NULL)
                {
                        if (file.CreateStream(m_lpRootStg, szOle10ItemName,
                                CFile::modeWrite|CFile::shareExclusive|CFile::modeCreate, &fe))
                        {
                                LPCTSTR szItemName;
                                DWORD dwLen;
                                CString strItemName = ((CPBSrvrItem*)pObject)->GetItemName();

                                if (strItemName.IsEmpty())
                                {
                                        szItemName = TEXT("");
                                        dwLen = 1;
                                }
                                else
                                {
                                        szItemName = strItemName;
                                        dwLen = lstrlen(szItemName) + 1;
                                }

                                file.Write( &dwLen, sizeof( dwLen ));
                                file.Write( &szItemName, dwLen);

                                file.Close();
                        }
                }

                SCODE sc;

                // Always write the CLSID for PBrush
                sc = WriteClassStg(m_lpRootStg, CLSID_PaintBrush);
                if (sc != NOERROR)
                        AfxThrowOleException(sc);

                sc = WriteFmtUserTypeStg(m_lpRootStg, (WORD)RegisterClipboardFormat(TEXT("PBrush")),
                    L"PBrush");
                if (sc != NOERROR)
                    AfxThrowOleException(sc);

                // commit the root storage
                sc = m_lpRootStg->Commit(STGC_ONLYIFCURRENT);
                if (sc != NOERROR)
                        AfxThrowOleException(sc);
        }
        CATCH_ALL(e)
        {
                file.Abort();   // will not throw an exception
                CommitItems(FALSE); // abort save in progress
                NO_CPP_EXCEPTION(saveArchive.Abort());
                THROW_LAST();
        }
        END_CATCH_ALL
}

void CPBDoc::LoadFromStorage()
{
        ASSERT(m_lpRootStg != NULL);

        // open Contents stream
        COleStreamFile file;
        CFileException fe;
        if (file.OpenStream(m_lpRootStg, szOle10Native,
                CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
                m_bPaintFormat = FALSE;
        }
        else if (file.OpenStream(m_lpRootStg, szContents,
                CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
                m_bPaintFormat = TRUE;
        }
        else
        {
                AfxThrowFileException(fe.m_cause, fe.m_lOsError);
        }


        // load it with CArchive (loads from Contents stream)
        CArchive loadArchive(&file, CArchive::load | CArchive::bNoFlushOnDelete);
        loadArchive.m_pDocument = this;
        loadArchive.m_bForceFlat = FALSE;

        TRY
        {
                OLESerialize(loadArchive);     // load main contents
                loadArchive.Close();
                file.Close();
        }
        CATCH_ALL(e)
        {
                file.Abort();   // will not throw an exception
                DeleteContents();   // removed failed contents
                NO_CPP_EXCEPTION(loadArchive.Abort());
                THROW_LAST();
        }
        END_CATCH_ALL
}

/***************************************************************************/
// CPBDoc diagnostics

#ifdef _DEBUG
void CPBDoc::AssertValid() const
    {
    COleServerDoc::AssertValid();
    }

void CPBDoc::Dump(CDumpContext& dc) const
    {
    COleServerDoc::Dump(dc);
    }
#endif //_DEBUG

/***************************************************************************/
// CPBDoc commands

BOOL CPBDoc::CreateNewDocument()
    {
    CBitmapObj* pBitmapObj = NULL;
    //
    // If we have a window already, reset the color squares.
    // every doc starts with a white background
    //


    pBitmapObj = new CBitmapObj;
    pBitmapObj->MakeEmpty();
    if (AfxGetMainWnd())
    {
       g_pColors->ResetColors(256);
    }
    if (! pBitmapObj)
        return FALSE;

    m_pBitmapObjNew = pBitmapObj;

    pBitmapObj->m_bTempName = m_bNewDoc;
    pBitmapObj->m_bDirty    = FALSE;

    theUndo.Flush();

    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::Finish()
    {
    CImgTool* pImgTool = CImgTool::GetCurrent();

    if (pImgTool != NULL && CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
        POSITION pos = GetFirstViewPosition();

        ((CTextTool*)pImgTool)->CloseTextTool( ((CPBView*)GetNextView( pos ))->m_pImgWnd );
        }

    CommitSelection( FALSE );

    if (m_pBitmapObj == NULL)
        return TRUE;

    if (! m_pBitmapObj->SaveResource( TRUE ))
        return FALSE;

    if (m_pBitmapObj->IsDirty())
        {
        SetModifiedFlag();

        if (theApp.m_bEmbedded)
                NotifyChanged();
        }
    return TRUE;
    }

/***************************************************************************/

BOOL CPBDoc::SaveTheDocument()
    {
    if (IsModified() || m_bNonBitmapFile)
        OnFileSave();
    return TRUE;
    }

/***************************************************************************/

void CPBDoc::OnShowControlBars(CFrameWnd *pFrame, BOOL bShow)
{
        POSITION pos = GetFirstViewPosition();
        CPBView* pView = (CPBView*)(GetNextView( pos ));

        if ( bShow )
        {
                pView->SetTools();
                if ( pView->m_pImgWnd &&
                         pView->m_pImgWnd->GetZoom() > 1 )
                        pView->ShowThumbNailView();
        }
        else
        {
                pView->HideThumbNailView();
        }

        // FEATURE: What I should do is add an OnShowControlBars member to
        // CImgTool, but that's too big a change for right now
        if (CImgTool::GetCurrentID() == IDMX_TEXTTOOL)
        {
                CTextTool* pTextTool = (CTextTool*)CImgTool::GetCurrent();
                pTextTool->OnShowControlBars(bShow);
        }

        COleServerDoc::OnShowControlBars(pFrame,bShow);
}

class CCB : public CControlBar
{
public:
        void ForceDelayed(void);
};

void CCB::ForceDelayed(void)
{
        if (!this)
        {
                return;
        }

        BOOL bVis = GetStyle() & WS_VISIBLE;
        UINT swpFlags = 0;
        if ((m_nStateFlags & delayHide) && bVis)
                swpFlags = SWP_HIDEWINDOW;
        else if ((m_nStateFlags & delayShow) && !bVis)
                swpFlags = SWP_SHOWWINDOW;
        m_nStateFlags &= ~(delayShow|delayHide);
        if (swpFlags != 0)
        {
                SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
                        SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
}

class CFW : public CFrameWnd
{
public:
        void ForceDelayed(void);
};

void CFW::ForceDelayed(void)
{
        if (!this)
        {
                return;
        }

        POSITION pos = m_listControlBars.GetHeadPosition();
        while (pos != NULL)
        {
                // show/hide the next control bar
                CCB* pBar = (CCB*)m_listControlBars.GetNext(pos);
                pBar->ForceDelayed();
        }
}

class COIPF : public COleIPFrameWnd
{
public:
        void ForceDelayed(void);
};

void COIPF::ForceDelayed(void)
{
        if (!this)
        {
                return;
        }

        ((CFW*)m_pMainFrame)->ForceDelayed();
        ((CFW*)m_pDocFrame )->ForceDelayed();
}

void CPBDoc::OnDeactivateUI(BOOL bUndoable)
{
COleServerDoc::OnDeactivateUI(bUndoable);

POSITION pos = GetFirstViewPosition();
CPBView* pView = (CPBView*)(GetNextView( pos ));
CancelToolMode (FALSE);
if (pView != NULL)
    {


        pView->HideThumbNailView();

        COIPF* pFrame = (COIPF*)m_pInPlaceFrame;
        pFrame->ForceDelayed();
    }
}

//
// We override OnUpdateDocument to ignore the modified flag. Certain MFC paths
// set the modified flag inappropriately, causing data loss.
BOOL CPBDoc::OnUpdateDocument ()
{
   // save a server document -> update
   TRY
   {
        SaveEmbedding();
   }
   CATCH_ALL(e)
   {
        AfxMessageBox(AFX_IDP_FAILED_TO_UPDATE);
        #ifndef _AFX_OLD_EXCEPTIONS
        e->Delete();
        #endif
        return FALSE;
   }
   END_CATCH_ALL

   return TRUE;
}

void CPBDoc::MyOnFileUpdate ()
{
   CancelToolMode (FALSE);
   OnFileUpdate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrusvw.h ===
// pbrusvw.h : interface of the CPBView class
//



class CPBDoc;
class CImgWnd;

class CThumbNailView;
class CFloatThumbNailView;


class CBitmapObj;
class C_PrintDialogEx;
/***************************************************************************/

class CPBView : public CView
    {
    protected: // create from serialization only

    DECLARE_DYNCREATE( CPBView )

    CPBView();

    public: /* Attributes ***********************************************/

    enum DOCKERS
        {
        unknown,
        toolbox,
        colorbox,

        };

    CImgWnd*             m_pImgWnd;
    CThumbNailView*      m_pwndThumbNailView;
    CFloatThumbNailView* m_pwndThumbNailFloat;


    public: /* Operations ***********************************************/

    CPBDoc* GetDocument();

   void   OnPaletteChanged(CWnd* pFocusWnd);
    BOOL   OnQueryNewPalette();

    BOOL   SetObject();

    int     SetTools();
    CPoint GetDockedPos     ( DOCKERS tool, CSize& sizeTool );

    void   GetFloatPos      ( DOCKERS tool, CRect& rectPos );
    void   SetFloatPos      ( DOCKERS tool, CRect& rectPos );

    void   ShowThumbNailView( void );
    void   HideThumbNailView( void );



    private: /***************************************************************/
    C_PrintDialogEx *m_pdexSub; // substitute in for CPrintDialog
    CPrintDialog    *m_pdRestore; // dialog pointer to restore after printing

    BOOL    SetView( CBitmapObj* pBitmapObj );

    void    ToggleThumbNailVisibility( void );
    BOOL    IsThumbNailVisible       ( void );
    BOOL    CreateThumbNailView();
    BOOL    DestroyThumbNailView();

    BOOL    InitPageStruct( LPPAGESETUPDLGA );
    static  UINT APIENTRY PaintHookProc( HWND, UINT, WPARAM, LPARAM );
    BOOL    GetPrintToInfo(CPrintInfo* pInfo);

    public:  /* Implementation **********************************************/

    virtual     ~CPBView();

    virtual BOOL PreCreateWindow( CREATESTRUCT& cs );
    virtual void OnInitialUpdate( void );
    virtual void OnActivateView ( BOOL bActivate, CView* pActivateView, CView* pDeactiveView );
    virtual void OnDraw         ( CDC* pDC ); // overridden to draw this view
    virtual BOOL OnCmdMsg       ( UINT, int, void*, AFX_CMDHANDLERINFO*);
    virtual void OnPrepareDC    ( CDC* pDC, CPrintInfo* pInfo = NULL );


    // Printing support
    virtual BOOL OnPreparePrinting(           CPrintInfo* pInfo );
    virtual void OnBeginPrinting  ( CDC* pDC, CPrintInfo* pInfo );
    virtual void OnPrint          ( CDC* pDC, CPrintInfo* pInfo );
    virtual void OnEndPrinting    ( CDC* pDC, CPrintInfo* pInfo );

    BOOL CanSetWallpaper();
    void SetTheWallpaper( BOOL bTiled = FALSE );

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

    // Generated message map functions
    protected: /************************************************************/

    //{{AFX_MSG(CPBView)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
    afx_msg void OnEditUndo();
    afx_msg void OnEditRedo();
    afx_msg void OnEditCut();
    afx_msg void OnEditClear();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnViewGrid();
    afx_msg void OnViewZoom100();
    afx_msg void OnViewZoom400();
    afx_msg void OnUpdateViewZoom100(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewZoom400(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewGrid(CCmdUI* pCmdUI);
    afx_msg void OnImageInvertColors();
    afx_msg void OnUpdateImageInvertColors(CCmdUI* pCmdUI);
    afx_msg void OnTglopaque();
    afx_msg void OnUpdateTglopaque(CCmdUI* pCmdUI);
    afx_msg void OnImageAttributes();
    afx_msg void OnSel2bsh();
    afx_msg void OnLargerbrush();
    afx_msg void OnSmallerbrush();
    afx_msg void OnViewZoom();
    afx_msg void OnImageFlipRotate();
    afx_msg void OnUpdateImageFlipRotate(CCmdUI* pCmdUI);
    afx_msg void OnEditcolors();
    afx_msg void OnUpdateEditcolors(CCmdUI* pCmdUI);

    #if 0 // unused features

    afx_msg void OnLoadcolors();
    afx_msg void OnUpdateLoadcolors(CCmdUI* pCmdUI);
    afx_msg void OnSavecolors();
    afx_msg void OnUpdateSavecolors(CCmdUI* pCmdUI);
    #endif
    afx_msg void OnEditSelectAll();
    afx_msg void OnEditPasteFrom();
    afx_msg void OnEditCopyTo();
    afx_msg void OnUpdateEditCopyTo(CCmdUI* pCmdUI);
    afx_msg void OnImageStretchSkew();
    afx_msg void OnUpdateImageStretchSkew(CCmdUI* pCmdUI);
    afx_msg void OnViewViewPicture();
    afx_msg void OnUpdateViewViewPicture(CCmdUI* pCmdUI);
    afx_msg void OnViewTextToolbar();
    afx_msg void OnUpdateViewTextToolbar(CCmdUI* pCmdUI);
    afx_msg void OnFileSetaswallpaperT();
    afx_msg void OnUpdateFileSetaswallpaperT(CCmdUI* pCmdUI);
    afx_msg void OnFileSetaswallpaperC();
    afx_msg void OnUpdateFileSetaswallpaperC(CCmdUI* pCmdUI);
    afx_msg void OnViewThumbnail();
    afx_msg void OnUpdateViewThumbnail(CCmdUI* pCmdUI);
   afx_msg void OnUpdateImageAttributes(CCmdUI* pCmdUI);
    afx_msg void OnEscape();
    afx_msg void OnEscapeServer();
   afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
   afx_msg void OnUpdateEditSelection(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditClearSel(CCmdUI* pCmdUI);
   afx_msg void OnFilePageSetup();
   afx_msg void OnImageClearImage();
   afx_msg void OnUpdateImageClearImage(CCmdUI* pCmdUI);
   //}}AFX_MSG
   afx_msg void OnDestroy();
   afx_msg BOOL PreTranslateMessage(MSG *pMsg);

#ifdef CUSTOMFLOAT
    afx_msg void OnUpdateViewColorBox(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewToolBox(CCmdUI* pCmdUI);
#endif



    DECLARE_MESSAGE_MAP()

    friend class CPrintResObj;
    };

#ifndef _DEBUG  // debug version in pbrusvw.cpp
inline CPBDoc* CPBView::GetDocument() { return (CPBDoc*)m_pDocument; }
#endif

#ifndef PD_NOCURRENTPAGE
#define PD_NOCURRENTPAGE               0x00800000
#endif //PD_NOCURRENTPAGE

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pbrush.h ===
// pbrush.h : main header file for the PBRUSH application
//

#ifndef __AFXWIN_H__
#error include TEXT('stdafx.h') before including this file for PCH
#endif

#include "resource.h"       // main symbols

#include "loadimag.h"

#ifdef PNG_SUPPORT
#undef PNG_SUPPORT
#endif
// Bits for CTheApp::m_wEmergencyFlags
//
#define memoryEmergency 0x0001 // in a low free memory state
#define gdiEmergency    0x0002 // some GDI create failed
#define userEmergency   0x0004 // a CreateWindow failed
#define warnEmergency   0x0008 // still need to warn the user
#define failedEmergency 0x0010 // last operation actually failed

// This is the minimum delay between warning messages so the user doesn't
// get bombed by repetitious message boxes.  The value is in milli-seconds.

#define ticksBetweenWarnings (1000L * 60)

#define nSysBrushes 25
#define nOurBrushes 4

#if 0
// Pulling self-registration out. This is to be done once during setup only

class CPBTemplateServer : public COleTemplateServer
{
        public:

        void UpdateRegistry(OLE_APPTYPE nAppType,
                LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL);
} ;

#endif

/***************************************************************************/
// CPBApp:
// See pbrush.cpp for the implementation of this class
//

class CPBApp : public CWinApp
    {
    public:


    CPBApp();
    ~CPBApp();
    //
    // OnFileNew made public for scanning support
    //
    afx_msg void OnFileNew();
    // Overrides
    virtual BOOL InitInstance();
    virtual int  ExitInstance();

    virtual void WinHelp( DWORD dwData, UINT nCmd = HELP_CONTEXT ); // general
    virtual BOOL OnIdle(LONG);

    // error handling routines
    inline  BOOL InEmergencyState() const { return m_wEmergencyFlags != 0; }

    void    SetMemoryEmergency(BOOL bFailed = TRUE);
    void    SetGdiEmergency   (BOOL bFailed = TRUE);
    void    SetUserEmergency  (BOOL bFailed = TRUE);

    BOOL    CheckForEmergency() { return (m_wEmergencyFlags? TRUE: FALSE); }
    void    WarnUserOfEmergency();

    void    SetFileError( UINT uOperationint, int nCause, LPCTSTR lpszFile = NULL );
    void    FileErrorMessageBox( void );

    CString GetLastFile() {return m_sLastFile;}

    void    TryToFreeMemory();

    void    ParseCommandLine();

    // Patch to set the devmode and devname after pagesetup
    void    SetDeviceHandles(HANDLE hDevNames, HANDLE hDevMode);

    // setup routines
    void    LoadProfileSettings();
    void    SaveProfileSettings();
    void    GetSystemSettings( CDC* pdc );

    // Methods
    CPoint  CheckWindowPosition( CPoint ptPosition, CSize& sizeWindow );

    CDocument* OpenDocumentFile( LPCTSTR lpszFileName );

    BOOL    DoPromptFileName( CString& fileName, UINT nIDSTitle, DWORD lFlags,
                              BOOL bOpenFileDialog, int& iColors, BOOL bOnlyBmp );

#if 0
    // Pulling self-registration out. This is to be done once during setup only
    void    RegisterShell(CSingleDocTemplate *pDocTemplate);
#endif

    // Implementation
    COleTemplateServer m_server; // Server object for document creation

    // This is the minimum amount of free memory we like to have
    DWORD   m_dwLowMemoryBytes;
    UINT    m_nLowGdiPercent;
    UINT    m_nLowUserPercent;

    WORD    m_wEmergencyFlags;

    // General user settings
    BOOL    m_bShowStatusbar;

#ifdef CUSTOMFLOAT
    BOOL    m_bShowToolbar;
    BOOL    m_bShowColorbar;
#endif

    BOOL    m_bShowThumbnail;
    BOOL    m_bShowTextToolbar;
    BOOL    m_bShowIconToolbar;
    BOOL    m_bShowGrid;

#ifdef CUSTOMFLOAT
    BOOL    m_bToolsDocked;
    BOOL    m_bColorsDocked;
#endif //CUSTOMFLOAT


    BOOL    m_bEmbedded;
    BOOL    m_bLinked;
    BOOL    m_bHidden;
    BOOL    m_bActiveApp;
    BOOL    m_bPenSystem;
    BOOL    m_bMonoDevice;
    BOOL    m_bPaletted;

    BOOL    m_bPrintOnly;
    CString m_strDocName;
    CString m_strPrinterName;
    CString m_strDriverName;
    CString m_strPortName;

    BOOL    m_bWiaCallback;
    CString m_strWiaDeviceId;
    CString m_strWiaEventId;

#ifdef PCX_SUPPORT
    BOOL    m_bPCXfile;
#endif

    int     m_iCurrentUnits;

    // custom colors defined by the user
    COLORREF* m_pColors;
    int       m_iColors;

    // copy of the system wide palette
    CPalette* m_pPalette;

    CFont   m_fntStatus;

    int     m_nEmbeddedType;

    HWND    m_hwndInPlaceApp;

    class   CInPlaceFrame* m_pwndInPlaceFrame;

#ifdef CUSTOMFLOAT
    CRect   m_rectFloatTools;
    CRect   m_rectFloatColors;
#endif

    CRect   m_rectFloatThumbnail;

    CRect   m_rectMargins;

    BOOL    m_bCenterHorizontally;
    BOOL    m_bCenterVertically;
    BOOL    m_bScaleFitTo;
    int     m_nAdjustToPercent;
    int     m_nFitToPagesWide;
    int     m_nFitToPagesTall;

    WINDOWPLACEMENT m_wpPlacement;

    CSize   m_sizeBitmap;

    int     m_iPointSize;
    int     m_iPosTextX;
    int     m_iPosTextY;
    int     m_iBoldText;
    int     m_iUnderlineText;
    int     m_iItalicText;

    int     m_iVertEditText;

    int     m_iPenText;
    CString m_strTypeFaceName;
    int     m_iCharSet;

    int     m_iSnapToGrid;
    int     m_iGridExtent;

    // general system metrics. updated on system notification
    struct
        {
        int iWidthinPels;
        int iHeightinPels;
        int iWidthinMM;
        int iHeightinMM;
        int iWidthinINCH;
        int iHeightinINCH;
        int ixPelsPerDM;
        int iyPelsPerDM;
        int ixPelsPerMM;
        int iyPelsPerMM;
        int ixPelsPerINCH;
        int iyPelsPerINCH;
        int iBitsPixel;
        int iPlanes;
        } ScreenDeviceInfo;

    int     m_cxFrame;
    int     m_cyFrame;
    int     m_cxBorder;
    int     m_cyBorder;
    int     m_cyCaption;

    CBrush* m_pbrSysColors[nSysBrushes + nOurBrushes];
    CString m_sCurFile;
    int   m_nFilters;
    GUID *m_guidFltType; // export filter types available
    GUID  m_guidFltTypeUsed;
    int   m_nFilterInIdx;
    int   m_nFilterOutIdx;
    DWORD GetFilterIndex (REFGUID guidFltType);
    void FixExtension (CString& fileName, int iflFltType);

    CGdiplusInit GdiplusInit;

    #ifdef _DEBUG
    BOOL    m_bLogUndo;
    #endif

    private:

    int     m_nFileErrorCause;  // from CFileException::m_cause
    WORD    m_wEmergencyFlagss;
    DWORD   m_tickLastWarning;
    CString m_strEmergencyNoMem;
    CString m_strEmergencyLowMem;
    CString m_sLastFile;
    UINT    m_uOperation;

    afx_msg void OnFileOpen();


    //{{AFX_MSG(CPBApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    };

extern CPBApp theApp;

#define IsInPlace()     (theApp.m_pwndInPlaceFrame != NULL)

//#define SZ_MAPISENDDOC TEXT("MAPISendDocuments")
//#define MAPIDLL TEXT("MAPI32.DLL")

typedef ULONG (FAR PASCAL *LPFNMAPISENDDOCUMENTS)(ULONG, LPTSTR, LPTSTR, LPTSTR, ULONG);

void CancelToolMode(BOOL bSelectionCommand);

#if 0

// removing CRegKey - clashes with ATL class 

class CRegKey
{
public:
        CRegKey(HKEY hkParent, LPCTSTR pszSubKey) { if (RegCreateKey(hkParent, pszSubKey, &m_hk)!=ERROR_SUCCESS) m_hk=NULL; }
        ~CRegKey() { if (m_hk) RegCloseKey(m_hk); }
        operator HKEY() const { return(m_hk); }

private:
        HKEY m_hk;
};

#endif

extern const CLSID BASED_CODE CLSID_Paint;
extern const CLSID BASED_CODE CLSID_PaintBrush;

#define ARRAYSIZE(_x) sizeof(_x)/sizeof(_x[0])

// make atoi work if building unicode
//
#ifdef UNICODE
#define Atoi _wtoi
#define _Itoa _itow
#define Itoa _itow
#else
#define Atoi atoi
#define _Itoa _itoa
#define Itoa itoa
#endif


// macro-ize ansi/unicode conversions
#define AtoW(x, y) MultiByteToWideChar (CP_ACP, 0, (x), -1, (y), (lstrlenA ((x))+1))
#define WtoA(x,y) WideCharToMultiByte(CP_ACP, 0, (x), -1, (y), (lstrlenW((x))+1), NULL,NULL)


#ifdef USE_MIRRORING

////    REGetLayout - Get layout of DC
//
//      Returns layout flags from an NT5/W98 or later DC, or zero
//      on legacy platforms.

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL         0x00400000L
#endif
#ifndef WS_EX_NOINHERITLAYOUT
#define WS_EX_NOINHERITLAYOUT   0x00100000L
#endif
#ifndef LAYOUT_RTL
#define LAYOUT_RTL              0x01
#endif

DWORD WINAPI PBGetLayoutInit(HDC hdc);
DWORD WINAPI PBSetLayoutInit(HDC hdc, DWORD dwLayout);
extern DWORD (WINAPI *PBSetLayout) (HDC hdc, DWORD dwLayout);
extern DWORD (WINAPI *PBGetLayout) (HDC hdc);

#endif


/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pgsetup.h ===
#ifndef _PGSETUP_H_
#define _PGSETUP_H_

/***************************************************************************/

class CPageSetupData
{
public:
    VOID UpdateControls(HWND hDlg);
    static VOID UpdateValue(HWND hDlg, int nIDDlgItem, UINT *pnResult);
    VOID CalculateImageRect(const CSize &PhysicalPageSize, CPoint &PhysicalOrigin, CSize &PhysicalImageSize);

    static UINT_PTR APIENTRY PageSetupHook(HWND, UINT, WPARAM, LPARAM);
    static UINT_PTR APIENTRY PagePaintHook(HWND, UINT, WPARAM, LPARAM);

public:
    BOOL bCenterHorizontally;
    BOOL bCenterVertically;
    BOOL bScaleFitTo;
    UINT nAdjustToPercent;
    UINT nFitToPagesWide;
    UINT nFitToPagesTall;

    double fPhysicalImageWidth;
    double fPhysicalImageHeight;
};

#endif //_PGSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pictures.h ===
// pictures.h : this is the header file for the picture object
//

#ifndef __PICTURES_H__
#define __PICTURES_H__

/****************************************************************************/

class CPic : public CDC
    {
    public:

    DECLARE_DYNAMIC( CPic )

    protected:

    CBitmap     mBitmap;
    CBitmap     mMask;
    HBITMAP     mhBitmapOld;
    CSize       mSize;
    int         miCnt;
    BOOL        mbReady;

    public:

                CPic();
               ~CPic();

    BOOL        PictureSet(LPCTSTR lpszResourceName, int iCnt=1 );
    BOOL        PictureSet(UINT nIDResource, int iCnt=1 );
    void        Picture( CDC* pDC, int iX, int iY, int iPic=0 );
    CSize       PictureSize() { return mSize; }

    private:

    BOOL        InstallPicture();

    };

/****************************************************************************/

#endif // __PICTURES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pcximage.cpp ===
//---------------------------------------------------------------
//  File: pcximage.cpp
//
//  Image manipulation functions for PCX format images.
//---------------------------------------------------------------
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgfile.h"
#include "imgcolor.h"
#include "undo.h"
#include "props.h"
#include "ferr.h"
#include "ctype.h"
#include "cmpmsg.h"

#define COLORMAPLENGTH 48
#define FILLERLENGTH 58

#ifdef PCX_SUPPORT

struct PCXHeader
    {
    unsigned char   manufacturer;
    unsigned char   version;
    unsigned char   encoding;
    unsigned char   bits_per_pixel_per_plane;
    short           xmin;
    short           ymin;
    short           xmax;
    short           ymax;
    unsigned short  hresolution;
    unsigned short  vresolution;
    unsigned char   colormap[COLORMAPLENGTH];
    unsigned char   reserved;
    unsigned char   nplanes;
    unsigned short  bytes_per_line;
    short           palette_info;
    unsigned char   filler[FILLERLENGTH];   // Header is 128 bytes
    };

#endif

class CFileBuffer : public CObject
    {
    DECLARE_DYNCREATE( CFileBuffer )

    public:

    enum Type
        {
        READ,
        WRITE
        };


    CFileBuffer();
   ~CFileBuffer();

    BOOL  Create( CFile* pfile, Type IO );
    short Get   ( void );
    BOOL  Put   ( BYTE cByte );
    long  Seek  ( long lOff, UINT nFrom );
    BOOL  Flush ( void );

    private:

    void  Fill  ( void );

    enum { MAX_BUFFER = 2048 };

    CFile*      m_pFile;
    int         m_iBuffPos;
    int         m_iBuffSize;
    BYTE*       m_pBuffer;
    };

IMPLEMENT_DYNCREATE( CFileBuffer, CObject )

#include "memtrace.h"

/****************************************************************************/

CFileBuffer::CFileBuffer() : CObject()
    {
    m_pFile     = 0;
    m_iBuffPos  = 0;
    m_iBuffSize = 0;
    m_pBuffer   = 0;
    }

/****************************************************************************/

CFileBuffer::~CFileBuffer()
    {
    if (m_pBuffer)
        delete [] m_pBuffer;
    }

/****************************************************************************/

BOOL CFileBuffer::Create( CFile* pfile, Type IO )
    {
    ASSERT( pfile != NULL );

    if (pfile == NULL)
        return FALSE;

    m_pFile   = pfile;
    m_pBuffer = new BYTE[MAX_BUFFER];

    if (! m_pBuffer)
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    if (IO == READ)
        {
        Fill();

        if (! m_iBuffSize)
            {
            theApp.SetFileError( IDS_ERROR_READLOAD, ferrIllformedFile );
            return FALSE;
            }
        }
    return TRUE;
    }

/****************************************************************************/

short CFileBuffer::Get( void )
    {
    if (! m_iBuffSize)
        return EOF;

    short sByte = (short)(unsigned short)m_pBuffer[m_iBuffPos++];

    if (m_iBuffPos == m_iBuffSize)
        Fill();

    return sByte;
    }

/****************************************************************************/

BOOL CFileBuffer::Put( BYTE cByte )
    {
    m_pBuffer[m_iBuffSize++] = cByte;

    if (m_iBuffSize == MAX_BUFFER)
        return Flush();

    return TRUE;
    }

/****************************************************************************/

long CFileBuffer::Seek( long lOff, UINT nFrom )
    {
    long lPos = m_pFile->Seek( lOff, nFrom );

    Fill();

    return lPos;
    }

/****************************************************************************/

void CFileBuffer::Fill()
    {
    m_iBuffSize = m_pFile->Read( m_pBuffer, MAX_BUFFER );
    m_iBuffPos  = 0;
    }

/****************************************************************************/

BOOL CFileBuffer::Flush( void )
    {
    TRY {
        m_pFile->Write( m_pBuffer, m_iBuffSize );
        }
    CATCH( CFileException, ex )
        {
        m_pFile->Abort();
        theApp.SetFileError( IDS_ERROR_SAVE, ex->m_cause );

        return FALSE;
        }
    END_CATCH

    m_iBuffSize = 0;

    return TRUE;
    }

/****************************************************************************/
/****************************************************************************/
#ifdef PCX_SUPPORT

BOOL CBitmapObj::ReadPCX( CFile* pfile )
    {
    if (! pfile->GetLength())
        {
        if (m_hThing)
            Free();

        m_bDirty = TRUE;

        return TRUE;
        }

    // if  a PCX extension try to load this as a PCX image.
    PCXHeader hdr;
    PBITMAP   p_dib;   // Device independent bitmap

    short bytes_per_line;

    pfile->Read( (unsigned char*)&hdr, sizeof( PCXHeader ) );

    // Check if image file format is acceptable

    if (hdr.manufacturer != 0x0a)
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, ferrCantDetermineType );
        return FALSE;
        }

    // We only handle 1, 4, 8, or 24-bit images

    short bits_per_pixel = hdr.nplanes * hdr.bits_per_pixel_per_plane;

    if (bits_per_pixel != 1
    &&  bits_per_pixel != 4
    &&  bits_per_pixel != 8
    &&  bits_per_pixel != 24)
        {
        theApp.SetFileError( IDS_ERROR_READLOAD, ferrCantDetermineType );
        return FALSE;
        }

    short image_width  = hdr.xmax - hdr.xmin + 1;
    short image_height = hdr.ymax - hdr.ymin + 1;

    // Allocate space where the PCX image will be unpacked.

    long pcx_image_size = (long) hdr.nplanes *
                          (long) image_height *
                          (long) hdr.bytes_per_line;

    BYTE* image = (BYTE*) new BYTE[pcx_image_size];

    if (image == NULL)
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    // Read in PCX image into this area.
    CFileBuffer FileBuffer;

    if (! FileBuffer.Create( pfile, CFileBuffer::READ ))
        {
        delete [] image;

        return FALSE;
        }

    // Decode run-length encoded image data
    short i;
    short byte;
    short count;
    long  pos = 0L;

    while ((byte = FileBuffer.Get()) != EOF)
        {
        if ((byte & 0xc0) == 0xc0)
            {
            count = byte & 0x3f;

            if ((byte = FileBuffer.Get()) != EOF)
                {
                for (i = 0; i < count; i++)
                    {
                    if (pos >= pcx_image_size)
                        break;

                    image[pos] = (CHAR)byte;
                    pos++;
                    }
                }
            }
        else
            {
            if (pos >= pcx_image_size)
                break;

            image[pos] = (CHAR)byte;
            pos++;
            }
        }

    // Allocate memory for the device independent bitmap (DIB)
    // Note that the number of bytes in each line of a DIB image
    // must be a multiple of 4.

    short bytes_per_line_per_plane = (image_width *
                       hdr.bits_per_pixel_per_plane + 7) / 8;

    short actual_bytes_per_line = (image_width *
                                   hdr.nplanes *
                       hdr.bits_per_pixel_per_plane + 7) / 8;
    bytes_per_line = actual_bytes_per_line;

    if ( bytes_per_line % 4)
         bytes_per_line = 4 * ( bytes_per_line / 4 + 1);

    // Make room for a palette

    short palettesize = 16;

    if (bits_per_pixel == 1)
        palettesize = 2;

    if (hdr.version >= 5
    && bits_per_pixel > 4)
        {
        // Go back 769 bytes from the end of the file

        FileBuffer.Seek( -769, CFile::end );

        if (FileBuffer.Get() == 12)
            {
            // There is a 256-color palette following this byte
            palettesize = 256;
            }
        }
    // If image has more than 256 colors then there is no palette

    if (bits_per_pixel > 8)
        palettesize = 0;

    // Allocate space for the bitmap
    if (m_hThing)
        Free();

    m_lMemSize = sizeof( BITMAPINFOHEADER ) + palettesize * sizeof( RGBQUAD )
                                   + (long)bytes_per_line * (long)image_height;
    if (! Alloc())
        return FALSE;

    p_dib = (PBITMAP) GlobalLock(m_hThing);

    // Set up bitmap info header

    LPBITMAPINFOHEADER p_bminfo = (LPBITMAPINFOHEADER)p_dib;

    p_bminfo->biSize          = sizeof(BITMAPINFOHEADER);
    p_bminfo->biWidth         = image_width;
    p_bminfo->biHeight        = image_height;
    p_bminfo->biPlanes        = 1;
    p_bminfo->biBitCount      = hdr.bits_per_pixel_per_plane * hdr.nplanes;
    p_bminfo->biCompression   = BI_RGB;
    p_bminfo->biSizeImage     = (long)image_height * (long) bytes_per_line;
    p_bminfo->biXPelsPerMeter = (long)hdr.hresolution;
    p_bminfo->biYPelsPerMeter = (long)hdr.vresolution;
    p_bminfo->biClrUsed       = 0;
    p_bminfo->biClrImportant  = 0;

    // Set up the color palette

    if (palettesize > 0)
        {
        //***** RGBQUAD *palette = (RGBQUAD*) ((LPSTR)imdata->p_dib

        LPRGBQUAD palette = LPRGBQUAD((LPSTR)p_dib + sizeof(BITMAPINFOHEADER));

        short palindex;

        for (palindex = 0; palindex < palettesize; palindex++)
            {
            if (palettesize == 256)
                {
                // Read palette from file

                palette[palindex].rgbRed       = (BYTE)FileBuffer.Get();
                palette[palindex].rgbGreen     = (BYTE)FileBuffer.Get();
                palette[palindex].rgbBlue      = (BYTE)FileBuffer.Get();
                palette[palindex].rgbReserved  = 0;
                }
            if (palettesize == 16)
                {
                // 16-color palette from PCX header

                palette[palindex].rgbRed      = (BYTE)hdr.colormap[3*palindex];
                palette[palindex].rgbGreen    = (BYTE)hdr.colormap[3*palindex+1];
                palette[palindex].rgbBlue     = (BYTE)hdr.colormap[3*palindex+2];
                palette[palindex].rgbReserved = 0;
                }
            if (palettesize == 2)
                {
                // Set up palette for black and white images

                palette[palindex].rgbRed      = palindex * 255;
                palette[palindex].rgbGreen    = palindex * 255;
                palette[palindex].rgbBlue     = palindex * 255;
                palette[palindex].rgbReserved = 0;
                }
            }
        }

    // Load image data into the DIB. Note the DIB image must be
    // stored "bottom to top" line order. That's why we position
    // data at the end of the array so that the image can be
    // stored backwards--from the last line to the first.

    BYTE* data = (BYTE*)p_dib + ((long)sizeof( BITMAPINFOHEADER )
                              + palettesize * sizeof( RGBQUAD )
                              + (image_height - 1) * bytes_per_line);

    // Define a macro to access bytes in the PCX image according
    // to specified line and plane index.

    short lineindex, byteindex, planeindex;

    #define bytepos(lineindex, planeindex, byteindex)  \
            ((long)(lineindex)*(long)hdr.bytes_per_line* \
             (long)hdr.nplanes + \
             (long)(planeindex)*(long)hdr.bytes_per_line + \
             (long)(byteindex))

    // Construct packed pixels out of decoded PCX image.

    short loc;
    unsigned short onebyte;
    unsigned short bits_copied;
    unsigned short few_bits;
    unsigned short k;
    unsigned short bbpb = 8/hdr.bits_per_pixel_per_plane;

    // Build a mask to pick out bits from each byte of the PCX image

    unsigned short himask = 0x80, mask;

    if (hdr.bits_per_pixel_per_plane > 1)
        for (i = 0; i < hdr.bits_per_pixel_per_plane - 1;
            i++) himask = 0x80 | (himask >> 1);

    for (lineindex = 0; lineindex < image_height;
         lineindex++, data -= bytes_per_line)
        {
        if (actual_bytes_per_line < bytes_per_line)
            for (loc = actual_bytes_per_line; loc < bytes_per_line; loc++)
                data[loc] = 0;

        loc         = 0;
        onebyte     = 0;
        bits_copied = 0;

        for (byteindex = 0; byteindex < bytes_per_line_per_plane; byteindex++)
            {
            for (k = 0, mask = himask; k < bbpb; k++,
                                        mask >>= hdr.bits_per_pixel_per_plane)
                {
                // Go through all scan line for all planes and copy bits into
                // the data array

                for (planeindex = 0; planeindex < hdr.nplanes; planeindex++)
                    {
                    few_bits = image[bytepos(lineindex,
                                            planeindex, byteindex)] & mask;

                    // Shift the selected bits to the most significant position

                    if (k > 0)
                        few_bits <<= (k*hdr.bits_per_pixel_per_plane);

                    // OR the bits with current pixel after shifting them right

                    if (bits_copied > 0)
                        few_bits >>= bits_copied;

                    onebyte |= few_bits;
                    bits_copied += hdr.bits_per_pixel_per_plane;

                    if (bits_copied >= 8)
                        {
                        data[loc] = (UCHAR)onebyte;
                        loc++;
                        bits_copied = 0;
                        onebyte = 0;
                        }
                    }
                }
            }
        }

    // Success!
    delete [] (BYTE*)image;

    GlobalUnlock(m_hThing);

    return TRUE;
    }

/****************************************************************************/
#define WIDTHBYTES(bits) ((((bits) + 31) / 32) * 4)

BOOL CBitmapObj::WritePCX( CFile* pfile )
    {
    if (m_pImg == NULL)
        {
        // The image has not been loaded, so we'll just copy the
        // original out to the file...
        ASSERT( m_hThing );

        if (! m_hThing)
            return FALSE;
        }
    else
        {
        // The image has been loaded and may have been edited, so
        // we'll convert it back to a dib to save...
        if (! m_hThing)
            SaveResource( FALSE );

        if (! m_hThing)
            return FALSE;
        }

    // build pcx file from the DIB
    PBITMAP   p_dib = (PBITMAP)GlobalLock(m_hThing);         // Device independent bitmap
    PCXHeader hdr;                                           // PCX bitmap header
    LPBITMAPINFOHEADER p_bminfo = (LPBITMAPINFOHEADER)p_dib; // Set up bitmap info header

    short palettesize = DIBNumColors( (LPSTR)p_dib);         // Get palette size

    hdr.manufacturer = 10;
//  hdr.version      = (char)((hPalette || (GetDeviceCaps(fileDC, RASTERCAPS) & RC_PALETTE)) ? 5 : 3);
    hdr.version      = (CHAR)( palettesize ? 5 : 3);
    hdr.encoding     = 1;
    hdr.xmin         = hdr.ymin = 0;
    hdr.xmax         = p_bminfo->biWidth - 1;
    hdr.ymax         = p_bminfo->biHeight- 1;
//  hdr.hresolution  = theApp.ScreenDeviceInfo.iWidthinPels;
//  hdr.vresolution  = theApp.ScreenDeviceInfo.iHeightinPels;
    hdr.hresolution  = (WORD)p_bminfo->biXPelsPerMeter;
    hdr.vresolution  = (WORD)p_bminfo->biYPelsPerMeter;
    hdr.reserved     = 0;
    hdr.nplanes      = (BYTE)p_bminfo->biPlanes; //biPlanes should always be 1
    hdr.palette_info = (BYTE)p_dib->bmWidthBytes;
    hdr.bits_per_pixel_per_plane = (CHAR) p_bminfo->biBitCount;

    hdr.bytes_per_line = WIDTHBYTES( (LONG) (p_bminfo->biBitCount * p_bminfo->biWidth) );

    // Clean up filler
    for (int index = FILLERLENGTH; index--; )
        hdr.filler[index] ='\0';

    //  If there are at most 16 colors place them in header
    LPRGBQUAD palette = LPRGBQUAD((LPSTR)p_dib + sizeof(BITMAPINFOHEADER));
    LPSTR       lpDst = (LPSTR)hdr.colormap;

    // Clean up colormap
    for (index = COLORMAPLENGTH; index--; )
        lpDst[index] ='\0';

    if (palettesize <= 16)
        for (index = palettesize; index--; )
            {
            *lpDst++ = palette->rgbRed;  /* swap RED and BLUE components */
            *lpDst++ = palette->rgbGreen;
            *lpDst++ = palette->rgbBlue;
            palette++;
            }

    pfile->Write( (unsigned char*)&hdr, sizeof( PCXHeader ) );

    // Now pack the image

    // Load image data from the DIB. Note the DIB image is
    // stored "bottom to top" line order. That's why we position
    // data at the end of the array so that the image can be
    // stored backwards--from the last line to the first.

    CFileBuffer FileBuffer;

    if (! FileBuffer.Create( pfile, CFileBuffer::WRITE ))
        {
        GlobalUnlock(m_hThing);
        return FALSE;
        }

    // find the start of the bitmap data then go to the end of the data
    // the PCX is stored in reverse order of the DIB
    int TopofData = sizeof( BITMAPINFOHEADER ) + palettesize * sizeof( RGBQUAD );
    BYTE* data = (BYTE*)p_dib + TopofData + hdr.bytes_per_line * (p_bminfo->biHeight );

    for (index = p_bminfo->biHeight; index--; )
        {
        data -= hdr.bytes_per_line;

        if (! PackBuff( &FileBuffer, data, hdr.bytes_per_line )) //convert to run length encoding.
            {
            GlobalUnlock(m_hThing);
            return FALSE;
            }
        }

    if (palettesize == 256) // Write palette to file
        {
        if (! FileBuffer.Put( 12 ))  // Tag number for palette information
            {
            GlobalUnlock(m_hThing);
            return FALSE;
            }

        for (index = 0; index < palettesize; index++)
            {
            if (! FileBuffer.Put( palette[index].rgbRed   )
            ||  ! FileBuffer.Put( palette[index].rgbGreen )
            ||  ! FileBuffer.Put( palette[index].rgbBlue  ))
                {
                GlobalUnlock(m_hThing);
                return FALSE;
                }
            }
        }

    GlobalUnlock(m_hThing);
    return FileBuffer.Flush();
    }

#endif //PCX_SUPPORT

/****************************************************************************/

/* run length encoding equates */
#define MINcount 2
#define MAXcount 63
#define ESCbits  0xC0
#define BUFFER_SIZE 1024

/* bitmaps are ordered <b, g, r, i> but PCX is ordered <r, g, b, i> ... */

BOOL CBitmapObj::PackBuff(CFileBuffer *FileBuffer, BYTE *PtrDib, int byteWidth )
    {
    BYTE  runChar;
    BYTE  runCount;
    BYTE* endPtr = PtrDib + byteWidth;

    for (runCount = 1, runChar = *PtrDib++; PtrDib <= endPtr; ++PtrDib)
        {
        if (PtrDib != endPtr && *PtrDib == runChar && runCount < MAXcount)
            ++runCount;
        else
            if (*PtrDib != runChar
            &&  runCount < MINcount
            && (runChar & ESCbits) != ESCbits)
                {
                while (runCount--)
                    if (! FileBuffer->Put( runChar ))
                        return FALSE;

                runCount = 1;
                runChar = *PtrDib;
                }
            else
                {
                runCount |= ESCbits;

                if (! FileBuffer->Put( runCount )
                ||  ! FileBuffer->Put( runChar  ))
                    return FALSE;

                runCount = 1;
                runChar  = *PtrDib;
                }
        }

    return TRUE;
    }

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pictures.cpp ===
// pictures.cpp : This is the code for the picture object
//

#include "stdafx.h"
#include "resource.h"
#include "pictures.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CPic, CDC )

#include "memtrace.h"

/****************************************************************************/

CPic::CPic()
     : CDC()
{
mhBitmapOld = NULL;
mbReady     = FALSE;
/*
**  set up our DC
*/
if (! CreateCompatibleDC( NULL ))
    {
    #ifdef _DEBUG
    OutputDebugString( TEXT("GDI error or unable to get a DC!\r\n") );
    #endif
    }
}

/****************************************************************************/

CPic::~CPic()
{
if (m_hDC)
    {
    if (mhBitmapOld)
        SelectObject( CBitmap::FromHandle( mhBitmapOld ) );

    if (mBitmap.m_hObject)
        mBitmap.DeleteObject();

    if (mMask.m_hObject)
        mMask.DeleteObject();
    }
}

/****************************************************************************/

void CPic::Picture( CDC* pDC, int iX, int iY, int iPic )
{
if (! mbReady || iPic < 0 || iPic >= miCnt)
    return;

int iPicX = iPic * mSize.cx;

SelectObject( &mMask );

// select  FG color to be Black and BK color to be White
//
// The Default Mono->Color Conversion sets (Black -> FG Color, White -> BG Color)
// It uses FG/BK color from the destination (color DC).
// we want Black -> black, White -> white
// a black/white bitmap in color format.
COLORREF cRefFGColorOld = pDC->SetTextColor( RGB(0,0,0) );
COLORREF cRefBKColorOld = pDC->SetBkColor(RGB(255,255,255));

pDC->BitBlt( iX, iY, mSize.cx, mSize.cy, this, iPicX, 0, SRCAND );

pDC->SetTextColor(cRefFGColorOld);
pDC->SetBkColor(cRefBKColorOld);


SelectObject( &mBitmap );

pDC->BitBlt( iX, iY, mSize.cx, mSize.cy, this, iPicX, 0, SRCPAINT );
}

/****************************************************************************/

BOOL CPic::PictureSet( LPCTSTR lpszResourceName, int iCnt )
{
BOOL bReturn = FALSE;
/*
**  get the Pictures bitmap
*/
if (m_hDC && iCnt)
    if (mBitmap.LoadBitmap( lpszResourceName ))
        {
        miCnt = iCnt;

        bReturn = InstallPicture();
        }
    else
        {
        #ifdef _DEBUG
        OutputDebugString( TEXT("Unable to load the bitmap!\r\n") );
        #endif
        }

return bReturn;
}

/****************************************************************************/

BOOL CPic::PictureSet( UINT nIDResource, int iCnt )
{
BOOL bReturn = FALSE;
/*
**  get the Pictures bitmap
*/
if (m_hDC && iCnt)
    if (mBitmap.LoadBitmap( nIDResource ))
        {
        miCnt = iCnt;

        bReturn = InstallPicture();
        }
    else
        {
        #ifdef _DEBUG
        OutputDebugString( TEXT("Unable to load the bitmap!\r\n") );
        #endif
        }
return bReturn;
}

/****************************************************************************/

BOOL CPic::InstallPicture()
{
/*
**  get the bitmap info from the picture bitmap, saving the picture size
*/
BITMAP bmInfo;

if (mBitmap.GetObject( sizeof( BITMAP ), &bmInfo ) != sizeof( BITMAP ))
    {
    #ifdef _DEBUG
    OutputDebugString( TEXT("GDI error getting bitmap information!\r\n") );
    #endif

    return FALSE;
    }

mSize = CSize( bmInfo.bmWidth / miCnt, bmInfo.bmHeight );
/*
**  put the bitmap in the DC, saving the original.
*/
CBitmap* bitmap = SelectObject( &mBitmap );

mhBitmapOld = (HBITMAP)bitmap->m_hObject;
/*
**  create the mask bitmap, same size monochrome
*/
if (! mMask.CreateBitmap( bmInfo.bmWidth, bmInfo.bmHeight, 1, 1, NULL ))
    {
    #ifdef _DEBUG
    OutputDebugString( TEXT("GDI error creating the mask bitmap!\r\n") );
    #endif

    return FALSE;
    }
/*
**  put the mask in a temp DC so we can generate the mask bits
*/
CDC dc;

dc.CreateCompatibleDC( this );

ASSERT( dc.m_hDC );

CBitmap* ob = dc.SelectObject( &mMask );
/*
**  use the color at the upper left corner for generating the mask
*/
SetBkColor( GetPixel( 1, 1 ) );

// this ROP Code will leave bits in the destination bitmap the same color if the
// corresponding source bitmap's bit are black.
// all other bits in the destination (where source bits are not black)
// are turned to black.

#define ROP_DSna 0x00220326L
/*
**  Creates the mask from all pixels in the image of a given color.
**  Copies to the mask, then cuts the image with the mask.
*/
// create the mast, All but the background color is Black
// bkcolor is white
dc.BitBlt( 0, 0, bmInfo.bmWidth, bmInfo.bmHeight, this, 0, 0, SRCCOPY  );

// select  FG color to be Black and BK color to be White
// The Default Mono->Color Conversion sets (Black -> FG Color, White -> BG Color)
// It uses FG/BK color from the destination (color DC).
// we want Black -> black, White -> white
// a black/white bitmap in color format.
COLORREF cRefFGColorOld = dc.SetTextColor( RGB(0,0,0) );
COLORREF cRefBKColorOld = dc.SetBkColor(RGB(255,255,255));

   BitBlt( 0, 0, bmInfo.bmWidth, bmInfo.bmHeight,  &dc, 0, 0, ROP_DSna );

dc.SetTextColor(cRefFGColorOld);
dc.SetBkColor(cRefBKColorOld);

dc.SelectObject( ob );
mbReady = TRUE;
return TRUE;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\pgsetup.cpp ===
//
// pgsetup.cpp
//
// implementation of the CPageSetupData class
//

#include "stdafx.h"
#include "resource.h"
#include "dlgs.h"
#include "pgsetup.h"

/***************************************************************************/

#define FIXED_FLOATPT_MULTDIV 100000

/***************************************************************************/

VOID CPageSetupData::UpdateControls(HWND hDlg)
{
    CheckDlgButton(hDlg, IDC_HORIZONTALLY, bCenterHorizontally);
    CheckDlgButton(hDlg, IDC_VERTICALLY, bCenterVertically);

    CheckDlgButton(hDlg, IDC_ADJUST_TO, !bScaleFitTo);
    SetDlgItemInt(hDlg, IDC_PERCENT_NORMAL_SIZE, nAdjustToPercent, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PERCENT_NORMAL_SIZE), !bScaleFitTo);
    EnableWindow(GetDlgItem(hDlg, IDC_STR_PERCENT_NORMAL_SIZE), !bScaleFitTo);
    
    CheckDlgButton(hDlg, IDC_FIT_TO, bScaleFitTo);
    SetDlgItemInt(hDlg, IDC_PAGES_WIDE, nFitToPagesWide, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PAGES_WIDE), bScaleFitTo);
    EnableWindow(GetDlgItem(hDlg, IDC_STR_PAGES_WIDE), bScaleFitTo);
    SetDlgItemInt(hDlg, IDC_PAGES_TALL, nFitToPagesTall, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PAGES_TALL), bScaleFitTo);
    EnableWindow(GetDlgItem(hDlg, IDC_STR_PAGES_TALL), bScaleFitTo);

    InvalidateRect(GetDlgItem(hDlg, rct1), 0, TRUE);
}

/***************************************************************************/

VOID CPageSetupData::UpdateValue(HWND hDlg, int nIDDlgItem, UINT *pnResult)
{
    BOOL bTranslated;

    UINT nResult = GetDlgItemInt(hDlg, nIDDlgItem, &bTranslated, FALSE);

    if (bTranslated && nResult != 0)
    {
        *pnResult = nResult;

        InvalidateRect(GetDlgItem(hDlg, rct1), 0, TRUE);
    }
}

/***************************************************************************/

UINT_PTR APIENTRY CPageSetupData::PageSetupHook(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            LPPAGESETUPDLG ppsd = (LPPAGESETUPDLG) lParam;

            if (ppsd == NULL)
            {
                break;
            }

            CPageSetupData *that = (CPageSetupData *) ppsd->lCustData;

            if (that == NULL)
            {
                break;
            }

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) ppsd);

            SendDlgItemMessage(hDlg, IDC_PERCENT_NORMAL_SIZE, EM_LIMITTEXT, 4, 0);

            SendDlgItemMessage(hDlg, IDC_PAGES_WIDE, EM_LIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_PAGES_TALL, EM_LIMITTEXT, 2, 0);
            
            that->UpdateControls(hDlg);
            
            break;
        }

        case WM_COMMAND:
        {
            LPPAGESETUPDLG ppsd = (LPPAGESETUPDLG) GetWindowLongPtr(hDlg, GWLP_USERDATA);

            if (ppsd == NULL)
            {
                break;
            }

            CPageSetupData *that = (CPageSetupData *) ppsd->lCustData;

            if (that == NULL)
            {
                break;
            }

            switch (LOWORD(wParam))
            {
                case IDC_HORIZONTALLY:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bCenterHorizontally = !that->bCenterHorizontally;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_VERTICALLY:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bCenterVertically = !that->bCenterVertically;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_ADJUST_TO:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bScaleFitTo = FALSE;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_FIT_TO:
                {
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        that->bScaleFitTo = TRUE;
                        that->UpdateControls(hDlg);
                    }

                    return TRUE;
                }

                case IDC_PERCENT_NORMAL_SIZE:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        UpdateValue(hDlg, IDC_PERCENT_NORMAL_SIZE, &that->nAdjustToPercent);
                    }
                    else if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        SetDlgItemInt(hDlg, IDC_PERCENT_NORMAL_SIZE, that->nAdjustToPercent, FALSE);
                    }

                    return TRUE;
                }

                case IDC_PAGES_WIDE:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        UpdateValue(hDlg, IDC_PAGES_WIDE, &that->nFitToPagesWide);
                    }
                    else if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        SetDlgItemInt(hDlg, IDC_PAGES_WIDE, that->nFitToPagesWide, FALSE);
                    }

                    return TRUE;
                }

                case IDC_PAGES_TALL:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        UpdateValue(hDlg, IDC_PAGES_TALL, &that->nFitToPagesTall);
                    }
                    else if (HIWORD(wParam) == EN_KILLFOCUS)
                    {
                        SetDlgItemInt(hDlg, IDC_PAGES_TALL, that->nFitToPagesTall, FALSE);
                    }

                    return TRUE;
                }
            }

            break;
        }
    }

    return FALSE;
}

/***************************************************************************/

VOID 
CPageSetupData::CalculateImageRect(
    const CSize &PhysicalPageSize, 
    CPoint      &PhysicalOrigin, 
    CSize       &PhysicalScaledImageSize
)
{
    // Find the scaled image size and the total page size required to print that image

    LONG nPhysicalTotalPageWidth;
    LONG nPhysicalTotalPageHeight;

    if (bScaleFitTo)
    {
        nPhysicalTotalPageWidth = PhysicalPageSize.cx * nFitToPagesWide;
        nPhysicalTotalPageHeight = PhysicalPageSize.cy * nFitToPagesTall;

        // Keep the aspect ratio; try the match the width first and if it fails, match the height

        PhysicalScaledImageSize.cx = nPhysicalTotalPageWidth;
        PhysicalScaledImageSize.cy = (LONG) (fPhysicalImageHeight * nPhysicalTotalPageWidth / fPhysicalImageWidth);

		if (PhysicalScaledImageSize.cy > nPhysicalTotalPageHeight)
        {
			PhysicalScaledImageSize.cx = (LONG) (fPhysicalImageWidth * nPhysicalTotalPageHeight / fPhysicalImageHeight);
			PhysicalScaledImageSize.cy = nPhysicalTotalPageHeight;
		}
    }
    else
    {
        PhysicalScaledImageSize.cx = (LONG) (fPhysicalImageWidth * nAdjustToPercent / 100);
        PhysicalScaledImageSize.cy = (LONG) (fPhysicalImageHeight * nAdjustToPercent / 100);

        nFitToPagesWide = (PhysicalScaledImageSize.cx + PhysicalPageSize.cx - 1) / PhysicalPageSize.cx;
        nFitToPagesTall = (PhysicalScaledImageSize.cy + PhysicalPageSize.cy - 1) / PhysicalPageSize.cy;

        nPhysicalTotalPageWidth = PhysicalPageSize.cx * nFitToPagesWide;
        nPhysicalTotalPageHeight = PhysicalPageSize.cy * nFitToPagesTall;
    }

    PhysicalOrigin.x = bCenterHorizontally ? (nPhysicalTotalPageWidth - PhysicalScaledImageSize.cx) / 2 : 0;

    PhysicalOrigin.y = bCenterVertically ? (nPhysicalTotalPageHeight - PhysicalScaledImageSize.cy) / 2 : 0;
}

/***************************************************************************/

UINT_PTR APIENTRY CPageSetupData::PagePaintHook(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_PSD_PAGESETUPDLG:
        {
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) lParam);
            break;
        }

        case WM_PSD_GREEKTEXTRECT:
        {
            LPPAGESETUPDLG ppsd = (LPPAGESETUPDLG) GetWindowLongPtr(hDlg, GWLP_USERDATA);

            if (ppsd == NULL)
            {
                break;
            }
            
            CPageSetupData *that = (CPageSetupData *) ppsd->lCustData;

            if (that == NULL)
            {
                break;
            }

            CRect *pOutputWindowRect = (CRect *) lParam;

            // Find the physical size of the page

            CSize PhysicalPageSize;

            PhysicalPageSize.cx = ppsd->ptPaperSize.x - ppsd->rtMargin.left - ppsd->rtMargin.right;
            PhysicalPageSize.cy = ppsd->ptPaperSize.y - ppsd->rtMargin.top - ppsd->rtMargin.bottom;

            CPoint PhysicalOrigin;
            CSize  PhysicalScaledImageSize;

            that->CalculateImageRect(PhysicalPageSize, PhysicalOrigin, PhysicalScaledImageSize);

            // Find the scaling ratios for the preview window

            double fWidthRatio = (double) pOutputWindowRect->Width() / PhysicalPageSize.cx;
            double fHeightRatio = (double) pOutputWindowRect->Height() / PhysicalPageSize.cy;

            // Find the size of the image rectangle on the preview window

            CRect OutputImageRect;

            OutputImageRect.left   = pOutputWindowRect->left + (int) (fWidthRatio  * PhysicalOrigin.x);
            OutputImageRect.top    = pOutputWindowRect->top  + (int) (fHeightRatio * PhysicalOrigin.y);
            OutputImageRect.right  = OutputImageRect.left    + (int) (fWidthRatio  * PhysicalScaledImageSize.cx);
            OutputImageRect.bottom = OutputImageRect.top     + (int) (fHeightRatio * PhysicalScaledImageSize.cy);

            // Draw a rectangle with crossing lines

            CDC *pDC = CDC::FromHandle((HDC) wParam);

            CGdiObject *pOldPen = pDC->SelectStockObject(BLACK_PEN);

            CGdiObject *pOldBrush = pDC->SelectStockObject(LTGRAY_BRUSH);

            pDC->Rectangle(OutputImageRect);

            pDC->MoveTo(OutputImageRect.left, OutputImageRect.top);
            pDC->LineTo(OutputImageRect.right - 1, OutputImageRect.bottom - 1);

            pDC->MoveTo(OutputImageRect.left, OutputImageRect.bottom - 1);
            pDC->LineTo(OutputImageRect.right - 1, OutputImageRect.top);

            pDC->SelectObject(pOldPen);

            pDC->SelectObject(pOldBrush);

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\printres.h ===
// printres.h : interface of the Cprintres class
//

#define MARGINS_UNITS 2540 // Store hundredths of MM
#define MARGINS_DEFAULT (MARGINS_UNITS * 3/4) // 3/4 inch default margins

class CImgWnd;

/***************************************************************************/

class CPrintResObj : public CObject
{
    DECLARE_DYNAMIC( CPrintResObj )

    public:

    CPrintResObj( CPBView* pView, CPrintInfo* pInfo );
    ~CPrintResObj();

    void BeginPrinting( CDC* pDC, CPrintInfo* pInfo );
    void PrepareDC    ( CDC* pDC, CPrintInfo* pInfo );
    BOOL PrintPage    ( CDC* pDC, CPrintInfo* pInfo );
    void EndPrinting  ( CDC* pDC, CPrintInfo* pInfo );

    // Attributes

    CPBView*  m_pView;
    LPVOID    m_pDIB;
    LPVOID    m_pDIBits;
    int       m_iZoom;
    CPalette* m_pDIBpalette;
    CSize     m_cSizeScroll;
    int       m_iPicWidth;
    int       m_iPicHeight;
    CRect     m_rtMargins;
    CPoint    m_PhysicalOrigin;
    CSize     m_PhysicalScaledImageSize;
    CSize     m_PhysicalPageSize;
    int       m_nPagesWide;
};

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\printres.cpp ===
// printres.cpp : implementation of the CPrintResObj class
//
// #define PAGESETUP

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "pbrusdoc.h"
#include "imgwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "printres.h"
#include "cmpmsg.h"
#include "imageatt.h"
#include "pgsetup.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CPrintResObj, CObject )

#include "memtrace.h"

void MulDivRect(LPRECT r1, LPRECT r2, int num, int div)
{
        r1->left = MulDiv(r2->left, num, div);
        r1->top = MulDiv(r2->top, num, div);
        r1->right = MulDiv(r2->right, num, div);
        r1->bottom = MulDiv(r2->bottom, num, div);
}

/***************************************************************************/
// CPrintResObj implementation

CPrintResObj::CPrintResObj( CPBView* pView, CPrintInfo* pInfo )
{
    m_pDIB        = NULL;
    m_pDIBpalette = NULL;

    if (pInfo                                  == NULL
    ||  pView                                  == NULL
    ||  pView->m_pImgWnd                       == NULL
    ||  pView->m_pImgWnd->m_pImg               == NULL
    ||  pView->m_pImgWnd->m_pImg->m_pBitmapObj == NULL)
        return;

    m_pView = pView;

    m_iPicWidth  = m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_nWidth;
    m_iPicHeight = m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_nHeight;

    //  force the resource to save itself then use the dib to print
    BOOL bOldFlag = m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_bDirty;
    m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_bDirty = TRUE;
    m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->SaveResource( TRUE );
    m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_bDirty = bOldFlag;

    m_pDIB = GlobalLock(m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_hThing);

    if (m_pDIB == NULL)
        return;

    m_pDIBpalette = CreateDIBPalette( (LPSTR)m_pDIB );
    m_pDIBits     = FindDIBBits     ( (LPSTR)m_pDIB );

    // save the scroll value off, then set to 0,0
    m_cSizeScroll = m_pView->m_pImgWnd->GetScrollPos();

    // save the zoom value off, then set to 100%
    m_iZoom      = m_pView->m_pImgWnd->GetZoom();
    m_rtMargins.SetRectEmpty();

    pInfo->m_nNumPreviewPages = 1;
    pInfo->m_lpUserData       = this;
}

/***************************************************************************/

CPrintResObj::~CPrintResObj()
{
    GlobalUnlock(m_pView->m_pImgWnd->m_pImg->m_pBitmapObj->m_hThing);
}

/***************************************************************************/

void CPrintResObj::BeginPrinting( CDC* pDC, CPrintInfo* pInfo )
{
    if (pDC               == NULL
    ||  pDC->GetSafeHdc() == NULL)
        return;

    m_pView->m_pImgWnd->SetScroll( 0, 0 );
    m_pView->m_pImgWnd->SetZoom  ( 1 );

    // get device sizes

    int nHorzRes = pDC->GetDeviceCaps(HORZRES);
    int nVertRes = pDC->GetDeviceCaps(VERTRES);

    int nHorzSize = pDC->GetDeviceCaps(HORZSIZE);
    int nVertSize = pDC->GetDeviceCaps(VERTSIZE);

    int nPhysicalWidth = pDC->GetDeviceCaps(PHYSICALWIDTH);
    int nPhysicalHeight = pDC->GetDeviceCaps(PHYSICALHEIGHT);

    int nPhysicalOffsetX = pDC->GetDeviceCaps(PHYSICALOFFSETX);
    int nPhysicalOffsetY = pDC->GetDeviceCaps(PHYSICALOFFSETY);

    // calculate min margins in pixels

    double cOutputXPelsPerMeter = (double) nHorzRes * 1000 / nHorzSize;
    double cOutputYPelsPerMeter = (double) nVertRes * 1000 / nVertSize;

    CRect rcMinMargins;

    rcMinMargins.left   = nPhysicalOffsetX;
    rcMinMargins.top    = nPhysicalOffsetY;
    rcMinMargins.right  = nPhysicalWidth  - nHorzRes - nPhysicalOffsetX;
    rcMinMargins.bottom = nPhysicalHeight - nVertRes - nPhysicalOffsetY;

    m_rtMargins.left   = max(0, (LONG) (theApp.m_rectMargins.left * cOutputXPelsPerMeter / 100000)   - rcMinMargins.left  );
    m_rtMargins.top    = max(0, (LONG) (theApp.m_rectMargins.top * cOutputYPelsPerMeter / 100000)    - rcMinMargins.top   );
    m_rtMargins.right  = max(0, (LONG) (theApp.m_rectMargins.right * cOutputXPelsPerMeter / 100000)  - rcMinMargins.right );
    m_rtMargins.bottom = max(0, (LONG) (theApp.m_rectMargins.bottom * cOutputYPelsPerMeter / 100000) - rcMinMargins.bottom);

    // Quick sanity check

    if (m_rtMargins.left + m_rtMargins.right >= nHorzRes)
    {
        m_rtMargins.left = m_rtMargins.right = 0;
    }

    if (m_rtMargins.top + m_rtMargins.bottom >= nVertRes)
    {
        m_rtMargins.top = m_rtMargins.bottom = 0;
    }

    CPageSetupData PageSetupData;

    PageSetupData.bCenterHorizontally = theApp.m_bCenterHorizontally;
    PageSetupData.bCenterVertically   = theApp.m_bCenterVertically;
    PageSetupData.bScaleFitTo         = theApp.m_bScaleFitTo;
    PageSetupData.nAdjustToPercent    = theApp.m_nAdjustToPercent;
    PageSetupData.nFitToPagesWide     = theApp.m_nFitToPagesWide;
    PageSetupData.nFitToPagesTall     = theApp.m_nFitToPagesTall;

    double cInputXPelsPerMeter = m_pView->m_pImgWnd->m_pImg->cXPelsPerMeter ? 
        m_pView->m_pImgWnd->m_pImg->cXPelsPerMeter : theApp.ScreenDeviceInfo.ixPelsPerDM * 10;

    double cInputYPelsPerMeter = m_pView->m_pImgWnd->m_pImg->cYPelsPerMeter ? 
        m_pView->m_pImgWnd->m_pImg->cYPelsPerMeter : theApp.ScreenDeviceInfo.iyPelsPerDM * 10;

    PageSetupData.fPhysicalImageWidth  = (double) m_iPicWidth * cOutputXPelsPerMeter / cInputXPelsPerMeter;
    PageSetupData.fPhysicalImageHeight = (double) m_iPicHeight * cOutputYPelsPerMeter / cInputYPelsPerMeter;

    m_PhysicalPageSize.cx = pDC->GetDeviceCaps(HORZRES) - m_rtMargins.left - m_rtMargins.right;
    m_PhysicalPageSize.cy = pDC->GetDeviceCaps(VERTRES) - m_rtMargins.top - m_rtMargins.bottom;

    PageSetupData.CalculateImageRect(m_PhysicalPageSize, m_PhysicalOrigin, m_PhysicalScaledImageSize);

    m_nPagesWide = PageSetupData.nFitToPagesWide;

    int nPages = PageSetupData.nFitToPagesWide * PageSetupData.nFitToPagesTall;

    pInfo->SetMaxPage(nPages);

    // If only printing 1 page, should not be in 2 page mode
    if (nPages == 1)
    {
        pInfo->m_nNumPreviewPages = 1;
    }
}

/******************************************************************************/
/* We not only move the window origin to allow us to print multiple pages      */
/* wide but we also scale both the viewport and window extents to make them   */
/* proportional (i.e. a line on the screen is the same size as on             */
/* the printer). The pages to print are numbered across.  For      +---+---+  */
/* example, if there  were 4 pages to print, then the first row    | 1 | 2 |  */
/* would have pages 1,2 and the second row would  have pages 3,4.  +---+---+  */
/*                                                                 | 3 | 4 |  */
/*                                                                 +---+---+  */
/*                                                                            */
/******************************************************************************/

void CPrintResObj::PrepareDC( CDC* pDC, CPrintInfo* pInfo )
{
    if (pDC == NULL || pInfo == NULL)
        return;

    pDC->SetMapMode( MM_TEXT );
    pDC->SetStretchBltMode( HALFTONE );
}

/***************************************************************************/

BOOL CPrintResObj::PrintPage( CDC* pDC, CPrintInfo* pInfo )
{
    if (m_pDIB == NULL)
        return FALSE;

    int nPageCol = (pInfo->m_nCurPage - 1) % m_nPagesWide;
    int nPageRow = (pInfo->m_nCurPage - 1) / m_nPagesWide;

    int nX0 = m_PhysicalOrigin.x - nPageCol * m_PhysicalPageSize.cx;
    int nY0 = m_PhysicalOrigin.y - nPageRow * m_PhysicalPageSize.cy;

    CRect OutputImageRect;

    OutputImageRect.left   = max(nX0, 0);
    OutputImageRect.top    = max(nY0, 0);
    OutputImageRect.right  = min(nX0 + m_PhysicalScaledImageSize.cx, m_PhysicalPageSize.cx);
    OutputImageRect.bottom = min(nY0 + m_PhysicalScaledImageSize.cy, m_PhysicalPageSize.cy);

    if (OutputImageRect.right < 0 || OutputImageRect.bottom < 0)
    {
        return TRUE;
    }

    CRect InputImageRect;

    InputImageRect.left   = MulDiv(OutputImageRect.left - nX0,   m_iPicWidth,  m_PhysicalScaledImageSize.cx);
    InputImageRect.top    = MulDiv(OutputImageRect.top - nY0,    m_iPicHeight, m_PhysicalScaledImageSize.cy);
    InputImageRect.right  = MulDiv(OutputImageRect.right - nX0,  m_iPicWidth,  m_PhysicalScaledImageSize.cx);
    InputImageRect.bottom = MulDiv(OutputImageRect.bottom - nY0, m_iPicHeight, m_PhysicalScaledImageSize.cy);

    if (InputImageRect.right < 0 || InputImageRect.bottom < 0)
    {
        return TRUE;
    }

    CPalette* ppalOld = NULL;

    if (m_pDIBpalette != NULL)
    {
        ppalOld = pDC->SelectPalette( m_pDIBpalette, FALSE );
        pDC->RealizePalette();
    }

    int nResult = StretchDIBits(
        pDC->m_hDC, 
        m_rtMargins.left + OutputImageRect.left, 
        m_rtMargins.top + OutputImageRect.top,
        OutputImageRect.Width(), 
        OutputImageRect.Height(),
        InputImageRect.left, 
        m_iPicHeight - InputImageRect.bottom, // DIB's are upside down
        InputImageRect.Width(), 
        InputImageRect.Height(),
        m_pDIBits, (LPBITMAPINFO)m_pDIB, 
        DIB_RGB_COLORS, SRCCOPY
    );

    if (nResult == GDI_ERROR)
    {
        CmpMessageBox( IDS_ERROR_PRINTING, AFX_IDS_APP_TITLE, MB_OK | MB_ICONEXCLAMATION );
    }

    if (ppalOld != NULL)
    {
        pDC->SelectPalette( ppalOld, FALSE );
    }

    return TRUE;
}

/***************************************************************************/

void CPrintResObj::EndPrinting( CDC* pDC, CPrintInfo* pInfo )
{
    if (pDC != NULL)
    {
        m_pView->m_pImgWnd->SetScroll( m_cSizeScroll.cx, m_cSizeScroll.cy );

        // restore the zoom value
        m_pView->m_pImgWnd->SetZoom( m_iZoom );
    }

    if (m_pDIBpalette != NULL)
        delete m_pDIBpalette;

    delete this;
}

/***************************************************************************/

inline int roundleast(int n)
{
        int mod = n%10;
        n -= mod;
        if (mod >= 5)
                n += 10;
        else if (mod <= -5)
                n -= 10;
        return n;
}

static void RoundRect(LPRECT r1)
{
        r1->left = roundleast(r1->left);
        r1->right = roundleast(r1->right);
        r1->top = roundleast(r1->top);
        r1->bottom = roundleast(r1->bottom);
}

void CPBView::OnFilePageSetup()
{
    CPageSetupDialog dlg;
    PAGESETUPDLG& psd = dlg.m_psd;
    TCHAR szMetric[2];
    BOOL bMetric;
    LCID lcidThread;
    //
    // We should use metric if the user has chosen CM in the
    // Image Attributes dialog, OR if using Pels and the NLS
    // setting is for metric
    //
    if (theApp.m_iCurrentUnits == ePIXELS)
    {
       lcidThread = GetThreadLocale();
       GetLocaleInfo (lcidThread, LOCALE_IMEASURE, szMetric, 2);
       bMetric = (szMetric[0] == TEXT('0'));
    }
    else
    {
       bMetric = ((eUNITS)theApp.m_iCurrentUnits == eCM); //centimeters
    }

    CPageSetupData PageSetupData;

    PageSetupData.bCenterHorizontally = theApp.m_bCenterHorizontally;
    PageSetupData.bCenterVertically   = theApp.m_bCenterVertically;
    PageSetupData.bScaleFitTo         = theApp.m_bScaleFitTo;
    PageSetupData.nAdjustToPercent    = theApp.m_nAdjustToPercent;
    PageSetupData.nFitToPagesWide     = theApp.m_nFitToPagesWide;
    PageSetupData.nFitToPagesTall     = theApp.m_nFitToPagesTall;

    double cXPelsPerMeter = m_pImgWnd->m_pImg->cXPelsPerMeter ? 
        m_pImgWnd->m_pImg->cXPelsPerMeter : theApp.ScreenDeviceInfo.ixPelsPerDM * 10;
    double cYPelsPerMeter = m_pImgWnd->m_pImg->cYPelsPerMeter ? 
        m_pImgWnd->m_pImg->cYPelsPerMeter : theApp.ScreenDeviceInfo.iyPelsPerDM * 10;

    PageSetupData.fPhysicalImageWidth = (double)m_pImgWnd->m_pImg->cxWidth * 100000 / cXPelsPerMeter;
    PageSetupData.fPhysicalImageHeight = (double)m_pImgWnd->m_pImg->cyHeight * 100000 / cYPelsPerMeter;

    if (!bMetric)
    {
        PageSetupData.fPhysicalImageWidth /= 2.54;
        PageSetupData.fPhysicalImageHeight /= 2.54;
    }

    psd.Flags |= PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK | PSD_ENABLEPAGESETUPTEMPLATE | 
        PSD_MARGINS | (bMetric ? PSD_INHUNDREDTHSOFMILLIMETERS : PSD_INTHOUSANDTHSOFINCHES);
    int nUnitsPerInch = bMetric ? 2540 : 1000;
    MulDivRect(&psd.rtMargin, theApp.m_rectMargins, nUnitsPerInch, MARGINS_UNITS);
    RoundRect(&psd.rtMargin);
// get the current device from the app
    PRINTDLG pd;
    pd.hDevNames = NULL;
    pd.hDevMode = NULL;
    theApp.GetPrinterDeviceDefaults(&pd);
    psd.hDevNames = pd.hDevNames;
    psd.hDevMode = pd.hDevMode;
    psd.hInstance = AfxGetInstanceHandle();
    psd.lCustData = (LPARAM) &PageSetupData;
    psd.lpfnPagePaintHook = CPageSetupData::PagePaintHook;
    psd.lpfnPageSetupHook = CPageSetupData::PageSetupHook;
    psd.lpPageSetupTemplateName = MAKEINTRESOURCE(IDD_PAGESETUPDLG);

    if (dlg.DoModal() == IDOK)
    {
        RoundRect(&psd.rtMargin);
        MulDivRect(theApp.m_rectMargins, &psd.rtMargin, MARGINS_UNITS, nUnitsPerInch);
        //theApp.m_rectPageMargin = m_rectMargin;
        theApp.SelectPrinter(psd.hDevNames, psd.hDevMode);

        theApp.m_bCenterHorizontally = PageSetupData.bCenterHorizontally;
        theApp.m_bCenterVertically   = PageSetupData.bCenterVertically;
        theApp.m_bScaleFitTo         = PageSetupData.bScaleFitTo;
        theApp.m_nAdjustToPercent    = PageSetupData.nAdjustToPercent;
        theApp.m_nFitToPagesWide     = PageSetupData.nFitToPagesWide;
        theApp.m_nFitToPagesTall     = PageSetupData.nFitToPagesTall;
    }

    // PageSetupDlg failed
//    if (CommDlgExtendedError() != 0)
//    {
       //
       //  nothing to handle this failure
       //
//    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\rotate.cpp ===
/****************************************************************************
 ROTATE.c

 The ROTATE module handles rotating a rectangular object.

****************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgsuprt.h"
#include "bmobject.h"
#include "undo.h"
#include "props.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

/***************************************************************************/

void CImgWnd::CmdRot90()
    {
    HideBrush();

    CRect     rotRect;
    HDC       hdcSrc;
    CPalette* ppalOld = NULL;

    if (! theImgBrush.m_pImg && ! g_bCustomBrush)
        {
        rotRect.SetRect( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight );

        hdcSrc = m_pImg->hDC;
        }
    else
        {
        PrepareForBrushChange( TRUE, TRUE );

        ppalOld = SetImgPalette( &theImgBrush.m_dc );

        hdcSrc = theImgBrush.m_dc.GetSafeHdc();

        rotRect         = rcDragBrush;
        rotRect.right  -= 1;
        rotRect.bottom -= 1;
        }

    ASSERT( hdcSrc != NULL);

    if (rotRect.IsRectEmpty() || ! hdcSrc)
        {
        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

        return;
        }

    int iWidth  = rotRect.Width();
    int iHeight = rotRect.Height();

    CRect destRect( 0, 0, iHeight, iWidth );

    destRect.OffsetRect( rotRect.left + iWidth  / 2 - iHeight / 2,
                         rotRect.top  + iHeight / 2 - iWidth  / 2 );
    CBitmap bmRotated;
    CDC     dcRotated;
    CDC*    pdcImg = CDC::FromHandle( m_pImg->hDC );

    if (! bmRotated.CreateCompatibleBitmap( pdcImg, iHeight, iWidth )
    ||  ! dcRotated.CreateCompatibleDC    ( pdcImg ))
        {
        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

        theApp.SetGdiEmergency( TRUE );
        return;
        }

    CBitmap*  pbmOld = dcRotated.SelectObject( &bmRotated );
    CPalette* ppalRotated = SetImgPalette( &dcRotated );

    BeginWaitCursor();

    int  iRow;
    int  iCol;
    BOOL bDone = FALSE;

    // Need code here to get select RECT from the hdcSrc
    HDC     rowDC  = ::CreateCompatibleDC    ( hdcSrc );
    HDC     colDC  = ::CreateCompatibleDC    ( hdcSrc );
    HBITMAP hrowBM = ::CreateCompatibleBitmap( hdcSrc, iWidth, 1 );
    HBITMAP hcolBM = ::CreateCompatibleBitmap( hdcSrc, 1, iWidth );

    if (rowDC && colDC && hrowBM && hcolBM)
        {
        HBITMAP scolBM  = (HBITMAP)::SelectObject( colDC, hcolBM );
        HBITMAP srowBM  = (HBITMAP)::SelectObject( rowDC, hrowBM );

        ::PatBlt( rowDC, 0, 0, iWidth, 1, BLACKNESS );
        ::PatBlt( colDC, 0, 0, 1, iWidth, BLACKNESS );

        HPALETTE hpalRow = SetImgPalette( rowDC ); // save to replace later
        HPALETTE hpalCol = SetImgPalette( colDC ); // save to replace later

        ::SelectObject( colDC, scolBM );
        ::SelectObject( rowDC, srowBM );

        DWORD dwLen;

        LPSTR lpDibRow = (LPSTR) DibFromBitmap( 
            hrowBM, DIB_RGB_COLORS, 24,
            theApp.m_pPalette, NULL, dwLen,
            m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter);

        LPSTR lpDibCol = (LPSTR) DibFromBitmap( 
            hcolBM, DIB_RGB_COLORS, 24,
            theApp.m_pPalette, NULL, dwLen,
            m_pImg->cXPelsPerMeter, m_pImg->cYPelsPerMeter);

        if (lpDibRow && lpDibCol)
            {
            VOID* pBitsRow = FindDIBBits( lpDibRow );
            VOID* pBitsCol = FindDIBBits( lpDibCol );

            for (iRow = 0, iCol = iHeight - 1; iRow < iHeight; iRow++, iCol--)
                {
                ::SelectObject( rowDC, hrowBM );
                ::BitBlt( rowDC, 0, 0, iWidth, 1, hdcSrc, 0, iRow, SRCCOPY );
                ::SelectObject( rowDC, srowBM );

                if (! GetDIBits( hdcSrc, hrowBM, 0, 1, pBitsRow, (LPBITMAPINFO)lpDibRow, DIB_RGB_COLORS ))
                    break;

                LPBYTE  pRow =  (LPBYTE)pBitsRow;
                LPDWORD pCol = (LPDWORD)pBitsCol;

                union
                    {
                    DWORD pixel;
                    char  byte[sizeof( DWORD )];
                    } u;

                u.byte[3] = 0;

                for (register int index = iWidth - 1; index >= 0; index--)
                    {
                    u.byte[0] = *pRow++;
                    u.byte[1] = *pRow++;
                    u.byte[2] = *pRow++;

                    pCol[index] = u.pixel;
                    }

                if (! SetDIBits( hdcSrc, hcolBM, 0, iWidth, pBitsCol, (LPBITMAPINFO)lpDibCol, DIB_RGB_COLORS ))
                    break;

                ::SelectObject( colDC, hcolBM );
                ::BitBlt( dcRotated.m_hDC, iCol, 0, 1, iWidth, colDC, 0, 0, SRCCOPY );
                ::SelectObject( colDC, scolBM );
                }

            bDone = (iRow == iHeight);

            if (! bDone)
                theApp.SetGdiEmergency( TRUE );
            }
        else
            theApp.SetMemoryEmergency( TRUE );

        if (lpDibRow)
            FreeDib( lpDibRow );

        if (lpDibCol)
            FreeDib( lpDibCol );

        if (hpalRow)
            ::SelectPalette( rowDC, hpalRow, FALSE );

        if (hpalCol)
            ::SelectPalette( colDC, hpalCol, FALSE );
        }
    else
        theApp.SetGdiEmergency( TRUE );

    // clean up
    if (rowDC)
        ::DeleteDC( rowDC );

    if (colDC)
        ::DeleteDC( colDC );

    if (hrowBM)
        ::DeleteObject( hrowBM );

    if (hcolBM)
        ::DeleteObject( hcolBM );

    EndWaitCursor();

    if (! bDone) // do the brute force method
        {
        if (ppalOld)
            theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

        if (ppalRotated)
            dcRotated.SelectPalette( ppalRotated, FALSE );

        dcRotated.SelectObject( pbmOld );
        dcRotated.DeleteDC();
        bmRotated.DeleteObject();
        return;
        }

    if (ppalOld)
        theImgBrush.m_dc.SelectPalette( ppalOld, FALSE );

    if (  theImgBrush.m_pImg
    &&  ! theImgBrush.m_bFirstDrag || g_bCustomBrush)
        {
        if (ppalRotated)
            dcRotated.SelectPalette( ppalRotated, FALSE );

        dcRotated.SelectObject( pbmOld );

        CBitmap bmMask;

        if (! bmMask.CreateBitmap( iHeight, iWidth, 1, 1, NULL ))
            {
            theApp.SetMemoryEmergency( TRUE );
            return;
            }

        theImgBrush.m_dc.SelectObject( &bmRotated );
        theImgBrush.m_bitmap.DeleteObject();
        theImgBrush.m_bitmap.Attach( bmRotated.Detach() );

        theImgBrush.m_size.cx = iHeight;
        theImgBrush.m_size.cy = iWidth;

        VERIFY( theImgBrush.m_maskDC.SelectObject( &bmMask ) ==
               &theImgBrush.m_maskBitmap );

        theImgBrush.m_maskBitmap.DeleteObject();
        theImgBrush.m_maskBitmap.Attach( bmMask.Detach() );
        theImgBrush.RecalcMask( crRight );

        MoveBrush( destRect );
        }
    else
        {
        theUndo.BeginUndo( TEXT("Resize Bitmap") );

        m_pImg->m_pBitmapObj->SetSizeProp( P_Size, CSize( iHeight, iWidth ) );

        m_pImg->cxWidth  = iHeight;
        m_pImg->cyHeight = iWidth;

        SetUndo( m_pImg );

        pdcImg->BitBlt( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight, &dcRotated, 0, 0, SRCCOPY );

        dcRotated.SelectObject( pbmOld );

        if (ppalRotated)
            dcRotated.SelectPalette( ppalRotated, FALSE );

        bmRotated.DeleteObject();

        InvalImgRect ( m_pImg, &rotRect );
        CommitImgRect( m_pImg, &rotRect );

        FinishUndo   ( rotRect );

        theUndo.EndUndo();

        DirtyImg     ( m_pImg );

        InvalidateRect( NULL );
        UpdateWindow();
        }

    dcRotated.DeleteDC();
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mspaint.rc
//
#define ID_EBOX_POPUPMENU_POS           0
#define ID_TOOL_POPUPMENU_POS           1
#define ID_MAINFRAME                    2
#define IDI_PAINT_DOC                   3
#define IDR_SRVR_INPLACE                4
#define IDR_SRVR_EMBEDDED               5
#define IDS_EXTENSION_BMP               6
#define IDS_EXTENSION_GIF               7
#define IDS_EXTENSION_JPEG              8
#define IDS_EXTENSION_ICO               9
#define IDS_EXTENSION_PCX               10
#define IDS_PCX_FILTER_NAME             11
#define IDS_ICO_FILTER_NAME             12
#define IDS_BMP_MONO                    13
#define IDS_BMP_16COLOR                 14
#define IDS_BMP_256COLOR                15
#define IDS_BMP_TRUECOLOR               16
#define IDS_EXTENSION_PCD               17
#define IDS_EXTENSION_PICT              18
#define IDS_TYPE_ALLFILES               19
#define IDS_PAL_FILETYPES               20
#define IDS_EXTENSION_PNG               21
#define IDS_EXTENSION_TGA               22
#define IDS_EXTENSION_TIFF              23
#define IDS_EXTENSION_PAL               24
#define IDS_PAL_UNTITLED                25
#define IDC_DITHER                      27
#define IDS_EXTENSION_DIB               28
#define IDS_EXTENSION_RLE               29
#define IDP_OLE_INIT_FAILED             30
#define ID_LISTCAPTION                  31
#define ID_LIST                         32
#define IDS_TYPE_ALLPICTURES            33
#define IDD_TEXT_FONT_DLG               37
#define IDB_TEXT_TBAR                   102
#define IDC_POINTSIZE                   103
#define IDC_TYPEFACE                    104
#define IDD_IMAGE_ATTRIBUTES            105
#define IDC_BOLD                        106
#define FONT_TT_BMP                     107
#define IDD_VIEW_ZOOM                   108
#define IDC_ITALIC                      109
#define ID_TEXT_PLACE                   110
#define FONT_PRN_BMP                    111
#define IDD_FLIP_ROTATE                 112
#define IDC_UNDERLINE                   112
#define IDC_SHADOW                      113
#define IDD_STRETCH_SKEW                113
#define IDR_TEXT_POPUP                  113
#define IDI_STRETCH_HORZ                114
#define IDC_ATTREDIT                    114
#define IDI_STRETCH_VERT                115
#define IDI_SKEW_HORZ                   116
#define IDI_SKEW_VERT                   117
#define IDR_SELECTION_POPUP             118
#define IDR_THUMBNAIL_POPUP             119
#define IDC_PENEXT                      120
#define IDC_EDITTEXT                    121
#define IDC_KEYBOARD                    122
#define IDC_INS_SPACE                   123
#define IDC_BACKSPACE                   124
#define IDC_NEWLINE                     125
#define IDR_PBRUSHTYPE                  129
#define IDD_COLORTABLE                  132
#define IDD_PAGESETUPDLG                133
#define IDBM_COMPWELL                   134
#define IDC_HSPLIT                      135
#define IDC_VERTEDIT                    136
#define TT_OPENTYPE_BMP                 137
#define PS_OPENTYPE_BMP                 138
#define TYPE1_BMP                       139
#define IDC_CHARSET                     140
#define STRINGARRAYSIZE                 240
#define IDC_WIDTH                       264
#define IDC_HEIGHT                      266
#define IDC_DEFAULT                     280
#define IDC_3STATE                      293
#define IDMB_ARROW                      599
#define IDMB_PICKTOOL                   620
#define IDMB_PICKRGNTOOL                621
#define IDMX_TEXTTOOL                   622
#define IDMB_FILLTOOL                   623
#define IDMB_LINETOOL                   624
#define IDMB_AIRBSHTOOL                 627
#define IDMB_CURVETOOL                  628
#define IDMB_POLYGONTOOL                632
#define IDMB_RNDRECTTOOL                634
#define IDMB_FRNDRECTTOOL               635
#define IDMB_PENCILTOOL                 636
#define IDMB_ERASERTOOL                 637
#define IDMB_ZOOMTOOL                   638
#define IDMY_PICKCOLOR                  639
#define IDMB_CBRUSHTOOL                 640
#define IDMB_RECTTOOL                   641
#define IDMB_FRECTTOOL                  642
#define IDMB_ELLIPSETOOL                643
#define IDMB_FELLIPSETOOL               644
#define IDMB_USERBTN                    700
#define IDC_CMDMESSAGE_CAP              722
#define IDC_TILEGRID                    727
#define IDC_PIXELGRID                   728
#define IDB_ELLIPSE1                    851
#define IDB_ELLIPSE2                    852
#define IDB_ELLIPSE3                    853
#define IDB_ELLIPSE4                    854
#define IDB_ELLIPSE5                    855
#define IDB_ELLIPSE6                    856
#define IDB_ELLIPSE7                    857
#define IDB_ELLIPSE8                    858
#define IDB_IMGTOOLS                    859
#define IDB_MAINTOOLS                   860
#define IDB_ZOOMOPT                     862
#define IDB_SELOPT                      863
#define IDB_AIROPT                      864
#define IDS_UNABLE_TO_PASTE             1000
#define IDC_STRETCH_HORZ_PERCENT        1019
#define IDC_STRETCH_VERT_PERCENT        1020
#define IDC_SKEW_HORZ_DEGREES           1021
#define IDC_SKEW_VERT_DEGREES           1022
#define IDC_INCHES                      1028
#define IDC_CENTIMETERS                 1029
#define IDC_PIXELS                      1030
#define IDC_WIDTH_STATIC                1050
#define IDC_HEIGHT_STATIC               1051
#define IDC_UNITS_GROUP                 1052
#define IDC_COLORS_GROUP                1053
#define IDC_PAINT_FLIP_GROUP            1054
#define IDC_STRETCH_HORZ_ICON           1055
#define IDC_STRETCH_VERT_ICON           1056
#define IDC_SKEW_HORZ_ICON              1057
#define IDC_SKEW_VERT_ICON              1058
#define IDC_SKEW_GROUP                  1059
#define IDC_STRETCH_GROUP               1060
#define IDC_STRETCH_HORZ_SUFFIX         1061
#define IDC_STRETCH_VERT_SUFFIX         1062
#define IDC_SKEW_HORZ_SUFFIX            1063
#define IDC_SKEW_VERT_SUFFIX            1064
#define IDC_CURRENT_ZOOM_STATIC         1065
#define IDC_ZOOM_GROUP                  1066
#define IDC_TRANS_GROUP                 1067
#define IDC_USE_TRANS                   1068
#define IDC_SELECT_COLOR                1069
#define IDC_TRANS_PAINT                 1070
#define IDC_FILEDATE_STATIC             1071
#define IDC_FILESIZE_STATIC             1072
#define IDC_RESOLUTION_STATIC           1073
#define IDC_MONOCHROME                  1079
#define IDC_COLORS                      1080
#define IDC_CURRENT_ZOOM                1081
#define IDC_ZOOM_100                    1082
#define IDC_ZOOM_200                    1083
#define IDC_ZOOM_400                    1084
#define IDC_ZOOM_600                    1085
#define IDC_ZOOM_800                    1086
#define IDC_HORIZONTAL                  1087
#define IDC_VERTICAL                    1088
#define IDC_BY_ANGLE                    1089
#define IDC_90_DEG                      1090
#define IDC_180_DEG                     1091
#define IDC_270_DEG                     1092
#define IDC_STRETCH_HORZ                1093
#define IDC_STRETCH_VERT                1094
#define IDC_SKEW_HORZ                   1095
#define IDC_SKEW_VERT                   1096
#define IDC_COLORLIST                   1099
#define IDC_DRAGTOOL                    1100
#define IDC_BRUSH                       1201
#define IDC_BULLSEYE                    1202
#define IDC_CROSSHAIR                   1203
#define IDC_EYEDROP                     1204
#define IDC_FLOOD                       1205
#define IDC_PENCIL                      1206
#define IDC_ZOOMIN                      1207
#define IDC_CENTER                      1210
#define IDC_HORIZONTALLY                1211
#define IDC_VERTICALLY                  1212
#define IDC_SCALING                     1213
#define IDC_ADJUST_TO                   1214
#define IDC_FIT_TO                      1215
#define IDC_PERCENT_NORMAL_SIZE         1216
#define IDC_STR_PERCENT_NORMAL_SIZE     1217
#define IDC_PAGES_WIDE                  1218
#define IDC_STR_PAGES_WIDE              1219
#define IDC_PAGES_TALL                  1220
#define IDC_STR_PAGES_TALL              1221
#define IDS_ERROR_OPEN                  2051
#define IDS_ERROR_READLOAD              2052
#define IDS_ERROR_SAVERO                2054
#define IDS_ERROR_COMPEX                2056
#define IDS_ERROR_RCPROB                2062
#define IDS_ERROR_WHAAAT                2064
#define IDS_ERROR_SAVEOVEROPEN          2067
#define IDS_ERROR_NOTVALID_RC           2080
#define IDS_ERROR_NOTVALID_EXE          2081
#define IDS_ERROR_NOTVALID_RES          2082
#define IDS_ERROR_NOTVALID_BMP          2083
#define IDS_ERROR_NOTVALID_ICO          2084
#define IDS_ERROR_NOTVALID_CUR          2085
#define IDS_ERROR_SAVE_ABORTED          2090
#define IDS_ERROR_NT_RES                2091
#define IDS_ERROR_CANT_SAVERO           2092
#define IDS_ERROR_EXE_INUSE             2096
#define IDS_ERROR_EXE_EMPTY             2097
#define IDS_ERROR_EXE_HDR               2100
#define IDS_ERROR_EXE_HDRMZ             2102
#define IDS_ERROR_EXE_HDRWV             2104
#define IDS_ERROR_EXE_HDRNW             2105
#define IDS_ERROR_EXE_SAVE              2106
#define IDS_ERROR_EXE_ALIGN             2107
#define IDS_ERROR_EXE_ALLOC             2108
#define IDS_ERROR_RES_SAVE              2109
#define IDS_ERROR_SAVE                  2110
#define IDS_ERROR_SAMENAME              2152
#define IDS_ERROR_GRIDRANGE             2210
#define IDS_ERROR_NOMEMORY              2240
#define IDS_ERROR_LOWMEMORY             2241
#define IDS_ERROR_GROUP                 2247
#define IDS_ERROR_PRINTING              2248
#define IDS_WARNING_COLORSAVE           2297
#define IDS_WARNING_MONO                2298
#define IDS_ERROR_BITMAPSIZE            2299
#define IDS_ERROR_FILE                  2300
#define IDS_ERROR_CLIPBOARD             2445
#define IDS_ERROR_NOPRINTER             2446
#define IDS_ERROR_SELECT_SCAN           2447
#define IDS_ERROR_SCAN_NEW              2448
#define IDS_DOWNLOAD_IMAGE              2449
#define IDS_STATUS_TRANSFER_FROM_DEVICE 2450
#define IDS_STATUS_PROCESSING_DATA      2451
#define IDS_STATUS_TRANSFER_TO_CLIENT   2452
#define IDB_SBSIZE                      3550
#define IDB_SBPOS                       3551
#define IDD_IMGGRIDOPT                  4001
#define IDD_GETPALETTE                  4007
#define IDS_UNDO                        4013
#define IDS_REDO                        4014
#define IDMX_SMALLERBRUSH               6810
#define IDMX_LARGERBRUSH                6811
#define IDMZ_BRUSHTOOL                  6816
#define IDMX_SEL2BSH                    6861
#define IDM_TGLOPAQUE                   6868
#define IDM_EDITCOLORS                  6869
#define IDM_LOADCOLORS                  6870
#define IDM_SAVECOLORS                  6871
#define IDS_MUST_SAVE_WALLPAPER         7057
#define IDMX_VS_PAGEDOWN                8000
#define IDMX_HS_PAGEDOWN                8001
#define IDMX_VS_PAGEUP                  8002
#define IDMX_HS_PAGEUP                  8003
#define IDCUR_MOVE                      8012
#define IDBM_DRAGHANDLE                 8021
#define IDBM_DRAGHANDLE2                8022
#define IDB_EMPTYPALETTE                8023
#define IDB_BUTTONBAR                   8024
#define IDCUR_SIZENWSE                  8025
#define IDCUR_SIZENESW                  8026
#define IDCUR_SIZEWE                    8027
#define IDCUR_SIZENS                    8028
#define IDCUR_AIRBRUSH                  8029
#define IDCUR_HIBEAM                    8030
#define IDS_ENLAGEBITMAPFORSTRETCH      9233
#define IDS_ENLAGEBITMAPFORCLIP         9234
#define IDC_EDIT                        9235
#define IDC_ADJUST                      9236
#define IDC_REDUCE                      9237
#define IDC_RED                         9238
#define IDC_GREEN                       9239
#define IDC_BLUE                        9240
#define IDC_HUE                         9241
#define IDC_SAT                         9242
#define IDC_LUM                         9243
#define IDD_COLORMAKER                  9244
#define IDC_RAINBOW                     9245
#define IDC_LUMSCROLL                   9246
#define IDC_CURRENT                     9247
#define IDS_ERROR_BOGUSFILE             10015
#define ID_WND_GRAPHIC                  32514
#define ID_TEXT_PLAIN                   32776
#define ID_TEXT_BOLD                    32777
#define ID_TEXT_ITALIC                  32778
#define ID_TEXT_SELECTFONT              32780
#define ID_TEXT_SELECTPOINTSIZE         32781
#define ID_TEXT_UNDERLINE               32789
#define ID_TOOLBAR_SHOWTOOLTIPS         32791
#define ID_TOOLBAR_HELP                 32792
#define ID_FILE_CHOOSE_PRINTER          37661
#define ID_FILE_SEND                    37662
#define ID_EDIT_COPY_TO                 37663
#define ID_EDIT_PASTE_FROM              37664
#define ID_FILE_SELECT_SOURCE           37665
#define ID_FILE_SCAN_NEW                37666
#define ID_VIEW_ZOOM_100                37670
#define ID_VIEW_ZOOM_400                37671
#define ID_VIEW_ZOOM                    37672
#define ID_VIEW_VIEW_PICTURE            37673
#define ID_VIEW_THUMBNAIL               37676
#define ID_VIEW_GRID                    37677
#define ID_VIEW_TEXT_TOOLBAR            37678
#define ID_IMAGE_FLIP_ROTATE            37680
#define ID_IMAGE_STRETCH_SKEW           37681
#define ID_IMAGE_INVERT_COLORS          37682
#define ID_IMAGE_ATTRIBUTES             37683
#define ID_IMAGE_CLEAR_IMAGE            37684
#define IDS_ERROR_FONTSIZENUMERIC       37685
#define IDS_FILEMENUHELP                37686
#define IDS_EDITMENUHELP                37687
#define IDS_VIEWMENUHELP                37688
#define IDS_IMAGEMENUHELP               37689
#define IDS_OPTIONSMENUHELP             37690
#define IDS_HELPMENUHELP                37691
#define IDS_ERROR_EXPORT                41747
#define IDS_ERROR_CANTREMOVE            41748
#define IDS_LOAD_PALETTE_COLORS         41749
#define IDS_QUERY_MKDIR                 41750
#define IDS_SAVE_PALETTE_COLORS         41750
#define IDS_EDIT_COLORS                 41751
#define IDS_EDIT_COPY_TO                41752
#define IDS_EDIT_PASTE_FROM             41753
#define IDS_SELECT_COLOR                41754
#define IDS_FILEDATE_NA                 41755
#define IDS_FILESIZE_NA                 41756
#define IDS_FILEDATE                    41757
#define IDS_FILESIZE                    41758
#define IDS_RESOLUTION_NA               41759
#define IDS_RESOLUTION                  41760
#define IDS_UNDO_PAINTING               42047
#define IDCS_BITMAP                     44036
#define IDS_COLORS                      44108
#define IDS_FONT_TOOL                   44109
#define IDS_VIEW                        44111
#define IDS_PAINT_TOOL                  44112
#define IDS_PerContractSoDontChange     44227
#define IDS_PerContractSoDontChange2    44228
#define IDS_SIZE_SEPARATOR              44700
#define IDS_POS_SEPARATOR               44701
#define ID_FILE_SETASWALLPAPER_C        57675
#define ID_FILE_SETASWALLPAPER_T        57677
#define ID_SELECTION_SENDTO             57683
#define ID_SELECTION_PRINTTO            57684
#define ID_THUMBNAIL_THUMBNAIL          57689
#define ID_THUMBNAIL_HELP               57690
#define IDS_REGISTRY_PATH               57691
#define ID_ESCAPE                       57692
#define ID_ESCAPE_SERVER                57693
#define ID_VIEW_TOOL_BOX                59415
#define ID_VIEW_COLOR_BOX               59416
#define IDS_ERROR_DBCSFONTONLY          59417
#define IDS_PAINTBRUSHPICTURE           59418
#define IDS_BITMAPIMAGE                 59419
#define IDS_HOTKEY_EDIT                 59420
#define IDS_HOTKEY_OPEN                 59421
#define IDS_FORMATERR_FILE              59500
#define IDS_FORMATERR_NOFILE            59501

#define ID_STATIC                       -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        142
#define _APS_NEXT_COMMAND_VALUE         59502
#define _APS_NEXT_CONTROL_VALUE         1074
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\saveimag.cpp ===
//
// saveimag.cpp
//
// implementation of saving a file to disk via an installed graphic filter
//
#include "stdafx.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "loadimag.h"
#include "saveimag.h"
#include "bmpstrm.h"
#include "imaging.h"

#include <atlbase.h>

#ifdef _X86_
#define _USE_IFL_API
#endif

extern BOOL GetHandlerForFile(BOOL bImport,LPCSTR szFile,
                              LPSTR szHandler,
                              UINT cb);           // defined in loadimag.cpp


inline RGBTRIPLE GetPalEntry(LPVOID lpPal3, BYTE index)
{
        RGBTRIPLE rgb;

        rgb.rgbtRed   = ((RGBTRIPLE *)lpPal3 + index)->rgbtRed;
        rgb.rgbtGreen = ((RGBTRIPLE *)lpPal3 + index)->rgbtGreen;
        rgb.rgbtBlue  = ((RGBTRIPLE *)lpPal3 + index)->rgbtBlue;

        return rgb;
}

inline void ConvertPalette(int bitCount, LPBYTE lpBuf, int width)
{
        int j;

        switch (bitCount)
        {
                case 4:
                        for (j=0; j<width; j++)
                        {
                                *(lpBuf+(width-1-j)*2+1) = (*(lpBuf+width-1-j) & 0x0f);
                                *(lpBuf+(width-1-j)*2)   = (*(lpBuf+width-1-j) & 0xf0) >> 4;
                        }
                        break;

                case 1:
                        for (j=0; j<width; j++)
                        {
                                *(lpBuf+(width-1-j)*8+7) = (*(lpBuf+width-1-j) & 0x1);
                                *(lpBuf+(width-1-j)*8+6) = (*(lpBuf+width-1-j) & 0x2)  >> 1;
                                *(lpBuf+(width-1-j)*8+5) = (*(lpBuf+width-1-j) & 0x4)  >> 2;
                                *(lpBuf+(width-1-j)*8+4) = (*(lpBuf+width-1-j) & 0x8)  >> 3;
                                *(lpBuf+(width-1-j)*8+3) = (*(lpBuf+width-1-j) & 0x10) >> 4;
                                *(lpBuf+(width-1-j)*8+2) = (*(lpBuf+width-1-j) & 0x20) >> 5;
                                *(lpBuf+(width-1-j)*8+1) = (*(lpBuf+width-1-j) & 0x40) >> 6;
                                *(lpBuf+(width-1-j)*8)   = (*(lpBuf+width-1-j) & 0x80) >> 7;
                        }
                        break;

                default:
                        // impossible!!!
                        break;
        }
}

inline BYTE SearchPalette(COLORREF crColor, LPVOID lpPal3)
{
        BYTE byRed   = GetRValue( crTrans );
        BYTE byGreen = GetGValue( crTrans );
        BYTE byBlue  = GetBValue( crTrans );

        for (int i = 0; i < MAX_PALETTE_COLORS; i++)
        {
                // note that we have to switch the colors back before
                // attempting to compare them!!
                if (byRed   == ((RGBTRIPLE *)lpPal3 + i)->rgbtBlue  &&
                        byGreen == ((RGBTRIPLE *)lpPal3 + i)->rgbtGreen &&
                        byBlue  == ((RGBTRIPLE *)lpPal3 + i)->rgbtRed)
                        return (BYTE)i;
        }

        // shouldn't reach here!!
        // (the color being searched must be in the palette)
        return 0;
}

BOOL SaveDIBToFileA( LPCSTR  szFileName,
                     REFGUID guidFormatID,
                     CBitmapObj* pBitmap )
{
    IFLTYPE iflType;

    if (guidFormatID == WiaImgFmt_GIF)
    {
        iflType = IFLT_GIF;
    }
    else if (guidFormatID == WiaImgFmt_BMP)
    {
        iflType = IFLT_BMP;
    }
    else if (guidFormatID == WiaImgFmt_JPEG)
    {
        iflType = IFLT_JPEG;
    }
    else if (guidFormatID == WiaImgFmt_TIFF)
    {
        iflType = IFLT_TIFF;
    }
    else if (guidFormatID == WiaImgFmt_PNG)
    {
        iflType = IFLT_PNG;
    }
    else if (guidFormatID == WiaImgFmt_PHOTOCD)
    {
        iflType = IFLT_PCD;
    }
    else
    {
        return FALSE;
    }

   #ifdef  _USE_IFL_API
        LPBITMAPINFOHEADER lpDib = (LPBITMAPINFOHEADER) GlobalLock(pBitmap->m_hThing);

        IFLCLASS iflClass = (lpDib->biBitCount == 24) ? IFLCL_RGB : IFLCL_PALETTE;
        int iBPS = 8; // bits per sample

        if (iflType == IFLT_JPEG)
                // force it to be RGB type, otherwise the JPEG filter won't take it
                iflClass = IFLCL_RGB;

        if (iflType == IFLT_GIF && iflClass == IFLCL_RGB)
        {
                GlobalUnlock(pBitmap->m_hThing);

                // force it to be PALETTE type, otherwise the GIF filter won't take it
                iflClass = IFLCL_PALETTE;

                // Now convert the image from RGB to palette-based. Note that
                // the call to DibFromBitmap() will allocate new memory!!
                DWORD dwSize;
                lpDib = (LPBITMAPINFOHEADER) DibFromBitmap(
                        pBitmap->m_pImg->hBitmap, BI_RGB, (WORD) iBPS,
                        pBitmap->m_pImg->m_pPalette, NULL, dwSize,
                        pBitmap->m_pImg->cXPelsPerMeter, pBitmap->m_pImg->cYPelsPerMeter);

                if (lpDib == NULL)
                        return FALSE;   // memory allocation failed

                // now replace the original
                pBitmap->Free();
                pBitmap->m_hThing   = lpDib;
                pBitmap->m_lMemSize = dwSize;
                lpDib = (LPBITMAPINFOHEADER) GlobalLock(pBitmap->m_hThing);
        }


        IFLCOMPRESSION iflCompression = IFLCOMP_DEFAULT; // or IFLCOMP_NONE ???

        IFLHANDLE iflHandle = iflCreateWriteHandle(lpDib->biWidth, lpDib->biHeight,
                iflClass, iBPS, iflCompression, iflType);

        if (iflHandle == NULL)
        {
                GlobalUnlock(pBitmap->m_hThing);
                return FALSE;
        }

        IFLERROR iflErr = iflOpen(iflHandle, (LPSTR)szFileName, IFLM_WRITE);
        if (iflErr != IFLERR_NONE)
        {
                iflFreeHandle(iflHandle);
                GlobalUnlock(pBitmap->m_hThing);
                return FALSE;
        }

        LPBITMAPINFOHEADER lpHdr = lpDib;

        DWORD   dwHdrLen = lpHdr->biSize + PaletteSize((LPSTR)lpHdr);

        LPBYTE  hp = ((LPBYTE)lpDib) + dwHdrLen;

        int             iOutWidth = (lpDib->biBitCount == 24) ?
                                                 lpDib->biWidth*3 :
                                                 lpDib->biWidth*24/lpDib->biBitCount;

        LPBYTE  lpBuf = new BYTE[iOutWidth];

        int             i, j, k;
        BYTE    byTemp;
        BOOL    fFound;

        // convert from pixels to bytes after rounding it up first
        DWORD dwWidthInBytes = ((lpDib->biWidth * lpDib->biBitCount + 31) &~31) /8;
        if (iflClass == IFLCL_RGB)
        {
                // set the transparent color on demand and only if it's been set
                if (g_bUseTrans && crTrans != TRANS_COLOR_NONE) // not default
                {
                        IFLCOLOR iflTransColor;

                        iflTransColor.wRed   = GetRValue( crTrans );
                        iflTransColor.wGreen = GetGValue( crTrans );
                        iflTransColor.wBlue  = GetBValue( crTrans );

                        // ignore any error return (if a format doesn't support
                        // transparent color, so be it)
                        iflControl(iflHandle, IFLCMD_TRANS_RGB, 0, 0, &iflTransColor);
                }

                if (lpDib->biBitCount == 24)
                {
                        // we already have a RGB image, so just copy it out
                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;

                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, iOutWidth);

                                // need to swap RED with BLUE for export
                                for (j = 0; j < iOutWidth; j+=3)
                                {
                                        byTemp = *(lpBuf+j);
                                        *(lpBuf+j) = *(lpBuf+j+2);
                                        *(lpBuf+j+2) = byTemp;
                                }

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                         }
                }
                else
                {
                        // need to convert from palatte color
                        RGBTRIPLE Pal3[MAX_PALETTE_COLORS];
                        memset(Pal3, 255, MAX_PALETTE_COLORS*sizeof(RGBTRIPLE));

                        LPRGBQUAD lpPal4 = (LPRGBQUAD)((LPBYTE)lpDib + lpDib->biSize);
                        for (i = 0; i < MAX_PALETTE_COLORS; i++)
                        {
                                Pal3[i].rgbtRed   = (lpPal4+i)->rgbBlue;
                                Pal3[i].rgbtGreen = (lpPal4+i)->rgbGreen;
                                Pal3[i].rgbtBlue  = (lpPal4+i)->rgbRed;
                        }

                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;

                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, lpDib->biWidth);

                                if (lpDib->biBitCount != 8)
                                        ConvertPalette(lpDib->biBitCount, lpBuf, lpDib->biWidth);

                                for (j = 0; j < lpDib->biWidth; j++)
                                {
                                        ((RGBTRIPLE *)(lpBuf+(lpDib->biWidth-j-1)*3))->rgbtRed   =
                                                GetPalEntry(&Pal3, *(lpBuf+lpDib->biWidth-j-1)).rgbtRed;
                                        ((RGBTRIPLE *)(lpBuf+(lpDib->biWidth-j-1)*3))->rgbtGreen =
                                                GetPalEntry(&Pal3, *(lpBuf+lpDib->biWidth-j-1)).rgbtGreen;
                                        ((RGBTRIPLE *)(lpBuf+(lpDib->biWidth-j-1)*3))->rgbtBlue  =
                                                GetPalEntry(&Pal3, *(lpBuf+lpDib->biWidth-j-1)).rgbtBlue;
                                }

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                        }
                }
        }
        else if (iflClass == IFLCL_PALETTE)
        {
                // first, get the color palette straight...
                RGBTRIPLE Pal3[MAX_PALETTE_COLORS];
                memset(Pal3, 255, MAX_PALETTE_COLORS*sizeof(RGBTRIPLE));

                if (PaletteSize((LPSTR)lpDib) != 0)
                {
                        // we have one available, so just copy it out...
                        // but not before we swap the RGB values first
                        LPRGBQUAD lpPal4 = (LPRGBQUAD)((LPBYTE)lpDib + lpDib->biSize);
                        for (i = 0; i < MAX_PALETTE_COLORS; i++)
                        {
                                Pal3[i].rgbtRed   = (lpPal4+i)->rgbBlue;
                                Pal3[i].rgbtGreen = (lpPal4+i)->rgbGreen;
                                Pal3[i].rgbtBlue  = (lpPal4+i)->rgbRed;
                        }
                        iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

                        if (g_bUseTrans)
                        {
                                BYTE byTransIdx = SearchPalette(crTrans, &Pal3);
                                iflControl(iflHandle, IFLCMD_TRANS_IDX, 0, 0, &byTransIdx);
                        }

                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;

                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, lpDib->biWidth);

                                if (lpDib->biBitCount != 8)
                                        ConvertPalette(lpDib->biBitCount, lpBuf, lpDib->biWidth);

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                        }
                }
                else
                {
                        // we have to create our own palette...
                        for (i = 0, k = 0; i < (int)lpDib->biSizeImage; i+=3)
                        {
                                fFound = FALSE;
                                for (j = 0; j < MAX_PALETTE_COLORS; j++)
                                        if (Pal3[j].rgbtRed   == ((RGBTRIPLE *)(hp+i))->rgbtRed &&
                                                Pal3[j].rgbtGreen == ((RGBTRIPLE *)(hp+i))->rgbtGreen &&
                                                Pal3[j].rgbtBlue  == ((RGBTRIPLE *)(hp+i))->rgbtBlue)
                                        {
                                                fFound = TRUE;
                                                break;
                                        }

                                if (!fFound && k < MAX_PALETTE_COLORS)
                                {
                                        Pal3[k].rgbtRed         = ((RGBTRIPLE *)(hp+i))->rgbtRed;
                                        Pal3[k].rgbtGreen       = ((RGBTRIPLE *)(hp+i))->rgbtGreen;
                                        Pal3[k].rgbtBlue        = ((RGBTRIPLE *)(hp+i))->rgbtBlue;
                                        k++;
                                }

                                if (k >= MAX_PALETTE_COLORS)
                                        // we have already filled every palette entry
                                        break;
                        }
                        iflControl(iflHandle, IFLCMD_PALETTE, 0, 0, &Pal3);

                        LPBYTE  lpBMP = hp + lpDib->biSizeImage - dwWidthInBytes;
                        for (i = 0;
                                 i < abs(lpDib->biHeight);
                                 lpBMP-=dwWidthInBytes, i++)
                        {
                                memcpy(lpBuf, lpBMP, lpDib->biWidth);

                                for (j = 0; j < lpDib->biWidth; j+=3)
                                {
                                        fFound = FALSE;
                                        for (k = 0; k < MAX_PALETTE_COLORS; k++)
                                        {
                                                if (*(lpBuf+j)   == Pal3[k].rgbtRed &&
                                                        *(lpBuf+j+1) == Pal3[k].rgbtGreen &&
                                                        *(lpBuf+j+2) == Pal3[k].rgbtBlue)
                                                {
                                                        fFound = TRUE;
                                                        *(lpBuf+j/3) = (BYTE) k;
                                                        break;
                                                }
                                        }

//                                      if (!fFound)
//                                              *(lpBuf+j/3) = 255;
                                }

                                // write out one line at a time
                                iflWrite(iflHandle, lpBuf, 1);
                        }
                }
        }
        else
                ;       // currently not supported

        delete [] lpBuf;

        iflClose(iflHandle);
        iflFreeHandle(iflHandle);

        GlobalUnlock(pBitmap->m_hThing);

        // now update the image by loading the file just exported
        USES_CONVERSION;

        HGLOBAL hNewDib = LoadDIBFromFile(A2CT(szFileName), &theApp.m_guidFltTypeUsed);
        pBitmap->ReadResource(hNewDib);

        theApp.m_sCurFile = szFileName;
        return TRUE;
   #endif // _USE_IFL_API
      return FALSE;
}

BOOL SaveDIBGdiplus(LPCTSTR szFileName, REFGUID guidFormatID, CBitmapObj* pBitmap)
{
    // find a suitable export filter

    CLSID ClsidEncoder;

    if (GetClsidOfEncoder(guidFormatID, &ClsidEncoder))
    {
        // create a stream that emulates a bmp file

        CComPtr<CBmpStream> pStream;
        
        if (CBmpStream::Create(&pStream) == S_OK)
        {
            pStream->SetBuffer(pBitmap->m_hThing, pBitmap->m_lMemSize, pBitmap->m_dwOffBits);

            // create the GDI+ object

            Gdiplus::Bitmap image(pStream);

            if (image.GetLastStatus() == Gdiplus::Ok)
            {
                // let GDI+ export the file

                USES_CONVERSION;

                if (image.Save(T2CW(szFileName), &ClsidEncoder, 0) == Gdiplus::Ok)
                {
                    // now update the image by loading the file just exported

                    HGLOBAL hNewDib = LoadDIBFromFile(szFileName, &theApp.m_guidFltTypeUsed);

                    pBitmap->ReadResource(hNewDib);

                    theApp.m_sCurFile = szFileName;

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOL SaveDIBToFile(LPCTSTR szFileName, REFGUID guidFormatID, CBitmapObj* pBitmap)
{
    // Try GDI+ filters first. If it fails to convert the image or 
    // if it's not available, try the old method

    BOOL bResult = FALSE;

    if (theApp.GdiplusInit.StartupStatus == Gdiplus::Ok)
    {
        __try
        {
            bResult = SaveDIBGdiplus(szFileName, guidFormatID, pBitmap);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    if (!bResult)
    {
        USES_CONVERSION;

        bResult = SaveDIBToFileA(T2CA(szFileName), guidFormatID, pBitmap);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\props.h ===
// Properties

#define P_Title             100
#define P_ALIGNCAPTION      101

#define P_String            106
#define P_Preload           107
#define P_Moveable          108
#define P_Discardable       109
#define P_Pure              110

#define P_HASMINVAL         200
#define P_HASMAXVAL         201
#define P_MINVAL            202
#define P_MAXVAL            203
#define P_MULTILINE         204
#define P_INITIALVAL        205
#define P_DATATYPE          206


#define P_Autolayout        300
#define P_Wrap              301
#define P_Border            302
#define P_LeftMargin        303
#define P_TopMargin         304
#define P_RightMargin       305
#define P_BottomMargin      306
#define P_Columns           307

#define P_WindowStyle       308
#define P_Caption           312

#define P_Popup             313
#define P_Separator         314
#define P_Checked           315
#define P_Inactive          316
#define P_Break             317
#define P_Help              318
#define P_MenuBar           319
#define P_HorizontalAlignment 321
#define P_VerticalAlignment 322
#define P_AutoSizeToContent 323
#define P_ShowKeyboardShortcuts 324
#define P_Grayed        325
#define P_ShowPropertyWindow 326
#define P_ShowControlPalette 327
#define P_DetectDuplicateIDs 328
#define P_BuildOnSave   329
#define P_DefaultHelpContext 330
#define P_MinimumResourceID 331
#define P_MinimumCommandID 332
#define P_MinimumStringID 333
#define P_MinimumAcceleratorID 334
#define P_CurrentSlob   335
#define P_OwnerDraw     336
#define P_DefaultButton 337
#define P_InitiallyChecked 338
#define P_Order         339
#define P_CaptionLocation 340
#define P_Position      342
#define P_PoppingProperties 343
#define P_LogUndo       344
#define P_Image         345
#define P_Width         346
#define P_Height        347
#define P_Colors        348
#define P_Hotspot       349
#define P_Size          350
#define P_Ctrl          352
#define P_Alt           353
#define P_Shift         354
#define P_Type          355
#define P_Key           357
#define P_Visible       360
#define P_Disabled      361
#define P_Group         362
#define P_Tabstop       363
#define P_TextAlign     364
#define P_NoPrefix      365
#define P_NoWrap        366
#define P_GfxType       367
#define P_GfxColor      368
#define P_GfxIcon       369
#define P_Auto          370
#define P_LeftText      371
#define P_3State        372
#define P_Context       374
#define P_FontFace      375
#define P_FontSize      376
#define P_Menu          377
#define P_Choices       378
#define P_NewItem       379
#define P_KeyValue      380

#define P_Standard      500
#define P_Sort          502
#define P_Notify        503
#define P_Keyin         504
#define P_VScroll       505
#define P_HScroll       506
#define P_Tabstops      507
#define P_NoRedraw      508
#define P_NoIntHeight   509
#define P_MultiCol      510
#define P_HasStrings    511
#define P_Selection     512
#define P_AutoHScroll   515
#define P_AutoVScroll   516
#define P_Password      517
#define P_NoHideSel     518
#define P_OEMConvert    519
#define P_MultiLine     520
#define P_UpperCase     522
#define P_LowerCase     523
#define P_AlignText     524
#define P_Shrink        525

#define P_AddToCaption  526
#define P_AcceleratorTable 527
#define P_TitleBar      529
#define P_State         530
#define P_ClipSiblings  531
#define P_ClipChildren  532
#define P_SystemModal   533
#define P_NoIdleMsg     534
#define P_LocalEdit     535
#define P_SystemMenu    536
#define P_MinimizeBox   537
#define P_MaximizeBox   538
#define P_Style         539

#define P_ThickFrame    540
#define P_NoParentNotify 541
#define P_TopMost       542
#define P_AcceptFiles   543
#define P_Transparent   544
#define P_Class         545
#define P_LayoutBorder  546
#define P_FrameType     547
#define P_AbsAlign      548

#define P_Show          550
#define P_Message       551
#define P_MsgClass      552
#define P_Function      553

#define P_CmdMessage    561
#define P_CmdSlob       562

#define P_ShowStatusbar 563
#define P_ShowToolbar   564

#define P_PosX          565
#define P_PosY          566

#define P_FileName      567

#define P_Grid          568
#define P_GridX         569
#define P_GridY         570

#define P_DisableNoScroll   572
#define P_ScrAlign          573
#define P_WantReturn        574
#define P_ReadOnly          575

#define P_Simple            580
#define P_DlgInit           581

#ifdef DS_NONBOLD
    #define P_NonBold           591
#endif

#ifdef _DEBUG
#define P_DebugValue        700
#endif


// Actions
#define A_ImageChange       1000
#define A_PostSel           1001
#define A_PreSel            1002
#define A_HexChange         1003
#define A_DependentList     1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\saveimag.h ===
//
//  SaveImage.c
//
//  routines to save and compress a graphics file using a MS Office
//  graphic export filter.
//
#include "image.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//  SaveDIBToFile
//
//  save an image file using an installed image export filter.
//
BOOL SaveDIBToFile( LPCTSTR szFileName,
                    REFGUID guidFormatID,
                    CBitmapObj * pBitmap );

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\settings.h ===
#ifndef __SETTINGS_H__
#define __SETTINGS_H__

extern void LoadRegistorSettings();
extern void SaveRegistorSettings();

#endif // __SETTINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\settings.cpp ===
#include "stdafx.h"
#include "pbrush.h"
#include "settings.h"

#include <atlbase.h>

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

extern BOOL NEAR g_bDriverCanStretch;
extern BOOL NEAR g_bShowAllFiles;

/***************************************************************************/

static TCHAR NEAR mszView[]            = TEXT("View");
static TCHAR NEAR mszNoStretching[]    = TEXT("NoStretching");
static TCHAR NEAR mszShowAllFiles[]    = TEXT("ShowAllFiles");

static TCHAR NEAR mszShowThumbnail[]   = TEXT("ShowThumbnail");
static TCHAR NEAR mszShowText[]        = TEXT("ShowTextTool");


static TCHAR NEAR mszSnapToGrid[]      = TEXT("SnapToGrid");
static TCHAR NEAR mszGridExtent[]      = TEXT("GridExtent");
static TCHAR NEAR mszBMPWidth[]        = TEXT("BMPWidth");
static TCHAR NEAR mszBMPHeight[]       = TEXT("BMPHeight");

static TCHAR NEAR mszThumbXPos[]       = TEXT("ThumbXPos");
static TCHAR NEAR mszThumbYPos[]       = TEXT("ThumbYPos");
static TCHAR NEAR mszThumbWidth[]      = TEXT("ThumbWidth");
static TCHAR NEAR mszThumbHeight[]     = TEXT("ThumbHeight");
static TCHAR NEAR mszCurrentUnits[]    = TEXT("UnitSetting");

static TCHAR NEAR mszText[]            = TEXT("Text");
static TCHAR NEAR mszFaceName[]        = TEXT("TypeFaceName");
static TCHAR NEAR mszPointSize[]       = TEXT("PointSize");
static TCHAR NEAR mszCharSet[]         = TEXT("CharSet");
static TCHAR NEAR mszBold[]            = TEXT("Bold");
static TCHAR NEAR mszUnderline[]       = TEXT("Underline");
static TCHAR NEAR mszItalic[]          = TEXT("Italic");

static TCHAR NEAR mszVertEdit[]        = TEXT("VerticalEdit");

static TCHAR NEAR mszPositionX[]       = TEXT("PositionX");
static TCHAR NEAR mszPositionY[]       = TEXT("PositionY");
static TCHAR NEAR mszTextPen[]         = TEXT("TextPen");

static TCHAR NEAR mszColors[]          = TEXT("Colors");
static TCHAR NEAR mszNumberOfColors[]  = TEXT("NumberOfColors");

static TCHAR NEAR mszSoftware[]        = TEXT("Software");
static TCHAR NEAR mszWindowPlacement[] = TEXT("WindowPlacement");

/***************************************************************************/

void OpenAppKey(LPCTSTR pszKeyName, HKEY *phk)
{
        *phk = NULL;

        CRegKey rkSoftware;

        if (rkSoftware.Create(HKEY_CURRENT_USER, mszSoftware) != ERROR_SUCCESS)
        {
                return;
        }

        CString cszSubKey;

        if (!cszSubKey.LoadString(IDS_REGISTRY_PATH))
        {
                return;
        }

        CRegKey rkSubKey;

        if (rkSubKey.Create(rkSoftware, cszSubKey) != ERROR_SUCCESS)
        {
                return;
        }


        //
        // use the app's profile name instead of the
        // localizable app name
        //
        CRegKey rkAppKey;

        if (rkAppKey.Create(rkSubKey, theApp.m_pszProfileName) != ERROR_SUCCESS)
        {
                return;
        }

        if (RegOpenKey(rkAppKey, pszKeyName, phk) != ERROR_SUCCESS)
        {
                return;
        }
}

void CPBApp::LoadProfileSettings()
    {
    CWinApp::LoadStdProfileSettings( );

    BOOL bNoStretch = (BOOL)GetProfileInt( mszView, mszNoStretching, FALSE );

    g_bDriverCanStretch = ! bNoStretch;

    m_bShowThumbnail    = (BOOL)GetProfileInt( mszView, mszShowThumbnail  , FALSE  );

    g_bShowAllFiles     = (BOOL)GetProfileInt( mszView, mszShowAllFiles, FALSE );

    int iX = GetProfileInt( mszView, mszBMPWidth , 0 );
    int iY = GetProfileInt( mszView, mszBMPHeight, 0 );

    if (! iX || ! iY)
        {
        iX = 0;
        iY = 0;
        }
    m_sizeBitmap = CSize( iX, iY );

    HKEY hkView;

    OpenAppKey(mszView, &hkView);
    if (hkView)
    {
        DWORD dwType = REG_BINARY;
        DWORD dwSize = sizeof(m_wpPlacement);;

        if (RegQueryValueEx(hkView, mszWindowPlacement, 0, &dwType, (LPBYTE)&m_wpPlacement,
            &dwSize)!= ERROR_SUCCESS || dwType!=REG_BINARY || dwSize!=sizeof(m_wpPlacement))
        {
            memset((LPVOID)&m_wpPlacement, 0, sizeof(m_wpPlacement));
        }
        RegCloseKey(hkView);
    }

    int    iW;
    int    iH;
    CPoint ptPos;
    CSize  size;

    iX = GetProfileInt( mszView, mszThumbXPos  , 0 );
    iY = GetProfileInt( mszView, mszThumbYPos  , 0 );
    iW = GetProfileInt( mszView, mszThumbWidth , 0 );
    iH = GetProfileInt( mszView, mszThumbHeight, 0 );

    if (iX && iY && iW && iH)
        {
        size  = CSize( iW, iH );
        ptPos = CheckWindowPosition( CPoint( iX, iY ), size );
        m_rectFloatThumbnail = CRect( ptPos, size );
        }



    m_iCurrentUnits = GetProfileInt( mszView, mszCurrentUnits, 0 );

    m_bShowTextToolbar = (BOOL)GetProfileInt   ( mszText, mszShowText , TRUE );
    m_iPointSize       =       GetProfileInt   ( mszText, mszPointSize, 0 );
    m_iBoldText        =       GetProfileInt   ( mszText, mszBold     , 0 );
    m_iUnderlineText   =       GetProfileInt   ( mszText, mszUnderline, 0 );
    m_iItalicText      =       GetProfileInt   ( mszText, mszItalic   , 0 );

    m_iVertEditText    =       GetProfileInt   ( mszText, mszVertEdit, -1 );

    m_iPosTextX        =       GetProfileInt   ( mszText, mszPositionX, 0 );
    m_iPosTextY        =       GetProfileInt   ( mszText, mszPositionY, 0 );
    m_strTypeFaceName  =       GetProfileString( mszText, mszFaceName , NULL);

    m_iCharSet = GetProfileInt   ( mszText, mszCharSet  , -1 );
    if (m_iCharSet == -1)
    {
        CHARSETINFO csi;
        if (!TranslateCharsetInfo((DWORD*)UIntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE))
            csi.ciCharset=ANSI_CHARSET;
        m_iCharSet = csi.ciCharset;
    }

    m_iPenText = GetProfileInt   ( mszText, mszTextPen  , 0 );

    m_iSnapToGrid = GetProfileInt( mszView, mszSnapToGrid, 0 );
    m_iGridExtent = GetProfileInt( mszView, mszGridExtent, 1 );

    m_pColors = new COLORREF[16];

    if (m_pColors != NULL)
        {
        TCHAR szNumber[8];
        int  iColors = GetProfileInt( mszColors, mszNumberOfColors, 0 );

        for (int i = 0; i < iColors; i++)
            {
            _Itoa( i, szNumber, 10 );

            m_pColors[i] = (COLORREF)GetProfileInt( mszColors, szNumber, 0 );
            }
        m_iColors = i;
        }
    }

/***************************************************************************/

void CPBApp::SaveProfileSettings()
    {
    HKEY hkView;

    OpenAppKey(mszView, &hkView);
    if (hkView)
    {
        RegSetValueEx(hkView, mszWindowPlacement, 0, REG_BINARY, (LPBYTE)&m_wpPlacement,
            sizeof(m_wpPlacement));
        RegCloseKey(hkView);
    }

    WriteProfileInt( mszView, mszShowThumbnail  , m_bShowThumbnail );

    WriteProfileInt( mszView, mszBMPWidth       , m_sizeBitmap.cx );
    WriteProfileInt( mszView, mszBMPHeight      , m_sizeBitmap.cy );
    WriteProfileInt( mszView, mszThumbXPos      , m_rectFloatThumbnail.left );
    WriteProfileInt( mszView, mszThumbYPos      , m_rectFloatThumbnail.top );
    WriteProfileInt( mszView, mszThumbWidth     , m_rectFloatThumbnail.Width() );
    WriteProfileInt( mszView, mszThumbHeight    , m_rectFloatThumbnail.Height() );
    WriteProfileInt( mszView, mszCurrentUnits   , m_iCurrentUnits );
    WriteProfileInt( mszView, mszNoStretching   , ! g_bDriverCanStretch );

    WriteProfileInt( mszText, mszShowText   , m_bShowTextToolbar );
    WriteProfileInt( mszText, mszPointSize  , m_iPointSize );
    WriteProfileInt( mszText, mszPositionX  , m_iPosTextX );
    WriteProfileInt( mszText, mszPositionY  , m_iPosTextY );
    WriteProfileInt( mszText, mszBold       , m_iBoldText );
    WriteProfileInt( mszText, mszUnderline  , m_iUnderlineText );
    WriteProfileInt( mszText, mszItalic     , m_iItalicText );

    WriteProfileInt( mszText, mszVertEdit   , m_iVertEditText );

    WriteProfileInt( mszText, mszTextPen    , m_iPenText );
    WriteProfileString( mszText, mszFaceName, m_strTypeFaceName );
    WriteProfileInt( mszText, mszCharSet    , m_iCharSet );

    WriteProfileInt( mszView, mszSnapToGrid, m_iSnapToGrid);
    WriteProfileInt( mszView, mszGridExtent, m_iGridExtent);

    if (m_pColors != NULL)
        {
        TCHAR szNumber[8];
        int  iColor;

        WriteProfileInt( mszColors, mszNumberOfColors, m_iColors );

        for (int i = 0; i < m_iColors; i++)
            {
            iColor = (int)(m_pColors[i] & (COLORREF)0x00FFFFFF);
            _Itoa( i, szNumber, 10 );

            WriteProfileInt( mszColors, szNumber, iColor );
            }
        delete [] m_pColors;
        }
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\skew.cpp ===
/****************************************************************************
 SKEW.c

 The SKEW module handles rotating a rectangular object.

****************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgsuprt.h"
#include "bmobject.h"
#include "undo.h"
#include "props.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

static int miAngle;

/***************************************************************************/

static int CalcOffset( int iValue )
    {
    // tan[angle] is the 100000/tangent of angles 1 to 89deg.
    static int invtan[90] = {  -1, 5728996, 2863625, 1908114, 1430067,
                          1143005,  951436,  814436,  711537,  631375,
                           567128,  514455,  470463,  433148,  401078,
                           373205,  348741,  327085,  307768,  290421,
                           274748,  260509,  247509,  235585,  224604,
                           214451,  205030,  196261,  188073,  180405,
                           173205,  166428,  160034,  153987,  148256,
                           142815,  137638,  132705,  127994,  123490,
                           119175,  115037,  111061,  107237,  103553,
                           100000,   96569,   93252,   90040,   86929,
                            83910,   80978,   78129,   75355,   72654,
                            70021,   67451,   64941,   62487,   60086,
                            57735,   55431,   53171,   50953,   48773,
                            46631,   44523,   42448,   40403,   38386,
                            36397,   34433,   32492,   30573,   28675,
                            26795,   24933,   23087,   21256,   19438,
                            17633,   15838,   14054,   12279,   10510,
                             8749,    6993,    5241,    3492,    1746 };
    return (((iValue * 1000000 / invtan[miAngle]) + 5) / 10);
    }

/***************************************************************************/

void CImgWnd::CmdSkewBrush( int iAngle, BOOL bHorz )
    {
    BOOL  bFullImage = FALSE;
    CDC*  pdcImg = CDC::FromHandle( m_pImg->hDC );
    CDC*  pdcSrc = &theImgBrush.m_dc;
    CRect rectSlct( 0, 0, theImgBrush.m_size.cx, theImgBrush.m_size.cy );

    if (theImgBrush.m_pImg == NULL && ! g_bCustomBrush)
        {
        bFullImage = TRUE;
        pdcSrc     = pdcImg;
        rectSlct.SetRect( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight );
        }

    CRect rectSkew = rectSlct;

    if (!iAngle || rectSlct.IsRectEmpty() || abs(iAngle) > 89 || abs(iAngle) < 1 )
        return;

    if (! bFullImage)
        {
        PrepareForBrushChange( TRUE, TRUE );
        HideBrush();
        }
    // angle is the angle of skew 0 to 90 degrees
    // axis is the direction to skew TRUE:  horizontal
    //                                      the y axis moves by angle
    //                               FALSE: verticle
    //                                      the x axis moves by angle
    int iWidthSlct  = rectSlct.Width();
    int iHeightSlct = rectSlct.Height();

    miAngle = abs(iAngle);

    if (bHorz) // horizontal - create a new bitmap of size = x + y * tan (angle)
        rectSkew.right += CalcOffset( iHeightSlct );
    else       // verticale - create a new bitmap of size = y + x * tan (angle)
        rectSkew.bottom += CalcOffset( iWidthSlct );

    int iWidthSkew  = rectSkew.Width();
    int iHeightSkew = rectSkew.Height();

    // angle is the angle of skew 0 to 90 degrees
    // axis is the direction to skew TRUE:  horizontal
    //                                      the y axis moves by angle
    //                               FALSE: verticle
    //                                      the x axis moves by angle
    CDC     dcWork;
    CBitmap bmWork;
    CBrush  brBackground;

    if (! dcWork.CreateCompatibleDC( pdcImg )
    ||  ! bmWork.CreateCompatibleBitmap( pdcImg, iWidthSkew, iHeightSkew )
    ||  ! brBackground.CreateSolidBrush( crRight ))
        {
        theApp.SetGdiEmergency( TRUE );
        return;
        }

    CBitmap*  pbmOld = dcWork.SelectObject( &bmWork );
    CPalette* ppalOld = SetImgPalette( &dcWork, FALSE );

    dcWork.FillRect( rectSkew, &brBackground );

    CPalette* ppalOldSrc = SetImgPalette( pdcSrc, FALSE );

    // Skew the bitmap
    int mx = 1;
    int my = 1;  // local variables for the skew
    int x = rectSlct.left;
    int y = rectSlct.top;

    BeginWaitCursor();

    if (bHorz) // horizontal
        {
        if (iAngle > 0)
            {
            mx = x + CalcOffset( iHeightSlct - y );
            // Start at Bottom
            for (y = rectSlct.bottom; y >= rectSlct.top; )
                {
                dcWork.BitBlt( mx, y, iWidthSlct, 1, pdcSrc, x, y, SRCCOPY );
                mx = x + CalcOffset( iHeightSlct - y-- );
                }
            }
        else
            {
            x = rectSkew.right - iWidthSlct;
            mx = x - CalcOffset( iHeightSlct - y );
            for (y = rectSlct.bottom; y >= rectSlct.top; )
                {
                dcWork.BitBlt( mx, y, iWidthSlct, 1, pdcSrc, rectSlct.left, y, SRCCOPY );
                mx = x - CalcOffset( iHeightSlct - y-- );
                }
            }
        }
    else
        { // vertical
        if (iAngle > 0)
            {
            my = y + CalcOffset( iWidthSlct - x );
            // Start at left
            for (x = rectSlct.left - 1; x <= rectSlct.right; )
                {
                dcWork.BitBlt( x, my, 1, iHeightSlct, pdcSrc, x, y, SRCCOPY );
                my = y + CalcOffset( iWidthSlct - x++ );
                }
            }
        else
            {
            y = rectSkew.bottom - iHeightSlct;
            my = y - CalcOffset( iWidthSlct - x );
            for (x = rectSlct.left - 1; x <= rectSlct.right; )
                {
                dcWork.BitBlt( x, my, 1, iHeightSlct, pdcSrc, x, rectSlct.top, SRCCOPY );
                my = y - CalcOffset( iWidthSlct - x++ );
                }
            }
        }

    if (ppalOldSrc)
        pdcSrc->SelectPalette( ppalOldSrc, FALSE );

    if (bFullImage)
        {
        theUndo.BeginUndo( TEXT("Skew Bitmap") );

        m_pImg->m_pBitmapObj->SetSizeProp( P_Size, CSize( iWidthSkew, iHeightSkew ) );

        m_pImg->cxWidth  = iWidthSkew;
        m_pImg->cyHeight = iHeightSkew;

        SetUndo( m_pImg );

        pdcImg->BitBlt( 0, 0, m_pImg->cxWidth, m_pImg->cyHeight, &dcWork, 0, 0, SRCCOPY );

        InvalImgRect ( m_pImg, &rectSkew );
        CommitImgRect( m_pImg, &rectSkew );

        FinishUndo( rectSkew );

        theUndo.EndUndo();

        DirtyImg( m_pImg );

        InvalidateRect( NULL );
        UpdateWindow();

        dcWork.SelectObject( pbmOld );
        bmWork.DeleteObject();
        }
    else
        {
        CBitmap bmMask;

        if (! bmMask.CreateBitmap( iWidthSkew, iHeightSkew, 1, 1, NULL ))
            {
            if (ppalOld)
                dcWork.SelectPalette( ppalOld, FALSE );

            theApp.SetMemoryEmergency( TRUE );
            return;
            }

        dcWork.SelectObject( pbmOld );

        theImgBrush.m_dc.SelectObject( &bmWork );
        theImgBrush.m_bitmap.DeleteObject();
        theImgBrush.m_bitmap.Attach( bmWork.Detach() );

        theImgBrush.m_size.cx = iWidthSkew;
        theImgBrush.m_size.cy = iHeightSkew;

        VERIFY( theImgBrush.m_maskDC.SelectObject( &bmMask ) ==
               &theImgBrush.m_maskBitmap );

        theImgBrush.m_maskBitmap.DeleteObject();
        theImgBrush.m_maskBitmap.Attach( bmMask.Detach() );
        theImgBrush.RecalcMask( crRight );

        rectSkew = theImgBrush.m_rcSelection;

        mx = 0;
        my = 0;

        if (bHorz)
            mx = CalcOffset( iHeightSlct ) / 2;
        else
            my = CalcOffset( iWidthSlct ) / 2;

        rectSkew.InflateRect( mx, my );

        MoveBrush( rectSkew );
        }

    if (ppalOld)
        dcWork.SelectPalette( ppalOld, FALSE );

    dcWork.DeleteDC();

    EndWaitCursor();
    }

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\sources.inc ===
MAJORCOMP=shell
MINORCOMP=accesory

TARGETNAME=mspaint
TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h

USE_NATIVE_EH=1
USE_MFC=1
USE_STATIC_ATL=1
ATL_VER=30

# need to wait on ofn\$O\ofn.lib
SYNCHRONIZE_DRAIN = 1

C_DEFINES=-DWIN32 -D_WINDOWS -DNT -DUSE_MIRRORING

INCLUDES=..;..\res;$(INCLUDES);$(PRINTSCAN_INC_PATH)

SOURCES=            \
    ..\bar.cpp      \
    ..\bmobject.cpp \
    ..\cmpmsg.cpp   \
    ..\colorsrc.cpp \
    ..\docking.cpp  \
    ..\global.cpp   \
    ..\imageatt.cpp \
    ..\imgbrush.cpp \
    ..\imgcolor.cpp \
    ..\imgcpyps.cpp \
    ..\imgdlgs.cpp  \
    ..\imgfile.cpp  \
    ..\imgsuprt.cpp \
    ..\imgtools.cpp \
    ..\imgwell.cpp  \
    ..\imgwnd.cpp   \
    ..\ipframe.cpp  \
    ..\minifwnd.cpp \
    ..\pbrusdoc.cpp \
    ..\pbrusfrm.cpp \
    ..\pbrush.cpp   \
    ..\pbrusvw.cpp  \
    ..\pictures.cpp \
    ..\printres.cpp \
    ..\rotate.cpp   \
    ..\settings.cpp \
    ..\skew.cpp     \
    ..\sprite.cpp   \
    ..\srvritem.cpp \
    ..\tedit.cpp    \
    ..\tfont.cpp    \
    ..\thumnail.cpp \
    ..\toolbox.cpp  \
    ..\tracker.cpp  \
    ..\t_curve.cpp  \
    ..\t_fhsel.cpp  \
    ..\t_poly.cpp   \
    ..\t_text.cpp   \
    ..\undo.cpp     \
    ..\mspaint.rc   \
    ..\loadimag.cpp \
    ..\saveimag.cpp \
    ..\bmpstrm.cpp  \
    ..\imaging.cpp  \
    ..\pgsetup.cpp

# Add interlac.cpp if the PNG support is ever fixed

TARGETLIBS=                          \
        $(TARGETLIBS)                \
        $(SDK_LIB_PATH)\comdlg32.lib \
        $(SDK_LIB_PATH)\ole32.lib    \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\winspool.lib \
        $(SDK_LIB_PATH)\uuid.lib     \
        $(SDK_LIB_PATH)\shell32.lib  \
        $(SDK_LIB_PATH)\htmlhelp.lib \
        $(SDK_LIB_PATH)\imm32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib  \
        $(SDK_LIB_PATH)\gdiplus.lib  \
        $(SDK_LIB_PATH)\uxtheme.lib


!if $(386)
TARGETLIBS=                          \
        $(TARGETLIBS)                \
        ..\image.lib                 \
        $(SDK_LIB_PATH)\oldnames.lib
!endif

DELAYLOAD=gdiplus.dll;uxtheme.dll
DLOAD_ERROR_HANDLER=none
 
# 
# Fusionized
# 
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\sprite.h ===
#ifndef __SPRITE_H__
#define __SPRITE_H__

// Draggers are graphical objects that typicaly overlay windows and
// can be shown, hidden, and moved.  A default dragger is simply a 
// dotted rectangle XOR'd over the contents of it's window.
//
// For bitmap draggers, use the CSprite class.
//
// CDragger() creates hidden draggers.
//
// ~CDragger() will hide a dragger before it is destroyed.
//
// Move() and SetSize() will make sure a dragger gets erased from 
// it's old position and if it was visible, it will be drawn in 
// it's new position.
//

class CDragger : public CObject
    {
    public:

    enum STATE 
        {
        hidden,
        shown,
        obscured
        };

             CDragger   () : m_rect(), m_pWnd() { m_state = hidden; };
             CDragger   ( CWnd* pWnd, CRect* pRect = NULL );
    virtual ~CDragger   ();

    virtual void Hide   ();
    virtual void Show   ();
    virtual void Obscure(BOOL bObscure);
    
    virtual void Draw   ();
    virtual void Erase  ();
    virtual void Move   ( const CRect& newRect, BOOL bForceShow = FALSE );
    virtual void Move   ( const CPoint& newTopLeft, BOOL bForceShow = FALSE );
            void MoveBy ( int cx, int cy, BOOL bForceShow = FALSE );
            void SetSize( const CSize& newSize, BOOL bForceShow = FALSE );

    virtual CObList* GetDraggerList() { return NULL; }
    virtual CRect    GetRect() const;
    inline  BOOL     IsShown() const { return m_state == shown; }
    
    CRect m_rect;
    STATE m_state;
    CWnd* m_pWnd;

    #ifdef _DEBUG
    DECLARE_DYNAMIC( CDragger )
    #endif
    };


class CMultiDragger : public CDragger
    {
    public:

             CMultiDragger();
             CMultiDragger(CWnd* pWnd);
    virtual ~CMultiDragger();

    virtual void Hide();
    virtual void Show();
    virtual void Draw();
    virtual void Erase();
    virtual void Move(const CPoint& newTopLeft, BOOL bForceShow = FALSE);
    
    virtual CRect GetRect() const;

    void Add   (CDragger *pDragger);
    void Remove(CDragger *pDragger);

    virtual CObList* GetDraggerList() { return &m_draggerList; }

    CObList m_draggerList;

    #ifdef _DEBUG
    DECLARE_DYNAMIC( CMultiDragger )
    #endif
    };

class CSprite : public CDragger
    {
    public:

    CSprite();
    CSprite(CWnd* pWnd, CRect* pRect = NULL);
    virtual ~CSprite();
    
    virtual void Move(const CRect&, BOOL = FALSE);
    inline  void Move(const CPoint& newTopLeft) 
                { CDragger::Move(newTopLeft); }
    virtual void Draw() = 0;
    virtual void SaveBits();
    virtual void Erase();
    
    CBitmap m_saveBits;

    #ifdef _DEBUG
    DECLARE_DYNAMIC( CSprite )
    #endif
    };

class CHighlight : public CDragger
    {
    public:

     CHighlight();
     CHighlight(CWnd *pWnd, CRect* pRect = NULL, int bdrSize = 2);
    ~CHighlight();

    int m_bdrSize;

    virtual void Draw();
    virtual void Erase();
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\srvritem.cpp ===
// srvritem.cpp : implementation of the CPBSrvrItem class
//

#include "stdafx.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "srvritem.h"
#include "bmobject.h"
#include "docking.h"
#include "minifwnd.h"
#include "imgwnd.h"
#include "imgsuprt.h"
#include "imgcolor.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CPBSrvrItem, COleServerItem)

#include "memtrace.h"

/***************************************************************************/
// CPBSrvrItem implementation

CPBSrvrItem::CPBSrvrItem( CPBDoc* pContainerDoc, CBitmapObj* pBM )
                : COleServerItem( pContainerDoc, TRUE )
{
        if (pBM)
        {
                m_pBitmapObj = pBM;
        }
        else
        {
                pBM = pContainerDoc->m_pBitmapObj;

                m_pBitmapObj = NULL;
        }

        if (pBM && pBM->m_pImg)
        {
                COleDataSource* oleDataSrc = GetDataSource();

                // support CF_DIB format
                oleDataSrc->DelayRenderFileData( CF_DIB );
                oleDataSrc->DelayRenderData( CF_BITMAP );

                if (pBM->m_pImg->m_pPalette != NULL)
                {
                        oleDataSrc->DelayRenderData( CF_PALETTE );
                }
        }
}

/***************************************************************************/

CPBSrvrItem::~CPBSrvrItem()
{
        // TODO: add cleanup code here
        if (m_pBitmapObj)
        {
                delete m_pBitmapObj;
        }
}

/***************************************************************************/

void CPBSrvrItem::Serialize(CArchive& ar)
    {
    // CPBSrvrItem::Serialize will be called by the framework if
    //  the item is copied to the clipboard.  This can happen automatically
    //  through the OLE callback OnGetClipboardData.  A good default for
    //  the embedded item is simply to delegate to the document's Serialize
    //  function.  If you support links, then you will want to serialize
    //  just a portion of the document.

    // IsLinkedItem always returns TRUE even though we don't support links,
    // so I am just removing the check
    // if (! IsLinkedItem())
        {
        CPBDoc* pDoc = GetDocument();
        ASSERT_VALID(pDoc);

        CBitmapObj* pBMCur = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;
        CBitmapObj* pBMNew = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObjNew;

        pDoc->SerializeBitmap( ar, pBMCur, pBMNew, TRUE );
        }
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
    {
    // Most applications, like this one, only handle drawing the content
    //  aspect of the item.  If you wish to support other aspects, such
    //  as DVASPECT_THUMBNAIL (by overriding OnDrawEx), then this
    //  implementation of OnGetExtent should be modified to handle the
    //  additional aspect(s).

    if (dwDrawAspect != DVASPECT_CONTENT)
        return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

    // CPBSrvrItem::OnGetExtent is called to get the extent in
    //  HIMETRIC units of the entire item.  The default implementation
    //  here simply returns a hard-coded number of units.

    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID( pDoc );

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if (pBM         != NULL
    &&  pBM->m_pImg != NULL)
        {
       //
       // What was the padding for?
       //
        rSize.cx = pBM->m_pImg->cxWidth ;// + GetSystemMetrics( SM_CXBORDER ) + CTracker::HANDLE_SIZE * 2;
        rSize.cy = pBM->m_pImg->cyHeight;// + GetSystemMetrics( SM_CYBORDER ) + CTracker::HANDLE_SIZE * 2;

        CDC* pDC = CDC::FromHandle( pBM->m_pImg->hDC );

        if (pDC != NULL)
            {
            pDC->DPtoHIMETRIC( &rSize );
            }
        else /* punt */
            {
            rSize.cx = (int)(((long)rSize.cx * 10000L) / (long)theApp.ScreenDeviceInfo.ixPelsPerDM);
            rSize.cy = (int)(((long)rSize.cy * 10000L) / (long)theApp.ScreenDeviceInfo.iyPelsPerDM);
            }
        }
    else
        rSize = CSize( 3000, 3000 );

    return TRUE;
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnSetExtent( DVASPECT nDrawAspect, const CSize& size )
    {
    TRACE( TEXT("MSPaint OnSetExtent %d %d\n"), size.cx, size.cy );

    return COleServerItem::OnSetExtent( nDrawAspect, size );
    }

/***************************************************************************/

void CPBSrvrItem::OnOpen()
    {
    CPBDoc* pDoc = (CPBDoc*)GetDocument();

        if (theApp.m_bLinked)
            {
        theApp.m_bHidden = FALSE;

        if (g_pDragBrushWnd != NULL)
            HideBrush();

        g_pDragBrushWnd = NULL;
        g_pMouseImgWnd  = NULL;
        fDraggingBrush  = FALSE;

        POSITION pos = pDoc->GetFirstViewPosition();
        CPBView* pView = (CPBView*)(pDoc->GetNextView( pos ));

        if (pView != NULL)
            {
            pView->SetTools();
            }
        }
    COleServerItem::OnOpen();
    }

/***************************************************************************/

void CPBSrvrItem::OnShow()
    {
    theApp.m_bHidden = FALSE;

    COleServerItem::OnShow();
    }

/***************************************************************************/

void CPBSrvrItem::OnHide()
    {
    theApp.m_bHidden = TRUE;

    g_pMouseImgWnd = NULL;

    if (g_pDragBrushWnd != NULL)
        HideBrush();

    COleServerItem::OnHide();
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnDraw(CDC* pDC, CSize& rSize)
    {
    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID(pDoc);

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if (pBM != NULL)
        {
        CDC* pDCBitmap = CDC::FromHandle( pBM->m_pImg->hDC );

        if (pDCBitmap != NULL)
            {
            CSize size( pBM->m_pImg->cxWidth,
                        pBM->m_pImg->cyHeight );

                size.cy = -size.cy;

            pDC->SetMapMode  ( MM_ANISOTROPIC );
            pDC->SetWindowExt( size );
            pDC->SetWindowOrg( 0, 0 );

            CPalette* ppalOld = NULL;

            if (pBM->m_pImg->m_pPalette != NULL)
                {
                ppalOld = pDC->SelectPalette( pBM->m_pImg->m_pPalette, FALSE ); // Background ??

                pDC->RealizePalette();
                }

            pDC->StretchBlt( 0, 0, size.cx, size.cy, pDCBitmap,
                             0, 0, pBM->m_pImg->cxWidth,
                                   pBM->m_pImg->cyHeight, SRCCOPY );

            if (pBM->m_pImg->m_pPalette != NULL)
                pDC->SelectPalette( ppalOld, FALSE ); // Background ??
            }
        }
    return TRUE;
    }

/***************************************************************************/

COleDataSource* CPBSrvrItem::OnGetClipboardData( BOOL bIncludeLink,
                                                 CPoint* pptOffset,
                                                 CSize *pSize )
    {
    ASSERT_VALID( this );

    COleDataSource* pDataSource = new COleDataSource;

    TRY
        {
        GetClipboardData( pDataSource, bIncludeLink, pptOffset, pSize );
        }
    CATCH_ALL( e )
        {
        delete pDataSource;

        THROW_LAST();
        }
    END_CATCH_ALL

    ASSERT_VALID( pDataSource );

    return pDataSource;
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnRenderGlobalData( LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal )
    {
        ASSERT( lpFormatEtc != NULL );

        BOOL bResult = FALSE;

    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID( pDoc );

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if ((lpFormatEtc->cfFormat == CF_BITMAP
      || lpFormatEtc->cfFormat == CF_PALETTE)
    && pBM != NULL)
        {
        if (lpFormatEtc->cfFormat == CF_BITMAP)
            {
            }
        else // CF_PALETTE
            {
            }
        }
    else
        bResult = COleServerItem::OnRenderGlobalData( lpFormatEtc, phGlobal );

    return bResult;
    }

/***************************************************************************/

BOOL CPBSrvrItem::OnRenderFileData( LPFORMATETC lpFormatEtc, CFile* pFile )
    {
        ASSERT( lpFormatEtc != NULL );

        BOOL bResult = FALSE;

    CPBDoc* pDoc = GetDocument();

    ASSERT_VALID( pDoc );

    CBitmapObj* pBM = m_pBitmapObj ? m_pBitmapObj : pDoc->m_pBitmapObj;

    if (lpFormatEtc->cfFormat == CF_DIB && pBM != NULL)
        {
        TRY
            {
            // save as dib
            pBM->SaveResource( FALSE );
            pBM->WriteResource( pFile, CBitmapObj::rtDIB );
            bResult = TRUE;
            }
        CATCH( CFileException, ex )
            {
            theApp.SetFileError( IDS_ERROR_SAVE, ex->m_cause );
            return FALSE;
            }
        END_CATCH
        }
    else
        bResult = COleServerItem::OnRenderFileData( lpFormatEtc, pFile );

        return bResult;
    }

/***************************************************************************/
// CPBSrvrItem diagnostics

#ifdef _DEBUG
void CPBSrvrItem::AssertValid() const
    {
    COleServerItem::AssertValid();
    }

/***************************************************************************/

void CPBSrvrItem::Dump(CDumpContext& dc) const
    {
    COleServerItem::Dump(dc);
    }
#endif

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\sprite.cpp ===
#include "stdafx.h"
#include "global.h"
#include "sprite.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
IMPLEMENT_DYNAMIC( CDragger, CObject )
IMPLEMENT_DYNAMIC( CMultiDragger, CDragger )
IMPLEMENT_DYNAMIC(CSprite, CDragger)
#endif

#include "memtrace.h"

extern BOOL moduleInit;

  /**********************************************************************/
  /*                      CDragger Implementation                       */
  /**********************************************************************/

/*
 * OPTIMIZATION
 *
 * At the moment, draggers get a new DC whenever they need to draw or
 * erase.  We could cut that in half easily by merging the draw/erase
 * code, and achieve even better wins by allocating a single DC for a
 * multiple selection draw/erase.
 */

CDragger::CDragger( CWnd* pWnd, CRect* pRect )
    {
    ASSERT(pWnd != NULL);

    m_pWnd  = pWnd;
    m_state = hidden;

    m_rect.SetRect(0,0,0,0);

    if (pRect != NULL)
        m_rect = *pRect;
    }

CDragger::~CDragger()
    {
    if (m_pWnd->m_hWnd != NULL && m_state != hidden)
        Hide();
    }

/* CDragger::Draw
 *
 * This is a specialized Draw to draw our drag rectangles; drag
 * rectangles are the dotted rectangles which we draw when the user is
 * dragging a tracker to move or resize a control.
 */
void CDragger::Draw()
    {
    ASSERT( m_pWnd != NULL );

    CRect rect = m_rect;

    /*
     * This gets complex -- hold on to your hat.  The m_rect is
     * measured in client coordinates of the window, but since we
     * need to use GetWindowDC rather than GetDC (to avoid having
     * the m_rect clipped by the dialog's children) we must map
     * these coordinates to window coords.  We do this by mapping
     * them into screen coordinates, computing the offset from the
     * upper left corner of the dialog's WindowRect, and mapping
     * them back.  It's the most efficient way I can think to do
     * it; other suggestions are welcome.
     */
    CRect parentRect;

    m_pWnd->GetWindowRect( &parentRect );
    m_pWnd->ClientToScreen( &rect );

    rect.OffsetRect( -parentRect.left, -parentRect.top );

    // now we've got "rect" in the coordinates of the thing we
    // want to draw on.

    int dx = (rect.right - rect.left) - 1;
    int dy = (rect.bottom - rect.top) - 1;

    CDC* dc = m_pWnd->GetWindowDC();

    ASSERT( dc != NULL );

    CBrush* oldBrush = dc->SelectObject( GetHalftoneBrush() );

    dc->PatBlt( rect.left     , rect.top       , dx, 1 , PATINVERT );
    dc->PatBlt( rect.left     , rect.bottom - 1, dx, 1 , PATINVERT );
    dc->PatBlt( rect.left     , rect.top       , 1 , dy, PATINVERT );
    dc->PatBlt( rect.right - 1, rect.top       , 1 , dy, PATINVERT );

    dc->SelectObject( oldBrush );

    m_pWnd->ReleaseDC( dc );
    }

/* CDragger::Erase
 *
 * Since the default draw uses XOR, we can just Draw again to erase!
 */
void CDragger::Erase()
    {
    Draw();
    }

/* CDragger::Show, Hide
 *
 * The "drag rectangle" is the dotted rectangle which we draw when the
 * user is moving or resizing a control by dragging it with the mouse.
 * These functions erase and draw the drag rectangle, respectively.
 */
void CDragger::Hide()
    {
    if (m_state != shown)
        return;

    m_state = hidden;
    Erase();
    }

void CDragger::Show()
    {
    if (m_state != hidden)
        return;

    m_state = shown;
    Draw();
    }


void CDragger::Obscure( BOOL bObscure )
    {
    if (bObscure)
        {
        if (m_state != shown)
            return;

        Hide();
        m_state = obscured;
        }
    else
        {
        if (m_state != obscured)
            return;

        m_state = hidden;
        Show();
        }
    }

/* CDragger::Move
 *
 * Since nearly every single occurance of "CDragger->Show" occurred in
 * the context "Hide, m_rect = foo, Show", I decided to merge this
 * functionality into a single C++ function.
 */
void CDragger::Move(const CRect& newRect, BOOL bForceShow)
    {
    if ((m_rect == newRect) && !bForceShow)
        return;

    BOOL fShow = bForceShow || m_state == shown;
    Hide();
    m_rect = newRect;

    if (fShow)
        Show();
    }

void CDragger::MoveBy(int cx, int cy, BOOL bForceShow)
    {
    CSize offset (cx, cy);
    CPoint newTopLeft = m_rect.TopLeft() + offset;
    Move(newTopLeft, bForceShow);
    }

CRect CDragger::GetRect() const
    {
    return m_rect;
    }

void CDragger::Move(const CPoint& newTopLeft, BOOL bForceShow)
    {
    Move(m_rect - m_rect.TopLeft() + newTopLeft, bForceShow);
    }

void CDragger::SetSize(const CSize& newSize, BOOL bForceShow)
    {
    CRect newRect  = m_rect;
    newRect.right  = newRect.left + newSize.cx;
    newRect.bottom = newRect.top  + newSize.cy;

    Move(newRect, bForceShow);
    }

CMultiDragger::CMultiDragger() : m_draggerList()
    {
    ASSERT( m_draggerList.IsEmpty() );
    }

CMultiDragger::CMultiDragger(CWnd *pWnd) : CDragger(pWnd), m_draggerList()
    {
    ASSERT(m_draggerList.IsEmpty());
    }


CMultiDragger::~CMultiDragger()
    {
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger *pDragger = (CDragger*) m_draggerList.GetNext(pos);
        delete pDragger;
        }
    }

CRect CMultiDragger::GetRect() const
    {
    // accumulate the bounding rectangle for the group
    POSITION pos = m_draggerList.GetHeadPosition();

    CRect boundRect (32767, 32767, -32767, -32767);
    while (pos != NULL)
        {
        CDragger    *pDragger = (CDragger*) m_draggerList.GetNext(pos);
        boundRect.left  = min (boundRect.left, pDragger->m_rect.left);
        boundRect.right = max (boundRect.right, pDragger->m_rect.right);
        boundRect.top   = min (boundRect.top, pDragger->m_rect.top);
        boundRect.bottom= max (boundRect.bottom, pDragger->m_rect.bottom);
        }

    return boundRect;
    }

void CMultiDragger::Hide()
    {
    // hide each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Hide();
        }
    }

void CMultiDragger::Show()
    {
    // show each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Show();
        }
    }

void CMultiDragger::Draw()
    {
    // draw each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Draw();
        }
    }

void CMultiDragger::Erase()
    {
    // erase each dragger on the list
    POSITION pos = m_draggerList.GetHeadPosition();

    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->Erase();
        }
    }

void CMultiDragger::Move(const CPoint& newTopLeft, BOOL bForceShow)
    {
    // move each dragger to the new top left

    // first go through the list and find the current topmost leftmost
    // point

    CPoint  topLeft (32767, 32767);
    POSITION pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        CRect   draggerRect = pDragger->GetRect();
        if (draggerRect.left < topLeft.x)
            topLeft.x= draggerRect.left;
        if (draggerRect.top < topLeft.y)
            topLeft.y= draggerRect.top;
        }

    // now find the offset and move each dragger
    CSize   offset = newTopLeft - topLeft;
    pos = m_draggerList.GetHeadPosition();
    while (pos != NULL)
        {
        CDragger* pDragger = (CDragger*) m_draggerList.GetNext(pos);
        pDragger->MoveBy(offset.cx, offset.cy, bForceShow);
        }
    }

void CMultiDragger::Add(CDragger *pDragger)
    {
    // add the dragger to the list
    ASSERT(pDragger != NULL);
    m_draggerList.AddTail(pDragger);
    }

void CMultiDragger::Remove(CDragger *pDragger)
    {
    // remove the dragger from the list
    ASSERT(pDragger != NULL);
    POSITION pos = m_draggerList.Find(pDragger);
    if (pos != NULL)
        m_draggerList.RemoveAt(pos);
    }


CSprite::CSprite() : m_saveBits()
    {
    m_state = hidden;
    m_pWnd = NULL;
    }


CSprite::CSprite(CWnd* pWnd, CRect* pRect)
        : CDragger(pWnd, pRect), m_saveBits()
    {
    m_state = hidden;
    m_pWnd = pWnd;
    }


CSprite::~CSprite()
    {
    if (m_pWnd->m_hWnd != NULL && m_state != hidden)
        Hide();
    }


void CSprite::Move(const CRect& newRect, BOOL bForceShow)
    {
    CRect rect = newRect;

    if ((rect == m_rect) && !bForceShow)
        return;

    STATE oldState = m_state;
    Hide();
    if (newRect.Size() != m_rect.Size())
        m_saveBits.DeleteObject();
    m_rect = rect;
    if (bForceShow || oldState == shown)
        Show();
    }

void CSprite::SaveBits()
    {
    CClientDC dcWnd(m_pWnd);
    CDC dcSave;
    CBitmap* pOldBitmap;

    dcSave.CreateCompatibleDC(&dcWnd);
    if (m_saveBits.m_hObject == NULL)
        {
        m_saveBits.CreateCompatibleBitmap(&dcWnd, m_rect.Width(),
            m_rect.Height());
        }
    pOldBitmap = dcSave.SelectObject(&m_saveBits);
    dcSave.BitBlt(0, 0, m_rect.Width(), m_rect.Height(),
        &dcWnd, m_rect.left, m_rect.top, SRCCOPY);
    dcSave.SelectObject(pOldBitmap);
    }


void CSprite::Erase()
    {
    if (m_saveBits.m_hObject == NULL)
        return;

    LONG dwStyle = ::GetWindowLong(m_pWnd->m_hWnd, GWL_STYLE);
    ::SetWindowLong(m_pWnd->m_hWnd, GWL_STYLE, dwStyle & ~WS_CLIPCHILDREN);

    CClientDC dcWnd(m_pWnd);
    CDC dcSave;
    CBitmap* pOldBitmap;

    dcSave.CreateCompatibleDC(&dcWnd);
    pOldBitmap = dcSave.SelectObject(&m_saveBits);
    dcWnd.ExcludeUpdateRgn(m_pWnd);
    dcWnd.BitBlt(m_rect.left, m_rect.top, m_rect.Width(), m_rect.Height(),
        &dcSave, 0, 0, SRCCOPY);
    dcSave.SelectObject(pOldBitmap);

    ::SetWindowLong(m_pWnd->m_hWnd, GWL_STYLE, dwStyle);
    }


CHighlight::CHighlight()
    {
    m_bdrSize = 2;
    }


CHighlight::CHighlight(CWnd *pWnd, CRect *pRect, int bdrSize)
           : CDragger(pWnd, pRect)
    {
    m_bdrSize = bdrSize;
    m_rect.InflateRect(m_bdrSize, m_bdrSize);
    }

CHighlight::~CHighlight()
    {
    if (m_pWnd->m_hWnd != NULL && m_state != hidden)
        Hide();
    }


void CHighlight::Draw()
    {
    m_pWnd->UpdateWindow();

    CClientDC   dc(m_pWnd);
    CBrush      *pOldBrush  = dc.SelectObject(GetSysBrush(COLOR_HIGHLIGHT));

    // draw the top, right, bottom and left sides
    dc.PatBlt(m_rect.left    + m_bdrSize, m_rect.top                 ,
              m_rect.Width() - m_bdrSize, m_bdrSize                  , PATCOPY);
    dc.PatBlt(m_rect.right - m_bdrSize  , m_rect.top + m_bdrSize     ,
              m_bdrSize                 , m_rect.Height() - m_bdrSize, PATCOPY);
    dc.PatBlt(m_rect.left               , m_rect.bottom - m_bdrSize  ,
              m_rect.Width() - m_bdrSize, m_bdrSize                  , PATCOPY);
    dc.PatBlt(m_rect.left               , m_rect.top                 ,
              m_bdrSize                 , m_rect.Height() - m_bdrSize, PATCOPY);

    // restore the state of the DC
    dc.SelectObject(pOldBrush);
    }

void CHighlight::Erase()
    {
    m_pWnd->InvalidateRect(&m_rect);
    m_pWnd->UpdateWindow();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\srvritem.h ===
// srvritem.h : interface of the CPBSrvrItem class
//

class CPBSrvrItem : public COleServerItem
    {
    DECLARE_DYNAMIC(CPBSrvrItem)

    // Constructors
    public:

    CPBSrvrItem(CPBDoc* pContainerDoc, CBitmapObj* pBM = NULL);

    // Attributes
    CPBDoc* GetDocument() const { return (CPBDoc*)COleServerItem::GetDocument(); }

    // Implementation
    public:

    CBitmapObj* m_pBitmapObj;

    ~CPBSrvrItem();

    #ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    #endif

    virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
    virtual BOOL OnGetExtent( DVASPECT dwDrawAspect, CSize& rSize );
    virtual BOOL OnSetExtent( DVASPECT nDrawAspect, const CSize& size );
    virtual void OnOpen( void );
    virtual void OnShow( void );
    virtual void OnHide( void );
    virtual BOOL OnRenderGlobalData( LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal );
	virtual BOOL OnRenderFileData( LPFORMATETC lpFormatEtc, CFile* pFile );
	virtual COleDataSource* OnGetClipboardData( BOOL bIncludeLink,
                                                CPoint* pptOffset, CSize *pSize );
   
    protected:

    virtual void Serialize(CArchive& ar);   // overridden for document i/o
    };

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#include <afxcmn.h>         // for tooltips
#include <afxwin.h>         // MFC core and standard components
#include <objbase.h>
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE classes
#include <afxpriv.h>

#include <sti.h>
#include <wia.h>
#include <wiadevdp.h>

#include <gdiplus/gdiplus.h>

#include <UxTheme.h>
#include <TmSchema.h>

#include "bar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\tedit.cpp ===
/******************************************************************************/
/* Tedit.CPP: IMPLEMENTATION OF THE CTedit CLASS                              */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  Edit Control Object                                                       */
/*      CAttrEdit::OnPaint                                                   */
/*      CAttrEdit::OnEraseBkgnd                                               */
/*      CAttrEdit::OnRButtonDown                                              */
/*      CAttrEdit::OnChar                                                     */
/*      CAttrEdit::OnMouseMove                                                */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Text Edit Control Parent Window (Parent of Edit Control)                  */
/*      CTedit::CTedit                                                        */
/*      CTedit::CTedit                                                        */
/*      CTedit::~CTedit                                                       */
/*                                                                            */
/*  Miscellaneous Methods                                                     */
/*      CTedit::RefreshWindow                                                 */
/*      CTedit::SetTextColor                                                  */
/*      CTedit::SetBackColor                                                  */
/*      CTedit::SetTransparentMode                                            */
/*      CTedit::Undo                                                          */
/*      CTedit::ShowFontPalette                                               */
/*      CTedit::IsFontPaletteVisible                                          */
/*      CTedit::GetBitmap                                                     */
/*      CTedit::PostNcDestroy                                                 */
/*      CTedit::GetDefaultMinSize                                             */
/*                                                                            */
/*  Edit Control Notification and processing methods                          */
/*      CTedit::OnAttrEditEnChange                                            */
/*      CTedit::OnAttrEditFontChange                                          */
/*                                                                            */
/*  Control Notification/Window Messages                                      */
/*      CTedit::OnEraseBkgnd                                                  */
/*      CTedit::OnSize                                                        */
/*      CTedit::OnMove                                                        */
/*      CTedit::OnCtlColor                                                    */
/*      CTedit::OnNcCalcSize                                                  */
/*      CTedit::OnNcPaint                                                     */
/*      CTedit::OnNcHitTest                                                   */
/*      CTedit::OnRButtonDown                                                 */
/*                                                                            */
/*  Popup Menu Control Notification/Window Messages                           */
/*      CTedit::OnTextPlain                                                   */
/*      CTedit::OnTextBold                                                    */
/*      CTedit::OnTextItalic                                                  */
/*      CTedit::OnTextUnderline                                               */
/*      CTedit::OnTextSelectfont                                              */
/*      CTedit::OnTextSelectpointsize                                         */
/*      CTedit::OnEditCut                                                     */
/*      CTedit::OnEditCopy                                                    */
/*      CTedit::OnEditPaste                                                   */
/*      CTedit::OnTextDelete                                                  */
/*      CTedit::OnTextSelectall                                               */
/*      CTedit::OnTextPlace                                                   */
/*      CTedit::OnTextTexttool                                                */
/*                                                                            */
/*      CTedit::OnUpdateTextPlain                                             */
/*      CTedit::OnUpdateTextBold                                              */
/*      CTedit::OnUpdateTextItalic                                            */
/*      CTedit::OnUpdateTextUnderline                                         */
/*      CTedit::OnUpdateTextTexttool                                          */
/*                                                                            */
/******************************************************************************/

// TEDIT.CPP: IMPLEMENTATION OF THE CTEDIT CLASS
//
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusvw.h"
#include "pbrusfrm.h"
#include "imgwnd.h"
#include "pictures.h"
#include "minifwnd.h"
#include "tfont.h"
#include "tedit.h"
#include "tracker.h"

#include <imm.h>

#include "imgsuprt.h"

#ifndef WM_SYSTIMER
#define WM_SYSTIMER     0x118
#endif //WM_SYSTIMER


#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CAttrEdit, CEdit )
IMPLEMENT_DYNCREATE( CTedit, CWnd )

#include "memtrace.h"




/******************************************************************************/
// CAttrEdit

BEGIN_MESSAGE_MAP( CAttrEdit, CEdit )
    //{{AFX_MSG_MAP(CAttrEdit)
    ON_WM_PAINT()
    ON_WM_ERASEBKGND()
    ON_WM_RBUTTONDOWN()
    ON_WM_CHAR()

    ON_MESSAGE(WM_IME_CHAR, OnImeChar)
    ON_MESSAGE(WM_IME_COMPOSITION, OnImeComposition)
    ON_MESSAGE(WM_INPUTLANGCHANGE, OnInputLangChange)
    ON_WM_KILLFOCUS()


    ON_WM_NCHITTEST()
    ON_WM_SETFOCUS()
    ON_WM_SIZE()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_KEYDOWN()
    ON_MESSAGE(WM_SYSTIMER, OnSysTimer)

        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CAttrEdit::CAttrEdit()
    {
    m_bBackgroundTransparent = TRUE;
    m_pParentWnd             = NULL;
    m_uiLastChar[0] = 32;
    m_uiLastChar[1] = 32;

    m_rectUpdate.SetRectEmpty();


    m_strResult.Empty();
    m_bMouseDown = FALSE;
    m_hHCursor = theApp.LoadStandardCursor( IDC_IBEAM );
    m_hVCursor = theApp.LoadCursor( IDCUR_HIBEAM );
    m_hOldCursor = NULL;
    m_rectFmt.SetRectEmpty();
    m_iPrevStart = -1;
    m_bResizeOnly = FALSE;

    }

/******************************************************************************/

void CAttrEdit::OnPaint()
    {
    GetUpdateRect( &m_rectUpdate );


    if ( !m_pParentWnd->m_bVertEdit )
        {
        Default();
        return;
        }
    else
        {
        CFont*      pFont;
        CFont*      pOldFont = NULL;
        CPalette*   ppalOld = NULL;
        int         OldBkMode;
        COLORREF    OldTxtColor;
        CRect       rc = m_rectFmt;
        int         cnt = 0;
        int         i = 0, h = 0;
        int         nLen;
        CString     cStr;
        LPTSTR      lpStr;
        int         nStart, nEnd;
        CDC*        pDC = NULL;
        PAINTSTRUCT ps;

        const MSG *pCurrentMessage = GetCurrentMessage();
        //wParam is DC
        if ( pCurrentMessage->wParam )
            {
            HDC     hDC = (HDC) pCurrentMessage->wParam;
            pDC = CDC::FromHandle( hDC );
            }
        else
            pDC = BeginPaint( &ps );

        if (pDC == NULL || pDC->m_hDC == NULL)
            {
            theApp.SetGdiEmergency();
            return;
            }

        OldBkMode = pDC->GetBkMode();
        OldTxtColor = pDC->GetTextColor();
        ppalOld = PBSelectPalette(pDC, theApp.m_pPalette, FALSE);

        m_pParentWnd->SendMessage( WM_CTLCOLOREDIT, (WPARAM)pDC->m_hDC,
                                   (LPARAM) m_hWnd );

        pFont = GetFont();
        pOldFont = pDC->SelectObject( pFont );

        h = m_pParentWnd->m_iLineHeight;

        cnt = GetLineCount();

        GetSel( nStart, nEnd );
        if ( nStart == nEnd )
            {
            for ( i = 0; i < cnt; i++ )
                {
                nLen = LineLength( LineIndex( i ) );
                lpStr = cStr.GetBufferSetLength( nLen );
                GetLine( i, lpStr, nLen );
                TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                            (LPTSTR)lpStr, nLen, FALSE );
                }
            }
        else
            {
            int nStartLn, nEndLn;
            int nMaxText = GetWindowTextLength();
            int nChar = 0;

            nStartLn = LineFromChar( nStart );
            nEndLn   = LineFromChar( nEnd );

            //Before Start
            for ( i = 0; i < nStartLn; i++ )
                {
                nLen = LineLength( LineIndex( i ) );
                lpStr = cStr.GetBufferSetLength( nLen );
                GetLine( i, lpStr, nLen );
                TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                            (LPTSTR)lpStr, nLen, FALSE );
                nChar = LineIndex( i + 1 );
                }
            nLen = LineLength( LineIndex( i ) );
            lpStr = cStr.GetBufferSetLength( nLen );
            GetLine( i, lpStr, nLen );
            TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                        (LPTSTR)lpStr, nStart - nChar, FALSE );

            //Selected Text
            COLORREF bkColor  = pDC->SetBkColor( GetSysColor(COLOR_HIGHLIGHT) );
            COLORREF txtColor = pDC->SetTextColor( GetSysColor(COLOR_HIGHLIGHTTEXT) );
            int      bkMode   = pDC->SetBkMode( OPAQUE );

            CPoint ptStart( (DWORD)SendMessage( EM_POSFROMCHAR, nStart ) );
            if ( nStartLn == nEndLn )
                {
                TabTextOut( pDC, nStart, rc.right - h * i, ptStart.x,
                            (LPTSTR)lpStr + (nStart - nChar), nEnd - nStart, TRUE );
                }
            else
                {
                TabTextOut( pDC, nStart, rc.right - h * i, ptStart.x,
                            (LPTSTR)lpStr + (nStart - nChar), nLen + nChar - nStart, TRUE );
                nChar = LineIndex( i + 1 );

                for ( i++; i < nEndLn; i++ )
                    {
                    nLen = LineLength( LineIndex( i ) );
                    lpStr = cStr.GetBufferSetLength( nLen );
                    GetLine( i, lpStr, nLen );
                    TabTextOut( pDC, nChar, rc.right - h * i, 0,
                                (LPTSTR)lpStr, nLen, TRUE );
                    nChar = LineIndex( i + 1 );
                    }

                nLen = LineLength( LineIndex( i ) );
                lpStr = cStr.GetBufferSetLength( nLen );
                GetLine( i, lpStr, nLen );
                TabTextOut( pDC, nChar, rc.right - h * i, 0,
                            (LPTSTR)lpStr, nEnd - nChar, TRUE );
                }

            pDC->SetBkColor( bkColor );
            pDC->SetTextColor( txtColor );
            pDC->SetBkMode( bkMode );

            //After End
            if ( nEnd < nMaxText )
                {
                CPoint ptEnd( (DWORD)SendMessage( EM_POSFROMCHAR, nEnd ) );
                TabTextOut( pDC, nEnd, rc.right - h * i, ptEnd.x,
                            (LPTSTR)lpStr + (nEnd - nChar), nChar + nLen - nEnd, FALSE );
                for ( i++; i < cnt; i++ )
                    {
                    nLen = LineLength( LineIndex( i ) );
                    lpStr = cStr.GetBufferSetLength( nLen );
                    GetLine( i, lpStr, nLen );
                    TabTextOut( pDC, LineIndex( i ), rc.right - h * i, 0,
                                (LPTSTR)lpStr, nLen, FALSE );
                    }
                }
            }

        cStr.Empty();

        if (pOldFont)   pDC->SelectObject( pOldFont );
        if (ppalOld)    pDC->SelectPalette( ppalOld, FALSE );
        pDC->SetBkMode( OldBkMode );
        pDC->SetTextColor( OldTxtColor );

        if ( !pCurrentMessage->wParam )
            EndPaint( &ps );
        }
    }

/******************************************************************************/

BOOL CAttrEdit::OnEraseBkgnd( CDC* pDC )
    {
    if (m_pParentWnd == NULL)
        return CEdit::OnEraseBkgnd( pDC );

    ASSERT( m_pParentWnd->m_pImgWnd->m_pImg      != NULL );
    ASSERT( m_pParentWnd->m_pImgWnd->m_pImg->hDC != NULL );

    CPalette* ppalOld = NULL;

    if (m_rectUpdate.IsRectEmpty())
        {
        if (! GetUpdateRect( &m_rectUpdate, FALSE ))
            GetClientRect( &m_rectUpdate );

        ValidateRect( &m_rectUpdate );
        }
    CRect destRect = m_rectUpdate;

    ClientToScreen( &m_rectUpdate );

    m_pParentWnd->m_pImgWnd->ScreenToClient( &m_rectUpdate );

    ppalOld = PBSelectPalette(pDC, theApp.m_pPalette, FALSE);

    if (m_bBackgroundTransparent)
        m_pParentWnd->m_pImgWnd->DrawImage( pDC, &m_rectUpdate, &destRect );
    else
        pDC->FillRect( &destRect, &m_pParentWnd->m_hbrBkColor );

    if (ppalOld)
        pDC->SelectPalette( ppalOld, FALSE );

    m_rectUpdate.SetRectEmpty();

    return TRUE;
    }

/******************************************************************************/

void CAttrEdit::OnRButtonDown(UINT nFlags, CPoint point)
    {
    const MSG *pCurrentMessage = GetCurrentMessage();

    m_pParentWnd->SendMessage( pCurrentMessage->message,
                               pCurrentMessage->wParam,
                               pCurrentMessage->lParam);
    }

/******************************************************************************/

void CAttrEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{

    m_uiLastChar[0] = m_uiLastChar[1];

#ifndef UNICODE
    //
    // For DBCS we have to peek for the trail byte if the current
    // byte is a lead byte
    //
    if (IsDBCSLeadByte((BYTE)nChar))
    {
       MSG msg;
       ZeroMemory (&msg, sizeof(msg));
       ::PeekMessage (&msg, m_hWnd, WM_CHAR, WM_CHAR, PM_NOREMOVE);
       m_uiLastChar[1] = (UINT)MAKEWORD((BYTE)msg.wParam, (BYTE)nChar);
    }
    else
#endif // UNICODE
       m_uiLastChar[1] = nChar;


    if ( m_pParentWnd->m_bVertEdit )
       {
       SetCaretPosition( TRUE, NULL, -1 );
       UpdateInput();
       HideCaret();
       }

    CEdit::OnChar( nChar, nRepCnt, nFlags );

    if ( m_pParentWnd->m_bVertEdit )
       {
       SetCaretShape();
       UpdateInput();
       ShowCaret();
       }


    BOOL bRefresh = FALSE;

    switch (nChar)
        {
        case VK_BACK:
        case VK_DELETE:
        case VK_INSERT:
            bRefresh = TRUE;

            break;
        }

    if (bRefresh)
        m_pParentWnd->RefreshWindow(); /* enhance to do only the character involved */


     //
     // The edit control may have to resize
     //
     m_bResizeOnly = TRUE;
     m_pParentWnd->OnEnMaxText ();
     m_bResizeOnly = FALSE;

}


/******************************************************************************/

LRESULT CAttrEdit::OnInputLangChange( WPARAM wParam, LPARAM lParam )
{
    LRESULT lRet = Default();

    if ( m_pParentWnd->m_bVertEdit )
    {
        SetCaretPosition( TRUE, NULL, -1 );
    }
    return lRet;
}

/******************************************************************************/

LRESULT CAttrEdit::OnImeChar( WPARAM wParam, LPARAM lParam )
    {



        if ( m_pParentWnd->m_bVertEdit )
            {
            SetCaretPosition( TRUE, NULL, -1 );
            UpdateInput();
            HideCaret();
            }


            return Default();

    }

/******************************************************************************/

LRESULT CAttrEdit::OnImeComposition( WPARAM wParam, LPARAM lParam )
    {
    // Use Faster Way undr Japanese Keyboard Layout (Japanese IME)
    // Japanese IME may generate lots of chars at one time.
    // This way is better than waiting WM_CHAR.

    DWORD dwKeyboardLayout = PRIMARYLANGID(LOWORD(GetKeyboardLayout(0)));

    if ( dwKeyboardLayout == LANG_JAPANESE)
        {
        if (lParam & GCS_RESULTSTR)
            {
            HIMC hIMC = ImmGetContext(m_hWnd);

            DWORD dwSize;
            if (hIMC &&
                (dwSize = ImmGetCompositionString(hIMC,GCS_RESULTSTR,NULL,0L)))
                {
                    // ImmGetCompositionString returns the buffer size, IN BYTES.
                    // even if Unicode version.
                    LPTSTR lp = m_strResult.GetBufferSetLength(dwSize);
                    ImmGetCompositionString(hIMC,GCS_RESULTSTR,lp,dwSize+sizeof(TCHAR));
                    *(lp + dwSize/sizeof(TCHAR)) = TEXT('\0');
                    ReplaceSel(lp);
                    m_strResult.Empty();
                }

            ImmReleaseContext(m_hWnd, hIMC);

            lParam &= ~( GCS_RESULTREADSTR | GCS_RESULTREADCLAUSE | GCS_RESULTSTR | GCS_RESULTCLAUSE);
            if (lParam)
                DefWindowProc(WM_IME_COMPOSITION,wParam,lParam);

            // We'are not sure, how IME hide its composiiton window.
            m_pParentWnd->RefreshWindow();
            return 0;
            }
        }
    else if ( dwKeyboardLayout == LANG_KOREAN)
        {
        if ( m_pParentWnd->m_bVertEdit ) {

           Default();

           SetCaretPosition( FALSE, NULL, -2);

           // We should update current composition string.
           UpdateInput();
           return 0;
        }
        else {
           // We should update current composition string.
           UpdateInput();
               return Default();
        }
    }

    return Default();
    }

/******************************************************************************/

void CAttrEdit::OnKillFocus(CWnd* pNewWnd)
    {
    HIMC hIMC = ImmGetContext(m_hWnd);
    ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0L);
    ImmReleaseContext(m_hWnd, hIMC);

    CEdit::OnKillFocus(pNewWnd);


        if ( m_pParentWnd->m_bVertEdit )
                {
                SetFmtRect();
                Repaint();
                }


    }



/******************************************************************************/

UINT CAttrEdit::OnNcHitTest( CPoint point )
    {
    const MSG *pCurrentMessage = GetCurrentMessage();
    UINT  uiHitTestCode = (UINT)DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   pCurrentMessage->lParam);

        if ( (uiHitTestCode == HTCLIENT) )
                {
                if ( (m_pParentWnd->m_bVertEdit) )  SetVCursorShape();
                else                                SetHCursorShape();
                }

    return uiHitTestCode;
    }

/******************************************************************************/

void CAttrEdit::OnSetFocus( CWnd* pOldWnd )
    {
        Default();

        if ( m_pParentWnd->m_bVertEdit )
                {
                SetCaretShape();
                SetCaretPosition( FALSE, NULL, -1 );
                Repaint();
                }
    }

/******************************************************************************/

void CAttrEdit::OnSize( UINT nType, int cx, int cy )
    {
        Default();

        m_rectFmt.left = m_rectFmt.top = 0;
        m_rectFmt.right  = cx;
        m_rectFmt.bottom = cy;

        SetFmtRect();
    }


/******************************************************************************/

void CAttrEdit::OnLButtonDblClk(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        HideCaret();
        UpdateSel();
        SetStartSelect();

        int     tt = point.y;
        point.y = m_rectFmt.right - point.x;
        point.x = tt;

    const MSG *pCurrentMessage = GetCurrentMessage();
        DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   MAKELPARAM( point.x, point.y ));

        SetCaretPosition( TRUE, &point, -1 );
        ShowCaret();
        UpdateSel();
        UpdateWindow();
    }

/******************************************************************************/

void CAttrEdit::OnLButtonDown(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        HideCaret();
        UpdateSel();
        SetStartSelect();

        int     iPrevEnd;
        GetSel( m_iPrevStart, iPrevEnd );

        int     tt = point.y;
        point.y = m_rectFmt.right - point.x;
        point.x = tt;

        //reset caret position to get correct caret position
        CPoint  pt( -20000, -20000 );
        SetCaretPos( pt );

    const MSG *pCurrentMessage = GetCurrentMessage();
        DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   MAKELPARAM( point.x, point.y ));

        SetCaretPosition( TRUE, &point, m_iPrevStart );
        if ( GetKeyState(VK_SHIFT) >= 0 )       //not extend selection
                        GetSel( m_iPrevStart, iPrevEnd );
        ShowCaret();
        UpdateSel();
        UpdateWindow();

        m_bMouseDown = TRUE;

    }

/******************************************************************************/

void CAttrEdit::OnLButtonUp(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        m_bMouseDown = FALSE;

        HideCaret();
        UpdateSel();
        SetStartSelect();

        int     tt = point.y;
        point.y = m_rectFmt.right - point.x;
        point.x = tt;

    const MSG *pCurrentMessage = GetCurrentMessage();
        DefWindowProc( pCurrentMessage->message,
                   pCurrentMessage->wParam,
                   MAKELPARAM( point.x, point.y ));

        SetCaretPosition( TRUE, &point, m_iPrevStart );
        ShowCaret();
        UpdateSel();
        UpdateWindow();
    }


/******************************************************************************/

void CAttrEdit::OnMouseMove(UINT nFlags, CPoint point)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return;
                }

        if ( m_bMouseDown )
                {
                HideCaret();
                UpdateSel();
                SetStartSelect();

                int     tt = point.y;
                point.y = m_rectFmt.right - point.x;
                point.x = tt;

        const MSG *pCurrentMessage = GetCurrentMessage();
                DefWindowProc( pCurrentMessage->message,
                           pCurrentMessage->wParam,
                       MAKELPARAM( point.x, point.y ));

                SetCaretPosition( TRUE, &point, m_iPrevStart );
                ShowCaret();
                UpdateSel();
                UpdateWindow();
                }
        else    CEdit::OnMouseMove( nFlags, point );

    }

/******************************************************************************/

void CAttrEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
                return;
                }

        BOOL    bPrev = FALSE;

        HideCaret();

    switch (nChar)
        {
        case VK_LEFT:
                case VK_RIGHT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
        case VK_END:
                        {
                        UpdateSel();

                        CPoint ptCaretPos = GetCaretPos();
                        if ( ptCaretPos.y != 0 ) bPrev = TRUE;

                        int     iPrevEnd;
                        GetSel( m_iPrevStart, iPrevEnd );

                        SetStartSelect();       //for VK_RETURN

                        //reset caret position to get correct caret position
                        CPoint  pt( -20000, -20000 );
                        SetCaretPos( pt );

                        break;
                        }
        }

    switch (nChar)
        {
        case VK_LEFT:   nChar = VK_DOWN;                                        break;
                case VK_RIGHT:  nChar = VK_UP;                                          break;
                case VK_UP:             nChar = VK_LEFT;        bPrev = FALSE;  break;
                case VK_DOWN:   nChar = VK_RIGHT;       bPrev = FALSE;  break;
                case VK_HOME:                                           bPrev = FALSE;  break;
        case VK_END:                                            bPrev = TRUE;   break;
        }

    const MSG *pCurrentMessage = GetCurrentMessage();
    DefWindowProc( pCurrentMessage->message,
                   nChar,
                   pCurrentMessage->lParam);

    switch (nChar)
        {
        case VK_LEFT:
                case VK_RIGHT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
        case VK_END:
                        {
                        SetCaretPosition( bPrev, NULL, m_iPrevStart );
                        UpdateSel();
                        UpdateWindow();
                        break;
                        }
        case VK_HANJA:
                // For Korea hanja conversion.
                SetCaretPosition( FALSE, NULL, -2);
                break;

                }

        ShowCaret();
}

/******************************************************************************/
void            CAttrEdit::SetStartSelect( void )
        {
        int     nStart, nEnd;

        CPoint ptCaretPos = GetCaretPos();

        if ( ptCaretPos.y == 0 )
                {
                GetSel( nStart, nEnd );
                if ( nStart == nEnd )   SetSel( nStart, nEnd );
                }
        }

/******************************************************************************/
void CAttrEdit::SetCaretPosition( BOOL bPrev, CPoint* ptMouse, int iPrevStart )
        {

        HideCaret();

        // Get Caret Position
        CPoint  ptCaretPos;

        // Get End Selected Position to be Caret Position
        int     nStart, nEnd;

        GetSel( nStart, nEnd );

        if ( iPrevStart != -1 && nStart < iPrevStart )
            nEnd = nStart;
#ifdef UNICODE
        // When NT bug 116057 is fixed, remove this code


        // For composition string support
        if ( m_pParentWnd->m_bVertEdit && iPrevStart == -2)
            nEnd -= 1 * sizeof(WCHAR)/sizeof(TCHAR);
#endif //UNICODE
        CPoint ptPos( (DWORD)SendMessage( EM_POSFROMCHAR, nEnd ) );

        if ( nEnd >= GetWindowTextLength() ||
             ( ptPos.x == 0 && (bPrev) && (ptMouse == NULL ||
                                           ptMouse->y < ptPos.y ) ) )
            {
            CString cStr;
            CDC*    pDC = GetDC();
            CFont*  pFont = GetFont();
            CFont*  pOldFont;
            int     nLine = ( (ptPos.x < 0) ? GetLineCount() : LineFromChar( nEnd ) ) - 1;
            int     nChar = LineIndex( nLine );
            int     nLen = LineLength( nChar );
            LPTSTR  lpStr = cStr.GetBufferSetLength( nLen );
            TEXTMETRIC tm;

            pOldFont = pDC->SelectObject( pFont );
            GetLine( nLine, lpStr, nLen );

            pDC->GetTextMetrics( &tm );

            if ( !(tm.tmPitchAndFamily & TMPF_FIXED_PITCH) )
                m_iTabPos = tm.tmAveCharWidth;
            else
                {
                CPoint  len( pDC->GetTextExtent( TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52) );
                m_iTabPos = (len.x / 26 + 1) / 2;
                if ( m_iTabPos <= 0 )   m_iTabPos = tm.tmAveCharWidth;
                }

            m_iTabPos *= 8;
            if ( m_iTabPos <= 0 )   m_iTabPos = 1;

            CPoint  tt( 0, 0 );
            if ( nLen > 0 )
                {
                if ( *(lpStr + nLen - 1) == TEXT('\t') )
                    {
                    tt = (CPoint) (DWORD)SendMessage( EM_POSFROMCHAR, nChar + nLen - 1 );
                    tt.x = min( (tt.x / m_iTabPos + 1) * m_iTabPos, m_rectFmt.bottom - 1 );
                    }
                else
                    {
                    LPTSTR  lpChar = lpStr + nLen - 1;
                    int     nCnt;

                    for ( nCnt = 0; nCnt < nLen && *lpChar != TEXT('\t'); nCnt++, lpChar-- );
                    lpChar++;
                    tt = (CPoint) (DWORD)SendMessage( EM_POSFROMCHAR, nChar + nLen - nCnt );
                    tt.Offset( pDC->GetTextExtent( lpChar, nCnt ) );
                    }
                }
            cStr.Empty();
            ptCaretPos.x = tt.x;
            ptCaretPos.y = m_pParentWnd->m_iLineHeight * nLine;
            pDC->SelectObject( pOldFont );

            ReleaseDC( pDC );
            }
        else
            {
            ptCaretPos.x = ptPos.x;
            ptCaretPos.y = ptPos.y;
            }

        // H -> V
        CPoint  pt( m_rectFmt.right - ptCaretPos.y - m_pParentWnd->m_iLineHeight,
                    ptCaretPos.x );
        //
        // for some reason, typing spaces pushes the caret beyond the bottom of the rect.
        // Cover that case by forcing the caret to be at the bottom of the rect.
        //
        if (pt.y > m_rectFmt.bottom)
        {
           pt.y = m_rectFmt.bottom-2;
        }
        SetCaretPos( pt );

        //Set IME composition window position
        HIMC        himc;

        if (himc=ImmGetContext(m_hWnd))
            {
            COMPOSITIONFORM cf;
            RECT    rcClient;

            cf.dwStyle = CFS_RECT;
            cf.ptCurrentPos.x = m_rectFmt.right - ptCaretPos.y - 1;
            cf.ptCurrentPos.y = pt.y;
            GetClientRect( &rcClient );
            cf.rcArea = rcClient;

            ImmSetCompositionWindow(himc,&cf);
            ImmReleaseContext(m_hWnd, himc);
            }

#ifndef WINNT // don't call ImmSetCompositionWindow at this time.
        SetFmtRect();   //it should be called after set IME position
#endif

        ShowCaret();
        }

/******************************************************************************/
void            CAttrEdit::SetCaretShape( void )
        {
        HideCaret();
        ::DestroyCaret();
        ::CreateCaret( m_hWnd, NULL, m_pParentWnd->m_iLineHeight, 2 );
        ShowCaret();
        }

/******************************************************************************/
void            CAttrEdit::SetFmtRect()
        {
        RECT    rc;

        rc.left = rc.top = 0;
        if ( m_pParentWnd->m_bVertEdit )
                {
                rc.right  = m_rectFmt.bottom;
                rc.bottom = m_rectFmt.right;
                }
        else
                {
                rc.right  = m_rectFmt.right;
                rc.bottom = m_rectFmt.bottom;
                }
        
        HIMC            himc;
        COMPOSITIONFORM cf;
        BOOL            bResult = FALSE;

        if (himc=ImmGetContext(m_hWnd)) {
            bResult = ImmGetCompositionWindow(himc,&cf);
        }
        
        SetRectNP( &rc );
        
        if (himc && bResult) {
            ImmSetCompositionWindow(himc,&cf);
        }

        }

/******************************************************************************/
void CAttrEdit::Repaint(void)
    {
        InvalidateRect( NULL, TRUE );
        UpdateWindow();
        }

/******************************************************************************/
void CAttrEdit::UpdateSel(void)
    {
        int     nStart, nEnd;

        GetSel( nStart, nEnd );

        if (nStart != nEnd )
                {
                RECT    rc = m_rectFmt;

                if ( nStart > nEnd )
                        {
                        int     tt = nStart;
                        nStart = nEnd;
                        nEnd = tt;
                        }

                CPoint ptStart( (DWORD)SendMessage( EM_POSFROMCHAR, nStart ) );
                rc.right -= ptStart.y;

                if ( nEnd < GetWindowTextLength() )
                        {
                        CPoint ptEnd( (DWORD)SendMessage( EM_POSFROMCHAR, nEnd ) );
                        rc.left = m_rectFmt.right - ptEnd.y  - m_pParentWnd->m_iLineHeight;
                        }

                InvalidateRect( &rc );
                }
        }

/******************************************************************************/
void CAttrEdit::UpdateInput(void)
    {
        RECT    rc = m_rectFmt;

        CPoint pt( GetCaretPos() );
        rc.right = pt.x + m_pParentWnd->m_iLineHeight;

        InvalidateRect( &rc );
        }

/******************************************************************************/

LRESULT CAttrEdit::OnSysTimer( WPARAM wParam, LPARAM lParam )
    {

        if ( !m_pParentWnd->m_bVertEdit )
                {
                Default();
                return 1L;
                }

    return 1L;
    }

/******************************************************************************/
void CAttrEdit::SetHCursorShape(void)
    {
        if ( GetSafeHwnd() )
                {
                ShowCursor( FALSE );
                SetClassLongPtr( m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_hHCursor );
                ShowCursor( TRUE );
                }
        }

/******************************************************************************/
void CAttrEdit::SetVCursorShape(void)
    {
        if ( GetSafeHwnd() )
                {
                ShowCursor( FALSE );
                SetClassLongPtr( m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_hVCursor );
                ShowCursor( TRUE );
                }
        }

/******************************************************************************/
void CAttrEdit::TabTextOut( CDC* pDC, int nCharIndex, int x, int y, LPCTSTR lpStr, int nCount, BOOL bSelect )
{
    int     i, nCnt;
    LPCTSTR lpChar = lpStr;
    CPoint  pt;
    CPoint  ptEnd;
    RECT    rc;
    BOOL    bReverse;

    CSize s1 = pDC->GetTextExtent( TEXT("a"), 1 );
    CSize s2 = pDC->GetTextExtent( TEXT("aa"), 2 );
    bReverse = (s1.cx == s2.cx);

    rc.left = x - m_pParentWnd->m_iLineHeight;
    rc.right = x;

    for ( i = 0, nCnt = 0; i < nCount; i++, nCnt++, lpStr++ )
    {
        if ( *lpStr == TEXT('\t') )
        {
            pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex );
            if ( nCnt > 0 )
            {
                pDC->TextOut( x, pt.x, lpChar, nCnt );
            }

            nCharIndex += nCnt + 1;
            nCnt = -1;
            lpChar = lpStr + 1;
            if ( bSelect )
            {
                pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex - 1 );
                rc.top = pt.x;

                if ( i < (nCount - 1) )
                {
                    pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex );
                    rc.bottom = pt.x;
                }
                else
                {
                    rc.bottom = min( (pt.x / m_iTabPos + 1) * m_iTabPos,
                                     m_rectFmt.bottom - 1 );
                }

                pDC->ExtTextOut( x, rc.top, 0 /*ETO_OPAQUE*/, &rc, NULL, 0, NULL );
            }
        }
    }

    if ( nCnt > 0 )
    {
        pt = (CPoint)(DWORD)SendMessage( EM_POSFROMCHAR, nCharIndex );
        pDC->TextOut( x, pt.x, lpChar, nCnt );
    }
}


/******************************************************************************/
/******************************************************************************/
// CTedit

BEGIN_MESSAGE_MAP( CTedit, CWnd )
    //{{AFX_MSG_MAP(CTedit)
    ON_WM_SIZE()
    ON_WM_MOVE()
    ON_WM_CTLCOLOR()
    ON_WM_NCCALCSIZE()
    ON_WM_NCPAINT()
    ON_WM_NCHITTEST()
    ON_WM_RBUTTONDOWN()
    ON_COMMAND(ID_TEXT_PLAIN, OnTextPlain)
    ON_COMMAND(ID_TEXT_BOLD, OnTextBold)
    ON_COMMAND(ID_TEXT_ITALIC, OnTextItalic)
    ON_COMMAND(ID_TEXT_UNDERLINE, OnTextUnderline)
    ON_COMMAND(ID_TEXT_SELECTFONT, OnTextSelectfont)
    ON_COMMAND(ID_TEXT_SELECTPOINTSIZE, OnTextSelectpointsize)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_CLEAR, OnTextDelete)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnTextSelectall)
    ON_COMMAND(ID_EDIT_UNDO, OnTextUndo)
    ON_COMMAND(ID_TEXT_PLACE, OnTextPlace)
    ON_COMMAND(ID_VIEW_TEXT_TOOLBAR, OnTextTexttool)
    ON_WM_LBUTTONDOWN()
        //}}AFX_MSG_MAP
    ON_WM_GETMINMAXINFO()
    ON_MESSAGE(WM_MOVING, OnMoving)
    ON_EN_CHANGE(IDC_ATTREDIT, OnAttrEditEnChange)
    ON_EN_MAXTEXT(IDC_ATTREDIT, OnEnMaxText)
    ON_EN_UPDATE(IDC_ATTREDIT, OnEnUpdate)

    ON_WM_DESTROY()

END_MESSAGE_MAP()

/******************************************************************************/
// CTedit construction/destruction

CTedit::CTedit()
    {
    m_eLastAction     = eNO_CHANGE;
    m_bCleanupBKBrush = FALSE;
    m_bStarting       = TRUE;
    m_bPasting        = FALSE;
    m_bExpand         = FALSE;
    m_bChanged        = FALSE;
    m_uiHitArea       = HTNOWHERE;
    m_crFGColor       = ::GetSysColor( COLOR_WINDOWTEXT );
    m_crBKColor       = ::GetSysColor( COLOR_WINDOW     );

    // Need to be initialized during first GETMINMAXINFO call
    m_SizeMinimum.cx = 1;
    m_SizeMinimum.cy = 1;

    m_bBackgroundTransparent = TRUE;

    m_cRectOldPos.SetRectEmpty();
    m_cRectWindow.SetRectEmpty();


    m_bVertEdit = FALSE;
    m_bAssocIMC = FALSE;
    m_hIMCEdit = NULL;
    m_hIMCFace = NULL;
    m_hIMCSize = NULL;
    m_hWndFace = NULL;
    m_hWndSize = NULL;

    }

/******************************************************************************/

CTedit::~CTedit()
    {
    if (m_bCleanupBKBrush)
        {
        m_hbrBkColor.DeleteObject();      //Set in SetTransparentMode
        m_bCleanupBKBrush = FALSE;
        }
    }

/******************************************************************************/

BOOL CTedit::Create( CImgWnd* pParentWnd,
                     COLORREF crefForeground,
                     COLORREF crefBackground,
                     CRect&   rectPos,
                     BOOL     bBackTransparent )
    {
    if (! m_bStarting)
        return FALSE;

    // Initialize member variables
    m_pImgWnd   = pParentWnd;
    m_crBKColor = crefBackground;
    m_crFGColor = crefForeground;
    m_bBackgroundTransparent = bBackTransparent; // Do this or else

    SetTransparentMode( bBackTransparent );

    CRect rectText = rectPos;

    rectText.InflateRect( CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE );
    rectText.right  += CTracker::HANDLE_SIZE * 2;
    rectText.bottom += CTracker::HANDLE_SIZE * 2;

    if (! CWnd::Create( NULL, TEXT(""), WS_CHILD | WS_THICKFRAME, rectText, pParentWnd, IDC_ATTREDIT + 1 ))
        return FALSE;

    CRect rectEditArea;

    GetClientRect( &rectEditArea );

    m_cEdit.m_pParentWnd = this;

    if (! m_cEdit.Create( WS_CHILD | ES_LEFT | ES_MULTILINE | ES_NOHIDESEL | ES_WANTRETURN, rectEditArea, this, IDC_ATTREDIT ))
        {
        theApp.SetMemoryEmergency();

        DestroyWindow();
        return FALSE;
        }

    ClientToScreen( &rectEditArea ); // use this to let the font tool where not to cover

    m_pcTfont = new CTfont( this ); // this is the class Text Font Pallette
                                    // it is derived from cframewnd and will
    ASSERT( m_pcTfont != NULL );    // auto destruct when this window
                                    // 'CTedit' is Destroyed
    if (m_pcTfont == NULL || ! m_pcTfont->Create( rectEditArea ))
        {
        theApp.SetMemoryEmergency();

        DestroyWindow();

        m_pcTfont = NULL;
        return FALSE;
        }

    // reset the width and height to the minimum if nessesary
    CSize size = GetDefaultMinSize(); // must call after ctfont object created (it sets our font).
    m_cRectWindow = CRect( rectText.TopLeft(), size );
    SetWindowPos( &wndTop, 0, 0, size.cx, size.cy, SWP_NOACTIVATE | SWP_NOMOVE );

    ShowWindow( SW_SHOWNOACTIVATE );

    GetClientRect( &rectEditArea );

    m_cEdit.SetWindowPos( &wndTopMost, 0, 0, rectEditArea.Width(),
                                             rectEditArea.Height(), 0 );
    m_cEdit.ShowWindow( SW_SHOWNOACTIVATE );

    m_bStarting = FALSE;


        //get all control windows on ToolBar for controling IME
        CWnd* pcWndFace = m_pcTfont->GetFontFaceControl();
        if ( (pcWndFace != NULL) && (pcWndFace->GetSafeHwnd() != NULL) )
                        m_hWndFace = pcWndFace->m_hWnd; //static

        CWnd* pcWndSize = m_pcTfont->GetFontSizeControl();
        if ( (pcWndSize != NULL) && (
                  pcWndSize->GetSafeHwnd() != NULL) )
                {
                CWnd* pcWndEditSize = pcWndSize->GetWindow( GW_CHILD ); //edit
                if ( (pcWndEditSize != NULL) && (
                          pcWndEditSize->GetSafeHwnd() != NULL) )
                                m_hWndSize = pcWndEditSize->m_hWnd;     //edit
                }

        //save original Edit control
        if ( m_cEdit.GetSafeHwnd() )
                m_cEdit.m_hOldCursor = (HCURSOR) SetClassLongPtr( m_cEdit.m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_cEdit.m_hHCursor );


         //only DBCS font would enable IME
        CFont* pcFont = m_cEdit.GetFont();
        LOGFONT     lf;
        pcFont->GetObject( sizeof( LOGFONT ), &lf );
        if ( !IS_DBCS_CHARSET( lf.lfCharSet ) )
                {
                m_bAssocIMC = TRUE;
                if (!IsCUAS())
                    m_hIMCEdit = DisableIme( m_cEdit.m_hWnd );
                m_hIMCFace = DisableIme( m_hWndFace );
                m_hIMCSize = DisableIme( m_hWndSize );
                }


        //initial Caret Position
        if ( m_bVertEdit )
                {
                CPoint  pt( 0, 0 );
                m_cEdit.SetCaretPos( pt );
                m_cEdit.SetCaretPosition( FALSE, NULL, -1 );
                }

    m_cEdit.SetFocus();

    return TRUE;
    }

/******************************************************************************/

BOOL CTedit::PreCreateWindow( CREATESTRUCT& cs )
    {
    cs.dwExStyle |= WS_EX_TRANSPARENT;

    return CWnd::PreCreateWindow( cs );
    }

/******************************************************************************/

void CTedit::RefreshWindow( CRect* prect, BOOL bErase )
    {
    if (! m_bStarting)
        {
        UINT flags = RDW_INVALIDATE;

        if (bErase)
            flags |= RDW_ERASE;

        if ( m_bVertEdit )
            {
            m_cEdit.SetFmtRect();
            m_cEdit.Repaint();
            }

        else
            m_cEdit.RedrawWindow( prect, NULL, flags );
        }
    }

/******************************************************************************/

void CTedit::SetTextColor( COLORREF crColor )
    {
    m_crFGColor = crColor;
    RefreshWindow( NULL, FALSE );
    }

/******************************************************************************/

void CTedit::SetBackColor( COLORREF crColor )
    {
    m_crBKColor = crColor;

    if (! m_bBackgroundTransparent)
        {
        m_bBackgroundTransparent = TRUE; // just fake it out
        SetTransparentMode( FALSE ); // to setup the background brush when in opaque mode
        }
    }

/******************************************************************************/

void CTedit::SetTransparentMode( BOOL bTransparent )
    {
    BOOL bRefresh = ((! m_bBackgroundTransparent &&   bTransparent)
                  || (  m_bBackgroundTransparent && ! bTransparent));

    m_cEdit.m_bBackgroundTransparent = bTransparent;
            m_bBackgroundTransparent = bTransparent;

    if (m_bCleanupBKBrush)
        {
        m_hbrBkColor.DeleteObject();
        m_bCleanupBKBrush = FALSE;
        }

    if (! m_bBackgroundTransparent)
        {
        m_hbrBkColor.CreateSolidBrush( m_crBKColor );
        m_bCleanupBKBrush = TRUE;
        }

    if (bRefresh)
        {
        InvalidateRect( NULL );
        UpdateWindow();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::Undo()
    {

    if ( m_bVertEdit )
        m_cEdit.HideCaret();

    switch(m_eLastAction)
        {
        case eEBOX_CHANGE:
            m_cEdit.Undo();
            break;

        case eFONT_CHANGE:
            ASSERT(m_pcTfont != NULL);

            if (m_pcTfont != NULL)
                {
                m_pcTfont->Undo();
                }
             break;

        case eSIZE_MOVE_CHANGE:
            if (! m_cRectOldPos.IsRectEmpty())
                MoveWindow( m_cRectOldPos );
             break;

        default:
             break;
        }


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretShape();
                m_cEdit.SetCaretPosition( TRUE, NULL, -1 );
                m_cEdit.ShowCaret();
                }

    }

/******************************************************************************/

void CTedit::ShowFontPalette(int nCmdShow)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        theApp.m_bShowTextToolbar = ! theApp.m_bShowTextToolbar;

        m_pcTfont->ShowWindow(nCmdShow);
        }
    }

/******************************************************************************/

BOOL CTedit::IsFontPaletteVisible(void)
    {
    BOOL bWindowVisible = FALSE;

    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        bWindowVisible = m_pcTfont->IsWindowVisible();
        }

    return bWindowVisible;
    }

/******************************************************************************/

void CTedit::ShowFontToolbar(BOOL bActivate)
{
        // FEATURE: Remove ShowFontPalette after RTM

        if (m_pcTfont == NULL)
        {
                return;
        }

        m_pcTfont->ShowWindow(bActivate ? SW_SHOW : SW_SHOWNOACTIVATE);
}

/******************************************************************************/

void CTedit::HideFontToolbar(void)
{
        if (m_pcTfont == NULL)
        {
                return;
        }

        m_pcTfont->ShowWindow(SW_HIDE);
}

/******************************************************************************/
// Returns a Ptr to a discardable bitmap (CBitmap object) or NULL on error

void CTedit::GetBitmap( CDC* pDC, CRect* prectImg )
    {
    if (! m_bBackgroundTransparent)
        pDC->FillRect( prectImg, &m_hbrBkColor );

    m_cEdit.SetSel( -1, 0 );


    if ( m_bVertEdit )
        {
        m_cEdit.SetFmtRect();
        m_cEdit.UpdateWindow();
        }


    CPoint ptViewOrgOld = pDC->SetViewportOrg( prectImg->left, prectImg->top );

    m_cEdit.SendMessage( WM_PAINT, (WPARAM)(pDC->m_hDC) );

    pDC->SetViewportOrg( ptViewOrgOld );
    pDC->SelectClipRgn( NULL );
    }

/******************************************************************************/

void CTedit::PostNcDestroy()
    {

    // If m_pcTfont is destroyed by shutdown before CTedit,
    // m_pcTfont will be null
    if (m_pcTfont != NULL)
        {
        m_pcTfont->DestroyWindow();
        m_pcTfont = NULL;
        }

    delete this;
    }

/******************************************************************************/

CSize CTedit::GetDefaultMinSize( void )
    {
    CRect cRectClient;
    int   iWidth;
    int   iHeight;

    // edit control takes up the whole client area of the ctedit
    // object/window, so width of client of ctedit is same as widht of edit
    // control window.  Edit control window has no border.
    GetClientRect( &cRectClient );

    iWidth  = cRectClient.Width();
    iHeight = cRectClient.Height();

    CDC*   pDC    = m_cEdit.GetDC();
    CFont* pcFont = m_cEdit.GetFont();

    if (pDC    != NULL
    &&  pcFont != NULL)
        {
        TEXTMETRIC tm;
        CFont*     pcFontOld = NULL;

        pcFontOld = pDC->SelectObject( pcFont );

        pDC->GetTextMetrics( &tm );

        BOOL bUpdateSize = FALSE;

        m_SizeMinimum.cx = tm.tmAveCharWidth * MIN_CHARS_DISPLAY_SIZE + CTracker::HANDLE_SIZE * 2;
        m_SizeMinimum.cy = tm.tmHeight                                + CTracker::HANDLE_SIZE * 2;

        if (m_SizeMinimum.cx > iWidth) // must be able to at least display MIN_CHARS_DISPLAY_SIZE
            {
            iWidth      = m_SizeMinimum.cx;
            bUpdateSize = TRUE;
            }

        if (m_SizeMinimum.cy > iHeight) // must be able to at least 1 char high
            {
            iHeight     = m_SizeMinimum.cy;
            bUpdateSize = TRUE;
            }

        if (bUpdateSize)
            m_eLastAction = eNO_CHANGE; // don't want user to be able to undo this

        if (pcFontOld != NULL)
            {
            pDC->SelectObject( pcFontOld );
            }
        }
    if (pDC != NULL)
        m_cEdit.ReleaseDC( pDC );

    cRectClient.SetRect( 0, 0, iWidth - 1, iHeight - 1 );

    ClientToScreen( &cRectClient );
    m_pImgWnd->ScreenToClient( &cRectClient );

    CRect rectDrawing = m_pImgWnd->GetDrawingRect();

    if (cRectClient.right > rectDrawing.right)
        iWidth -= (cRectClient.right - rectDrawing.right) - CTracker::HANDLE_SIZE;

    if (cRectClient.bottom > rectDrawing.bottom)
        iHeight -= (cRectClient.bottom - rectDrawing.bottom) - CTracker::HANDLE_SIZE;

    m_SizeMinimum.cx = iWidth;
    m_SizeMinimum.cy = iHeight;

    return CSize( iWidth, iHeight );
    }

/******************************************************************************/

void CTedit::OnAttrEditEnChange(void)
    {
    m_eLastAction = eEBOX_CHANGE;

    if (m_bRefresh)
        m_cEdit.UpdateWindow();


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretPosition( TRUE, NULL, -1 );
                m_cEdit.UpdateWindow();
                }

    }

/******************************************************************************/

void CTedit::OnEnUpdate()
    {
    CPoint ptCaretPos = m_cEdit.GetCaretPos();
    CPoint ptLastChar( (DWORD)m_cEdit.SendMessage( EM_POSFROMCHAR,
                               (WPARAM)(m_cEdit.GetWindowTextLength() - 1) ) );
    CRect rect;
    m_cEdit.GetClientRect( &rect );
    rect.top    = ptCaretPos.y;
    rect.bottom = ptLastChar.y + m_iLineHeight;
    m_cEdit.InvalidateRect( &rect, TRUE );

    m_bChanged = TRUE;
    }

/******************************************************************************/

void CTedit::OnEnMaxText()
    {

    if (m_bPasting)
        {
        if (!m_cEdit.m_bResizeOnly)
        {
            AfxMessageBox( IDS_UNABLE_TO_PASTE, MB_OK | MB_ICONEXCLAMATION );
        }
        return;
        }

    CFont* pfntEdit = m_cEdit.GetFont();

    if (pfntEdit == NULL)
        return;

    CClientDC dc( &m_cEdit );

    CFont* pfntOld = dc.SelectObject( pfntEdit );

    TEXTMETRIC tm;

    dc.GetTextMetrics( &tm );

    CRect rectText;
    CRect rectImg;

    GetWindowRect( &rectText );

    m_pImgWnd->ScreenToClient( &rectText );

    POINT pt;
    ::GetCaretPos (&pt);
    //
    // If the next character would extend past the end of the
    // edit window, grow the window


    if (!m_bVertEdit && m_cEdit.m_bResizeOnly &&
       ((rectText.left + pt.x + 2*tm.tmMaxCharWidth < rectText.right)
       || (rectText.top + pt.y + 2*tm.tmHeight < rectText.bottom)) )
    {
       return;
    }
    else if (m_bVertEdit && m_cEdit.m_bResizeOnly &&
       ((pt.x - tm.tmMaxCharWidth > 0)
       || (rectText.top + pt.y + 2*tm.tmHeight < rectText.bottom)) )
    {
       return;
    }
    m_pImgWnd->GetClientRect ( &rectImg );


    if (m_cEdit.m_strResult.IsEmpty())
    {

                if (m_bVertEdit)
                        rectText.left -= tm.tmHeight;
                else
                rectText.bottom += tm.tmHeight;
    }
    else
    {
        CRect rectTmp = rectText;
        int nLen = m_cEdit.m_strResult.GetLength();


        if (m_bVertEdit)
           rectText.left -= dc.DrawText(m_cEdit.m_strResult.GetBuffer(nLen),
                                      nLen,&rectTmp,
                                      DT_CALCRECT | DT_LEFT | DT_WORDBREAK);
        else
           rectText.bottom += dc.DrawText(m_cEdit.m_strResult.GetBuffer(nLen),
                                      nLen,&rectTmp,
                                      DT_CALCRECT | DT_LEFT | DT_WORDBREAK);
    }

    CRect rectDrawing = m_pImgWnd->GetDrawingRect();

    if ( ((m_bVertEdit) && rectText.left>=rectDrawing.left && rectText.left >= rectImg.left) ||
         ((!m_bVertEdit) && rectText.bottom<=rectDrawing.bottom && rectText.bottom<=rectImg.bottom) )
    {
        MoveWindow( &rectText );
        m_cEdit.UpdateWindow();

        if ( m_bVertEdit )
            m_cEdit.UpdateInput();

        if (!m_cEdit.m_bResizeOnly)
        {
            if (m_cEdit.m_strResult.IsEmpty())
            {
                #ifdef UNICODE
                WCHAR ch[3];

                ch[0] = (WCHAR)m_cEdit.m_uiLastChar[0];
                ch[1] = L'\0';
                #else
                BYTE ch[3];
                //
                // Put lead and trail bytes in proper place for DBCS characters.
                //
                if (IsDBCSLeadByte (HIBYTE(LOWORD(m_cEdit.m_uiLastChar[0]))))
                {
                   ch[0] = HIBYTE(LOWORD(m_cEdit.m_uiLastChar[0]));
                   ch[1] = LOBYTE(LOWORD(m_cEdit.m_uiLastChar[0]));
                   ch[2] = '\0';
                }
                else
                {
                   ch[0] = LOBYTE(LOWORD(m_cEdit.m_uiLastChar[0]));
                   ch[1] = '\0';
                }
                #endif // UNICODE
                if (ch[0] == VK_RETURN)
                {
                    lstrcpy((LPTSTR)ch, TEXT("\r\n"));
                }

                m_cEdit.ReplaceSel((LPCTSTR) ch );
            }
             else
            {
                int nLen = m_cEdit.m_strResult.GetLength();

                m_cEdit.ReplaceSel( m_cEdit.m_strResult.GetBuffer(nLen));
            }
        }
    }

    if (pfntOld)
        dc.SelectObject( pfntOld );
    }

/******************************************************************************/

void CTedit::OnAttrEditFontChange(void)
    {
    CClientDC editDC( &m_cEdit );
    CFont* pcFont = m_cEdit.GetFont();
    if (!pcFont)
    {
        return; // this happens when you "escape" from the font
                //  selection listbox
    }
    CFont* pFontOld = editDC.SelectObject( pcFont);

    TEXTMETRIC tm;

    editDC.GetTextMetrics( &tm );

    m_iLineHeight = tm.tmHeight;


    #ifdef _DEBUG
    TRACE1( "New font line height %d.\n", m_iLineHeight );
    #endif


        //only DBCS associated font would enable IME
        if ( !m_bStarting )
                {

                LOGFONT     lf;

                pcFont->GetObject( sizeof( LOGFONT ), &lf );
                if ( IS_DBCS_CHARSET( lf.lfCharSet ) )

                        {

                        if (m_bAssocIMC)
                                {

                                m_bAssocIMC = FALSE;
                                if (!IsCUAS())
                                    {
                                    EnableIme( m_cEdit.m_hWnd, m_hIMCEdit );
                                    m_hIMCEdit = NULL;
                                    }
                                EnableIme( m_hWndFace, m_hIMCFace );
                                EnableIme( m_hWndSize, m_hIMCSize );
                                m_hIMCFace = NULL;
                                m_hIMCSize = NULL;
                                m_pcTfont->SetFocus();
                                }
                        }
                else
                        {

                        if (!m_bAssocIMC)
                                {

                                m_bAssocIMC = TRUE;
                                if (!IsCUAS())
                                    m_hIMCEdit = DisableIme( m_cEdit.m_hWnd );
                                m_hIMCFace = DisableIme( m_hWndFace );
                                m_hIMCSize = DisableIme( m_hWndSize );
                                m_pcTfont->SetFocus();
                                }
                        }
                }


    if (pFontOld != NULL)
        editDC.SelectObject( pFontOld );

    m_eLastAction = eFONT_CHANGE;
    }

/******************************************************************************/

void CTedit::OnSize( UINT nType, int cx, int cy )
    {
    if (! m_bStarting)
        ShowWindow( SW_HIDE );

    // need to do this if transparent to force see through
    m_cRectOldPos = m_cRectWindow;
    GetWindowRect( &m_cRectWindow );
    m_pImgWnd->ScreenToClient( m_cRectWindow );

    m_eLastAction = eSIZE_MOVE_CHANGE;

    // could be NULL when main window is created and child edit window
    // has not been created yet.
    if (m_cEdit.GetSafeHwnd() != NULL)
        {
        m_cEdit.MoveWindow( 0, 0, cx, cy );
        m_cEdit.SetWindowPos( &wndTopMost, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }
    InvalidateRect( NULL );
    UpdateWindow();

    if (m_bBackgroundTransparent)
        {
        RefreshWindow();
        }
    if (! m_bStarting)
        ShowWindow( SW_SHOW );


        if ( m_bVertEdit )
                {
                m_cEdit.SetFmtRect();
                CPoint pt( -20000, -20000 );
                m_cEdit.SetCaretPos( pt );
                m_cEdit.SetCaretPosition( FALSE, NULL, -1 );
                m_cEdit.Repaint();
                }


    }

/******************************************************************************/

void CTedit::OnMove( int x, int y )
    {
    // need to do this if transparent to force see through
    m_cRectOldPos = m_cRectWindow;
    GetWindowRect( &m_cRectWindow );
    m_pImgWnd->ScreenToClient( m_cRectWindow );

    if (m_cRectOldPos.Width()  != m_cRectWindow.Width()
    ||  m_cRectOldPos.Height() != m_cRectWindow.Height())
        {
        //reset back to previous, since new will be updated in onsize, due to
        // size and move happening both (e.g. sizing either left or top side
        // causes an onmove then an onsize
        m_cRectWindow = m_cRectOldPos;
        }
    m_eLastAction = eSIZE_MOVE_CHANGE;

    if (m_cEdit.GetSafeHwnd() != NULL)
        {
        m_cEdit.SetWindowPos( &wndTopMost, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
        }

    InvalidateRect( NULL );
    UpdateWindow();

    if (m_bBackgroundTransparent)
        {
        RefreshWindow();
        }
    }

/******************************************************************************/

LRESULT CTedit::OnMoving( WPARAM, LPARAM lprc )
    {
    LRESULT lResult = 0;
    CRect rectEdit  = *((LPRECT)lprc);
    CRect rectImage = m_pImgWnd->GetDrawingRect();

    m_pImgWnd->ClientToScreen( &rectImage );

    int iX = 0;
    int iY = 0;

    if (rectEdit.left < rectImage.left)
        iX = rectImage.left - rectEdit.left;
    else
        if (rectEdit.right > rectImage.right)
            iX = -(rectEdit.right - rectImage.right);

    if (rectEdit.top < rectImage.top)
        iY = rectImage.top - rectEdit.top;
    else
        if (rectEdit.bottom > rectImage.bottom)
            iY = -(rectEdit.bottom - rectImage.bottom);

    if (iX || iY)
        {
        rectEdit.OffsetRect( iX, iY );
        *((LPRECT)lprc) = rectEdit;
        lResult = 1;
        }
    return lResult;
    }

/******************************************************************************/

void CTedit::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
    {
    CRect rectImage = m_pImgWnd->GetDrawingRect();
    CSize      Size = rectImage.Size();

    lpMMI->ptMaxSize.x      = Size.cx;
    lpMMI->ptMaxSize.y      = Size.cy;
    lpMMI->ptMaxPosition    = rectImage.TopLeft();
    lpMMI->ptMinTrackSize.x = m_SizeMinimum.cx;
    lpMMI->ptMinTrackSize.y = m_SizeMinimum.cy;

    CRect rectClient;

    GetWindowRect( &rectClient );
    m_pImgWnd->ScreenToClient( &rectClient );

    switch (m_uiHitArea)
        {
        case HTTOP:
        case HTLEFT:
        case HTTOPLEFT:
            break;

        case HTRIGHT:
        case HTTOPRIGHT:
        case HTBOTTOMRIGHT:
            lpMMI->ptMaxSize.x -= (rectClient.left - rectImage.left);

            if (m_uiHitArea == HTBOTTOMRIGHT)
                ; // fall thru and do the bottom
            else
                break;

        case HTBOTTOMLEFT:
        case HTBOTTOM:
            lpMMI->ptMaxSize.y -= (rectClient.top - rectImage.top);
            break;
        }

    lpMMI->ptMaxTrackSize = lpMMI->ptMaxSize;
    }

/******************************************************************************/

HBRUSH CTedit::OnCtlColor (CDC* pDC, CWnd* pWnd, UINT nCtlColor )
    {
    HBRUSH hbrBack = NULL;

    if (pWnd == &m_cEdit)
        {
        PBSelectPalette( pDC, theApp.m_pPalette, FALSE );
        pDC->SetTextColor( m_crFGColor );

        //set the background color and transparent mode
//      if (m_bBackgroundTransparent)
//          {
            pDC->SetBkMode( TRANSPARENT );

            hbrBack = (HBRUSH)::GetStockObject( NULL_BRUSH );
//          }
//      else
//          {
//          pDC->SetBkMode( OPAQUE );
//          pDC->SetBkColor( m_crBKColor );

//          hbrBack = (HBRUSH)m_hbrBkColor.GetSafeHandle();
//          }
        }
    if (hbrBack == NULL)
        return (HBRUSH)Default();

    return hbrBack;
    }

/******************************************************************************/
//void CTedit::OnLButtonDown(UINT nFlags, CPoint point )
//  {
//  SendMessage(WM_NCLBUTTONDOWN, HTCAPTION, MAKELPARAM(point.x, point.y));
//  SetFocus();
//  CEdit::OnLButtonDown(nFlags, point);
//  }

/******************************************************************************/

void CTedit::OnNcCalcSize( BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp )
    {
    /* Increase by an extra width height of the border*/
    lpncsp->rgrc[0].left   += CTracker::HANDLE_SIZE;
    lpncsp->rgrc[0].top    += CTracker::HANDLE_SIZE;
    lpncsp->rgrc[0].right  -= CTracker::HANDLE_SIZE;
    lpncsp->rgrc[0].bottom -= CTracker::HANDLE_SIZE;
    }

/******************************************************************************/

void CTedit::OnNcPaint()
    {
    CDC *pdcWindow = GetWindowDC();

    ASSERT(pdcWindow != NULL);

    if (pdcWindow != NULL)
        {
        CRgn    rgnClipping;
        CRect   cWinRect;
        int     iWindowWidth;
        int     iWindowHeight;

        GetWindowRect( &cWinRect );

        iWindowWidth  = cWinRect.Width();
        iWindowHeight = cWinRect.Height();

        CRect cBorderRect( 0, 0, iWindowWidth, iWindowHeight );

        CTracker::DrawBorder ( pdcWindow, cBorderRect, CTracker::all );
        CTracker::DrawHandles( pdcWindow, cBorderRect, CTracker::all );

        ReleaseDC( pdcWindow );
        }
    }

/******************************************************************************/

UINT CTedit::OnNcHitTest( CPoint point )
    {
    CRect cClientRect;
    UINT  uiHitTestCode = HTCAPTION;

    ScreenToClient( &point );

    GetClientRect(&cClientRect);

    //Test to see if the pt is in THE CLIENT AREA
    if (cClientRect.PtInRect(point))
        {
        uiHitTestCode = HTCLIENT;
        }

    m_uiHitArea = HTNOWHERE;

    switch (CTracker::HitTest( cClientRect, point, CTracker::nil ))
        {
        case CTracker::resizingTop:
            m_uiHitArea = HTTOP;
            break;

        case CTracker::resizingLeft:
            m_uiHitArea = HTLEFT;
            break;

        case CTracker::resizingRight:
            m_uiHitArea = HTRIGHT;
            break;

        case CTracker::resizingBottom:
            m_uiHitArea = HTBOTTOM;
            break;

        case CTracker::resizingTopLeft:
            m_uiHitArea = HTTOPLEFT;
            break;

        case CTracker::resizingTopRight:
            m_uiHitArea = HTTOPRIGHT;
            break;

        case CTracker::resizingBottomLeft:
            m_uiHitArea = HTBOTTOMLEFT;
            break;

        case CTracker::resizingBottomRight:
            m_uiHitArea = HTBOTTOMRIGHT;
            break;
        }

    if (m_uiHitArea != HTNOWHERE)
        uiHitTestCode = m_uiHitArea;


        m_cEdit.SetHCursorShape();


    return uiHitTestCode;
    }

/******************************************************************************/

void CTedit::OnRButtonDown(UINT nFlags, CPoint point)
    {
    CMenu cMenuPopup;
    CMenu *pcContextMenu;
    CRect cRectClient;
    BOOL  bRC = cMenuPopup.LoadMenu( IDR_TEXT_POPUP );

    ASSERT( bRC );

    if (bRC)
        {
        GetClientRect( &cRectClient );

        pcContextMenu = cMenuPopup.GetSubMenu( ID_EBOX_POPUPMENU_POS );

        ASSERT( pcContextMenu != NULL );

        if (pcContextMenu != NULL)
            {
            // update the check marks
            OnUpdateTextPlain    ( pcContextMenu );
            OnUpdateTextBold     ( pcContextMenu );
            OnUpdateTextItalic   ( pcContextMenu );
            OnUpdateTextUnderline( pcContextMenu );
            OnUpdateTextTexttool ( pcContextMenu );

            ClientToScreen( &point );
            ClientToScreen( &cRectClient );

            // the frame actually has a clue about what items to enable...
            CWnd *notify = GetParentFrame();

            if( !notify )
                notify = this; // oh well...

            pcContextMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                                     point.x, point.y, notify, &cRectClient );
            }
        }
    }

/******************************************************************************/

void CTedit::OnTextPlain()
    {
    ASSERT( m_pcTfont != NULL );

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsBoldOn())
            {
            m_pcTfont->OnBold();
            }

        if (m_pcTfont->IsItalicOn())
            {
            m_pcTfont->OnItalic();
            }

        if (m_pcTfont->IsUnderlineOn())
            {
            m_pcTfont->OnUnderline();
            }

        if (m_pcTfont->IsShadowOn())
            {
            m_pcTfont->OnShadow();
            }

        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextBold()
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        m_pcTfont->OnBold();
        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextItalic()
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        m_pcTfont->OnItalic();
        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextUnderline()
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        m_pcTfont->OnUnderline();
        m_pcTfont->RefreshToolBar();

        RefreshWindow();
        }
    }

/******************************************************************************/

void CTedit::OnTextSelectfont()
    {
    if (m_pcTfont != NULL)
        {
        if (! IsFontPaletteVisible())
            ShowFontPalette( SW_SHOW );
        else
            m_pcTfont->SetFocus();
        }
    }

/******************************************************************************/

void CTedit::OnTextSelectpointsize()
    {
    if (m_pcTfont != NULL)
        {
        if (! IsFontPaletteVisible())
            ShowFontPalette( SW_SHOW );
        else
            m_pcTfont->SetFocus();

        CWnd* pWnd = m_pcTfont->GetFontSizeControl();

        if (pWnd != NULL)
            {
            pWnd->SetFocus();
            }
        }
    }

/******************************************************************************/

void CTedit::OnEditCut()
    {

        if ( m_bVertEdit )      HideCaret();


    m_cEdit.Cut();
    RefreshWindow();


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretShape();
                ShowCaret();
                }

    }

/******************************************************************************/

void CTedit::OnEditCopy()
    {
    m_cEdit.Copy();
    }

/******************************************************************************/

void CTedit::OnEditPaste()
    {
    m_bPasting = TRUE;

    #ifdef _DEBUG
    TRACE0( "OnEditPaste Start\n" );
    #endif

    m_cEdit.Paste();

    #ifdef _DEBUG
    TRACE0( "OnEditPaste End\n" );
    #endif

    m_bPasting = FALSE;

    RefreshWindow();
    }

/******************************************************************************/

void CTedit::OnTextDelete()
    {
    int iLength = m_cEdit.GetWindowTextLength();
    int iStart  = iLength;
    int iEnd    = iLength;


        if ( m_bVertEdit )              m_cEdit.HideCaret();


    m_cEdit.GetSel( iStart, iEnd );

    if (iStart == iEnd)
        {
        if (iLength == iStart)
            return;

        CString strText;
        m_cEdit.GetWindowText(strText);
        if (!strText.IsEmpty() && (IsDBCSLeadByte((CHAR)strText[iStart])
            || strText[iStart]==TEXT('\r')))
            iEnd += 2;
        else
            iEnd += 1;

        m_cEdit.SetSel( iStart, iEnd, TRUE );
        }
    m_cEdit.Clear();


        if ( m_bVertEdit )
                {
                m_cEdit.SetCaretShape();
                m_cEdit.SetCaretPosition( TRUE, NULL, -1 );
                m_cEdit.ShowCaret();
                m_cEdit.Repaint();
                }
        else
                {


    UpdateWindow();
    RefreshWindow();


                }


    }

/******************************************************************************/

void CTedit::OnTextSelectall()
    {
    m_cEdit.SetSel( 0, -1, TRUE );

    RefreshWindow();
    }

/******************************************************************************/

void CTedit::OnTextUndo()
    {
    Undo();

    RefreshWindow();
    }

/******************************************************************************/

void CTedit::OnTextPlace()
    {
    CWnd* cwndParent = GetParent();

    cwndParent->PostMessage( WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM( CTracker::HANDLE_SIZE + 1, CTracker::HANDLE_SIZE + 1 ) );
    cwndParent->PostMessage( WM_LBUTTONUP,   MK_LBUTTON, MAKELPARAM( CTracker::HANDLE_SIZE + 1, CTracker::HANDLE_SIZE + 1 ) );
    }

/******************************************************************************/

void CTedit::OnTextTexttool()
    {
    if (IsFontPaletteVisible())
        {
        ShowFontPalette( SW_HIDE );
        }
    else
        {
        ShowFontPalette( SW_SHOWNOACTIVATE );
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextPlain( CMenu *pcMenu )
    {
    ASSERT( m_pcTfont != NULL );

    if (m_pcTfont != NULL)
        {
        if (! m_pcTfont->IsBoldOn()
        &&  ! m_pcTfont->IsItalicOn()
        &&  ! m_pcTfont->IsUnderlineOn()
        &&  ! m_pcTfont->IsShadowOn())
           {
           pcMenu->CheckMenuItem(ID_TEXT_PLAIN, MF_BYCOMMAND | MF_CHECKED);
           }
       else
           {
           pcMenu->CheckMenuItem(ID_TEXT_PLAIN, MF_BYCOMMAND | MF_UNCHECKED);
           }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextBold(CMenu *pcMenu)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsBoldOn())
            {
            pcMenu->CheckMenuItem(ID_TEXT_BOLD, MF_BYCOMMAND | MF_CHECKED);
            }
        else
            {
            pcMenu->CheckMenuItem(ID_TEXT_BOLD, MF_BYCOMMAND | MF_UNCHECKED);
            }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextItalic(CMenu *pcMenu)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsItalicOn())
            {
            pcMenu->CheckMenuItem(ID_TEXT_ITALIC, MF_BYCOMMAND | MF_CHECKED);
            }
        else
            {
            pcMenu->CheckMenuItem(ID_TEXT_ITALIC, MF_BYCOMMAND | MF_UNCHECKED);
            }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextUnderline(CMenu *pcMenu)
    {
    ASSERT(m_pcTfont != NULL);

    if (m_pcTfont != NULL)
        {
        if (m_pcTfont->IsUnderlineOn())
            {
            pcMenu->CheckMenuItem(ID_TEXT_UNDERLINE, MF_BYCOMMAND | MF_CHECKED);
            }
        else
            {
            pcMenu->CheckMenuItem(ID_TEXT_UNDERLINE, MF_BYCOMMAND | MF_UNCHECKED);
            }
        }
    }

/******************************************************************************/

void CTedit::OnUpdateTextTexttool(CMenu *pcMenu)
    {
    if (IsFontPaletteVisible())
        {
        pcMenu->CheckMenuItem(ID_VIEW_TEXT_TOOLBAR, MF_BYCOMMAND | MF_CHECKED);
        }
    else
        {
        pcMenu->CheckMenuItem(ID_VIEW_TEXT_TOOLBAR, MF_BYCOMMAND | MF_UNCHECKED);
        }
    }

/******************************************************************************/



/******************************************************************************/

void CTedit::OnDestroy(void)
    {
        if ( m_cEdit.GetSafeHwnd() )
                {
                if ( m_cEdit.m_hOldCursor )
                        SetClassLongPtr( m_cEdit.m_hWnd, GCLP_HCURSOR, (LONG_PTR) m_cEdit.m_hOldCursor );

                //restore original edit IMC
                if (m_bAssocIMC)
                        {
                        m_bAssocIMC = FALSE;
                        EnableIme( m_cEdit.m_hWnd, m_hIMCEdit );
                        EnableIme( m_hWndFace, m_hIMCFace );
                        EnableIme( m_hWndSize, m_hIMCSize );
                        m_hIMCEdit = NULL;
                        m_hIMCFace = NULL;
                        m_hIMCSize = NULL;
                        }
                }

        Default();
        return;
        }

/******************************************************************************/

HIMC    CTedit::DisableIme( HWND hWnd )
        {
        HIMC    hIMC = NULL;

        if ( (hWnd) && (::IsWindow( hWnd )) )
                hIMC = ImmAssociateContext( hWnd, NULL );

        return  hIMC;
        }

/******************************************************************************/

void    CTedit::EnableIme( HWND hWnd, HIMC hIMC )
        {
        if ( (hWnd) && (::IsWindow( hWnd )) )
                ImmAssociateContext( hWnd, hIMC );
        }

/******************************************************************************/

//
// Tablet PC.
//
// Is CUAS (Cicero Unaware App Support) is on, we need to use hIMC even on
// Ansi Font. The string from English HW/Speech TIPs will be delivered
// through hIMC.
//
BOOL CTedit::IsCUAS()
{
    BOOL bRet = FALSE;

    typedef BOOL (*PFNCTFIMMISCICEROENABLED)(void);

    static PFNCTFIMMISCICEROENABLED pfn = NULL;

    if (!pfn)
    {
        HMODULE hMod = LoadLibrary(TEXT("imm32.dll"));
        if (hMod)
        {
            pfn = (PFNCTFIMMISCICEROENABLED)GetProcAddress(hMod,
                               "CtfImmIsCiceroEnabled");

        }
    }
    if (pfn)
        bRet = pfn();
    return bRet;
}

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\tfont.h ===
// Tfont.h : interface of the CTfont class
//           This class takes text entry from the user.
//           It is derived from the CEdit class
/***************************************************************************/

#ifndef __Tfont_H__
#define __Tfont_H__

// TOOLBAAR CONSTANTS -- Bitmap Positions and Toolbar Positions

#define MAX_TBAR_ITEMS        12 // positions 0 through 11

#define BOLD_BMP_POS          0
#define ITALIC_BMP_POS        1
#define UNDERLINE_BMP_POS     2


#define VERTEDIT_BMP_POS      3
#define PEN_BMP_POS           4
#define EDITTEXT_BMP_POS      5
#define KEYBOARD_BMP_POS      6   // still wasting space in image
#define INS_SPACE_BMP_POS     7
#define BACKSPACE_BMP_POS     8
#define NEWLINE_BMP_POS       9

#define SHADOW_BMP_POS        -1  // don't exist currently

#define BOLD_TBAR_POS         0
#define ITALIC_TBAR_POS       1
#define UNDERLINE_TBAR_POS    2


#define VERTEDIT_TBAR_POS     3
#define SPACE_ONE             4
#define PEN_TBAR_TEXT_POS     5

#define INS_SPACE_TBAR_POS    5
#define BACKSPACE_TBAR_POS    6
#define NEWLINE_TBAR_POS      7
#define SPACE_TWO             8
#define EDITTEXT_TBAR_POS     9
#define SPACE_THREE          10
#define PEN_TBAR_PEN_POS     11

#define SHADOW_TBAR_POS       -1  // don't exist currently
#define KEYBOARD_TBAR_POS     -1  // don't exist currently

#define FONT_BMP_TXT_BORDER   2   // # pixels between font bmp (prn/tt) and text

#define UM_DELAYED_TOOLBAR   WM_USER + 900

// definde font types used by m_iFontType in CTfont class
#define TT_FONT             0x0001
#define TT_OPENTYPE_FONT    0x0002
#define PS_OPENTYPE_FONT    0x0004
#define TYPE1_FONT          0x0008
#define DEVICE_FONT         0x0010
#define RASTER_FONT         0x0020

#define NumCPic         5

class CTedit;    // forward reference for change/undo notification
//class CAttrEdit; // forward reference for setfont,...notification

/******************************************************************************/

class CTfontTbar : public CToolBar
    {
    private:

    protected: // create from serialization only

    DECLARE_DYNCREATE(CTfontTbar)

    protected:

    //{{AFX_MSG(CTfontTbar)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
        //  afx_msg void OnInsertObject();  // OLE support
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    public:

    CTfontTbar(void);

    virtual ~CTfontTbar(void);
    BOOL    Create(CWnd* pcParentWnd, BOOL bShowPen = FALSE);
    };

/******************************************************************************/

class CTfontDlg : public CDialogBar
    {
    private:
    CPic          m_cPictures[NumCPic];
    int           m_Max_cx_FontType_BMP;
    void SetColorsInDC(HDC hdc, BOOL bInverted);
    protected: // create from serialization only

    DECLARE_DYNCREATE(CTfontDlg)

    protected:

    //{{AFX_MSG(CTfontDlg)
    afx_msg void OnRButtonDown ( UINT nFlags, CPoint point );
//
// MFC 4 - had to put the WM_DRAWITEM and WM_MEASUREITEM handlers here instead
// of CTfont. This dialog is the real parent of the owner-draw combobox, don't
// know how the old version worked with these handlers in CTfont.
//
    afx_msg void OnDrawItem    (int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
    afx_msg void OnMeasureItem (int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg DWORD OnGetDefId   ( void );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    public:

    CTfontDlg(void);
    void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct, CString *pcStringText);
    virtual ~CTfontDlg(void);
    BOOL     Create(CWnd* pcParentWnd);
    };

/******************************************************************************/

class CCharSetDesc;
class CFontDesc;

/******************************************************************************/

class CTfont : public CMiniFrmWnd
    {
    private:

    int           m_iControlIDLastChange;
    int           m_iWeight;
    CFont         m_cCurrentFont;
    CString       m_cStrTypeFaceName;
    CString       m_cStrTypeFaceNamePrev;
    int           m_iPointSize;
    int           m_iPointSizePrev;

    CString       m_strFontName;
    int           m_iFontType;
    BYTE          m_nCharSet;
    BYTE          m_nCharSetPrev;

    BOOL          m_bBoldOn;
    BOOL          m_bItalicOn;
    BOOL          m_bUnderlineOn;

    BOOL          m_bVertEditOn;

    BOOL          m_bShadowOn;
    BOOL          m_bPenOn;

    CRect         m_cRectWindow;
    BOOL          m_bDisplayCText;
    BOOL          m_bInUpdate;

    class CTedit* m_pcTedit;
    CTfontDlg     m_cTfontDlg;
    CTfontTbar    *m_pcTfontTbar; // must be dynamic for changing buttons (delete/new)

    BYTE PickCharSet(CCharSetDesc *pCharSetDescList, int iCharSetSelection);

    void ResizeWindow(void);
    void ProcessNewTypeface(void);
    void UpdateEditControlFont(void);
    void FreeMemoryFromCBox(void);
    void OnTypeFaceComboBoxUpdate(void);
    void OnPointSizeComboBoxUpdate(void);

    void SaveToIniFile(void);
    void ReadFromIniFile(void);

    // was used for spin control to save point sizes,...
    //  CMapWordToPtr PointSizeMap;
    //  void EmptyMap(void);

    void RefreshFontList(void);

    int  EnumFontFace( ENUMLOGFONTEX*   lpEnumLogFont,
                       NEWTEXTMETRICEX* lpNewTextMetric,
                       int             iFontType );

    int  EnumFontSizes( LPENUMLOGFONT   lpEnumLogFont,
                        LPNEWTEXTMETRIC lpNewTextMetric,
                        int             iFontType );

    protected: // create from serialization only

    DECLARE_DYNCREATE(CTfont)

    //{{AFX_MSG(CTfont)
    afx_msg void OnTypefaceChange();
    afx_msg void OnPointSizeChange();
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnDestroy();
    afx_msg void OnMove(int x, int y);
    afx_msg void OnClose();
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    public:

    CTfont();
    CTfont( CTedit *pcTedit );
    ~CTfont(void);

    CWnd* GetFontSizeControl() { return ((m_cTfontDlg.GetSafeHwnd() == NULL)? NULL:
                                          m_cTfontDlg.GetDlgItem( IDC_POINTSIZE ) ); }

    CWnd* GetFontFaceControl() { return ((m_cTfontDlg.GetSafeHwnd() == NULL)? NULL:
                                          m_cTfontDlg.GetDlgItem( IDC_TYPEFACE ) ); }

    //MY AFX_MSG(CTfont)
    afx_msg void OnBold      ( void );
    afx_msg void OnItalic    ( void );
    afx_msg void OnUnderline ( void );

    afx_msg void OnVertEdit  ( void );
    afx_msg void OnVertEditUpdate  ( CCmdUI* pCmdUI );

    afx_msg void OnShadow    ( void );
    afx_msg void OnPen       ( void );
    afx_msg long OnDelayedPen( WPARAM wParam, LPARAM lParam );
    afx_msg void OnEditText  ( void );
    afx_msg void OnKeyboard  ( void );
    afx_msg void OnInsSpace  ( void );
    afx_msg void OnBackSpace ( void );
    afx_msg void OnNewLine   ( void );
    //MY AFX_MSG

    BOOL IsBoldOn      ( void ) { return m_bBoldOn;      }
    BOOL IsItalicOn    ( void ) { return m_bItalicOn;    }
    BOOL IsUnderlineOn ( void ) { return m_bUnderlineOn; }

    BOOL IsVertEditOn  ( void ) { return m_bVertEditOn;  }

    BOOL IsShadowOn    ( void ) { return m_bShadowOn;    }
    BOOL Create        ( CRect rectEditArea );
    void Undo          ( void );
    void RefreshToolBar( void );
    void GetFontInfo   ( int iFontSelection, BYTE nCharSetSelection);

    static int CALLBACK EnumFontFaceProc(ENUMLOGFONTEX* lpEnumLogFont,
                                         NEWTEXTMETRICEX* lpNewTextMetric,
                                          int iFontType, LPARAM lParam);
    static int CALLBACK EnumFontOneFaceProc(LPENUMLOGFONT lpEnumLogFont,
                                            LPNEWTEXTMETRIC lpNewTextMetric,
                                            int iFontType, LPARAM lParam);

    virtual WORD GetHelpOffset() {return 0;} // for now just return 0

    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

    virtual void RecalcLayout(BOOL bNotify = TRUE);

    };

/***************************************************************************/

#endif // __Tfont_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\tedit.h ===
// tedit.h : interface of the CTedit class
//
// This class takes text entry from the user.
// It is derived from the CEdit class
//

#ifndef __TEDIT_H__
#define __TEDIT_H__

// default position for text box
#define INITX 10
#define INITY 10
#define INITCX 100
#define INITCY 50

#define MIN_CHARS_DISPLAY_SIZE 5 // minimum size is 5 chars with the default font

#define WM_MOVING       0x0216

//#define EM_POSFROMCHAR  0x00D6
//#define EM_CHARFROMPOS  0x00D7


#define IS_DBCS_CHARSET( charset )         ( (charset == GB2312_CHARSET) || \
                                             (charset == SHIFTJIS_CHARSET) || \
                                             (charset == HANGEUL_CHARSET) || \
                                             (charset == CHINESEBIG5_CHARSET) )


class CTedit;
class CTfont;

typedef enum
    {
        eEBOX_CHANGE,
        eFONT_CHANGE,
        eSIZE_MOVE_CHANGE,
    eNO_CHANGE
    } eLASTACTION;


/******************************************************************************/

class CAttrEdit : public CEdit
    {
    public:

    BOOL    m_bBackgroundTransparent;

    UINT    m_uiLastChar[2];

    CRect   m_rectUpdate;

    CTedit* m_pParentWnd;

    CString m_strResult;


    HKL     m_hKL;
    BOOL    m_bMouseDown;
    HCURSOR m_hHCursor;
    HCURSOR m_hVCursor;
    HCURSOR m_hOldCursor;
    CRect   m_rectFmt;
    int     m_iPrevStart;
    int     m_iTabPos;
    BOOL    m_bResizeOnly; // when IME composition will
                           // force a resize
   
    CAttrEdit::CAttrEdit();

    DECLARE_DYNCREATE( CAttrEdit )

    protected: // create from serialization only

    //{{AFX_MSG(CAttrEdit)
    afx_msg void OnPaint();
    afx_msg BOOL OnEraseBkgnd ( CDC* pDC );
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnChar       (UINT nChar, UINT nRepCnt, UINT nFlags);

    afx_msg LRESULT OnImeChar          ( WPARAM wParam, LPARAM lParam );
    afx_msg LRESULT OnImeComposition   ( WPARAM wParam, LPARAM lParam );
    afx_msg LRESULT OnInputLangChange  ( WPARAM wParam, LPARAM lParam );
    afx_msg void OnKillFocus           ( CWnd* pNewWnd );
    afx_msg UINT OnNcHitTest           ( CPoint point );
    afx_msg void OnSetFocus            ( CWnd* pOldWnd );
    afx_msg void OnSize                ( UINT nType, int cx, int cy );
    afx_msg void OnLButtonDblClk       ( UINT nFlags, CPoint point );
    afx_msg void OnLButtonDown         ( UINT nFlags, CPoint point );
    afx_msg void OnMouseMove           ( UINT nFlags, CPoint point );
    afx_msg void OnLButtonUp           ( UINT nFlags, CPoint point );
    afx_msg void OnKeyDown             ( UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg LRESULT OnSysTimer         ( WPARAM wParam, LPARAM lParam );

        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetHCursorShape  ( void );
    void SetVCursorShape  ( void );
    void UpdateSel        ( void );
    void UpdateInput      ( void );
    void SetStartSelect   ( void );
    void SetCaretPosition ( BOOL bPrev, CPoint *ptMouse, int iPrevStart );
    void SetCaretShape    ( void );
    void SetFmtRect       ( void );
    void Repaint          ( void );
    void TabTextOut       ( CDC *pDC, int nCharIndex, int x, int y,
                            LPCTSTR lpStr, int nCount, BOOL bSelect );

    friend class CTedit;
    };

/******************************************************************************/

class CTedit : public CWnd
    {
       friend class CTfont;
    private:

    CAttrEdit   m_cEdit;
    CTfont*     m_pcTfont;
    eLASTACTION m_eLastAction;
    BOOL        m_bBackgroundTransparent;
    BOOL        m_bCleanupBKBrush;
    BOOL        m_bStarting;
    BOOL        m_bPasting;
    BOOL        m_bExpand;
    BOOL        m_bChanged;
    UINT        m_uiHitArea;
    COLORREF    m_crFGColor;
    COLORREF    m_crBKColor;
    CRect       m_cRectOldPos;
    CRect       m_cRectWindow;
    CSize       m_SizeMinimum;


    public:

    CImgWnd*    m_pImgWnd;
    CBrush      m_hbrBkColor;
    BOOL        m_bRefresh;


    int         m_iLineHeight;
    BOOL        m_bVertEdit;
    BOOL        m_bAssocIMC;
    HIMC        m_hIMCEdit;
    HIMC        m_hIMCFace;
    HIMC        m_hIMCSize;
    HWND        m_hWndFace;
    HWND        m_hWndSize;


    CTedit::CTedit();
   
    DECLARE_DYNCREATE( CTedit )
    afx_msg void OnEnMaxText();
    protected:

    //{{AFX_MSG(CTedit)
    afx_msg void OnAttrEditEnChange(void);
    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnMove( int x, int y );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );
    afx_msg HBRUSH OnCtlColor( CDC* pDC, CWnd* pWnd, UINT nCtlColor );
    afx_msg void OnNcCalcSize( BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp );
    afx_msg void OnNcPaint();
    afx_msg UINT OnNcHitTest( CPoint point );
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);

    afx_msg void OnTextPlain();
    afx_msg void OnTextBold();
    afx_msg void OnTextItalic();
    afx_msg void OnTextUnderline();
    afx_msg void OnTextSelectfont();
    afx_msg void OnTextSelectpointsize();
    afx_msg void OnEditCut();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnTextDelete();
    afx_msg void OnTextSelectall();
    afx_msg void OnTextUndo();
    afx_msg void OnTextPlace();
    afx_msg void OnTextTexttool();
    afx_msg void OnUpdateTextPlain(CMenu *pcMenu);
    afx_msg void OnUpdateTextBold(CMenu *pcMenu);
    afx_msg void OnUpdateTextItalic(CMenu *pcMenu);
    afx_msg void OnUpdateTextUnderline(CMenu *pcMenu);
    afx_msg void OnUpdateTextTexttool(CMenu *pcMenu);

    afx_msg void OnDestroy();

        //}}AFX_MSG

    afx_msg void OnEnUpdate();

    afx_msg LRESULT OnMoving( WPARAM, LPARAM lprc );

    DECLARE_MESSAGE_MAP()

    virtual void PostNcDestroy();

    CSize GetDefaultMinSize( void );

    public:

    virtual CTedit::~CTedit();

    virtual BOOL PreCreateWindow( CREATESTRUCT& cs );

    BOOL       Create( CImgWnd* pParentWnd,
                                       COLORREF crefForeground,
                       COLORREF crefBackground,
                       CRect& rectTextPos,
                       BOOL bBackTransparent = TRUE );

    void       OnAttrEditFontChange( void );
    void       RefreshWindow       ( CRect* prect = NULL, BOOL bErase = TRUE );
    void       SetTextColor        ( COLORREF crColor );
    void       SetBackColor        ( COLORREF crColor );
    void       SetTransparentMode  ( BOOL bTransparent );
    void       Undo                ();
    void       ShowFontPalette     ( int nCmdShow );
    BOOL       IsFontPaletteVisible( void );
    void       ShowFontToolbar     ( BOOL bActivate = FALSE );
    void       HideFontToolbar     ( void );
    BOOL       IsModified          ( void ) { return m_bChanged; }
    void       GetBitmap           ( CDC* pDC, CRect* prectImg );
    CAttrEdit* GetEditWindow       ( void ) { return &m_cEdit; }

    HIMC       DisableIme( HWND hWnd );
    void       EnableIme( HWND hWnd, HIMC hIMC );
    BOOL       IsCUAS();

    };

#endif // __TEDIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\tfont.cpp ===
/******************************************************************************/
/* Tfont.CPP: IMPLEMENTATION OF THE CTfont CLASS which encapsulates the       */
/* CTfondDlg and CTfontTbar classes                                           */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  TextFont Object                                                           */
/*      CTfont::CTfont                                                        */
/*      CTfont::CTfont                                                        */
/*      CTfont::~CTfont                                                       */
/*      CTfont::EmptyMap                                                      */
/*      CTfont::FreeMemoryFromCBox                                            */
/*                                                                            */
/*  Miscellaneous Methods                                                     */
/*      CTfont::Create                                                        */
/*      CTfont::Undo                                                          */
/*      CTfont::RefreshToolBar                                                */
/*      CTfont::ResizeWindow                                                  */
/*      CTfont::DrawItem                                                      */
/*      CTfont::SetColorsInDC                                                 */
/*      CTfont::SaveToIniFile                                                 */
/*      CTfont::RestoreFontAttrsFromIniFile                                   */
/*      CTfont::ReadFromIniFile                                               */
/*                                                                            */
/*  Font/Size enumeration methods                                             */
/*      CTfont::RefreshFontList                                               */
/*      CTfont::EnumFontFace                                                  */
/*      CTfont::EnumFontFaceProc                                              */
/*      CTfont::EnumFontSizes                                                 */
/*      CTfont::EnumFontOneFaceProc                                           */
/*                                                                            */
/*  Combo Box Notification and processing methods                             */
/*      CTfont::ProcessNewTypeface                                            */
/*      CTfont::UpdateEditControlFont                                         */
/*      CTfont::OnTypeFaceComboBoxUpdate                                      */
/*      CTfont::OnPointSizeComboBoxUpdate                                     */
/*      CTfont::OnTypefaceChange                                              */
/*      CTfont::OnPointSizeChange                                             */
/*      CTfont::OnRButtonDown                                                 */
/*                                                                            */
/*                                                                            */
/*  Control Notification/Window Messages                                      */
/*      CTfont::OnMove                                                        */
/*      CTfont::OnClose                                                       */
/*      CTfont::OnSetFocus                                                    */
/*      CTfont::OnDestroy                                                     */
/*      CTfont::OnBold                                                        */
/*      CTfont::OnItalic                                                      */
/*      CTfont::OnUnderline                                                   */
/*      CTfont::OnShadow                                                      */
/*      CTfont::OnPen                                                         */
/*      CTfont::OnEditText                                                    */
/*      CTfont::OnKeyboard                                                    */
/*      CTfont::OnInsSpace                                                    */
/*      CTfont::OnBackSpace                                                   */
/*      CTfont::OnNewLine                                                     */
/*      CTfont::OnDrawItem                                                    */
/*      CTfont::OnMeasureItem                                                 */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Tool Bar Object                                                           */
/*      CTfontTbar::CTfontTbar                                                */
/*      CTfontTbar::Create                                                    */
/*      CTfontTbar::~CTfontTbar                                               */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  Dialog Bar Object                                                         */
/*      TfontDlg::CTfontDlg(void)                                             */
/*      TfontDlg::Create(CWnd* pcParentWnd)                                   */
/*      TfontDlg::~CTfontDlg(void)                                            */
/*      TfontDlg::OnRButtonDown                                               */
/*                                                                            */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include <memory.h>
#include <tchar.h>
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "pictures.h"
#include "resource.h"
#include "minifwnd.h"
#include "Tfont.h"
#include "Tedit.h"
#ifndef NT
#include <penwin.h> // soe we can bring up the lens from the toolbar
#endif
#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CTfont, CMiniFrmWnd )
IMPLEMENT_DYNCREATE( CTfontTbar, CToolBar )
IMPLEMENT_DYNCREATE( CTfontDlg, CDialogBar )

#include "memtrace.h"

UINT    CTBitmaps[] = {FONT_TT_BMP, FONT_PRN_BMP, TT_OPENTYPE_BMP, PS_OPENTYPE_BMP, TYPE1_BMP};

/******************************************************************************/

class CCharSetDesc
{
public:
        CCharSetDesc(LPCTSTR lpszScript, BYTE nCharSet);

        CString       m_strScript;
        BYTE          m_nCharSet;
        CCharSetDesc *m_pNext;
};

CCharSetDesc::CCharSetDesc(LPCTSTR lpszScript, BYTE nCharSet)
{
        m_strScript = lpszScript;
        m_nCharSet  = nCharSet;
        m_pNext     = NULL;
}

/******************************************************************************/

class CFontDesc
{
public:
        CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet, int iFontType);
        ~CFontDesc();

        CString m_strName;
        CCharSetDesc m_CharSetDesc;
        int m_iFontType;
};

CFontDesc::CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet, int iFontType)
    : m_CharSetDesc(lpszScript, nCharSet)
{
        m_strName = lpszName;
        m_iFontType = iFontType;
}

CFontDesc::~CFontDesc()
{
    // delete the charset list entries

    CCharSetDesc *pCharSetDesc = m_CharSetDesc.m_pNext;

    while (pCharSetDesc) 
    {
        CCharSetDesc *pTemp = pCharSetDesc;
        pCharSetDesc = pCharSetDesc->m_pNext;
        delete pTemp;
    }
}

/******************************************************************************/

class CFontComboBox : public CComboBox
{
public:


        int AddFontName(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
                int iFontType);
        CFontDesc* GetFontDesc(int nIndex) {return (CFontDesc*)GetItemData(nIndex);};
        BOOL IsSameName(CFontDesc* pDesc, int index);

        // I'm not really doing the message map stuff
        void ClearList();
} ;

/******************************************************************************/

class CCharSetComboBox : public CComboBox
{
public:        
        int AddCharSet(LPCTSTR lpszScript, BYTE nCharSet);
        int SelectCharSet(int nStartAfter, BYTE nCharSet);
        int GetCurSelCharSet();
} ;

/******************************************************************************/

//
// HACKHACK: All this history stuff is to help make choosing a script for
// a font easier.  There doesn't seem to be anyway to get a "good" script
// for a given font/locale so what we do is save the last serveral scripts
// and hope that the font the user just switched to supports one of them.
//

class CHistoryList
{
public:
    CHistoryList();
    void AddHead(int nNewItem);
    int  GetAt  (unsigned int uIndex);

    enum       { m_uHistorySize = 4 };

private:
    unsigned int m_uHistoryIndex;
    int          m_HistoryList[m_uHistorySize];
};

CHistoryList::CHistoryList()
{
    m_uHistoryIndex = 0;

    for (int i = 0; i < m_uHistorySize; ++i)
    {
        m_HistoryList[i] = -1;
    }
}

void CHistoryList::AddHead(int nNewItem)
{
    m_HistoryList[(++m_uHistoryIndex) % m_uHistorySize] = nNewItem;
}

int CHistoryList::GetAt(unsigned int uIndex)
{
    ASSERT((int)uIndex >= 0 && uIndex < m_uHistorySize);

    return m_HistoryList[(m_uHistoryIndex-uIndex) % m_uHistorySize];
}

static CHistoryList g_CharSetHistoryList;

/******************************************************************************/
// CTfont

BEGIN_MESSAGE_MAP( CTfont, CMiniFrmWnd )
    //{{AFX_MSG_MAP(CTfont)
    ON_CBN_SELCHANGE(IDC_TYPEFACE, OnTypefaceChange)
    ON_CBN_SELCHANGE(IDC_POINTSIZE, OnPointSizeChange)
    ON_CBN_KILLFOCUS(IDC_POINTSIZE, OnPointSizeChange)
    ON_COMMAND(IDOK, OnPointSizeChange)
    ON_CBN_SELCHANGE(IDC_CHARSET, OnTypefaceChange)
    ON_WM_ERASEBKGND()
    ON_WM_SETFOCUS()
    ON_WM_DESTROY()
    ON_WM_MOVE()
    ON_WM_CLOSE()
    ON_WM_RBUTTONDOWN()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_COMMAND(IDC_BOLD, OnBold)
    ON_COMMAND(IDC_ITALIC, OnItalic)
    ON_COMMAND(IDC_UNDERLINE, OnUnderline)

    ON_COMMAND(IDC_VERTEDIT, OnVertEdit)
    ON_UPDATE_COMMAND_UI(IDC_VERTEDIT, OnVertEditUpdate)

    ON_COMMAND(IDC_SHADOW, OnShadow)
    ON_COMMAND(IDC_PENEXT, OnPen)
    ON_COMMAND(IDC_EDITTEXT, OnEditText)
    ON_COMMAND(IDC_KEYBOARD, OnKeyboard)
    ON_COMMAND(IDC_INS_SPACE, OnInsSpace)
    ON_COMMAND(IDC_BACKSPACE, OnBackSpace)
    ON_COMMAND(IDC_NEWLINE, OnNewLine)
        //}}AFX_MSG_MAP

    ON_MESSAGE(UM_DELAYED_TOOLBAR, OnDelayedPen)

END_MESSAGE_MAP()


/******************************************************************************/
// CTfont construction/destruction

CTfont::CTfont( CTedit *pcTedit )
    {
    ASSERT( pcTedit != NULL );

    m_pcTedit = pcTedit;

    m_cStrTypeFaceName.Empty();
    m_cStrTypeFaceNamePrev.Empty();

    m_nCharSet             = DEFAULT_CHARSET;
    m_nCharSetPrev         = DEFAULT_CHARSET;

    m_iWeight              = FW_NORMAL;
    m_bBoldOn              = FALSE;
    m_bItalicOn            = FALSE;
    m_bUnderlineOn         = FALSE;

    m_bVertEditOn          = FALSE;

    m_bShadowOn            = FALSE;
    m_bPenOn               = FALSE;
    m_bInUpdate            = FALSE;
    m_iControlIDLastChange = 0;
    m_iPointSize           = 0;
    m_iPointSizePrev       = 0;
    m_iFontType            = 0;

    m_cRectWindow.SetRectEmpty();

    m_pcTfontTbar = new CTfontTbar();
    }

/******************************************************************************/

CTfont::CTfont()
    {
    m_cStrTypeFaceName.Empty();
    m_cStrTypeFaceNamePrev.Empty();

    m_nCharSet             = DEFAULT_CHARSET;
    m_nCharSetPrev         = DEFAULT_CHARSET;

    m_iWeight              = FW_NORMAL;
    m_bBoldOn              = FALSE;
    m_bItalicOn            = FALSE;
    m_bUnderlineOn         = FALSE;

    m_bVertEditOn          = FALSE;

    m_bShadowOn            = FALSE;
    m_bPenOn               = FALSE;
    m_bInUpdate            = FALSE;
    m_iControlIDLastChange = 0;
    m_iPointSize           = 0;
    m_iPointSizePrev       = 0;
    m_iFontType            = 0;

    m_cRectWindow.SetRectEmpty();

    m_pcTfontTbar = new CTfontTbar();
    }

/******************************************************************************/
// CTfont construction/destruction

CTfont::~CTfont(void)
    {
    SaveToIniFile();

//  *DK* this deletion of the current font assumes this object, the font picker,
//  is going away at the same time the edit control is going away, since this
//  current font is selected into the edit control.

    m_cCurrentFont.DeleteObject();

    if (m_pcTedit)
    {
       m_pcTedit->m_pcTfont = NULL;
       m_pcTedit = NULL;
    }
    delete m_pcTfontTbar;
    }

/******************************************************************************/

BOOL CTfont::Create( CRect rectEditArea )
    {
    BOOL bRC = TRUE;

    CRect cRectWindow( 0, 0, 0, 0 );

    CString pWindowName;

    pWindowName.LoadString( IDS_FONT_TOOL);

    bRC = CMiniFrmWnd::Create( pWindowName, 0, cRectWindow, AfxGetMainWnd() );

    if (bRC != FALSE)
        {
        TRY
            {
            bRC = m_cTfontDlg.Create   ( this );   // can throw excpetion
            bRC = m_pcTfontTbar->Create( this );   // can throw excpetion

            ResizeWindow();
            }
        CATCH(CResourceException, e)
            {
            /*DK* ##ERROR CResourceException caught, could not create either toolbar or dialog bar object */
            }
        END_CATCH
        }
    else
        {
        /*DK* ##ERROR Could not create window for font tool box*/
        }

    ASSERT( bRC != FALSE );

    if (bRC != FALSE)
        {
        RefreshFontList();

        //Select the first item in the combobox.

        CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem( IDC_TYPEFACE );

        ASSERT( pCBox != NULL );

        if (pCBox != NULL)
            {

            // we need to default to font with correct charset or font association.
            CHARSETINFO csi;
            if (!TranslateCharsetInfo((DWORD*)UIntToPtr(GetACP()), &csi, TCI_SRCCODEPAGE))
                csi.ciCharset=ANSI_CHARSET;

            for (int bFound = FALSE, index=0; !bFound && index < pCBox->GetCount();index++)
            {
                CFontDesc* pDesc = (CFontDesc*) pCBox->GetItemData(index);

                for (CCharSetDesc *pCharSetDesc = &pDesc->m_CharSetDesc; !bFound && pCharSetDesc != NULL; pCharSetDesc = pCharSetDesc->m_pNext) 
                {
                    if ( pCharSetDesc->m_nCharSet == csi.ciCharset)
                    {
                        bFound = TRUE;
                        pCBox->SetCurSel(index);
                        g_CharSetHistoryList.AddHead(pCharSetDesc->m_nCharSet);
                    }
                }
            }

            // simulate a selection
            OnTypefaceChange();
            }
        ReadFromIniFile();  // will show the window the same state as saved

        // make sure the font tools does not show up on top of the edit box
        CRect rectFont;
        CRect rect;

        GetWindowRect( &rectFont );

        if (rect.IntersectRect( &rectEditArea, &rectFont ))
            SetWindowPos( &wndTop, rectFont.left,
                          rectEditArea.top - (rectFont.Height() + theApp.m_cyFrame),
                          0, 0, SWP_NOSIZE );

        if (theApp.m_bShowTextToolbar)
            ShowWindow( SW_SHOWNOACTIVATE );
        }
    return bRC;
    }

/***************************************************************************/

BOOL CTfont::PreCreateWindow(CREATESTRUCT& cs)
{
        BOOL bRet = CMiniFrmWnd::PreCreateWindow(cs);

        if (bRet)
        {
                // We don't want CLIENTEDGE on this window
                cs.dwExStyle &= ~WS_EX_CLIENTEDGE;
        }

        return(bRet);
}

/******************************************************************************/

void CTfont::GetFontInfo(int iFontSelection, BYTE nCharSetSelection)
{
        CFontComboBox*    pFontCBox    = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
        CCharSetComboBox* pCharSetCBox = (CCharSetComboBox*)m_cTfontDlg.GetDlgItem(IDC_CHARSET);

        CFontDesc* pDesc = pFontCBox->GetFontDesc(iFontSelection);

        m_strFontName = pDesc->m_strName;
        m_iFontType   = pDesc->m_iFontType;

        // set the charset

        m_nCharSetPrev = m_nCharSet;
        m_nCharSet     = nCharSetSelection;

        // fill in the charset combo box with the current set of charsets

        pCharSetCBox->ResetContent();

        for (CCharSetDesc *pCharSetDesc = &pDesc->m_CharSetDesc; pCharSetDesc != NULL; pCharSetDesc = pCharSetDesc->m_pNext) 
            {
            pCharSetCBox->AddCharSet(pCharSetDesc->m_strScript, pCharSetDesc->m_nCharSet);
            }

        // and select the current charset

        pCharSetCBox->SelectCharSet(-1, nCharSetSelection);
}


void CTfont::Undo(void)
    {
    switch( m_iControlIDLastChange )
        {
        case IDC_TYPEFACE:
            if (m_cStrTypeFaceName.Compare(m_cStrTypeFaceNamePrev) != 0)
                {
                TRY
                    {
                    CString cStrTemp = m_cStrTypeFaceName;

                    m_cStrTypeFaceName      = m_cStrTypeFaceNamePrev;
                    m_cStrTypeFaceNamePrev = cStrTemp;

                    CFontComboBox* pCBox = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);

                    int iSelection = pCBox->SelectString( -1, m_cStrTypeFaceName );

                    ASSERT( iSelection != CB_ERR );

                    if (iSelection != CB_ERR)
                        {
                           GetFontInfo(iSelection, m_nCharSetPrev);
                           ProcessNewTypeface();
                        }
                    }
                CATCH(CMemoryException,e)
                    {
                    /*DK* ##ERROR CString Thrown CMemoryException*/
                    }
                END_CATCH
                }

            // the processing of process new font may cause a re-selection in the
            // combo box (same code as user selection) changing this value.  We
            // must re-set for undo of undo.
            m_iControlIDLastChange = IDC_TYPEFACE;

            break;

        case IDC_POINTSIZE:
            if (m_iPointSize != m_iPointSizePrev)
                {
                int iPointSizeTemp = m_iPointSize;

                m_iPointSize     = m_iPointSizePrev;
                m_iPointSizePrev = iPointSizeTemp;

                m_cTfontDlg.SetDlgItemInt( IDC_POINTSIZE, m_iPointSize );

                UpdateEditControlFont();
                }
            break;

        case IDC_BOLD:
            OnBold();
            RefreshToolBar();
            break;

        case IDC_ITALIC:
            OnItalic();
            RefreshToolBar();
            break;

        case IDC_UNDERLINE:
            OnUnderline();
            RefreshToolBar();
            break;


        case IDC_VERTEDIT:
            OnVertEdit();
            RefreshToolBar();
            break;


        case IDC_SHADOW:
            OnShadow();
            RefreshToolBar();
            break;

        default:
            break;
        }
    }

/******************************************************************************/

void CTfont::RefreshToolBar(void)
    {
    // Set the bold button state
    if (m_bBoldOn)
        {
        m_pcTfontTbar->SetButtonInfo( BOLD_TBAR_POS, IDC_BOLD, TBBS_CHECKBOX | TBBS_CHECKED, BOLD_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo( BOLD_TBAR_POS, IDC_BOLD, TBBS_CHECKBOX, BOLD_BMP_POS);
        }

    // Set the italic button state
    if (m_bItalicOn)
        {
        m_pcTfontTbar->SetButtonInfo( ITALIC_TBAR_POS, IDC_ITALIC, TBBS_CHECKBOX | TBBS_CHECKED, ITALIC_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo( ITALIC_TBAR_POS, IDC_ITALIC, TBBS_CHECKBOX, ITALIC_BMP_POS);
        }

    // Set the underline button state
    if (m_bUnderlineOn)
        {
        m_pcTfontTbar->SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE, TBBS_CHECKBOX | TBBS_CHECKED, UNDERLINE_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE, TBBS_CHECKBOX, UNDERLINE_BMP_POS);
        }


    // Set the VertEdit button state
        if (m_bVertEditOn)
        {
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT, TBBS_CHECKBOX | TBBS_CHECKED, VERTEDIT_BMP_POS);
        }
    else
        {
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT, TBBS_CHECKBOX, VERTEDIT_BMP_POS);
        }


    // Set the underline button state
    if (theApp.m_bPenSystem)
        if (m_bPenOn)
            {
            m_pcTfontTbar->SetButtonInfo(PEN_TBAR_PEN_POS, IDC_PENEXT, TBBS_CHECKBOX | TBBS_CHECKED, PEN_BMP_POS);
            }
        else
            {
            m_pcTfontTbar->SetButtonInfo(PEN_TBAR_TEXT_POS, IDC_PENEXT, TBBS_CHECKBOX, PEN_BMP_POS);
            }

    // Set the shadow button state
//  currently this is not present on the toolbar.  When it is available, fix the
//  SHADOW_TBAR_POS and SHADOW_BMP_POS #define in tfont.h

//   if (m_bShadowOn)
//       {
//       m_pcTfontTbar->SetButtonInfo(SHADOW_TBAR_POS, IDC_SHADOW, TBBS_CHECKBOX | TBBS_CHECKED, SHADOW_BMP_POS);
//       }
//   else
//       {
//       m_pcTfontTbar->SetButtonInfo(SHADOW_TBAR_POS, IDC_SHADOW, TBBS_CHECKBOX, SHADOW_BMP_POS);
//       }
    }

/******************************************************************************/

void CTfont::ResizeWindow( void )
    {
    CRect cClientRect;
    CRect cRectDlgBar;
    CRect cRectTbar;

    int ixPosDlgBar   = 0;
    int iyPosDlgBar   = 0;
    int ixPosTbar     = 0;
    int iyPosTbar     = 0;
    int iWindowHeight = 0;
    int iWindowWidth  = 0;
    int iBorder       = 0;
    int ixNCBorder    = 0;
    int iyNCBorder    = 0;

    ixNCBorder += theApp.m_cxBorder * 2;
    iyNCBorder += theApp.m_cyBorder * 2;
    iyNCBorder += theApp.m_cyCaption;

    m_cTfontDlg.GetWindowRect( &cRectDlgBar );

    cRectTbar.SetRectEmpty();

    m_pcTfontTbar->GetWindowRect( &cRectTbar );

    // /4 since border is for top/bottom or left/right
    // the boder is 1/4 the height of the tool/dialog bar
    iBorder += cRectDlgBar.Height() / 4;

    // Compute the Width
    // Width is combination of both
    iWindowWidth += ixNCBorder;
    iWindowWidth += cRectDlgBar.Width();
    iWindowWidth += cRectTbar.Width();
    iWindowWidth += 3 * iBorder;  // border on left and right and between dlgbar and tbar

    // Compute the Height
    // Height is combination of both
    iWindowHeight += iyNCBorder;
    iWindowHeight += cRectDlgBar.Height();
    iWindowHeight += 2 * iBorder;  // border on top and bottom

    // position the main window
    if (GetSafeHwnd() != NULL)
        {
        // size this window to fit children
        SetWindowPos(&wndTop, 0, 0, iWindowWidth, iWindowHeight, SWP_NOMOVE);
        }

    GetClientRect(&cClientRect);

    // calculate the x positions of the 2 control bars (next to eachother)
    ixPosDlgBar   = iBorder;
    ixPosTbar     = iBorder * 2 + cRectDlgBar.Width();

    // center the 2 control bars in the vertical position
    iyPosDlgBar   = (cClientRect.Height() - cRectDlgBar.Height()) / 2;
    iyPosTbar     = (cClientRect.Height() - cRectTbar.Height()) / 2;

    // Position the Dialog Bar
    if (m_cTfontDlg.GetSafeHwnd() != NULL)
        {
        m_cTfontDlg.SetWindowPos(&wndTop, ixPosDlgBar, iyPosDlgBar, 0, 0, SWP_NOSIZE);
        m_cTfontDlg.ShowWindow(SW_SHOWNOACTIVATE);
        }

    // Position the Toolbar
    if (m_pcTfontTbar->GetSafeHwnd() != NULL)
        {
        m_pcTfontTbar->SetWindowPos(&wndTop, ixPosTbar, iyPosTbar, 0, 0, SWP_NOSIZE);
        m_pcTfontTbar->ShowWindow(SW_SHOWNOACTIVATE);
        }
    }

/******************************************************************************/


/******************************************************************************/
/*                                                                            */
/* Ini File section format  PBrush.INI in Windows Dir                         */
/* [Text]                                                                     */
/* TypeFaceName= string                                                       */
/* PointSize=  #                                                              */
/* FontPalette= x y nCmdShow  (x,y) is location screen.  nCmdShow is param to */
/* Bold= ON   F                              ShowWindow of SW_SHOW or SW_HIDE */
/* Italic= ON                                                                 */
/* Underline= ON                                                              */
/*                                                                            */
/******************************************************************************/

void CTfont::SaveToIniFile(void)
    {
    theApp.m_iPointSize      = m_iPointSize;
    theApp.m_strTypeFaceName = m_cStrTypeFaceName;
    theApp.m_iCharSet        = m_nCharSet;
    theApp.m_iPosTextX       = m_cRectWindow.left;
    theApp.m_iPosTextY       = m_cRectWindow.top;
    theApp.m_iBoldText       = m_bBoldOn;
    theApp.m_iItalicText     = m_bItalicOn;
    theApp.m_iUnderlineText  = m_bUnderlineOn;

    theApp.m_iVertEditText   = m_bVertEditOn;

    theApp.m_iPenText        = m_bPenOn;
    }

/******************************************************************************/
/* See Save to ini for format of ini file                                     */

void CTfont::ReadFromIniFile(void)
    {
    CRect rect;

    GetWindowRect( &rect );

    CSize size = rect.Size();

    CPoint ptPos = theApp.CheckWindowPosition( CPoint( theApp.m_iPosTextX,
                                                       theApp.m_iPosTextY ),
                                               size );
    if (! ptPos.x
    &&  ! ptPos.y)
        {
        AfxGetMainWnd()->GetWindowRect( &rect );

        rect.OffsetRect( 15, 15 );

        ptPos.x = rect.left;
        ptPos.y = rect.top;
        }

    if (GetSafeHwnd() != NULL)
        {
        SetWindowPos(&wndTop, ptPos.x, ptPos.y, 0, 0, SWP_NOSIZE);
        }

    if (theApp.m_strTypeFaceName.IsEmpty() == 0)
        {
        m_cStrTypeFaceName = theApp.m_strTypeFaceName;
        m_iPointSize = theApp.m_iPointSize;

//        m_iPointSize = 0; // 0 is initial value => 1st in list will be selected

        CFontComboBox* pCBox = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);

        int iSelection = pCBox->SelectString(-1, m_cStrTypeFaceName);

        if (iSelection != CB_ERR)
            {
            CFontDesc* pDesc = pCBox->GetFontDesc(iSelection);
            BYTE nNewCharSet = PickCharSet(&pDesc->m_CharSetDesc, theApp.m_iCharSet);

            GetFontInfo(iSelection, nNewCharSet);

            ProcessNewTypeface();  // this will also set the pointsize to what we have in our variable
            }
        }

    if (theApp.m_iBoldText)
        {
        m_bBoldOn = FALSE;
        OnBold();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(BOLD_TBAR_POS, IDC_BOLD,  TBBS_CHECKBOX | TBBS_CHECKED, BOLD_BMP_POS);
        }

    if (theApp.m_iItalicText)
        {
        m_bItalicOn = FALSE;
        OnItalic();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(ITALIC_TBAR_POS, IDC_ITALIC,  TBBS_CHECKBOX | TBBS_CHECKED, ITALIC_BMP_POS);
        }

    if (theApp.m_iUnderlineText)
        {
        m_bUnderlineOn = FALSE;
        OnUnderline();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE,  TBBS_CHECKBOX | TBBS_CHECKED, UNDERLINE_BMP_POS);
        }


        if (theApp.m_iVertEditText == -1)       //no setting in profile
                {
                        theApp.m_iVertEditText = (IS_DBCS_CHARSET(m_nCharSet)) ? FALSE : 2;
                }

        if (theApp.m_iVertEditText == 2)
                {
                m_bVertEditOn = 2;
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,  TBBS_CHECKBOX | TBBS_DISABLED, VERTEDIT_BMP_POS);
                }
    else if (theApp.m_iVertEditText)
        {
        m_bVertEditOn = FALSE;
        OnVertEdit();  // toggles from false to TRUE
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,  TBBS_CHECKBOX | TBBS_CHECKED, VERTEDIT_BMP_POS);
        }
        else
        {
        m_bVertEditOn = FALSE;
        m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,  TBBS_CHECKBOX, VERTEDIT_BMP_POS);
        }


    if (theApp.m_bPenSystem)
        if (theApp.m_iPenText)
            {
            m_bPenOn = FALSE;
            OnPen();  // toggles from false to TRUE
            }
    }

/******************************************************************************/

void CTfont::RefreshFontList(void)
    {
        CFontComboBox* pBox = (CFontComboBox *)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
        pBox->ClearList();

    CClientDC cdcWindow(this);
    HDC hDC = cdcWindow.GetSafeHdc();

    ASSERT(hDC != NULL);

    if (hDC != NULL)
        {
        FONTENUMPROC lpEnumFamCallBack;
        lpEnumFamCallBack = (FONTENUMPROC) CTfont::EnumFontFaceProc;

        LOGFONT lf;
        memset(&lf, 0, sizeof(lf));
        lf.lfCharSet = DEFAULT_CHARSET;

        ::EnumFontFamiliesEx(hDC, &lf, lpEnumFamCallBack, (LPARAM) this, NULL);
        }
    }

/******************************************************************************/

int CFontComboBox::AddFontName(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
        int iFontType)
{
        int nIndex = FindStringExact(-1, lpszName);
        if (nIndex != CB_ERR)
        {
                // add this new charset to the end of the charset list

                CFontDesc* pDesc = (CFontDesc*) GetItemData(nIndex);

                CCharSetDesc *pCharSetDesc = &pDesc->m_CharSetDesc;

                while (pCharSetDesc->m_pNext != NULL) 
                {
                    pCharSetDesc = pCharSetDesc->m_pNext;
                }

                pCharSetDesc->m_pNext = new CCharSetDesc(lpszScript, nCharSet);

                return(nIndex);
        }

        CFontDesc* pDesc = new CFontDesc(lpszName, lpszScript, nCharSet, iFontType);
        if (!pDesc)
        {
                return(-1);
        }

        nIndex = AddString(lpszName);
        ASSERT(nIndex >=0);
        if (nIndex >=0) //no error
        {
                SetItemData(nIndex, (DWORD_PTR)pDesc);
        }
        else
        {
                delete pDesc;
        }

        return nIndex;
}

void CFontComboBox::ClearList()
{
        // destroy all the CFontDesc's
        int nCount = GetCount();
        for (int i=0;i<nCount;i++)
                delete GetFontDesc(i);

        ResetContent();
}

BOOL CFontComboBox::IsSameName(CFontDesc* pDesc, int index)
{
        CFontDesc* pDescOther = GetFontDesc(index);
        if (pDescOther == (CFontDesc*)CB_ERR)
        {
                return(FALSE);
        }

        return(lstrcmp(pDesc->m_strName, pDescOther->m_strName) == 0);
}

int CCharSetComboBox::AddCharSet(LPCTSTR lpszScript, BYTE nCharSet)
{
    int nIndex = AddString(lpszScript);

    if (nIndex != CB_ERR && nIndex != CB_ERRSPACE)
    {
        SetItemData(nIndex, nCharSet);
    }

    return nIndex;
}

int CCharSetComboBox::SelectCharSet(int nStartAfter, BYTE nCharSet)
{
    for (int i = nStartAfter+1; i < GetCount(); ++i)
    {
        if ((BYTE) GetItemData(i) == nCharSet) 
        {
            return SetCurSel(i);
        }
    }

    return CB_ERR;
}

int CCharSetComboBox::GetCurSelCharSet()
{
    int iSelection = GetCurSel();

    if (iSelection != CB_ERR)
        {
        iSelection = (int) GetItemData(iSelection);
        }

    return iSelection;
}


int CTfont::EnumFontFace( ENUMLOGFONTEX*   lpEnumLogFont,
                          NEWTEXTMETRICEX* lpNewTextMetric,
                          int iFontType )
{
        // only enumerate TrueType faces
        // in DBCS builds also exclude vertical faces
        if ((lpEnumLogFont->elfLogFont.lfCharSet != OEM_CHARSET)
                && (lpEnumLogFont->elfLogFont.lfCharSet != MAC_CHARSET)

                && (lpEnumLogFont->elfLogFont.lfFaceName[0] != TEXT('@'))

                )
        {
                INT  ntmFlags = lpNewTextMetric->ntmTm.ntmFlags;
                CFontComboBox* pBox = (CFontComboBox *)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);

                if (ntmFlags & NTM_PS_OPENTYPE)
                    iFontType = PS_OPENTYPE_FONT;
                else if  (ntmFlags & NTM_TYPE1)
                    iFontType = TYPE1_FONT;
                else
                {
                    if (iFontType & TRUETYPE_FONTTYPE)
                    {
                        if (ntmFlags & NTM_TT_OPENTYPE)
                            iFontType = TT_OPENTYPE_FONT;
                        else
                            iFontType = TT_FONT;
                    }
                    else if (iFontType & DEVICE_FONTTYPE)
                        iFontType = DEVICE_FONT;
                    else if (iFontType & RASTER_FONTTYPE)
                        iFontType = RASTER_FONT;
                }

                pBox->AddFontName(lpEnumLogFont->elfLogFont.lfFaceName,
                        (LPCTSTR)lpEnumLogFont->elfScript, lpEnumLogFont->elfLogFont.lfCharSet, iFontType);
        }
        return 1;
}

/******************************************************************************/

int CALLBACK CTfont::EnumFontFaceProc( ENUMLOGFONTEX*   lpEnumLogFont,
                                       NEWTEXTMETRICEX* lpNewTextMetric,
                                       int iFontType, LPARAM lParam )
    {
    class CTfont* pCTfont;

    ASSERT(lParam != NULL);

    if (lParam != NULL)
        {
        pCTfont = (CTfont*)lParam;
        return pCTfont->EnumFontFace(lpEnumLogFont, lpNewTextMetric, iFontType);
        }

    return 0;
    }

/******************************************************************************/

int  CTfont::EnumFontSizes( LPENUMLOGFONT lpEnumLogFont,
                            LPNEWTEXTMETRIC lpNewTextMetric,
                            int iFontType )
    {
    int iPtSize = 0;

    /* testint */

    CAttrEdit* pcEdit = m_pcTedit->GetEditWindow();

    ASSERT(pcEdit != NULL);

    if (pcEdit != NULL)
        {
        CClientDC cdcClient( pcEdit );

        // ptsize = char height * 72 / pixels  per inch
        // char height = cell height - internal leading

        iPtSize = MulDiv( lpNewTextMetric->tmHeight -
                          lpNewTextMetric->tmInternalLeading,
                      72, cdcClient.GetDeviceCaps( LOGPIXELSY ) );
        }

    TCHAR buffTmp[10];

    // Leading zero prefixed for Combobox sorting order.
    wsprintf( buffTmp, TEXT("%2d"), iPtSize );

    CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem(IDC_POINTSIZE);

    ASSERT (pCBox != NULL);

    if (pCBox != NULL)
        {
        // only add the string if it does not exist
        int iRC = pCBox->FindStringExact(-1, buffTmp);

        if (iRC == CB_ERR)
            {
            pCBox->AddString(buffTmp);
            }
        }
    return 1;
    }

/******************************************************************************/

int CALLBACK CTfont::EnumFontOneFaceProc( LPENUMLOGFONT lpEnumLogFont,
                                                  LPNEWTEXTMETRIC lpNewTextMetric,
                                                  int iFontType, LPARAM lParam )
    {
    class CTfont* pCTfont;

    ASSERT(lParam != NULL);

    if (lParam != NULL)
        {
        pCTfont = (CTfont*)lParam;
        return pCTfont->EnumFontSizes(lpEnumLogFont, lpNewTextMetric, iFontType);
        }

    return 0;
    }

/******************************************************************************/
// User selected a new typeface in the combo box
/******************************************************************************/

void CTfont::ProcessNewTypeface(void)
    {
    CString cStringText;
    CClientDC cdcDlgBox( this );
    HDC hDC = cdcDlgBox.GetSafeHdc();

    ASSERT(hDC != NULL);

    if (hDC != NULL)
        {
        FONTENUMPROC lpEnumFamCallBack;
        lpEnumFamCallBack = (FONTENUMPROC)CTfont::EnumFontOneFaceProc;

        CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem(IDC_POINTSIZE);

        ASSERT (pCBox != NULL);

        if (pCBox != NULL)
            {
            pCBox->ResetContent();

            // only do this if non-true-type font  if true type, filll in with  default sizes
            if (
                (m_iFontType & (TT_FONT | TT_OPENTYPE_FONT)) ||
                !( (m_iFontType & (TT_FONT | TT_OPENTYPE_FONT)) || (m_iFontType & RASTER_FONT) )
                ) // if truetype or vector font
                {
                // True Type and Vector Fonts are continuously scallable.
                // There are the reccomended values
                pCBox->AddString(TEXT(" 8"));
                pCBox->AddString(TEXT(" 9"));
                pCBox->AddString(TEXT("10"));
                pCBox->AddString(TEXT("11"));
                pCBox->AddString(TEXT("12"));
                pCBox->AddString(TEXT("14"));
                pCBox->AddString(TEXT("16"));
                pCBox->AddString(TEXT("18"));
                pCBox->AddString(TEXT("20"));
                pCBox->AddString(TEXT("22"));
                pCBox->AddString(TEXT("24"));
                pCBox->AddString(TEXT("26"));
                pCBox->AddString(TEXT("28"));
                pCBox->AddString(TEXT("36"));
                pCBox->AddString(TEXT("48"));
                pCBox->AddString(TEXT("72"));
                }
            else
                {
                ::EnumFontFamilies(hDC, m_strFontName, lpEnumFamCallBack, (LPARAM) this);
                }

            // 0 is uninitialized value
            if (m_iPointSize != 0)
                {
                m_cTfontDlg.SetDlgItemInt(IDC_POINTSIZE, m_iPointSize);
                }
            else
                {
                pCBox->SetCurSel(0);
                }
           // simulate a selection
           OnPointSizeComboBoxUpdate();
           }
       }
    }

/******************************************************************************/
// change the font in the edit control based on the font selection
/******************************************************************************/

void CTfont::UpdateEditControlFont(void)
    {
    LOGFONT    lf;
    CFont*     pcOldFont;
    BOOL       bRC;
    HFONT      hFont;
    int        iCellHeight = 0;

    BeginWaitCursor();


    CAttrEdit* pcEdit = m_pcTedit->GetEditWindow();

    ASSERT(pcEdit != NULL);

    if (pcEdit != NULL)
        {
        CClientDC cdcClient( pcEdit );

        //previous font's tm.tmInternalLeading could be different from current.
        iCellHeight = - MulDiv(m_iPointSize, cdcClient.GetDeviceCaps(LOGPIXELSY)
                      ,72);
        }

    lf.lfWidth          = 0;
    lf.lfHeight         = iCellHeight;

    lf.lfEscapement     = (m_bVertEditOn == TRUE) ? 2700 : 0;
    lf.lfOrientation    = (m_bVertEditOn == TRUE) ? 2700 : 0;
    lf.lfWeight         = m_iWeight;
    lf.lfItalic         = (BYTE)m_bItalicOn;
    lf.lfUnderline      = (BYTE)m_bUnderlineOn;
    lf.lfStrikeOut      = 0;
    lf.lfCharSet        = m_nCharSet;
    lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    lf.lfQuality        = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = FF_DONTCARE | DEFAULT_PITCH;


    if ( (m_bVertEditOn == TRUE) && IS_DBCS_CHARSET( lf.lfCharSet ) )
         {
         lstrcpy(lf.lfFaceName, TEXT("@"));
         lstrcpyn(lf.lfFaceName + 1, m_strFontName, ARRAYSIZE(lf.lfFaceName) - 1);
         }
     else
         lstrcpyn(lf.lfFaceName, m_strFontName, ARRAYSIZE(lf.lfFaceName));

    hFont = (HFONT)m_cCurrentFont.Detach();
    bRC = m_cCurrentFont.CreateFontIndirect(&lf);

    ASSERT(bRC != 0);

    if (bRC != 0)
        {
        if (m_pcTedit != NULL)
            {
            CAttrEdit* pcEdit = m_pcTedit->GetEditWindow();

            ASSERT( pcEdit != NULL );

            pcOldFont = pcEdit->GetFont();
            pcEdit->SetFont( &m_cCurrentFont );
            m_pcTedit->OnAttrEditFontChange();
            m_pcTedit->RefreshWindow();
            }

        //hFont is last font allocated here
        if (hFont != NULL)
            {
            ::DeleteObject( hFont );
            }
        }
    else
        {
        /*DK* ##ERROR Could not create font indirect */
        }

    EndWaitCursor();
    }

/******************************************************************************/
/******************************************************************************/

BYTE CTfont::PickCharSet(CCharSetDesc *pCharSetDescList, int iCharSetSelection)
{
    ASSERT(pCharSetDescList);

    // place the selected charset on top of the charset history list

    if (iCharSetSelection != g_CharSetHistoryList.GetAt(0) && iCharSetSelection != -1)
    {
        g_CharSetHistoryList.AddHead(iCharSetSelection);
    }

    // try to select a charset from the history list

    for (unsigned int i = 0; i < g_CharSetHistoryList.m_uHistorySize; ++i) 
    {
        int nSearchCharSet = g_CharSetHistoryList.GetAt(i);

        if (nSearchCharSet != -1) 
        {
            for (CCharSetDesc *pCharSetDesc = pCharSetDescList; pCharSetDesc != NULL; pCharSetDesc = pCharSetDesc->m_pNext) 
            {
                if (pCharSetDesc->m_nCharSet == (BYTE) nSearchCharSet)
                {
                    return (BYTE) nSearchCharSet;
                }
            }
        }
    }

    // if we fail to find a match, select the first charset

    return pCharSetDescList->m_nCharSet;
}

/******************************************************************************/
// Combo box for type face changed, determine what processing to do
/******************************************************************************/

void CTfont::OnTypeFaceComboBoxUpdate(void)
    {
    int iSelection;
    CString cStringText;

//  LPFONTINFORMATION lpFontInformation;

    CFontComboBox*    pFontCBox    = (CFontComboBox*)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
    CCharSetComboBox* pCharSetCBox = (CCharSetComboBox*)m_cTfontDlg.GetDlgItem(IDC_CHARSET);

    ASSERT(pFontCBox != NULL && pCharSetCBox != NULL);

    if (pFontCBox != NULL && pCharSetCBox != NULL)
        {
        TRY
            {
            iSelection = pFontCBox->GetCurSel();

            ASSERT(iSelection != CB_ERR);

            if (iSelection != CB_ERR)
                {
                pFontCBox->GetLBText(iSelection, cStringText);
                }
            }
        CATCH(CMemoryException,e)
            {
            cStringText.Empty();
            /*DK* ##ERROR CString Thrown CMemoryException*/
            }
        END_CATCH

        int iCharSetSelection = pCharSetCBox->GetCurSelCharSet();

        if (m_cStrTypeFaceName.Compare(cStringText) != 0 || (BYTE) iCharSetSelection != m_nCharSet)
            {
            CFontDesc* pDesc = pFontCBox->GetFontDesc(iSelection);

            BYTE nNewCharSet = PickCharSet(&pDesc->m_CharSetDesc, iCharSetSelection);

            if ( IS_DBCS_CHARSET( nNewCharSet ) )
                {
                if ( m_bVertEditOn == 2 )
                    {
                    m_bVertEditOn = FALSE;
                    m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT,
                                                 TBBS_CHECKBOX, VERTEDIT_BMP_POS);
                    }
                }
            else
                {
                if ( m_bVertEditOn == TRUE )
                    {
                    AfxMessageBox(IDS_ERROR_DBCSFONTONLY);
                    pFontCBox->SelectString( -1, m_cStrTypeFaceName );
                    pCharSetCBox->SelectCharSet( -1, m_nCharSet );
                    return;
                    }
                else
                    {
                    m_bVertEditOn = 2;
                    m_pcTfontTbar->SetButtonInfo(VERTEDIT_TBAR_POS, IDC_VERTEDIT, TBBS_CHECKBOX | TBBS_DISABLED, VERTEDIT_BMP_POS);
                    }
                }


            // could have been set in OnCloseUpTypeFace method, so don't do double
            // processing
            TRY
                {
                m_cStrTypeFaceNamePrev = m_cStrTypeFaceName;
                m_cStrTypeFaceName = cStringText;
                }
            CATCH(CMemoryException,e)
                {
                m_cStrTypeFaceName.Empty();
                /*DK* ##ERROR CString Thrown CMemoryException*/
                }
            END_CATCH

            GetFontInfo(iSelection, nNewCharSet);

            ProcessNewTypeface();
            m_iControlIDLastChange = IDC_TYPEFACE;
            }
        }
    }

/******************************************************************************/

void CTfont::OnPointSizeComboBoxUpdate(void)
    {
    int iSelection;
    int iHeight;
    CString cStringText;

    CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem(IDC_POINTSIZE);

    ASSERT(pCBox != NULL);

    if (pCBox != NULL)
        {
        TRY
            {
            iSelection = pCBox->GetCurSel();

            if (iSelection != CB_ERR)
                {
                pCBox->GetLBText(iSelection, cStringText);
                iHeight = Atoi(cStringText);
                }
            else
                {
                // if no selection, get displayed value in combo edit part
                iHeight = m_cTfontDlg.GetDlgItemInt(IDC_POINTSIZE);
                }
            }
        CATCH(CMemoryException,e)
            {
            cStringText.Empty();
            /*DK* ##ERROR CString Thrown CMemoryException*/
            }
        END_CATCH


        if (iHeight !=0 )
            {
            if (iHeight != m_iPointSize )
                                {
                    // could have been set in OnCloseUpTypeFace method, so don't do double
                    // processing
                    m_iPointSizePrev = m_iPointSize;
                    m_iPointSize = iHeight;
                    }
                        }
                else
                        {
                        AfxMessageBox(IDS_ERROR_FONTSIZENUMERIC);
                        m_cTfontDlg.SetDlgItemInt(IDC_POINTSIZE,m_iPointSize);
                        }

        // need to call update font  because could be same size with diff
        // typeface, and we got called indirectly by filling the combo box
        UpdateEditControlFont();
        m_iControlIDLastChange = IDC_POINTSIZE;
        }
    }

/******************************************************************************/

void CTfont::OnTypefaceChange()
    {
    if (! m_bInUpdate)
        {
        m_bInUpdate = TRUE;
        OnTypeFaceComboBoxUpdate();
        m_bInUpdate = FALSE;
        }
    }

/******************************************************************************/

void CTfont::OnPointSizeChange()
    {
    if (! m_bInUpdate)
        {
        m_bInUpdate = TRUE;
        OnPointSizeComboBoxUpdate();
        m_bInUpdate = FALSE;
        }
    }

/******************************************************************************/

void CTfont::OnRButtonDown(UINT nFlags, CPoint point)
    {
#if 0
    CMenu cMenuPopup;
    CMenu *pcContextMenu;
    BOOL  bRC;

    bRC = cMenuPopup.LoadMenu(IDR_TEXT_POPUP);

    ASSERT(bRC != 0);

    if (bRC != 0)
        {
        pcContextMenu = cMenuPopup.GetSubMenu(ID_TOOL_POPUPMENU_POS);
        ASSERT(pcContextMenu != NULL);
        if (pcContextMenu != NULL)
            {
            ClientToScreen(&point);
            pcContextMenu->TrackPopupMenu(TPM_LEFTALIGN, point.x, point.y, this, NULL);
            }
        }
    else
        {
        /*DK* ##ERROR Could not loadmenu */
        }
#endif
    }

/******************************************************************************/

void CTfont::OnMove(int x, int y)
    {
    CMiniFrmWnd::OnMove(x, y);

    // TODO: Add your message handler code here
    GetWindowRect(&m_cRectWindow);
    }

/******************************************************************************/

void CTfont::OnClose()
    {
    theApp.m_bShowTextToolbar = FALSE;

    ShowWindow( SW_HIDE );
    }

/******************************************************************************/

BOOL CTfont::OnEraseBkgnd( CDC* pDC )
    {
    CRect rect;

    GetClientRect( rect );

    pDC->FillRect( rect, GetSysBrush( COLOR_BTNFACE ) );

        return CMiniFrmWnd::OnEraseBkgnd( pDC );
    }

/******************************************************************************/

void CTfont::OnSetFocus(CWnd* pOldWnd)
    {
    CMiniFrmWnd::OnSetFocus(pOldWnd);

    CComboBox* pCBox = (CComboBox*)m_cTfontDlg.GetDlgItem( IDC_TYPEFACE );

    ASSERT(pCBox != NULL);

    if (pCBox != NULL)
        {
        pCBox->SetFocus();
        }
    }

/******************************************************************************/

void CTfont::OnDestroy()
{
        CFontComboBox* pBox = (CFontComboBox *)m_cTfontDlg.GetDlgItem(IDC_TYPEFACE);
        pBox->ClearList();

        CMiniFrmWnd::OnDestroy();
}

/******************************************************************************/

void CTfont::OnBold(void)
    {
    m_iControlIDLastChange = IDC_BOLD;

    m_bBoldOn = !m_bBoldOn;

    if (m_bBoldOn)
        {
        m_iWeight = FW_BOLD;
        }
    else
        {
        m_iWeight = FW_NORMAL;
        }

    UpdateEditControlFont();
    }

/******************************************************************************/

void CTfont::OnItalic(void)
    {
    m_bItalicOn = !m_bItalicOn;

    UpdateEditControlFont();

    m_iControlIDLastChange = IDC_ITALIC;
    }

/******************************************************************************/

void CTfont::OnUnderline(void)
    {
    m_bUnderlineOn = !m_bUnderlineOn;

    UpdateEditControlFont();

    m_iControlIDLastChange = IDC_UNDERLINE;
    }


/******************************************************************************/

void CTfont::OnVertEdit(void)
    {
    if (m_bVertEditOn == 2)
        {
        return;
        }

    m_bVertEditOn = !m_bVertEditOn;
    m_pcTedit->m_bVertEdit = m_bVertEditOn;
    UpdateEditControlFont();
    m_iControlIDLastChange = IDC_VERTEDIT;
    }

/******************************************************************************/

void CTfont::OnVertEditUpdate(CCmdUI* pCmdUI)
    {
        pCmdUI->Enable( !(m_bVertEditOn == 2) );
    }


/******************************************************************************/

void CTfont::OnShadow(void)
    {
    m_bShadowOn = !m_bShadowOn;

    UpdateEditControlFont();

    m_iControlIDLastChange = IDC_SHADOW;
    }

/******************************************************************************/

void CTfont::OnPen(void)
    {
    PostMessage( UM_DELAYED_TOOLBAR );
    }

/******************************************************************************/

long CTfont::OnDelayedPen( WPARAM, LPARAM )
    {
    if (! theApp.m_bPenSystem)
        m_bPenOn = FALSE;

    m_bPenOn               = !m_bPenOn;
    m_iControlIDLastChange = IDC_PENEXT;

    delete m_pcTfontTbar;

    m_pcTfontTbar = new CTfontTbar();

    BOOL bRC = m_pcTfontTbar->Create( this, m_bPenOn );

    if (bRC)
        {
        ResizeWindow();
        RefreshToolBar();
        }
    return 0;
    }

/******************************************************************************/

void CTfont::OnEditText(void)
    {
    m_iControlIDLastChange = IDC_EDITTEXT;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SetFocus();
        #ifndef NT
        // NT doesn't support pen computing
        ctl->SendMessage(WM_PENMISC, PMSC_EDITTEXT, 0);
        #endif
        }
    }

/******************************************************************************/

void CTfont::OnKeyboard(void)
    {
    m_iControlIDLastChange = IDC_KEYBOARD;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        }
    }

/******************************************************************************/

void CTfont::OnInsSpace(void)
    {
    m_iControlIDLastChange = IDC_INS_SPACE;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SendMessage(WM_CHAR, (WPARAM)VK_SPACE, 0);
        ctl->SetFocus();
        }
    }

/******************************************************************************/

void CTfont::OnBackSpace(void)
    {
    m_iControlIDLastChange = IDC_BACKSPACE;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SendMessage(WM_CHAR, (WPARAM)VK_BACK, 0);
        ctl->SetFocus();
        }
    }

/******************************************************************************/

void CTfont::OnNewLine(void)
    {
    m_iControlIDLastChange = IDC_NEWLINE;

    CEdit *ctl = m_pcTedit? m_pcTedit->GetEditWindow() : NULL;
    if (ctl)
        {
        ctl->SendMessage(WM_CHAR, (WPARAM)VK_RETURN, 0);
        ctl->SetFocus();
        }
    }

/******************************************************************************/

void CTfontDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
    {
    CString   cStringText;
    CComboBox cCBox;
    BOOL      bRC;

    TRY
        {
        ASSERT( lpDrawItemStruct->CtlType == ODT_COMBOBOX );
        ASSERT( lpDrawItemStruct->CtlID   == IDC_TYPEFACE );

        if (lpDrawItemStruct->CtlType != ODT_COMBOBOX
        ||  lpDrawItemStruct->CtlID   != IDC_TYPEFACE)
            {
            AfxThrowNotSupportedException();
            }

        // empty combo boxes have -1 id

        if (lpDrawItemStruct->itemID != 0xFFFFFFFF)
            {
            bRC = cCBox.Attach(lpDrawItemStruct->hwndItem);

            ASSERT(bRC != 0);

            if (bRC == 0)
                {
                AfxThrowNotSupportedException();
                }

            TRY
                {
                cCBox.GetLBText(lpDrawItemStruct->itemID, cStringText);
                cCBox.Detach();

                DrawItem(lpDrawItemStruct, &cStringText);
                }
            CATCH(CMemoryException,e)
                {
                cStringText.Empty();
                cCBox.Detach();
                /*DK* ##ERROR CString Thrown CMemoryException*/
                }
            END_CATCH
            }
        }
    CATCH(CNotSupportedException,e)
        {
        CWnd::OnDrawItem(nIDCtl, lpDrawItemStruct);
        }
    END_CATCH
    }

/******************************************************************************/


void CTfont::OnLButtonDown(UINT nFlags, CPoint point)
    {
    CMiniFrmWnd::OnLButtonDown(nFlags, point);
    }

/******************************************************************************/

void CTfont::OnLButtonUp(UINT nFlags, CPoint point)
    {
    CMiniFrmWnd::OnLButtonUp( nFlags, point );
    }

/******************************************************************************/

void CTfont::RecalcLayout(BOOL bNotify /*= TRUE*/)
    {
    if (m_pcTfontTbar && m_pcTfontTbar->m_hWnd && m_cTfontDlg.m_hWnd)
        {
        ResizeWindow();
        }
    }

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/
// CTfontTbar

BEGIN_MESSAGE_MAP( CTfontTbar, CToolBar )
    //{{AFX_MSG_MAP(CTfontTbar)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //  ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/
// CTfontTbar construction/destruction

CTfontTbar::CTfontTbar(void)
    {
    }

/******************************************************************************/

BOOL CTfontTbar::Create(CWnd* pcParentWnd, BOOL bShowPen)
    {
    BOOL bRC = TRUE;
    int iNumButtons;
    int iNumSeparators;

    UINT ButtonIDS[MAX_TBAR_ITEMS];

    if (bShowPen)
        {
        ButtonIDS[0]   = IDC_BOLD;
        ButtonIDS[1]   = IDC_ITALIC;
        ButtonIDS[2]   = IDC_UNDERLINE;


        ButtonIDS[3]   = IDC_VERTEDIT;

        ButtonIDS[4]   = ID_SEPARATOR;
        ButtonIDS[5]   = IDC_INS_SPACE;
        ButtonIDS[6]   = IDC_BACKSPACE;
        ButtonIDS[7]   = IDC_NEWLINE;

        ButtonIDS[8]   = ID_SEPARATOR;
        ButtonIDS[9]   = IDC_EDITTEXT;

        ButtonIDS[10]  = ID_SEPARATOR;
        ButtonIDS[11]  = IDC_PENEXT;

        iNumButtons    = 12;
        iNumSeparators = 3;
        }
    else
        {
        ButtonIDS[0] = IDC_BOLD;
        ButtonIDS[1] = IDC_ITALIC;
        ButtonIDS[2] = IDC_UNDERLINE;

        ButtonIDS[3] = IDC_VERTEDIT;


        if (theApp.m_bPenSystem)
            {

            ButtonIDS[4] = ID_SEPARATOR;

            ButtonIDS[5] = IDC_PENEXT;
            iNumButtons    = 6;
            iNumSeparators = 1;
            }
        else
            {

            iNumButtons    = 4;
            iNumSeparators = 0;
            }
        }

    bRC = CToolBar::Create( pcParentWnd, CBRS_ALIGN_TOP );

    if (bRC == 0)
        {
        AfxThrowResourceException();
        /*DK* ##ERROR Could not create toolbar object*/
        }

    bRC = LoadBitmap(IDB_TEXT_TBAR);

    if (bRC == 0)
        {
        AfxThrowResourceException();
        /*DK* ##ERROR Could not load bitmap for toolbar*/
        }

    bRC = SetButtons(ButtonIDS, iNumButtons);

    if (bShowPen)
        {
        // Set the style to be checkbox  style.
        SetButtonInfo(BOLD_TBAR_POS,      IDC_BOLD,       TBBS_CHECKBOX, BOLD_BMP_POS);
        SetButtonInfo(ITALIC_TBAR_POS,    IDC_ITALIC,     TBBS_CHECKBOX, ITALIC_BMP_POS);
        SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE,  TBBS_CHECKBOX, UNDERLINE_BMP_POS);

        SetButtonInfo(VERTEDIT_TBAR_POS,  IDC_VERTEDIT,   TBBS_CHECKBOX, VERTEDIT_BMP_POS);



        SetButtonInfo(INS_SPACE_TBAR_POS, IDC_INS_SPACE,  TBBS_BUTTON, INS_SPACE_BMP_POS);
        SetButtonInfo(BACKSPACE_TBAR_POS, IDC_BACKSPACE,  TBBS_BUTTON, BACKSPACE_BMP_POS);
        SetButtonInfo(NEWLINE_TBAR_POS,   IDC_NEWLINE,    TBBS_BUTTON, NEWLINE_BMP_POS);

        SetButtonInfo(EDITTEXT_TBAR_POS,  IDC_EDITTEXT,   TBBS_BUTTON, EDITTEXT_BMP_POS);

        SetButtonInfo(PEN_TBAR_PEN_POS,   IDC_PENEXT,     TBBS_CHECKBOX, PEN_BMP_POS);

// presently unused
//        SetButtonInfo(KEYBOARD_TBAR_POS,  IDC_KEYBOARD,   TBBS_BUTTON, KEYBOARD_BMP_POS);
        }
    else
        {
        // Set the style to be checkbox  style.
        SetButtonInfo(BOLD_TBAR_POS,      IDC_BOLD,       TBBS_CHECKBOX, BOLD_BMP_POS);
        SetButtonInfo(ITALIC_TBAR_POS,    IDC_ITALIC,     TBBS_CHECKBOX, ITALIC_BMP_POS);
        SetButtonInfo(UNDERLINE_TBAR_POS, IDC_UNDERLINE,  TBBS_CHECKBOX, UNDERLINE_BMP_POS);

        SetButtonInfo(VERTEDIT_TBAR_POS,  IDC_VERTEDIT,   TBBS_CHECKBOX, VERTEDIT_BMP_POS);


        if (theApp.m_bPenSystem)
            SetButtonInfo(PEN_TBAR_TEXT_POS, IDC_PENEXT,  TBBS_CHECKBOX, PEN_BMP_POS);
        }

    CSize size = CToolBar::CalcFixedLayout( FALSE, TRUE );

    if (GetSafeHwnd() != NULL)
        {
        SetWindowPos( &wndTop, 0, 0, size.cx, size.cy, SWP_NOMOVE );
        }

    return bRC;
    }

/******************************************************************************/

CTfontTbar::~CTfontTbar(void)
    {
    }

/******************************************************************************/
/******************************************************************************/
// CTfontDlg

BEGIN_MESSAGE_MAP(CTfontDlg, CDialogBar)
    //{{AFX_MSG_MAP(CTfontDlg)
    ON_WM_RBUTTONDOWN()
    ON_WM_MEASUREITEM()
    ON_WM_DRAWITEM()
//  ON_DM_GETDEFID()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/******************************************************************************/
// CTfontDlg construction/destruction

CTfontDlg::CTfontDlg(void)
    {
      BOOL bRC;
      CSize cSizeBmp(0, 0);
      INT   i;

      m_Max_cx_FontType_BMP = 0;

      // Set up the Size Structures for offsets in drawing the font typeface.
      for (i = 0; i < NumCPic; i++)
      {
          bRC = m_cPictures[i].PictureSet(CTBitmaps[i]);
          ASSERT( bRC != 0 );

          if (bRC)
          {
              cSizeBmp = m_cPictures[i].PictureSize();
              if (cSizeBmp.cx > m_Max_cx_FontType_BMP)
              {
                  m_Max_cx_FontType_BMP = cSizeBmp.cx;
              }
          }
          else
          {
              /*DK* ##ERROR  could not create bitmap for tt font in owner draw lbox*/
          }
      }
    }

/******************************************************************************/

BOOL CTfontDlg::Create(CWnd* pcParentWnd)
    {
    BOOL bRC = CDialogBar::Create(pcParentWnd, IDD_TEXT_FONT_DLG,
                                               CBRS_NOALIGN, NULL);
    if (bRC)
        SetWindowPos(&wndTop, 0,0, m_sizeDefault.cx, m_sizeDefault.cy, SWP_NOMOVE);

    return bRC;
    }

/******************************************************************************/

CTfontDlg::~CTfontDlg(void)
    {
    }

/******************************************************************************/

void CTfontDlg::OnRButtonDown(UINT nFlags, CPoint point)
    {
    CWnd *pcParent = GetParent();

    const MSG *pCurrentMessage = GetCurrentMessage();

    pcParent->SendMessage(pCurrentMessage->message, pCurrentMessage->wParam,
                          pCurrentMessage->lParam);
    }

/******************************************************************************/
void CTfontDlg::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
    {
    TEXTMETRIC tm;
    BOOL bRC;

    // get default to fill in measureitem struct first
    CWnd::OnMeasureItem(nIDCtl, lpMeasureItemStruct);

    TRY
        {
        ASSERT( lpMeasureItemStruct->CtlType == ODT_COMBOBOX );
        ASSERT( lpMeasureItemStruct->CtlID   == IDC_TYPEFACE );

        if (lpMeasureItemStruct->CtlType != ODT_COMBOBOX
        ||  lpMeasureItemStruct->CtlID   != IDC_TYPEFACE)
            {
            AfxThrowNotSupportedException();
            }

        CClientDC cdcClient(this);

        bRC = cdcClient.GetTextMetrics(&tm);

        ASSERT(bRC !=0);

        if (bRC != 0)
            {
            lpMeasureItemStruct->itemHeight = tm.tmAscent + 2;
            }
        }
    CATCH(CNotSupportedException,e)
        {
        }
    END_CATCH
    }

/******************************************************************************/

void CTfontDlg::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct, CString *pcStringText)
{
   CBrush* cpBrush;
   BOOL   bSelected;
   BOOL   bRC;
   CDC    cdcCombo;
   BOOL   bDrawPicture = FALSE;
   CRect  cRectText;
   int    iPictureHeight = 0;
   CSize  cSizeBmp(0,0);
   int    ix = 0;
   int    iy = 0;

   CFontDesc* pDesc = (CFontDesc*)lpDrawItemStruct->itemData;
   CFontComboBox *pwndCombo = (CFontComboBox *)CFontComboBox::FromHandle(lpDrawItemStruct->hwndItem);
   if (pwndCombo)
   {
   // Only need to check the item before and after
      if (!pwndCombo->IsSameName(pDesc, lpDrawItemStruct->itemID - 1)
       && !pwndCombo->IsSameName(pDesc, lpDrawItemStruct->itemID + 1))
      {
         pcStringText = &pDesc->m_strName;
      }
   }

   // Set the picture object up to draw a picture if one is needed (if this
   // font is a printer/true type font).
   bDrawPicture = TRUE;

   switch (pDesc->m_iFontType)
   {
      case DEVICE_FONT:
         cSizeBmp       = m_cPictures[1].PictureSize();
         break;

      case TT_FONT:
         cSizeBmp       = m_cPictures[0].PictureSize();
         break;

      case TT_OPENTYPE_FONT:
         cSizeBmp       = m_cPictures[2].PictureSize();
         break;

      case PS_OPENTYPE_FONT:
         cSizeBmp       = m_cPictures[3].PictureSize();
         break;

      case TYPE1_FONT:
         cSizeBmp       = m_cPictures[4].PictureSize();
         break;

      default:
         bDrawPicture = FALSE;
         break;
   }

   if (bDrawPicture)
   {
      iPictureHeight = cSizeBmp.cy;
   }

   TRY
   {
      if ( (lpDrawItemStruct->itemState & ODS_SELECTED) ==  ODS_SELECTED)
      {
         bSelected = TRUE;
         cpBrush = GetSysBrush( COLOR_HIGHLIGHT );
      }
      else
      {
         bSelected = FALSE;
         cpBrush = GetSysBrush( COLOR_WINDOW );
      }

      if (! cpBrush)
      {
         /*DK* ##ERROR Could not create solid brush */
         AfxThrowNotSupportedException();
      }

      bRC = cdcCombo.Attach(lpDrawItemStruct->hDC);

      ASSERT(bRC != 0);

      if (bRC == 0)
      {
          AfxThrowNotSupportedException();
      }

      SetColorsInDC(lpDrawItemStruct->hDC, bSelected);

      cdcCombo.FillRect(&(lpDrawItemStruct->rcItem), cpBrush);

      // If this is a Printer or True Type font, draw the image/picture.
      if (bDrawPicture)
      {
          ix = lpDrawItemStruct->rcItem.left + 1;  // 0 is focus rect
          //center vertically
          iy = lpDrawItemStruct->rcItem.top +
              abs(((lpDrawItemStruct->rcItem.bottom -
          lpDrawItemStruct->rcItem.top) - iPictureHeight))/2;

          switch (pDesc->m_iFontType)
          {
             case DEVICE_FONT:
                m_cPictures[1].Picture(&cdcCombo, ix, iy);
                break;

             case TT_FONT:
                m_cPictures[0].Picture(&cdcCombo, ix, iy);
                break;

             case TT_OPENTYPE_FONT:
                m_cPictures[2].Picture(&cdcCombo, ix, iy);
                break;

             case PS_OPENTYPE_FONT:
                m_cPictures[3].Picture(&cdcCombo, ix, iy);
                break;

             case TYPE1_FONT:
                m_cPictures[4].Picture(&cdcCombo, ix, iy);
                break;

             default:
                break;
          }
      }

      // set the rectangle  for the text, and draw the text
      cRectText       =  lpDrawItemStruct->rcItem;
      cRectText.left += m_Max_cx_FontType_BMP + FONT_BMP_TXT_BORDER;

      cdcCombo.DrawText(*pcStringText, -1, &(cRectText), DT_LEFT | DT_SINGLELINE | DT_VCENTER);

      if ( (lpDrawItemStruct->itemState & ODS_FOCUS) ==  ODS_FOCUS)
      {
         cdcCombo.DrawFocusRect(&(lpDrawItemStruct->rcItem));
      }

   }
   CATCH(CNotSupportedException,e)
   {
   /*DK* ##ERROR Internal Thown Unsupported Exception */
   }
   END_CATCH

   cdcCombo.Detach();
}

/******************************************************************************/
// bInverted is the same as text selected.

void CTfontDlg::SetColorsInDC(HDC hdc, BOOL bInverted)
{
    DWORD dwFGColor;
    DWORD dwBKColor;

    if (bInverted)
        {
        dwFGColor = ::GetSysColor( COLOR_HIGHLIGHTTEXT );
        dwBKColor = ::GetSysColor( COLOR_HIGHLIGHT );
        }
    else
       {
       dwFGColor = ::GetSysColor( COLOR_WINDOWTEXT );
       dwBKColor = ::GetSysColor( COLOR_WINDOW );
       }

    ::SetTextColor( hdc, dwFGColor );

    ::SetBkMode ( hdc, OPAQUE );
    ::SetBkColor( hdc, dwBKColor );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\thumnail.h ===
#ifndef __THUMNAIL_H__
#define __THUMNAIL_H__

/******************************************************************************/

class CThumbNailView : public CWnd
    {
    DECLARE_DYNAMIC(CThumbNailView)

    protected:

    class CImgWnd *m_pcImgWnd;

    // Generated message map functions
    //{{AFX_MSG(CThumbNailView)
    afx_msg void OnPaint();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnThumbnailThumbnail();
    afx_msg void OnUpdateThumbnailThumbnail(CCmdUI* pCmdUI);
    afx_msg void OnClose();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DrawTracker(CDC *pDC);

    public:

    CThumbNailView();
    CThumbNailView(CImgWnd *pcImgWnd);
    ~CThumbNailView();
    BOOL Create(DWORD dwStyle, CRect cRectWindow, CWnd *pcParentWnd);
    void DrawImage(CDC* pDC);
    void RefreshImage(void);
    CImgWnd* GetImgWnd(void);
    void UpdateThumbNailView();
    };

/******************************************************************************/

class CFloatThumbNailView : public CMiniFrmWnd
    {
    DECLARE_DYNAMIC(CFloatThumbNailView)

    protected:

    CThumbNailView *m_pcThumbNailView;

    // Generated message map functions
    //{{AFX_MSG(CFloatThumbNailView)
    afx_msg void OnClose();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    public:

    CPoint GetPosition() { return m_ptPosition; }
    CSize  GetSize()     { return m_szSize; }

    CFloatThumbNailView();
    CFloatThumbNailView(CImgWnd *pcImgWnd);
    ~CFloatThumbNailView();
    CThumbNailView* GetThumbNailView() { return m_pcThumbNailView; }

    virtual BOOL Create(CWnd* pParentWnd);
    virtual void PostNcDestroy();
    virtual WORD GetHelpOffset() { return ID_WND_GRAPHIC; }

    private:

    CPoint  m_ptPosition;
    CSize   m_szSize;
    };

/******************************************************************************/

class CFullScreenThumbNailView : public CFrameWnd
    {
    DECLARE_DYNAMIC(CFullScreenThumbNailView)

    private:
    LONG_PTR m_hOldIcon;
    protected:

    BOOL   m_bSaveShowFlag;
//  CBrush m_brBackground;

    CThumbNailView *m_pcThumbNailView;

    // Generated message map functions
    //{{AFX_MSG(CFullScreenThumbNailView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnClose ();

        //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    public:

    CFullScreenThumbNailView();
    CFullScreenThumbNailView(CImgWnd *pcImgWnd);
    ~CFullScreenThumbNailView();
    virtual BOOL Create(LPCTSTR szCaption);
    };


#endif // __THUMNAIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\toolbox.h ===
// toolbox.h : Declares the class interfaces for the toolbox window class.

#ifndef __TOOLBOX_H__
#define __TOOLBOX_H__

#define TM_TOOLDOWN     (WM_USER+0x0010)
#define TM_TOOLUP       (WM_USER+0x0011)
#define TM_TOOLDBLCLK   (WM_USER+0x0012)
#define TM_QUERYDROP    (WM_USER+0x0013)
#define TM_DROP         (WM_USER+0x0014)
#define TM_ABORTDROP    (WM_USER+0x0015)

#define TF_DISABLED     0x8000
#define TF_GRAYED       TF_DISABLED
#define TF_SELECTED     0x4000
#define TF_DOWN         TF_SELECTED
#define TF_DRAG         0x2000
#define TF_HOT          0x0800
#define TF_NYI          0x9000     // this represents a NYI tool (note that
                                   // TF_NYI implies TF_DISABLED)

#define TS_DEFAULT      0xC000
#define TS_STICKY       0x4000
#define TS_DRAG         0x2000
#define TS_CMD          0x1000
#define TS_VB           0x0800
#define TS_WELL         0x0400

#define NUM_TOOLS_WIDE  2

class CToolboxWnd;

#ifdef CUSTOMFLOAT
class CImageWell;
#else //!CUSTOMFLOAT
#include "imgwell.h"
#include "imgcolor.h"
#endif

/////////////////////////////////////////////////////////////////////////////

// CTool:
// A CTool is a thin-window button which can be inserted in a CToolboxWnd.
// Note that the tool is "owned" by a separate window, which is notified
// directly when the tool is used (pushed, dragged, unpushed, etc.).  The
// CToolboxWnd sends TM_* messages to the owning window.
//
// The graphics are completely calculated from the single bitmap given to
// the tool upon creation.  The pushed, disabled and unpushed states are
// drawn from the bitmap, which should be a two-color image without any
// chiseling button effects in it.  The graphic is centered in the button.
//
// For buttons defined with the TS_DRAG style, a cursor ID may be specified
// for the can't-drop state.  If not specified, the generic slashed-O
// cursor is used.
//
/******************************************************************************/

class CTool : public CObject
    {
    public: /*****************************************************************/
    CToolboxWnd* m_pOwner;
    WORD         m_wID;
    int          m_nImage; // index into parent's image well

    WORD         m_wState;
    WORD         m_wStyle;

    CTool(CToolboxWnd* pOwner, WORD wID, int nImage,
                      WORD wStyle = 0, WORD wState = 0);
    };

/******************************************************************************/
// CToolboxWnd:
// This is a typical mini-frame window, filled with an array of special
// buttons of the CTool class (above).  Direct access to this CObArray is
// allowed with the GetTools member function.
//
// After directly manipulating the tool array (adding, removing or modifying
// tools), use the Invalidate member function to repaint the window with the
// new state.
//
/******************************************************************************/

#ifdef CUSTOMFLOAT
class CDocking;
#endif

class CToolboxWnd : public CControlBar
    {
    DECLARE_DYNAMIC(CToolboxWnd)

    private:    /**************************************************************/

    CBitmap*    m_bmStuck;
    CBitmap*    m_bmPushed;
    CBitmap*    m_bmPopped;
    CTool*      m_tCapture;
    BOOL        m_bInside;
    CRect       m_lasttool;
    HCURSOR     m_oldcursor;
    CTool*      m_pLastHot;
    CRect       m_rectLastHot;
    HTHEME      m_hTheme;

    CObArray*   m_Tools;
    CPoint      m_downpt;            // "click down point" for drag debounce -gh

#ifdef CUSTOMFLOAT
    CDocking*   m_pDocking;
#endif

    protected:  /**************************************************************/

    CTool* ToolFromPoint(CRect* rect, CPoint* pt) const;
    void   SizeByButtons(int nButtons = -1, BOOL bRepaint = FALSE);
    BOOL   DrawStockBitmaps();

    WORD        m_wWide;
    CPoint     m_btnsize;
    CImageWell m_imageWell;
    CRect      m_rcTools;
    int        m_nOffsetX;
    int        m_nOffsetY;

    public:     /**************************************************************/

    static const POINT NEAR ptDefButton;

    CToolboxWnd();
    ~CToolboxWnd();

    virtual BOOL Create(const TCHAR FAR* lpWindowName,
                        DWORD dwStyle, const RECT& rect,
                        const POINT& btnsize = ptDefButton, WORD wWide = 1,
                        CWnd* pParentWnd = NULL, int nImageWellID = 0);
    virtual BOOL OnCommand(UINT wParam, LONG lParam);
    virtual UINT OnCmdHitTest ( CPoint point, CPoint* pCenter );
    virtual BOOL SetStatusText(int nHit);

    int  HitTestToolTip( CPoint point, UINT* pHit );

    void AddTool(CTool* tool);
    void RemoveTool(CTool* tool);
    WORD SetToolState(WORD wID, WORD wState);
    WORD SetToolStyle(WORD wID, WORD wStyle);
    void SelectTool(WORD wid);
    WORD CurrentToolID();
    CTool* GetTool(WORD wID);
    void DrawButtons(CDC& dc, RECT* rcPaint);

    inline int GetToolCount() { return (int)m_Tools->GetSize(); }
    inline CTool* GetToolAt(int nTool) { return (CTool*)m_Tools->GetAt(nTool); }

    void CancelDrag();

    afx_msg void OnSysColorChange();
    afx_msg void OnPaint();
    afx_msg void OnLButtonDown(UINT wFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT wFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT wFlags, CPoint point);
    afx_msg void OnMouseMove(UINT wFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT wFlags, CPoint point);
    afx_msg void OnClose();
    afx_msg void OnDestroy();
    afx_msg void OnWinIniChange(LPCTSTR lpSection);
    afx_msg void OnKeyDown(UINT, UINT, UINT);
    afx_msg LONG OnToolDown(UINT wID, LONG lParam);
    afx_msg LONG OnToolUp(UINT wID, LONG lParam);
    afx_msg LRESULT OnThemeChanged(WPARAM, LPARAM);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
//  afx_msg LONG OnSwitch(UINT wID, LONG point);

//  virtual BOOL BeginDragDrop( CTool* pTool, CPoint pt );

    DECLARE_MESSAGE_MAP()
    };

/******************************************************************************/

class CImgToolWnd : public CToolboxWnd
    {
    public:     /**************************************************************/

    CRect        m_rcBrushes;

    virtual BOOL Create(const TCHAR* pWindowName, DWORD dwStyle,
                        const RECT& rect, const POINT& btnSize, WORD wWide,
                        CWnd* pParentWnd, BOOL bDkRegister = TRUE);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

    BOOL PreTranslateMessage(MSG* pMsg);

    afx_msg void  OnSysColorChange();
    afx_msg BOOL  OnEraseBkgnd(CDC* pDC);
    afx_msg void  OnLButtonDown(UINT nFlags, CPoint pt);
    afx_msg void  OnLButtonDblClk(UINT nFlags, CPoint pt);
    afx_msg void  OnRButtonDown(UINT nFlags, CPoint pt);
    afx_msg void  OnPaint();
    afx_msg UINT  OnNcHitTest(CPoint point);

	virtual int   OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
    virtual CSize GetSize();
    virtual WORD  GetHelpOffset() { return ID_WND_GRAPHIC; }
    virtual void  OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

    void InvalidateOptions(BOOL bErase = TRUE);
    friend class CImgColorsWnd;

#ifdef _DEBUG
    virtual void AssertValid() const
    {
	    CWnd::AssertValid();
    }
#endif //_DEBUG

    DECLARE_MESSAGE_MAP();
    };


/******************************************************************************/

#ifdef CUSTOMFLOAT
class CFloatImgToolWnd : public CMiniFrmWnd
    {
    DECLARE_DYNAMIC(CFloatImgToolWnd)

    public:     /**************************************************************/

    virtual ~CFloatImgToolWnd(void);
    virtual BOOL Create(const TCHAR* pWindowName, DWORD dwStyle,
                        const RECT& rect, const POINT& btnSize, WORD wWide,
                        CWnd* pParentWnd, BOOL bDkRegister = TRUE);
    virtual WORD GetHelpOffset() { return ID_WND_GRAPHIC; }
    afx_msg void OnSysColorChange();
    afx_msg void OnClose();

    DECLARE_MESSAGE_MAP()

    };
#endif //CUSTOMFLOAT

/***************************************************************************/

extern CImgToolWnd* NEAR g_pImgToolWnd;

#endif // __TOOLBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\thumnail.cpp ===
/******************************************************************************/
/* THUMNAIL.CPP: IMPLEMENTATION OF THE CThumbNailView and CFloatThumNailView  */
/*               and CFullScreenThumbNailView Classes                         */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  CThumbNailView Class Object                                               */
/*     CThumbNailView::CThumbNailView                                         */
/*     CThumbNailView::CThumbNailView                                         */
/*     CThumbNailView::~CThumbNailView                                        */
/*     CThumbNailView::Create                                                 */
/*     CThumbNailView::OnSize                                                 */
/*     CThumbNailView::OnPaint                                                */
/*     CThumbNailView::DrawImage                                              */
/*     CThumbNailView::DrawTracker                                            */
/*     CThumbNailView::RefreshImage                                           */
/*     CThumbNailView::GetImgWnd                                              */
/*     CThumbNailView::OnKeyDown                                              */
/*     CThumbNailView::OnLButtonDown                                          */
/*     CThumbNailView::OnRButtonDown                                          */
/*     CThumbNailView::OnThumbnailThumbnail                                   */
/*     CThumbNailView::OnUpdateThumbnailThumbnail                             */
/*                                                                            */
/*  CFloatThumbNailView Class Object                                          */
/*     CFloatThumbNailView::CFloatThumbNailView                               */
/*     CFloatThumbNailView::~CFloatThumbNailView                              */
/*     CFloatThumbNailView::Create                                            */
/*     CFloatThumbNailView::OnClose                                           */
/*     CFloatThumbNailView::OnSize                                            */
/*                                                                            */
/*  CFullScreenThumbNailView Class Object                                     */
/*     CFullScreenThumbNailView::CFullScreenThumbNailView                     */
/*     CFullScreenThumbNailView::CFullScreenThumbNailView                     */
/*     CFullScreenThumbNailView::~CFullScreenThumbNailView                    */
/*     CFullScreenThumbNailView::Create                                       */
/*     CFullScreenThumbNailView::OnLButtonDown                                */
/*     CFullScreenThumbNailView::OnKeyDown                                    */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/*  These 3 objects provide a layer around the thumbnail view window, which   */
/*  allow it to easily be a child, floating or a full screen. The ThumbNail   */
/*  View Window is just a CWnd Window which on paints does a BitBlt from the  */
/*  CImgWnd it was passsed on construction.                                   */
/*                                                                            */
/*  The structure of the objects is as follows:                               */
/*                                                                            */
/*  CFullScreenThumbNailView is a Frame Window  (with no border and sized to  */
/*      full screen).  It destroys itself on any keystroke or button click     */
/*      while visible, it dissables the main application window.  It contains */
/*      a CThumbNailView object as a child window.                            */
/*                                                                            */
/*  CFloatThumbNailView is a MiniFrame Window                                 */
/*     CThumbNailView is a Child Window (which is sizable) A child of the     */
/*                    the CFloatThumbNailView window.  This can be created    */
/*                    independent if a floating window is not desired (i.e.   */
/*                    for the docked view). It is this window which has the   */
/*                    image drawn into it.                                    */
/*                                                                            */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "minifwnd.h"
#include "docking.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgcolor.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "imgtools.h"
#include "imgwnd.h"
#include "thumnail.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CThumbNailView, CWnd)
IMPLEMENT_DYNAMIC(CFloatThumbNailView, CMiniFrmWnd)
IMPLEMENT_DYNAMIC(CFullScreenThumbNailView, CFrameWnd)


#include "memtrace.h"

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

BEGIN_MESSAGE_MAP(CThumbNailView, CWnd)
    //{{AFX_MSG_MAP(CThumbNailView)
    ON_WM_PAINT()
    ON_WM_KEYDOWN()
    ON_WM_LBUTTONDOWN()
    ON_WM_RBUTTONDOWN()
    ON_COMMAND(ID_THUMBNAIL_THUMBNAIL, OnThumbnailThumbnail)
    ON_UPDATE_COMMAND_UI(ID_THUMBNAIL_THUMBNAIL, OnUpdateThumbnailThumbnail)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CThumbNailView::CThumbNailView(CImgWnd *pcImgWnd)
    {
    m_pcImgWnd = pcImgWnd;
    }

/******************************************************************************/

CThumbNailView::CThumbNailView()
    {
    m_pcImgWnd = NULL;
    }

/******************************************************************************/

CThumbNailView::~CThumbNailView(void)
    {
    }

/******************************************************************************/

BOOL CThumbNailView::Create(DWORD dwStyle, CRect cRectWindow, CWnd *pcParentWnd)
    {
    return( CWnd::Create(NULL, TEXT(""), dwStyle, cRectWindow, pcParentWnd, NULL) );
    }

/***************************************************************************/

void CThumbNailView::OnClose()
    {
    ShowWindow(SW_HIDE);
    }

/******************************************************************************/

void CThumbNailView::OnPaint()
    {
    CPaintDC dc(this); // device context for painting

    // TODO: Add your message handler code here

#ifdef USE_MIRRORING
    //
    // Disable RTL mirroring on full screen window
    //
    if (PBGetLayout(dc.GetSafeHdc()) & LAYOUT_RTL)
    {
        PBSetLayout(dc.GetSafeHdc(), 0);
    }
#endif

    // Do not call CWnd::OnPaint() for painting messages
    DrawImage(&dc);
    }

/******************************************************************************/

void CThumbNailView::DrawImage(CDC* pDC)
    {
    /*
    **  when there is nothing to do, then don't do it
    */
    if (! theApp.m_bShowThumbnail || m_pcImgWnd         == NULL
                                  || m_pcImgWnd->m_pImg == NULL )
        return;

    CRect crectClient;
    int   iMinWidth;
    int   iMinHeight;
    int   iLeft;
    int   iTop;

    CSize cSizeScrollPos = m_pcImgWnd->GetScrollPos();

    cSizeScrollPos.cx = abs( cSizeScrollPos.cx ) - CTracker::HANDLE_SIZE;
    cSizeScrollPos.cy = abs( cSizeScrollPos.cy ) - CTracker::HANDLE_SIZE;

    GetClientRect(crectClient);

    // find the smaller of the two the real image or the thumbnail window.

    iMinWidth  = min( crectClient.Width() , m_pcImgWnd->m_pImg->cxWidth  );
    iMinHeight = min( crectClient.Height(), m_pcImgWnd->m_pImg->cyHeight );

    if (crectClient.Width() >= m_pcImgWnd->m_pImg->cxWidth)
        {
        iLeft = 0; // can fit the whole image width into the thumbnail
        }
    else // image width greater than thumbnail width
        {
        // does thumbnail extend past end if started at scroll pos?
        if (cSizeScrollPos.cx + crectClient.Width() > m_pcImgWnd->m_pImg->cxWidth)
            {
            iLeft = cSizeScrollPos.cx - ( (cSizeScrollPos.cx
                                          + crectClient.Width()
                                          - m_pcImgWnd->m_pImg->cxWidth));
            }
        else
            {
            iLeft = cSizeScrollPos.cx;
            }
        }

    if (crectClient.Height() >= m_pcImgWnd->m_pImg->cyHeight)
        {
        iTop = 0; // can fit the whole image height into the thumbnail
        }
    else // image height greater than thumbnail height
        {
        // does thumbnail extend past bottom if started at scroll pos?
        if (cSizeScrollPos.cy + crectClient.Height() > m_pcImgWnd->m_pImg->cyHeight)
            {
            iTop = cSizeScrollPos.cy - ( (cSizeScrollPos.cy
                                          + crectClient.Height()
                                          - m_pcImgWnd->m_pImg->cyHeight));
            }
        else
            {
            iTop = cSizeScrollPos.cy;
            }
        }

    CDC cDC;
    cDC.Attach(m_pcImgWnd->m_pImg->hDC);

    CPalette* ppalOldSrc = theImgBrush.SetBrushPalette(&cDC, FALSE);
    CPalette* ppalOldDst = theImgBrush.SetBrushPalette( pDC, FALSE);

    pDC->BitBlt(0, 0, iMinWidth, iMinHeight,
                &cDC, iLeft, iTop, SRCCOPY);

    if (ppalOldDst)
    {
        pDC->SelectPalette(ppalOldDst, FALSE);
    }
    if (ppalOldSrc)
    {
        cDC.SelectPalette(ppalOldSrc, FALSE);
    }

    cDC.Detach();

    DrawTracker(pDC);
    }

/******************************************************************************/
/* basically the same processing as the imgwnd::drawtracker method, without   */
/* the zoom */

void CThumbNailView::DrawTracker(CDC *pDC)
    {
//  BOOL bDrawTrackerRgn = FALSE;

    if (m_pcImgWnd->GetCurrent() != m_pcImgWnd
    ||  theImgBrush.m_bMoveSel
    ||  theImgBrush.m_bSmearSel
    ||  theImgBrush.m_bMakingSelection)
        {
        // This is not the active view, or the user is doing something
        // to prevent the tracker from appearing.
        return;
        }

    BOOL bReleaseDC = FALSE;
    CRect clientRect;

    if (pDC == NULL)
        {
        pDC = GetDC();

        if (pDC == NULL)
            {
            theApp.SetGdiEmergency(FALSE);
            return;
            }
        bReleaseDC = TRUE;
        }

    GetClientRect(&clientRect);

    CRect trackerRect;

    m_pcImgWnd->GetImageRect(trackerRect);

    trackerRect.InflateRect(CTracker::HANDLE_SIZE, CTracker::HANDLE_SIZE);

    CTracker::EDGES edges = (CTracker::EDGES)(CTracker::right | CTracker::bottom);

//  if (CImgTool::GetCurrentID() == IDMB_PICKRGNTOOL)
//      {
//      bDrawTrackerRgn = TRUE;
//      }

    if (m_pcImgWnd->m_pImg == theImgBrush.m_pImg)
        {
        edges = CTracker::all;
        CSize cSzScroll = m_pcImgWnd->GetScrollPos();

        trackerRect = theImgBrush.m_rcSelection;

//      trackerRect.InflateRect( CTracker::HANDLE_SIZE,
//                               CTracker::HANDLE_SIZE);
        trackerRect.OffsetRect(  cSzScroll.cx, cSzScroll.cy);

        }

    if (m_pcImgWnd->m_pImg == theImgBrush.m_pImg)
        {
//      if (bDrawTrackerRgn)
//          {
//          CTracker::DrawBorderRgn( pDC, trackerRect, &(theImgBrush.m_cRgnPolyFreeHandSel) );
//          }
//      else
//          {
            CTracker::DrawBorder( pDC, trackerRect );
//          }
        }

    if (bReleaseDC)
        {
        ReleaseDC(pDC);
        }
    }

/******************************************************************************/
/* Basically Do a paint without an erase background to prevent blinking       */

void CThumbNailView::RefreshImage(void)
    {
    if (theApp.m_bShowThumbnail)
        {
        TRY
            {
            CClientDC dc(this);
            DrawImage(&dc);
            }
        CATCH(CResourceException,e)
            {
            }
        END_CATCH
        }
    }

/******************************************************************************/

CImgWnd* CThumbNailView::GetImgWnd(void)
    {
    return m_pcImgWnd;
    }

/******************************************************************************/

void CThumbNailView::UpdateThumbNailView()
    {
    CPBView* pcbActiveView = (CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView();

    m_pcImgWnd = pcbActiveView->m_pImgWnd;
    }

/******************************************************************************/

void CThumbNailView::OnKeyDown(UINT /*nChar*/, UINT /*nRepCnt*/, UINT /*nFlags*/)
    {
    const MSG* pmsg = GetCurrentMessage();

    GetParent()->SendMessage( pmsg->message, pmsg->wParam, pmsg->lParam );
    }

/******************************************************************************/

void CThumbNailView::OnLButtonDown(UINT /*nFlags*/, CPoint /*point*/)
    {
    const MSG* pmsg = GetCurrentMessage();

    GetParent()->SendMessage(pmsg->message, pmsg->wParam, pmsg->lParam);
    }

/******************************************************************************/

void CThumbNailView::OnRButtonDown(UINT /*nFlags*/, CPoint point)
    {
    HWND  hwnd = GetSafeHwnd();  // must do this before calling SendMsg to parent, since it could delete us,
    const MSG* pmsg = GetCurrentMessage();

    GetParent()->SendMessage(pmsg->message, pmsg->wParam, pmsg->lParam);
    // the window is destroyed by the parent if FullScreenView

    if (::IsWindow(hwnd) != FALSE)  // window still exists => object still valid, put up pop up menu.
        {
        CMenu cMenuPopup;
        CMenu *pcContextMenu;
        BOOL  bRC;
        CRect cRectClient;

        GetClientRect(&cRectClient);

        bRC = cMenuPopup.LoadMenu( IDR_THUMBNAIL_POPUP );

        ASSERT(bRC != 0);

        if (bRC != 0)
            {
            pcContextMenu = cMenuPopup.GetSubMenu(0);

            ASSERT(pcContextMenu != NULL);

            if (pcContextMenu != NULL)
                {
                // update the check marks
                ClientToScreen(&point);
                ClientToScreen(&cRectClient);
                pcContextMenu->CheckMenuItem(ID_THUMBNAIL_THUMBNAIL, MF_BYCOMMAND | MF_CHECKED);
                pcContextMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, &cRectClient);
                }
            }
        }
    }

/******************************************************************************/

void CThumbNailView::OnThumbnailThumbnail()
    {
    CPBView* pView = (CPBView*)(((CFrameWnd*)AfxGetMainWnd())->GetActiveView());

    if (pView != NULL && pView->IsKindOf( RUNTIME_CLASS( CPBView ) ))
        pView->HideThumbNailView();
    }

/******************************************************************************/

void CThumbNailView::OnUpdateThumbnailThumbnail(CCmdUI* pCmdUI)
    {
    pCmdUI->SetCheck();
    }

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

BEGIN_MESSAGE_MAP(CFloatThumbNailView, CMiniFrmWnd)
    //{{AFX_MSG_MAP(CFloatThumbNailView)
    ON_WM_CLOSE()
    ON_WM_SIZE()
        ON_WM_GETMINMAXINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CFloatThumbNailView::CFloatThumbNailView(CImgWnd *pcMainImgWnd)
    {
    m_pcThumbNailView = new CThumbNailView(pcMainImgWnd);

    if (m_pcThumbNailView == NULL)
        {
        theApp.SetMemoryEmergency();
        TRACE( TEXT("New Thumbnail View faild\n") );
        }
    }

/******************************************************************************/

CFloatThumbNailView::CFloatThumbNailView()
    {
    m_pcThumbNailView = NULL;
    }

/******************************************************************************/

CFloatThumbNailView::~CFloatThumbNailView(void)
    {
    }

/******************************************************************************/

BOOL CFloatThumbNailView::Create(CWnd* pParentWnd)
    {
    BOOL bRC;
    CRect cWindowRect;

    pParentWnd->GetWindowRect( &cWindowRect );

    cWindowRect.BottomRight() = cWindowRect.TopLeft();
    cWindowRect.right   += 120;
    cWindowRect.bottom  += 120;
    cWindowRect.OffsetRect( 15, 15 );

    if (! theApp.m_rectFloatThumbnail.IsRectEmpty())
        {
        cWindowRect = theApp.m_rectFloatThumbnail;
        }

    CString pWindowName;

    pWindowName.LoadString( IDS_VIEW );

    bRC = CMiniFrmWnd::Create( pWindowName, WS_THICKFRAME, cWindowRect, pParentWnd );

    if (bRC)
        {
        ASSERT( m_pcThumbNailView );

        GetClientRect( &cWindowRect );

        if (!m_pcThumbNailView->Create( WS_CHILD | WS_VISIBLE, cWindowRect, this ))
            {
            bRC = FALSE;
            theApp.SetMemoryEmergency();
            TRACE( TEXT("New Thumbnail View faild\n") );
            }
        }

    GetWindowRect( &theApp.m_rectFloatThumbnail );

    return bRC;
    }

/******************************************************************************/
// OnClose
//
// A Colorsbox is usally created by the parent, and will be destroyed
// specifically by the parent upon leaving the app.  When the user closes
// the Colorsbox, it is simply hidden.  The parent can then reshow it without
// recreating it.
//
void CFloatThumbNailView::OnClose()
    {
    theApp.m_bShowThumbnail = FALSE;

    ShowWindow(SW_HIDE);
    }

/******************************************************************************/

void CFloatThumbNailView::PostNcDestroy()
    {
    if (m_pcThumbNailView != NULL)
        {
        delete m_pcThumbNailView;
        m_pcThumbNailView = NULL;
        }

    CWnd::PostNcDestroy();
    }

/******************************************************************************/

void CFloatThumbNailView::OnSize(UINT nType, int cx, int cy)
    {
    CMiniFrmWnd::OnSize(nType, cx, cy);

    if (m_pcThumbNailView                != NULL
    &&  m_pcThumbNailView->GetSafeHwnd() != NULL)
        {
        m_pcThumbNailView->SetWindowPos( &wndTop, 0, 0, cx, cy, SWP_NOACTIVATE );
        }

    theApp.m_rectFloatThumbnail.right  = theApp.m_rectFloatThumbnail.left + cx;
    theApp.m_rectFloatThumbnail.bottom = theApp.m_rectFloatThumbnail.top  + cy;
    }

/******************************************************************************/

void CFloatThumbNailView::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
    {
    lpMMI->ptMinTrackSize.x = 2 * GetSystemMetrics( SM_CXICON );
    lpMMI->ptMinTrackSize.y = 2 * GetSystemMetrics( SM_CYICON );

    CWnd::OnGetMinMaxInfo( lpMMI );
    }

/******************************************************************************/
/******************************************************************************/
/******************************************************************************/

BEGIN_MESSAGE_MAP(CFullScreenThumbNailView, CFrameWnd)
    //{{AFX_MSG_MAP(CFullScreenThumbNailView)
    ON_WM_LBUTTONDOWN()
    ON_WM_KEYDOWN()
    ON_WM_RBUTTONDOWN()
    ON_WM_ERASEBKGND()
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************/

CFullScreenThumbNailView::CFullScreenThumbNailView(CImgWnd *pcMainImgWnd)
    {
    m_bSaveShowFlag = theApp.m_bShowThumbnail;
    theApp.m_bShowThumbnail = TRUE;


//  m_brBackground.CreateSolidBrush( ::GetSysColor( COLOR_BACKGROUND ) );

    m_pcThumbNailView = new CThumbNailView(pcMainImgWnd);

    if (m_pcThumbNailView == NULL)
        {
        theApp.SetMemoryEmergency();
        TRACE( TEXT("New Thumbnail View faild\n") );
        }
    }

/******************************************************************************/

CFullScreenThumbNailView::CFullScreenThumbNailView()
    {
    m_hOldIcon = 0;
    m_pcThumbNailView = NULL;
    }

/******************************************************************************/

CFullScreenThumbNailView::~CFullScreenThumbNailView(void)
    {
    if (m_hOldIcon)
    {
       SetClassLongPtr (((CFrameWnd*)this)->GetSafeHwnd(), GCLP_HICON, (LONG_PTR)m_hOldIcon);
    }
    if (m_pcThumbNailView != NULL)
        {
        delete m_pcThumbNailView;

        theApp.m_bShowThumbnail = m_bSaveShowFlag;
        }
//  if (m_brBackground.m_hObject != NULL)
//      m_brBackground.DeleteObject();
    }

/******************************************************************************/

BOOL CFullScreenThumbNailView::Create(LPCTSTR szCaption)
    {
    ASSERT( m_pcThumbNailView );
    TCHAR szFileName[MAX_PATH];
    HICON hIcon;

    CRect cWindowRect( 0, 0, ::GetSystemMetrics( SM_CXSCREEN ),
                             ::GetSystemMetrics( SM_CYSCREEN ) );
    //
    // Use the current file name as the caption of the window so
    // it shows up in alt-tab
    if (szCaption && *szCaption)
    {
       GetFileTitle (szCaption, szFileName, MAX_PATH);
    }
    else
    {
       LoadString (GetModuleHandle (NULL), AFX_IDS_UNTITLED, szFileName, MAX_PATH);
    }

    BOOL bRC = CFrameWnd::Create( NULL, szFileName,  WS_POPUP|WS_VISIBLE | WS_CLIPCHILDREN,
                                                                       cWindowRect );
    //
    // This window needs a Paint icon instead of a boring icon
    // So set the class's icon to the Paint icon
    // We want alt-tab to work decently
    hIcon = LoadIcon (GetModuleHandle (NULL), MAKEINTRESOURCE(ID_MAINFRAME));
    m_hOldIcon = SetClassLongPtr (((CFrameWnd*)this)->GetSafeHwnd(), GCLP_HICON, (LONG_PTR)hIcon);

    if (bRC)
        {
        ASSERT( m_pcThumbNailView );

        AfxGetMainWnd()->EnableWindow( FALSE );

        CImgWnd* pcImgWnd = m_pcThumbNailView->GetImgWnd();

        if (pcImgWnd != NULL)
            {
            // find the smaller of the two the real image or the full screen window size.
            int iMinWidth  = min( cWindowRect.Width(),  pcImgWnd->m_pImg->cxWidth  );
            int iMinHeight = min( cWindowRect.Height(), pcImgWnd->m_pImg->cyHeight );

            // center the image in the full screen window.
            cWindowRect.left   =  (cWindowRect.Width()  - iMinWidth)  / 2;
            cWindowRect.top    =  (cWindowRect.Height() - iMinHeight) / 2;
            cWindowRect.right  =   cWindowRect.left     + iMinWidth;
            cWindowRect.bottom =   cWindowRect.top      + iMinHeight;

            m_pcThumbNailView->Create( WS_CHILD | WS_VISIBLE, cWindowRect, this );
            }
        }

    return bRC;
    }

/******************************************************************************/

BOOL CFullScreenThumbNailView::OnEraseBkgnd( CDC* pDC )
    {
    CBrush* pbr = GetSysBrush( COLOR_BACKGROUND );

//  if (m_brBackground.m_hObject == NULL)
    if (! pbr)
            return CFrameWnd::OnEraseBkgnd( pDC );

    CRect cRectClient;

    GetClientRect( &cRectClient );
    pDC->FillRect( &cRectClient, pbr /* &m_brBackground */ );

    return TRUE;
    }


/******************************************************************************/
void CFullScreenThumbNailView::OnLButtonDown(UINT /*nFlags*/, CPoint /*point*/)
    {
    PostMessage (WM_CLOSE, 0, 0);
    }

/******************************************************************************/

void CFullScreenThumbNailView::OnKeyDown(UINT /*nChar*/, UINT /*nRepCnt*/, UINT /*nFlags*/)
    {
    PostMessage (WM_CLOSE, 0, 0);
    }

/******************************************************************************/


void CFullScreenThumbNailView::OnClose ()
    {
    AfxGetMainWnd()->EnableWindow( TRUE );
    ::DestroyWindow( m_hWnd );
    }
/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\toolbox.cpp ===
/******************************************************************************/
/*                                                                            */
/* Class Implementations in this file                                         */
/*      CFloatImgToolWnd                                                      */
/*      CImgToolWnd                                                           */
/*      CToolboxWnd                                                           */
/*      CTool                                                                 */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "ipframe.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "imgtools.h"
#include "toolbox.h"
#include "imgcolor.h"
#include "docking.h"
#include "t_Text.h"

#define TRYANYTHING

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CToolboxWnd, CControlBar)

#include "memtrace.h"

CImgToolWnd* NEAR g_pImgToolWnd = NULL;

#define BPR(br, rop)        \
 { dc.SelectObject((br));   \
   dc.PatBlt(rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, rop); }

#define iidmMac ( sizeof (rgidm) / sizeof (rgidm[0]) )

static UINT NEAR rgidm [] =
    {
    IDMB_PICKRGNTOOL,
    IDMB_PICKTOOL,

    IDMB_ERASERTOOL,
    IDMB_FILLTOOL,

    IDMY_PICKCOLOR,
    IDMB_ZOOMTOOL,

    IDMB_PENCILTOOL,
    IDMB_CBRUSHTOOL,

    IDMB_AIRBSHTOOL,
    IDMX_TEXTTOOL,

    IDMB_LINETOOL,
    IDMB_CURVETOOL,

    IDMB_RECTTOOL,
    IDMB_POLYGONTOOL,

    IDMB_ELLIPSETOOL,
    IDMB_RNDRECTTOOL
    };

/******************************************************************************/

BEGIN_MESSAGE_MAP(CImgToolWnd, CToolboxWnd)
        ON_WM_SYSCOLORCHANGE()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_RBUTTONDOWN()
    ON_WM_PAINT()
    ON_WM_KEYDOWN()
    ON_WM_KEYUP()
    ON_WM_CHAR()
    ON_WM_NCHITTEST()
END_MESSAGE_MAP()


/******************************************************************************/

HTHEME SafeOpenThemeData(HWND hwnd, LPCWSTR pszClassList)
    {
    __try
        {
        return OpenThemeData(hwnd, pszClassList);
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
        return 0;
        }
    }

/******************************************************************************/

BOOL CImgToolWnd::Create(const TCHAR* pWindowName, DWORD dwStyle,
                         const RECT& rect, const POINT& btnSize, WORD wWide,
                         CWnd* pParentWnd, BOOL bDkRegister)
    {
    if (! CToolboxWnd::Create( pWindowName, dwStyle, rect,
                               btnSize, NUM_TOOLS_WIDE, pParentWnd, IDB_IMGTOOLS ))
        {
        return FALSE;
        }

    for (int iidm = 0; iidm < iidmMac; iidm += 1)
        {
        CTool* pTool = new CTool(this, (WORD)rgidm[iidm], iidm, TS_CMD | TS_STICKY,
                rgidm[iidm] == CImgTool::GetCurrentID() ? TF_DOWN : 0);

        if (pTool == NULL)
            {
            DestroyWindow();
            return FALSE;
            }
        AddTool(pTool);

        }


    m_nOffsetX = m_btnsize.x / 5;
    m_nOffsetY = m_btnsize.y / 5;

    CSize size = GetSize();

    MoveWindow( rect.left, rect.top, size.cx, size.cy );

    return TRUE;
    }


/******************************************************************************/
//

void CImgToolWnd::OnSysColorChange()
        {
        CToolboxWnd::OnSysColorChange();
        InvalidateRect(NULL, FALSE);
        }

/******************************************************************************/

int CImgToolWnd::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
    {
    CRect rect;

    CTool* pTool = ToolFromPoint( &rect, &point );

	if (pTool != NULL)
	    {
		int nHit = pTool->m_wID;

		if (pTI != NULL)
		    {
			pTI->hwnd     = m_hWnd;
            pTI->uId      = nHit;
            pTI->rect     = rect;
			pTI->lpszText = LPSTR_TEXTCALLBACK;
		    }

		return nHit;
	    }

	return -1;  // not found
    }

/******************************************************************************/

void CImgToolWnd::OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler )
    {
    }

/******************************************************************************/

CSize CImgToolWnd::CalcFixedLayout( BOOL bStretch, BOOL bHorz )
    {
#ifdef TRYANYTHING
        return GetSize();
#else
    CSize size = CControlBar::CalcFixedLayout( bStretch, bHorz );

    CSize sizeBar = GetSize();

    size.cx = sizeBar.cx;
    return size;
#endif
    }

/******************************************************************************/

UINT CImgToolWnd::OnNcHitTest(CPoint point)
    {
    return CToolboxWnd::OnNcHitTest(point);
    }

/******************************************************************************/

CSize CImgToolWnd::GetSize()
    {
    // Leave room in the toolbox for the brushes...
    CRect clientRect;
    CRect windowRect;
    CSize sizeDiff;

    GetWindowRect( &windowRect );
    GetClientRect( &clientRect );

    sizeDiff = windowRect.Size() - clientRect.Size();
    int nTools = GetToolCount();

    clientRect.right  = m_btnsize.x * NUM_TOOLS_WIDE + m_nOffsetX * 2;
    clientRect.bottom = (nTools / NUM_TOOLS_WIDE + (!!(nTools % NUM_TOOLS_WIDE)))
                                          * m_btnsize.y + m_nOffsetY * 2;

    m_rcTools.left   = m_nOffsetX;
    m_rcTools.top    = m_nOffsetY;
    m_rcTools.right  = clientRect.right - m_nOffsetX;
    m_rcTools.bottom = clientRect.bottom - m_nOffsetY;

    m_rcBrushes.left   = clientRect.left   + (4 + m_nOffsetX);
    m_rcBrushes.top    = clientRect.bottom;
    m_rcBrushes.right  = clientRect.right  - (4 + m_nOffsetX);
    m_rcBrushes.bottom = clientRect.bottom + 66;

    clientRect.bottom += m_rcBrushes.Height() + m_nOffsetY;

    return clientRect.Size() + sizeDiff;
    }

/******************************************************************************/

void CImgToolWnd::OnLButtonDown(UINT nFlags, CPoint pt)
    {
    BOOL bInBrushes = m_rcBrushes.PtInRect(pt);

    if (bInBrushes)
        {
        CRect optionsRect = m_rcBrushes;

        optionsRect.InflateRect(-1, -1);
        pt -= (CSize)optionsRect.TopLeft();

        CImgTool::GetCurrent()->OnClickOptions(this, optionsRect, pt);
        }
    else
        CToolboxWnd::OnLButtonDown(nFlags, pt);
    }

/******************************************************************************/

void CImgToolWnd::InvalidateOptions(BOOL bErase)
    {
    // NOTE: bErase is now ignored since we do drawing off-screen and
    // blt the whole thing...

    CRect optionsRect = m_rcBrushes;
    optionsRect.InflateRect(-1, -1);

    InvalidateRect(&optionsRect, FALSE);
    }

/******************************************************************************/

void CImgToolWnd::OnLButtonDblClk(UINT nFlags, CPoint pt)
    {
    CToolboxWnd::OnLButtonDblClk(nFlags, pt);
    }

/******************************************************************************/

void CImgToolWnd::OnRButtonDown(UINT nFlags, CPoint pt)
    {
    CToolboxWnd::OnRButtonDown(nFlags, pt);
    }

/******************************************************************************/

BOOL CImgToolWnd::OnEraseBkgnd( CDC* pDC )
    {
    CRect rect;
    GetClientRect( rect );
    pDC->FillRect( rect, GetSysBrush( COLOR_BTNFACE ) );

        return CControlBar::OnEraseBkgnd( pDC );
    }

/******************************************************************************/

void CImgToolWnd::OnPaint()
    {
    CPaintDC dc(this);

    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }

    if (CImgWnd::c_pImgWndCur == NULL)
        {
        // Chances are, we're are going to be hidden soon, so don't
        // bother painting...
        return;
        }

    DrawButtons(dc, &dc.m_ps.rcPaint);

    ASSERT(CImgWnd::c_pImgWndCur->m_pImg != NULL);

    // Brush Shapes
    if (!(m_rcBrushes & dc.m_ps.rcPaint).IsRectEmpty())
        {
        Draw3dRect(dc.m_hDC, &m_rcBrushes );
        CRect optionsRect = m_rcBrushes;
        optionsRect.InflateRect(-1, -1);

        CRect rc(0, 0, optionsRect.Width(), optionsRect.Height());
        CDC memDC;
        CBitmap memBM;

        if (!memDC.CreateCompatibleDC(&dc) ||
            !memBM.CreateCompatibleBitmap(&dc, rc.right, rc.bottom))
            {
            theApp.SetGdiEmergency();
            return;
            }
        CBitmap* pOldBitmap = memDC.SelectObject(&memBM);

        CBrush* pOldBrush = memDC.SelectObject(GetSysBrush( COLOR_BTNFACE ));

        memDC.PatBlt(0, 0, rc.right, rc.bottom, PATCOPY);

        CRect rcPaint = dc.m_ps.rcPaint;
        rcPaint.OffsetRect(-optionsRect.left, -optionsRect.top);

        CImgTool::GetCurrent()->OnPaintOptions(&memDC, rcPaint, rc);

        dc.BitBlt(optionsRect.left, optionsRect.top, optionsRect.Width(),
                  optionsRect.Height(), &memDC, 0, 0, SRCCOPY);

        memDC.SelectObject(pOldBitmap);
        memDC.SelectObject(pOldBrush);
        }
    }

/******************************************************************************/

BOOL CImgToolWnd::PreTranslateMessage(MSG* pMsg)
    {
    switch (pMsg->message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
            if (CImgWnd::c_pImgWndCur != NULL)
                {
                pMsg->hwnd = CImgWnd::c_pImgWndCur->m_hWnd;
                return CImgWnd::c_pImgWndCur->PreTranslateMessage(pMsg);
                }
            return FALSE;
        }

        return CToolboxWnd::PreTranslateMessage(pMsg);
    }

/******************************************************************************/
// default button size

const POINT NEAR CToolboxWnd::ptDefButton = { 26, 26 };

/*DK*/
BEGIN_MESSAGE_MAP(CToolboxWnd, CControlBar)
        ON_WM_SYSCOLORCHANGE()
    ON_WM_PAINT()
    ON_WM_LBUTTONDOWN()
    ON_WM_RBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_CLOSE()
    ON_WM_DESTROY()
    ON_WM_WININICHANGE()
    ON_WM_KEYDOWN()
    ON_MESSAGE(TM_TOOLDOWN, OnToolDown)
    ON_MESSAGE(TM_TOOLUP, OnToolUp)
    ON_MESSAGE(WM_THEMECHANGED, OnThemeChanged)
    /*DK*/
//  ON_MESSAGE(WM_HELPHITTEST, OnHelpHitTest)
END_MESSAGE_MAP()

/******************************************************************************/

CToolboxWnd::CToolboxWnd()
    {
    m_Tools    = new CObArray;
    m_bmStuck  = NULL;
    m_bmPushed = NULL;
    m_bmPopped = NULL;
    m_tCapture = NULL;
    m_bInside  = FALSE;
    m_nOffsetX = 0;
    m_nOffsetY = 0;
    m_pLastHot = 0;
    m_hTheme   = 0;
    }

/******************************************************************************/

CToolboxWnd::~CToolboxWnd()
    {
    if (m_bmStuck != NULL)
        delete m_bmStuck;

    if (m_bmPushed != NULL)
        delete m_bmPushed;

    if (m_bmPopped != NULL)
        delete m_bmPopped;

    if (m_Tools != NULL)
        {
        int nTools = (int)m_Tools->GetSize();

        for (int iTool = 0; iTool < nTools; iTool += 1)
            {
            CTool* pTool = (CTool*)m_Tools->GetAt(iTool);
            delete pTool;
            }

        delete m_Tools;
        }
    }

/******************************************************************************/

BOOL CToolboxWnd::Create(const TCHAR FAR* lpWindowName,
                         DWORD dwStyle, const RECT& rect,
                         const POINT& btnsize /* = ptDefButton */, WORD wWide /* = 1 */,
                         CWnd* pParentWnd /* = NULL */, int nImageWellID /* = 0 */)
    {
    // This routine is a lot more complicated than the typical Create, so
    // because (1) we aren't a built-in Windows window type, and (2) we
    // want to specify the client size with the btnsize and wWide parameters.
    // (We ignore the width, height of the rect parameter.)

    if (nImageWellID != 0 && !m_imageWell.Load(nImageWellID, CSize(16, 16)))
        return FALSE;

        // save the style
        m_dwStyle = (UINT)dwStyle | CBRS_TOOLTIPS | CBRS_FLYBY;

    DWORD dwS = (m_dwStyle & ~WS_VISIBLE);

    CRect t = rect;

    t.right  = t.left + 20;
    t.bottom = t.top  + 20;

    BOOL bRet = CControlBar::Create( NULL, lpWindowName, dwS, t, pParentWnd,
                                                         ID_VIEW_TOOL_BOX );
    if (! bRet)
        return FALSE;

    m_wWide   = wWide;
    m_btnsize = btnsize;

#ifdef TRYANYTHING
        SizeByButtons( -1, TRUE );
#else
    SizeByButtons( 0 );
#endif

    m_hTheme = SafeOpenThemeData(GetSafeHwnd(), L"toolbar");

    if (! DrawStockBitmaps())
        {
        DestroyWindow();
        return FALSE;
        }

    if (dwStyle & WS_VISIBLE)
        {
        ShowWindow(SW_SHOW);
        UpdateWindow();
        }

    return TRUE;
    }

/******************************************************************************/
// private DrawStockBitmaps:
// Draws the three states of button, given the desired button size of this
// CToolboxWnd.  These have no graphic on them; the buttons have bitmap
// glyphs to be added to these blank forms.
//
// The three states:
//   m_bmPopped  This is the normal look of a button.  Note that this is
//               also used as the basis of a grayed (disabled) button, by
//               changing how the button's glyph is drawn on it.
//   m_bmPushed  This is the button-down state for non-sticky tools (tools
//               that pop back out as soon as you let go.
//   m_bmStuck   This is the button-down state for sticky tools.  This has
//               a distinct look that is more easily visible, per UISG.
//

BOOL CToolboxWnd::DrawStockBitmaps()
    {
    CWindowDC wdc(this);
    if (wdc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency(TRUE);
        return FALSE;
        }

    CBitmap* obm;
    CBrush* obr;
    CRect rc;
    CDC dc;

    if (!dc.CreateCompatibleDC(&wdc))
        {
        theApp.SetGdiEmergency(TRUE);
        return FALSE;
        }

    obr = dc.SelectObject(GetSysBrush(COLOR_WINDOWFRAME));

    // bmPopped:
    //
    if (m_bmPopped)
        delete m_bmPopped;
    m_bmPopped = new CBitmap;
    if (!m_bmPopped->CreateCompatibleBitmap(&wdc, m_btnsize.x, m_btnsize.y))
        {
        theApp.SetMemoryEmergency(TRUE);
        return FALSE;
        }
    obm = dc.SelectObject(m_bmPopped);
    rc = CRect(0, 0, m_btnsize.x, m_btnsize.y);
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
#ifdef OLDBUTTONS
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
#endif
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNHIGHLIGHT), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);

    // bmPushed:
    //
    if (m_bmPushed)
        delete m_bmPushed;
    m_bmPushed = new CBitmap;
    if (!m_bmPushed->CreateCompatibleBitmap(&wdc, m_btnsize.x, m_btnsize.y))
        {
        theApp.SetMemoryEmergency(TRUE);
        return FALSE;
        }
    dc.SelectObject(m_bmPushed);
    rc = CRect(0, 0, m_btnsize.x, m_btnsize.y);
#ifndef OLDBUTTONS
    BPR(GetSysBrush(COLOR_BTNHIGHLIGHT), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
#else
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left += 2; rc.top += 2;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
#endif

    // bmStuck:
    //
    if (m_bmStuck)
        delete m_bmStuck;
    m_bmStuck = new CBitmap;
    if (!m_bmStuck->CreateCompatibleBitmap(&wdc, m_btnsize.x, m_btnsize.y))
        {
        theApp.SetMemoryEmergency(TRUE);
        return FALSE;
        }
    dc.SelectObject(m_bmStuck);
    rc = CRect(0, 0, m_btnsize.x, m_btnsize.y);
#ifndef OLDBUTTONS
    BPR(GetSysBrush(COLOR_BTNHIGHLIGHT), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.left++; rc.top++;
    BPR(GetSysBrush(COLOR_BTNFACE), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left++; rc.top++;
#else
    BPR(GetSysBrush(COLOR_WINDOWFRAME), PATCOPY);
    rc.right--; rc.bottom--;
    BPR(GetSysBrush(COLOR_BTNSHADOW), PATCOPY);
    rc.left += 2; rc.top += 2;
#endif

    dc.SelectObject(GetHalftoneBrush());
#ifdef OLDBUTTONS
    dc.SetTextColor(RGB(255, 255, 255));
    dc.SetBkColor(RGB(192, 192, 192));
#else
        dc.SetTextColor(GetSysColor(COLOR_BTNFACE));
        dc.SetBkColor(GetSysColor(COLOR_BTNHIGHLIGHT));
#endif
    dc.PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATCOPY);

    dc.SelectObject(obm);
    dc.SelectObject(obr);
    dc.DeleteDC();

    return TRUE;
    }

/******************************************************************************/
//

afx_msg void CToolboxWnd::OnSysColorChange()
        {
        CControlBar::OnSysColorChange();
        DrawStockBitmaps();
        InvalidateRect(NULL, FALSE);
        }

/******************************************************************************/
//
// SizeByButtons
//
// Sizes the window according to the current (or a specified) number of
// buttons.  If there are no buttons, the window makes room for one button.
// Unfilled button slots show through to the background.
//

void CToolboxWnd::SizeByButtons(int nButtons /* = -1 */,
                                BOOL bRepaint /* = FALSE */)
    {
    if (nButtons == -1)
        nButtons = (int)m_Tools->GetSize();
    if (nButtons == 0)
        nButtons = 1;

    // Can't use the hokey Windows' AdjustWindowRect() to work this out,
    // so we do it ourselves by adapting the window based on the difference
    // between GetWindowRect and ClientRect results.
    //
    CRect w, c;
    GetWindowRect(&w);
    w.right -= w.left;
    w.bottom -= w.top;
    GetClientRect(&c);

    if (bRepaint)
        Invalidate(TRUE);

    MoveWindow(w.left, w.top,
                m_btnsize.x * m_wWide + (w.right - c.right) - 1,
                m_btnsize.y * ((nButtons / m_wWide) + (!!(nButtons % m_wWide)))
                        + (w.bottom-c.bottom) - 1,
                bRepaint);
    }

/******************************************************************************/
// OnWinIniChange:
//
void CToolboxWnd::OnWinIniChange(LPCTSTR lpSection)

    {
        lpSection;
#ifdef TRYANYTHING
        CControlBar::OnWinIniChange( lpSection );
#endif
    DrawStockBitmaps();
    Invalidate(TRUE);
    }

/******************************************************************************/
//
// OnKeyDown
//
// Implements keyboard handling for the toolbox window.. this allows
// trapping of the ESC key, for moving the selected to back to the
// arrow.
//
void CToolboxWnd::OnKeyDown(UINT nKey, UINT nRepCnt, UINT nFlags)
    {
    if (nKey == VK_ESCAPE && m_tCapture)
        CancelDrag();
    else
        CControlBar::OnKeyDown(nKey, nRepCnt, nFlags);
    }

/******************************************************************************/

void CToolboxWnd::CancelDrag()
    {
#if 0
    // this is bogus as dragging is presently disabled
    if (m_tCapture != NULL)
        m_tCapture->m_wState |= TF_DRAG; // so select will cancel it
#endif

    m_bInside = FALSE;

#if 0
    // whoever tries to make drag/drop work will have to handle the fact
    // that our client does not get notified by SelectTool
    SelectTool( IDMB_ARROW );
#endif

    m_tCapture = NULL;
    ReleaseCapture();
    }

/******************************************************************************/
// AddTool:
//
void CToolboxWnd::AddTool(CTool* tool)
    {
    m_Tools->Add((CObject*)tool);

    if ((m_Tools->GetSize() + m_wWide - 1) / m_wWide > 11)  // only have 11 high if more increase the width
        m_wWide += 1;

    SizeByButtons(-1, TRUE);

    }


/******************************************************************************/
// RemoveTool:
//
void CToolboxWnd::RemoveTool(CTool* tool)
    {
    for (int nTool = GetToolCount() - 1; GetToolAt(nTool) != tool; nTool -= 1)
        ASSERT(nTool >= 0);

    m_Tools->RemoveAt(nTool);

    if ((m_Tools->GetSize() + m_wWide - 2) / (m_wWide - 1) <= 11 && m_wWide > 1)
        m_wWide -= 1;

    SizeByButtons(-1, TRUE);
    }


/******************************************************************************/
// private GetTool:
//
CTool* CToolboxWnd::GetTool(WORD wID)
    {
    int nTools = (int)m_Tools->GetSize();
    for (int i = 0; i < nTools; i++)
        {
        CTool* t = (CTool*)m_Tools->GetAt(i);
        if (t && t->m_wID == wID)
            return t;
        }

    return NULL;
    }

/******************************************************************************/
//
// SetToolState
//
// Used by the owner of a button to modify the state of the button.
// This does not notify the owner of the new state; presumably the
// owner knows what it's doing to its own buttons.  This allows the
// owner to use this API during a WM_TOOLDOWN, etc., without getting
// into a shouting match with the toolbox.
//
WORD CToolboxWnd::SetToolState(WORD wID, WORD wState)
    {
    CRect rect;
    CTool* t = GetTool(wID);
    if (t && !(t->m_wState & TF_NYI))
        {
        WORD w = t->m_wState;
        t->m_wState = wState;

        //
        // if state hasn't changed, return to avoid invalidate and
        // associated flicker.
        //

        if (w == wState)
            return w;

        //
        // Calculate the rectangle of the button whose state is changing,
        // and invalidate it.
        //
        // replaces ed's simplistic (and flickering) code:
        //
        //      Invalidate(FALSE)
        //

        for (int i = 0; (CTool*)m_Tools->GetAt(i) != t; i += 1)
            {
            ASSERT(i != m_Tools->GetSize());
            }

        rect.left   = (i % m_wWide) * m_btnsize.x + m_nOffsetX;
        rect.top    = (i / m_wWide) * m_btnsize.y + m_nOffsetY;
        rect.right  = rect.left + m_btnsize.x;
        rect.bottom = rect.top  + m_btnsize.y;

        InvalidateRect(&rect, TRUE);
        return w;
        }

    return 0;
    }

/******************************************************************************/
// SetToolStyle:
// Used by the owner of a button to modify the style of the button.
// This forces the state of the button to be enabled and released.
// This does not notify the owner of the new state; presumably the
// owner knows what it's doing to its own buttons.  This allows the
// owner to use this API during a WM_TOOLDOWN, etc., without getting
// into a shouting match with the toolbox.
//
WORD CToolboxWnd::SetToolStyle(WORD wID, WORD wStyle)
    {
    CTool* t = GetTool(wID);
    if (t)
        {
        WORD w = t->m_wStyle;
        t->m_wStyle = wStyle;
        t->m_wState = 0;
        Invalidate(FALSE);
        return w;
        }

    return 0;
    }


/******************************************************************************/
//
// SelectTool
//
// Selects a given tool and deselects all the other tools.      So, for instance,
// to select the arrow, call pToolbox->SelectTool(IDMB_ARROW);
//
void CToolboxWnd::SelectTool(WORD wID)
    {
    //
    // first clear all the tools except the one we want pressed, then
    // select the one we want.
    //
    for (int i = 0; i < m_Tools->GetSize(); i += 1)
        {
        CTool* pTool = (CTool*)m_Tools->GetAt(i);

        if (pTool->m_wID != wID)
            SetToolState(pTool->m_wID, 0);
        }

    SetToolState( wID, TF_SELECTED );
    }

/******************************************************************************/
/* CToolboxWnd::CurrentTool
 *
 * Returns the ID of the currently selected tool.
 */
WORD CToolboxWnd::CurrentToolID()
    {
    int nTools = (int)m_Tools->GetSize();
    for (int i = 0; i < nTools; i++)
        {
        CTool* t = (CTool*)m_Tools->GetAt(i);
        if (t && t->m_wState == TF_SELECTED)
            return t->m_wID;
        }
    return IDMB_ARROW;
    }

/******************************************************************************/

#define HITTYPE_SUCCESS         0               // hit an item in the control bar
#define HITTYPE_NOTHING         (-1)    // hit nothing, but hit the control bar itself
#define HITTYPE_OUTSIDE         (-2)    // hit a window outside of the control bar
#define HITTYPE_TRACKING        (-3)    // this app is has the focus (is tracking)
#define HITTYPE_INACTIVE        (-4)    // the app is not active
#define HITTYPE_DISABLED        (-5)    // the control bar is disabled
#define HITTYPE_FOCUS           (-6)    // the control bar has focus

int CToolboxWnd::HitTestToolTip( CPoint point, UINT* pHit )
    {
    if (pHit)
        *pHit = (UINT)-1;    // assume it won't hit anything

    int iReturn = HITTYPE_INACTIVE;

    // make sure this app is active
    if (theApp.m_bActiveApp)
        {
        // check for this application tracking (capture set)
        if (! m_tCapture)
            {
            // finally do the hit test on the items within the control bar
            ScreenToClient( &point );

            CRect  rect;
            CTool* pTool = ToolFromPoint( &rect, &point );

            if (pTool && rect.PtInRect( point ))
                {
                iReturn = HITTYPE_SUCCESS;

                if (pHit)
                    *pHit = pTool->m_wID;
                }
            else
                iReturn = HITTYPE_OUTSIDE;
            }
        else
            iReturn = HITTYPE_TRACKING;
                }

    #ifdef _DEBUG
    TRACE2( "HitTestToolType %d - %u\n", iReturn, pHit );
    #endif

    return iReturn;
    }

/******************************************************************************/

UINT CToolboxWnd::OnCmdHitTest( CPoint point, CPoint* pCenter )
    {
    ASSERT_VALID( this );

    // now hit test against CToolBar buttons
    CRect  rect;
    UINT   nHit  = (UINT)-1;
    CTool* pTool = ToolFromPoint( &rect, &point );

    if (pTool)
        nHit = pTool->m_wID;

    return nHit;
    }

/******************************************************************************/
// private ToolFromPoint:
// Given a CPoint in client coordinates, this function returns the tool
// associated with the button at that point, if any.  If a tool is found,
// the given CRect (if not NULL) is filled with the bounds of the tool's
// button.
//
CTool* CToolboxWnd::ToolFromPoint(CRect* rect, CPoint* pt) const
    {
    CRect  c = m_rcTools;
    CPoint p = *pt;

    if (p.x < c.left || p.x >= c.right
    ||  p.y < c.top  || p.y >= c.bottom)
        return NULL;

    int x = (p.x - m_nOffsetX) / m_btnsize.x;
    int y = (p.y - m_nOffsetY) / m_btnsize.y;
    int i = x + (y * m_wWide);

    if (i >= m_Tools->GetSize())
        return NULL;

    CTool* t = (CTool*)(m_Tools->GetAt( i ));

    if (t && rect)
        {
        rect->left   = m_btnsize.x * x + m_nOffsetX;
        rect->top    = m_btnsize.y * y + m_nOffsetY;
        rect->right  = rect->left + m_btnsize.x;
        rect->bottom = rect->top  + m_btnsize.y;
        }

    return t;
    }

/******************************************************************************/
// OnLButtonDown:

void CToolboxWnd::OnLButtonDown(UINT wFlags, CPoint point)
    {
        wFlags; // Avoid unused arg warnings
    m_tCapture = ToolFromPoint( &m_lasttool, &point );
    m_downpt   = point;

    if (m_tCapture)
        {
        CRect   rect = m_lasttool;
        CString strPrompt;

        m_bInside = FALSE;

        rect.InflateRect( -1, -1 );

        if (rect.PtInRect( point ))
            {
            if (m_tCapture->m_wID <= IDMB_USERBTN)
                GetOwner()->SendMessage( WM_SETMESSAGESTRING, (WPARAM)m_tCapture->m_wID );

            if (m_tCapture->m_wState & TF_DISABLED)
                m_tCapture = NULL;
            else
                m_bInside = TRUE;
            }
        else
            m_tCapture = NULL;
        }
    else
        {
                CControlBar::OnLButtonDown(wFlags,point);
        }

    if (m_tCapture )
        {
        SetCapture();

        if (m_tCapture)
            InvalidateRect( &m_lasttool, TRUE );
        }
    }

/******************************************************************************/

void CToolboxWnd::OnRButtonDown(UINT wFlags, CPoint point)
    {
        wFlags;
        point;
    if (GetCapture() == this)
        CancelDrag();
    }

/******************************************************************************/
/*DK*/
//  LRESULT CToolboxWnd::OnHelpHitTest(WPARAM wParam, LPARAM lParam)
//      {
//      CPoint pt(lParam);
//      CTool* t = ToolFromPoint(&m_lasttool, &pt);
//
//      if (t == NULL)
//          return CMiniFrmWnd::OnHelpHitTest(wParam, lParam);
//      else
//          {
//          ASSERT( t->m_wID );
//          return HID_BASE_BUTTON + t->m_wID;
//          }
//      }


// OnLButtonDblClk:  FUTURE: Maybe just not use CS_DBLCLKS?
//
void CToolboxWnd::OnLButtonDblClk(UINT wFlags, CPoint point)
    {
    OnLButtonDown(wFlags, point);
    }

/******************************************************************************/

BOOL CToolboxWnd::SetStatusText(int nHit)
    {
    if (nHit == -1 && m_pLastHot != 0)
        {
        m_pLastHot->m_wState &= ~TF_HOT;
        InvalidateRect(&m_rectLastHot, TRUE);
        m_pLastHot = 0;
        }

    return CControlBar::SetStatusText(nHit);
    }

/******************************************************************************/
// OnMouseMove:
//
void CToolboxWnd::OnMouseMove(UINT wFlags, CPoint point)
    {
    CTool* t = m_tCapture;

    if (! t || (t->m_wState & TF_DISABLED))
        {
        if (m_hTheme) 
            {
            CRect rectHot;

            CTool* pHot = ToolFromPoint(&rectHot, &point);

            if (m_pLastHot != pHot)
                {
                if (m_pLastHot)
                    {
                    m_pLastHot->m_wState &= ~TF_HOT;
                    InvalidateRect(&m_rectLastHot, TRUE);
                    }

                if (pHot)
                    {
                    pHot->m_wState |= TF_HOT;
                    InvalidateRect(&rectHot, TRUE);
                    }

                m_rectLastHot = rectHot;
                m_pLastHot = pHot;
                }
            }

        CControlBar::OnMouseMove( wFlags, point );
        return;
        }

    BOOL bWasInside = m_bInside;
    CRect rect = m_lasttool;

    rect.InflateRect( -1, -1 );

    m_bInside = ((! (t->m_wState & TF_DRAG)) && rect.PtInRect( point ));

    if (bWasInside != m_bInside)
        InvalidateRect( &m_lasttool, TRUE );

    if (t && !(t->m_wState & TF_DISABLED))
        {
        // if it's a mousemove and we're draggable, then see how far it
        // is from the original mousedown -- if it's a fair distance,
        // then drag it.
        if ((t->m_wStyle & TS_DRAG) &&
                    (((point.x - m_downpt.x) > 3) ||
                     ((point.y - m_downpt.y) > 3) ||
                     ((m_downpt.x - point.x) > 3) ||
                     ((m_downpt.y - point.y) > 3)))
            {
            t->m_wState |= TF_DRAG;

            if (t->m_wStyle & TS_STICKY)
                {
                if (!(t->m_wState & TF_SELECTED))
                    {
                    t->m_wState |= TF_SELECTED;

                    if (t->m_pOwner)
                        t->m_pOwner->SendMessage(TM_TOOLDOWN, t->m_wID);
                    }

                if (m_bInside)
                    InvalidateRect(&m_lasttool, TRUE);

                m_bInside = FALSE; // looks stuck immediately!
                }
            }
        if (t->m_pOwner && (t->m_wState & TF_DRAG))
            {
            CPoint spt = point;
            ClientToScreen(&spt);

            // if the drag and drop began ok, release the captured tool
//          if (t->m_pOwner->BeginDragDrop( t, spt ))
//              m_tCapture = NULL;
            }
        }
    }


/******************************************************************************/
// OnLButtonUp:

void CToolboxWnd::OnLButtonUp(UINT wFlags, CPoint point)
    {
    if (! m_tCapture )
        {
        CControlBar::OnLButtonUp( wFlags, point );
        return;
        }

    CTool* t = m_tCapture;

    if (t && ! (t->m_wState & TF_DISABLED))
        {
        m_bInside = (point.x >= m_lasttool.left
                  && point.x <  m_lasttool.right
                  && point.y >= m_lasttool.top
                  && point.y <  m_lasttool.bottom);

        if (m_bInside)
            {
            if (t->m_wStyle & TS_STICKY)
                {
                if (! (t->m_wState & TF_DRAG))
                    {
                    t->m_wState ^= TF_SELECTED;

                    InvalidateRect(&m_lasttool, TRUE);

                    if (t->m_pOwner)
                        t->m_pOwner->SendMessage( t->m_wState & TF_SELECTED?
                                         TM_TOOLDOWN : TM_TOOLUP, t->m_wID );
                    }
                }

            if (t->m_wStyle & TS_CMD)
                {
                if (t->m_pOwner)
                    AfxGetMainWnd()->SendMessage( WM_COMMAND, t->m_wID );
                }
            }
        }
    ReleaseCapture();
    m_tCapture = NULL;
    m_bInside  = FALSE;
    }

/******************************************************************************/

BOOL CToolboxWnd::OnCommand(UINT wParam, LONG lParam)
    {
    AfxGetMainWnd()->SendMessage(WM_COMMAND, wParam, lParam);
    return TRUE;
    }

/******************************************************************************/

void CToolboxWnd::DrawButtons(CDC& dc, RECT* rcPaint)
    {
    CRect rect;
    CRect updateRect;
    int i, n;

    if (rcPaint == NULL)
        {
        GetClientRect( &updateRect );
        rcPaint = &updateRect;
        }

    CDC memdc;
    memdc.CreateCompatibleDC(&dc);

    if (m_hTheme == 0)
        {
        // Force the buttons to be rebuilt here
        DrawStockBitmaps();
        }

    CBitmap* obm = memdc.SelectObject( m_bmPopped );
    CBrush*  obr = memdc.SelectObject( GetSysBrush( COLOR_BTNTEXT ) );

    n = (int)m_Tools->GetSize();

    BOOL bUsedImageWell = FALSE;

    for (i = 0; i < n; i++)
        {
        CTool* t = (CTool*)m_Tools->GetAt(i);

        if (! t)
            continue;

        rect.left   = (i % m_wWide) * m_btnsize.x + m_nOffsetX;
        rect.top    = (i / m_wWide) * m_btnsize.y + m_nOffsetY;

        rect.right  = rect.left + m_btnsize.x;
        rect.bottom = rect.top  + m_btnsize.y;

        CRect ir;

        if (! ir.IntersectRect( rcPaint, &rect ))
            continue;

        // Select the right stock bitmap, and remember to
        // shove the graphic if it's in a pushed state.
        //
        CBitmap* bmStock = m_bmPopped;
        int xshove = 0, yshove = 0;
        int iButtonStateId = TS_NORMAL;

        if (t->m_wState & (TF_SELECTED | TF_DRAG))
            {
            bmStock = m_bmStuck;
            xshove = 1; yshove = 1;
            iButtonStateId = t->m_wState & TF_HOT ? TS_HOTCHECKED : TS_CHECKED;
            }
        else if (t->m_wState & TF_HOT)
            {
            iButtonStateId = TS_HOT;
            }

        if ((t == m_tCapture && m_bInside) && !(t->m_wState & TF_DRAG))
            {
            bmStock = m_bmPushed;
            xshove = 2; yshove = 2;
            iButtonStateId = TS_PRESSED;
            }

        // Draw a blank button first...

        if (m_hTheme)     
            { 
            DrawThemeBackground(m_hTheme, dc, TP_BUTTON, iButtonStateId, &rect, 0);
            }
            else
            {
            ::DrawBitmap(&dc, bmStock, &rect, SRCCOPY, &memdc);
            }
         
        // Now draw the glyph on top...
        rect.OffsetRect( xshove, yshove );

        if (! bUsedImageWell)
            {
            if (! m_imageWell.Open())
                goto LReturn;

            bUsedImageWell = TRUE;

            if (! m_imageWell.CalculateMask())
                goto LReturn;
            }

        CPoint pt( rect.left + (rect.Width()  - 16) / 2,
                   rect.top  + (rect.Height() - 16) / 2 );

        m_imageWell.DrawImage( &dc, pt, t->m_nImage );
        }

LReturn:
    if (bUsedImageWell)
        m_imageWell.Close();

    memdc.SelectObject(obr);
    memdc.SelectObject(obm);
    memdc.DeleteDC();
    }

/******************************************************************************/
// OnPaint:
//

void CToolboxWnd::OnPaint()
    {
    CPaintDC dc(this);
    if (dc.m_hDC == NULL)
        {
        theApp.SetGdiEmergency();
        return;
        }
    DrawButtons(dc, &dc.m_ps.rcPaint);
    }

/******************************************************************************/
// OnClose
//
// A toolbox is usally created by the parent, and will be destroyed
// specifically by the parent upon leaving the app.  When the user closes
// the toolbox, it is simply hidden.  The parent can then reshow it without
// recreating it.
//
// This also changes the menu test to "show" rather than "hide"

void CToolboxWnd::OnClose()
    {
#ifdef TRYANYTHING
        CControlBar::OnClose();
#endif
//      ShowWindow(SW_HIDE);
    }

/******************************************************************************/
// OnDestroy
//
void CToolboxWnd::OnDestroy()
    {
    if (m_hTheme)
        {
        CloseThemeData(m_hTheme);
        m_hTheme = 0;
        }
    CControlBar::OnDestroy();
    }

/******************************************************************************/
// OnThemeChanged
//
LRESULT CToolboxWnd::OnThemeChanged(WPARAM, LPARAM)
    {
    if (m_hTheme)
        {
        CloseThemeData(m_hTheme);
        }
    m_hTheme = SafeOpenThemeData(GetSafeHwnd(), L"toolbar");
    InvalidateRect(0, TRUE);
    return TRUE;
    }

/******************************************************************************/
// OnToolDown:
//
LONG CToolboxWnd::OnToolDown(UINT wID, LONG /* lParam */)
    {
    for (int i = 0; i < m_Tools->GetSize(); i += 1)
        {
        CTool* pTool = (CTool*)m_Tools->GetAt(i);

        if (pTool->m_wID != wID)
            SetToolState(pTool->m_wID, 0);
        }

    return (LONG)TRUE;
    }

/******************************************************************************/
// OnToolUp:
//
LONG CToolboxWnd::OnToolUp(UINT /* wID */, LONG /* lParam */)
    {
    for (int i = 0; i < m_Tools->GetSize(); i += 1)
        {
        CTool* pTool = (CTool*)m_Tools->GetAt(i);
        SetToolState(pTool->m_wID, 0);
        }
    SetToolState(IDMB_ARROW, TF_SELECTED);

    return (LONG)TRUE;
    }
#ifdef XYZZYZ
/******************************************************************************/
// OnSwitch:
//
LONG CToolboxWnd::OnSwitch(UINT /* wID */, LONG /* point */)
    {
    return (LONG)TRUE;
    }

/******************************************************************************/
// OnQueryDrop:
//
BOOL CToolboxWnd::BeginDragDrop (CTool* /*pTool*/, CPoint /*pt*/)
    {
    return FALSE;
    }
#endif
/******************************************************************************/

CTool::CTool(CToolboxWnd* pOwner, WORD wID, int nImage,
        WORD wStyle /* = 0 */, WORD wState /* = 0 */)
    {
    m_pOwner = pOwner;
    m_wID    = wID;
    m_nImage = nImage;
    m_wStyle = wStyle;
    m_wState = wState;
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\tracker.h ===
#ifndef __TRACKER_H__
#define __TRACKER_H__

#include "sprite.h"

extern HCURSOR HCursorFromTrackerState( int m );

class CTracker : public CSprite
    {
    public:

    enum STATE
        {                               // WARNING - mapTrackerStateToPHCursor
        nil,                            //           (in tracker.cpp) is
        predrag,                        //           dependant on the
        moving,                         //           ordering of this enum!
        resizingTop,
        resizingLeft,
        resizingRight,
        resizingBottom,
        resizingTopLeft,
        resizingTopRight,
        resizingBottomLeft,
        resizingBottomRight,
        };

    enum { HANDLE_SIZE = 3 };           // size of tracker resize handles

    enum EDGES
        {
        none   = 0,
        left   = 1,
        top    = 2,
        right  = 4,
        bottom = 8,
        all    = 15
        };

    static  void    DrawBorder ( CDC* pDC, const CRect& rect, EDGES edges = all );
    static  void    DrawHandles( CDC* pDC, const CRect& rect, EDGES edges );

    static  STATE   HitTest(const CRect& rect, CPoint pt, STATE defaultState );

    static  void    DrawBorderRgn ( CDC* pdc, const CRect& trackerRect,              CRgn *pcRgnPoly );
    static  void    DrawHandlesRgn( CDC* pDC, const CRect&        rect, EDGES edges, CRgn *pcRgnPoly );

    static  STATE   HitTestRgn(const CRect& rect, CPoint pt, STATE defaultState, CRgn *pcRgnPoly );

    static  void    CleanUpTracker();
    };

#endif // __TRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_curve.h ===
#ifndef __T_CURVE_H__
#define __T_CURVE_H__

#include "imgtools.h"

#define MAX_ANCHOR_POINTS  4 // endpoints the user selects (buttondown).

class CCurveTool : public CRubberTool
    {
    DECLARE_DYNAMIC(CCurveTool)

    protected:
        POINT    m_PolyPoints[MAX_ANCHOR_POINTS];
        CRect    m_cRectBounding;
        int      m_iNumAnchorPoints;

        void AdjustBoundingRect(void);
        void AddPoint(POINT ptNewPoint);
        void SetCurrentPoint(POINT ptNewPoint);
        BOOL DrawCurve(CDC* pDC);

        virtual void AdjustPointsForConstraint(MTI *pmti);
        virtual void PreProcessPoints(MTI *pmti);

    public:

        CCurveTool();
        ~CCurveTool();

        virtual void Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown);
        virtual void OnStartDrag(CImgWnd* pImgWnd, MTI* pmti );
        virtual void OnEndDrag(CImgWnd* pImgWnd, MTI* pmti );
        virtual void OnDrag(CImgWnd* pImgWnd, MTI* pmti );
        virtual void OnCancel(CImgWnd* pImgWnd);
        virtual void EndMultiptOperation(BOOL bAbort = FALSE);
        virtual void OnActivate( BOOL bActivate );

        BOOL CanEndMultiptOperation(MTI* pmti );

    };


#endif // __T_CURVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_curve.cpp ===
/******************************************************************************/
/* T_CURVE.CPP: IMPLEMENTATION OF THE CCurveTool CLASS                        */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  CCurve Tool Class Object                                                  */
/*     CCurveTool::CCurveTool                                                 */
/*     CCurveTool::~CCurveTool                                                */
/*     CCurveTool::AdjustBoundingRect                                         */
/*     CCurveTool::AddPoint                                                   */
/*     CCurveTool::SetCurrentPoint                                            */
/*     CCurveTool::DrawCurve                                                  */
/*     CCurveTool::AdjustPointsForConstraint                                  */
/*     CCurveTool::PreProcessPoints                                           */
/*     CCurveTool::Render                                                     */
/*     CCurveTool::OnStartDrag                                                */
/*     CCurveTool::OnEndDrag                                                  */
/*     CCurveTool::OnDrag                                                     */
/*     CCurveTool::OnCancel                                                   */
/*     CCurveTool::CanEndMultiptOperation                                     */
/*     CCurveTool::EndMultiptOperation                                        */
/******************************************************************************/
/*                                                                            */
/* Briefly, this Object draws a curve from 4 (currently) points. It generates */
/* a list of points which are placed in the array, and then calls polyline    */
/* to draw line segments to build a curve.                                    */
/*                                                                            */
/* The array is divided into 2 pieces.  The first piece is the anchor points, */
/* the 2nd piece is the array of points which will be passed to polyline.     */
/* The anchor points are placed in the array in the following order           */
/* 2,3,4,...1. See the addpoint method below for info on this order.          */
/*                                                                            */
/******************************************************************************/
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "pbrusvw.h"
#include "t_curve.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCurveTool, CRubberTool)

#include "memtrace.h"

extern CLineTool NEAR g_lineTool;

CCurveTool       NEAR g_curveTool;


/******************************************************************************/
CCurveTool::CCurveTool()
    {
    m_nCmdID = IDMB_CURVETOOL;
    m_iNumAnchorPoints = 0;
    m_cRectBounding.SetRectEmpty();
    }

/******************************************************************************/
CCurveTool::~CCurveTool()
    {
    m_cRectBounding.SetRectEmpty();
    }

/******************************************************************************/
/* recalculate the bounding rectangle for the polyline/curve                  */
void CCurveTool::AdjustBoundingRect(void)
    {
    int iStrokeWidth = GetStrokeWidth();
    int i;

    if (m_iNumAnchorPoints >= 1)
        {
        //set the rect to equal the 1st value
        m_cRectBounding.SetRect(m_PolyPoints[0].x, m_PolyPoints[0].y,
                                m_PolyPoints[0].x, m_PolyPoints[0].y);
        }

    for (i=1; i < m_iNumAnchorPoints; i++)
        {
        m_cRectBounding.SetRect( min(m_PolyPoints[i].x, m_cRectBounding.left),
                                 min(m_PolyPoints[i].y, m_cRectBounding.top),
                                 max(m_PolyPoints[i].x, m_cRectBounding.right),
                                 max(m_PolyPoints[i].y, m_cRectBounding.bottom));
        }

        // Adjust rectangle for Windows GDI (Non-inclusive right/bottom)
        m_cRectBounding.bottom++; m_cRectBounding.right++;

    // Adjust for width of current drawing line/border
    m_cRectBounding.OffsetRect(-(iStrokeWidth/2),-(iStrokeWidth/2));
    m_cRectBounding.InflateRect(iStrokeWidth, iStrokeWidth);
    }
/******************************************************************************/
// This method adds a new point into the array and increases the number of
// anchor points currently in the array.  If there  are no points in the
// array, it adds a point to the 1st position (index 0).  If there are any
// points currently in the array, it copies the last point to the new
// location, and then adds the new point where the old last point was (1 point
// before the last point.  The 1st point added is always the last point in the
// array, and the  2nd point added is always the 1st point.
// The order of the points in the array are: 2,3,4,....,1
void CCurveTool::AddPoint(POINT ptNewPoint)
    {
    BOOL bRC = TRUE;

    if (m_iNumAnchorPoints == 0)
        {
        m_PolyPoints[m_iNumAnchorPoints] = ptNewPoint;
        m_iNumAnchorPoints++;
        }
    else
        {
        if (m_iNumAnchorPoints < MAX_ANCHOR_POINTS)
            {
            m_PolyPoints[m_iNumAnchorPoints] = m_PolyPoints[m_iNumAnchorPoints-1];
            m_PolyPoints[m_iNumAnchorPoints-1] = ptNewPoint;
            m_iNumAnchorPoints++;
            }
        }


    AdjustBoundingRect();
    }
/******************************************************************************/
// This method changes the value of the last point in the array.  If there are
// 2 points, then it modifies the 2nd point, knowing that when there are only
// 2 points, we are draing a straight line (between 2 points).  If there are
// more than 2 points, it modified the second to last point in the array,
// which is actually the last point dropped/placed.  See above for expl of
// order of points in the array.
void CCurveTool::SetCurrentPoint(POINT ptNewPoint)
    {
    if (m_iNumAnchorPoints == 2)
        {
        m_PolyPoints[m_iNumAnchorPoints-1] = ptNewPoint;
        }
    else
        {
        if (m_iNumAnchorPoints > 2)
            {
            m_PolyPoints[m_iNumAnchorPoints-2] = ptNewPoint;
            }
        }
    AdjustBoundingRect();
    }
/******************************************************************************/
BOOL CCurveTool::DrawCurve(CDC* pDC)
    {
                POINT ptCurve[MAX_ANCHOR_POINTS];
                UINT uPoints = m_iNumAnchorPoints;
                int i;

                for (i=uPoints-1; i>=0; --i)
                {
                        ptCurve[i] = m_PolyPoints[i];
                }

                // HACK: PolyBezier cannot handle 3 points, so repeat the middle point
                if (uPoints == 3)
                {
                        ptCurve[3] = ptCurve[2];
                        ptCurve[2] = ptCurve[1];
                        uPoints = 4;
                }

                PolyBezier(pDC->m_hDC, ptCurve, uPoints);

                return(TRUE);
    }
/******************************************************************************/
/* Call the line's adjustpointsforconstraint member function                  */
/* only do this if there are 2 points (i.e. drawing a straight line           */
void CCurveTool::AdjustPointsForConstraint(MTI *pmti)
    {
    if (m_iNumAnchorPoints == 2)
        {
        g_lineTool.AdjustPointsForConstraint(pmti);
        }
    }

/******************************************************************************/
// ptDown must be anchor point for our line, not where we did mouse button down
// on a subsequent point in the multipt operation
void CCurveTool::PreProcessPoints(MTI *pmti)
    {
    pmti->ptDown = m_PolyPoints[0];
    CRubberTool::PreProcessPoints(pmti);
    }

/******************************************************************************/
/* Render sets up the pen and brush, and then calls either Render             */
/* The pen and brush is set up exactly the same as the parent routine in      */
/* CRubberTool.  If there are only 2 points, do the standard line drawing     */
/* using moveto and lineto, instead of trying to create a curve between 2 pts */

void CCurveTool::Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown)
    {
    // Setup Pen/Brush
    SetupPenBrush( pDC->m_hDC, bDraw, TRUE, bCtrlDown );

    if (m_iNumAnchorPoints == 2)
        {
        pDC->MoveTo( m_PolyPoints[0].x, m_PolyPoints[0].y );
        pDC->LineTo( m_PolyPoints[1].x, m_PolyPoints[1].y );
        }
    else
        {
        if (m_iNumAnchorPoints > 2)
            {
            DrawCurve( pDC );
            }
        }
    // Cleanup Pen/Brush
    SetupPenBrush( pDC->m_hDC, bDraw,  FALSE, bCtrlDown );

    // Need to return the bounding rect
    rect = m_cRectBounding;
    }

void CCurveTool::OnActivate( BOOL bActivate )
{
        if (!bActivate && m_bMultPtOpInProgress)
        {
                CImgWnd* pImgWnd = ((CPBView*)((CFrameWnd*)AfxGetMainWnd())->GetActiveView())->m_pImgWnd;

                // Stolen from CPBView::OnEscape
                // I don't think this can ever be NULL, but just in case
                if (pImgWnd != NULL)
                {
                        EndMultiptOperation( FALSE ); // end the multipt operation

                        Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, TRUE, TRUE, FALSE);
                        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
                        CommitImgRect(pImgWnd->m_pImg, &m_cRectBounding);
                        pImgWnd->FinishUndo(m_cRectBounding);

                        ClearStatusBarSize();
                }
        }

        CRubberTool::OnActivate( bActivate );
}


/******************************************************************************/
/* On Start Drag is called on mouse button down.  We basically call on Start  */
/* Drag of the parent (default) class after adding in our point(s) into the   */
/* array of points.  If this is the first point (i.e. bMultiptOpInProgress == */
/* False, then we need 2 points in our array, and we can call the default     */
/* OnStartDrag.  If it is not the first point, then we just add the new point */
/* and call our OnDrag.  In either case, OnDrag is called which eventually    */
/* calls render to do our drawing on the mouse down                           */
/* We only call the parent OnStartDrag  the first time, because it does some  */
/* setup which we do not want done each time                                  */
void CCurveTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    if (m_bMultPtOpInProgress)
        {
        AddPoint(pmti->pt);
        OnDrag(pImgWnd, pmti);
        }
    else
        {
        // must reset numAnchorPoints before calling addpoint the 1st time.
        m_iNumAnchorPoints = 0;
        AddPoint(pmti->pt);
        m_bMultPtOpInProgress = TRUE;
        // No Mult Pt In Progress => 1st Click
        //
        // add a 2nd point, last point is what we are draing to
        // 1st point is anchor.  1st time, need 2 points to draw a line
        // subsequent times, just add 1 point in array of points.
        AddPoint(pmti->pt);
        CRubberTool::OnStartDrag(pImgWnd, pmti);
        }

    }
/******************************************************************************/
/* On End Drag is sent on a mouse button up.  This basically is a clone of the*/
/* CRubberTool::OnEndDrag method, except that we use our bounding rect for all*/
/* the image invalidation, and commit, and undo function calls.               */
/* if we are in the middle of a multipoint operation, we do not want to call  */
/* all the routines to fix the drawing (e.g. invalImgRect, CommitImgRect,     */
/* FinishUndo).  We just want to save the current point, render, and return   */
void CCurveTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints(pmti);
    SetCurrentPoint(pmti->pt);

    if (m_bMultPtOpInProgress)
        {
        // can't call OnDrag for this object/class, since it calls preprocesspt
        // again, and then onDrag.  If you call preproces again, you will lose
        // bounding rectange box prev, and not be able to invalidate / repaint
        // Still have to invalidate bounding rect, since if rect is larger than
        // current rect, must invalidate to paint. E.g. If let off shift, then
        // let off button, end point would be adjusted and bouning rect would
        // also be correct, but rect calculated in CRubberTool::OnDrag is
        // incorrect.
        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
        CRubberTool::OnDrag(pImgWnd, pmti);
        }
    else
        {
        OnDrag(pImgWnd, pmti); // one last time to refresh display in prep for final render
        Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, pmti->fLeft, TRUE, pmti->fCtrlDown);
        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
        CommitImgRect(pImgWnd->m_pImg, &m_cRectBounding);
        pImgWnd->FinishUndo(m_cRectBounding);

        ClearStatusBarSize();

        CImgTool::OnEndDrag(pImgWnd, pmti);
        }
    }

/******************************************************************************/
/* On Drag is sent when the mouse is moved with the button down.  We basically*/
/* save the current point, and call the base class processing.  Since the base*/
/* class processing invalidates the rect on the screen and cleans it up so we */
/* can paint a new line, we have to adjust the previous rectangle to be the   */
/* bounding rectangle of our polyline.  If we did not do this, our previous   */
/* drawing would not get erased, and we would be drawing our new line over    */
/* part of the previous line.  The default processing finally calls Render    */
/* which since our render is virtual, will call our render method above.      */
void CCurveTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints(pmti);
    SetCurrentPoint(pmti->pt);
    CRubberTool::OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/
/* On Cancel is sent when the user aborts an operation while in progress      */
/* EndMultiptOperation with TRUE will do all our cleanup                      */
void CCurveTool::OnCancel(CImgWnd* pImgWnd)
    {
    EndMultiptOperation(TRUE);
    CImgTool::OnCancel(pImgWnd);
    }

/******************************************************************************/
/* we can only end if the number of maximum points was entered.  We must stay */
/* in capture/multiptmode until we get EXACTLY the desired number of anchor   */
/* points                                                                     */
BOOL CCurveTool::CanEndMultiptOperation(MTI* pmti )
    {

    if (m_iNumAnchorPoints == MAX_ANCHOR_POINTS)
        {
        m_bMultPtOpInProgress = FALSE;
        }
    else
        {
        m_bMultPtOpInProgress = TRUE;
        }

    return (CRubberTool::CanEndMultiptOperation(pmti));
    }

/******************************************************************************/
/* If bAbort is true, this means an error occurred, or the user cancelled the */
/* multipoint operation in the middle of it.  We just set the num of anchor   */
/* points to 0 to stop drawing and call the default endmultiptoperation       */
void CCurveTool::EndMultiptOperation(BOOL bAbort)
    {
    if (bAbort)
        {
        m_iNumAnchorPoints = 0;
        m_cRectBounding.SetRectEmpty();
        }

    CRubberTool::EndMultiptOperation();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_fhsel.h ===
#ifndef __T_FHSEL_H__
#define __T_FHSEL_H__

#include "imgtools.h"
#include "t_poly.h"

class CFreehandSelectTool : public CPolygonTool
    {
    DECLARE_DYNAMIC(CFreehandSelectTool)

    protected:

    CRgn *m_pcRgnPoly;
    CRgn *m_pcRgnPolyBorder;

    int  m_iNumPoints;

    void AdjustPointsForZoom( int iZoom );
    BOOL CreatePolyRegion   ( int iZoom );
    BOOL CreatePolyRegion   ( int iZoom, LPPOINT lpPoints, int iPoints );

    virtual BOOL SetupPenBrush( HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown );
    virtual void AdjustPointsForConstraint( MTI *pmti );
    virtual void PreProcessPoints( MTI *pmti );

    virtual BOOL IsToolModal(void);

    public:

    CFreehandSelectTool();
    ~CFreehandSelectTool();

    BOOL ExpandPolyRegion( int iNewSizeX, int iNewSizeY );

    virtual void OnPaintOptions ( CDC* pDC, const CRect& paintRect,
                                  const CRect& optionsRect );
    virtual void OnClickOptions ( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                     const CPoint& clickPoint );



    virtual void OnStartDrag( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag  ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag     ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel   ( CImgWnd* pImgWnd );
    virtual void OnActivate ( BOOL bActivate );

    virtual BOOL CanEndMultiptOperation( MTI* pmti );

    friend class CImgWnd;
    };


#endif // __T_FHSEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_fhsel.cpp ===
/******************************************************************************/
/* T_FHSEL.CPP: IMPLEMENTATION OF THE CFreehandSelectTool CLASS               */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/******************************************************************************/
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgbrush.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "t_fhsel.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CFreehandSelectTool, CPolygonTool )

#include "memtrace.h"

extern CSelectTool  NEAR g_selectTool;
CFreehandSelectTool NEAR g_freehandselectTool;

/******************************************************************************/

CFreehandSelectTool::CFreehandSelectTool()
    {
    m_bIsUndoable     = FALSE;
    m_nCmdID          = IDMB_PICKRGNTOOL;
    m_bCanBePrevTool  = FALSE;
    m_bFilled         = FALSE;
    m_bBorder         = FALSE;
    m_nStrokeWidth    = 1;
    m_pcRgnPoly       = &(theImgBrush.m_cRgnPolyFreeHandSel);
    m_pcRgnPolyBorder = &(theImgBrush.m_cRgnPolyFreeHandSelBorder);
    }

/******************************************************************************/

CFreehandSelectTool::~CFreehandSelectTool()
    {
    }

/******************************************************************************/

void CFreehandSelectTool::AdjustPointsForZoom(int iZoom)
    {
    int iSize = (int)m_cObArrayPoints.GetSize();
    CPoint *pcPoint;

    for (int i = 0; i < iSize; i++)
        {
        pcPoint= (CPoint *)m_cObArrayPoints.GetAt(i);
        pcPoint->x *= iZoom;
        pcPoint->y *= iZoom;
        }
    }

/******************************************************************************/

BOOL CFreehandSelectTool::CreatePolyRegion( int iZoom )
    {
    BOOL bRC = TRUE;
    CPoint *pcPointArray;

    // cleanup old region if exists
    if (m_pcRgnPoly->GetSafeHandle())
        m_pcRgnPoly->DeleteObject();

    // cleanup old region if exists
    if (m_pcRgnPolyBorder->GetSafeHandle())
        m_pcRgnPolyBorder->DeleteObject();

    bRC = CopyPointsToMemArray( &pcPointArray, &m_iNumPoints );

    if (! bRC)
        {
        theApp.SetMemoryEmergency();
        return FALSE;
        }

    bRC = m_pcRgnPoly->CreatePolygonRgn( pcPointArray, m_iNumPoints, ALTERNATE );

    delete [] pcPointArray;

    if (! bRC)  // offset for selection boundary
        {
        theApp.SetGdiEmergency();
        return FALSE;
        }

    m_pcRgnPoly->OffsetRgn( -m_cRectBounding.left,
                            -m_cRectBounding.top );
    //
// This adjustment appears to be unnecessary. removed it 5/1/1997
//    AdjustPointsForZoom( iZoom );

    bRC = CopyPointsToMemArray( &pcPointArray, &m_iNumPoints );

    if (bRC)
        {
        bRC = m_pcRgnPolyBorder->CreatePolygonRgn( pcPointArray, m_iNumPoints, ALTERNATE );

        delete [] pcPointArray;

        if (bRC) // offset for selection boundary
            m_pcRgnPolyBorder->OffsetRgn( -(m_cRectBounding.left * iZoom),
                                          -(m_cRectBounding.top  * iZoom) );
        }
    if (! bRC)
        m_pcRgnPoly->DeleteObject();

    return bRC;
    }

/******************************************************************************/

BOOL CFreehandSelectTool::CreatePolyRegion( int iZoom, LPPOINT lpPoints, int iPoints )
    {
    if (! lpPoints || iPoints < 3)
        return FALSE;

    DeleteArrayContents();

    TRY {
        CPoint* pPt;

        for (int i = 0; i < iPoints; i++)
            {
            pPt = new CPoint( lpPoints[i] );

            m_cObArrayPoints.Add( (CObject *)pPt );
            }
        }
    CATCH( CMemoryException, e )
        {
        DeleteArrayContents();

        theApp.SetMemoryEmergency();

        return FALSE;
        }
    END_CATCH

    m_iNumPoints = iPoints;

    AdjustBoundingRect();

    rcPrev = m_cRectBounding;
    m_bMultPtOpInProgress = FALSE;

    theImgBrush.m_bMakingSelection = FALSE;
    theImgBrush.m_bMoveSel         = FALSE;
    theImgBrush.m_bSmearSel        = FALSE;

    if (! CreatePolyRegion( iZoom ))
        return FALSE;

    return TRUE;
    }

/******************************************************************************/

BOOL CFreehandSelectTool::ExpandPolyRegion( int iNewSizeX, int iNewSizeY )
    {
    CPoint* pcPointArray;
    int    iNumPts;

    if (! CopyPointsToMemArray( &pcPointArray, &iNumPts ))
        return FALSE;

    int iWidth  = m_cRectBounding.Width()  + 1;
    int iHeight = m_cRectBounding.Height() + 1;
    int iDeltaX = ((iNewSizeX - iWidth ) * 10) / iWidth;
    int iDeltaY = ((iNewSizeY - iHeight) * 10) / iHeight;

    CPoint* pPtArray = pcPointArray;
    int     iPts     = iNumPts;

    while (iPts--)
        {
        pPtArray->x = (((pPtArray->x * 10) + (pPtArray->x * iDeltaX)) + 5) / 10;
        pPtArray->y = (((pPtArray->y * 10) + (pPtArray->y * iDeltaY)) + 5) / 10;

        pPtArray++;
        }

    BOOL bReturn = CreatePolyRegion( CImgWnd::GetCurrent()->GetZoom(),
                                     pcPointArray, iNumPts );
    delete [] pcPointArray;

    return bReturn;
    }

/******************************************************************************/
/* This routine is called before rendering onto the DC.  It basically, calls  */
/* the default setup to setup the pen and brush, and then overrides the Pen if*/
/* drawing in progress and drawing without any border.  This case is necessary*/
/* since if you do not have a border, you need to see something during the in */
/* progress drawing mode.  It uses the inverse (not) of the screen color as   */
/* the border in this mode.                                                   */

BOOL CFreehandSelectTool::SetupPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown)
    {
    static int iOldROP2Code;
    static BOOL bCurrentlySetup = FALSE;

    m_nStrokeWidth = 1;  // override any changes

    BOOL bRC = CClosedFormTool::SetupPenBrush(hDC, bLeftButton, bSetup, bCtrlDown);

    // for multipt operations in progress (e.g. drawing outline, not fill yet
    // if there is no border, use the not of the screen color for the border.
    // When bMultiptopinprogress == FALSE, final drawing, we will use a null
    // pen and thus have no border.
    if (bSetup)
        {
        if (bCurrentlySetup)
            bRC = FALSE;
        else
            {
            bCurrentlySetup = TRUE;
            iOldROP2Code = SetROP2(hDC, R2_NOT);
            }
        }
    else
        {
        if (bCurrentlySetup)
            {
            bCurrentlySetup = FALSE;

            // if no border, restore drawing mode
            SetROP2(hDC, iOldROP2Code);
            }
        else
            // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
            bRC = FALSE;
        }

    return bRC;
    }

/******************************************************************************/
/* Call the line's adjustpointsforconstraint member function                  */

void CFreehandSelectTool::AdjustPointsForConstraint(MTI *pmti)
    {
    CClosedFormTool::AdjustPointsForConstraint(pmti);
    }

/******************************************************************************/
// ptDown must be anchor point for our line, not where we did mouse button down

void CFreehandSelectTool::PreProcessPoints(MTI *pmti)
    {
    CClosedFormTool::PreProcessPoints(pmti);
    }

/***************************************************************************/

void CFreehandSelectTool::OnPaintOptions ( CDC* pDC,
                                           const CRect& paintRect,
                                           const CRect& optionsRect )
    {
    g_selectTool.OnPaintOptions( pDC, paintRect, optionsRect );
    }

/******************************************************************************/

void CFreehandSelectTool::OnClickOptions ( CImgToolWnd* pWnd,
                                           const CRect& optionsRect,
                                           const CPoint& clickPoint )
    {
    g_selectTool.OnClickOptions(pWnd, optionsRect, clickPoint);
    }

/******************************************************************************/

void CFreehandSelectTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    HideBrush();
    OnActivate( FALSE );
//  CommitSelection( TRUE );

    pImgWnd->EraseTracker();
    theImgBrush.m_bMakingSelection = TRUE;

    // simulate multipt op in progress, until button up or asked.  This will
    // allow us to draw differently for duration and end.
    m_bMultPtOpInProgress = TRUE;

    DeleteArrayContents();

    CClosedFormTool::OnStartDrag( pImgWnd, pmti );
    }

/******************************************************************************/

void CFreehandSelectTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    int iZoom = pImgWnd->GetZoom();

    theImgBrush.m_bMakingSelection = FALSE;
    theImgBrush.m_bMoveSel         = theImgBrush.m_bSmearSel = FALSE;

    OnDrag(pImgWnd, pmti); // one last time to refresh display in prep for final render

    Render( CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, pmti->fLeft, TRUE, pmti->fCtrlDown );

    m_iNumPoints = (int)m_cObArrayPoints.GetSize();

    if (m_iNumPoints > 2)
        if (! CreatePolyRegion( iZoom ))
            return;

    if (pmti->ptDown.x == pmti->pt.x
    &&  pmti->ptDown.y == pmti->pt.y)
        {
        if (m_iNumPoints > 3) // 3 is min points.  If click down/up get 2
            {
            // must fool selectTool.OnEndDrag to think width of selection is
            // greater than 0.  If 0, thinks selection is done/place it (i.e.
            // just clicked down/up.  We only do this if the end point is the
            // same as the beginning point.  This case will have width=height=0,
            // but number of points > 2
            pmti->pt.x++;
            pmti->pt.y++;
            }
        }

    pmti->ptDown = m_cRectBounding.TopLeft();
    pmti->pt     = m_cRectBounding.BottomRight();

    g_selectTool.OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CFreehandSelectTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    // Must set rcPrev to m_cRectBoundingRect prior to calling SetCurrentPoint
    // Since SetCurrentPoint will adjust m_cRectBounding, and we want the
    // previous bounding rect.
    rcPrev = m_cRectBounding;

    if (pmti->pt.x > pImgWnd->m_pImg->cxWidth)
        pmti->pt.x = pImgWnd->m_pImg->cxWidth;

    if (pmti->pt.y > pImgWnd->m_pImg->cyHeight)
        pmti->pt.y = pImgWnd->m_pImg->cyHeight;

    if (pmti->pt.x < 0)
        pmti->pt.x = 0;

    if (pmti->pt.y < 0)
        pmti->pt.y = 0;

    TRY {
        AddPoint(pmti->pt);
        }

    CATCH(CMemoryException,e)
        {
        theApp.SetMemoryEmergency();
        return;
        }
    END_CATCH

    CClosedFormTool::OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/

void CFreehandSelectTool::OnCancel(CImgWnd* pImgWnd)
    {
    // We were not selecting or dragging, just cancel the select tool...
    CommitSelection( TRUE );

    //render one last time to turn off/invert the line if any drawn
        if (theImgBrush.m_bMakingSelection)
        {
                Render( CDC::FromHandle( pImgWnd->m_pImg->hDC ), m_cRectBounding,
                        TRUE, TRUE, FALSE );
        }
    theImgBrush.TopLeftHandle();

    g_bCustomBrush = FALSE;
    theImgBrush.m_pImg             = NULL;
    theImgBrush.m_bMoveSel         = FALSE;
    theImgBrush.m_bSmearSel        = FALSE;
    theImgBrush.m_bMakingSelection = FALSE;

    InvalImgRect( pImgWnd->m_pImg, NULL );

    DeleteArrayContents();

    CPolygonTool::OnCancel(pImgWnd);
    }

/***************************************************************************/

BOOL CFreehandSelectTool::IsToolModal(void)
{
        if (theImgBrush.m_pImg)
        {
                return(TRUE);
        }

        return(CPolygonTool::IsToolModal());
}

/******************************************************************************/

void CFreehandSelectTool::OnActivate(BOOL bActivate)
    {
    g_selectTool.OnActivate(bActivate);
    }

/******************************************************************************/
/* this class really isn't a multipt operation, but is derived from one thus  */
/* we can always end the multipt operation if anyone asks                     */

BOOL CFreehandSelectTool::CanEndMultiptOperation(MTI* pmti )
    {
    m_bMultPtOpInProgress = FALSE;
    return (CClosedFormTool::CanEndMultiptOperation(pmti));
    }

/******************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\tracker.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "sprite.h"
#include "tracker.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#include "memtrace.h"

// FUTURE: Make these static to CTracker!
CBitmap NEAR g_bmapDragHandle;  // Handle for the drag handle bitmap.
CBitmap NEAR g_bmapDragHandle2; // Handle for hollow drag handle bitmap.


// These are the bitmaps arrays used for tracker borders and the dotted
// drag rectangles.
//
static unsigned short bmapHorizBorder[] =
                                { 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0 };

static unsigned short bmapVertBorder [] =
                                { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA };

static CBrush  NEAR brushHorizBorder;
static CBrush  NEAR brushVertBorder;
static CBitmap NEAR bitmapHorizBorder;
static CBitmap NEAR bitmapVertBorder;

static HCURSOR hcurArrow    = NULL;     // System "Select Arrow" cursor.
static HCURSOR hcurMove     = NULL;     // System "Move" cursor.
static HCURSOR hcurSizeNESW = NULL;     // System sizing "NESW" cursor.
static HCURSOR hcurSizeNS   = NULL;     // System sizing "NS" cursor.
static HCURSOR hcurSizeNWSE = NULL;     // System sizing "NWSE" cursor.
static HCURSOR hcurSizeWE   = NULL;     // System sizing "WE" cursor.
static HCURSOR hcurDragTool;


// This array of hCursors is used to map tracker states (see the definition
// of CTracker in editor.hxx) to the appropriate mouse cursor bitmaps.
//
static HCURSOR* mapTrackerStateToPHCursor[] =
    {
    &hcurArrow,                             // nil
    &hcurArrow,                             // predrag
    &hcurMove,                              // moving
    &hcurSizeNS,                            // resizingTop
    &hcurSizeWE,                            // resizingLeft
    &hcurSizeWE,                            // resizingRight
    &hcurSizeNS,                            // resizingBottom
    &hcurSizeNWSE,                          // resizingTopLeft
    &hcurSizeNESW,                          // resizingTopRight
    &hcurSizeNESW,                          // resizingBottomLeft
    &hcurSizeNWSE,                          // resizingBottomRight
    };


HCURSOR HCursorFromTrackerState( int m )
    {
    ASSERT(m >= 0 &&
        m < sizeof (mapTrackerStateToPHCursor) / sizeof (HCURSOR*));
    return (*(mapTrackerStateToPHCursor[m]));
    }


/* RVUV2
 *
 * This code needs to be called, just once, before we begin to use
 * trackers.  In lieu of a standard initialization function into which
 * I can put this code, I am using a moduleInit variable as a kludge.
 */

BOOL moduleInit = FALSE;                    /**  RVUV2 temporary!  **/

BOOL InitTrackers()
    {
    /*
     * Initialize the brushes and bitmaps needed to do repaints
     */

    if (! bitmapHorizBorder.CreateBitmap( 8, 8, 1, 1, (LPSTR)bmapHorizBorder )
    ||  ! bitmapVertBorder.CreateBitmap ( 8, 8, 1, 1, (LPSTR)bmapVertBorder  )
    ||  ! brushHorizBorder.CreatePatternBrush( &bitmapHorizBorder )
    ||  ! brushVertBorder.CreatePatternBrush ( &bitmapVertBorder  )
    ||  ! g_bmapDragHandle.LoadBitmap ( IDBM_DRAGHANDLE )
    ||  ! g_bmapDragHandle2.LoadBitmap( IDBM_DRAGHANDLE2 ))
        {
        // Future: Failure here should cause error in opening dialog resource!
        theApp.SetMemoryEmergency( FALSE );
        return FALSE;
        }

    hcurArrow    = theApp.LoadStandardCursor( IDC_ARROW );
    hcurMove     = theApp.LoadCursor( IDCUR_MOVE     );
    hcurSizeNESW = theApp.LoadCursor( IDCUR_SIZENESW );
    hcurSizeNS   = theApp.LoadCursor( IDCUR_SIZENS   );
    hcurSizeNWSE = theApp.LoadCursor( IDCUR_SIZENWSE );
    hcurSizeWE   = theApp.LoadCursor( IDCUR_SIZEWE   );

    hcurDragTool = ::LoadCursor( AfxGetInstanceHandle(),
                                 MAKEINTRESOURCE( IDC_DRAGTOOL ));

    moduleInit = TRUE;

    return TRUE;
    }

/***************************************************************************/

void CTracker::CleanUpTracker()
    {
    brushHorizBorder.DeleteObject();
    brushVertBorder.DeleteObject();

    bitmapHorizBorder.DeleteObject();
    bitmapVertBorder.DeleteObject();

    g_bmapDragHandle.DeleteObject();
    g_bmapDragHandle2.DeleteObject();
    }

/***************************************************************************/
// NOTE: The rect passed in here is the inner-most rect of the tracker!

CTracker::STATE CTracker::HitTest( const CRect& rc,
                                         CPoint pt,
                                   STATE defaultState )
    {
    /*
     * Compute position of edge (non-corner) handles
     */
    int xMid = ((rc.right + rc.left) / 2) - (HANDLE_SIZE / 2);
    int yMid = ((rc.top + rc.bottom) / 2) - (HANDLE_SIZE / 2);

    /*
     * Now we do the actual hit-testing for each resizing handle
     */
    if ((pt.x < rc.left) && (pt.x > rc.left - HANDLE_SIZE))
        {
        if ((pt.y < rc.top) && (pt.y > rc.top - HANDLE_SIZE))
            return(resizingTopLeft);
        else
            if ((pt.y >= rc.bottom) && (pt.y < rc.bottom + HANDLE_SIZE))
                return(resizingBottomLeft);
            else
                if ( (pt.y >= yMid) && (pt.y < yMid + HANDLE_SIZE) )
                    return(resizingLeft);
        }
    else
        if ((pt.x >= rc.right) && (pt.x < rc.right + HANDLE_SIZE))
            {
            if ((pt.y < rc.top) && (pt.y > rc.top - HANDLE_SIZE))
                return(resizingTopRight);
            else
                if ((pt.y >= rc.bottom) && (pt.y < rc.bottom + HANDLE_SIZE))
                    return(resizingBottomRight);
                else
                    if ((pt.y >= yMid) && (pt.y < yMid + HANDLE_SIZE))
                        return(resizingRight);
            }
        else
            if ( (pt.x >= xMid) && (pt.x < xMid + HANDLE_SIZE) )
                {
                if ((pt.y < rc.top) && (pt.y > rc.top - HANDLE_SIZE))
                    return(resizingTop);
                else
                    if ((pt.y >= rc.bottom) && (pt.y < rc.bottom + HANDLE_SIZE))
                        return(resizingBottom);
                }

    return (defaultState);
    }

/******************************************************************************/

void CTracker::DrawBorder( CDC* dc, const CRect& trackerRect, EDGES edges )
    {
    if (! moduleInit)
        InitTrackers();     // RVUV2

    // Some precalculation for drawing the fuzzy borders
    int width       = trackerRect.Width();
    int height      = trackerRect.Height();
    int borderWidth =                             HANDLE_SIZE;
    int xLength     = width                     - HANDLE_SIZE * 2;
    int xHeight     = height                    - HANDLE_SIZE * 2;
    int xRight      = trackerRect.left + width  - HANDLE_SIZE;
    int yBottom     = trackerRect.top  + height - HANDLE_SIZE;
    int iOffset     = 1;

    // Draw the fuzzy borders.  Note that we have different bitmaps for
    // the vertical and horizontal borders.
    COLORREF windowColor    = GetSysColor( COLOR_WINDOW    );
    COLORREF highlightColor = GetSysColor( COLOR_HIGHLIGHT );

    dc->SetTextColor( windowColor    ); // colors reversed to adjust for
    dc->SetBkColor  ( highlightColor ); // patblt's reversed world view.

    CBrush* oldBrush = dc->SelectObject( &brushHorizBorder );

    if (! (edges & top))
        {
        dc->SelectObject( GetSysBrush( COLOR_APPWORKSPACE ) );
        iOffset = 0;
        }

    dc->PatBlt( trackerRect.left + HANDLE_SIZE, trackerRect.top + iOffset, xLength, borderWidth - 2 * iOffset, PATCOPY );
    dc->PatBlt( trackerRect.left + HANDLE_SIZE,         yBottom + iOffset, xLength, borderWidth - 2 * iOffset, PATCOPY );

    iOffset = 1;

//  dc->SelectObject( &brushVertBorder );

    if (! (edges & left))
        {
        dc->SelectObject( GetSysBrush( COLOR_APPWORKSPACE ) );
        iOffset = 0;
        }

    dc->PatBlt(           xRight + iOffset, trackerRect.top + HANDLE_SIZE, borderWidth - 2 * iOffset, xHeight, PATCOPY );
    dc->PatBlt( trackerRect.left + iOffset, trackerRect.top + HANDLE_SIZE, borderWidth - 2 * iOffset, xHeight, PATCOPY );

    dc->SelectObject( oldBrush );         // clean up
    }

/******************************************************************************/

void CTracker::DrawHandles( CDC* dc, const CRect& rect, EDGES edges )
    {
    /*
     * Some precalculation for tracker handles.  The bitmaps are colored,
     * but the function that loads them adds the windowColor and
     * selectionColor.
     */
    int x = rect.left + rect.Width() - HANDLE_SIZE;
    int y = rect.top + rect.Height() - HANDLE_SIZE;
    int xMid = rect.left + (((rect.Width() + 1) / 2) - (HANDLE_SIZE / 2));
    int yMid = rect.top + (((rect.Height() + 1) / 2) - (HANDLE_SIZE / 2));

    BOOL bTopLeft     = (edges & top   ) && (edges & left );
    BOOL bTopRight    = (edges & top   ) && (edges & right);
    BOOL bBottomLeft  = (edges & bottom) && (edges & left );
    BOOL bBottomRight = (edges & bottom) && (edges & right);
    /*
     * Choose a solid resizing handle if this is the currently selected
     * control, otherwise choose a hollow tracker handle.
     */
    CDC tempDC;

    if (!tempDC.CreateCompatibleDC(dc))
        {
        theApp.SetGdiEmergency();
        return;
        }
    /*
     * Draw the eight resizing handles.
     */
    dc->SetTextColor( GetSysColor( COLOR_HIGHLIGHT ) );
    dc->SetBkColor  ( GetSysColor( COLOR_WINDOW    ) );

    for (int i = 0; i < 2; i += 1)
        {
        CBitmap* pOldBitmap = tempDC.SelectObject( i? &g_bmapDragHandle2
                                                    : &g_bmapDragHandle );
        if (bTopLeft)
            dc->BitBlt(rect.left, rect.top, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & top)
            dc->BitBlt(xMid, rect.top, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (bTopRight)
            dc->BitBlt(x, rect.top, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & right)
            dc->BitBlt(x, yMid, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (bBottomRight)
            dc->BitBlt(x, y, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & bottom)
            dc->BitBlt(xMid, y, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (bBottomLeft)
            dc->BitBlt(rect.left, y, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);
        if (edges & left)
            dc->BitBlt(rect.left, yMid, HANDLE_SIZE, HANDLE_SIZE,
                                             &tempDC, 0, 0, SRCCOPY);

        edges        = (EDGES)~(int)edges;
        bTopLeft     = !bTopLeft;
        bTopRight    = !bTopRight;
        bBottomLeft  = !bBottomLeft;
        bBottomRight = !bBottomRight;

        tempDC.SelectObject(pOldBitmap);
        }
    }

/******************************************************************************/

void CTracker::DrawBorderRgn( CDC* pdc, const CRect& trackerRect, CRgn *pcRgnPoly)
    {
    int ixOffset, iyOffset;

    if (! moduleInit)
        {
        InitTrackers(); // RVUV2
        }

    COLORREF windowColor    = GetSysColor( COLOR_WINDOW );
    COLORREF highlightColor = GetSysColor( COLOR_HIGHLIGHT );

    pdc->SetTextColor( windowColor    ); // colors reversed to adjust for
    pdc->SetBkColor  ( highlightColor ); // patblt's reversed world view.

    ixOffset = trackerRect.left + CTracker::HANDLE_SIZE + 1;
    iyOffset = trackerRect.top  + CTracker::HANDLE_SIZE + 1;

    // offset bitmap in the imgwnd from selection boundary
    if (pcRgnPoly                  != NULL
    &&  pcRgnPoly->GetSafeHandle() != NULL)
        {
        pcRgnPoly->OffsetRgn( ixOffset, iyOffset );

        pdc->FrameRgn( pcRgnPoly, &brushVertBorder, 1, 1 );

        pcRgnPoly->OffsetRgn( -ixOffset, -iyOffset );
        }
    }

/******************************************************************************/

void CTracker::DrawHandlesRgn( CDC* dc, const CRect& rect, EDGES edges, CRgn *pcRgnPoly)
    {
    /*
     * Some precalculation for tracker handles.  The bitmaps are colored,
     * but the function that loads them adds the windowColor and
     * selectionColor.
     */
    }

/******************************************************************************/

CTracker::STATE CTracker::HitTestRgn( const CRect& rc, CPoint pt,
                                   STATE defaultState, CRgn *pcRgnPoly)
    {
//  if (pcRgnPoly->PtInRegion(pt) != FALSE)

    return (defaultState);
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_poly.h ===
#ifndef __T_POLY_H__
#define __T_POLY_H__

#include "imgtools.h"

class CPolygonTool : public CClosedFormTool
    {
    DECLARE_DYNAMIC( CPolygonTool )

    protected:

    CObArray m_cObArrayPoints;
    CRect    m_cRectBounding;
    CImgWnd* m_pImgWnd;
    MTI      m_MTI;

    void DeleteArrayContents ( void );
    void AdjustBoundingRect  ( void );
    BOOL CopyPointsToMemArray( CPoint **pcPoint, int *piNumElements );
    void AddPoint            ( POINT ptNewPoint );
    void SetCurrentPoint     ( POINT ptNewPoint );

    virtual void RenderInProgress         ( CDC* pDC );
    virtual void RenderFinal              ( CDC* pDC );
    virtual BOOL SetupPenBrush            ( HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown );
    virtual void AdjustPointsForConstraint( MTI *pmti );
    virtual void PreProcessPoints         ( MTI *pmti );

    public:

    CPolygonTool();
    ~CPolygonTool();

    virtual void Render        ( CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown );
    virtual void OnEnter       ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnLeave       ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnActivate    ( BOOL bActivate );
    virtual void OnStartDrag   ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag     ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnCancel      ( CImgWnd* pImgWnd );
    virtual void OnUpdateColors( CImgWnd* pImgWnd );

    virtual void EndMultiptOperation   ( BOOL bAbort = FALSE );
    virtual BOOL CanEndMultiptOperation( MTI* pmti );


    friend class CImgWnd;
    };

#endif // __T_POLY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_poly.cpp ===
/******************************************************************************/
/* T_POLY.CPP: IMPLEMENTATION OF THE CPolygonTool CLASS                       */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  Polygon Tool Class Object                                                 */
/*     CPolygonTool::CPolygonTool                                             */
/*     CPolygonTool::~CPolygonTool                                            */
/*     CPolygonTool::DeleteArrayContents                                      */
/*     CPolygonTool::AdjustBoundingRect                                       */
/*     CPolygonTool::CopyPointsToMemArray                                     */
/*     CPolygonTool::AddPoint                                                 */
/*     CPolygonTool::SetCurrentPoint                                          */
/*     CPolygonTool::RenderInProgress                                         */
/*     CPolygonTool::RenderFinal                                              */
/*     CPolygonTool::SetupPenBrush                                            */
/*     CPolygonTool::AdjustPointsForConstraint                                */
/*     CPolygonTool::PreProcessPoints                                         */
/*     CPolygonTool::Render                                                   */
/*     CPolygonTool::OnStartDrag                                              */
/*     CPolygonTool::OnEndDrag                                                */
/*     CPolygonTool::OnDrag                                                   */
/*     CPolygonTool::OnCancel                                                 */
/*     CPolygonTool::CanEndMultiptOperation                                   */
/*     CPolygonTool::EndMultiptOperation                                      */
/******************************************************************************/
/*                                                                            */
/* Briefly, This object stores the points of the polygon in a CObArray of     */
/* CPoint Objects.  For the in progress drawing, it calls PolyLine.  When the */
/* polygon is closed or completed (by the user doubleclicking => asking us to */
/* close it), Polygon is called on the same points.                           */
/*                                                                            */
/* The last point in the array of points is always the point the current line */
/* is being drawn to.  The first time 2 points are added (the Anchor/first    */
/* point, and the point the line is being drawn to) It does happen that this  */
/* first time, they are the same point.  It is necessary that the first time  */
/* 2 points are added, since subsequent times, new points are not added, but  */
/* the last point is reset.                                                   */
/*                                                                            */
/******************************************************************************/
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgwell.h"
#include "t_poly.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CPolygonTool, CClosedFormTool)

#include "memtrace.h"

extern CLineTool NEAR g_lineTool;

CPolygonTool     NEAR g_polygonTool;

extern MTI NEAR mti;

/******************************************************************************/

CPolygonTool::CPolygonTool()
    {
    m_nCmdID              = IDMB_POLYGONTOOL;
    m_cRectBounding.SetRectEmpty();
    m_bMultPtOpInProgress = FALSE;
    m_nStrokeWidth        = 1;
    }

/******************************************************************************/

CPolygonTool::~CPolygonTool()
    {
    m_cRectBounding.SetRectEmpty();
    DeleteArrayContents();
    }

/******************************************************************************/
/* delete all cpoint objects allocated and stored in the array                */
/* also free any memory associated with the array                             */

void CPolygonTool::DeleteArrayContents(void)
    {
    int iSize = (int)m_cObArrayPoints.GetSize();

    CPoint *pcPoint;

    for (int i = 0; i < iSize; i++)
        {
        pcPoint= (CPoint *)m_cObArrayPoints.GetAt( i );
        delete pcPoint;
        }
    m_cObArrayPoints.RemoveAll();
    }

/******************************************************************************/
/* recalculate the bounding rectangle for the polyline/polygon                */

void CPolygonTool::AdjustBoundingRect(void)
    {
    int iSize = (int)m_cObArrayPoints.GetSize();
    CPoint *pcPoint;
    int iStrokeWidth = GetStrokeWidth();
    int i;

    if (iSize >= 1)
        {
        pcPoint= (CPoint*)m_cObArrayPoints.GetAt( 0 );
        //set the rect to equal the 1st value
        m_cRectBounding.SetRect(pcPoint->x, pcPoint->y, pcPoint->x, pcPoint->y);
        }

    for (i = 1; i < iSize; i++)
        {
        pcPoint = (CPoint *)m_cObArrayPoints.GetAt( i );

        m_cRectBounding.SetRect( min( pcPoint->x, m_cRectBounding.left   ),
                                 min( pcPoint->y, m_cRectBounding.top    ),
                                 max( pcPoint->x, m_cRectBounding.right  ),
                                 max( pcPoint->y, m_cRectBounding.bottom ) );
        }
    // Adjust for width of current drawing line/border
    m_cRectBounding.OffsetRect ( -(iStrokeWidth / 2), -(iStrokeWidth / 2) );
    m_cRectBounding.InflateRect(   iStrokeWidth     ,   iStrokeWidth);
    }

/******************************************************************************/
/* This method will copy the CObArray structure of CPoints to a contiguous    */
/* memory block of CPoint Structures                                          */

BOOL CPolygonTool::CopyPointsToMemArray(CPoint **pcPoint, int *piNumElements)
    {
    BOOL bRC = TRUE;
    int i;
    int iSize = (int)m_cObArrayPoints.GetSize();

    if (! iSize)
        {
        *piNumElements = 0;
        *pcPoint = NULL;
        return TRUE;
        }
    TRY
        {
        *pcPoint = new CPoint[iSize];

        if (*pcPoint == NULL)
            {
            AfxThrowMemoryException();
            }

        for (i=0; i < iSize; i++)
            {
            (*pcPoint)[i] = *((CPoint*) (m_cObArrayPoints[i]));
            }

        *piNumElements = iSize;
        }

    CATCH(CMemoryException,e)
        {
        *piNumElements = 0;
        bRC = FALSE;
        }

    END_CATCH

    return bRC;
    }

/******************************************************************************/
/* This routine can Throw a CMemoryException!!                                */
/* It adds a new point to the end of the array, possibly increasing the size  */

void CPolygonTool::AddPoint(POINT ptNewPoint)
    {

    CPoint *pcPoint;

    pcPoint = new CPoint(ptNewPoint);
    if (pcPoint == NULL)
        {
        AfxThrowMemoryException();
        }

    m_cObArrayPoints.Add((CObject *)pcPoint);
    AdjustBoundingRect();
    }

/******************************************************************************/
/* This method changes the value of the last point in the array.  It does not */
/* remove the point and add a new one.  It just modifies it in place          */

void CPolygonTool::SetCurrentPoint(POINT ptNewPoint)
    {
    int iLast = (int)m_cObArrayPoints.GetUpperBound();

    if (iLast >= 0)
        {
        CPoint *pcPoint = (CPoint *) m_cObArrayPoints[iLast];

        pcPoint->x = ptNewPoint.x;
        pcPoint->y = ptNewPoint.y;

        AdjustBoundingRect();
        }
    }

/******************************************************************************/
/* Render In Progress is called for all drawing during the multi-pt operation */
/* The only difference between this method and RenderFinal is that it calls   */
/* polyline and RenderFinal calls polygon.                                    */

void CPolygonTool::RenderInProgress(CDC* pDC)
    {

    CPoint *pcPointArray = 0;
    int     iNumElements;



    if (CopyPointsToMemArray( &pcPointArray, &iNumElements ) && pcPointArray != NULL)
        {
        pDC->Polyline(pcPointArray, iNumElements);

        delete [] pcPointArray;
        }
    }

/******************************************************************************/
/* Render Final is called at the end of the multi-pt drawing mode.  The only  */
/* difference between this method and RenderInProgress is that it calls       */
/* polygon and RenderInProgress calls polyline.                               */

void CPolygonTool::RenderFinal(CDC* pDC)
    {

    CPoint *pcPointArray = 0;
    int     iNumElements;


    if (CopyPointsToMemArray(&pcPointArray, &iNumElements) && pcPointArray != NULL)
        {
        // Remove RIP with only 2 points
        if (iNumElements > 2)
            pDC->Polygon(pcPointArray, iNumElements);
        delete [] pcPointArray;
        }

    }

/******************************************************************************/
/* This routine is called before rendering onto the DC.  It basically, calls  */
/* the default setup to setup the pen and brush, and then overrides the Pen if*/
/* drawing in progress and drawing without any border.  This case is necessary*/
/* since if you do not have a border, you need to see something during the in */
/* progress drawing mode.  It uses the inverse (not) of the screen color as   */
/* the border in this mode.                                                   */

BOOL CPolygonTool::SetupPenBrush(HDC hDC, BOOL bLeftButton, BOOL bSetup, BOOL bCtrlDown)
    {
    static int  iOldROP2Code;
    static BOOL bCurrentlySetup = FALSE;

    BOOL bRC = CClosedFormTool::SetupPenBrush(hDC, bLeftButton, bSetup, bCtrlDown);

    // for multipt operations in progress (e.g. drawing outline, not fill yet
    // if there is no border, use the not of the screen color for the border.
    // When bMultiptopinprogress == FALSE, final drawing, we will use a null
    // pen and thus have no border.
    if (m_bMultPtOpInProgress)
        {
        if (bSetup)
            {
            if (! bCurrentlySetup)
               {
               bCurrentlySetup = TRUE;

               // if no border, draw inprogress border as inverse of screen color
               if (! m_bBorder)
                   iOldROP2Code = SetROP2(hDC, R2_NOT);
               }
            else
                // Error: Will lose allocated Brush/Pen
                bRC = FALSE;
            }
        else
            {
            if (bCurrentlySetup)
                {
                bCurrentlySetup = FALSE;

                // if no border, restore drawing mode
                if (! m_bBorder)
                    SetROP2(hDC, iOldROP2Code);
                }
            else
                // Error: Cannot Free/cleanup Brush/Pen -- Never allocated.
                bRC = FALSE;
            }
        }

    return bRC;
    }

/******************************************************************************/
/* Call the line's adjustpointsforconstraint member function                  */
void CPolygonTool::AdjustPointsForConstraint(MTI *pmti)
    {
    g_lineTool.AdjustPointsForConstraint(pmti);
    }

/******************************************************************************/
// ptDown must be anchor point for our line, not where we did mouse button down

void CPolygonTool::PreProcessPoints(MTI *pmti)
    {
    int iLast = (int)m_cObArrayPoints.GetUpperBound();

    if (iLast > 0)
        iLast--;

    CPoint* pcPoint;

    if (iLast >= 0)
        {
        pcPoint = (CPoint *)m_cObArrayPoints[iLast];
        pmti->ptDown = *pcPoint;
        }
    CClosedFormTool::PreProcessPoints(pmti);
    }

/******************************************************************************/
/* Render sets up the pen and brush, and then calls either RenderInProgress   */
/* or RenderFinal.  RenderInProgress is called if in the middle of a multipt  */
/* operation, and RenderFinal is called when a multipt operation is complete  */
/* The pen and brush is set up exactly the same as the parent routine in      */
/* CRubberTool */

void CPolygonTool::Render(CDC* pDC, CRect& rect, BOOL bDraw, BOOL bCommit, BOOL bCtrlDown)
    {
    // Setup Pen/Brush
    SetupPenBrush(pDC->m_hDC, bDraw, TRUE, bCtrlDown);

    if (m_bMultPtOpInProgress)
        {
        RenderInProgress(pDC);
        }
    else
        {
        RenderFinal(pDC);
        }
    // Cleanup Pen/Brush
    SetupPenBrush(pDC->m_hDC, bDraw,  FALSE, bCtrlDown);

    // Need to return the bounding rect
    rect = m_cRectBounding;
    }

/******************************************************************************/

void CPolygonTool::OnActivate( BOOL bActivate )
    {
    if (! bActivate && m_bMultPtOpInProgress)
        {
        if (m_pImgWnd != NULL)
            if (m_cObArrayPoints.GetSize() > 1)
                {
                OnStartDrag( m_pImgWnd, &m_MTI );
                OnEndDrag  ( m_pImgWnd, &m_MTI );

                m_MTI.ptPrev = m_MTI.pt;

                EndMultiptOperation(); // end the multipt operation

                OnEndDrag( m_pImgWnd, &m_MTI );

                mti.fLeft  = FALSE;
                mti.fRight = FALSE;
                }
            else
                OnCancel( m_pImgWnd );
        else
            EndMultiptOperation( TRUE );
        }
    m_pImgWnd = NULL;

        if (bActivate)
        {
                m_nStrokeWidth = g_nStrokeWidth;
        }
        else
        {
                g_nStrokeWidth = m_nStrokeWidth;
        }

    CImgTool::OnActivate( bActivate );
    }

/******************************************************************************/

void CPolygonTool::OnEnter( CImgWnd* pImgWnd, MTI* pmti )
    {
    m_pImgWnd = NULL;
    }

/******************************************************************************/

void CPolygonTool::OnLeave( CImgWnd* pImgWnd, MTI* pmti )
    {
    m_pImgWnd = pImgWnd;
    }

/******************************************************************************/
/* On Start Drag is called on mouse button down.  We basically call on Start  */
/* Drag of the parent (default) class after adding in our point(s) into the   */
/* array of points.  If this is the first point (i.e. bMultiptOpInProgress == */
/* False, then we need 2 points in our array, and we can call the default     */
/* OnStartDrag.  If it is not the first point, then we just add the new point */
/* and call our OnDrag.  In either case, OnDrag is called which eventually    */
/* calls render to do our drawing on the mouse down                           */

void CPolygonTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    TRY {
        if (m_bMultPtOpInProgress)
            {
            CRect rect;

            CPoint pt = pmti->pt;

            pImgWnd->ImageToClient( pt );
            pImgWnd->GetClientRect( &rect );

            if (rect.PtInRect( pt ))
                {
                AddPoint( pmti->pt );
                OnDrag( pImgWnd, pmti );
                }
            }
        else
            {
            DeleteArrayContents();
            m_cRectBounding.SetRectEmpty();

            AddPoint( pmti->pt );
            // must set m_bmultptopinprogress prior to calling onstartdrag
            // since that calls render,and render will call renderinprogress
            // or renderfinal depending on the sate of this variable.
            m_bMultPtOpInProgress = TRUE;
            // No Mult Pt In Progress => 1st Click
            //
            // add a 2nd point, last point is what we are draing to
            // 1st point is anchor.  1st time, need 2 points to draw a line
            // subsequent times, just re-use last point as anchor and only one
            // more point is added (above outside test for m_bmultptopinprogress)
            AddPoint( pmti->pt );
            CClosedFormTool::OnStartDrag( pImgWnd, pmti );
            }
        }

    CATCH(CMemoryException,e)
        {
        }

    END_CATCH
    }

/******************************************************************************/
/* On End Drag is sent on a mouse button up.  This basically is a clone of the*/
/* CRubberTool::OnEndDrag method, except that we use our bounding rect for all*/
/* the image invalidation, and commit, and undo function calls.               */
/* if we are in the middle of a multipoint operation, we do not want to call  */
/* all the routines to fix the drawing (e.g. invalImgRect, CommitImgRect,     */
/* FinishUndo).  We just want to save the current point, render, and return   */

void CPolygonTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints(pmti);
    SetCurrentPoint(pmti->pt);

    if (m_bMultPtOpInProgress)
        {
        m_MTI = *pmti;
        // can't call OnDrag for this object/class, since it calls preprocesspt
        // again, and then onDrag.  If you call preproces again, you will lose
        // bounding rectange box prev, and not be able to invalidate / repaint
        // Still have to invalidate bounding rect, since if rect is larger than
        // current rect, must invalidate to paint. E.g. If let off shift, then
        // let off button, end point would be adjusted and bouning rect would
        // also be correct, but rect calculated in CClosedFormTool::OnDrag is
        // incorrect.
        InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);

        CClosedFormTool::OnDrag(pImgWnd, pmti);
        return;
        }


    if (! m_cObArrayPoints.GetSize())
        return;

    OnDrag(pImgWnd, pmti); // one last time to refresh display in prep for final render
    Render(CDC::FromHandle(pImgWnd->m_pImg->hDC), m_cRectBounding, pmti->fLeft, TRUE, pmti->fCtrlDown);
    InvalImgRect(pImgWnd->m_pImg, &m_cRectBounding);
    CommitImgRect(pImgWnd->m_pImg, &m_cRectBounding);
    pImgWnd->FinishUndo(m_cRectBounding);

    ClearStatusBarSize();

    CImgTool::OnEndDrag(pImgWnd, pmti);
    }

/******************************************************************************/
/* On Drag is sent when the mouse is moved with the button down.  We basically*/
/* save the current point, and call the base class processing.  Since the base*/
/* class processing invalidates the rect on the screen and cleans it up so we */
/* can paint a new line, we have to adjust the previous rectangle to be the   */
/* bounding rectangle of our polyline.  If we did not do this, our previous   */
/* drawing would not get erased, and we would be drawing our new line over    */
/* part of the previous line.  The default processing finally calls Render    */
/* which since our render is virtual, will call our render method above.      */

void CPolygonTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    PreProcessPoints    ( pmti     );
    SetCurrentPoint     ( pmti->pt );
    SetStatusBarPosition( pmti->pt );
    SetStatusBarSize    ( m_cRectBounding.Size() );

    CClosedFormTool::OnDrag(pImgWnd, pmti);
    }

/******************************************************************************/
/* On Cancel is sent when the user aborts an operation while in progress      */
/* EndMultiptOperation with TRUE will do all our cleanup                      */

void CPolygonTool::OnCancel(CImgWnd* pImgWnd)
    {
    InvalImgRect( pImgWnd->m_pImg, &m_cRectBounding );
    EndMultiptOperation(TRUE);
    CClosedFormTool::OnCancel(pImgWnd);
    }

/******************************************************************************/
/* If point is on 1st point (i.e. closes the polygon) then can end is true    */
// Use the stroke width to determine the width of the line and whether the    */
/* end point touches the beginning point because of the line thickness        */

BOOL CPolygonTool::CanEndMultiptOperation(MTI* pmti )
    {
    CPoint *pcPoint = (CPoint *) m_cObArrayPoints[0];

    CSize cSizeDiff = (*pcPoint) - pmti->pt;

    int iStrokeWidth = GetStrokeWidth() * 2;

    m_bMultPtOpInProgress = ! ((abs( cSizeDiff.cx ) <= iStrokeWidth)
                            && (abs( cSizeDiff.cy ) <= iStrokeWidth));
    return ( TRUE );
    }

/******************************************************************************/
/* If bAbort is true, this means an error occurred, or the user cancelled the */
/* multipoint operation in the middle of it.  We need to clean up the         */
/* allocated memory in our array of points.                                   */

void CPolygonTool::EndMultiptOperation( BOOL bAbort )
    {
    if (bAbort)
        {
        DeleteArrayContents();
        }

    CClosedFormTool::EndMultiptOperation();
    }

/******************************************************************************/

void CPolygonTool::OnUpdateColors( CImgWnd* pImgWnd )
    {
    if (m_cObArrayPoints.GetSize() && m_bMultPtOpInProgress)
        {
        OnStartDrag( pImgWnd, &m_MTI );
        OnEndDrag  ( pImgWnd, &m_MTI );
        }
    }

/******************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\undo.cpp ===
#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "bmobject.h"
#include "undo.h"
#include "props.h"
#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CUndoBmObj, CBitmapObj)

#include "memtrace.h"

CUndoBmObj NEAR theUndo;

static BOOL m_bFlushAtEnd;

/////////////////////////////////////////////////////////////////////////////
//
// A CBmObjSequence is a packed array of slob property changes or custom
// actions.  Each record contains a property or action id, a pointer to
// a slob, a property type, and a value (depending on the type).
//
// These sequences are used to store undo/redo information in theUndo.
// Each undo/redo-able thing is contained in one CBmObjSequence.
//


CBmObjSequence::CBmObjSequence() : CByteArray(), m_strDescription()
    {
    SetSize(0, 100); // increase growth rate
    m_nCursor = 0;
    }

CBmObjSequence::~CBmObjSequence()
    {
    Cleanup();
    }

// Pull an array of bytes out of the sequence.
//
void CBmObjSequence::Retrieve( BYTE* rgb, int cb )
    {
    for (int ib = 0; ib < cb; ib += 1)
        *rgb++ = GetAt(m_nCursor++);
    }

// Pull a string out the sequence.

void CBmObjSequence::RetrieveStr( CString& str )
    {
    int nStrLen;
    RetrieveInt(nStrLen);
    if (nStrLen == 0)
        {
        str.Empty();
        }
    else
        {
        BYTE* pb = (BYTE*)str.GetBufferSetLength(nStrLen);
        for (int nByte = 0; nByte < nStrLen; nByte += 1)
            *pb++ = GetAt(m_nCursor++);
        str.ReleaseBuffer(nStrLen);
        }
    }

// Traverse the sequence and remove any slobs that are contained within.
//
void CBmObjSequence::Cleanup()
    {
    m_nCursor = 0;

    while (m_nCursor < GetSize())
        {
        BYTE op;
        CBitmapObj* pSlob;
        int nPropID;

        RetrieveByte(op);

        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        switch (op)
            {
            default:
                TRACE1("Illegal undo opcode (%d)\n", op);
                ASSERT(FALSE);

            case CUndoBmObj::opAction:
                {
                int cbUndoRecord;
                RetrieveInt(cbUndoRecord);
                int ib = m_nCursor;
                pSlob->DeleteUndoAction(this, nPropID);
                m_nCursor = ib + cbUndoRecord;
                }
                break;

            case CUndoBmObj::opIntProp:
            case CUndoBmObj::opBoolProp:
                {
                int val;
                RetrieveInt(val);
                }
                break;

            case CUndoBmObj::opLongProp:
                {
                long val;
                RetrieveLong(val);
                }
                break;

            case CUndoBmObj::opDoubleProp:
                {
                double num;
                RetrieveNum(num);
                }
                break;

            case CUndoBmObj::opStrProp:
                {
                CString str;
                RetrieveStr(str);
                }
                break;

            case CUndoBmObj::opSlobProp:
                {
                CBitmapObj* pSlobVal;
                RetrievePtr(pSlobVal);
                }
                break;

            case CUndoBmObj::opRectProp:
                {
                CRect rcVal;
                RetrieveRect(rcVal);
                }
                break;

            case CUndoBmObj::opPointProp:
                {
                CPoint ptVal;
                RetrievePoint(ptVal);
                }
                break;
            }
        }
    }


// Start looking right after the begin op for ops we really need to keep.
// If none are found, the entire record is discarded below.  (For now, we
// only throw away records that are empty or consist only of selection
// change ops.)
//
BOOL CBmObjSequence::IsUseful(CBitmapObj*& pLastSlob, int& nLastPropID)
    {
    m_nCursor = 0;
    while (m_nCursor < GetSize() && GetAt(m_nCursor) == CUndoBmObj::opAction)
        {
        BYTE op;
        int nAction, cbActionRecord;
        CBitmapObj* pSlob;

        RetrieveByte(op);
        ASSERT(op == CUndoBmObj::opAction);
        RetrievePtr(pSlob);
        RetrieveInt(nAction);
        RetrieveInt(cbActionRecord);

        if (nAction != A_PreSel && nAction != A_PostSel)
            {
            // Back cursor up to the opcode...
            m_nCursor -= sizeof (int) * 2 + sizeof (CBitmapObj*) + 1;
            break;
            }

        m_nCursor += cbActionRecord;
        }

    if (m_nCursor == GetSize())
        return FALSE; // sequnce consists only of selection changes


    // Now check if we should throw this away because it's just
    // modifying the same string or rectangle property as the last
    // undoable operation...  This is an incredible hack to implement
    // a "poor man's" Multiple-Consecutive-Changes-to-a-Property-as-
    // One-Operation feature.

    BYTE op;
    RetrieveByte(op);

    if (op == CUndoBmObj::opStrProp || op == CUndoBmObj::opRectProp)
        {
        CBitmapObj* pSlob;
        int nPropID;

        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        nLastPropID = nPropID;
        pLastSlob = pSlob;
        }

    m_nCursor = 0;
    return TRUE;
    }


// Perform the property changes and actions listed in the sequence.
//
void CBmObjSequence::Apply()
    {
    m_nCursor = 0;
    while (m_nCursor < GetSize())
        {
        BYTE op;
        CBitmapObj* pSlob;
        int nPropID;

        RetrieveByte(op);
        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        switch (op)
            {
            default:
                TRACE1("Illegal undo opcode (%d)\n", op);
                ASSERT(FALSE);

            case CUndoBmObj::opAction:
                pSlob->UndoAction(this, nPropID);
                break;

            case CUndoBmObj::opIntProp:
            case CUndoBmObj::opBoolProp:
                {
                int val;
                RetrieveInt(val);
                pSlob->SetIntProp(nPropID, val);
                }
                break;
            }
        }
    }

/////////////////////////////////////////////////////////////////////////////



CUndoBmObj::CUndoBmObj() : m_seqs()
    {
    ASSERT(this == &theUndo); // only one of these is allowed!

    m_nRecording = 0;
    m_cbUndo = 0;
    m_nMaxLevels = 2;
    m_pLastSlob = NULL;
    m_nLastPropID = 0;
    m_nPauseLevel = 0;
    m_nRedoSeqs = 0;
    }


CUndoBmObj::~CUndoBmObj()
    {
    Flush();
    }


// Set the maximum number of sequences that can be held at once.
//
void CUndoBmObj::SetMaxLevels(int nLevels)
    {
    if (nLevels < 1)
        return;

    m_nMaxLevels = nLevels;
    Truncate();
    }


// Returns the maximum number of sequences that can be held at once.
//
int CUndoBmObj::GetMaxLevels() const
    {
    return m_nMaxLevels;
    }


// Call this to after a sequence is recorded to prevent the next
// sequence from being coalesced with it.
//
void CUndoBmObj::FlushLast()
    {
    m_pLastSlob = NULL;
    m_nLastPropID = 0;
    }


// Call this at the start of an undoable user action.  Calls may be nested
// as long as each call to BeginUndo is balanced with a call to EndUndo.
// Only the "outermost" calls actually have any affect on the undo buffer.
//
// The szCmd parameter should contain the text that you want to appear
// after "Undo" in the Edit menu.
//
// The bResetCursor parameter is only used internally to modify behaviour
// when recording redo sequences and you should NOT pass anything for this
// parameter.
//
void CUndoBmObj::BeginUndo(const TCHAR* szCmd, BOOL bResetCursor)
    {
#ifdef _DEBUG
    if (theApp.m_bLogUndo)
        TRACE2("BeginUndo: %s (%d)\n", szCmd, m_nRecording);
#endif

    // Handle nesting
    m_nRecording += 1;
    if (m_nRecording != 1)
        return;

    if (bResetCursor) // this is the default case
        {
        // Disable Redo for non-Undo/Redo commands...
        while (m_nRedoSeqs > 0)
            {
            delete m_seqs.GetHead();
            m_seqs.RemoveHead();
            m_nRedoSeqs -= 1;
            }
        }

    m_pCurSeq = new CBmObjSequence;
    m_pCurSeq->m_strDescription = szCmd;

    m_bFlushAtEnd = FALSE;
    }

// In most cases, this overloaded function will be called.  It takes a
// resource ID instead of a char*, allowing easier internationalization
//
void CUndoBmObj::BeginUndo(const UINT idCmd, BOOL bResetCursor)
    {
    CString strCmd;
    VERIFY(strCmd.LoadString(idCmd));

    BeginUndo(strCmd, bResetCursor);
    }


// Call this at the end of an undoable user action to cause the sequence
// since the BeginUndo to be stored in the undo buffer.
//
void CUndoBmObj::EndUndo()
    {
#ifdef _DEBUG
    if (theApp.m_bLogUndo)
        TRACE1("EndUndo: %d\n", m_nRecording - 1);
#endif

    ASSERT(m_nRecording > 0);

    // Handle nesting
    m_nRecording -= 1;
    if (m_nRecording != 0)
        return;

    if (!m_pCurSeq->IsUseful(m_pLastSlob, m_nLastPropID))
        {
        // Remove empty or otherwise useless undo records!
        delete m_pCurSeq;
        m_pCurSeq = NULL;
        return;
        }

    // We'll keep it, add it to the list...
    if (m_nRedoSeqs > 0)
        {
        // Add AFTER any redo sequences we have but before any undo's
        POSITION pos = m_seqs.FindIndex(m_nRedoSeqs - 1);
        ASSERT(pos != NULL);
        m_seqs.InsertAfter(pos, m_pCurSeq);
        }
    else
        {
        // Just add before any other undo sequences
        m_seqs.AddHead(m_pCurSeq);
        }
    m_pCurSeq = NULL;

    Truncate(); // Make sure the undo buffer doesn't get too big!

    if (m_bFlushAtEnd)
        Flush();
    }


// This functions ensures there aren't too many levels in the buffer.
//
void CUndoBmObj::Truncate()
    {
    POSITION pos = m_seqs.FindIndex(m_nRedoSeqs + m_nMaxLevels);
    while (pos != NULL)
        {
#ifdef _DEBUG
    if (theApp.m_bLogUndo)
        TRACE(TEXT("Undo record fell off the edge...\n"));
#endif
        POSITION posRemove = pos;
        delete m_seqs.GetNext(pos);
        m_seqs.RemoveAt(posRemove);
        }
    }


// Call this to perform an undo command.
//
void CUndoBmObj::DoUndo()
    {
    CWaitCursor waitCursor;

    if (m_nRedoSeqs == m_seqs.GetCount())
        return; // nothing to undo!

    m_bPerformingUndoRedo = TRUE;

    POSITION pos = m_seqs.FindIndex(m_nRedoSeqs);
    ASSERT(pos != NULL);
    CBmObjSequence* pSeq = (CBmObjSequence*)m_seqs.GetAt(pos);

    BeginUndo(pSeq->m_strDescription, FALSE); // Setup Redo

    // Remove this sequence after BeginUndo so the one inserted
    // there goes to the right place...
    m_seqs.RemoveAt(pos);

    pSeq->Apply();

    FlushLast();
    EndUndo();
    FlushLast();

    m_bPerformingUndoRedo = FALSE;

    delete pSeq;

    // Do not bump the redo count if the undo flushed the buffer!  (This
    // happens when a resource is pasted/dropped, then opened, then a
    // property in it changes, and the user undoes back to before the
    // paste.)
    if (m_seqs.GetCount() != 0)
        m_nRedoSeqs += 1;


    }


// Call this to perform a redo command.
//
void CUndoBmObj::DoRedo()
    {
    if (m_nRedoSeqs == 0)
        return; // nothing in redo buffer

    m_nRedoSeqs -= 1;
    DoUndo();

    // Do not drop the redo count if the undo flushed the buffer!  (This
    // happens when a resource is pasted/dropped, then opened, then a
    // property in it changes, and the user undoes back to before the
    // paste.)
    if (m_seqs.GetCount() != 0)
        m_nRedoSeqs -= 1;
    }


// Generate a string appropriate for the undo menu command.
//
void CUndoBmObj::GetUndoString(CString& strUndo)
    {
    static CString NEAR strUndoTemplate;

    if (strUndoTemplate.IsEmpty())
        VERIFY(strUndoTemplate.LoadString(IDS_UNDO));

    CString strUndoCmd;

    if (CanUndo())
        {
        POSITION pos = m_seqs.FindIndex(m_nRedoSeqs);
        strUndoCmd = ((CBmObjSequence*)m_seqs.GetAt(pos))->m_strDescription;
        }

    int cchUndo = strUndoTemplate.GetLength() - 2; // less 2 for "%s"
    wsprintf(strUndo.GetBufferSetLength(cchUndo + strUndoCmd.GetLength()),
             strUndoTemplate, (const TCHAR*)strUndoCmd);
    }


// Generate a string appropriate for the redo menu command.
//
void CUndoBmObj::GetRedoString(CString& strRedo)
    {
    static CString NEAR strRedoTemplate;

    if (strRedoTemplate.IsEmpty())
        VERIFY(strRedoTemplate.LoadString(IDS_REDO));

    CString strRedoCmd;

    if (CanRedo())
        {
        POSITION pos = m_seqs.FindIndex(m_nRedoSeqs - 1);
        strRedoCmd = ((CBmObjSequence*)m_seqs.GetAt(pos))->m_strDescription;
        }

    int cchRedo = strRedoTemplate.GetLength() - 2; // less 2 for "%s"
    wsprintf(strRedo.GetBufferSetLength(cchRedo + strRedoCmd.GetLength()),
        strRedoTemplate, (const TCHAR*)strRedoCmd);
    }


// Call this to completely empty the undo buffer.
//
void CUndoBmObj::Flush()
    {
    PreTerminateList(&m_seqs);

    m_cbUndo = 0;
    m_nRedoSeqs = 0;

    m_bFlushAtEnd = TRUE;
    }


void CUndoBmObj::OnInform(CBitmapObj* pChangedSlob, UINT idChange)
    {
    if (idChange == SN_DESTROY)
        {
        // When a slob we have a reference to is deleted (for real), we
        // have no choice but to flush the whole buffer...  This normally
        // only happens when a resource editor window is closed...  (If
        // the slob's container is the undo buffer, then we are already
        // in the process of flushing, so don't recurse!)

        Flush();
        }

    CBitmapObj::OnInform(pChangedSlob, idChange);
    }


//
// The following functions are used by the CBitmapObj code to insert commands
// into the undo/redo sequence currently being recorded.  All of the On...
// functions are used to record changes to the various types of properties
// and are called by the CBitmapObj::Set...Prop functions exclusively.
//


// Insert an array of bytes.
//
UINT CUndoBmObj::Insert(const void* pv, int cb)
    {
    ASSERT(m_pCurSeq != NULL);

    BYTE* rgb = (BYTE*)pv;

    m_pCurSeq->InsertAt(0, 0, cb);

    for (int ib = 0; ib < cb; ib += 1)
        m_pCurSeq->SetAt(ib, *rgb++);

    return cb;
    }


// Insert a string.
//
UINT CUndoBmObj::InsertStr(const TCHAR* sz)
    {
    ASSERT(m_pCurSeq != NULL);

    BYTE* pb = (BYTE*)sz;
    int nStrLen = lstrlen(sz);

    InsertInt(nStrLen);
    if (nStrLen > 0)
        {
        m_pCurSeq->InsertAt(sizeof (int), 0, nStrLen);
        for (int nByte = 0; nByte < nStrLen; nByte += 1)
            m_pCurSeq->SetAt(sizeof (int) + nByte, *pb++);
        }
    return nStrLen + sizeof (int);
    }


void CUndoBmObj::OnSetIntProp(CBitmapObj* pChangedSlob, UINT nPropID, UINT nOldVal)
        {
    ASSERT(m_nRecording != 0);

    CIntUndoRecord undoRecord;
    undoRecord.m_op = opIntProp;
    undoRecord.m_pBitmapObj = pChangedSlob;
    undoRecord.m_nPropID = nPropID;
    undoRecord.m_nOldVal = nOldVal;
    Insert(&undoRecord, sizeof (undoRecord));
    pChangedSlob->AddDependant(this);
    }

#ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
// Undo related debugging aids
//

void CBmObjSequence::Dump()
    {
    m_nCursor = 0;
    while (m_nCursor < GetSize())
        {
        BYTE op;
        CBitmapObj* pSlob;
        int nPropID;

        RetrieveByte(op);
        RetrievePtr(pSlob);
        RetrieveInt(nPropID);

        switch (op)
            {
        default:
            TRACE1("Illegal undo opcode (%d)\n", op);
            ASSERT(FALSE);

        case CUndoBmObj::opAction:
                {
                int cbUndoRecord;
                RetrieveInt(cbUndoRecord);
                m_nCursor += cbUndoRecord;

                TRACE3("opAction: pSlob = 0x%08lx, nActionID = %d, "
                    TEXT("nBytes = %d\n"), pSlob, nPropID, cbUndoRecord);
                }
            break;

        case CUndoBmObj::opIntProp:
        case CUndoBmObj::opBoolProp:
                {
                int val;
                RetrieveInt(val);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %d\n",
                    pSlob, nPropID, val);
                }
            break;

        case CUndoBmObj::opLongProp:
                {
                long val;
                RetrieveLong(val);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %ld\n",
                    pSlob, nPropID, val);
                }
            break;

        case CUndoBmObj::opDoubleProp:
                {
                double num;
                RetrieveNum(num);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, val = %f\n",
                    pSlob, nPropID, num);
                }
            break;

        case CUndoBmObj::opStrProp:
                {
                CString str;
                RetrieveStr(str);
                if (str.GetLength() > 80)
                    {
                    str = str.Left(80);
                    str += TEXT("...");
                    }
                TRACE3("opStr: pSlob = 0x%08lx, nPropID = %d, val = %s\n",
                    pSlob, nPropID, (const TCHAR*)str);
                }
            break;

        case CUndoBmObj::opSlobProp:
                {
                CBitmapObj* pSlobVal;
                RetrievePtr(pSlobVal);
                TRACE3("opInt: pSlob = 0x%08lx, nPropID = %d, "
                    TEXT("val = 0x%08lx\n"), pSlob, nPropID, pSlobVal);
                }
            break;

        case CUndoBmObj::opRectProp:
                {
                CRect rcVal;
                RetrieveRect(rcVal);
                TRACE3("opRect: pSlob = 0x%08lx, nPropID = %d, "
                    TEXT("val = %d,%d,%d,%d\n"), pSlob, nPropID, rcVal);
                }
            break;

        case CUndoBmObj::opPointProp:
                {
                CPoint ptVal;
                RetrievePoint(ptVal);
                TRACE3("opPoint: pSlob = 0x%08lx, nPropID = %d, "
                    TEXT("val = %d,%d,%d,%d\n"), pSlob, nPropID, ptVal);
                }
            break;
            }
        }
    }


void CUndoBmObj::Dump()
    {
    int nRecord = 0;
    POSITION pos = m_seqs.GetHeadPosition();
    while (pos != NULL)
        {
        CBmObjSequence* pSeq = (CBmObjSequence*)m_seqs.GetNext(pos);
        TRACE2("Record (%d) %s:\n", nRecord,
            nRecord < m_nRedoSeqs ? TEXT("redo") : TEXT("undo"));
        pSeq->Dump();
        nRecord += 1;
        }
    }


extern "C" void DumpUndo()
    {
    theUndo.Dump();
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\undo.h ===
#ifndef __UNDO_H__
#define __UNDO_H__


// A CBmObjSequence holds the codes for one undo or redo operation.
class CBmObjSequence : public CByteArray
    {
    public:

     CBmObjSequence();
    ~CBmObjSequence();

    void Retrieve(BYTE* rgb, int cb);
    void RetrieveStr(CString& str);

    inline void RetrieveByte(BYTE& b)     { Retrieve(&b, 1); }
    inline void RetrieveInt(int& n)       { Retrieve((BYTE*)&n  , sizeof (int)); }
    inline void RetrieveLong(long& n)     { Retrieve((BYTE*)&n  , sizeof (long)); }
    inline void RetrieveNum(double& num)  { Retrieve((BYTE*)&num, sizeof (double)); }
    inline void RetrievePtr(CBitmapObj*& ptr)  { Retrieve((BYTE*)&ptr, sizeof (CBitmapObj*)); }
    inline void RetrieveRect(CRect& rc)   { Retrieve((BYTE*)&rc , sizeof (rc)); }
    inline void RetrievePoint(CPoint& pt) { Retrieve((BYTE*)&pt , sizeof (pt)); }

    void Cleanup();
    BOOL IsUseful(CBitmapObj*&, int&);
    void Apply();

    #ifdef _DEBUG
    void Dump();
    #endif

    int m_nCursor;
    CString m_strDescription;
    };


class CUndoBmObj : public CBitmapObj
    {
    DECLARE_DYNAMIC(CUndoBmObj)

    public:
     CUndoBmObj();
    ~CUndoBmObj();

    void BeginUndo(const TCHAR* szCmd, BOOL bResetCursor = TRUE);
    void BeginUndo(const UINT idCmd, BOOL bResetCursor = TRUE);
    void EndUndo();

    inline BOOL CanUndo() const
            { return m_nRedoSeqs < m_seqs.GetCount(); }

    inline BOOL CanRedo() const
            { return m_nRedoSeqs > 0; }

    inline BOOL InUndoRedo() const
            { return m_bPerformingUndoRedo; }

    void GetUndoString(CString& strUndo);
    void GetRedoString(CString& strRedo);

    void DoUndo();
    void DoRedo();

    void SetMaxLevels(int nLevels);
    int  GetMaxLevels() const;

    void OnSetIntProp( CBitmapObj* pChangedSlob, UINT nPropID, UINT nOldVal );

    #ifdef _DEBUG
    void Dump();
    #endif

    inline BOOL IsRecording() { return m_nRecording != 0 && m_nPauseLevel == 0; }

    inline void Pause() { m_nPauseLevel += 1; }

    inline void Resume() { ASSERT(m_nPauseLevel > 0); m_nPauseLevel -= 1; }

    enum
        {
        // Note correspondence with PRD
        opStart,
        opEnd,
        opAction,
        opIntProp,
        opLongProp,
        opBoolProp,
        opDoubleProp,
        opStrProp,
        opSlobProp,
        opRectProp,
        opPointProp
        };

    UINT Insert(const void* rgb, int cb);
    UINT InsertStr(const TCHAR* sz);

    inline UINT InsertByte(BYTE b) { return Insert(&b, 1); }
    inline UINT InsertInt(int n) { return Insert((BYTE*)&n, sizeof (int)); }
    inline UINT InsertLong(long n) { return Insert((BYTE*)&n, sizeof (long)); }
    inline UINT InsertNum(double num) { return Insert((BYTE*)&num, sizeof (double)); }
    inline UINT InsertPtr(const void* ptr)
                {
                if (ptr != NULL)
                    {
                    ASSERT(((CObject*)ptr)->IsKindOf(RUNTIME_CLASS(CBitmapObj)));
                    ((CBitmapObj*)ptr)->AddDependant(this);
                    }
                return Insert((BYTE*)&ptr, sizeof (CBitmapObj*));
                }
    inline UINT InsertRect(const CRect& rc) { return Insert((BYTE*)&rc, sizeof (CRect)); }
    inline UINT InsertPoint(const CPoint& pt) { return Insert((BYTE*)&pt, sizeof (CPoint)); }

    void Flush();

    void OnInform(CBitmapObj* pChangedSlob, UINT idChange);

    void FlushLast();

    private:

    void Truncate();

    int m_nRecording; // BeginUndo() nesting count
    int m_nPauseLevel; // Pause() nesting count

    int m_cbUndo;

    // These ?Last* variables are used to coalesce consecutive changes
    // to the same property...
    CBitmapObj* m_pLastSlob;
    int m_nLastPropID;

    // Properties...
    int m_nMaxLevels;

    CObList m_seqs; // pointers to CBmObjSequences
    int m_nRedoSeqs;
    CBmObjSequence* m_pCurSeq;

    BOOL m_bPerformingUndoRedo;

    friend class CBmObjSequence;
    };


#pragma pack(1)

class CUndoRecord
    {
    public:

    BYTE m_op;
    CBitmapObj* m_pBitmapObj;
    UINT m_nPropID;
    };


class CIntUndoRecord : public CUndoRecord
    {
    public:

    int m_nOldVal;
    };


class CLongUndoRecord : public CUndoRecord
    {
    public:

    long m_nOldVal;
    };


class CDoubleUndoRecord : public CUndoRecord
    {
    public:

    double m_numOldVal;
    };


class CRectUndoRecord : public CUndoRecord
    {
    public:

    CRect m_rectOldVal;
    };


class CPointUndoRecord : public CUndoRecord
    {
    public:

    CPoint m_ptOldVal;
    };


class CBitmapObjUndoRecord : public CUndoRecord
    {
    public:

    const CBitmapObj* m_pOldVal;
    };

#pragma pack()

extern CUndoBmObj NEAR theUndo;

#endif // __UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_text.h ===
#ifndef __T_TEXT_H__
#define __T_TEXT_H__

#include "imgtools.h"

#define MAX_MOVE_DIST_FOR_PLACE 10 // min pixels to move before not considered a place operation

class CTextTool : public CSelectTool
    {
    DECLARE_DYNAMIC( CTextTool )

    protected:

    class CTedit* m_pCTedit;

    void CreateTextEditObject( CImgWnd* pImgWnd, MTI* pmti );
    void PlaceTextOnBitmap   ( CImgWnd* pImgWnd );

    public:

    CTextTool();
    ~CTextTool();

    virtual void OnUpdateColors( CImgWnd* pImgWnd );
    virtual void OnActivate    ( BOOL bActivate );
    virtual void OnCancel      ( CImgWnd* pImgWnd );
    virtual void OnStartDrag   ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnEndDrag     ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnDrag        ( CImgWnd* pImgWnd, MTI* pmti );
    virtual void OnClickOptions( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                    const CPoint& clickPoint );
    virtual void OnShowControlBars(BOOL bShow);

    BOOL    IsSlectionVisible () { return ( m_pCTedit != NULL ); }
    CTedit* GetTextEditField  () { return m_pCTedit; }
    BOOL    FontPaletteVisible();
    void    ToggleFontPalette ();
    void    CloseTextTool     ( CImgWnd* pImgWnd );
    };

#endif // __T_TEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\mspaint\t_text.cpp ===
/******************************************************************************/
/* T_TEXT.CPP: IMPLEMENTATION OF THE CTextTool CLASS                        */
/*                                                                            */
/*                                                                            */
/******************************************************************************/
/*                                                                            */
/* Methods in this file                                                       */
/*                                                                            */
/*  CText Tool Class Object                                                   */
/*     CTextTool::CTextTool                                                   */
/*     CTextTool::~CTextTool                                                  */
/*     CTextTool::CreateTextEditObject                                        */
/*     CTextTool::PlaceTextOnBitmap                                           */
/*     CTextTool::OnUpdateColors                                              */
/*     CTextTool::OnCancel                                                    */
/*     CTextTool::OnStartDrag                                                 */
/*     CTextTool::OnEndDrag                                                   */
/*     CTextTool::OnDrag                                                      */
/*     CTextTool::OnClickOptions                                              */
/******************************************************************************/
/*                                                                            */
/* This is the Text edit tool.  It creates a tedit class object when the user */
/* is done dragging the selection for the size desired.                       */
/*                                                                            */
/* The Once a text object window exist, it is either cancelled or placed      */
/* according to the following rules.                                          */
/*                                                                            */
/* Cancel Rules                                                               */
/* - During a Drag, if the user drags more than MAX_MOVE_DIST_FOR_PLACE       */
/* - At the End of a Drag, if the user lets up the mouse more than            */
/*      MAX_MOVE_DIST_FOR_PLACE pixels from where they did the mosue down     */
/* - If the user selects anohter tool (in imgtools, select processing, see    */
/*      CImgTool::Select()).                                                  */
/*                                                                            */
/* Place Rules                                                                */
/* - At the End of a Drag, if the user lets up the mouse less than or equal   */
/*      to MAX_MOVE_DIST_FOR_PLACE pixels from where they did the mosue down  */
/*                                                                            */
/* Also, during the time the edit control object is visible/exists, the scroll*/
/* bars are disabled.                                                         */
/*                                                                            */
/******************************************************************************/

#include "stdafx.h"
#include "global.h"
#include "pbrush.h"
#include "pbrusdoc.h"
#include "pbrusfrm.h"
#include "pbrusvw.h"
#include "docking.h"
#include "minifwnd.h"
#include "bmobject.h"
#include "imgsuprt.h"
#include "imgwnd.h"
#include "imgbrush.h"
#include "imgwell.h"
#include "pictures.h"
#include "tfont.h"
#include "tedit.h"
#include "t_Text.h"

#ifdef _DEBUG
#undef THIS_FILE
static CHAR BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CTextTool, CSelectTool )

#include "memtrace.h"

CTextTool NEAR g_TextTool;

/******************************************************************************/

CTextTool::CTextTool()
    {
    m_nCmdID         = IDMX_TEXTTOOL;
    m_pCTedit        = NULL;
    m_bIsUndoable    = TRUE;
    m_bCanBePrevTool = FALSE;
    }

/******************************************************************************/

CTextTool::~CTextTool()
    {
    }

/******************************************************************************/
/* Creates the CTedit class object with the appropriate attributes and        */
/* dissables the scroll bars on the bitmap window                             */

void CTextTool::CreateTextEditObject( CImgWnd* pImgWnd, MTI* pmti )
    {
    c_selectRect.SetRect( 0, 0, 0, 0 );

    if (pImgWnd         == NULL
    ||  pImgWnd->m_pImg == NULL)
        return;

    BOOL  bBackTransparent;
    CRect cRectTextBox;

    if (pmti->ptDown.x > pmti->pt.x)
        {
        cRectTextBox.left  = pmti->pt.x;
        cRectTextBox.right = pmti->ptDown.x;
        }
    else
        {
        cRectTextBox.left  = pmti->ptDown.x;
        cRectTextBox.right = pmti->pt.x;
        }

    if (pmti->ptDown.y > pmti->pt.y)
        {
        cRectTextBox.top    = pmti->pt.y;
        cRectTextBox.bottom = pmti->ptDown.y;
        }
    else
        {
        cRectTextBox.top    = pmti->ptDown.y;
        cRectTextBox.bottom = pmti->pt.y;
        }

    if (cRectTextBox.left   < 0)
        cRectTextBox.left   = 0;
    if (cRectTextBox.top    < 0)
        cRectTextBox.top    = 0;
    if (cRectTextBox.right  > pImgWnd->m_pImg->cxWidth  - 1)
        cRectTextBox.right  = pImgWnd->m_pImg->cxWidth  - 1;
    if (cRectTextBox.bottom > pImgWnd->m_pImg->cyHeight - 1)
        cRectTextBox.bottom = pImgWnd->m_pImg->cyHeight - 1;

    CRect rectImg;

    pImgWnd->GetClientRect( &rectImg );
    pImgWnd->ClientToImage(  rectImg );

    if (cRectTextBox.left   < rectImg.left)
        cRectTextBox.left   = rectImg.left;
    if (cRectTextBox.top    < rectImg.top )
        cRectTextBox.top    = rectImg.top;
    if (cRectTextBox.right  > rectImg.right)
        cRectTextBox.right  = rectImg.right - 1;
    if (cRectTextBox.bottom > rectImg.bottom)
        cRectTextBox.bottom = rectImg.bottom -1;

    bBackTransparent = ! theImgBrush.m_bOpaque;

    pImgWnd->ImageToClient( cRectTextBox );

    m_pCTedit = new CTedit;

    if (m_pCTedit != NULL
    &&  m_pCTedit->Create( pImgWnd, crLeft, crRight, cRectTextBox, bBackTransparent ))
        {
        SetupRubber( pImgWnd->m_pImg );

        pImgWnd->EnableScrollBar( SB_BOTH, ESB_DISABLE_BOTH );
        }
    else
        {
        TRACE( TEXT("Create Edit Window Failed!\n") );

        theApp.SetMemoryEmergency();
        }
    }

/******************************************************************************/
/* Places the image of the text edit control on the bitmap                    */
/* Then it deletes the text edit control, and re-enables the scroll bars      */

void CTextTool::PlaceTextOnBitmap( CImgWnd* pImgWnd )
    {
    if (m_pCTedit->IsModified())
        {
        CRect cRectClient;
        CDC*  pDC = CDC::FromHandle(pImgWnd->m_pImg->hDC);

        m_pCTedit->GetClientRect ( &cRectClient );
        m_pCTedit->ClientToScreen( &cRectClient );
        pImgWnd->ScreenToClient  ( &cRectClient );
        pImgWnd->ClientToImage   (  cRectClient );
        m_pCTedit->GetBitmap( pDC, &cRectClient );

        InvalImgRect ( pImgWnd->m_pImg, &cRectClient );
        CommitImgRect( pImgWnd->m_pImg, &cRectClient );

        pImgWnd->FinishUndo( cRectClient );

        DirtyImg( pImgWnd->m_pImg );
        }
    m_pCTedit->DestroyWindow();
    m_pCTedit = NULL;

    pImgWnd->EnableScrollBar( SB_BOTH, ESB_ENABLE_BOTH );
    }

/******************************************************************************/
/* updates the foreground and background colors                               */

void CTextTool::OnUpdateColors( CImgWnd* pImgWnd )
    {
    if (m_pCTedit != NULL)
        {
        m_pCTedit->SetTextColor( crLeft  );
        m_pCTedit->SetBackColor( crRight );
        }
    }

/******************************************************************************/

void CTextTool::OnActivate( BOOL bActivate )
    {
    if (bActivate)
        {
                // Disallow activation if Zoomed.
        if (CImgWnd::GetCurrent()->GetZoom() > 1 )
            {
            ::MessageBeep( MB_ICONASTERISK );

                        SelectPrevious();
            }
        }
    else
        {
        if (CWnd::GetCapture() != CImgWnd::c_pImgWndCur && m_pCTedit != NULL &&
                IsWindow(m_pCTedit->m_hWnd) )
            {
            CAttrEdit* pEdit = m_pCTedit->GetEditWindow();

            if (pEdit != NULL && IsWindow(pEdit->m_hWnd) && pEdit->GetWindowTextLength() > 0)
                PlaceTextOnBitmap( CImgWnd::c_pImgWndCur );
            else
                {
                m_pCTedit->DestroyWindow();
                m_pCTedit = NULL;
                InvalImgRect( CImgWnd::c_pImgWndCur->m_pImg, NULL ); // redraw selection

                CImgWnd::c_pImgWndCur->EnableScrollBar( SB_BOTH, ESB_ENABLE_BOTH );
                }
            }
        }
    CImgTool::OnActivate( bActivate );
    }

/******************************************************************************/
/* Deletes the text edit control, and refreshes the bitmap display, while     */
/* also re-enabling the scroll bars                                           */

void CTextTool::OnCancel(CImgWnd* pImgWnd)
    {
    if (m_pCTedit != NULL)
        {
        m_pCTedit->DestroyWindow();
        m_pCTedit = NULL;
        }

    InvalImgRect( pImgWnd->m_pImg, NULL );  // redraw selection

    pImgWnd->EnableScrollBar( SB_BOTH, ESB_ENABLE_BOTH );

    CImgTool::OnCancel( pImgWnd );
    }

/******************************************************************************/

void CTextTool::OnStartDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    CImgTool::OnStartDrag( pImgWnd, pmti );
    OnDrag( pImgWnd, pmti );
    }

/******************************************************************************/
/* if a text edit object does not exist, it creates one here.  If one does    */
/* exist, it checks the distance between the point down and point up.  If     */
/* less than or equal to MAX_MOVE_DIST_FOR_PLACE it places the bitmap, else   */
/* it assumes the user wants to abort the prior text editing session, and     */
/* destroys the prior text edit control and creates a new one with the newly  */
/* created dragged coordinate box (ptdown and ptup).                          */

void CTextTool::OnEndDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    CSize cPtDownUpDistance = pmti->ptDown - pmti->pt;

    // if the text box exists on a button up, was the button up close enough
    // to the button down to decide to place instead of throw away and
    // create a new text edit box.
    if (m_pCTedit != NULL)
        {
        PlaceTextOnBitmap( pImgWnd );

        int iDist = max( (abs( cPtDownUpDistance.cx )),
                         (abs( cPtDownUpDistance.cy )) );

        if (iDist <= MAX_MOVE_DIST_FOR_PLACE)
            {
            ClearStatusBarSize();
            CImgTool::OnEndDrag( pImgWnd, pmti );
            }
        else
            CreateTextEditObject( pImgWnd, pmti );
        }
    else // m_pCTedit == NULL either 1st time or destroyed, since on drag moved more than MAX_MOVE_DIS_FOR_PLACE
        {
        CreateTextEditObject( pImgWnd, pmti );
        }
    }

/******************************************************************************/

void CTextTool::OnDrag( CImgWnd* pImgWnd, MTI* pmti )
    {
    CPoint ptNew( pmti->pt.x, pmti->pt.y );
    CRect rectImg;

    pImgWnd->GetClientRect( &rectImg );
    pImgWnd->ClientToImage(  rectImg );

    if (! rectImg.PtInRect( ptNew ))
        {
        if (ptNew.x < rectImg.left)
            ptNew.x = rectImg.left;
        if (ptNew.x > rectImg.right)
            ptNew.x = rectImg.right;
        if (ptNew.y < rectImg.top)
            ptNew.y = rectImg.top;
        if (ptNew.y > rectImg.bottom)
            ptNew.y = rectImg.bottom;

        pmti->pt = ptNew;
        }
    CSelectTool::OnDrag( pImgWnd, pmti );
    }

/******************************************************************************/
/* Set the text edit tool  window's options for transparent or opaque         */

void CTextTool::OnClickOptions( CImgToolWnd* pWnd, const CRect& optionsRect,
                                                   const CPoint& clickPoint )
    {
    CSelectTool::OnClickOptions( pWnd, optionsRect, clickPoint );

    if (m_pCTedit != NULL)
        m_pCTedit->SetTransparentMode( ! theImgBrush.m_bOpaque );
    }

/******************************************************************************/
/* report to the rest of the program if the font palette is showin            */

BOOL CTextTool::FontPaletteVisible()
    {
    return (m_pCTedit? m_pCTedit->IsFontPaletteVisible(): FALSE);
    }

/******************************************************************************/
/* toggle the visable state of the Font Palette                               */

void CTextTool::ToggleFontPalette()
    {
    if (m_pCTedit)
        m_pCTedit->ShowFontPalette( m_pCTedit->IsFontPaletteVisible()? SW_HIDE: SW_SHOW );
    }

/******************************************************************************/

void CTextTool::OnShowControlBars(BOOL bShow)
{
        if (m_pCTedit == NULL)
        {
                return;
        }

        if (bShow)
        {
                if (!theApp.m_bShowTextToolbar)
                {
                        return;
                }

                m_pCTedit->ShowFontToolbar();
        }
        else
        {
                m_pCTedit->HideFontToolbar();
        }
}

/******************************************************************************/

void CTextTool::CloseTextTool( CImgWnd* pImgWnd )
    {
    if (! m_pCTedit)
        return;

        if ( IsWindow(pImgWnd->m_hWnd) )
                {
            if (! m_pCTedit->IsModified())
                {
                OnCancel( pImgWnd );
                return;
                }

            if (pRubberImg != pImgWnd->m_pImg)
                SetupRubber( pImgWnd->m_pImg );

                //  SetUndo( pImgWnd->m_pImg );

            PlaceTextOnBitmap( pImgWnd );

            pImgWnd->UpdateWindow();
                }
    }

/******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\notepad.h ===
/* Notepad.h */

#pragma warning(disable: 4201) // nonstd extension: nameless struct/union
#pragma warning(disable:4127) // conditional expression is constant
#define NOCOMM
#define NOSOUND
#define STRICT
#include <windows.h>
#include <ole2.h>
#include <commdlg.h>
#include <commctrl.h>

// we need this for CharSizeOf(), ByteCountOf(),
#include "uniconv.h"

/* handy debug macro */
#define ODS OutputDebugString

#define CP_UTF16     1200
#define CP_UTF16BE   1201
#define CP_AUTO      65536             // Internal to notepad

#define BOM_UTF8_HALF        0xBBEF
#define BOM_UTF8_2HALF       0xBF


/* openfile filter for all text files */
#define FILE_TEXT         1
#define FILE_ENCODED      4


typedef enum WB
{
   wbDefault,                          // New file or loaded from encoding without BOM
   wbNo,                               // BOM was not present
   wbYes,                              // BOM was not present
} WB;


/* ID for the status window */
#define ID_STATUS_WINDOW     WM_USER+1



#define PT_LEN               40    /* max length of page setup strings */
#define CCHFILTERMAX         256   /* max. length of filter name buffers */

// Menu IDs 
#define ID_APPICON           1 /* must be one for explorer to find this */
#define ID_ICON              2
#define ID_MENUBAR           1

// Dialog IDs

#define IDD_ABORTPRINT           11
#define IDD_PAGESETUP            12
#define IDD_SAVEDIALOG           13    // template for save dialog
#define IDD_GOTODIALOG           14    // goto line number dialog
#define IDD_SELECT_ENCODING      15    // Select Encoding dialog
#define IDD_SAVE_UNICODE_DIALOG  16    //

// Control IDs 

#define IDC_CODEPAGE         257   // listbox in save dialog
#define IDC_GOTO             258   // line number to goto
#define IDC_ENCODING         259   // static text in save dialog
#define IDC_SAVE_AS_UNICODE  260

//  Menu IDs 

// File
#define M_NEW                1
#define M_OPEN               2
#define M_SAVE               3
#define M_SAVEAS             4
#define M_PAGESETUP          5
#define M_PRINT              6
#define M_EXIT               7

// Edit
#define M_UNDO               16
#define M_CUT                WM_CUT       /* These just get passed down to the edit control */
#define M_COPY               WM_COPY
#define M_PASTE              WM_PASTE
#define M_CLEAR              WM_CLEAR
#define M_FIND               21
#define M_FINDNEXT           22
#define M_REPLACE            23
#define M_GOTO               24
#define M_SELECTALL          25
#define M_DATETIME           26
#define M_STATUSBAR          27

// Format
#define M_WW                 32
#define M_SETFONT            33

// Help
#define M_HELP               64
#define M_ABOUT              65

// Control IDs

#define ID_EDIT              15
#define ID_FILENAME          20
#define ID_PAGENUMBER        21


#define ID_HEADER            30
#define ID_FOOTER            31
#define ID_HEADER_LABEL      32
#define ID_FOOTER_LABEL      33

#define ID_ASCII             50
#define ID_UNICODE           51


// IDs used to load RC strings

#define IDS_DISKERROR         1
#define IDS_FNF               2
#define IDS_SCBC              3
#define IDS_UNTITLED          4
#define IDS_NOTEPAD           5
#define IDS_CFS               6
#define IDS_ERRSPACE          7
#define IDS_FTL               8
#define IDS_NN                9
#define IDS_COMMDLGINIT      10
#define IDS_PRINTDLGINIT     11
#define IDS_CANTPRINT        12
#define IDS_NVF              13
#define IDS_CREATEERR        14
#define IDS_NOWW             15
#define IDS_MERGE1           16
#define IDS_HELPFILE         17
#define IDS_HEADER           18
#define IDS_FOOTER           19

#define IDS_TEXTFILES        20
#define IDS_HTMLFILES        21
#define IDS_XMLFILES         22
#define IDS_ENCODEDTEXT      23
#define IDS_ALLFILES         24

#define IDS_MOREENCODING     25

#define IDS_CANNOTQUIT       28
#define IDS_LOADDRVFAIL      29
#define IDS_ACCESSDENY       30

#define IDS_FONTTOOBIG       31
#define IDS_COMMDLGERR       32

#define IDS_LINEERROR        33  /* line number error     */
#define IDS_LINETOOLARGE     34  /* line number too large */
#define IDS_INVALIDCP        35  /* invalid codepage */
#define IDS_INVALIDIANA      36  /* invalid encoding */
#define IDS_ENCODINGMISMATCH 37

#define IDS_CURRENT_PAGE     38  /* currently printing page on abort dlg */

// constants for the status bar
#define IDS_LINECOL          39
#define IDS_COMPRESSED_FILE  40
#define IDS_ENCRYPTED_FILE   41
#define IDS_HIDDEN_FILE      42
#define IDS_OFFLINE_FILE     43
#define IDS_READONLY_FILE    44
#define IDS_SYSTEM_FILE      45
#define IDS_FILE             46

#define IDS_NOSTATUSAVAIL    47  

#define CCHKEYMAX           128  /* max characters in search string */

#define CCHNPMAX              0  /* no limit on file size */

#define SETHANDLEINPROGRESS   0x0001 /* EM_SETHANDLE has been sent */
#define SETHANDLEFAILED       0x0002 /* EM_SETHANDLE caused EN_ERRSPACE */

/* Standard edit control style:
 * ES_NOHIDESEL set so that find/replace dialog doesn't undo selection
 * of text while it has the focus away from the edit control.  Makes finding
 * your text easier.
 */
#define ES_STD (WS_CHILD|WS_VSCROLL|WS_VISIBLE|ES_MULTILINE|ES_NOHIDESEL)

/* EXTERN decls for data */

extern BOOL fCase;                /* Flag specifying case sensitive search */
extern BOOL fReverse;             /* Flag for direction of search */
extern TCHAR szSearch[];
extern HWND hDlgFind;             /* handle to modeless FindText window */

extern HANDLE hEdit;
extern HANDLE hFont;
extern HANDLE hAccel;
extern HANDLE hInstanceNP;
extern HANDLE hStdCursor, hWaitCursor;
extern HWND   hwndNP, hwndEdit, hwndStatus;

extern LOGFONT  FontStruct;
extern INT      iPointSize;

extern BOOL     fRunBySetup;

extern DWORD    dwEmSetHandle;

extern TCHAR    chMerge;

extern BOOL     fWrap;
extern TCHAR    szFileOpened[];
extern HANDLE   fp;

//
// Holds header and footer strings to be used in printing.
// use HEADER and FOOTER to index.
//
extern TCHAR    chPageText[2][PT_LEN]; // header and footer strings
#define HEADER 0
#define FOOTER 1
//
// Holds header and footer from pagesetupdlg during destroy.
// if the user hit ok, then keep.  Otherwise ignore.
//
extern TCHAR    chPageTextTemp[2][PT_LEN];

extern TCHAR    szNotepad[];
extern TCHAR   *szMerge;
extern TCHAR   *szUntitled, *szNpTitle, *szNN, *szErrSpace;
extern TCHAR  **const rgsz[];     /* More strings. */
extern TCHAR   *szNVF;
extern TCHAR   *szPDIE;
extern TCHAR   *szDiskError;
extern TCHAR   *szCREATEERR;
extern TCHAR   *szWE;
extern TCHAR   *szFTL;
extern TCHAR   *szINF;
extern TCHAR   *szFNF;
extern TCHAR   *szNEDSTP;
extern TCHAR   *szNEMTP;
extern TCHAR   *szCFS;
extern TCHAR   *szPE;
extern TCHAR   *szCP;
extern TCHAR   *szACCESSDENY;
extern TCHAR   *szFontTooBig;
extern TCHAR   *szLoadDrvFail;
extern TCHAR   *szCommDlgErr;
extern TCHAR   *szCommDlgInitErr;
extern TCHAR   *szInvalidCP;
extern TCHAR   *szInvalidIANA;
extern TCHAR   *szEncodingMismatch;
extern TCHAR   *szHelpFile;

extern TCHAR   *szCurrentPage;
extern TCHAR   *szHeader;
extern TCHAR   *szFooter;

/* variables for the new File/Open and File/Saveas dialogs */
extern OPENFILENAME OFN;        /* passed to the File Open/save APIs */
extern TCHAR  szOpenFilterSpec[]; /* default open filter spec          */
extern TCHAR  szSaveFilterSpec[]; /* default save filter spec          */

extern TCHAR *szTextFiles;      /* File/Open TXT filter spec. string */
extern TCHAR *szHtmlFiles;      /* File/Open HTML filter spec. string */
extern TCHAR *szXmlFiles;       /* File/Open XML filter spec. string */
extern TCHAR *szEncodedText;    /* File/Open TXT Filter spec. string */
extern TCHAR *szAllFiles;       /* File/Open Filter spec. string */
extern TCHAR *szMoreEncoding;

extern FINDREPLACE FR;          /* Passed to FindText()        */
extern PAGESETUPDLG g_PageSetupDlg;
extern TCHAR szPrinterName[];   /* name of the printer passed to PrintTo */

extern UINT g_cpANSI;           /* system ANSI codepage (GetACP())   */
extern UINT g_cpOEM;            /* system OEM codepage (GetOEMCP())  */
extern UINT g_cpUserLangANSI;   /* user UI language ANSI codepage    */
extern UINT g_cpUserLangOEM;    /* user UI language OEM codepage     */
extern UINT g_cpUserLocaleANSI; /* user default LCID ANSI codepage   */
extern UINT g_cpUserLocaleOEM;  /* user default LCID OEM codepage    */
extern UINT g_cpKeyboardANSI;   /* keyboard ANSI codepage            */
extern UINT g_cpKeyboardOEM;    /* keyboard OEM codepage             */

extern BOOL g_fSelectEncoding;  /* Prompt for encoding by default    */
extern UINT g_cpDefault;        /* codepage default                  */
extern UINT g_cpOpened;         /* codepage of open file             */
extern UINT g_cpSave;           /* codepage in which to save         */
extern WB   g_wbOpened;         /* BOM was present when opened       */
extern WB   g_wbSave;           /* BOM should be saved               */
extern BOOL g_fSaveEntity;      /* Entities should be saved          */

extern UINT   wFRMsg;           /* message used in communicating     */
                                /*   with Find/Replace dialog        */
extern UINT   wHlpMsg;          /* message used in invoking help     */

extern HMENU hSysMenuSetup;     /* Save Away for disabled Minimize   */
extern BOOL  fStatus;
extern INT   dyStatus;


/* Macro for setting status bar - x is the text to set and n is the part number
   in the statusbar */
#define SetStatusBarText(x, n) if(hwndStatus)SendMessage(hwndStatus, SB_SETTEXT, n, (LPARAM)(LPTSTR)(x));



/* EXTERN procs */
/* procs in notepad.c */
VOID
PASCAL
SetPageSetupDefaults(
    VOID
    );

BOOL far PASCAL SaveAsDlgHookProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

LPCTSTR PFileInPath(LPCTSTR szFile);

BOOL CheckSave(BOOL fSysModal);
LRESULT NPWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FUntitled(void);
const TCHAR *SzTitle(void);
void SetFileName(LPCTSTR szFile);
INT AlertBox(HWND hwndParent, LPCTSTR szCaption, LPCTSTR szText1,
                   LPCTSTR szText2, UINT style);
void NpWinIniChange(VOID);
void FreeGlobalPD(void);
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SaveUnicodeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SelectEncodingDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
VOID CALLBACK WinEventFunc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject,
                      LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime);
VOID GotoAndScrollInView( INT OneBasedLineNumber );
void NPSize (int cxNew, int cyNew);


/* procs in npcss.c */
BOOL FDetectCssEncodingA(LPCSTR rgch, UINT cch, UINT *pcp);
BOOL FDetectCssEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp);

/* procs in npdate.c */
VOID InsertDateTime (BOOL fCrlf);

/* procs in npfile.c */
BOOL SaveFile(HWND hwndParent, LPCTSTR szFile, BOOL fSaveAs);
BOOL LoadFile(LPCTSTR szFile, BOOL fSelectEncoding);
VOID New(BOOL fCheck);
void AddExt(TCHAR *sz);
void AlertUser_FileFail(LPCTSTR szFile);
BOOL FDetectEncodingW(LPCTSTR szFile, LPCWSTR rgch, UINT cch, UINT *pcp);

/* procs in nphtml.c */
BOOL FDetectHtmlEncodingA(LPCSTR rgch, UINT cch, UINT* pcp);
BOOL FDetectHtmlEncodingW(LPCWSTR rgch, UINT cch, UINT* pcp);

/* procs in npinit.c */
INT NPInit(HANDLE hInstance, HANDLE hPrevInstance, LPTSTR lpCmdLine, INT cmdShow);
void GetKeyboardCodepages(LANGID);
void GetUserLocaleCodepages(void);
void InitLocale(VOID);
void SaveGlobals(VOID);

/* procs in npmisc.c */
INT FindDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL Search(TCHAR *szSearch);
INT AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL NpReCreate(LONG style);
LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive);

/* procs in npmlang.c */
UINT ConvertFromUnicode(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, LPSTR rgchMbcs, UINT cchMbcs, BOOL *pfDefCharUsed);
UINT ConvertToUnicode(UINT cp, LPCSTR rgchMbcs, UINT cchMbcs, LPWSTR rgchUtf16, UINT cchUtf16);
BOOL FDetectEncodingA(LPCSTR rgch, UINT cch, UINT* pcp);
BOOL FLookupCodepageNameA(LPCSTR rgchEncoding, UINT cch, UINT* pcp);
BOOL FLookupCodepageNameW(LPCWSTR rgchEncoding, UINT cch, UINT* pcp);
BOOL FSupportWriteEntities(UINT cp);
BOOL FValidateCodepage(HWND hwnd, UINT cp);
void PopulateCodePages(HWND hWnd, BOOL fSelectEncoding, UINT cpSelect, UINT cpExtra);
void UnloadMlang();

/* procs in npprint.c */
typedef enum _PRINT_DIALOG_TYPE {
   UseDialog,
   DoNotUseDialog,
   NoDialogNonDefault
} PRINT_DIALOG_TYPE;

INT    AbortProc( HDC hPrintDC, INT reserved );
INT_PTR AbortDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT    NpPrint( PRINT_DIALOG_TYPE type );
INT    NpPrintGivenDC( HDC hPrintDC );

UINT_PTR
CALLBACK
PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

HANDLE GetPrinterDC (VOID);
HANDLE GetNonDefPrinterDC (VOID);
VOID   PrintIt(PRINT_DIALOG_TYPE type);


/* procs in nputf.c */

INT    IsTextUTF8   (LPSTR lpstrInputStream, INT iLen);
INT    IsInputTextUnicode(LPSTR lpstrInputStream, INT iLen);


/* procs in nxpml.c */
BOOL FDetectXmlEncodingA(LPCSTR rgch, UINT cch, UINT *pcp);
BOOL FDetectXmlEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp);
BOOL FIsXmlW(LPCWSTR rgwch, UINT cch);


// Help IDs for Notepad

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_PAGE_FOOTER                 1000
#define IDH_PAGE_HEADER                 1001
#define IDH_FILETYPE                    1002
#define IDH_GOTO                        1003
#define IDH_CODEPAGE                    1004

// Private message to track the HKL switch

#define PWM_CHECK_HKL                   (WM_APP + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\notepad.c ===
/*
 *   Notepad application
 *   Copyright (C) 1984-2000 Microsoft Corporation
 */


#include "precomp.h"
#include <htmlhelp.h>

#define DeepTrouble() MessageBox(hwndNP, szErrSpace, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONSTOP);

UINT     lGotoLine;                  /* line number to goto to */

TCHAR    chMerge;
HWND     hwndNP = 0;                 /* handle to notepad parent window   */
HWND     hwndStatus = 0;             /* handle to notepad status window   */
HWND     hwndEdit = 0;               /* handle to main text control item  */
HANDLE   hEdit;                      /* Handle to storage for edit item   */
HWND     hDlgFind = NULL;            /* handle to modeless FindText window */
HANDLE   hStdCursor;                 /* handle to arrow or beam cursor    */
HANDLE   hWaitCursor;                /* handle to hour glass cursor       */
HANDLE   hInstanceNP;                /* Module instance handle            */
HANDLE   hFont;                      /* handle to Unicode font            */
LOGFONT  FontStruct;                 /* font dialog structure             */
INT      iPointSize=120;             /* current point size unit=1/10 pts  */
TCHAR    szFileOpened[MAX_PATH+1];     /* Current notepad filename          */
TCHAR    szSearch[CCHKEYMAX];        /* Search string                     */
TCHAR    szReplace[CCHKEYMAX];       /* replace string                    */

BOOL     fStatus = FALSE;            /* status bar shown?                 */
INT      dyStatus;                   /* height of status bar              */


HMENU    hSysMenuSetup;              /* Save Away for disabled Minimize   */

DWORD    dwEmSetHandle = 0;          /* Is EM_SETHANDLE in process?       */
HANDLE   hAccel;                     /* Handle to accelerator table       */
BOOL     fRunBySetup = FALSE;        /* Did SlipUp WinExec us??           */
BOOL     fWrap = 0;                  /* Flag for word wrap                */
TCHAR    szNotepad[] = TEXT("Notepad");/* Name of notepad window class    */

BOOL fInSaveAsDlg = FALSE;

/* variables for the new File/Open, File/Saveas,Find Text and Print dialogs */
OPENFILENAME OFN;                     /* passed to the File Open/save APIs */
TCHAR szOpenFilterSpec[CCHFILTERMAX]; /* default open filter spec          */
TCHAR szSaveFilterSpec[CCHFILTERMAX]; /* default save filter spec          */

UINT g_cpANSI;                        /* system ANSI codepage (GetACP())   */
UINT g_cpOEM;                         /* system OEM codepage (GetOEMCP())  */
UINT g_cpUserLangANSI;                /* user UI language ANSI codepage    */
UINT g_cpUserLangOEM;                 /* user UI language OEM codepage     */
UINT g_cpUserLocaleANSI;              /* user default LCID ANSI codepage   */
UINT g_cpUserLocaleOEM;               /* user default LCID OEM codepage    */
UINT g_cpKeyboardANSI;                /* keyboard ANSI codepage            */
UINT g_cpKeyboardOEM;                 /* keyboard OEM codepage             */

BOOL g_fSelectEncoding;               /* Prompt for encoding by default    */
UINT g_cpDefault;                     /* codepage default                  */
UINT g_cpOpened;                      /* codepage of open file             */
UINT g_cpSave;                        /* codepage in which to save         */
WB   g_wbOpened;                      /* BOM was present when opened       */
WB   g_wbSave;                        /* BOM should be saved               */
BOOL g_fSaveEntity;                   /* Entities should be saved          */

FINDREPLACE FR;                       /* Passed to FindText()              */
PAGESETUPDLG g_PageSetupDlg;
UINT wFRMsg;                          /* message used in communicating     */
                                      /* with Find/Replace dialog          */

DWORD dwCurrentSelectionStart = 0L;   /* WM_ACTIVATEAPP selection pos      */
DWORD dwCurrentSelectionEnd   = 0L;   /* WM_ACTIVATEAPP selection pos      */
UINT wHlpMsg;                         /* message used in invoking help     */

/* Strings loaded from resource file passed to LoadString at initialization time */
/* To add resource string:
 * 1) create IDS_ macro definition in notepad.h
 * 2) create string in resource file
 * 3) create 'TCHAR*' variable directly below and in notepad.h file
 * 4) add &variable to rgsz
 *
 */
TCHAR *szDiskError =(TCHAR *)IDS_DISKERROR;  /* Can't open File, check disk  */
TCHAR *szFNF       =(TCHAR *)IDS_FNF;        /* File not found               */
TCHAR *szSCBC      =(TCHAR *)IDS_SCBC;       /* Save changes before closing? */
TCHAR *szUntitled  =(TCHAR *)IDS_UNTITLED;   /* Untitled                     */
TCHAR *szNpTitle   =(TCHAR *)IDS_NOTEPAD;    /* Notepad -                    */
TCHAR *szCFS       =(TCHAR *)IDS_CFS;        /* Can't find string            */
TCHAR *szErrSpace  =(TCHAR *)IDS_ERRSPACE;   /* Memory space exhausted       */
TCHAR *szFTL       =(TCHAR *)IDS_FTL;        /* File too large for notepad   */
TCHAR *szNN        =(TCHAR *)IDS_NN;         /* Notepad name                 */

TCHAR *szCommDlgInitErr = (TCHAR*)IDS_COMMDLGINIT; /* common dialog error %x */
TCHAR *szPDIE      =(TCHAR*) IDS_PRINTDLGINIT; /* Print dialog init error    */
TCHAR *szCP        =(TCHAR*) IDS_CANTPRINT;  /* Can't print                  */
TCHAR *szNVF       =(TCHAR*) IDS_NVF;        /* Not a valid filename.        */
TCHAR *szCREATEERR =(TCHAR*) IDS_CREATEERR;  /* cannot create file           */
TCHAR *szNoWW      =(TCHAR*) IDS_NOWW;       /* Too much text to word wrap   */
TCHAR *szMerge     =(TCHAR*) IDS_MERGE1;     /* search string for merge      */
TCHAR *szHelpFile  =(TCHAR*) IDS_HELPFILE;   /* Name of helpfile.            */
TCHAR *szHeader    =(TCHAR*) IDS_HEADER;
TCHAR *szFooter    =(TCHAR*) IDS_FOOTER;

TCHAR *szTextFiles          = (TCHAR*) IDS_TEXTFILES;    /* File/Open TXT filter spec. string */
TCHAR *szHtmlFiles          = (TCHAR*) IDS_HTMLFILES;    /* File/Open HTML filter spec. string */
TCHAR *szXmlFiles           = (TCHAR*) IDS_XMLFILES;     /* File/Open XML filter spec. string */
TCHAR *szEncodedText        = (TCHAR*) IDS_ENCODEDTEXT;  /* File/Open TXT Filter spec. string */
TCHAR *szAllFiles           = (TCHAR*) IDS_ALLFILES;     /* File/Open Filter spec. string */

TCHAR *szMoreEncoding       = (TCHAR*) IDS_MOREENCODING;

#if 0
TCHAR *szOpenCaption        = (TCHAR*) IDS_OPENCAPTION;  /* caption for File/Open dlg */
TCHAR *szSaveCaption        = (TCHAR*) IDS_SAVECAPTION;  /* caption for File/Save dlg */
#endif
TCHAR *szCannotQuit         = (TCHAR*) IDS_CANNOTQUIT;   /* cannot quit during a WM_QUERYENDSESSION */
TCHAR *szLoadDrvFail        = (TCHAR*) IDS_LOADDRVFAIL;  /* LOADDRVFAIL from PrintDlg */
TCHAR *szACCESSDENY         = (TCHAR*) IDS_ACCESSDENY;   /* Access denied on Open */
TCHAR *szFontTooBig         = (TCHAR*) IDS_FONTTOOBIG;   /* font too big or page too small */

TCHAR *szCommDlgErr         = (TCHAR*) IDS_COMMDLGERR;   /* common dialog error %x */
TCHAR *szLineError          = (TCHAR*) IDS_LINEERROR;    /* line number error        */
TCHAR *szLineTooLarge       = (TCHAR*) IDS_LINETOOLARGE; /* line number out of range */
TCHAR *szInvalidCP          = (TCHAR*) IDS_INVALIDCP;    /* invalid codepage */
TCHAR *szInvalidIANA        = (TCHAR*) IDS_INVALIDIANA;  /* invalid encoding */
TCHAR *szEncodingMismatch   = (TCHAR*) IDS_ENCODINGMISMATCH;
TCHAR *szCurrentPage        = (TCHAR*) IDS_CURRENT_PAGE;

// strings for the status bar
TCHAR *szLineCol        = (TCHAR*) IDS_LINECOL;
TCHAR *szCompressedFile = (TCHAR*) IDS_COMPRESSED_FILE;  
TCHAR *szEncryptedFile  = (TCHAR*) IDS_ENCRYPTED_FILE;   
TCHAR *szHiddenFile     = (TCHAR*) IDS_HIDDEN_FILE;      
TCHAR *szOfflineFile    = (TCHAR*) IDS_OFFLINE_FILE;     
TCHAR *szReadOnlyFile   = (TCHAR*) IDS_READONLY_FILE;    
TCHAR *szSystemFile     = (TCHAR*) IDS_SYSTEM_FILE;      
TCHAR *szFile           = (TCHAR*) IDS_FILE;             
TCHAR *szNoStatusAvail  = (TCHAR*) IDS_NOSTATUSAVAIL;


// Resource strings
// This table *must* be null terminated
//
// At startup, these pointers point to pointes which have the IDS_ number in them.
// npinit.c will LoadString on these resource IDs and replace the IDs with pointers.

TCHAR ** const rgsz[] = {
        &szDiskError,
        &szFNF,
        &szSCBC,
        &szUntitled,
        &szErrSpace,
        &szCFS,
        &szNpTitle,
        &szFTL,
        &szNN,
        &szCommDlgInitErr,
        &szPDIE,
        &szCP,
        &szNVF,
        &szCREATEERR,
        &szNoWW,
        &szMerge,
        &szHelpFile,
        &szTextFiles,
        &szHtmlFiles,
        &szXmlFiles,
        &szEncodedText,
        &szAllFiles,
        &szMoreEncoding,
        &szCannotQuit,
        &szLoadDrvFail,
        &szACCESSDENY,
        &szCommDlgErr,
        &szFontTooBig,
        &szLineError,
        &szLineTooLarge,
        &szInvalidCP,
        &szInvalidIANA,
        &szEncodingMismatch,
        &szCurrentPage,
        &szHeader,
        &szFooter,
        &szLineCol,
        &szCompressedFile,
        &szEncryptedFile,
        &szHiddenFile,
        &szOfflineFile,
        &szReadOnlyFile,
        &szSystemFile,
        &szFile,
        &szNoStatusAvail,
        NULL                      // end of table marker
};


HANDLE   fp;          /* file pointer */


#if 0
VOID DisplayFont( LOGFONT* pf )
{
    TCHAR dbuf[100];

    ODS(TEXT("-----------------------\n"));
    wsprintf(dbuf,TEXT("lfHeight          %d\n"),pf->lfHeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"),pf->lfWidth ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"),pf->lfEscapement); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"),pf->lfOrientation); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"),pf->lfWeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"),pf->lfItalic); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderLine       %d\n"),pf->lfUnderline); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"),pf->lfStrikeOut); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"),pf->lfCharSet); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"),pf->lfOutPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecision   %d\n"),pf->lfClipPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"),pf->lfQuality); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"),pf->lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"),pf->lfFaceName); ODS(dbuf);

}
#endif

static TCHAR  szPath[MAX_PATH];

void FileDragOpen(void);
VOID NpResetMenu(HWND hWnd);
BOOL SignalCommDlgError(VOID);
VOID ReplaceSel( BOOL bView );

/* FreeGlobal, frees  all global memory allocated. */

void NEAR PASCAL FreeGlobal()
{
    if(g_PageSetupDlg.hDevMode)
    {
        GlobalFree(g_PageSetupDlg.hDevMode);
    }

    if(g_PageSetupDlg.hDevNames)
    {
        GlobalFree(g_PageSetupDlg.hDevNames);
    }

    g_PageSetupDlg.hDevMode=  NULL; // make sure they are zero for PrintDlg
    g_PageSetupDlg.hDevNames= NULL;
}

VOID PASCAL SetPageSetupDefaults( VOID )
{
    TCHAR szIMeasure[ 2 ];

    g_PageSetupDlg.lpfnPageSetupHook= PageSetupHookProc;
    g_PageSetupDlg.lpPageSetupTemplateName= MAKEINTRESOURCE(IDD_PAGESETUP);

    GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2 );

    g_PageSetupDlg.Flags= PSD_MARGINS  |
            PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;

    if (szIMeasure[ 0 ] == TEXT( '1' ))
    {
        //  English measure (in thousandths of inches).
        g_PageSetupDlg.Flags |= PSD_INTHOUSANDTHSOFINCHES;
        g_PageSetupDlg.rtMargin.top    = 1000;
        g_PageSetupDlg.rtMargin.bottom = 1000;
        g_PageSetupDlg.rtMargin.left   = 750;
        g_PageSetupDlg.rtMargin.right  = 750;
    }
    else
    {
        //  Metric measure (in hundreths of millimeters).
        g_PageSetupDlg.Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
        g_PageSetupDlg.rtMargin.top    = 2500;
        g_PageSetupDlg.rtMargin.bottom = 2500;
        g_PageSetupDlg.rtMargin.left   = 2000;
        g_PageSetupDlg.rtMargin.right  = 2000;
    }

}

/* Standard window size proc */
void NPSize (int cxNew, int cyNew)
{

    /* Invalidate the edit control window so that it is redrawn with the new
     * margins. Needed when comming up from iconic and when doing word wrap so
     * the new margins are accounted for.
     */

    InvalidateRect(hwndEdit, (LPRECT)NULL, TRUE);

    // the height of the edit window depends on whether the status bar is
    // displayed.
    MoveWindow (hwndEdit, 0, 0, cxNew, cyNew - (fStatus?dyStatus:0), TRUE);

}


// SelectEncodingDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

INT_PTR CALLBACK SelectEncodingDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UINT *pcp;

#define PCPPROP ((LPCTSTR) 0xA000L)

    switch (message)
    {
        case WM_INITDIALOG:
            pcp = (UINT *) lParam;

            SetProp(hDlg, PCPPROP, (HANDLE) pcp);

            PopulateCodePages(hDlg, TRUE, *pcp, *pcp);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                LRESULT lr;

                case IDC_CODEPAGE:
                    if (HIWORD(wParam) != LBN_DBLCLK)
                    {
                        break;
                    }

                    // Fall through

                case IDOK:
                    pcp = (UINT *) GetProp(hDlg, PCPPROP);

                    if (pcp != NULL)
                    {
                        lr = SendDlgItemMessage(hDlg, IDC_CODEPAGE, LB_GETCURSEL, 0, 0);

                        if (lr >= 0)
                        {
                            *pcp = (UINT) SendDlgItemMessage(hDlg, IDC_CODEPAGE, LB_GETITEMDATA, (WPARAM) lr, 0);
                        }
                    }

                    RemoveProp(hDlg, PCPPROP);
                    EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL :
                    RemoveProp(hDlg, PCPPROP);
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;
            }
            break;
    }

    return FALSE;
}


// NpSaveDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while saving.
//

const DWORD s_SaveAsHelpIDs[]=
    {
        IDC_CODEPAGE, IDH_FILETYPE,
        IDC_ENCODING, IDH_FILETYPE,
        0, 0
    };

UINT_PTR APIENTRY NpSaveDialogHookProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT cch;
    HANDLE hText;
    INT id;

    switch( msg )
    {
        LRESULT lr;

        case WM_INITDIALOG:
            g_cpSave = g_cpOpened;
            g_wbSave = g_wbOpened;

            // Check for an HTML or XML file with a declared encoding
            // If one is found, suggest the declared encoding

            cch = (UINT) SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0);
            hText = (HANDLE) SendMessage(hwndEdit, EM_GETHANDLE, 0, 0);

            if (hText != NULL)
            {
                LPCTSTR rgwch = (LPTSTR) LocalLock(hText);

                if (rgwch != NULL)
                {
                    UINT cpDetected;

                    if (FDetectEncodingW(szFileOpened, rgwch, cch, &cpDetected))
                    {
                        // We detected an expected encoding for this file

                        g_cpSave = cpDetected;
                    }

                    LocalUnlock(hText);
                }
            }

            PopulateCodePages(hDlg, FALSE, g_cpSave, g_cpOpened);

            // Clear CBS_SORT flag to keep More... entry at end of list

            lr = SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_INSERTSTRING, (WPARAM) -1, (LPARAM) szMoreEncoding);

            if (lr >= 0)
            {
                SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_SETITEMDATA, (WPARAM) lr, CP_AUTO);
            }
            break;

        case WM_COMMAND:
            lr = SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_GETCURSEL, 0, 0);

            if (lr >= 0)
            {
                g_cpSave = (UINT) SendDlgItemMessage(hDlg, IDC_CODEPAGE, CB_GETITEMDATA, (WPARAM) lr, 0);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)->hItemHandle);

            if ( id != IDC_CODEPAGE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hDlg == (HWND) wParam )
            {
                POINT pt;

                GetCursorPos(&pt);
                ScreenToClient(hDlg, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hDlg, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_CODEPAGE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;
    }

    return(FALSE);
}

// GotoAndScrollInView
//
// Put the cursor at the begining of a line, and scroll the
// editbox so the user can see it.
//
// If there is a failure, it just leaves the cursor where it is.
//

VOID GotoAndScrollInView( INT OneBasedLineNumber )
{
    UINT CharIndex;
    CharIndex= (UINT) SendMessage( hwndEdit,
                                   EM_LINEINDEX,
                                   OneBasedLineNumber-1,
                                   0 );
    if( CharIndex != (UINT) -1 )
    {
        SendMessage( hwndEdit, EM_SETSEL, CharIndex, CharIndex);
        SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }

}

/* ** Notepad command proc - called whenever notepad gets WM_COMMAND
      message.  wParam passed as cmd */
INT NPCommand(
    HWND     hwnd,
    WPARAM   wParam,
    LPARAM   lParam )
{
    HWND     hwndFocus;
    LONG     lSel;
    TCHAR    szNewName[MAX_PATH] = TEXT("");      /* New file name */
    LONG     style;
    DWORD    rc;
    RECT     rcClient;

    UNREFERENCED_PARAMETER( lParam );

    switch (LOWORD(wParam))
    {
        case M_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case M_NEW:
            New(TRUE);
            break;

        case M_OPEN:
            if (CheckSave(FALSE))
            {
                szNewName[0] = TEXT('\0');      /* set default selection */

                /* set up the variable fields of the OPENFILENAME struct.
                 * (the constant fields have been set in NPInit()
                 */
                OFN.lpstrFile      = szNewName;
#if 0
                OFN.lpstrTitle     = szOpenCaption;
#endif

                /* Added OFN_FILEMUSTEXIST to eliminate problems in LoadFile.
                 * 12 February 1991    clarkc
                 */

                OFN.Flags          = OFN_HIDEREADONLY     | OFN_FILEMUSTEXIST |
                                     OFN_EXPLORER;

                OFN.lpTemplateName = NULL;
                OFN.lpfnHook       = NULL;
                OFN.lpstrFilter    = szOpenFilterSpec;
                OFN.lpstrDefExt    = TEXT("txt");
                OFN.nFilterIndex   = FILE_TEXT;

                if (GetOpenFileName(&OFN))
                {
                   HANDLE oldfp= fp;

                   fp= CreateFile( szNewName,            // filename
                                   GENERIC_READ,         // access mode
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,                 // security descriptor
                                   OPEN_EXISTING,        // how to create
                                   FILE_ATTRIBUTE_NORMAL,// file attributes
                                   NULL);                // hnd to file attrs

                   /* Try to load the file and reset fp if failed */

                   if (!LoadFile(szNewName, OFN.nFilterIndex == FILE_ENCODED))
                   {
                      fp= oldfp;
                   }
                }
                else
                {
                    SignalCommDlgError();
                }
            }
            break;

        case M_SAVE:
            /* set up the variable fields of the OPENFILENAME struct.
             * (the constant fields have been sel in NPInit()
             */
            g_cpSave = g_cpOpened;
            g_wbSave = g_wbOpened;

            if (!FUntitled() && SaveFile(hwndNP, szFileOpened, FALSE))
            {
                break;
            }

            /* fall through */

        case M_SAVEAS:
            lstrcpy(szNewName, szFileOpened);     // Set default selection

            OFN.lpstrFile      = szNewName;
#if 0
            OFN.lpstrTitle     = szSaveCaption;
#endif

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags          = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                                 OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                                 OFN_EXPLORER         | OFN_ENABLESIZING    |
                                 OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName = TEXT("NpSaveDialog");
            OFN.lpfnHook       = NpSaveDialogHookProc;
            OFN.lpstrFilter    = szSaveFilterSpec;
            OFN.lpstrDefExt    = TEXT("txt");
            OFN.nFilterIndex   = FILE_TEXT;

            //
            // Do common dialog to save file
            //

            fInSaveAsDlg = TRUE;
            if (GetSaveFileName(&OFN))
            {
                SaveFile(hwnd, szNewName, TRUE);
            }

            else
            {
                SignalCommDlgError();
            }

            fInSaveAsDlg = FALSE;
            break;

        case M_SELECTALL:
            {
                HMENU    hMenu;

                hMenu = GetMenu(hwndNP);
                lSel = (LONG) SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, 0L);
                SendMessage (hwndEdit, EM_SETSEL, 0, lSel );
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
                EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_GRAYED);
                break;
            }

        case M_REPLACE:
            if( hDlgFind )
            {
               SetFocus( hDlgFind );
            }
            else
            {
               FR.Flags= FR_HIDEWHOLEWORD | FR_REPLACE;
               FR.lpstrReplaceWith= szReplace;
               FR.wReplaceWithLen= CCHKEYMAX;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = ReplaceText( &FR );
            }
            break;

        case M_FINDNEXT:
            if (szSearch[0])
            {
               Search(szSearch);
               break;
            }
            /* else fall thro' a,d bring up "find" dialog */

        case M_FIND:
            if (hDlgFind)
            {
               SetFocus(hDlgFind);
            }
            else
            {
               FR.Flags= FR_DOWN | FR_HIDEWHOLEWORD;
               FR.lpstrReplaceWith= NULL;
               FR.wReplaceWithLen= 0;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = FindText((LPFINDREPLACE)&FR);
            }
            break;

        case M_GOTO:
            {
                INT  Result;

                Result= (INT)DialogBox( hInstanceNP,
                                        MAKEINTRESOURCE(IDD_GOTODIALOG),
                                        hwndNP,
                                        GotoDlgProc );

                //
                // move cursor only if ok pressed and line number ok
                //

                if( Result == 0 )
                {
                    GotoAndScrollInView( lGotoLine );
                }
            }
            break;

        case M_ABOUT:
            ShellAbout(hwndNP,
                       szNN,
                       TEXT(""),
                       LoadIcon(hInstanceNP,
                                (LPTSTR)MAKEINTRESOURCE(ID_ICON)));

            break;

        case M_HELP:
            HtmlHelpA(GetDesktopWindow(), "notepad.chm", HH_DISPLAY_TOPIC, 0L);
            break;

        case M_CUT:
        case M_COPY:
        case M_CLEAR:
            lSel = (LONG)SendMessage (hwndEdit, EM_GETSEL, 0, 0L);
            if (LOWORD(lSel) == HIWORD(lSel))
               break;

        case M_PASTE:
            /* If notepad parent or edit window has the focus,
               pass command to edit window.
               make sure line resulting from paste will not be too long. */
            hwndFocus = GetFocus();
            if (hwndFocus == hwndEdit || hwndFocus == hwndNP)
            {
                PostMessage(hwndEdit, LOWORD(wParam), 0, 0);
            }
            break;

        case M_DATETIME:
            InsertDateTime(FALSE);
            break;

        case M_UNDO:
            SendMessage (hwndEdit, EM_UNDO, 0, 0L);
            break;

        case M_WW:
            style= (!fWrap) ? ES_STD : (ES_STD | WS_HSCROLL);
            if( NpReCreate( style ) )
            {
                fWrap= !fWrap;
            }
            else
            {
                MessageBox(hwndNP, szNoWW, szNN,
                           MB_APPLMODAL | MB_OK | MB_ICONWARNING);
            }

            // redraw the status bar
            if( fStatus )
            {
                GetClientRect(hwndNP, &rcClient);
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
                ShowWindow( hwndStatus, SW_SHOW );
            }

            break;

        case M_STATUSBAR:

            // hide/show the statusbar and also redraw the edit window accordingly.
            GetClientRect(hwndNP, &rcClient);

            if ( fStatus )
            {
                fStatus = FALSE;
                ShowWindow ( hwndStatus, SW_HIDE );
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
            }
            else
            {
                fStatus = TRUE;
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);

                ShowWindow( hwndStatus, SW_SHOW );
            }
            break;

        case ID_EDIT:
            break;

        case M_PRINT:
            PrintIt( UseDialog );
            break;

        case M_PAGESETUP:
            TryPrintDlgAgain:
            
            if( PageSetupDlg(&g_PageSetupDlg) )
            {
                //  We know it's okay to copy these strings over...
                lstrcpy(chPageText[HEADER], chPageTextTemp[HEADER]);
                lstrcpy(chPageText[FOOTER], chPageTextTemp[FOOTER]);
            }
            else
            {
                rc= CommDlgExtendedError();

                if( rc == PDERR_PRINTERNOTFOUND ||
                    rc == PDERR_DNDMMISMATCH    ||
                    rc == PDERR_DEFAULTDIFFERENT )
                  {
                      FreeGlobal();
                      g_PageSetupDlg.hDevMode= g_PageSetupDlg.hDevNames= 0;
                      goto TryPrintDlgAgain;
                  }

                // Check for Dialog Failure

                SignalCommDlgError( );

            }
            break;

        case M_SETFONT:
        {
            CHOOSEFONT  cf;
            HFONT       hFontNew;
            HDC         hDisplayDC;     // display DC

            hDisplayDC= GetDC(NULL);    // try to get display DC
            if( !hDisplayDC )
                break;

            /* calls the font chooser (in commdlg)
             * We set lfHeight; choosefont returns ipointsize
             */
            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = hwnd;
            cf.lpLogFont = &FontStruct;         // filled in by init
            FontStruct.lfHeight= -MulDiv(iPointSize,GetDeviceCaps(hDisplayDC,LOGPIXELSY),720);
            cf.Flags = CF_INITTOLOGFONTSTRUCT |
                       CF_SCREENFONTS         | 
                       CF_NOSCRIPTSEL         |
                       CF_NOVERTFONTS         |
                       0;
            cf.rgbColors = 0;                   // only if cf_effects
            cf.lCustData = 0;                   // for hook function
            cf.lpfnHook = (LPCFHOOKPROC) NULL;
            cf.lpTemplateName = (LPTSTR) NULL;
            cf.hInstance = NULL;
            cf.lpszStyle = NULL;                // iff cf_usestyle
            cf.nFontType = SCREEN_FONTTYPE;
            cf.nSizeMin  = 0;  // iff cf_limitsize
            cf.nSizeMax  = 0;  // iff cf_limitsize
            ReleaseDC( NULL, hDisplayDC );

            if( ChooseFont(&cf) )
            {
                SetCursor( hWaitCursor );        // may take some time
                
                hFontNew= CreateFontIndirect(&FontStruct);
                if( hFontNew )
                {
                   DeleteObject( hFont );
                   hFont= hFontNew;
                   SendMessage( hwndEdit, WM_SETFONT,
                               (WPARAM)hFont, MAKELPARAM(TRUE, 0));
                   iPointSize= cf.iPointSize;  // remember for printer
                }
                SetCursor( hStdCursor );
            }
            break;
        }

        default:
            return FALSE;
    }
    return TRUE;
}


// for some reason, this procedure tries to maintain
// a valid 'fp' even though I believe it does not need
// to be.
void FileDragOpen(void)
{
    HANDLE oldfp;

    oldfp= fp;       // remember in case of error

    if( CheckSave(FALSE) )
    {

         fp= CreateFile( szPath,               // filename
                         GENERIC_READ,         // access mode
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         NULL,                 // security descriptor
                         OPEN_EXISTING,        // how to create
                         FILE_ATTRIBUTE_NORMAL,// file attributes
                         NULL);                // hnd to file attrs

       if( fp == INVALID_HANDLE_VALUE )
       {
          AlertUser_FileFail( szPath );

          // Restore fp to original file.
          fp= oldfp;
       }
       /* Try to load the file and reset fp if failed */
       else if (!LoadFile(szPath, g_fSelectEncoding))
       {
           fp= oldfp;
       }
    }
}


/* Proccess file drop/drag options. */
void doDrop (WPARAM wParam, HWND hwnd)
{
   /* If user dragged/dropped a file regardless of keys pressed
    * at the time, open the first selected file from file manager. */

    if (DragQueryFile ((HANDLE)wParam, 0xFFFFFFFF, NULL, 0)) /* # of files dropped */
    {
       DragQueryFile ((HANDLE)wParam, 0, szPath, CharSizeOf(szPath));
       SetActiveWindow (hwnd);
       FileDragOpen();
    }
    DragFinish ((HANDLE)wParam);  /* Delete structure alocated for WM_DROPFILES*/
}

/* ** if notepad is dirty, check to see if user wants to save contents */
BOOL CheckSave(BOOL fSysModal)
{
    INT    mdResult;
    TCHAR  szNewName[MAX_PATH];      /* New file name */

/* If it's untitled and there's no text, don't worry about it */
    if (FUntitled() && !SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0))
        return(TRUE);

    if (!SendMessage(hwndEdit, EM_GETMODIFY, 0, 0))
        return(TRUE);

    mdResult = AlertBox(hwndNP, szNN, szSCBC, SzTitle(),
                        (WORD)((fSysModal ? MB_SYSTEMMODAL :
                                            MB_APPLMODAL)| MB_YESNOCANCEL| MB_ICONWARNING));

    if (mdResult == IDYES)
    {
        if (FUntitled())
        {
SaveFilePrompt:
            lstrcpy(szNewName, szFileOpened);     // Set default selection

            OFN.lpstrFile      = szNewName;
#if 0
            OFN.lpstrTitle     = szSaveCaption;
#endif

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags          = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                                 OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                                 OFN_EXPLORER         | OFN_ENABLESIZING    |
                                 OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName = TEXT("NpSaveDialog");
            OFN.lpfnHook       = NpSaveDialogHookProc;
            OFN.lpstrFilter    = szSaveFilterSpec;
            OFN.lpstrDefExt    = TEXT("txt");
            OFN.nFilterIndex   = FILE_TEXT;

            //
            // Set dialog checkmark by current file type
            //

            fInSaveAsDlg = TRUE;
            if (GetSaveFileName(&OFN))
            {
                if (!SaveFile(hwndNP, szNewName, TRUE))
                {
                    // Fixing close without saving file when disk-full

                    goto SaveFilePrompt;
                }
            }
            else
            {
                mdResult= IDCANCEL;       /* Don't exit Program */
                if( CommDlgExtendedError() )/* Dialog box failed, Lo-mem*/
                    DeepTrouble();
            }

            fInSaveAsDlg = FALSE;
        }
        else
        {
            // Initialize the save type.

            g_cpSave = g_cpOpened;
            g_wbSave = g_wbOpened;

            if (SaveFile(hwndNP, szFileOpened, FALSE))
            {
                return(TRUE);
            }

            goto SaveFilePrompt;
        }
    }

    return (mdResult != IDCANCEL);
}


/* Notepad window class procedure */
LRESULT FAR NPWndProc(
        HWND       hwnd,
        UINT       message,
        WPARAM     wParam,
        LPARAM     lParam)
{
    LPFINDREPLACE lpfr;
    DWORD dwFlags;
    INT iParts[2];


    switch (message)
    {
/* If we're being run by Setup and it's the system menu, be certain that
 * the minimize menu item is disabled.  Note that hSysMenuSetup is only
 * initialized if Notepad is being run by Setup.  Don't use it outside
 * the fRunBySetup conditional!    28 June 1991    Clark Cyr
 */
        case WM_INITMENUPOPUP:
            if (fRunBySetup && HIWORD(lParam))
               EnableMenuItem(hSysMenuSetup,SC_MINIMIZE,MF_GRAYED|MF_DISABLED);
            break;

        case WM_SYSCOMMAND:
            if (fRunBySetup)
            {
                /* If we have been spawned by SlipUp we need to make sure the
                 * user doesn't minimize us or alt tab/esc away.
                 */
                if (wParam == SC_MINIMIZE ||
                    wParam == SC_NEXTWINDOW ||
                    wParam == SC_PREVWINDOW)
                    break;
            }
            DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_SETFOCUS:
            if (!IsIconic(hwndNP))
            {
               SetFocus(hwndEdit);
            }
            break;

        case WM_KILLFOCUS:
            SendMessage (hwndEdit, message, wParam, lParam);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CLOSE:

            // Save any globals in the registry if need be

            SaveGlobals();

            if (CheckSave(FALSE))
            {
                /* Exit help */
                if(!WinHelp(hwndNP, (LPTSTR)szHelpFile, HELP_QUIT, 0))
                    DeepTrouble();

                DestroyWindow(hwndStatus);
                DestroyWindow(hwndNP);
                DeleteObject(hFont);
            }

            break;

        case WM_QUERYENDSESSION:
            if (fInSaveAsDlg)
            {
                MessageBeep (0);
                MessageBeep (0);
                MessageBox (hwndNP, szCannotQuit, szNN, MB_OK|MB_SYSTEMMODAL);
                return FALSE;
            }
            else
                return (CheckSave(TRUE));
            break;


        case WM_ACTIVATEAPP:
            if (wParam)
            {
            /* This causes the caret position to be at the end of the selection
             * but there's no way to ask where it was or set it if known.  This
             * will cause a caret change when the selection is made from bottom
             * to top.
             */
                if( dwCurrentSelectionStart != 0 || dwCurrentSelectionEnd != 0 )
                {
                   SendMessage( hwndEdit, EM_SETSEL,
                                dwCurrentSelectionStart,
                                dwCurrentSelectionEnd );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
                }
            }
            else
            {
                SendMessage( hwndEdit, EM_GETSEL,
                            (WPARAM) &dwCurrentSelectionStart,
                            (LPARAM) &dwCurrentSelectionEnd);
                if (dwCurrentSelectionStart == dwCurrentSelectionEnd)
                {
                    dwCurrentSelectionStart = 0L;
                    dwCurrentSelectionEnd = 0L;
                }
                else
                {
                   SendMessage (hwndEdit, EM_SETSEL, dwCurrentSelectionStart,
                                dwCurrentSelectionEnd);
                   SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);
                }
            }
            break;

        case WM_ACTIVATE:
            if ((LOWORD(wParam) == WA_ACTIVE       ||
                 LOWORD(wParam) == WA_CLICKACTIVE) &&
                !IsIconic(hwndNP)
               )
               {
                   // active doesn't always mean foreground (ntbug# 53048)
                   if( GetForegroundWindow() == hwndNP )
                   {
                       SetFocus(GetForegroundWindow());
                   }
               }
            break;

        case WM_SIZE:
            switch (wParam)
            {
                case SIZENORMAL:
                case SIZEFULLSCREEN:

                    // resize the status window.
                    SendMessage (hwndStatus, WM_SIZE, 0, 0L);
                    iParts[0] = 3 * (MAKEPOINTS(lParam).x)/4;
                    iParts[1] = -1;

                    // Divide the status window into two parts
                    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts); 

                    NPSize(MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y);
                    break;

                case SIZEICONIC:
                    return (DefWindowProc(hwnd, message, wParam, lParam));
                    break;
                }
            break;

        case WM_INITMENU:
            NpResetMenu( hwnd );
            break;

        //
        // Some keyboards come with a "Search" button which the shell team
        // wanted us to handle.  See ntbug# 380067
        //

        case WM_APPCOMMAND:

            if( ( GET_APPCOMMAND_LPARAM(lParam) == APPCOMMAND_BROWSER_SEARCH ) ) 
            {
                NPCommand(hwnd, M_FIND, 0);
                break;
            }
            // otherwise fall through
 
        case WM_COMMAND:

            if ((HWND)(lParam) == hwndEdit &&
                (HIWORD(wParam) == EN_ERRSPACE ||
                 HIWORD(wParam) == EN_MAXTEXT))
            {
                if (dwEmSetHandle == SETHANDLEINPROGRESS)
                    dwEmSetHandle = SETHANDLEFAILED;
                else
                    DeepTrouble();
                return 0L;
            }

            if (!NPCommand(hwnd, wParam, lParam))
               return (DefWindowProc(hwnd, message, wParam, lParam));
            break;


        case WM_WININICHANGE:
            // Ignore for now.
            // If you put this back in, be sure it handles both
            // the metric change and the decimal change.
            NpWinIniChange();
            break;

        case WM_DROPFILES: /*case added 03/26/91 for file drag/drop support*/
            doDrop (wParam,hwnd);
            break;

        case PWM_CHECK_HKL: /* private message: corresponding to HKL change message */
            {
                LANGID langid = LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0));

                GetKeyboardCodepages(langid);

                if (PRIMARYLANGID(langid) == LANG_JAPANESE) {
                    LPARAM imeStatus = 0;
                    /*
                     * If new current HKL is Japanese, handle the result string at once.
                     */
                    imeStatus = EIMES_GETCOMPSTRATONCE;
                    SendMessage(hwndEdit, EM_SETIMESTATUS, EMSIS_COMPOSITIONSTRING, imeStatus);
                }
            }
            break;

        default:
            /* this can be a message from the modeless Find Text window */
            if (message == wFRMsg)
            {
                BOOL bStatus;    // true if found text

                lpfr = (LPFINDREPLACE)lParam;
                dwFlags = lpfr->Flags;

                fReverse = (dwFlags & FR_DOWN      ? FALSE : TRUE);
                fCase    = (dwFlags & FR_MATCHCASE ? TRUE  : FALSE);

                if( dwFlags & FR_FINDNEXT )
                {
                    SetCursor( hWaitCursor );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACE )
                {
                    //
                    // Replace current selection if it matches
                    // then highlight the next occurence of the string.
                    //

                    SetCursor( hWaitCursor );
                    ReplaceSel( TRUE );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACEALL )
                {
                   //
                   // The replace dialog doesn't allow reverse searches
                   // but just it cases it changes, for it to false.
                   //
                   if( fReverse )
                   {
                       fReverse= FALSE;
                   }

                   //
                   // Replace all occurances of text in the file
                   // starting from the top.  Reset the selection
                   // to the top of the file.
                   //
                   SetCursor( hWaitCursor );
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   do
                   {
                      ReplaceSel( FALSE );
                      bStatus= Search( szSearch );
                   }
                   while( bStatus );
                   SetCursor( hStdCursor );
                   //
                   // back to the top of the file.
                   //
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);

                }
                else if (dwFlags & FR_DIALOGTERM)
                    hDlgFind = NULL;   /* invalidate modeless window handle */
                break;
            }
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

LPTSTR SkipProgramName (LPTSTR lpCmdLine)
{
    LPTSTR  p = lpCmdLine;
    BOOL    bInQuotes = FALSE;

    //
    // Skip executable name
    //
    for (p; *p; p = CharNext(p))
    {
       if ((*p == TEXT(' ') || *p == TEXT('\t')) && !bInQuotes)
          break;

       if (*p == TEXT('\"'))
          bInQuotes = !bInQuotes;
    }

    while (*p == TEXT(' ') || *p == TEXT('\t'))
       p++;

    return (p);
}

/* ** Main loop */

INT WINAPI WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpAnsiCmdLine,
   INT cmdShow)
{
    MSG msg;
    LPTSTR lpCmdLine = GetCommandLine ();
    HWINEVENTHOOK hEventHook = NULL;

#ifdef PENWINDOWS

    VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
/* PenWindow registration must be before creating an edit class window.
 * Moved here, along with goto statement below for appropriate cleanup.
 *                 10 July 1991    ClarkC
 */
    lpfnRegisterPenApp= GetProcAddress( (HINSTANCE)(INT_PTR)(GetSystemMetrics(SM_PENWINDOWS)), 
                                        "RegisterPenApp");
    if( lpfnRegisterPenApp ) {
        (*lpfnRegisterPenApp)(1, TRUE);
    }
#endif

    if (!NPInit(hInstance, hPrevInstance, SkipProgramName(lpCmdLine), cmdShow))
    {
        msg.wParam = FALSE;
        goto UnloadMlang;
    }

    // set an event hook to get the cursor position! this event hook is used to update
    // the line & column position of the caret shown in the statusbar.
    hEventHook = SetWinEventHook(EVENT_OBJECT_LOCATIONCHANGE, EVENT_OBJECT_LOCATIONCHANGE, NULL, WinEventFunc, 
                                (DWORD) GetCurrentProcessId(), 0, WINEVENT_OUTOFCONTEXT);
 
    while (GetMessage((LPMSG)&msg, (HWND)NULL, 0, 0))
    {
        //
        // To handle IME status when active KL is changed.
        //
        if (msg.message == WM_INPUTLANGCHANGEREQUEST) {
            //
            // WM_INPUTLANGCHANGE will be *sent* to WndProc,
            // so there's no chance to catch WM_INPUTLANGCHANGE from the frame window.
            // Instead, we post the private message to check the active HKL later.
            //
            PostMessage(hwndNP, PWM_CHECK_HKL, 0, 0);
        }

        if (!hDlgFind || !IsDialogMessage(hDlgFind, &msg))
        {
            if (TranslateAccelerator(hwndNP, hAccel, (LPMSG)&msg) == 0)
            {
               TranslateMessage ((LPMSG)&msg);
               DispatchMessage ((LPMSG)&msg);
            }
        }
    }

    /* Clean up any global allocations */

    FreeGlobal();

    LocalFree(hEdit);

    if (hEventHook)
        UnhookWinEvent(hEventHook);

UnloadMlang:
    UnloadMlang();

#ifdef PENWINDOWS
    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);
#endif PENWINDOWS

    return (int)(msg.wParam);

    UNREFERENCED_PARAMETER( lpAnsiCmdLine );
}


/* This function is called whenever the location of the caret changes
in the edit window. The function updates the statusbar with the current
line number, column of the caret */

VOID CALLBACK WinEventFunc(
    HWINEVENTHOOK hWinEventHook, 
    DWORD event, 
    HWND hwnd, 
    LONG idObject,
    LONG idChild, 
    DWORD dwEventThread, 
    DWORD dwmsEventTime)
{
    DWORD SelStart, SelEnd;
    UINT  iLine, iCol;
    TCHAR szStatusText[128];

    // get the current caret position.
    SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

    // the line numbers are 1 based instead 0 based. hence add 1.
    iLine = (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
    iCol = SelStart - (UINT)SendMessage( hwndEdit, EM_LINEINDEX, iLine-1, 0 ) + 1;

    // prepare and display the statusbar.
    // make sure you don't overflow the buffer boundary.
    _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, iLine, iCol);

    // display status unless wordwrap is on
    // Users get confused by MLE's idea of a line numbers.  Bug# 194034 (9/29/2000)

    if( !fWrap )
    {
        SetStatusBarText( szStatusText, 1 );
    }
    else
    {
        SetStatusBarText( szNoStatusAvail, 1 );
    }

    UNREFERENCED_PARAMETER( hWinEventHook );
    UNREFERENCED_PARAMETER( event );
    UNREFERENCED_PARAMETER( hwnd );
    UNREFERENCED_PARAMETER( idObject );
    UNREFERENCED_PARAMETER( idChild );
    UNREFERENCED_PARAMETER( dwEventThread );
    UNREFERENCED_PARAMETER( dwmsEventTime );
};


BOOL FUntitled(void)
{
   return(szFileOpened[0] == TEXT('\0'));
}


const TCHAR *SzTitle(void)
{
   return(FUntitled() ? szUntitled : szFileOpened);
}


void SetFileName(LPCTSTR szFile)
{
    TCHAR szWindowText[MAX_PATH+50];
    TCHAR szStatusText[128] = TEXT("");

    // if "untitled" then don't do all this work...

    if (szFile == NULL)
    {
        szFileOpened[0] = TEXT('\0');

        lstrcpy(szWindowText, szUntitled);
    }

    else
    {
        DWORD dwAttributes;

        if (szFile != szFileOpened)
        {
            TCHAR szFileT[MAX_PATH];
            BOOL fPeriod;
            LPTSTR pch;

            if (GetFullPathName(szFile, MAX_PATH, szFileT, NULL) == 0)
            {
                // We can't get the full path for some reason.
                // Use what was passed in.

                lstrcpyn(szFileT, szFile, MAX_PATH);
            }

            // Get real(file system) name for the file.

            if (GetLongPathName(szFileT, szFileOpened, MAX_PATH) == 0)
            {
                lstrcpy(szFileOpened, szFile);
            }

            // If the filename has no extension, append a trailing period
            // This keeps the COMDLG32 code from appending a default extension.

            fPeriod = FALSE;

            for (pch = szFileOpened; *pch != TEXT('\0'); pch++)
            {
                if (*pch == TEXT('.'))
                {
                    fPeriod = TRUE;
                }

                else if (*pch == TEXT('\\'))
                {
                    fPeriod = FALSE;
                }
            }

            if (!fPeriod && (pch < (szFileOpened + MAX_PATH - 1)))
            {
               *pch++ = TEXT('.');
               *pch = TEXT('\0');
            }
        }

        GetFileTitle(szFileOpened, szWindowText, MAX_PATH);

        // get the attributes for file. these will be shown
        // in the status bar.
        dwAttributes = GetFileAttributes(szFileOpened);

        // prepare the status bar text and show
        // if the file has any special properties (such as hidden, readonly etc.)

        if (dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
            if ((lstrlen(szStatusText) + lstrlen(szCompressedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)
                lstrcpy(szStatusText, szCompressedFile);

        if (dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)   
            if ((lstrlen(szStatusText) + lstrlen(szEncryptedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szEncryptedFile);

        if (dwAttributes & FILE_ATTRIBUTE_HIDDEN)
            if ((lstrlen(szStatusText) + lstrlen(szHiddenFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szHiddenFile);

        if (dwAttributes & FILE_ATTRIBUTE_OFFLINE)
            if ((lstrlen(szStatusText) + lstrlen(szOfflineFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szOfflineFile);

        if (dwAttributes & FILE_ATTRIBUTE_READONLY)
            if ((lstrlen(szStatusText) + lstrlen(szReadOnlyFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szReadOnlyFile);

        if (dwAttributes & FILE_ATTRIBUTE_SYSTEM)
            if ((lstrlen(szStatusText) + lstrlen(szSystemFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szSystemFile);

        // if the status did get updated by file properties
        if (*szStatusText != TEXT('\0'))
        {
            // get rid of the last comma
            szStatusText[lstrlen(szStatusText)-1] = TEXT(' ');

            if ((lstrlen(szStatusText) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)           
                lstrcat(szStatusText, szFile);
        }
    }

    // set the status bar. the Line and Col count is 1 initially for
    // the newly opened file as the caret position is at the first character.
    SetStatusBarText(szStatusText, 0);
    _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, 1, 1);

    if( !fWrap )
    {
        SetStatusBarText( szStatusText, 1 );
    }
    else
    {
        SetStatusBarText( szNoStatusAvail, 1 );
    }

    lstrcat(szWindowText, szNpTitle);
    SetWindowText(hwndNP, szWindowText);

}

/* ** Given filename which may or maynot include path, return pointer to
      filename (not including path part.) */
LPCTSTR PFileInPath(LPCTSTR szFile)
{
    LPCTSTR pch = szFile;
    LPCTSTR psz;

    /* Strip path/drive specification from name if there is one */
    /* Ripped out AnsiPrev calls.     21 March 1991  clarkc     */
    for (psz = szFile; *psz; psz = CharNext(psz))
      {
        if ((*psz == TEXT(':')) || (*psz == TEXT('\\')))
            pch = psz;
      }

    if (pch != szFile)  /* If found slash or colon, return the next character */
        pch++;          /* increment OK, pch not pointing to DB character     */

    return(pch);
}

/* ** Enable or disable menu items according to selection state
      This routine is called when user tries to pull down a menu. */

VOID NpResetMenu( HWND hwnd )
{
    LONG    lsel;
    INT     mfcc;   /* menuflag for cut, copy */
    BOOL    fCanUndo;
    HANDLE  hMenu;
    BOOL    fPaste= FALSE;
    UINT    uSelState;

    hMenu = GetMenu(hwndNP);

    // cut, copy and delete only get enabled if there is text selected.

    lsel = (LONG)SendMessage(hwndEdit, EM_GETSEL, 0, 0L);
    mfcc = LOWORD(lsel) == HIWORD(lsel) ? MF_GRAYED : MF_ENABLED;
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CUT, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_COPY, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CLEAR, mfcc);

    // check if the selectall is gray (that means the user has already
    // done select-all) and it the user has deselected - if so, time
    // to re-enable selectall menu.

    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if ((uSelState == MF_GRAYED) && (mfcc == MF_GRAYED))
    {
        EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
    }

    // paste is enabled if there is text in the clipboard

    if( OpenClipboard(hwnd) )
    {
        fPaste= IsClipboardFormatAvailable(CF_TEXT);
        CloseClipboard();
    }
    EnableMenuItem(GetSubMenu(hMenu, 1), M_PASTE, fPaste ? MF_ENABLED : MF_GRAYED);

    // enable Undo only if editcontrol says we can do it.

    fCanUndo = (BOOL) SendMessage(hwndEdit, EM_CANUNDO, 0, 0L);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_UNDO, fCanUndo ? MF_ENABLED : MF_GRAYED);

    // check the status bar

    CheckMenuItem(GetSubMenu(hMenu, 2), M_STATUSBAR, fStatus ? MF_CHECKED: MF_UNCHECKED );

    // check the word wrap item correctly

    CheckMenuItem(GetSubMenu(hMenu, 3), M_WW, fWrap ? MF_CHECKED : MF_UNCHECKED);


    //
    // Disable 'goto' if word wrap; there is no obvious relationship
    // between the MLE line number and what the user sees.
    // fixes windows bug# 206587 (10/18/2000)
    //
    EnableMenuItem( GetSubMenu(GetMenu(hwndNP),1), 
                    M_GOTO, 
                    fWrap ? MF_GRAYED : MF_ENABLED );

}


void NpWinIniChange(VOID)
{
   InitLocale();
}

/* ** Scan sz1 for merge spec.    If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL MergeStrings(
    LPCTSTR szSrc,
    LPCTSTR szMerge,
    LPTSTR szDst)
{
    LPCTSTR pchSrc;
    LPTSTR  pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

    /* Find merge spec if there is one. */
    while( *pchSrc != chMerge)
    {
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if( !*pchSrc++ )
        {
            return FALSE;
        }

    }

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge)
    {
        while (*szMerge)
            *pchDst++ = *szMerge++;
    }

    /* Jump over merge spec */
    pchSrc++,pchSrc++;

    /* Now append rest of Src String */
    while( *pchSrc );
    {
        *pchDst++ = *pchSrc++;
    }
    return TRUE;

}

/* ** Post a message box */
INT AlertBox(
    HWND    hwndParent,
    LPCTSTR szCaption,
    LPCTSTR szText1,
    LPCTSTR szText2,
    UINT     style)
{
    INT iResult;                      // result of function
    INT iAllocSize;                   // size needed for message
    LPTSTR pszMessage;                // combined message

    // Allocate a message buffer assuming there will be a merge.
    // If we cannot do the allocation, tell the user something
    // related to the original problem. (not the allocation failure)
    // Then pray that MessageBox can get enough memory to actually work.

    iAllocSize= (lstrlen(szText1) + (szText2 ? lstrlen(szText2) : 0) + 1 ) * sizeof(TCHAR);

    pszMessage= (TCHAR*) LocalAlloc( LPTR, iAllocSize );

    if( pszMessage )
    {
        MergeStrings( szText1, szText2, pszMessage );
        iResult= MessageBox( hwndParent, pszMessage, szCaption, style );
        LocalFree( (HLOCAL) pszMessage );
    }
    else
    {
        iResult= MessageBox( hwndParent, szText1, szCaption, style );
    }

    return( iResult );
}

// SignalCommDlgError
//
// If a common dialog error occurred, put up reasonable message box.
//
// returns: TRUE if error occurred, FALSE if no error.
//

typedef struct tagMAPERROR
{
    DWORD   rc;            // return code from CommDlgExtendedError()
    PTCHAR* ppszMsg;       // text of message pointer
} MAPERROR;

// errors not in this list get generic "common dialog error %x" message.
static TCHAR* szNull= TEXT("");

MAPERROR maperror[]=
{
    CDERR_DIALOGFAILURE,  &szErrSpace,
    CDERR_INITIALIZATION, &szCommDlgInitErr,
    CDERR_MEMLOCKFAILURE, &szPDIE,
    CDERR_LOADSTRFAILURE, &szErrSpace,
    CDERR_FINDRESFAILURE, &szErrSpace,
    PDERR_LOADDRVFAILURE, &szLoadDrvFail,
    PDERR_GETDEVMODEFAIL, &szErrSpace,
    PDERR_NODEFAULTPRN,   &szNull,          // don't report; common dialog does already
};

BOOL SignalCommDlgError(VOID)
{
    DWORD rc;               // return code
    TCHAR* pszMsg;          // message
    INT    i;
    TCHAR  szBuf[200];      // just for common dialog failure

    rc= CommDlgExtendedError();

    // no failure - just return

    if( rc == 0 )
    {
        return FALSE;
    }

    // some sort of error - pick up message

    pszMsg= NULL;
    for( i=0; i< sizeof(maperror)/sizeof(maperror[0]); i++ )
    {
        if( rc == maperror[i].rc )
        {
            pszMsg= *maperror[i].ppszMsg;
        }
    }

    // if no known mapping - tell user the actual return code
    // this may be a bit confusing, but rare hopefully.

    if( !pszMsg )
    {
        _sntprintf(szBuf, sizeof(szBuf)/sizeof(TCHAR) -1, szCommDlgErr, rc);
        pszMsg= szBuf;
    }

    // popup if there is any message to give user

    if( *pszMsg )
    {
        MessageBox(hwndNP, pszMsg, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONSTOP);
    }

    return TRUE;

}

// ReplaceSel
//
// Replace the current selection with string from FR struct
// if the current selection matches our search string.
//
// MLE will show selection if bView is true.
//


VOID ReplaceSel( BOOL bView )
{
    DWORD StartSel;    // start of selected text
    DWORD EndSel;      // end of selected text

    HANDLE hEText;
    TCHAR* pStart;
    DWORD  ReplaceWithLength;  // length of replacement string
    DWORD  FindWhatLength;

    ReplaceWithLength= lstrlen(FR.lpstrReplaceWith);
    FindWhatLength= lstrlen(FR.lpstrFindWhat);

    SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &StartSel, (LPARAM) &EndSel );
    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return;
    }

    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return;
    }

    if(  (EndSel-StartSel) == FindWhatLength )
    {
       if( (fCase &&
            !_tcsncmp(  FR.lpstrFindWhat, pStart+StartSel, FindWhatLength) ) ||
           (!fCase &&
           ( 2 == CompareString(LOCALE_USER_DEFAULT,
                  NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                  FR.lpstrFindWhat, FindWhatLength,
                  pStart+StartSel,  FindWhatLength ) ) ) )
        {
            SendMessage( hwndEdit, EM_REPLACESEL,
                         TRUE, (LPARAM) FR.lpstrReplaceWith);
            SendMessage( hwndEdit, EM_SETSEL,
                         StartSel, StartSel+ReplaceWithLength );

            if( bView )
            {
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
    }

    LocalUnlock( hEText );
}

// GotoDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

const DWORD s_GotoHelpIDs[] = {
    IDC_GOTO, IDH_GOTO,
    0, 0
};

#define GOTOBUFSIZE 100
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    TCHAR szBuf[GOTOBUFSIZE];
    UINT LineNum;
    DWORD SelStart, SelEnd;

    switch (message)
    {
        //
        // initialize input field to size of file
        //
        case WM_INITDIALOG:
            SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

            // the line numbers are 1 based instead 0 based. hence add 1.
            LineNum= (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
            wsprintf(szBuf, TEXT("%d"), LineNum);
            SetDlgItemText( hDlg, IDC_GOTO, szBuf );
            SetFocus( hDlg );
            return TRUE;
            break;

        // context sensitive help.
        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                UINT CharIndex;

                case IDC_GOTO:
                    return TRUE;
                    break;

                case IDOK:
                    GetDlgItemText( hDlg, IDC_GOTO, szBuf, GOTOBUFSIZE );

                    // convert all unicode numbers to range L'0' to L'9'

                    FoldString( MAP_FOLDDIGITS, szBuf, -1, szBuf, GOTOBUFSIZE);
                    lGotoLine= _ttol( szBuf );

                    //
                    // see if valid line number
                    //

                    CharIndex= (UINT)SendMessage( hwndEdit,
                                            EM_LINEINDEX,
                                            lGotoLine-1,
                                            0);
                    if( lGotoLine > 0 && CharIndex != -1 )
                    {
                        EndDialog(hDlg, 0);  // successfull
                        return TRUE;
                    }

                    //
                    // Invalid line number
                    // warning user and set to reasonable value
                    //

                    MessageBox( hDlg, szLineTooLarge, szLineError, MB_OK );

                    LineNum= (UINT)SendMessage( hwndEdit, EM_GETLINECOUNT, 0, 0 );
                    wsprintf(szBuf, TEXT("%d"), LineNum);
                    SetDlgItemText( hDlg, IDC_GOTO, szBuf );
                    SetFocus( hDlg );
                    break;

                case IDCANCEL :
                    EndDialog(hDlg, 1 );   // cancelled
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)
            break;
    } // switch (message)

    return FALSE;     // Didn't process a message
}


INT_PTR CALLBACK SaveUnicodeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        int id;

        case WM_COMMAND :
            id = LOWORD(wParam);

            switch (id)
            {
                case IDC_SAVE_AS_UNICODE :
                case IDOK :
                case IDCANCEL :
                    EndDialog(hDlg, (int) LOWORD(wParam));
                    return TRUE;
            }
        break;
    }

    return FALSE;

    UNREFERENCED_PARAMETER( lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npdate.c ===
/* npdate - Code for getting and inserting current date and time.
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"

/* ** Replace current selection with date/time string.
 *    if fCrlf is true, date/time string should begin
 *    and end with crlf
*/
VOID InsertDateTime (BOOL fCrlf)
{
   SYSTEMTIME time ;
   TCHAR szDate[80] ;
   TCHAR szTime[80] ;
   TCHAR szDateTime[sizeof(szDate) + sizeof(szTime) + 10] = TEXT("");
   DWORD locale;
   BOOL bMELocale;
   DWORD dwFlags = DATE_SHORTDATE;

   //  See if the user locale id is Arabic or Hebrew.
   locale    = GetUserDefaultLCID();
   bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW));

   locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

   // Get the time
   GetLocalTime( &time ) ;

   if (bMELocale)
   {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
           lstrcat(szDateTime, TEXT("\x200F")); // RLM
       } else {
           dwFlags |= DATE_LTRREADING;
           lstrcat(szDateTime, TEXT("\x200E")); // LRM
       }
   }

   // Format date and time
   GetDateFormat(locale,dwFlags, &time,NULL,szDate,CharSizeOf(szDate));
   GetTimeFormat(locale,TIME_NOSECONDS,&time,NULL,szTime,CharSizeOf(szTime));

   if( fCrlf )
       lstrcat(szDateTime, TEXT("\r\n"));


   lstrcat(szDateTime, szTime);
   lstrcat(szDateTime, TEXT(" "));
   lstrcat(szDateTime, szDate);

   if( fCrlf )
        lstrcat(szDateTime, TEXT("\r\n"));

   // send it in one shot; this is also useful for undo command
   // so that user can undo the date-time.
   SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szDateTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npcss.c ===
/*
 * CSS support functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"


BOOL FIsCssWhitespaceW(WCHAR wch)
{
    return((wch == L' ') || (wch == L'\x9') || (wch == L'\xA') || (wch == L'\xC') || (wch == L'\xD'));
}


BOOL FIsCssWhitespaceA(char ch)
{
    return(FIsCssWhitespaceW((WCHAR) (BYTE) ch));
}


BOOL FIsCssA(LPCSTR rgch, UINT cch)
{
    if (memcmp(rgch, "@charset", 8) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FIsCssW(LPCWSTR rgwch, UINT cch)
{
    if (memcmp(rgwch, L"@charset", 8 * sizeof(WCHAR)) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FDetectCssEncodingA(LPCSTR rgch, UINT cch, UINT *pcp)
{
    const char *pchMax;
    const char *pch;
    char chQuote;
    const char *pchCharset;

    // Check for file begining with @charset

    if (cch < 13)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsCssA(rgch, cch))
    {
        // Not XML

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 8;

    while ((pch < pchMax) && FIsCssWhitespaceA(*pch))
    {
        pch++;
    }

    if ((pch == pchMax) || ((*pch != '\'') && (*pch != '"')))
    {
        // No @charset specification

        return(FALSE);
    }

    chQuote = *pch++;

    pchCharset = pch;

    while ((pch < pchMax) && (*pch != chQuote))
    {
        pch++;
    }

    if (pch == pchMax)
    {
        // No @charset specification

        return(FALSE);
    }

    // We have an CSS encoding declaration from pchCharset to (pch - 1)

    if (pch == pchCharset)
    {
        // No @charset specification

        return(FALSE);
    }

    // To be strict a CSS charset declaration should have optional whitespace then a semicolon here

    if (!FLookupCodepageNameA((LPCSTR) pchCharset, (UINT) (pch - pchCharset), pcp))
    {
        // Encoding is not recognized

        return(FALSE);
    }

    if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
    {
        // These are bogus since we know the file is MBCS

        return(FALSE);
    }

    return(FValidateCodepage(hwndNP, *pcp));
}


BOOL FDetectCssEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp)
{
    const WCHAR *pchMax;
    const WCHAR *pch;
    WCHAR chQuote;
    const WCHAR *pchCharset;

    // Check for file begining with @charset

    if (cch < 13)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsCssW(rgch, cch))
    {
        // No @charset specification

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 8;

    while ((pch < pchMax) && FIsCssWhitespaceW(*pch))
    {
        pch++;
    }

    if ((pch == pchMax) || ((*pch != L'\'') && (*pch != L'"')))
    {
        // No @charset specification

        return(FALSE);
    }

    chQuote = *pch++;

    pchCharset = pch;

    while ((pch < pchMax) && (*pch != chQuote))
    {
        pch++;
    }

    if (pch == pchMax)
    {
        // No @charset specification

        return(FALSE);
    }

    // We have an CSS encoding declaration from pchCharset to (pch - 1)

    if (pch == pchCharset)
    {
        // No @charset specification

        return(FALSE);
    }

    // To be strict a CSS charset declaration should have optional whitespace then a semicolon here

    if (!FLookupCodepageNameW(pchCharset, (UINT) (pch - pchCharset), pcp))
    {
        // Encoding is not recognized

        return(FALSE);
    }

#if 0
    if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
    {
        // These are bogus since we know the file is MBCS

        return(FALSE);
    }
#endif

    return(FValidateCodepage(hwndNP, *pcp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npmisc.c ===
/*
 * misc notepad functions
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"

BOOL fCase = FALSE;         // Flag specifying case sensitive search 
BOOL fReverse = FALSE;      // Flag for direction of search 

extern HWND hDlgFind;       // handle to modeless FindText window 

LPTSTR ReverseScan(
    LPTSTR lpSource,
    LPTSTR lpLast,
    LPTSTR lpSearch,
    BOOL fCaseSensitive )
{
   TCHAR cLastCharU;
   TCHAR cLastCharL;
   INT   iLen;

   cLastCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cLastCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   iLen = lstrlen(lpSearch);

   if (!lpLast)
      lpLast = lpSource + lstrlen(lpSource);

   do
   {
      if (lpLast == lpSource)
         return NULL;

      --lpLast;

      if (fCaseSensitive)
      {
         if (*lpLast != *lpSearch)
            continue;
      }
      else
      {
           if( !( *lpLast == cLastCharU || *lpLast == cLastCharL ) )
            continue;
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpLast, lpSearch, iLen))
            break;
      }
      else
      {
         //
         // compare whole string using locale specific comparison.
         // do not use C runtime version since it may be wrong.
         //

         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpLast,   iLen,
                    lpSearch, iLen) )
            break;
      }
   } while (TRUE);

   return lpLast;
}

LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive )
{
   TCHAR cFirstCharU;
   TCHAR cFirstCharL;
   int iLen = lstrlen(lpSearch);

   cFirstCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cFirstCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   while (*lpSource)
   {
      if (fCaseSensitive)
      {
         if (*lpSource != *lpSearch)
         {
            lpSource++;
            continue;
         }
      }
      else
      {
         if( !( *lpSource == cFirstCharU || *lpSource == cFirstCharL ) )
         {
            lpSource++;
            continue;
         }
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpSource, lpSearch, iLen))
            break;
      }
      else
      {
         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpSource, iLen,
                    lpSearch, iLen) )
            break;
      }

      lpSource++;
   }

   return *lpSource ? lpSource : NULL;
}


// search forward or backward in the edit control text for the given pattern
// It is the responsibility of the caller to set the cursor

BOOL Search (TCHAR * szKey)
{
    BOOL      bStatus= FALSE;
    TCHAR   * pStart, *pMatch;
    DWORD     StartIndex, LineNum, EndIndex;
    DWORD     SelStart, SelEnd, i;
    HANDLE    hEText;           // handle to edit text
    UINT      uSelState;
    HMENU     hMenu;
    BOOL      bSelectAll = FALSE;


    if (!*szKey)
        return( bStatus );

    SendMessage(hwndEdit, EM_GETSEL, (WPARAM)&SelStart, (LPARAM)&SelEnd);


    // when we finish the search, we highlight the text found, and continue 
    // the search after the end of the highlighted position (in forward 
    // case) or from the begining of the highlighted position in the reverse
    // direction (in reverse case). this would break if the user has 
    // selected all text. this hack would take care of it. (this is consistent
    // with VC editors' search too.

    hMenu = GetMenu(hwndNP);
    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if (uSelState == MF_GRAYED)
    {
        bSelectAll = TRUE;
        SelStart = SelEnd =0;
    }


    //
    // get pointer to edit control text to search
    //

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return( bStatus );
    }
    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return( bStatus );
    }

    if (fReverse)
    {
        // Get current line number 
        LineNum= (DWORD)SendMessage(hwndEdit, EM_LINEFROMCHAR, SelStart, 0);
        // Get index to start of the line
        StartIndex= (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, LineNum, 0);
        // Set upper limit for search text
        EndIndex= SelStart;
        pMatch= NULL;

        // Search line by line, from LineNum to 0
        i = LineNum;
        while (TRUE)
        {
            pMatch= ReverseScan(pStart+StartIndex,pStart+EndIndex,szKey,fCase);
            if (pMatch)
               break;
            // current StartIndex is the upper limit for the next search 
            EndIndex= StartIndex;

            if (i)
            {
                // Get start of the next line
                i-- ;
                StartIndex = (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, i, 0);
            }
            else
               break ;
        }
    }
    else
    {
            pMatch= ForwardScan(pStart+SelEnd, szKey, fCase);
    }

    LocalUnlock(hEText);

    if (pMatch == NULL)
    {
        //
        // alert user on not finding any text unless it is replace all
        //
        if( !(FR.Flags & FR_REPLACEALL) )
        {
            HANDLE hPrevCursor= SetCursor( hStdCursor );
            AlertBox( hDlgFind ? hDlgFind : hwndNP,
                      szNN,
                      szCFS,
                      szSearch,
                      MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
            SetCursor( hPrevCursor );
        }
    }
    else
    {
        SelStart = (DWORD)(pMatch - pStart);
        SendMessage( hwndEdit, EM_SETSEL, SelStart, SelStart+lstrlen(szKey));

        // since we are selecting the found text, enable SelectAll again.
        if (bSelectAll)
        {
            EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
        }

        //
        // show the selected text unless it is replace all
        //

        if( !(FR.Flags & FR_REPLACEALL) )
        {
            SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
        }
        bStatus= TRUE;   // found
    }

    return( bStatus );
}

// Recreate notepad edit window, get text from old window and put in new window. 
// Called when user changes style from wrap on/off 
//
// Called with the style of the new window
//

BOOL NpReCreate( long style )
{
    RECT    rcT1;
    HWND    hwndT1;
    HANDLE  hT1;
    int     cchTextNew;
    TCHAR*  pchText;
    BOOL    fWrapIsOn = ((style & WS_HSCROLL) != 0);
    HCURSOR hPrevCursor;
    BOOL    bModified;     // modify flag from old edit buffer

    // if wordwrap, remove soft carriage returns 

    hPrevCursor= SetCursor( hWaitCursor );     // this may take some time...
    if( fWrapIsOn ) 
    {
        GotoAndScrollInView(1);  // get around MLE bug

        SendMessage(hwndEdit, EM_FMTLINES, FALSE, 0L);
    }

    bModified= (SendMessage( hwndEdit, EM_GETMODIFY, 0,0 ) != 0);

    cchTextNew= (int)SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0L );
    hT1= LocalAlloc( LMEM_MOVEABLE, ByteCountOf(cchTextNew + 1) );
    if( !hT1 )
    {
        // failed, restore wordwrap; insert soft carriage returns
        if( fWrapIsOn )
        {
            SendMessage(hwndEdit, EM_FMTLINES, TRUE, 0L);
        }
        SetCursor( hPrevCursor );
        return FALSE;
    }

    GetClientRect( hwndNP, (LPRECT)&rcT1 );

    //
    // save the current edit control text.
    //

    pchText= LocalLock (hT1);
    SendMessage( hwndEdit, WM_GETTEXT, cchTextNew+1, (LPARAM)pchText );
    hwndT1= CreateWindowEx( WS_EX_CLIENTEDGE,
        TEXT("Edit"),
        TEXT(""), // pchText
        style,
        0,
        0,
        rcT1.right,
        rcT1.bottom,
        hwndNP,
        (HMENU)ID_EDIT,
        hInstanceNP, NULL );
    if( !hwndT1 )
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )      // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        LocalUnlock(hT1);
        LocalFree(hT1);
        return FALSE;
    }

    //
    // The user can "add" styles to the edit window after it is
    // created (like WS_EX_RTLREADING) when language packs are installed.
    // Preserve these styles when changing the word wrap.
    //

    SetWindowLong( hwndT1 ,
                   GWL_EXSTYLE ,
                   GetWindowLong( hwndEdit , GWL_EXSTYLE )|WS_EX_CLIENTEDGE ) ;

    // Set font before set text to save time calculating
    SendMessage( hwndT1, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0) );

    if (!SendMessage (hwndT1, WM_SETTEXT, 0, (LPARAM) pchText))
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )   // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        DestroyWindow( hwndT1 );
        LocalUnlock( hT1 );
        LocalFree( hT1 );
        return FALSE;
    }
    LocalUnlock(hT1);


    DestroyWindow( hwndEdit );     // out with the old
    hwndEdit = hwndT1;             // in with the new

    // free the earlier allocated memory in hEdit

    if (hEdit)
        LocalFree(hEdit);

    hEdit = hT1;

    // limit text for safety's sake.

    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    ShowWindow(hwndNP, SW_SHOW);
    SendMessage( hwndEdit, EM_SETMODIFY, bModified, 0L );
    SetFocus(hwndEdit);

    SetCursor( hPrevCursor );   // restore cursor

    // redraw the status bar

    if( fStatus )
    {
        RECT rcClient;
        GetClientRect(hwndNP, &rcClient);
        NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
        ShowWindow( hwndStatus, SW_SHOW );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npfile.c ===
/*
 * npfile.c  - Routines for file i/o for notepad
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"


HANDLE  hFirstMem;
const CHAR BOM_UTF8[3] = {(BYTE) 0xEF, (BYTE) 0xBB, (BYTE)0xBF};



//****************************************************************
//
//   ReverseEndian
//
//   Purpose: copies unicode character from one endian source
//            to another.
//
//            may work on lpDst == lpSrc
//

VOID ReverseEndian( PTCHAR lpDst, PTCHAR lpSrc, DWORD nChars )
{
    DWORD  cnt;

    for( cnt=0; cnt < nChars; cnt++,lpDst++,lpSrc++ )
    {
        *lpDst= (TCHAR) (((*lpSrc<<8) & 0xFF00) + ((*lpSrc>>8)&0xFF));
    }
}

//*****************************************************************
//
//   AnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//   Returns     : TRUE is successful, FALSE if not
//                 GetLastError() will have the error code.
//
//*****************************************************************

BOOL AnsiWriteFile(HANDLE  hFile,    // file to write to
                   UINT uCodePage,   // code page to convert unicode to
                   LPVOID lpBuffer,  // unicode buffer
                   DWORD nChars,     // number of unicode chars
                   DWORD nBytes )    // number of ascii chars to produce
{
    LPSTR   lpAnsi;              // pointer to allocate buffer
    BOOL    Done;                // status from write (returned)
    DWORD   nBytesWritten;       // number of bytes written

    lpAnsi= (LPSTR) LocalAlloc( LPTR, nBytes + 1 );
    if( !lpAnsi )
    {
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
       return (FALSE);
    }

    ConvertFromUnicode(uCodePage,         // code page
                       g_fSaveEntity,     // fNoBestFit
                       g_fSaveEntity,     // fWriteEntities
                       (LPWSTR) lpBuffer, // wide char buffer
                       nChars,            // chars in wide char buffer
                       lpAnsi,            // resultant ascii string
                       nBytes,            // size of ascii string buffer
                       NULL);             // flag to set if default char used
                                          
    Done = WriteFile(hFile, lpAnsi, nBytes, &nBytesWritten, NULL);

    LocalFree(lpAnsi);

    return(Done);

} // end of AnsiWriteFile()



// Routines to deal with the soft EOL formatting.
//
// MLE Actually inserts characters into the text being under edit, so they
// have to be removed before saving the file.
//
// It turns out that MLE will get confused if the current line is bigger than
// the current file, so we will reset the cursor to 0,0 to keep it from looking stupid.
// Should be fixed in MLE, but...
//

VOID ClearFmt(VOID) 
{
    if( fWrap )
    {
        GotoAndScrollInView( 1 );

        SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)FALSE, 0 );// remove soft EOLs

    }
}

VOID RestoreFmt(VOID)
{
    if( fWrap )
    {
        NpReCreate( ES_STD );   // slow but it works
    }
}


BOOL FDetectEncodingW(LPCTSTR szFile, LPCWSTR rgch, UINT cch, UINT *pcp)
{
    TCHAR szExt[_MAX_EXT];

    if (FDetectXmlEncodingW(rgch, cch, pcp))
    {
        // We recognized this as an XML file with a valid encoding

        return TRUE;
    }

    if (FDetectHtmlEncodingW(rgch, cch, pcp))
    {
        // We recognized this as an HTML file with a valid encoding

        return TRUE;
    }

    _wsplitpath(szFile, NULL, NULL, NULL, szExt);

    if (lstrcmpi(szExt, TEXT(".css")) == 0)
    {
        if (FDetectCssEncodingW(rgch, cch, pcp))
        {
            // We recognized this as CSS file with a valid encoding

            return TRUE;
        }
    }

    return FALSE;
}


/* Save notepad file to disk.  szFileSave points to filename.  fSaveAs
   is TRUE iff we are being called from SaveAsDlgProc.  This implies we must
   open file on current directory, whether or not it already exists there
   or somewhere else in our search path.
   Assumes that text exists within hwndEdit.    30 July 1991  Clark Cyr
 */

BOOL SaveFile(HWND hwndParent, LPCTSTR szFile, BOOL fSaveAs)
{
  LPTSTR    lpch;
  UINT      nChars;
  BOOL      flag;
  BOOL      fNew = FALSE;
  BOOL      fSaveEntity;
  BOOL      fDefCharUsed = FALSE;
  BOOL*     pfDefCharUsed;
  static const WCHAR wchBOM = BYTE_ORDER_MARK;
  static const WCHAR wchRBOM = REVERSE_BYTE_ORDER_MARK;
  HLOCAL    hEText;                // handle to MLE text
  UINT cpDetected;
  DWORD     nBytesWritten;         // number of bytes written
  UINT      cchMbcs;               // length of equivalent MBCS file


    if (g_cpSave == CP_AUTO)
    {
        UINT cch;
        HANDLE hText;
        int id;

        g_cpSave = g_cpOpened;

        // Check for an HTML or XML file with a declared encoding
        // If one is found, suggest the declared encoding

        cch = (UINT) SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0);
        hText = (HANDLE) SendMessage(hwndEdit, EM_GETHANDLE, 0, 0);

        if (hText != NULL)
        {
            LPCTSTR rgwch = (LPTSTR) LocalLock(hText);

            if (rgwch != NULL)
            {
                if (FDetectEncodingW(szFile, rgwch, cch, &cpDetected))
                {
                    // We detected an expected encoding for this file

                    g_cpSave = cpDetected;
                }

                LocalUnlock(hText);
            }
        }

        id = (int) DialogBoxParam(hInstanceNP,
                                  MAKEINTRESOURCE(IDD_SELECT_ENCODING),
                                  hwndNP,
                                  SelectEncodingDlgProc,
                                  (LPARAM) &g_cpSave);

        if (id == IDCANCEL)
        {
            return(FALSE);
        }
    }


    /* If saving to an existing file, make sure correct disk is in drive */
    if (!fSaveAs)
    {
       fp = CreateFile(szFile,                     // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ,            // share mode
                       NULL,                       // security descriptor
                       OPEN_EXISTING,              // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs
    }
    else
    {

       // Carefully open the file.  Do not truncate it if it exists.
       // set the fNew flag if it had to be created.
       // We do all this in case of failures later in the process.

       fp = CreateFile(szFile,                     // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                       NULL,                       // security descriptor
                       OPEN_ALWAYS,                // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs

       if( fp != INVALID_HANDLE_VALUE )
       {
          fNew= (GetLastError() != ERROR_ALREADY_EXISTS );
       }
    }

    if( fp == INVALID_HANDLE_VALUE )
    {
        if (fSaveAs)
          AlertBox( hwndParent, szNN, szCREATEERR, szFile,
                    MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return FALSE;
    }


    // if wordwrap, remove soft carriage returns 
    // Also move the cursor to a safe place to get around MLE bugs
    
    ClearFmt();

    /* Must get text length after formatting */

    nChars = (UINT) SendMessage(hwndEdit, WM_GETTEXTLENGTH, 0, 0);
    hEText = (HANDLE) SendMessage(hwndEdit, EM_GETHANDLE, 0, 0);

    if ((hEText == NULL) || ((lpch = (LPTSTR) LocalLock(hEText)) == NULL))
    {
       goto FailFile;
    }
       
Retry:
    // Determine the SaveAs file type, and write the appropriate BOM.
    // If the filetype is UTF-8 or Ansi, do the conversion.

    if (FDetectEncodingW(szFile, lpch, nChars, &cpDetected))
    {
        // We detected an expected encoding for this file

        if (g_cpSave != cpDetected)
        {
            int id;

            // Display a warning that encodings do not match

            id = MessageBox(hwndNP,
                            szEncodingMismatch,
                            szNN,
                            MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONWARNING);

            if (id == IDCANCEL)
            {
                goto CleanUp;
            }

            if (id == IDYES)
            {
                g_cpSave = cpDetected;
            }
        }
    }

    switch (g_cpSave)
    {
        case CP_UTF16 :
            if (g_wbSave != wbNo)
            {
                WriteFile(fp, &wchBOM, ByteCountOf(1), &nBytesWritten, NULL);
            }

            flag = WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
            break;

        case CP_UTF16BE :
            if (g_wbSave != wbNo)
            {
                WriteFile(fp, &wchRBOM, ByteCountOf(1), &nBytesWritten, NULL);
            }

            ReverseEndian(lpch, lpch, nChars);
            flag = WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
            ReverseEndian(lpch, lpch, nChars);
            break;

        case CP_UTF8 :
            // For UTF-8, write the BOM and continue to the default case.
            // For XML, do NOT write a BOM for wbDefault

            if ((g_wbSave == wbYes) || ((g_wbSave == wbDefault) && !FIsXmlW(lpch, nChars)))
            {
                WriteFile(fp, &BOM_UTF8, 3, &nBytesWritten, NULL);
            }

            // Fall through to convert and write the file

        default:
            fSaveEntity = g_fSaveEntity && FSupportWriteEntities(g_cpSave);

            pfDefCharUsed = NULL;

            if (!fSaveEntity && (g_cpSave != CP_UTF8))
            {
                pfDefCharUsed = &fDefCharUsed;
            }

            cchMbcs = ConvertFromUnicode(g_cpSave,
                                         TRUE,
                                         fSaveEntity,
                                         (LPWSTR) lpch,
                                         nChars,
                                         NULL,
                                         0,
                                         pfDefCharUsed);

            if (fDefCharUsed)
            {
                int id = (int) DialogBox(hInstanceNP,
                                         MAKEINTRESOURCE(IDD_SAVE_UNICODE_DIALOG),
                                         hwndNP,
                                         SaveUnicodeDlgProc);

                switch (id)
                {
                    case IDC_SAVE_AS_UNICODE :
                        g_cpSave = CP_UTF16;
                        goto Retry;

                    case IDOK :
                        // Continue.

                        break;

                    case IDCANCEL :
                        goto CleanUp;
                }
            }

            if (pfDefCharUsed != NULL)
            {
                // We need to convert again because WideCharToMultiByte
                // sometimes fails with pfDefUsedChar != NULL.

                cchMbcs = ConvertFromUnicode(g_cpSave,
                                             fSaveEntity,
                                             fSaveEntity,
                                             (LPWSTR) lpch,
                                             nChars,
                                             NULL,
                                             0,
                                             NULL);

            }

            flag = AnsiWriteFile(fp, g_cpSave, lpch, nChars, cchMbcs);
            break;
    }

    if (!flag)
    {
       SetCursor(hStdCursor);     /* display normal cursor */

FailFile:
       AlertUser_FileFail(szFile);
CleanUp:
       SetCursor(hStdCursor);

       CloseHandle(fp); fp=INVALID_HANDLE_VALUE;

       if( hEText )
           LocalUnlock( hEText );

       if (fNew)
          DeleteFile(szFile);

       //
       // if wordwrap, insert soft carriage returns 
       //

       RestoreFmt();

       return FALSE;
    }

    SetEndOfFile(fp);

    g_cpOpened = g_cpSave;
    g_wbOpened = g_wbSave;

    SendMessage(hwndEdit, EM_SETMODIFY, FALSE, 0L);

    SetFileName(szFile);

    CloseHandle(fp); fp=INVALID_HANDLE_VALUE;

    if( hEText )
        LocalUnlock( hEText );

    //
    // if wordwrap, insert soft carriage returns 
    //

    RestoreFmt();

    // Display the normal cursor
    SetCursor(hStdCursor);

    return TRUE;
} // end of SaveFile()


/* Read contents of file from disk.
 * Do any conversions required.
 * File is already open, referenced by handle fp
 * Close the file when done.
 * If cpOpen != CP_AUTO, then use it as codepage, otherwise do automagic guessing.
 */

BOOL LoadFile(LPCTSTR szFile, BOOL fSelectEncoding)
{
    UINT      len, i, nChars;
    LPTSTR    lpch=NULL;
    LPTSTR    lpBuf;
    LPSTR     lpBufAfterBOM;
    UINT      cpOpen;
    BOOL      fLog=FALSE;
    TCHAR*    p;
    BY_HANDLE_FILE_INFORMATION fiFileInfo;
    BOOL      bStatus;          // boolean status
    HLOCAL    hNewEdit=NULL;    // new handle for edit buffer
    HANDLE    hMap;             // file mapping handle
    TCHAR     szNullFile[2];    // fake null mapped file

    if( fp == INVALID_HANDLE_VALUE )
    {
       AlertUser_FileFail( szFile );
       return (FALSE);
    }

    //
    // Get size of file
    // We use this heavy duty GetFileInformationByHandle API
    // because it finds bugs.  It takes longer, but it only is
    // called at user interaction time.
    //

    bStatus= GetFileInformationByHandle( fp, &fiFileInfo );
    len= (UINT) fiFileInfo.nFileSizeLow;

    // NT may delay giving this status until the file is accessed.
    // i.e. the open succeeds, but operations may fail on damaged files.

    if( !bStatus )
    {
        AlertUser_FileFail( szFile );
        CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;
        return( FALSE );
    }

    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.
    //
    // bug# 168148: silently fails to open 2.4 gig text file on win64
    // Caused by trying to convert ascii file to unicode which overflowed
    // the dword length handled by multibytetowidechar conversion.
    // Since no one will be happy with the performance of the MLE with
    // a file this big, we will just refuse to open it now.
    //
    // For example, on a Pentium 173 MHz with 192 Megs o'RAM (Tecra 8000) 
    // I got these results:
    //
    // size   CPU-time
    //    0    .12
    //    1    .46
    //    2    .77
    //    3   1.041
    //    4   1.662
    //    5   2.092
    //    6   2.543
    //    7   3.023
    //    8   3.534
    //    9   4.084
    //   10   4.576
    //   16   8.371
    //   32  23.142
    //   64  74.426
    //
    //  Curve fitting these numbers to cpu-time=a+b*size+c*size*size
    //     we get a really good fit with cpu= .24+.28*size+.013*size*size
    //
    // For 1 gig, this works out to be 3.68 hours.  2 gigs=14.6 hours
    //
    // And the user isn't going to be happy with adding or deleting characters
    // with the MLE control.  It wants to keep the memory stuctures uptodate
    // at all times.
    //
    // Going to richedit isn't a near term solution either:
    //
    // size    CPU-time
    // 2       3.8
    // 4       9.0
    // 6      21.9
    // 8      30.4
    // 10     65.3
    // 16   1721 or >3.5 hours (it was still running when I killed it)
    //
    //
    // feature: should we only bail if not unicode?
    //

    if( len >=0x4000000 || fiFileInfo.nFileSizeHigh != 0 )
    {
       AlertBox( hwndNP, szNN, szErrSpace, szFile,
                 MB_APPLMODAL | MB_OK | MB_ICONWARNING );
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       return (FALSE);
    }

    SetCursor(hWaitCursor);                // physical I/O takes time

    //
    // Create a file mapping so we don't page the file to
    // the pagefile.  This is a big win on small ram machines.
    //

    if( len != 0 )
    {
        lpBuf= NULL;

        hMap= CreateFileMapping( fp, NULL, PAGE_READONLY, 0, len, NULL );

        if( hMap )
        {
            lpBuf= MapViewOfFile( hMap, FILE_MAP_READ, 0,0,len);
            CloseHandle( hMap );
        }
    }
    else  // file mapping doesn't work on zero length files
    {
        lpBuf= (LPTSTR) &szNullFile;
        *lpBuf= 0;  // null terminate
    }

    CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;

    if( lpBuf == NULL )
    {
        SetCursor( hStdCursor );
        //
        // bug# 192007: Opening migrated files with bad RSS gives bad error msg
        //
        // We used to just say 'out of memory', but that was wrong.
        // We will now give the standard OS error message.
        // If the user doesn't understand that, then FormatMessage s/b be fixed.
        //
        AlertUser_FileFail( szFile );
        return( FALSE );
    }


    //
    // protect access to the mapped file with a try/except so we
    // can detect I/O errors.
    //

    //
    // WARNING: be very very careful.  This code is pretty fragile.
    // Files across the network, or RSM files (tape) may throw excepts
    // at random points in this code.  Anywhere the code touches the
    // memory mapped file can cause an AV.  Make sure variables are
    // in consistent state if an exception is thrown.  Be very careful
    // with globals.

    __try
    {
    /* Determine the file type and number of characters
     * If the user overrides, use what is specified.
     * Otherwise, we depend on 'IsTextUnicode' getting it right.
     * If it doesn't, bug IsTextUnicode.
     */

    cpOpen = g_cpDefault;

    if (fSelectEncoding || (cpOpen == CP_AUTO))
    {
        switch (*lpBuf)
        {
            TCHAR szExt[_MAX_EXT];

            case BYTE_ORDER_MARK:
                cpOpen = CP_UTF16;
                break;

            case REVERSE_BYTE_ORDER_MARK:
                cpOpen = CP_UTF16BE;
                break;

            case BOM_UTF8_HALF:
                // UTF-8 BOM has 3 bytes; if it doesn't have UTF-8 BOM just fall through ..

                if ((len > 2) && (((BYTE *) lpBuf)[2] == BOM_UTF8_2HALF))
                {
                    cpOpen = CP_UTF8;
                    break;
                }

                // Fall through

            default:
                // Is the file Unicode without BOM ?

                if (IsInputTextUnicode((LPSTR) lpBuf, len))
                {
                    cpOpen = CP_UTF16;
                    break;
                }

                if (FDetectXmlEncodingA((LPSTR) lpBuf, len, &cpOpen))
                {
                    // We recognized this as an XML file with a valid encoding

                    break;
                }

                if (FDetectHtmlEncodingA((LPSTR) lpBuf, len, &cpOpen))
                {
                    // We recognized this as an HTML file with a valid encoding

                    break;
                }

                _wsplitpath(szFile, NULL, NULL, NULL, szExt);

                if (lstrcmpi(szExt, TEXT(".css")) == 0)
                {
                    if (FDetectCssEncodingA((LPSTR) lpBuf, len, &cpOpen))
                    {
                        // We recognized this as an HTML file with a valid encoding

                        break;
                    }
                }

                // Is the file UTF-8 even though it doesn't have UTF-8 BOM.

                if (IsTextUTF8((LPSTR) lpBuf, len))
                {
                    cpOpen = CP_UTF8;
                    break;
                }

                // Well, assume default or ANSI if no default

                if (fSelectEncoding)
                {
                    // Use MLANG to detect the encoding as default in Select Encoding dialog

                    if (FDetectEncodingA((LPSTR) lpBuf, len, &cpOpen))
                    {
                        // We recognized this as an XML file with a valid encoding

                        break;
                    }
                }

                // Use default

                cpOpen = g_cpDefault;

                if (cpOpen == CP_AUTO)
                {
                    cpOpen = g_cpANSI;
                }
                break;
        }             
    }

    if (fSelectEncoding)
    {
        int id;

        id = (int) DialogBoxParam(hInstanceNP,
                                  MAKEINTRESOURCE(IDD_SELECT_ENCODING),
                                  hwndNP,
                                  SelectEncodingDlgProc,
                                  (LPARAM) &cpOpen);

        if (id == IDCANCEL)
        {
            if (lpBuf != (LPTSTR) &szNullFile)
            {
                UnmapViewOfFile(lpBuf);
            }

            return(FALSE);
        }
    }

    lpBufAfterBOM = (LPSTR) lpBuf;

    if (cpOpen == CP_UTF16)
    {
        if ((len >= sizeof(WCHAR)) && ((*(WCHAR *) lpBuf) == BYTE_ORDER_MARK))
        {
            // Skip the BOM

            lpBufAfterBOM = (LPSTR) lpBuf + sizeof(WCHAR);
            len -= sizeof(WCHAR);
        }
    }

    else if (cpOpen == CP_UTF16BE)
    {
        if ((len >= sizeof(WCHAR)) && ((*(WCHAR *) lpBuf) == REVERSE_BYTE_ORDER_MARK))
        {
            // Skip the BOM

            lpBufAfterBOM = (LPSTR) lpBuf + sizeof(WCHAR);
            len -= sizeof(WCHAR);
        }
    }

    else if (cpOpen == CP_UTF8)
    {
        if ((len >= 3) && ((*(WCHAR *) lpBuf) == BOM_UTF8_HALF) && (((BYTE *) lpBuf)[2] == BOM_UTF8_2HALF))
        {
            // Skip the BOM

            lpBufAfterBOM = (LPSTR) lpBuf + 3;
            len -= 3;
        }
    }

    // Find out no. of chars present in the string.

    if ((cpOpen == CP_UTF16) || (cpOpen == CP_UTF16BE))
    {
        nChars = len / sizeof(WCHAR);
    }

    else
    {
        nChars = ConvertToUnicode(cpOpen, (LPSTR) lpBufAfterBOM, len, NULL, 0);
    }

    //
    // Don't display text until all done.
    //

    SendMessage(hwndEdit, WM_SETREDRAW, FALSE, 0);

    // Reset selection to 0

    SendMessage(hwndEdit, EM_SETSEL, 0, 0L);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    // resize the edit buffer
    // if we can't resize the memory, inform the user

    hNewEdit= LocalReAlloc(hEdit, ByteCountOf(nChars + 1), LMEM_MOVEABLE);

    if( !hNewEdit )
    {
       TCHAR szFileT[MAX_PATH]; /* Private copy of current filename */

      /* Bug 7441: New() modifies szFileOpened to which szFile may point.
       *           Save a copy of the filename to pass to AlertBox.
       *  17 November 1991    Clark R. Cyr
       */
       lstrcpy(szFileT, szFile);
       New(FALSE);

       /* Display the hour glass cursor */
       SetCursor(hStdCursor);

       AlertBox( hwndNP, szNN, szFTL, szFileT,
                 MB_APPLMODAL | MB_OK | MB_ICONWARNING);
       if( lpBuf != (LPTSTR) &szNullFile )
       {
           UnmapViewOfFile( lpBuf );
       }

       // let user see old text

       SendMessage(hwndEdit, WM_SETREDRAW, FALSE, 0);
       return FALSE;
    }

    /* Transfer file from temporary buffer to the edit buffer */
    lpch= (LPTSTR) LocalLock(hNewEdit);

    if (cpOpen == CP_UTF16)
    {
        CopyMemory(lpch, lpBufAfterBOM, ByteCountOf(nChars));
    }

    else if (cpOpen == CP_UTF16BE)
    {
        ReverseEndian(lpch, (LPTSTR) lpBufAfterBOM, nChars);
    }

    else
    {      
        ConvertToUnicode(cpOpen, (LPSTR) lpBufAfterBOM, len, lpch, nChars);
    }

    // Got everything; update global safe now

    g_cpOpened = cpOpen;

    if ((cpOpen != CP_UTF16) && (cpOpen != CP_UTF16BE) && (cpOpen != CP_UTF8))
    {
        g_wbOpened = wbDefault;
    }

    else if (lpBufAfterBOM != (LPSTR) lpBuf)
    {
        g_wbOpened = wbYes;
    }

    else
    {
        g_wbOpened = wbNo;
    }

    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AlertBox( hwndNP, szNN, szDiskError, szFile,
            MB_APPLMODAL | MB_OK | MB_ICONWARNING );
        nChars= 0;   // don't deal with it.
    }

    /* Free file mapping */
    if( lpBuf != (LPTSTR) &szNullFile )
    {
        UnmapViewOfFile( lpBuf );
    }

    if( lpch ) 
    {

       // Fix any NUL character that came in from the file to be spaces.

       for (i = 0, p = lpch; i < nChars; i++, p++)
       {
          if( *p == (TCHAR) 0 )
             *p= TEXT(' ');
       }
      
       // null terminate it.  Safe even if nChars==0 because it is 1 TCHAR bigger

       *(lpch+nChars)= (TCHAR) 0;      /* zero terminate the thing */
   
       // Set 'fLog' if first characters in file are ".LOG"
   
       fLog= *lpch++ == TEXT('.') && *lpch++ == TEXT('L') &&
             *lpch++ == TEXT('O') && *lpch == TEXT('G');
    }
   
    if( hNewEdit )
    {
       LocalUnlock( hNewEdit );

       // now it is safe to set the global edit handle

       hEdit= hNewEdit;
    }

    SetFileName(szFile);

  /* Pass handle to edit control.  This is more efficient than WM_SETTEXT
   * which would require twice the buffer space.
   */

  /* Bug 7443: If EM_SETHANDLE doesn't have enough memory to complete things,
   * it will send the EN_ERRSPACE message.  If this happens, don't put up the
   * out of memory notification, put up the file to large message instead.
   *  17 November 1991     Clark R. Cyr
   */
    dwEmSetHandle = SETHANDLEINPROGRESS;
    SendMessage(hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0);
    if (dwEmSetHandle == SETHANDLEFAILED)
    {
       SetCursor(hStdCursor);

       dwEmSetHandle = 0;
       AlertBox(hwndNP, szNN, szFTL, szFile, MB_APPLMODAL|MB_OK|MB_ICONWARNING);
       New(FALSE);
       SendMessage (hwndEdit, WM_SETREDRAW, TRUE, 0);
       return(FALSE);
    }
    dwEmSetHandle = 0;

    PostMessage (hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L);

    /* If file starts with ".LOG" go to end and stamp date time */
    if (fLog)
    {
       SendMessage( hwndEdit, EM_SETSEL, (WPARAM)nChars, (LPARAM)nChars);
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
       InsertDateTime(TRUE);
    }

    /* Move vertical thumb to correct position */
    SetScrollPos(hwndNP,
                 SB_VERT,
                 (int) SendMessage (hwndEdit, WM_VSCROLL, EM_GETTHUMB, 0),
                 TRUE);

    /* Now display text */
    SendMessage(hwndEdit, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(hwndEdit, NULL, TRUE);
    UpdateWindow(hwndEdit);

    SetCursor(hStdCursor);

    return( TRUE );
}

/* New Command - reset everything
 */

void New(BOOL fCheck)
{
    HANDLE hTemp;
    TCHAR* pSz;

    if (!fCheck || CheckSave (FALSE))
    {
        SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM) TEXT(""));

        SetFileName(NULL);

        SendMessage(hwndEdit, EM_SETSEL, 0, 0);
        SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

        // resize of 1 NULL character i.e. zero length

        hTemp= LocalReAlloc( hEdit, sizeof(TCHAR), LMEM_MOVEABLE );
        if( hTemp )
        {
           hEdit= hTemp;
        }

        // null terminate the buffer.  LocalReAlloc won't do it
        // because in all cases it is not growing which is the
        // only time it would zero out anything.

        pSz= LocalLock( hEdit );
        *pSz= TEXT('\0');
        LocalUnlock( hEdit );

        SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0L);
        szSearch[0] = (TCHAR) 0;

        // Set encoding of new document

        g_cpOpened = g_cpDefault;

        if (g_cpOpened == CP_AUTO)
        {
            g_cpOpened = g_cpANSI;
        }

        g_wbOpened = wbDefault;
    }

} // end of New()

/* If sz does not have extension, append ".txt"
 * This function is useful for getting to undecorated filenames
 * that setup apps use.  DO NOT CHANGE the extension.  Too many setup
 * apps depend on this functionality.
 */

void AddExt( TCHAR* sz )
{
    TCHAR*   pch1;
    int      ch;
    DWORD    dwSize;

    dwSize= lstrlen(sz);

    pch1= sz + dwSize;   // point to end

    ch= *pch1;
    while( ch != TEXT('.') && ch != TEXT('\\') && ch != TEXT(':') && pch1 > sz)
    {
        //
        // backup one character.  Do NOT use CharPrev because
        // it sometimes doesn't actually backup.  Some Thai
        // tone marks fit this category but there seems to be others.
        // This is safe since it will stop at the beginning of the
        // string or on delimiters listed above.  bug# 139374 2/13/98
        //
        // pch1= (TCHAR*)CharPrev (sz, pch1);
        pch1--;  // back up
        ch= *pch1;
    }

    if( *pch1 != TEXT('.') )
    {
       if( dwSize + sizeof(".txt") <= MAX_PATH ) {  // avoid buffer overruns
           lstrcat( sz, TEXT(".txt") );
       }
    }

}


/* AlertUser_FileFail(LPTSTR szFile)
 *
 * szFile is the name of file that was attempted to open.
 * Some sort of failure on file open.  Alert the user
 * with some monologue box.  At least give him decent
 * error messages.
 */

VOID AlertUser_FileFail(LPCTSTR szFile)
{
    TCHAR msg[256];     // buffer to format message into
    DWORD dwStatus;     // status from FormatMessage
    UINT  style= MB_APPLMODAL | MB_OK | MB_ICONWARNING;

    // Check GetLastError to see why we failed
    dwStatus=
    FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   GetUserDefaultLangID(),
                   msg,  // where message will end up
                   CharSizeOf(msg), NULL );
    if( dwStatus )
    {
        MessageBox(hwndNP, msg, szNN, style);
    }
    else
    {
        AlertBox(hwndNP, szNN, szDiskError, szFile, style);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npinit.c ===
/*
 *   Notepad application
 *
 *      Copyright (C) 1984-2000 Microsoft Corporation
 *
 *      NPInit - One time init for notepad.
 */

#include "precomp.h"


TCHAR chPageText[2][PT_LEN];    /* Strings to hold PageSetup items.        */
TCHAR chPageTextTemp[2][PT_LEN];
TCHAR szPrinterName[256];       /* String to hold printername for PrintTo verb */

static UINT cpDefault;
static INT fSaveWindowPositions=0;    /* true if we are to save window position  */

static INT g_WPtop,g_WPleft,g_WPDX,g_WPDY;   /* initial window positions          */

/* routines to handle saving and restoring information in the registry.
 *
 * SaveGlobals - saves interesting globals to the registry
 *
 * GetGlobals  - gets interesting globals from the registry
 *
 * Interesting Globals:
 *
 * FontStruct information include calculated pointsize
 * Codepage
 *
 * If we want to save PageSetup info, save the margins in some
 * units (cm for example) and convert on input and output.
 */

/* name of section to save into -- never internationalize */
#define OURKEYNAME TEXT("Software\\Microsoft\\Notepad")

// RegWriteInt - write an integer to the registry

VOID RegWriteInt( HKEY hKey, PTCHAR pszKey, INT iValue )
{
    RegSetValueEx( hKey, pszKey, 0, REG_DWORD, (BYTE*)&iValue, sizeof(INT) );
}

// RegWriteString - write a string to the registry

VOID RegWriteString( HKEY hKey, PTCHAR pszKey, PTCHAR pszValue )
{
    INT len;     // length of string with null in bytes

    len= (lstrlen( pszValue )+1) * sizeof(TCHAR);
    RegSetValueEx( hKey, pszKey, 0, REG_SZ, (BYTE*)pszValue, len );
}

// RegGetInt - Get integer from registry

DWORD RegGetInt( HKEY hKey, PTCHAR pszKey, DWORD dwDefault )
{
    DWORD dwResult= !ERROR_SUCCESS;
    LONG  lStatus= ERROR_SUCCESS;
    DWORD dwSize= sizeof(DWORD);
    DWORD dwType= 0;

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) &dwResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_DWORD )
    {
        dwResult= dwDefault;
    }
    return( dwResult );
}

// RegGetString - get string from registry

VOID RegGetString( HKEY hKey, PTCHAR pszKey, PTCHAR pszDefault, PTCHAR pszResult, INT iCharLen )
{
    LONG  lStatus= !ERROR_SUCCESS;
    DWORD dwSize;      // size of buffer
    DWORD dwType= REG_NONE;

    dwSize= iCharLen * sizeof(TCHAR);

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) pszResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_SZ )
    {
        CopyMemory( pszResult, pszDefault, iCharLen*sizeof(TCHAR) );
    }
}


// lfHeight is calculated using PointSize
// lfWidth set by font mapper


VOID SaveGlobals(VOID)
{
    HKEY hKey;    // key to our registry root
    LONG lStatus; // status from RegCreateKey
    WINDOWPLACEMENT wp;

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        return;   // just return quietly
    }

    RegWriteInt( hKey, TEXT("lfEscapement"),     FontStruct.lfEscapement);
    RegWriteInt( hKey, TEXT("lfOrientation"),    FontStruct.lfOrientation);
    RegWriteInt( hKey, TEXT("lfWeight"),         FontStruct.lfWeight);
    RegWriteInt( hKey, TEXT("lfItalic"),         FontStruct.lfItalic);
    RegWriteInt( hKey, TEXT("lfUnderline"),      FontStruct.lfUnderline);
    RegWriteInt( hKey, TEXT("lfStrikeOut"),      FontStruct.lfStrikeOut);
    RegWriteInt( hKey, TEXT("lfCharSet"),        FontStruct.lfCharSet);
    RegWriteInt( hKey, TEXT("lfOutPrecision"),   FontStruct.lfOutPrecision);
    RegWriteInt( hKey, TEXT("lfClipPrecision"),  FontStruct.lfClipPrecision);
    RegWriteInt( hKey, TEXT("lfQuality"),        FontStruct.lfQuality);
    RegWriteInt( hKey, TEXT("lfPitchAndFamily"), FontStruct.lfPitchAndFamily);
    RegWriteInt( hKey, TEXT("iPointSize"),       iPointSize);
    RegWriteInt( hKey, TEXT("fWrap"),            fWrap);
    RegWriteInt( hKey, TEXT("StatusBar"),        fStatus);
    RegWriteInt( hKey, TEXT("fSaveWindowPositions"),fSaveWindowPositions );

    RegWriteString( hKey, TEXT("lfFaceName"), FontStruct.lfFaceName);

    RegWriteString( hKey, TEXT("szHeader"),  chPageText[HEADER] );
    RegWriteString( hKey, TEXT("szTrailer"), chPageText[FOOTER] );
    RegWriteInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    RegWriteInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    RegWriteInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    RegWriteInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    wp.length= sizeof(wp);

    if( GetWindowPlacement( hwndNP, &wp ) )
    {
        RegWriteInt( hKey, TEXT("iWindowPosX"), wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosY"), wp.rcNormalPosition.top);
        RegWriteInt( hKey, TEXT("iWindowPosDX"), wp.rcNormalPosition.right - wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosDY"), wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);
    }

    RegCloseKey( hKey );
}


// GetGlobals
//
// Pick up font information etc that may be saved in the registry.
//
// We are called pretty early in setup and don't have things like hwndNP valid yet.
//

VOID GetGlobals( VOID )
{
    LOGFONT lfDef;          // default logical font
    HFONT   hFixedFont;     // standard font to use
    LONG    lStatus;        // status from RegCreateKey
    HKEY    hKey;           // key into registry

    //
    // quickly get a reasonable set of default parameters
    // for the default font if we need it.
    //
    
    hFixedFont= GetStockObject( SYSTEM_FIXED_FONT );

    if ( hFixedFont )
    {
        GetObject( hFixedFont, sizeof(LOGFONT), &lfDef );
    }
    else
    {
        ZeroMemory( &lfDef, sizeof(lfDef) );
    }

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        hKey= NULL;   // later calls to RegGet... will return defaults
    }
    FontStruct.lfWidth= 0;



    FontStruct.lfEscapement=     (LONG)RegGetInt( hKey, TEXT("lfEscapement"),     lfDef.lfEscapement);
    FontStruct.lfOrientation=    (LONG)RegGetInt( hKey, TEXT("lfOrientation"),    lfDef.lfOrientation);
    FontStruct.lfWeight=         (LONG)RegGetInt( hKey, TEXT("lfWeight"),         lfDef.lfWeight);
    FontStruct.lfItalic=         (BYTE)RegGetInt( hKey, TEXT("lfItalic"),         lfDef.lfItalic);
    FontStruct.lfUnderline=      (BYTE)RegGetInt( hKey, TEXT("lfUnderline"),      lfDef.lfUnderline);
    FontStruct.lfStrikeOut=      (BYTE)RegGetInt( hKey, TEXT("lfStrikeOut"),      lfDef.lfStrikeOut);

    //
    // We have to preserve lfCharSet because some fonts (symbol, marlett) don't handle 
    // 0 (ANSI_CHARSET) or 1 (DEFAULT_CHARSET), and the font mapper will map to a 
    // different facename.  Later we will see if the CreateFont has the same FaceName
    // and get a more appropriate lfCharSet if need be.
    //

    FontStruct.lfCharSet=        (BYTE)RegGetInt( hKey, TEXT("lfCharSet"),        lfDef.lfCharSet);
    
    FontStruct.lfOutPrecision=   (BYTE)RegGetInt( hKey, TEXT("lfOutPrecision"),   lfDef.lfOutPrecision);
    FontStruct.lfClipPrecision=  (BYTE)RegGetInt( hKey, TEXT("lfClipPrecision"),  lfDef.lfClipPrecision);
    FontStruct.lfQuality=        (BYTE)RegGetInt( hKey, TEXT("lfQuality"),        lfDef.lfQuality);
    FontStruct.lfPitchAndFamily= (BYTE)RegGetInt( hKey, TEXT("lfPitchAndFamily"), lfDef.lfPitchAndFamily);

    //
    // If there is no FaceName in the registry, use the default "Lucida Console"
    // This will show off most of the glyphs except in the FE locales.
    // For FE, we can't font link fonts with the glyphs because they would have to have
    // the exact width as lucida console, or the console/csrss will AV (July 9, 1999)
    //

    RegGetString( hKey, TEXT("lfFaceName"), TEXT("Lucida Console"), FontStruct.lfFaceName, LF_FACESIZE);

    iPointSize= RegGetInt( hKey, TEXT("iPointSize"), 100);
    fWrap=      RegGetInt( hKey, TEXT("fWrap"),      0);
    fStatus=    RegGetInt( hKey, TEXT("StatusBar"),  0);
    fSaveWindowPositions= RegGetInt( hKey, TEXT("fSaveWindowPositions"), 0 );

    // if page settings not in registry, we will use defaults

    RegGetString( hKey, TEXT("szHeader"),  chPageText[HEADER], chPageText[HEADER], PT_LEN );
    RegGetString( hKey, TEXT("szTrailer"), chPageText[FOOTER], chPageText[FOOTER], PT_LEN );

    g_PageSetupDlg.rtMargin.top=    (LONG)RegGetInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    g_PageSetupDlg.rtMargin.bottom= (LONG)RegGetInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    g_PageSetupDlg.rtMargin.left=   (LONG)RegGetInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    g_PageSetupDlg.rtMargin.right=  (LONG)RegGetInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    // if window positions in registry use them, otherwise us defaults

    g_WPtop=  (INT) RegGetInt( hKey, TEXT("iWindowPosY"),  (DWORD) CW_USEDEFAULT );
    g_WPleft= (INT) RegGetInt( hKey, TEXT("iWindowPosX"),  (DWORD) CW_USEDEFAULT );
    g_WPDX=   (INT) RegGetInt( hKey, TEXT("iWindowPosDX"), (DWORD) CW_USEDEFAULT );
    g_WPDY=   (INT) RegGetInt( hKey, TEXT("iWindowPosDY"), (DWORD) CW_USEDEFAULT );
    
    if( hKey )
    {
        RegCloseKey( hKey );
    }

}


void GetLocaleCodepages(LCID lcid, UINT* pcpANSI, UINT* pcpOEM)
{
    // FEATURE: don't check returns?  Not likely; fix later
    GetLocaleInfoW(lcid,
                   LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                   (LPTSTR) pcpANSI,
                   sizeof(*pcpANSI));

    GetLocaleInfoW(lcid,
                   LOCALE_IDEFAULTCODEPAGE | LOCALE_RETURN_NUMBER,
                   (LPTSTR) pcpOEM,
                   sizeof(*pcpOEM));

    // LOCALE_IDEFAULTMACCODEPAGE ?
    // LOCALE_IDEFAULTEBCDICCODEPAGE ?
}


void GetKeyboardCodepages(LANGID langid)
{
    GetLocaleCodepages(langid, &g_cpKeyboardANSI, &g_cpKeyboardOEM);
}


void GetSystemCodepages(void)
{
    g_cpANSI = GetACP();
    g_cpOEM = GetOEMCP();
}


void GetUserLocaleCodepages(void)
{
    GetLocaleCodepages(GetUserDefaultUILanguage(), &g_cpUserLocaleANSI, &g_cpUserLocaleOEM);

    GetLocaleCodepages(GetUserDefaultLCID(), &g_cpUserLocaleANSI, &g_cpUserLocaleOEM);
}


/*
 * lstrncmpi( str1, str2, len )
 * compares two strings, str1 and str2, up
 * to length 'len' ignoring case.  If they
 * are equal, we will return 0.  Otherwise not 0.
 */

static
INT lstrncmpi( PTCHAR sz1, PTCHAR sz2 )
{
    TCHAR ch1, ch2;
    while( *sz1 )
    {
        ch1= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz1++ );
        ch2= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz2++ );
        if( ch1 != ch2 )
            return 1;
    }
    return 0;                // they are equal
}

static int NPRegister (HANDLE hInstance);

/* GetFileName
 *
 * Parse off filename from command line and put
 * into lpFileName
 */

LPTSTR GetFileName( LPTSTR lpFileName, LPTSTR lpCmdLine )
{
   LPTSTR lpTemp = lpFileName;
   HANDLE hFindFile;
   WIN32_FIND_DATA info;

   /*
   ** Allow for filenames surrounded by double and single quotes
   ** like in longfilenames.
   */
   if( *lpCmdLine == TEXT('\"') || *lpCmdLine == TEXT('\'') )
   {
      TCHAR chMatch = *lpCmdLine;
      DWORD dwSize=0;

      // Copy over filename
      while( *(++lpCmdLine) && (*lpCmdLine != chMatch) && (dwSize<MAX_PATH) )
      {
         *lpTemp++ = *lpCmdLine;
         dwSize++;
      }

      // NULL terminate the filename (no embedded quotes allowed in filenames)
      *lpTemp = TEXT('\0');
   }
   else
   {
      lstrcpyn(lpFileName, lpCmdLine,MAX_PATH);
   }

   /*
   ** Check to see if the unaltered filename exists.  If it does then don't
   ** append a default extension.
   */
   hFindFile= FindFirstFile( lpFileName, &info );

   if( hFindFile != INVALID_HANDLE_VALUE )
   {
      FindClose( hFindFile );
   }
   else
   {
      /*
      ** Add default extension and try again
      */
      AddExt( lpFileName );

      hFindFile= FindFirstFile( lpFileName, &info );

      if( hFindFile != INVALID_HANDLE_VALUE )
      {
         FindClose( hFindFile );
      }
   }

   // return the pointer to the end of the filename.
   return lpCmdLine;
}

/* SizeStrings - Get the total size of the resource strings   */
/* returns size in 'chars' or zero if failure                 */
/* we do this in case the international people really change  */
/* the size of resources.                                     */

/* Read all the strings into a buffer to size them.  Since we  */
/* don't know the maximum size of string resource, we may have */
/* to change the size of the read buffer.  This is done with   */
/* a simple doubling algorithm.                                */

INT SizeStrings(HANDLE hInstance)
{
    INT    iElementSize=350;  // current max size of string
    INT    total;             // total size of resources
    PTCHAR Buf;               // buffer to try putting resources into
    INT    ids;               // identifier number for resource
    INT    len;               // length of one resource

    while( TRUE )             // keep looping til all strings can be read
    {
        Buf= LocalAlloc( LPTR, ByteCountOf(iElementSize) );
        if( !Buf )
        {
            return 0;    // failure
        }
        for( ids=0, total=0; rgsz[ids] != NULL; ids++ )
        {
            len= LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), Buf, iElementSize );

            if( len >= iElementSize-1 )
            {
                #if DBG
                    ODS(TEXT("notepad: resource string too long!\n"));
                #endif
                break;
            }
            total += len+1;  // account for null terminator
        }
        LocalFree( Buf );

        if( rgsz[ids] == NULL ) break;

        iElementSize= iElementSize*2;
    }
    return( total );
}


/* InitStrings - Get all text strings from resource file */
BOOL InitStrings (HANDLE hInstance)
{
    TCHAR*   pch;
    INT      cchRemaining;
    INT      ids, cch;

    // allocate memory and lock it down forever.  we have pointers into it.
    // the localrealloc() function will not work well for freeing
    // unused memory because it may (and did) move memory.

    cchRemaining= SizeStrings( hInstance );
    if( !cchRemaining )
        return( FALSE );       // fail because we are out of memory

    pch= LocalAlloc( LPTR, ByteCountOf(cchRemaining) );
    if( !pch )
        return( FALSE );

    cchRemaining= (INT)LocalSize( pch ) / sizeof(TCHAR);
    if( cchRemaining == 0 )    // can't alloc memory - failure
        return( FALSE );

    for( ids = 0; rgsz[ids] != NULL; ids++ )
    {
       cch= 1 + LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), pch, cchRemaining );
       *rgsz[ids]= pch;
       pch += cch;

       if( cch > cchRemaining )   // should never happen
       {
           MessageBox( NULL, TEXT("Out of RC string space!!"),
                      TEXT("DEV Error!"), MB_OK);
           return( FALSE );
       }

       cchRemaining -= cch;
    }

    /* Get header and footer strings */

    lstrcpyn( chPageText[HEADER], szHeader, PT_LEN ); 
    lstrcpyn( chPageText[FOOTER], szFooter, PT_LEN ); 

    chMerge= *szMerge;
    return (TRUE);
}

/*
 * SkipBlanks( pszText )
 * skips blanks or tabs to either next character or EOL
 * returns pointer to same.
 */
PTCHAR SkipBlanks( PTCHAR pszText )
{
    while( *pszText == TEXT(' ') || *pszText == TEXT('\t') )
        pszText++;

    return pszText;
}


// if /.SETUP option exists in the command line process it.
BOOL ProcessSetupOption (LPTSTR lpszCmdLine)
{
    INT iSta= 0;
    /* Search for /.SETUP in the command line */
    if( !lstrncmpi( TEXT("/.SETUP"), lpszCmdLine ) )
    {
        fRunBySetup = TRUE;
        /* Save system menu handle for INITMENUPOPUP message */
        hSysMenuSetup =GetSystemMenu(hwndNP, FALSE);
        /* Allow exit on ^C, ^D and ^Z                      */
        /* Note that LoadAccelerators must be called before */
        /* TranslateAccelerator is called, true here        */
        hAccel = LoadAccelerators(hInstanceNP, TEXT("SlipUpAcc"));
        lpszCmdLine += 7;
    }
    else
        return FALSE;

    /* Don't offer a minimize button */
    SetWindowLong( hwndNP, GWL_STYLE,
                   WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                   WS_THICKFRAME |                  WS_MAXIMIZEBOX |
                   WS_VSCROLL    | WS_HSCROLL);

    /* skip blanks again to get to filename */
    lpszCmdLine= SkipBlanks( lpszCmdLine );

    if (*lpszCmdLine)
    {
        TCHAR szFile[MAX_PATH];

        /* Get the filename. */
        GetFileName(szFile, lpszCmdLine);

        fp= CreateFile( szFile,                 // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE, // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  //file attributes
                        NULL);                  // hnd of file attrs

        if( fp == INVALID_HANDLE_VALUE )
        {
           DWORD dwErr;

           // Check GetLastError to see why we failed
           dwErr = GetLastError ();
           switch (dwErr)
           {
              case ERROR_ACCESS_DENIED:
                 iSta= AlertBox( hwndNP, szNN, szACCESSDENY, szFile,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONWARNING);
                 break;

              case ERROR_FILE_NOT_FOUND:
                 iSta= AlertBox(hwndNP, szNN, szFNF, szFile,
                      MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONWARNING);
                 if( iSta == IDYES )
                 {
                    fp= CreateFile( szFile,                // filename
                                    GENERIC_READ|GENERIC_WRITE,  // access
                                    FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                    NULL,                  // security descrp
                                    OPEN_ALWAYS,           // how to create
                                    FILE_ATTRIBUTE_NORMAL, // file attributes
                                    NULL);                 // hnd of file attrs
                 }
                 break;

              case ERROR_INVALID_NAME:
                 iSta= AlertBox( hwndNP, szNN, szNVF, szFile,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONWARNING);
                 break;

              default:
                 iSta= AlertBox(hwndNP, szNN, szDiskError, szFile,
                          MB_APPLMODAL | MB_OKCANCEL | MB_ICONWARNING);
                 break;
           }
        }

        if (fp == INVALID_HANDLE_VALUE)
           return (FALSE);

        LoadFile(szFile, FALSE);          // load setup file
    }

    if( iSta == IDCANCEL )
       return( IDCANCEL );
    else
       return( IDYES );
}

/*
 * ProcessShellOptions(lpszCmdLine)
 *
 * If the command line has any options specified by the shell
 * process them.
 * Currently /P <filename> - prints the given file
 *           /PT "filename" "printer name" "Driver dll" "port"
 */
BOOL ProcessShellOptions (LPTSTR lpszCmdLine, int cmdShow)
{
    BOOL   bDefPrinter = TRUE;
    LPTSTR lpszAfterFileName;
    INT    i = 0;
    TCHAR szFile[MAX_PATH];

    // Is it PrintTo ?
    if( lstrncmpi( TEXT("/PT"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+3 );
        bDefPrinter = FALSE;
    }
    // Or is it Print ?
    else if ( lstrncmpi( TEXT("/P"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+2 );
    }
    else
        return FALSE;

    if (!*lpszCmdLine)
       return FALSE;

/* Added as per Bug #10923 declaring that the window should show up
 * and then the printing should begin.   29 July 1991  Clark Cyr
 */
    ShowWindow(hwndNP, cmdShow);

    /* Get the filename; have the pointer to the end of the filename */
    lpszAfterFileName = GetFileName(szFile, lpszCmdLine) + 1;

    if (!bDefPrinter)
    {
        /* extract the printer name from the command line. */
        if (!*lpszAfterFileName)
            return FALSE;

        lpszAfterFileName = SkipBlanks( lpszAfterFileName );

        /* (since we are passing multiple arguments here, the filename, */
        /* the printername have to be in quotes. */
        if( *lpszAfterFileName != TEXT('\"') )
            return FALSE;

        // Copy over printername
        while( *(++lpszAfterFileName) && *lpszAfterFileName != TEXT('\"') )
        {
            szPrinterName[i++] = *lpszAfterFileName;
        }

        // NULL terminate the printername (no embedded quotes allowed in printernames)
        szPrinterName[i] = TEXT('\0');
    }


    fp= CreateFile( szFile,                 // filename
                    GENERIC_READ,           // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                    NULL,                   // security descriptor
                    OPEN_EXISTING,          // how to create
                    FILE_ATTRIBUTE_NORMAL,  // file attributes
                    NULL);                  // hnd of file attrs to copy

    if( fp == INVALID_HANDLE_VALUE )
    {
       TCHAR* pszMsg;

       // select reasonable error message based on GetLastError

       switch( GetLastError() )
       {
          case ERROR_ACCESS_DENIED:
          case ERROR_NETWORK_ACCESS_DENIED:
              pszMsg= szACCESSDENY;
              break;

          case ERROR_FILE_NOT_FOUND:
              pszMsg= szFNF;
              break;

          case ERROR_INVALID_NAME:
              pszMsg= szNVF;
              break;

          default:
              pszMsg= szDiskError;
              break;
       }

       AlertBox(hwndNP, szNN, pszMsg, szFile,
                 MB_APPLMODAL | MB_OK | MB_ICONWARNING);
       return (TRUE);
    }

    // Load the file into the edit control

    LoadFile(szFile, g_fSelectEncoding);    // get print file

    // Print the file

    if (bDefPrinter)
    {
        PrintIt( DoNotUseDialog );
    }
    else
    {
        PrintIt( NoDialogNonDefault );
    }

    return (TRUE);
}

/* CreateFilter
 *
 * Creates filters for GetOpenFileName.
 *
 */

VOID CreateFilter(BOOL fOpen, PTCHAR szFilterSpec)
{
    PTCHAR pszFilterSpec;

    /* construct default filter string in the required format for
     * the new FileOpen and FileSaveAs dialogs
     * if you add to this, make sure CCHFILTERMAX is large enough.
     */

    pszFilterSpec = szFilterSpec;

    // .txt first for compatibility
    lstrcpy(pszFilterSpec, szTextFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.txt"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, szHtmlFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.htm;*.html"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, szXmlFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.xml"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    if (fOpen)
    {
        lstrcpy(pszFilterSpec, szEncodedText);
        pszFilterSpec += lstrlen(pszFilterSpec) + 1;

        lstrcpy(pszFilterSpec, TEXT("*.txt"));
        pszFilterSpec += lstrlen(pszFilterSpec) + 1;
    }

    // and last, all files
    lstrcpy(pszFilterSpec, szAllFiles);
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.*"));
    pszFilterSpec += lstrlen(pszFilterSpec) + 1;

    *pszFilterSpec = TEXT('\0');

}

// EnumProc
//
// Callback function for EnumFonts
//
// Purpose: sets lfCharSet in passed logfont to a valid lfCharSet
//          and terminates enumeration.
//

int CALLBACK EnumProc( 
    LOGFONT*     pLf,
    TEXTMETRIC*  pTm,
    DWORD        dwType,
    LPARAM       lpData )
{

    ((LOGFONT*) lpData)-> lfCharSet= pLf->lfCharSet;

    return( 0 );  // stop enumeration

    UNREFERENCED_PARAMETER( pTm );
    UNREFERENCED_PARAMETER( dwType );
}


/* One time initialization */
INT NPInit (HANDLE hInstance, HANDLE hPrevInstance,
            LPTSTR lpCmdLine, INT cmdShow)
{
    HDC    hDisplayDC;     /* screen DC                */
    RECT   rcT1;           /* for sizing edit window   */
    RECT   rcStatus;       /* rect for the status window */
    INT    iSta;
    WINDOWPLACEMENT wp;    /* structure to place window at the correct position */
    INT    iParts[2];
    LANGID langid;

    /* determine the message number to be used for communication with
     * Find dialog
     */
    wFRMsg= RegisterWindowMessage( (LPTSTR)FINDMSGSTRING );
    if( !wFRMsg )
    {
         return FALSE;
    }

    wHlpMsg=  RegisterWindowMessage( (LPTSTR)HELPMSGSTRING );
    if( !wHlpMsg )
    {
         return FALSE;
    }

    /* open a global DC to the display */

    hDisplayDC= GetDC(NULL);
    if( !hDisplayDC )
        return FALSE;

    /* Go load strings */
    if (!InitStrings (hInstance))
        return FALSE;

    InitLocale();     // localize strings etc.

    /* Load the arrow and hourglass cursors. */
    hStdCursor= LoadCursor( NULL,
           (LPTSTR) (INT_PTR) (GetSystemMetrics(SM_PENWINDOWS) ? IDC_ARROW : IDC_IBEAM ));
    hWaitCursor= LoadCursor( NULL, IDC_WAIT );

    /* Load accelerators. */
    hAccel= LoadAccelerators(hInstance, TEXT("MainAcc"));
    if( !hWaitCursor || !hAccel )
        return FALSE;

    if( !hPrevInstance )
    {
       if( !NPRegister( hInstance ) )
          return (FALSE);
    }

    hInstanceNP= hInstance;

    /* init. fields of PRINTDLG struct.. */
    /* Inserted here since command line print statements are valid. */
    g_PageSetupDlg.lStructSize   = sizeof(PAGESETUPDLG);
    g_PageSetupDlg.hDevMode      = NULL;
    g_PageSetupDlg.hDevNames     = NULL;
    g_PageSetupDlg.hInstance     = hInstance;
    SetPageSetupDefaults();

    //
    // Pick up information saved in registry
    //

    GetGlobals();

    // Determine the codepages associated with the user's various system settings

    GetSystemCodepages();

    hwndNP= CreateWindow(  szNotepad, 
                           TEXT(""),
                           WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                           WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | 0,
                           g_WPleft,     // x
                           g_WPtop,      // y
                           g_WPDX,       // width
                           g_WPDY,       // height
                           (HWND)NULL,   // parent or owner
                           (HMENU)NULL,  // menu or child window
                           hInstance,    // application instance
                           NULL);        // window creation data

    g_PageSetupDlg.hwndOwner     = hwndNP;

    if( !hwndNP )
        return FALSE;
   
    // On multimon machines, the previous position stored of notepad may
    // not be in the display area. call SetWindowPlacement to fix this.

    // If the information specified in WINDOWPLACEMENT would result in a window 
    // that is completely off the screen, the system will automatically adjust 
    // the coordinates so that the window is visible, taking into account 
    // changes in screen resolution and multiple monitor configuration. 

    // g_WPDX and g_WPDY are CW_USEDEFAULT when notepad is started for the
    // first time on the user machine.
    if (g_WPDX != CW_USEDEFAULT && g_WPDY != CW_USEDEFAULT)
    {
        memset(&wp, 0, sizeof(wp));
        wp.length = sizeof(wp);        
        wp.rcNormalPosition.left = g_WPleft;
        wp.rcNormalPosition.right = g_WPleft + g_WPDX;
        wp.rcNormalPosition.top = g_WPtop;
        wp.rcNormalPosition.bottom = g_WPtop + g_WPDY;

        // don't check the return value; if this call fails for any reason,
        // just go on with the position of the notepad in the above CreateWindow() call.
        SetWindowPlacement(hwndNP, &wp);
    }

    /* File Drag Drop support added 03/26/91 - prototype only. w-dougw   */
    /* All processing of drag/drop files is done the under WM_DROPFILES  */
    /* message.                                                          */
    DragAcceptFiles( hwndNP,TRUE ); /* Process dragged and dropped files. */

    GetClientRect( hwndNP, (LPRECT) &rcT1 );

    hwndEdit= CreateWindowEx(
                     WS_EX_CLIENTEDGE,
                     TEXT("Edit"), 
                     TEXT(""),
                     (fWrap) ? ES_STD : (ES_STD | WS_HSCROLL),
                     0, 0, rcT1.right, rcT1.bottom - 100,
                     hwndNP, 
                     (HMENU)ID_EDIT, 
                     hInstance, 
                     (LPVOID)NULL );
    if( !hwndEdit )
    {
        return FALSE;
    }


    // create a status window.
    hwndStatus= CreateStatusWindow( (fStatus?WS_VISIBLE:0)|WS_BORDER|WS_CHILD|WS_CLIPSIBLINGS, 
                                     TEXT(""), 
                                     hwndNP, 
                                     ID_STATUS_WINDOW);
    if ( !hwndStatus )
        return FALSE;

    GetClientRect( hwndStatus, (LPRECT) &rcStatus );

    // determine height of statusbar window and save...
    dyStatus = rcStatus.bottom - rcStatus.top;

    iParts[0] = 3 * (rcStatus.right-rcStatus.left)/4;
    iParts[1] = -1;

    // Divide the status window into two parts
    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts); 
 

    // handle word wrap now if set in registry

    SendMessage( hwndEdit, EM_FMTLINES, fWrap, 0L );  // tell MLE

    FontStruct.lfHeight= -MulDiv(iPointSize,
                                 GetDeviceCaps(hDisplayDC,LOGPIXELSY),
                                 720);
    hFont= CreateFontIndirect( &FontStruct );

    //
    // Make sure the font mapper gives us the same face name.
    //
    // If the locale changes, a font that use to work just fine gets mapped to
    // a different facename because of support for the charset does not exist
    // in the new locale.
    //
    // In this case, we will find one lfCharSet that does exist for this FaceName
    // and use that for the CreateFontIndirect.
    //

    {
        HFONT hPrev;
        TCHAR szTextFace[LF_FACESIZE];

        // Get the facename that was really used.

        hPrev= SelectObject( hDisplayDC, hFont );
        GetTextFace( hDisplayDC, sizeof(szTextFace)/sizeof(TCHAR), (LPTSTR) &szTextFace );
        SelectObject( hDisplayDC, hPrev );

        // if not the same, get a lfCharSet that does exist in this font

        if( lstrcmpi( szTextFace, FontStruct.lfFaceName ) != 0 )
        {
            EnumFonts( hDisplayDC, FontStruct.lfFaceName, (FONTENUMPROC) EnumProc, (LPARAM) &FontStruct );
            DeleteObject( hFont );   

            hFont= CreateFontIndirect( &FontStruct );
        }
    }

    SendMessage (hwndEdit, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(FALSE, 0));
    ReleaseDC( NULL, hDisplayDC );

    /* we will not verify that a unicode font is available until
    ** we actually need it.  Perhaps we'll get lucky, and only deal
    ** with ascii files.
    */

    szSearch[0] = (TCHAR) 0;
    /*
     * Win32s does not allow local memory handles to be passed to Win3.1.
     * So, hEdit is used for transferring text to and from the edit control.
     * Before reading text into it, it must be reallocated to a proper size.
     */
    hEdit = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, ByteCountOf(1));

    /* limit text for safety's sake. */
    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    /* Get visible window on desktop; helps taskman  find it */

    SetFileName(NULL);
    ShowWindow(hwndNP, cmdShow);
    SetCursor(hStdCursor);

    /* Scan for initial /A or /W to override automatic file typing for
     * 'notepad /p file' or 'notepad file'
     */
    lpCmdLine= SkipBlanks( lpCmdLine );

    g_cpDefault = CP_AUTO;

    if (!lstrncmpi(TEXT("/A"), lpCmdLine))
    {
        g_cpDefault = g_cpANSI;

        lpCmdLine = SkipBlanks(lpCmdLine+2);
    }

    //
    // user provided codepage 
    // In standard C format (1234 (decimal), x123 (hex), 010 (octal)
    // if 0, then use ANSI codepage
    // if 1, then use OEM codepage

    else if (!lstrncmpi(TEXT("/CP:"), lpCmdLine))
    {
        BOOL fValid;

        // scan off the code page.  Base==0 means the syntax determines the base
        // "10" == 10,  "x10" == 16, "010" == 8
        g_cpDefault = wcstoul(lpCmdLine+4, &lpCmdLine, 0);

        if ((*lpCmdLine != TEXT('\0')) && (*lpCmdLine != TEXT(' ')) && (*lpCmdLine != TEXT('\t')))
        {
            fValid = FALSE;
        }

        else
        {
            if (g_cpDefault == CP_ACP)
            {
                g_cpDefault = GetACP();
            }

            else if (g_cpDefault == CP_OEMCP)
            {
                g_cpDefault = GetOEMCP();
            }

            fValid = FValidateCodepage(hwndNP, g_cpDefault);
        }

        if (!fValid)
        {
            AlertBox(hwndNP, szNN, szInvalidCP, NULL, MB_APPLMODAL | MB_OK | MB_ICONERROR);

            return FALSE;
        }

        lpCmdLine = SkipBlanks(lpCmdLine);
    }

    else if (!lstrncmpi(TEXT("/E:"), lpCmdLine))
    {
        const TCHAR *rgchEncoding = lpCmdLine = lpCmdLine+3;

        while ((*lpCmdLine != TEXT('\0')) && (*lpCmdLine != TEXT(' ')) && (*lpCmdLine != TEXT('\t')))
        {
            lpCmdLine++;
        }

        if (!FLookupCodepageNameW(rgchEncoding, (UINT) (lpCmdLine - rgchEncoding), &g_cpDefault))
        {
            AlertBox(hwndNP, szNN, szInvalidIANA, NULL, MB_APPLMODAL | MB_OK | MB_ICONERROR);

            return FALSE;
        }

        if (!FValidateCodepage(hwndNP, g_cpDefault))
        {
            AlertBox(hwndNP, szNN, szInvalidCP, NULL, MB_APPLMODAL | MB_OK | MB_ICONERROR);

            return FALSE;
        }

        lpCmdLine = SkipBlanks(lpCmdLine);
    }

    else if (!lstrncmpi(TEXT("/W"), lpCmdLine))
    {
        g_cpDefault = CP_UTF16;

        lpCmdLine = SkipBlanks(lpCmdLine+2);
    }

    if (!lstrncmpi(TEXT("/SELECTENCODING"), lpCmdLine))
    {
        g_fSelectEncoding = TRUE;

        lpCmdLine = SkipBlanks(lpCmdLine+15);
    }

    // Set encoding of new document or if LoadFile fails

    g_cpOpened = g_cpDefault;

    if (g_cpOpened == CP_AUTO)
    {
        g_cpOpened = g_cpANSI;
    }

    g_wbOpened = wbDefault;

    /* check for /.SETUP option first.
       if /.SETUP absent, check for SHELL options /P
       Whenever a SHELL option is processed, post a WM_CLOSE msg.
       */
    iSta= ProcessSetupOption( lpCmdLine );
    if( iSta )
    {
        if( iSta == IDCANCEL )
        {
            return( FALSE );
        }
    }
    else if( ProcessShellOptions( lpCmdLine, cmdShow ) )
    {
        PostMessage( hwndNP, WM_CLOSE, 0, 0L );
        return TRUE;
    }
    else if( *lpCmdLine )
    {
        TCHAR szFile[MAX_PATH];

        /* Get the filename. */
        GetFileName(szFile, lpCmdLine);

        fp = CreateFile(szFile,                 // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // hnd of file attrs to copy

        if( fp == INVALID_HANDLE_VALUE )
        {
           // If the file can't be opened, maybe the user wants a new
           // one created.

           if( GetLastError() == ERROR_FILE_NOT_FOUND )
           {
              INT AlertStatus;

              AlertStatus= AlertBox( hwndNP, szNN, szFNF, szFile,
                     MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONWARNING);
              if( AlertStatus == IDCANCEL )
              {
                  return( FALSE );
              }

              if( AlertStatus == IDYES )
              {
                 fp = CreateFile(szFile,                // filename
                                 GENERIC_READ|GENERIC_WRITE,  // access
                                 FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                 NULL,                  // security descrp
                                 OPEN_ALWAYS,           // how to create
                                 FILE_ATTRIBUTE_NORMAL, // file attributes
                                 NULL);                 // hnd of file attrs
              }

           }
           else
           {
               AlertUser_FileFail(szFile);
           }
        }

        if (fp != INVALID_HANDLE_VALUE)
        {
           LoadFile(szFile, g_fSelectEncoding);   // get file specified on command line
        }
    }

    CreateFilter(TRUE, szOpenFilterSpec);
    CreateFilter(FALSE, szSaveFilterSpec);

    /* init. some fields of the OPENFILENAME struct used by fileopen and
     * filesaveas, but NEVER changed.
     */
    memset( &OFN, 0, sizeof(OFN) );
    OFN.lStructSize       = sizeof(OPENFILENAME);
    OFN.hwndOwner         = hwndNP;
    OFN.nMaxFile          = MAX_PATH;
    OFN.hInstance         = hInstance;

    /* init.fields of the FINDREPLACE struct used by FindText() */
    memset( &FR, 0, sizeof(FR) );
    FR.lStructSize        = sizeof(FINDREPLACE);       /* Don't hard code it */
    FR.hwndOwner          = hwndNP;


    /* Force a scroll to current selection (which could be at eof if
       we loaded a log file.) */
    {
       DWORD  dwStart, dwEnd;

       SendMessage( hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd );
       SendMessage( hwndEdit, EM_SETSEL, dwStart, dwEnd );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }

    langid = LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0));

    GetKeyboardCodepages(langid);

    if (PRIMARYLANGID(langid) == LANG_JAPANESE) {
        /*
         * If current HKL is Japanese, handle the result string at once.
         */
        SendMessage(hwndEdit, EM_SETIMESTATUS,
                                EMSIS_COMPOSITIONSTRING, EIMES_GETCOMPSTRATONCE);
    }

    return TRUE;
}

/* ** Notepad class registration proc */
BOOL NPRegister (HANDLE hInstance)
{
    WNDCLASSEX   NPClass;
    PWNDCLASSEX  pNPClass = &NPClass;

/* Bug 12191: If Pen Windows is running, make the background cursor an
 * arrow instead of the edit control ibeam.  This way the user will know
 * where they can use the pen for writing vs. what will be considered a
 * mouse action.   18 October 1991       Clark Cyr
 */
    pNPClass->cbSize        = sizeof(NPClass);
    pNPClass->hCursor       = LoadCursor(NULL, GetSystemMetrics(SM_PENWINDOWS)
                                               ? IDC_ARROW : IDC_IBEAM);
    pNPClass->hIcon         = LoadIcon(hInstance,
                                      (LPTSTR) MAKEINTRESOURCE(ID_ICON));

    pNPClass->hIconSm       = LoadImage(hInstance,
                                        MAKEINTRESOURCE(ID_ICON),
                                        IMAGE_ICON, 16, 16,
                                        LR_DEFAULTCOLOR);
    pNPClass->lpszMenuName  = (LPTSTR) MAKEINTRESOURCE(ID_MENUBAR);
    pNPClass->hInstance     = hInstance;
    pNPClass->lpszClassName = szNotepad;
    pNPClass->lpfnWndProc   = NPWndProc;
    pNPClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    pNPClass->style         = 0; // was CS_BYTEALIGNCLIENT (obsolete)
    pNPClass->cbClsExtra    = 0;
    pNPClass->cbWndExtra    = 0;

    if (!RegisterClassEx((LPWNDCLASSEX)pNPClass))
        return (FALSE);

    return (TRUE);
}


/* Get Locale info from the Registry, and initialize global vars  */

void InitLocale(void)
{
    GetUserLocaleCodepages();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\nphtml.c ===
/*
 * HTML support functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"


BOOL FDetectHtmlEncodingA(LPCSTR rgch, UINT cch, UINT* pcp)
{
    return(FALSE);
    UNREFERENCED_PARAMETER( rgch );
    UNREFERENCED_PARAMETER( cch );
    UNREFERENCED_PARAMETER( pcp );
}


BOOL FDetectHtmlEncodingW(LPCWSTR rgch, UINT cch, UINT* pcp)
{
    return(FALSE);
    UNREFERENCED_PARAMETER( rgch );
    UNREFERENCED_PARAMETER( cch );
    UNREFERENCED_PARAMETER( pcp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npmlang.c ===
/*
 * MLANG wrapper functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"

#include "mlang.h"
#include "oleauto.h"


#define CP_USERDEF         50000
#define CP_ISCII_MIN       57002
#define CP_ISCII_MAC       57011

#define IsISCII(cp)  (((cp) >= CP_ISCII_MIN) && ((cp) <= CP_ISCII_MAC))


BOOL fInitializedCom;
IMultiLanguage3 *pml3;


BOOL FLoadMlang()
{
    HRESULT hr;

    if (!fInitializedCom)
    {
        hr = CoInitialize(NULL);

        if (FAILED(hr))
        {
            return(FALSE);
        }

        fInitializedCom = TRUE;
    }

    if (pml3 == NULL)
    {
        hr = CoCreateInstance(&CLSID_CMultiLanguage,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              &IID_IMultiLanguage3,
                              (void **) &pml3);

        if (FAILED(hr))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL FValidWin32CodePage(UINT cp)
{
    switch (cp)
    {
    case 50220 :
    case 50221 :
    case 50222 :
    case 50225 :
    case 50227 :
    // case 50229 :
    case 52936 :
        // We don't use WCToMB or MBToWC for these because there are
        // bugs in C_IS2022.DLL and MLANG has built support.

        return(FALSE);
    }

    return(IsValidCodePage(cp));
}


ConvertFromUnicodeMlang(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, LPSTR rgchMbcs, UINT cchMbcs, BOOL* pfDefCharUsed)
{
    DWORD dwMode;
    UINT cchSrc;
    UINT cchDst;
    DWORD dwFlags;
    HRESULT hr;

    if (!FLoadMlang())
    {
        return(0);
    }

    dwMode = 0;
    cchSrc = cchUtf16;
    cchDst = cchMbcs;
    dwFlags = fWriteEntities ? MLCONVCHARF_NCR_ENTITIZE : MLCONVCHARF_USEDEFCHAR;

    if (fNoBestFit)
    {
        dwFlags |= MLCONVCHARF_NOBESTFITCHARS;
    }

    hr = pml3->lpVtbl->ConvertStringFromUnicodeEx(pml3,
                                                  &dwMode,
                                                  cp,
                                                  (WCHAR *) rgchUtf16,
                                                  &cchSrc,
                                                  rgchMbcs,
                                                  &cchDst,
                                                  dwFlags,
                                                  NULL);

    if (FAILED(hr))
    {
        return(0);
    }

    if (pfDefCharUsed != NULL)
    {
        *pfDefCharUsed = (hr == S_FALSE);
    }

    return(cchDst);
}


UINT ConvertFromUnicode(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, LPSTR rgchMbcs, UINT cchMbcs, BOOL* pfDefCharUsed)
{
    UINT cch;

    if (cchUtf16 == 0)
    {
        return(0);
    }

    if (!fWriteEntities && FValidWin32CodePage(cp))
    {
        cch = WideCharToMultiByte(cp,
                                  fNoBestFit ? WC_NO_BEST_FIT_CHARS : 0,
                                  rgchUtf16,
                                  cchUtf16,
                                  rgchMbcs,
                                  cchMbcs,
                                  NULL,
                                  pfDefCharUsed);

        if (cch != 0)
        {
            return(cch);
        }

        // We retry with MLANG even when WCToMB supports the code page
        // because there are code pages when WCToMB may not support all
        // the features of the API.  I know this is the case for WCToMB
        // and the ISCII encodings.  We try again just for robustness.
    }

    cch = ConvertFromUnicodeMlang(cp, fNoBestFit, fWriteEntities, rgchUtf16, cchUtf16, rgchMbcs, cchMbcs, pfDefCharUsed);

#if DBG
    if (cch == 0)
    {
        DebugBreak();
    }
#endif

    return(cch);
}


UINT ConvertToUnicodeMlang(UINT cp, LPCSTR rgchMbcs, UINT cchMbcs, LPWSTR rgchUtf16, UINT cchUtf16)
{
    DWORD dwMode;
    UINT cchSrc;
    UINT cchDst;
    HRESULT hr;

    if (!FLoadMlang())
    {
        return(0);
    }

    dwMode = 0;
    cchSrc = cchMbcs;
    cchDst = cchUtf16;

    hr = pml3->lpVtbl->ConvertStringToUnicode(pml3,
                                              &dwMode,
                                              cp,
                                              (CHAR *) rgchMbcs,
                                              &cchSrc,
                                              rgchUtf16,
                                              &cchDst);

    if (FAILED(hr))
    {
        return(0);
    }

    return(cchDst);
}


UINT ConvertToUnicode(UINT cp, LPCSTR rgchMbcs, UINT cchMbcs, LPWSTR rgchUtf16, UINT cchUtf16)
{
    UINT cch;

    if (cchMbcs == 0)
    {
        return(0);
    }

    if (FValidWin32CodePage(cp))
    {
        cch = MultiByteToWideChar(cp, 0, rgchMbcs, cchMbcs, rgchUtf16, cchUtf16);

        if (cch != 0)
        {
            return(cch);
        }

        // We retry with MLANG even when MBToWC supports the code page
        // because there are code pages when MBToWC may not support all
        // the features of the API.  I know this is the case for WCToMB
        // and the ISCII encodings.  We try again just for robustness.
    }

    cch = ConvertToUnicodeMlang(cp, rgchMbcs, cchMbcs, rgchUtf16, cchUtf16);

#if DBG
    if (cch == 0)
    {
        DebugBreak();
    }
#endif

    return(cch);
}


BOOL FDetectEncodingA(LPCSTR rgch, UINT cch, UINT* pcp)
{
    INT cb;
    DetectEncodingInfo dei;
    INT cdei;
    HRESULT hr;

    if (!FLoadMlang())
    {
        return(0);
    }

    cb = (INT) cch;
    cdei = 1;

    hr = pml3->lpVtbl->DetectInputCodepage(pml3,
                                           0,
                                           0,
                                           (LPSTR) rgch,
                                           &cb,
                                           &dei,
                                           &cdei);

    if (hr != S_OK)
    {
        return(FALSE);
    }

    if (cdei == 0)
    {
        return(FALSE);
    }

    *pcp = dei.nCodePage;

    return(TRUE);
}


BOOL FLookupCodepageNameW(LPCWSTR rgchEncoding, UINT cch, UINT* pcp)
{
    BSTR bstrEncoding;
    MIMECSETINFO mci;
    HRESULT hr;

    if (cch == 0)
    {
        return(FALSE);
    }

    if (rgchEncoding[0] == L'_')
    {
        // Don't allow internal MLANG encodings

        return(FALSE);
    }

    if (!FLoadMlang())
    {
        return(FALSE);
    }

    bstrEncoding = SysAllocStringLen(rgchEncoding, cch);

    if (bstrEncoding == NULL)
    {
        return(FALSE);
    }

    hr = pml3->lpVtbl->GetCharsetInfo(pml3, bstrEncoding, &mci);

    SysFreeString(bstrEncoding);

    *pcp = mci.uiInternetEncoding;

    if (SUCCEEDED(hr))
    {
        return(TRUE);
    }

    return(FALSE);
}


BOOL FLookupCodepageNameA(LPCSTR rgchEncoding, UINT cch, UINT* pcp)
{
    WCHAR rgwchEncoding[MAX_MIMECSET_NAME];
    UINT ich;

    if (cch > MAX_MIMECSET_NAME)
    {
        return(FALSE);
    }

    for (ich = 0; ich < cch; ich++)
    {
        // Assume input is ASCII or Latin-1 and zero extend each character

        rgwchEncoding[ich] = (WCHAR) (BYTE) rgchEncoding[ich];
    }

    return(FLookupCodepageNameW(rgwchEncoding, cch, pcp));
}


BOOL FSupportWriteEntities(UINT cp)
{
    if (IsISCII(cp))
    {
        return(FALSE);
    }

    return(TRUE);
}


BOOL FValidateCodepage(HWND hwnd, UINT cp)
{
    HRESULT hr;

    if (IsValidCodePage(cp))
    {
        return(TRUE);
    }

    if ((cp == CP_USERDEF) || (cp == CP_AUTO) || (cp == CP_MACCP) || (cp == CP_THREAD_ACP))
    {
        return(FALSE);
    }

    if (!FLoadMlang())
    {
        return(FALSE);
    }

    hr = pml3->lpVtbl->ValidateCodePage(pml3, cp, hwnd);

    if (SUCCEEDED(hr) && (hr != S_FALSE))
    {
        return(TRUE);
    }

    return(FALSE);
}


void PopulateCodePages(HWND hWnd, BOOL fSelectEncoding, UINT cpSelect, UINT cpExtra)
{
    IEnumCodePage *pecp;
    UINT msg_ADDSTRING;
    UINT msg_SETITEMDATA;
    UINT msg_GETCOUNT;
    UINT msg_GETITEMDATA;
    UINT msg_SETCURSEL;
    HRESULT hr;
    LRESULT lr;

    if (!FLoadMlang())
    {
        return;
    }

    hr = pml3->lpVtbl->EnumCodePages(pml3,
                                     MIMECONTF_VALID_NLS | MIMECONTF_EXPORT,
                                     GetUserDefaultUILanguage(),
                                     &pecp);

    if (FAILED(hr))
    {
        return;
    }

    msg_ADDSTRING   = fSelectEncoding ? LB_ADDSTRING   : CB_ADDSTRING;
    msg_SETITEMDATA = fSelectEncoding ? LB_SETITEMDATA : CB_SETITEMDATA;
    msg_GETCOUNT    = fSelectEncoding ? LB_GETCOUNT    : CB_GETCOUNT;
    msg_GETITEMDATA = fSelectEncoding ? LB_GETITEMDATA : CB_GETITEMDATA;
    msg_SETCURSEL   = fSelectEncoding ? LB_SETCURSEL   : CB_SETCURSEL;

    for (;;)
    {
        MIMECPINFO mci;
        ULONG c;

        hr = pecp->lpVtbl->Next(pecp, 1, &mci, &c);

        if (FAILED(hr))
        {
            break;
        }

        if (c == 0)
        {
            break;
        }

        if (mci.uiCodePage == CP_USERDEF)
        {
            // Ignore "User Defined"

            continue;
        }

        if (!fSelectEncoding)
        {
            if (mci.uiCodePage == cpSelect)
            {
            }

            else if (mci.uiCodePage == cpExtra)
            {
            }

            else if (mci.uiCodePage == CP_UTF16)
            {
            }

            else if (mci.uiCodePage == 1252)
            {
            }

            else if (mci.uiCodePage == CP_UTF8)
            {
            }

            else if (mci.uiCodePage == g_cpDefault)
            {
            }

            else if (mci.uiCodePage == g_cpANSI)
            {
               // Don't filter ANSI codepage used by system
            }

            else if (mci.uiCodePage == g_cpOEM)
            {
               // Don't filter OEM codepage used by system
            }

            else if (mci.uiCodePage == g_cpUserLangANSI)
            {
               // Don't filter ANSI codepage associated with user's default UI language
            }

            else if (mci.uiCodePage == g_cpUserLangOEM)
            {
               // Don't filter OEM codepage associated with user's default UI language
            }

            else if (mci.uiCodePage == g_cpUserLocaleANSI)
            {
               // Don't filter ANSI codepage associated with user's default locale
            }

            else if (mci.uiCodePage == g_cpUserLocaleOEM)
            {
               // Don't filter OEM codepage associated with user's default locale
            }

            else if (mci.uiCodePage == g_cpKeyboardANSI)
            {
               // Don't filter ANSI codepage associated with the current active keyboard
            }

            else if (mci.uiCodePage == g_cpKeyboardOEM)
            {
               // Don't filter OEM codepage associated with the current active keyboard
            }

            else
            {
                continue;
            }
        }

        lr = SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_ADDSTRING, 0, (LPARAM) mci.wszDescription);

        if (lr < 0)
        {
            break;
        }

        SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_SETITEMDATA, (WPARAM) lr, (LPARAM) mci.uiCodePage);
    }

    pecp->lpVtbl->Release(pecp);

    lr = SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_GETCOUNT, 0, 0);

    while (--lr >= 0)
    {
        UINT cp = (UINT) SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_GETITEMDATA, (WPARAM) lr, 0);

        if (cp == cpSelect)
        {
            SendDlgItemMessage(hWnd, IDC_CODEPAGE, msg_SETCURSEL, (WPARAM) lr, 0);
            break;
        }
    }
}


void UnloadMlang()
{
    if (pml3 != NULL)
    {
        pml3->lpVtbl->Release(pml3);

        pml3 = NULL;
    }

    if (fInitializedCom)
    {
        CoUninitialize();

        fInitializedCom = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npprint.c ===
/*
 * npprint.c -- Code for printing from notepad.
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#define NOMINMAX
#include "precomp.h"

//#define DBGPRINT

/* indices into chBuff */
#define LEFT   0
#define CENTER 1
#define RIGHT  2

INT     tabSize;                    /* Size of a tab for print device in device units*/
HWND    hAbortDlgWnd;
INT     fAbort;                     /* true if abort in progress      */
INT     yPrintChar;                 /* height of a character          */


RECT rtMargin;

/* left,center and right string for header or trailer */
#define MAXTITLE MAX_PATH
TCHAR chBuff[RIGHT+1][MAXTITLE];

/* date and time stuff for headers */
#define MAXDATE MAX_PATH
#define MAXTIME MAX_PATH
TCHAR szFormattedDate[MAXDATE]=TEXT("Y");   // formatted date (may be internationalized)
TCHAR szFormattedTime[MAXTIME]=TEXT("Y");   // formatted time (may be internaltionalized)
SYSTEMTIME PrintTime;                       // time we started printing


INT xPrintRes;          // printer resolution in x direction
INT yPrintRes;          // printer resolution in y direction
INT yPixInch;           // pixels/inch
INT xPhysRes;           // physical resolution x of paper
INT yPhysRes;           // physical resolution y of paper

INT xPhysOff;           // physical offset x
INT yPhysOff;           // physical offset y

INT dyTop;              // width of top border (pixels)
INT dyBottom;           // width of bottom border
INT dxLeft;             // width of left border
INT dxRight;            // width of right border

INT iPageNum;           // global page number currently being printed

/* define a type for NUM and the base */
typedef long NUM;
#define BASE 100L

/* converting in/out of fixed point */
#define  NumToShort(x,s)   (LOWORD(((x) + (s)) / BASE))
#define  NumRemToShort(x)  (LOWORD((x) % BASE))

/* rounding options for NumToShort */
#define  NUMFLOOR      0
#define  NUMROUND      (BASE/2)
#define  NUMCEILING    (BASE-1)

#define  ROUND(x)  NumToShort(x,NUMROUND)
#define  FLOOR(x)  NumToShort(x,NUMFLOOR)

/* Unit conversion */
#define  InchesToCM(x)  (((x) * 254L + 50) / 100)
#define  CMToInches(x)  (((x) * 100L + 127) / 254)

void     DestroyAbortWnd(void) ;
VOID     TranslateString(TCHAR *);

BOOL CALLBACK AbortProc(HDC hPrintDC, INT reserved)
{
    MSG msg;

    while( !fAbort && PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE) )
    {
       if( !hAbortDlgWnd || !IsDialogMessage( hAbortDlgWnd, (LPMSG)&msg ) )
       {
          TranslateMessage( (LPMSG)&msg );
          DispatchMessage( (LPMSG)&msg );
       }
    }
    return( !fAbort );

    UNREFERENCED_PARAMETER(hPrintDC);
    UNREFERENCED_PARAMETER(reserved);
}


INT_PTR CALLBACK AbortDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static HMENU hSysMenu;

    switch( msg )
    {
       case WM_COMMAND:
          fAbort= TRUE;
          DestroyAbortWnd();
          return( TRUE );

       case WM_INITDIALOG:
          hSysMenu= GetSystemMenu( hwnd, FALSE );
          SetDlgItemText( hwnd, ID_FILENAME,
             FUntitled() ? szUntitled : PFileInPath(szFileOpened) );
          SetFocus( hwnd );
          return( TRUE );

       case WM_INITMENU:
          EnableMenuItem( hSysMenu, (WORD)SC_CLOSE, (DWORD)MF_GRAYED );
          return( TRUE );
    }
    return( FALSE );

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}


/*
 * print out the translated header/footer string in proper position.
 * uses globals xPrintWidth, ...
 *
 * returns 1 if line was printed, otherwise 0.
 */

INT PrintHeaderFooter (HDC hDC, INT nHF)
{
    SIZE    Size;    // to compute the width of each string
    INT     yPos;    // y position to print
    INT     xPos;    // x position to print

    if( *chPageText[nHF] == 0 )   // see if anything to do
        return 0;                // we didn't print

    TranslateString( chPageText[nHF] );

    // figure out the y position we are printing

    if( nHF == HEADER )
        yPos= dyTop;
    else
        yPos= yPrintRes - dyBottom - yPrintChar;

    // print out the various strings
    // N.B. could overprint which seems ok for now

    if( *chBuff[LEFT] )     // left string
    {
        TextOut( hDC, dxLeft, yPos, chBuff[LEFT], lstrlen(chBuff[LEFT]) );
    }

    if( *chBuff[CENTER] )   // center string
    {
        GetTextExtentPoint32( hDC, chBuff[CENTER], lstrlen(chBuff[CENTER]), &Size );
        xPos= (xPrintRes-dxRight+dxLeft)/2 - Size.cx/2;
        TextOut( hDC, xPos, yPos, chBuff[CENTER], lstrlen(chBuff[CENTER]) );
    }

    if( *chBuff[RIGHT] )    // right string
    {
        GetTextExtentPoint32( hDC, chBuff[RIGHT], lstrlen(chBuff[RIGHT]), &Size );
        xPos= xPrintRes - dxRight - Size.cx;
        TextOut( hDC, xPos, yPos, chBuff[RIGHT], lstrlen(chBuff[RIGHT]) );
    }
    return 1;              // we did print something
}
/*
 * GetResolutions
 *
 * Gets printer resolutions.
 * sets globals: xPrintRes, yPrintRes, yPixInch
 *
 */

VOID GetResolutions(HDC hPrintDC)
{
    xPrintRes = GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes = GetDeviceCaps( hPrintDC, VERTRES );
    yPixInch  = GetDeviceCaps( hPrintDC, LOGPIXELSY );

    xPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALWIDTH );
    yPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALHEIGHT );

    xPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETX );
    yPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETY );
}

/* GetMoreText
 *
 * Gets the next line of text from the MLE, returning a pointer
 * to the beginning and just past the end.
 *
 * linenum    - index into MLE                                   (IN)
 * pStartText - start of MLE                                     (IN)
 * ppsStr     - pointer to where to put pointer to start of text (OUT)
 * ppEOL      - pointer to where to put pointer to just past EOL (OUT)
 *
 */

VOID GetMoreText( INT linenum, PTCHAR pStartText, PTCHAR* ppsStr, PTCHAR* ppEOL )
{
    INT Offset;        // offset in 'chars' into edit buffer
    INT nChars;        // number of chars in line

    Offset= (INT)SendMessage( hwndEdit, EM_LINEINDEX, linenum, 0 );

    nChars= (INT)SendMessage( hwndEdit, EM_LINELENGTH, Offset, 0 );

    *ppsStr= pStartText + Offset;

    *ppEOL= (pStartText+Offset) + nChars;
}

#ifdef DBGPRINT
TCHAR dbuf[100];
VOID ShowMargins( HDC hPrintDC )
{
    INT xPrintRes, yPrintRes;
    RECT rct;
    HBRUSH hBrush;

    xPrintRes= GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes= GetDeviceCaps( hPrintDC, VERTRES );
    hBrush= GetStockObject( BLACK_BRUSH );

    if ( hBrush )
    {
        SetRect( &rct, 0,0,xPrintRes-1, yPrintRes-1 );
        FrameRect( hPrintDC, &rct, hBrush );
        SetRect( &rct, dxLeft, dyTop, xPrintRes-dxRight, yPrintRes-dyBottom );
        FrameRect( hPrintDC, &rct, hBrush );
    }
}

VOID PrintLogFont( LOGFONT lf )
{
    wsprintf(dbuf,TEXT("lfHeight          %d\n"), lf.lfHeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"), lf.lfWidth         ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"), lf. lfEscapement   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"), lf.lfOrientation   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"), lf.lfWeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"), lf.lfItalic        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderline       %d\n"), lf.lfUnderline     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"), lf.lfStrikeOut     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"), lf.lfCharSet       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"), lf.lfOutPrecision  ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecison    %d\n"), lf.lfClipPrecision ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"), lf.lfQuality       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"), lf.lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"), lf.lfFaceName      ); ODS(dbuf);
}
#endif

// GetPrinterDCviaDialog
//
// Use the common dialog PrintDlgEx() function to get a printer DC to print to.
//
// Returns: valid HDC or INVALID_HANDLE_VALUE if error.
//

HDC GetPrinterDCviaDialog( VOID )
{
    PRINTDLGEX pdTemp;
    HDC hDC;
    HRESULT hRes;

    //
    // Get the page setup information
    //

    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
    }

    //
    // Initialize the dialog structure
    //

    ZeroMemory( &pdTemp, sizeof(pdTemp) );

    pdTemp.lStructSize= sizeof(pdTemp);

    pdTemp.hwndOwner= hwndNP;
    pdTemp.nStartPage= START_PAGE_GENERAL;
    pdTemp.Flags= PD_NOPAGENUMS  | PD_RETURNDC | PD_NOCURRENTPAGE |
                  PD_NOSELECTION | 0;

    // if use set printer in PageSetup, use it here too.

    if( g_PageSetupDlg.hDevMode )
    {
        pdTemp.hDevMode= g_PageSetupDlg.hDevMode;
    }

    if( g_PageSetupDlg.hDevNames )
    {
        pdTemp.hDevNames= g_PageSetupDlg.hDevNames;
    }


    //
    // let user select printer
    //

    hRes= PrintDlgEx( &pdTemp );

    //
    // get DC if valid return
    //

    hDC= INVALID_HANDLE_VALUE;

    if( hRes == S_OK )
    {
        if( (pdTemp.dwResultAction == PD_RESULT_PRINT) || (pdTemp.dwResultAction == PD_RESULT_APPLY) )
        {
            if( pdTemp.dwResultAction == PD_RESULT_PRINT )
            {
                hDC= pdTemp.hDC;
            }
            
            //
            // Get the page setup information for the printer selected in case it was
            // the first printer added by the user through notepad.
            //
            if( !g_PageSetupDlg.hDevMode ) 
            {
                g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
                PageSetupDlg(&g_PageSetupDlg);
                g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
            }

            // change devmode if user pressed print or apply
            g_PageSetupDlg.hDevMode= pdTemp.hDevMode;
            g_PageSetupDlg.hDevNames= pdTemp.hDevNames;
        }       
    }

    // FEATURE: free hDevNames

    return( hDC );
}

INT NpPrint( PRINT_DIALOG_TYPE type)
{
    HDC hPrintDC;

    SetCursor( hWaitCursor );

    switch( type )
    {
        case UseDialog:
            hPrintDC= GetPrinterDCviaDialog();
            break;
        case NoDialogNonDefault:
            hPrintDC= GetNonDefPrinterDC();
            break;
        case DoNotUseDialog:
        default:
            hPrintDC= GetPrinterDC();
            break;
    }

    if( hPrintDC == INVALID_HANDLE_VALUE )
    {
        SetCursor( hStdCursor );
        return( 0 );   // message already given
    }

    return( NpPrintGivenDC( hPrintDC ) );

}

INT NpPrintGivenDC( HDC hPrintDC )
{
    HANDLE     hText= NULL;          // handle to MLE text
    HFONT      hPrintFont= NULL;     // font to print with
    HANDLE     hPrevFont= NULL;      // previous font in hPrintDC

    BOOL       fPageStarted= FALSE;  // true if StartPage called for this page
    BOOL       fDocStarted=  FALSE;  // true if StartDoc called
    PTCHAR     pStartText= NULL;     // start of edit text (locked hText)
    TEXTMETRIC Metrics;
    TCHAR      msgbuf[MAX_PATH];     // Document name for tracking print job
    INT        nLinesPerPage;        // not inc. header and footer
    // iErr will contain the first error discovered ie it is sticky
    // This will be the value returned by this function.
    // It does not need to translate SP_* errors except for SP_ERROR which should be
    // GetLastError() right after it is first detected.
    INT        iErr=0;               // error return
    DOCINFO    DocInfo;
    LOGFONT    lfPrintFont;          // local version of FontStruct
    LCID       lcid;                 // locale id

    fAbort = FALSE;
    hAbortDlgWnd= NULL;

    SetCursor( hWaitCursor );

    GetResolutions( hPrintDC );

    // Get the time and date for use in the header or trailer.
    // We use the GetDateFormat and GetTimeFormat to get the
    // internationalized versions.

    GetLocalTime( &PrintTime );       // use local, not gmt

    lcid= GetUserDefaultLCID();

    GetDateFormat( lcid, DATE_LONGDATE, &PrintTime, NULL, szFormattedDate, MAXDATE );

    GetTimeFormat( lcid, 0,             &PrintTime, NULL, szFormattedTime, MAXTIME );


   /*
    * This part is to select the current font to the printer device.
    * We have to change the height because FontStruct was created
    * assuming the display.  Using the remembered pointsize, calculate
    * the new height.
    */

    lfPrintFont= FontStruct;                          // make local copy
    lfPrintFont.lfHeight= -(iPointSize*yPixInch)/(72*10);
    lfPrintFont.lfWidth= 0;

    //
    // convert margins to pixels
    // ptPaperSize is the physical paper size, not the printable area.
    // do the mapping in physical units
    //

    SetMapMode( hPrintDC, MM_ANISOTROPIC );

    SetViewportExtEx( hPrintDC,
                      xPhysRes,
                      yPhysRes,
                      NULL );

    SetWindowExtEx( hPrintDC,
                    g_PageSetupDlg.ptPaperSize.x,
                    g_PageSetupDlg.ptPaperSize.y,
                    NULL );

    rtMargin = g_PageSetupDlg.rtMargin;

    LPtoDP( hPrintDC, (LPPOINT) &rtMargin, 2 );

    SetMapMode( hPrintDC,MM_TEXT );    // restore to mm_text mode

    hPrintFont= CreateFontIndirect(&lfPrintFont);

    if( !hPrintFont )
    {
        goto ErrorExit;
    }

    hPrevFont= SelectObject( hPrintDC, hPrintFont );
    if( !hPrevFont )
    {
        goto ErrorExit;
    }

    SetBkMode( hPrintDC, TRANSPARENT );
    if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
    {
        goto ErrorExit;
    }

    // The font may not a scalable (say on a bubblejet printer)
    // In this case, just pick some font
    // For example, FixedSys 9 pt would be non-scalable

    if( !(Metrics.tmPitchAndFamily & (TMPF_VECTOR | TMPF_TRUETYPE )) )
    {
        // remove just created font

        hPrintFont= SelectObject( hPrintDC, hPrevFont );  // get old font
        DeleteObject( hPrintFont );

        memset( lfPrintFont.lfFaceName, 0, LF_FACESIZE*sizeof(TCHAR) );

        hPrintFont= CreateFontIndirect( &lfPrintFont );
        if( !hPrintFont )
        {
            goto ErrorExit;
        }

        hPrevFont= SelectObject( hPrintDC, hPrintFont );
        if( !hPrevFont )
        {
            goto ErrorExit;
        }

        if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
        {
            goto ErrorExit;
        }
    }
    yPrintChar= Metrics.tmHeight+Metrics.tmExternalLeading;  /* the height */

    tabSize = Metrics.tmAveCharWidth * 8; /* 8 ave char width pixels for tabs */

    // compute margins in pixels

    dxLeft=   max(rtMargin.left - xPhysOff,0);
    dxRight=  max(rtMargin.right  - (xPhysRes - xPrintRes - xPhysOff), 0 );
    dyTop=    max(rtMargin.top  - yPhysOff,0);
    dyBottom= max(rtMargin.bottom - (yPhysRes - yPrintRes - yPhysOff), 0 );

#ifdef DBGPRINT
    {
        TCHAR dbuf[100];
        RECT rt= g_PageSetupDlg.rtMargin;
        POINT pt;

        wsprintf(dbuf,TEXT("Print pOffx %d  pOffy %d\n"),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETX),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETY));
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALWIDTH: %d\n"), xPhysRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("HORZRES: %d\n"),xPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALOFFSETX: %d\n"),xPhysOff);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("LOGPIXELSX: %d\n"),
                 GetDeviceCaps(hPrintDC,LOGPIXELSX));
        ODS(dbuf);

        GetViewportOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Viewport org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        GetWindowOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Window org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PrintRes x: %d  y: %d\n"),xPrintRes, yPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PaperSize  x: %d  y: %d\n"),
                 g_PageSetupDlg.ptPaperSize.x,
                 g_PageSetupDlg.ptPaperSize.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("unit margins:  l: %d  r: %d  t: %d  b: %d\n"),
                 rt.left, rt.right, rt.top, rt.bottom);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("pixel margins: l: %d  r: %d  t: %d  b: %d\n"),
                 rtMargin.left, rtMargin.right, rtMargin.top, rtMargin.bottom);
        ODS(dbuf);

        wsprintf(dbuf,TEXT("dxLeft %d  dxRight %d\n"),dxLeft,dxRight);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("dyTop %d  dyBot %d\n"),dyTop,dyBottom);
        ODS(dbuf);
    }
#endif


    /* Number of lines on a page with margins  */
    /* two lines are used by header and footer */
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    if( *chPageText[HEADER] )
        nLinesPerPage--;
    if( *chPageText[FOOTER] )
        nLinesPerPage--;


    /*
    ** There was a bug in NT once where a printer driver would
    ** return a font that was larger than the page size which
    ** would then cause Notepad to constantly print blank pages
    ** To keep from doing this we check to see if we can fit ANYTHING
    ** on a page, if not then there is a problem so quit.  MarkRi 8/92
    */
    if( nLinesPerPage <= 0 )
    {
FontTooBig:
        MessageBox( hwndNP, szFontTooBig, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING );

        SetLastError(0);          // no error

ErrorExit:
        iErr= GetLastError();     // remember the first error

ExitWithThisError:                // preserve iErr (return SP_* errors)

        if( hPrevFont )
        {
            SelectObject( hPrintDC, hPrevFont );
            DeleteObject( hPrintFont );
        }

        if( pStartText )          // were able to lock hText
            LocalUnlock( hText );

        if( fPageStarted )
        {
            if( EndPage( hPrintDC ) <= 0 )
            {
                // if iErr not already set then set it to the new error code.
                if( iErr == 0 )
                {
                    iErr= GetLastError();
                }
       
            }
        }    

        if( fDocStarted )
        {
            if( fAbort ) {
               AbortDoc( hPrintDC );
            }
            else {
               if( EndDoc( hPrintDC ) <= 0 )
               {
                   // if iErr not already set then set it to the new error code.
                   if (iErr == 0)
                   {
                       iErr= GetLastError();
                   }
               }
            }
        }    

        DeleteDC( hPrintDC );

        DestroyAbortWnd();

        SetCursor( hStdCursor );

        if (!fAbort)
        {
            return( iErr );
        }
        else
        {
            return( SP_USERABORT );
        }
    }



    if( (iErr= SetAbortProc (hPrintDC, AbortProc)) < 0 )
    {
        goto ExitWithThisError;
    }

    // get printer to MLE text
    hText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hText )
    {
        goto ErrorExit;
    }
    pStartText= LocalLock( hText );
    if( !pStartText )
    {
        goto ErrorExit;
    }

    GetWindowText( hwndNP, msgbuf, CharSizeOf(msgbuf) );

    EnableWindow( hwndNP, FALSE );    // Disable window to prevent reentrancy

    hAbortDlgWnd= CreateDialog(         hInstanceNP,
                              (LPTSTR)  MAKEINTRESOURCE(IDD_ABORTPRINT),
                                        hwndNP,
                                        AbortDlgProc);

    if( !hAbortDlgWnd )
    {
        goto ErrorExit;
    }

    DocInfo.cbSize= sizeof(DOCINFO);
    DocInfo.lpszDocName= msgbuf;
    DocInfo.lpszOutput= NULL;
    DocInfo.lpszDatatype= NULL; // Type of data used to record print job
    DocInfo.fwType= 0; // not DI_APPBANDING

    SetLastError(0);      // clear error so it reflects errors in the future

    if( StartDoc( hPrintDC, &DocInfo ) <= 0 )
    {
        iErr = GetLastError();
        goto ExitWithThisError;
    }
    fDocStarted= TRUE;


    // Basicly, this is just a loop surrounding the DrawTextEx API.
    // We have to calculate the printable area which will not include
    // the header and footer area.
    {
    INT iTextLeft;        // amount of text left to print
    INT iSta;              // status
    UINT dwDTFormat;       // drawtext flags
    DRAWTEXTPARAMS dtParm; // drawtext control
    RECT rect;             // rectangle to draw in
    UINT dwDTRigh = 0;     // drawtext flags (RTL)

    iPageNum= 1;
    fPageStarted= FALSE;

    // calculate the size of the printable area for the text
    // not including the header and footer

    ZeroMemory( &rect, sizeof(rect) );

    rect.left= dxLeft; rect.right= xPrintRes-dxRight;
    rect.top=  dyTop;  rect.bottom= yPrintRes-dyBottom;

    if( *chPageText[HEADER] != 0 )
    {
        rect.top += yPrintChar;
    }

    if( *chPageText[FOOTER] != 0 )
    {
        rect.bottom -= yPrintChar;
    }

    iTextLeft= lstrlen(pStartText);

    //Get the edit control direction.
    if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING)
        dwDTRigh = DT_RIGHT | DT_RTLREADING;


    while(  !fAbort && (iTextLeft>0) )
    {
        #define MAXSTATUS 100
        TCHAR szPagePrinting[MAXSTATUS+1];

        // update abort dialog box to inform user where we are in the printing
        _sntprintf( szPagePrinting, MAXSTATUS, szCurrentPage, iPageNum ); 
        SetDlgItemText( hAbortDlgWnd, ID_PAGENUMBER, szPagePrinting );

        PrintHeaderFooter( hPrintDC, HEADER );

        ZeroMemory( &dtParm, sizeof(dtParm) );

        dtParm.cbSize= sizeof(dtParm);
        dtParm.iTabLength= tabSize;

        dwDTFormat= DT_EDITCONTROL | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX |
                    DT_WORDBREAK | dwDTRigh | 0;

        if( StartPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= TRUE;

        #ifdef DBGPRINT
        ShowMargins(hPrintDC);
        #endif

        /* Ignore errors in printing.  EndPage or StartPage will find them */
        iSta= DrawTextEx( hPrintDC,
                          pStartText,
                          iTextLeft,
                          &rect,
                          dwDTFormat,
                          &dtParm);

        PrintHeaderFooter( hPrintDC, FOOTER );

        if( EndPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= FALSE;

        iPageNum++;

        // if we can't print a single character (too big perhaps)
        // just bail now.
        if( dtParm.uiLengthDrawn == 0 )
        {
            goto FontTooBig;
        }

        pStartText += dtParm.uiLengthDrawn;
        iTextLeft  -= dtParm.uiLengthDrawn;

    }


    }

    iErr=0;        // no errors
    goto ExitWithThisError;

}


VOID DestroyAbortWnd (void)
{
    EnableWindow(hwndNP, TRUE);
    DestroyWindow(hAbortDlgWnd);
    hAbortDlgWnd = NULL;
}



const DWORD s_PageSetupHelpIDs[] = {
    ID_HEADER_LABEL,       IDH_PAGE_HEADER,
    ID_HEADER,             IDH_PAGE_HEADER,
    ID_FOOTER_LABEL,       IDH_PAGE_FOOTER,
    ID_FOOTER,             IDH_PAGE_FOOTER,
    0, 0
};

/*******************************************************************************
*
*  PageSetupHookProc
*
*  DESCRIPTION:
*     Callback procedure for the PageSetup common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of PageSetup window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR CALLBACK PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    INT   id;    /* ID of dialog edit controls */
    POINT pt;

    switch (Message)
    {

        case WM_INITDIALOG:
            for (id = ID_HEADER; id <= ID_FOOTER; id++)
            {
                SendDlgItemMessage(hWnd, id, EM_LIMITTEXT, PT_LEN-1, 0L);
                SetDlgItemText(hWnd, id, chPageText[id - ID_HEADER]);
            }

            SendDlgItemMessage(hWnd, ID_HEADER, EM_SETSEL, 0,
                               MAKELONG(0, PT_LEN-1));
            return TRUE;

        case WM_DESTROY:
            //  We don't know if the user hit OK or Cancel, so we don't
            //  want to replace our real copies until we know!  We _should_ get
            //  a notification from the common dialog code!
            for( id = ID_HEADER; id <= ID_FOOTER; id++ )
            {
                GetDlgItemText(hWnd, id, chPageTextTemp[id - ID_HEADER],PT_LEN);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {

                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);

            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/***************************************************************************
 * VOID TranslateString(TCHAR *src)
 *
 * purpose:
 *    translate a header/footer strings
 *
 * supports the following:
 *
 *    &&    insert a & char
 *    &f    current file name or (untitled)
 *    &d    date in Day Month Year
 *    &t    time
 *    &p    page number
 *    &p+num  set first page number to num
 *
 * Alignment:
 *    &l, &c, &r for left, center, right
 *
 * params:
 *    IN/OUT  src     this is the string to translate
 *
 *
 * used by:
 *    Header Footer stuff
 *
 * uses:
 *    lots of c lib stuff
 *
 ***************************************************************************/


VOID TranslateString (TCHAR * src)
{
    // File, Page, Time, Date, Center, Right, Left
    // these *never* change so don't put into resources for localizers
    TCHAR        letters[15]=TEXT("fFpPtTdDcCrRlL");
    TCHAR        buf[MAX_PATH];
    INT          page;
    INT          nAlign=CENTER;    // current string to add chars to
    INT          nIndex[RIGHT+1];  // current lengths of (left,center,right)
    struct tm   *newtime;
    time_t       long_time;
    INT          iLen;             // length of strings

    nIndex[LEFT]   = 0;
    nIndex[CENTER] = 0;
    nIndex[RIGHT]  = 0;

    /* Get the time we need in case we use &t. */
    time (&long_time);
    newtime = localtime (&long_time);


    while (*src)   /* look at all of source */
    {
        while (*src && *src != TEXT('&'))
        {
            chBuff[nAlign][nIndex[nAlign]] = *src++;
            nIndex[nAlign] += 1;
        }

        if (*src == TEXT('&'))   /* is it the escape char? */
        {
            src++;

            if (*src == letters[0] || *src == letters[1])
            {                      /* &f file name (no path) */
                if (!FUntitled())
                {
                    GetFileTitle(szFileOpened, buf, CharSizeOf(buf));
                }
                else
                {
                    lstrcpy(buf, szUntitled);
                }

                /* Copy to the currently aligned string. */
                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );

                    /* Update insertion position. */
                    nIndex[nAlign] += lstrlen (buf);
                }

            }
            else if (*src == letters[2] || *src == letters[3])  /* &P or &P+num page */
            {
                src++;
                page = 0;
                if (*src == TEXT('+'))       /* &p+num case */
                {
                    src++;
                    while (_istdigit(*src))
                    {
                        /* Convert to int on-the-fly*/
                        page = (10*page) + (*src) - TEXT('0');
                        src++;
                    }
                }

                wsprintf( buf, TEXT("%d"), iPageNum+page );  // convert to chars

                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );
                    nIndex[nAlign] += lstrlen (buf);
                }
                src--;
            }
            else if (*src == letters[4] || *src == letters[5])   /* &t time */
            {
                iLen= lstrlen( szFormattedTime );

                /* extract time */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedTime, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == letters[6] || *src == letters[7])   /* &d date */
            {
                iLen= lstrlen( szFormattedDate );

                /* extract day month day */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedDate, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == TEXT('&'))       /* quote a single & */
            {
                if( nIndex[nAlign] + 1 < MAXTITLE )
                {
                    chBuff[nAlign][nIndex[nAlign]] = TEXT('&');
                    nIndex[nAlign] += 1;
                }
            }
            /* Set the alignment for whichever has last occured. */
            else if (*src == letters[8] || *src == letters[9])   /* &c center */
                nAlign=CENTER;
            else if (*src == letters[10] || *src == letters[11]) /* &r right */
                nAlign=RIGHT;
            else if (*src == letters[12] || *src == letters[13]) /* &d date */
                nAlign=LEFT;

            src++;
        }
     }
     /* Make sure all strings are null-terminated. */
     for (nAlign= LEFT; nAlign <= RIGHT ; nAlign++)
        chBuff[nAlign][nIndex[nAlign]] = (TCHAR) 0;

}

/* GetPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */

HANDLE GetPrinterDC (VOID)
{
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;
    HDC hDC;


    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;
    }

    if( !g_PageSetupDlg.hDevNames )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    lpDevNames= (LPDEVNAMES) GlobalLock (g_PageSetupDlg.hDevNames);


    lpDevMode= NULL;

    if( g_PageSetupDlg.hDevMode )
       lpDevMode= (LPDEVMODE) GlobalLock( g_PageSetupDlg.hDevMode );

    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *  will be NULL after GlobalLock()
     */

    /* The lpszOutput name is null so CreateDC will use the current setting
     * from PrintMan.
     */

    hDC= CreateDC (((LPTSTR)lpDevNames)+lpDevNames->wDriverOffset,
                      ((LPTSTR)lpDevNames)+lpDevNames->wDeviceOffset,
                      NULL,
                      lpDevMode);

    GlobalUnlock( g_PageSetupDlg.hDevNames );

    if( g_PageSetupDlg.hDevMode )
        GlobalUnlock( g_PageSetupDlg.hDevMode );


    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* GetNonDefPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */
/*                        using the name of the Printer server */

HANDLE GetNonDefPrinterDC (VOID)
{
    HDC     hDC;
    HANDLE  hPrinter;
    DWORD   dwBuf;
    DRIVER_INFO_1  *di1;



    // open the printer and retrieve the driver name.
    if (!OpenPrinter(szPrinterName, &hPrinter, NULL))
    {
        return INVALID_HANDLE_VALUE;
    }

    // get the buffer size.
    GetPrinterDriver(hPrinter, NULL, 1, NULL, 0, &dwBuf);
    di1 = (DRIVER_INFO_1  *) LocalAlloc(LPTR, dwBuf);
    if (!di1)
    {
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 1, (LPBYTE) di1, dwBuf, &dwBuf))
    {
        LocalFree(di1);
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    // Initialize the PageSetup dlg to default values.
    // using default printer's value for another printer !!
    g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
    PageSetupDlg(&g_PageSetupDlg);
    g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;

    // create printer dc with default initialization.
    hDC= CreateDC (di1->pName, szPrinterName, NULL, NULL);

    // cleanup.
    LocalFree(di1);
    ClosePrinter(hPrinter);

    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* PrintIt() - print the file, giving popup if some error */

void PrintIt(PRINT_DIALOG_TYPE type)
{
    INT iError;
    TCHAR* szMsg= NULL;
    TCHAR  msg[400];       // message info on error

    /* print the file */

    iError= NpPrint( type );

    if(( iError != 0) &&
       ( iError != SP_APPABORT )     &&
       ( iError != SP_USERABORT ) )
    {
        // translate any known spooler errors
        if( iError == SP_OUTOFDISK   ) iError= ERROR_DISK_FULL;
        if( iError == SP_OUTOFMEMORY ) iError= ERROR_OUTOFMEMORY;
        if( iError == SP_ERROR       ) iError= GetLastError();
        /* SP_NOTREPORTED not handled.  Does it happen? */


        //
        // iError may be 0 because the user aborted the printing.
        // Just ignore.
        //

        if( iError == 0 ) return;

        // Get system to give reasonable error message
        // These will also be internationalized.

        if(!FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           iError,
                           GetUserDefaultLangID(),
                           msg,  // where message will end up
                           CharSizeOf(msg), NULL ) )
        {
            szMsg= szCP;   // couldn't get system to say; give generic msg
        }
        else
        {
            szMsg= msg;
        }

        AlertBox( hwndNP, szNN, szMsg, SzTitle(),
                  MB_APPLMODAL | MB_OK | MB_ICONWARNING);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\precomp.h ===
#define WIN31
#include "notepad.h"
#include <shellapi.h>
#include <cderr.h>
#include <winnlsp.h>   // for NORM_STOP_ON_NULL

#include <string.h>

//
// We need to define BYTE_ORDER_MARK, and figure
// out how to get the system to tell us a font is a 
// unicode font, and then we can eliminate uconvert.h
//
#include "uconvert.h"
#include "uniconv.h"
#include <stdio.h>

#include <stdlib.h>

#include <ctype.h>
#include <time.h>
#include <winspool.h>
#include "dlgs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\nputf.c ===
/*
 * nputf.c  - Routines for utf text processing for notepad
 *
 * Copyright (C) 1998-2000 Microsoft Corporation
 */

#include "precomp.h"


/* IsTextUTF8
 *
 * UTF-8 is the encoding of Unicode based on Internet Society RFC2279
 * ( See http://www.cis.ohio-state.edu/htbin/rfc/rfc2279.html )
 *
 * Basicly:
 * 0000 0000-0000 007F - 0xxxxxxx  (ascii converts to 1 octet!)
 * 0000 0080-0000 07FF - 110xxxxx 10xxxxxx    ( 2 octet format)
 * 0000 0800-0000 FFFF - 1110xxxx 10xxxxxx 10xxxxxx (3 octet format)
 * (this keeps going for 32 bit unicode) 
 * 
 *
 * Return value:  TRUE, if the text is in UTF-8 format.
 *                FALSE, if the text is not in UTF-8 format.
 *                We will also return FALSE is it is only 7-bit ascii, so the right code page
 *                will be used.
 *
 *                Actually for 7 bit ascii, it doesn't matter which code page we use, but
 *                notepad will remember that it is utf-8 and "save" or "save as" will store
 *                the file with a UTF-8 BOM.  Not cool.
 */


INT IsTextUTF8( LPSTR lpstrInputStream, INT iLen )
{
    INT   i;
    DWORD cOctets;  // octets to go in this UTF-8 encoded character
    UCHAR chr;
    BOOL  bAllAscii= TRUE;

    cOctets= 0;
    for( i=0; i < iLen; i++ ) {
        chr= *(lpstrInputStream+i);

        if( (chr&0x80) != 0 ) bAllAscii= FALSE;

        if( cOctets == 0 )  {
            //
            // 7 bit ascii after 7 bit ascii is just fine.  Handle start of encoding case.
            //
            if( chr >= 0x80 ) {  
               //
               // count of the leading 1 bits is the number of characters encoded
               //
               do {
                  chr <<= 1;
                  cOctets++;
               }
               while( (chr&0x80) != 0 );

               cOctets--;                        // count includes this character
               if( cOctets == 0 ) return FALSE;  // must start with 11xxxxxx
            }
        }
        else {
            // non-leading bytes must start as 10xxxxxx
            if( (chr&0xC0) != 0x80 ) {
                return FALSE;
            }
            cOctets--;                           // processed another octet in encoding
        }
    }

    //
    // End of text.  Check for consistency.
    //

    if( cOctets > 0 ) {   // anything left over at the end is an error
        return FALSE;
    }

    if( bAllAscii ) {     // Not utf-8 if all ascii.  Forces caller to use code pages for conversion
        return FALSE;
    }

    return TRUE;
}


/* IsInputTextUnicode
 * Verify if the input stream is in Unicode format.
 *
 * Return value:  TRUE, if the text is in Unicode format.
 *
 * 29 June 1998          
 */


INT IsInputTextUnicode  (LPSTR lpstrInputStream, INT iLen)
{
    INT  iResult= ~0; // turn on IS_TEXT_UNICODE_DBCS_LEADBYTE
    BOOL bUnicode;

    // We would like to check the possibility
    // of IS_TEXT_UNICODE_DBCS_LEADBYTE.
    //

    bUnicode= IsTextUnicode( lpstrInputStream, iLen, &iResult);

    if (bUnicode                                         &&
       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    )
    {
        CPINFO cpiInfo;
        CHAR* pch= (CHAR*)lpstrInputStream;
        INT  cb;

        //
        // If the result depends only upon statistics, check
        // to see if there is a possibility of DBCS.
        // Only do this check if the ansi code page is DBCS
        //

        GetCPInfo( CP_ACP, &cpiInfo);

        if( cpiInfo.MaxCharSize > 1 )
        {
            for( cb=0; cb<iLen; cb++ )
            {
                if( IsDBCSLeadByte(*pch++) )
                {
                    return FALSE;
                }
            }
        }
     }

     return bUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\notepad.h ===
/* Notepad.h */

#define NOCOMM
#define NOSOUND
#include <windows.h>
#include <ole2.h>
#include <commdlg.h>
#include <commctrl.h>
// we need this for CharSizeOf(), ByteCountOf(),
#include "uniconv.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

/* handy debug macro */
#define ODS OutputDebugString

typedef enum _NP_FILETYPE {
   FT_UNKNOWN=-1,
   FT_ANSI=0,
   FT_UNICODE=1,
   FT_UNICODEBE=2,
   FT_UTF8=3,
} NP_FILETYPE;


#define BOM_UTF8_HALF        0xBBEF
#define BOM_UTF8_2HALF       0xBF


/* openfile filter for all text files */
#define FILE_TEXT         1


/* ID for the status window */
#define ID_STATUS_WINDOW     WM_USER+1


#define PT_LEN               40    /* max length of page setup strings */
#define CCHFILTERMAX         80    /* max. length of filter name buffers */

// Menu IDs 
#define ID_APPICON           1 /* must be one for explorer to find this */
#define ID_ICON              2
#define ID_MENUBAR           1

// Dialog IDs

#define IDD_ABORTPRINT       11
#define IDD_PAGESETUP        12
#define IDD_SAVEDIALOG       13    // template for save dialog
#define IDD_GOTODIALOG       14    // goto line number dialog

// Control IDs 

#define IDC_FILETYPE         257   // listbox in save dialog
#define IDC_GOTO             258   // line number to goto
#define IDC_ENCODING         259   // static text in save dialog

//  Menu IDs 

// File
#define M_NEW                1
#define M_OPEN               2
#define M_SAVE               3
#define M_SAVEAS             4
#define M_PAGESETUP          5
#define M_PRINT              6
#define M_EXIT               7

// Edit
#define M_UNDO               16
#define M_CUT                WM_CUT       /* These just get passed down to the edit control */
#define M_COPY               WM_COPY
#define M_PASTE              WM_PASTE
#define M_CLEAR              WM_CLEAR
#define M_FIND               21
#define M_FINDNEXT           22
#define M_REPLACE            23
#define M_GOTO               24
#define M_SELECTALL          25
#define M_DATETIME           26
#define M_STATUSBAR          27

// Format
#define M_WW                 32
#define M_SETFONT            33

// Help
#define M_HELP               64
#define M_ABOUT              65

// Control IDs

#define ID_EDIT              15
#define ID_FILENAME          20
#define ID_PAGENUMBER        21


#define ID_HEADER            30
#define ID_FOOTER            31
#define ID_HEADER_LABEL      32
#define ID_FOOTER_LABEL      33

#define ID_ASCII             50
#define ID_UNICODE           51


// IDs used to load RC strings
//
// Note: The international team doesn't like wholesale changes
// to these IDs.  Apparently, if the ID changes they have to
// translate the string again.  It's best to just add new IDs 
// to the end.

#define IDS_DISKERROR         1
#define IDS_FNF               2
#define IDS_SCBC              3
#define IDS_UNTITLED          4
#define IDS_NOTEPAD           5
#define IDS_CFS               6
#define IDS_ERRSPACE          7
#define IDS_FTL               8
#define IDS_NN                9
#define IDS_COMMDLGINIT      10
#define IDS_PRINTDLGINIT     11
#define IDS_CANTPRINT        12
#define IDS_NVF              13
#define IDS_CREATEERR        14
#define IDS_NOWW             15
#define IDS_MERGE1           16
#define IDS_HELPFILE         17
#define IDS_HEADER           18
#define IDS_FOOTER           19

#define IDS_ANSITEXT         20
#define IDS_ALLFILES         21
#define IDS_OPENCAPTION      22
#define IDS_SAVECAPTION      23
#define IDS_CANNOTQUIT       24
#define IDS_LOADDRVFAIL      25
#define IDS_ACCESSDENY       26
#define IDS_ERRUNICODE       27


#define IDS_FONTTOOBIG       28
#define IDS_COMMDLGERR       29


#define IDS_LINEERROR        30  /* line number error     */
#define IDS_LINETOOLARGE     31  /* line number too large */

#define IDS_FT_ANSI          32  /* ascii              */
#define IDS_FT_UNICODE       33  /* unicode            */
#define IDS_FT_UNICODEBE     34  /* unicode big endian */
#define IDS_FT_UTF8          35  /* UTF-8 format       */

#define IDS_CURRENT_PAGE     36  /* currently printing page on abort dlg */

// constants for the status bar
#define IDS_LINECOL          37
#define IDS_COMPRESSED_FILE  38
#define IDS_ENCRYPTED_FILE   39
#define IDS_HIDDEN_FILE      40
#define IDS_OFFLINE_FILE     41
#define IDS_READONLY_FILE    42
#define IDS_SYSTEM_FILE      43
#define IDS_FILE             44


#define IDS_LETTERS          45    /* formatting letters used in page setup */

#define CSTRINGS             45    /* cnt of stringtable strings from .rc file */

// This string is used by MUI for the "FriendlyTypeName".
// See reference to it in hivecls.inx
// We don't load it so the number is out of sequence with those we do load.

#define IDS_TEXT_FRIENDLY_NAME      469

#define CCHKEYMAX           128  /* max characters in search string */

#define BUFFER_TEST_SIZE    1024 /* number of characters to read from a file to determine the file encoding */

#define CCHNPMAX              0  /* no limit on file size */

#define SETHANDLEINPROGRESS   0x0001 /* EM_SETHANDLE has been sent */
#define SETHANDLEFAILED       0x0002 /* EM_SETHANDLE caused EN_ERRSPACE */

/* Standard edit control style:
 * ES_NOHIDESEL set so that find/replace dialog doesn't undo selection
 * of text while it has the focus away from the edit control.  Makes finding
 * your text easier.
 */
#define ES_STD (WS_CHILD|WS_VSCROLL|WS_VISIBLE|ES_MULTILINE|ES_NOHIDESEL)

/* EXTERN decls for data */
extern NP_FILETYPE fFileType;     /* Flag indicating the type of text file */

extern BOOL fCase;                /* Flag specifying case sensitive search */
extern BOOL fReverse;             /* Flag for direction of search */
extern TCHAR szSearch[];
extern HWND hDlgFind;             /* handle to modeless FindText window */

extern HANDLE hEdit;
extern HANDLE hFont;
extern HANDLE hAccel;
extern HANDLE hInstanceNP;
extern HANDLE hStdCursor, hWaitCursor;
extern HWND   hwndNP, hwndEdit, hwndStatus;

extern LOGFONT  FontStruct;
extern INT      iPointSize;

extern BOOL     fRunBySetup;

extern DWORD    dwEmSetHandle;

extern TCHAR    chMerge;

extern BOOL     fUntitled;
extern BOOL     fWrap;
extern TCHAR    szFileName[];
extern HANDLE   fp;

extern BOOL     fMLE_is_broken;

//
// Holds header and footer strings to be used in printing.
// use HEADER and FOOTER to index.
//
extern TCHAR    chPageText[2][PT_LEN]; // header and footer strings
#define HEADER 0
#define FOOTER 1
//
// Holds header and footer from pagesetupdlg during destroy.
// if the user hit ok, then keep.  Otherwise ignore.
//
extern TCHAR    chPageTextTemp[2][PT_LEN];

extern TCHAR    szNotepad[];
extern TCHAR   *szMerge;
extern TCHAR   *szUntitled, *szNpTitle, *szNN, *szErrSpace;
extern TCHAR   *szErrUnicode;
extern TCHAR  **rgsz[];          /* More strings. */
extern TCHAR   *szNVF;
extern TCHAR   *szPDIE;
extern TCHAR   *szDiskError;
extern TCHAR   *szCREATEERR;
extern TCHAR   *szWE;
extern TCHAR   *szFTL;
extern TCHAR   *szINF;
extern TCHAR   *szFNF;
extern TCHAR   *szNEDSTP;
extern TCHAR   *szNEMTP;
extern TCHAR   *szCFS;
extern TCHAR   *szPE;
extern TCHAR   *szCP;
extern TCHAR   *szACCESSDENY;
extern TCHAR   *szFontTooBig;
extern TCHAR   *szLoadDrvFail;
extern TCHAR   *szCommDlgErr;
extern TCHAR   *szCommDlgInitErr;
extern TCHAR   *szHelpFile;

extern TCHAR   *szFtAnsi;
extern TCHAR   *szFtUnicode;
extern TCHAR   *szFtUnicodeBe;
extern TCHAR   *szFtUtf8;
extern TCHAR   *szCurrentPage;
extern TCHAR   *szHeader;
extern TCHAR   *szFooter;
extern TCHAR   *szLetters;

/* variables for the new File/Open and File/Saveas dialogs */
extern OPENFILENAME OFN;        /* passed to the File Open/save APIs */
extern TCHAR  szOpenFilterSpec[]; /* default open filter spec          */
extern TCHAR  szSaveFilterSpec[]; /* default save filter spec          */
extern TCHAR *szAnsiText;       /* part of the text for the above    */
extern TCHAR *szAllFiles;       /* part of the text for the above    */
extern FINDREPLACE FR;          /* Passed to FindText()        */
extern PAGESETUPDLG g_PageSetupDlg;
extern TCHAR  szPrinterName []; /* name of the printer passed to PrintTo */

extern NP_FILETYPE    g_ftOpenedAs;     /* file was opened           */
extern NP_FILETYPE    g_ftSaveAs;       /* file was saved as type    */

extern UINT   wFRMsg;           /* message used in communicating    */
                                /*   with Find/Replace dialog       */
extern UINT   wHlpMsg;          /* message used in invoking help    */

extern HMENU hSysMenuSetup;     /* Save Away for disabled Minimize   */
extern BOOL  fStatus;
extern INT   dyStatus;


/* Macro for setting status bar - x is the text to set and n is the part number
   in the statusbar */
#define SetStatusBarText(x, n) if(hwndStatus)SendMessage(hwndStatus, SB_SETTEXT, n, (LPARAM)(LPTSTR)(x));
VOID UpdateStatusBar( BOOL fForceUpdate );



/* EXTERN procs */
/* procs in notepad.c */
VOID
PASCAL
SetPageSetupDefaults(
    VOID
    );

BOOL far PASCAL SaveAsDlgHookProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

LPTSTR PASCAL far PFileInPath (LPTSTR sz);

BOOL FAR CheckSave (BOOL fSysModal);
LRESULT FAR NPWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void FAR SetTitle (TCHAR *sz);
INT FAR  AlertBox (HWND hwndParent, TCHAR *szCaption, TCHAR *szText1,
                   TCHAR *szText2, UINT style);
void FAR NpWinIniChange (VOID);
void FAR FreeGlobalPD (void);
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
VOID CALLBACK WinEventFunc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject,
                      LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime);


NP_FILETYPE fDetermineFileType(LPBYTE lpFileContents, UINT iSize);
VOID GotoAndScrollInView( INT OneBasedLineNumber );
void NPSize (int cxNew, int cyNew);


/* procs in npdate.c */
VOID FAR InsertDateTime (BOOL fCrlf);

/* procs in npfile.c */
BOOL FAR  SaveFile (HWND hwndParent, TCHAR *szFileSave, BOOL fSaveAs);
BOOL FAR  LoadFile (TCHAR *sz, INT type );
VOID FAR  New (BOOL  fCheck);
void FAR  AddExt (TCHAR *sz);
INT FAR   Remove (LPTSTR szFileName);
VOID FAR  AlertUser_FileFail( LPTSTR szFileName );

/* procs in npinit.c */
INT FAR  NPInit (HANDLE hInstance, HANDLE hPrevInstance,
                 LPTSTR lpCmdLine, INT cmdShow);
void FAR InitLocale (VOID);
void SaveGlobals( VOID );

/* procs in npmisc.c */
INT FAR  FindDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL     Search (TCHAR *szSearch);
INT FAR  AboutDlgProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL FAR NpReCreate (LONG style);
LPTSTR   ForwardScan (LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive);


/* procs in npprint.c */
typedef enum _PRINT_DIALOG_TYPE {
   UseDialog,
   DoNotUseDialog,
   NoDialogNonDefault
} PRINT_DIALOG_TYPE;

INT    AbortProc( HDC hPrintDC, INT reserved );
INT_PTR AbortDlgProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT    NpPrint( PRINT_DIALOG_TYPE type );
INT    NpPrintGivenDC( HDC hPrintDC );

UINT_PTR
CALLBACK
PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

HANDLE GetPrinterDC (VOID);
HANDLE GetNonDefPrinterDC (VOID);
VOID   PrintIt(PRINT_DIALOG_TYPE type);


/* procs in nputf.c */

INT    IsTextUTF8   (LPSTR lpstrInputStream, INT iLen);
INT    IsInputTextUnicode(LPSTR lpstrInputStream, INT iLen);



// Help IDs for Notepad

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_PAGE_FOOTER                 1000
#define IDH_PAGE_HEADER                 1001
#define IDH_FILETYPE                    1002
#define IDH_GOTO                        1003

// Private message to track the HKL switch

#define PWM_CHECK_HKL                   (WM_APP + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\npdate.c ===
/* npdate - Code for getting and inserting current date and time.
 *   Copyright (C) 1984-1995 Microsoft Inc.
 */

#include "precomp.h"

/* ** Replace current selection with date/time string.
 *    if fCrlf is true, date/time string should begin
 *    and end with crlf
*/
VOID FAR InsertDateTime (BOOL fCrlf)
{
   SYSTEMTIME time ;
   TCHAR szDate[80] ;
   TCHAR szTime[80] ;
   TCHAR szDateTime[sizeof(szDate) + sizeof(szTime) + 10] = TEXT("");
   DWORD locale;
   BOOL bMELocale;
   DWORD dwFlags = DATE_SHORTDATE;

   //  See if the user locale id is Arabic or Hebrew.
   locale    = GetUserDefaultLCID();
   bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW));

   locale = MAKELCID( MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), SORT_DEFAULT) ;

   // Get the time
   GetLocalTime( &time ) ;

   if (bMELocale)
   {
       //Get the date format that matches the edit control reading direction.
       if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING) {
           dwFlags |= DATE_RTLREADING;
           lstrcat(szDateTime, TEXT("\x200F")); // RLM
       } else {
           dwFlags |= DATE_LTRREADING;
           lstrcat(szDateTime, TEXT("\x200E")); // LRM
       }
   }

   // Format date and time
   GetDateFormat(locale,dwFlags, &time,NULL,szDate,CharSizeOf(szDate));
   GetTimeFormat(locale,TIME_NOSECONDS,&time,NULL,szTime,CharSizeOf(szTime));

   if( fCrlf )
       lstrcat(szDateTime, TEXT("\r\n"));


   lstrcat(szDateTime, szTime);
   lstrcat(szDateTime, TEXT(" "));
   lstrcat(szDateTime, szDate);

   if( fCrlf )
        lstrcat(szDateTime, TEXT("\r\n"));

   // send it in one shot; this is also useful for undo command
   // so that user can undo the date-time.
   SendMessage(hwndEdit, EM_REPLACESEL, TRUE, (LPARAM)szDateTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\newpad\npxml.c ===
/*
 * XML support functions
 *  Copyright (C) 2000 Microsoft Corporation
 */

#include "precomp.h"


BOOL FIsXmlWhitespaceW(WCHAR wch)
{
    return((wch == L' ') || (wch == L'\x9') || (wch == L'\xA') || (wch == L'\xD'));
}


BOOL FIsXmlWhitespaceA(char ch)
{
    return(FIsXmlWhitespaceW((WCHAR) (BYTE) ch));
}


BOOL FIsXmlA(LPCSTR rgch, UINT cch)
{
    if (memcmp(rgch, "<?xml", 5) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FIsXmlW(LPCWSTR rgwch, UINT cch)
{
    if (memcmp(rgwch, L"<?xml", 5 * sizeof(WCHAR)) != 0)
    {
        // Not XML

        return(FALSE);
    }

    return(TRUE);

    UNREFERENCED_PARAMETER( cch );
}


BOOL FDetectXmlEncodingA(LPCSTR rgch, UINT cch, UINT *pcp)
{
    LPCSTR pchMax;
    LPCSTR pch;
    char chQuote;

    // XML files encoded in UTF-16 are required to have a BOM which if present
    // would already have been detected.  This means that if this file is XML
    // it either is encoded in UCS-4 or UTF-32 which isn't supported or an MBCS
    // encoding of some form.  We check for ASCII compatible encodings only
    // which includes everything we probably care about but excludes EBCDIC.

    // Check for file begining with <?xml ... encoding='...' ... ?>

    if (cch < 20)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsXmlA(rgch, cch))
    {
        // Not XML

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 5;

    if (!FIsXmlWhitespaceA(*pch))
    {
        // Not XML

        return(FALSE);
    }

    pch++;

    chQuote = '\0';

    for (;;)
    {
        LPCSTR pchToken;

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        if (FIsXmlWhitespaceA(*pch))
        {
            pch++;
            continue;
        }

        if (*pch == '=')
        {
            pch++;
            continue;
        }

        if ((*pch == '\'') || (*pch == '"'))
        {
            if (*pch == chQuote)
            {
                chQuote = '\0';
            }

            else
            {
                chQuote = *pch;
            }

            pch++;
            continue;
        }

        if (chQuote != '\0')
        {
            // We are within a quoted string.  Skip everything until closing quote.

            pch++;
            continue;
        }

        if ((pch + 2) > pchMax)
        {
            // Not XML

            break;
        }

        if ((pch[0] == '?') && (pch[1] == '>'))
        {
            // This looks like XML.  At this point if we don't find an encoding
            // specification we could assume UTF-8.  We don't because there are
            // malformed XML documents and assuming UTF-8 might affect Notepad
            // compatibility.  This may be fine but we put it off for now.

            // *pcp = CP_UTF8;
            // return(TRUE);

            break;
        }

        pchToken = pch;

        while ((pch < pchMax) && (*pch != '=') && (*pch != '?') && !FIsXmlWhitespaceA(*pch))
        {
            pch++;
        }

        if (pch != (pchToken + 8))
        {
             continue;
        }

        if (memcmp(pchToken, "encoding", 8) != 0)
        {
             continue;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceA(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || (*pch++ != '='))
        {
            // Not XML

            break;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceA(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || ((*pch != '\'') && (*pch != '"')))
        {
            // Not XML

            break;
        }

        chQuote = *pch++;

        pchToken = pch;

        while ((pch < pchMax) && (*pch != chQuote))
        {
            pch++;
        }

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        // We have an XML encoding declaration from pchToken to (pch - 1)

        if (pch == pchToken)
        {
            // Not XML

            break;
        }

        if (!FLookupCodepageNameA((LPCSTR) pchToken, (UINT) (pch - pchToken), pcp))
        {
            // Encoding is not recognized

            break;
        }

        if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
        {
            // These are bogus since we know the file is MBCS

            break;
        }

        return(FValidateCodepage(hwndNP, *pcp));
    }

    return(FALSE);
}


BOOL FDetectXmlEncodingW(LPCWSTR rgch, UINT cch, UINT *pcp)
{
    const WCHAR *pchMax;
    const WCHAR *pch;
    WCHAR chQuote;

    // XML files encoded in UTF-16 are required to have a BOM which if present
    // would already have been detected.  This means that if this file is XML
    // it either is encoded in UCS-4 or UTF-32 which isn't supported or an MBCS
    // encoding of some form.  We check for ASCII compatible encodings only
    // which includes everything we probably care about but excludes EBCDIC.

    // Check for file begining with <?xml ... encoding='...' ... ?>

    if (cch < 20)
    {
        // File is too small

        return(FALSE);
    }

    if (!FIsXmlW(rgch, cch))
    {
        // Not XML

        return(FALSE);
    }

    // Don't scan more than 4K looking for encoding even if it is valid XML

    cch = __min(cch, 4096);

    pchMax = rgch + cch;
    pch = rgch + 5;

    if (!FIsXmlWhitespaceW(*pch))
    {
        // Not XML

        return(FALSE);
    }

    pch++;

    chQuote = L'\0';

    for (;;)
    {
        const WCHAR *pchToken;

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        if (FIsXmlWhitespaceW(*pch))
        {
            pch++;
            continue;
        }

        if (*pch == L'=')
        {
            pch++;
            continue;
        }

        if ((*pch == L'\'') || (*pch == L'"'))
        {
            if (*pch == chQuote)
            {
                chQuote = L'\0';
            }

            else
            {
                chQuote = *pch;
            }

            pch++;
            continue;
        }

        if (chQuote != L'\0')
        {
            // We are within a quoted string.  Skip everything until closing quote.

            pch++;
            continue;
        }

        if ((pch + 2) > pchMax)
        {
            // Not XML

            break;
        }

        if ((pch[0] == L'?') && (pch[1] == L'>'))
        {
            // This looks like XML.  At this point if we don't find an encoding
            // specification we could assume UTF-8.  We don't because there are
            // malformed XML documents and assuming UTF-8 might affect Notepad
            // compatibility.  This may be fine but we put it off for now.

            // *pcp = CP_UTF8;
            // return(TRUE);

            break;
        }

        pchToken = pch;

        while ((pch < pchMax) && (*pch != L'=') && (*pch != L'?') && !FIsXmlWhitespaceW(*pch))
        {
            pch++;
        }

        if (pch != (pchToken + 8))
        {
             continue;
        }

        if (memcmp(pchToken, L"encoding", 8) != 0)
        {
             continue;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceW(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || (*pch++ != L'='))
        {
            // Not XML

            break;
        }

        while ((pch < pchMax) && FIsXmlWhitespaceW(*pch))
        {
            pch++;
        }

        if ((pch == pchMax) || ((*pch != L'\'') && (*pch != L'"')))
        {
            // Not XML

            break;
        }

        chQuote = *pch++;

        pchToken = pch;

        while ((pch < pchMax) && (*pch != chQuote))
        {
            pch++;
        }

        if (pch == pchMax)
        {
            // Not XML

            break;
        }

        // We have an XML encoding declaration from pchToken to (pch - 1)

        if (pch == pchToken)
        {
            // Not XML

            break;
        }

        if (!FLookupCodepageNameW(pchToken, (UINT) (pch - pchToken), pcp))
        {
            // Encoding is not recognized

            break;
        }

#if 0
        if ((*pcp == CP_UTF16) || (*pcp == CP_UTF16BE))
        {
            // These are bogus since we know the file is MBCS

            break;
        }
#endif

        return(FValidateCodepage(hwndNP, *pcp));
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\precomp.h ===
#define WIN31
#include "notepad.h"
#include <shellapi.h>
#include <cderr.h>
#include <winnlsp.h>   // for NORM_STOP_ON_NULL

#include <string.h>

//
// We need to define BYTE_ORDER_MARK, and figure
// out how to get the system to tell us a font is a 
// unicode font, and then we can eliminate uconvert.h
//
#include "uconvert.h"
#include "uniconv.h"
#include <stdio.h>

#include <stdlib.h>

#include <ctype.h>
#include <time.h>
#include <winspool.h>
#include "dlgs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\npinit.c ===
/*
 *   Notepad application
 *
 *      Copyright (C) 1984-1995 Microsoft Inc.
 *
 *      NPInit - One time init for notepad.
 *               Routines are in a separate segment.
 */

#include "precomp.h"


TCHAR chPageText[2][PT_LEN];    /* Strings to hold PageSetup items.        */
TCHAR chPageTextTemp[2][PT_LEN];
TCHAR szPrinterName[256];       /* String to hold printername for PrintTo verb */

static NP_FILETYPE fInitFileType;     /* file type override                      */
static INT fSaveWindowPositions=0;    /* true if we are to save window position  */

static INT g_WPtop,g_WPleft,g_WPDX,g_WPDY;   /* initial window positions          */

/* routines to handle saving and restoring information in the registry.
 *
 * SaveGlobals - saves interesting globals to the registry
 *
 * GetGlobals  - gets interesting globals from the registry
 *
 * Interesting Globals:
 *
 * FontStruct information include calculated pointsize
 * Codepage
 *
 * If we want to save PageSetup info, save the margins in some
 * units (cm for example) and convert on input and output.
 */

/* name of section to save into -- never internationalize */
#define OURKEYNAME TEXT("Software\\Microsoft\\Notepad")

// RegWriteInt - write an integer to the registry

VOID RegWriteInt( HKEY hKey, PTCHAR pszKey, INT iValue )
{
    RegSetValueEx( hKey, pszKey, 0, REG_DWORD, (BYTE*)&iValue, sizeof(INT) );
}

// RegWriteString - write a string to the registry

VOID RegWriteString( HKEY hKey, PTCHAR pszKey, PTCHAR pszValue )
{
    INT len;     // length of string with null in bytes

    len= (lstrlen( pszValue )+1) * sizeof(TCHAR);
    RegSetValueEx( hKey, pszKey, 0, REG_SZ, (BYTE*)pszValue, len );
}

// RegGetInt - Get integer from registry

DWORD RegGetInt( HKEY hKey, PTCHAR pszKey, DWORD dwDefault )
{
    DWORD dwResult= !ERROR_SUCCESS;
    LONG  lStatus= ERROR_SUCCESS;
    DWORD dwSize= sizeof(DWORD);
    DWORD dwType= 0;

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) &dwResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_DWORD )
    {
        dwResult= dwDefault;
    }
    return( dwResult );
}

// RegGetString - get string from registry

VOID RegGetString( HKEY hKey, PTCHAR pszKey, PTCHAR pszDefault, PTCHAR pszResult, INT iCharLen )
{
    LONG  lStatus= !ERROR_SUCCESS;
    DWORD dwSize;      // size of buffer
    DWORD dwType;

    dwSize= iCharLen * sizeof(TCHAR);

    if( hKey )
    {
        lStatus= RegQueryValueEx( hKey,
                                  pszKey,
                                  NULL,
                                  &dwType,
                          (BYTE*) pszResult,
                                  &dwSize );
    }

    if( lStatus != ERROR_SUCCESS || dwType != REG_SZ )
    {
        CopyMemory( pszResult, pszDefault, iCharLen*sizeof(TCHAR) );
    }
}


// lfHeight is calculated using PointSize
// lfWidth set by font mapper


VOID SaveGlobals(VOID)
{
    HKEY hKey;    // key to our registry root
    LONG lStatus; // status from RegCreateKey
    WINDOWPLACEMENT wp;

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        return;   // just return quietly
    }

    RegWriteInt( hKey, TEXT("lfEscapement"),     FontStruct.lfEscapement);
    RegWriteInt( hKey, TEXT("lfOrientation"),    FontStruct.lfOrientation);
    RegWriteInt( hKey, TEXT("lfWeight"),         FontStruct.lfWeight);
    RegWriteInt( hKey, TEXT("lfItalic"),         FontStruct.lfItalic);
    RegWriteInt( hKey, TEXT("lfUnderline"),      FontStruct.lfUnderline);
    RegWriteInt( hKey, TEXT("lfStrikeOut"),      FontStruct.lfStrikeOut);
    RegWriteInt( hKey, TEXT("lfCharSet"),        FontStruct.lfCharSet);
    RegWriteInt( hKey, TEXT("lfOutPrecision"),   FontStruct.lfOutPrecision);
    RegWriteInt( hKey, TEXT("lfClipPrecision"),  FontStruct.lfClipPrecision);
    RegWriteInt( hKey, TEXT("lfQuality"),        FontStruct.lfQuality);
    RegWriteInt( hKey, TEXT("lfPitchAndFamily"), FontStruct.lfPitchAndFamily);
    RegWriteInt( hKey, TEXT("iPointSize"),       iPointSize);
    RegWriteInt( hKey, TEXT("fWrap"),            fWrap);
    RegWriteInt( hKey, TEXT("StatusBar"),        fStatus);
    RegWriteInt( hKey, TEXT("fSaveWindowPositions"),fSaveWindowPositions );

    RegWriteString( hKey, TEXT("lfFaceName"), FontStruct.lfFaceName);

    RegWriteString( hKey, TEXT("szHeader"),  chPageText[HEADER] );
    RegWriteString( hKey, TEXT("szTrailer"), chPageText[FOOTER] );
    RegWriteInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    RegWriteInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    RegWriteInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    RegWriteInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    RegWriteInt( hKey, TEXT("fMLE_is_broken"), fMLE_is_broken );

    wp.length= sizeof(wp);

    if( GetWindowPlacement( hwndNP, &wp ) )
    {
        RegWriteInt( hKey, TEXT("iWindowPosX"), wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosY"), wp.rcNormalPosition.top);
        RegWriteInt( hKey, TEXT("iWindowPosDX"), wp.rcNormalPosition.right - wp.rcNormalPosition.left);
        RegWriteInt( hKey, TEXT("iWindowPosDY"), wp.rcNormalPosition.bottom - wp.rcNormalPosition.top);
    }

    RegCloseKey( hKey );
}


// GetGlobals
//
// Pick up font information etc that may be saved in the registry.
//
// We are called pretty early in setup and don't have things like hwndNP valid yet.
//

VOID GetGlobals( VOID )
{
    LOGFONT lfDef;          // default logical font
    HFONT   hFont;          // standard font to use
    LONG    lStatus;        // status from RegCreateKey
    HKEY    hKey;           // key into registry

    //
    // quickly get a reasonable set of default parameters
    // for the default font if we need it.
    //

    hFont= GetStockObject( SYSTEM_FIXED_FONT );

    if ( hFont )
    {
        GetObject( hFont, sizeof(LOGFONT), &lfDef );
    }

    lStatus= RegCreateKey( HKEY_CURRENT_USER, OURKEYNAME, &hKey );
    if( lStatus != ERROR_SUCCESS )
    {
        hKey= NULL;   // later calls to RegGet... will return defaults
    }
    FontStruct.lfWidth= 0;



    FontStruct.lfEscapement=     (LONG)RegGetInt( hKey, TEXT("lfEscapement"),     lfDef.lfEscapement);
    FontStruct.lfOrientation=    (LONG)RegGetInt( hKey, TEXT("lfOrientation"),    lfDef.lfOrientation);
    FontStruct.lfWeight=         (LONG)RegGetInt( hKey, TEXT("lfWeight"),         lfDef.lfWeight);
    FontStruct.lfItalic=         (BYTE)RegGetInt( hKey, TEXT("lfItalic"),         lfDef.lfItalic);
    FontStruct.lfUnderline=      (BYTE)RegGetInt( hKey, TEXT("lfUnderline"),      lfDef.lfUnderline);
    FontStruct.lfStrikeOut=      (BYTE)RegGetInt( hKey, TEXT("lfStrikeOut"),      lfDef.lfStrikeOut);

    //
    // We have to preserve lfCharSet because some fonts (symbol, marlett) don't handle 
    // 0 (ANSI_CHARSET) or 1 (DEFAULT_CHARSET), and the font mapper will map to a 
    // different facename.  Later we will see if the CreateFont has the same FaceName
    // and get a more appropriate lfCharSet if need be.
    //

    FontStruct.lfCharSet=        (BYTE)RegGetInt( hKey, TEXT("lfCharSet"),        lfDef.lfCharSet);
    
    FontStruct.lfOutPrecision=   (BYTE)RegGetInt( hKey, TEXT("lfOutPrecision"),   lfDef.lfOutPrecision);
    FontStruct.lfClipPrecision=  (BYTE)RegGetInt( hKey, TEXT("lfClipPrecision"),  lfDef.lfClipPrecision);
    FontStruct.lfQuality=        (BYTE)RegGetInt( hKey, TEXT("lfQuality"),        lfDef.lfQuality);
    FontStruct.lfPitchAndFamily= (BYTE)RegGetInt( hKey, TEXT("lfPitchAndFamily"), lfDef.lfPitchAndFamily);

    //
    // If there is no FaceName in the registry, use the default "Lucida Console"
    // This will show off most of the glyphs except in the FE locales.
    // For FE, we can't font link fonts with the glyphs because they would have to have
    // the exact width as lucida console, or the console/csrss will AV (July 9, 1999)
    //

    RegGetString( hKey, TEXT("lfFaceName"), TEXT("Lucida Console"), FontStruct.lfFaceName, LF_FACESIZE);

    iPointSize= RegGetInt( hKey, TEXT("iPointSize"), 100);
    fWrap=      RegGetInt( hKey, TEXT("fWrap"),      0);
    fStatus=    RegGetInt( hKey, TEXT("StatusBar"),  0);
    fSaveWindowPositions= RegGetInt( hKey, TEXT("fSaveWindowPositions"), 0 );

    // if page settings not in registry, we will use defaults

    RegGetString( hKey, TEXT("szHeader"),  chPageText[HEADER], chPageText[HEADER], PT_LEN );
    RegGetString( hKey, TEXT("szTrailer"), chPageText[FOOTER], chPageText[FOOTER], PT_LEN );

    g_PageSetupDlg.rtMargin.top=    (LONG)RegGetInt( hKey, TEXT("iMarginTop"),    g_PageSetupDlg.rtMargin.top );
    g_PageSetupDlg.rtMargin.bottom= (LONG)RegGetInt( hKey, TEXT("iMarginBottom"), g_PageSetupDlg.rtMargin.bottom );
    g_PageSetupDlg.rtMargin.left=   (LONG)RegGetInt( hKey, TEXT("iMarginLeft"),   g_PageSetupDlg.rtMargin.left );
    g_PageSetupDlg.rtMargin.right=  (LONG)RegGetInt( hKey, TEXT("iMarginRight"),  g_PageSetupDlg.rtMargin.right );

    // if window positions in registry use them, otherwise us defaults

    g_WPtop=  RegGetInt( hKey, TEXT("iWindowPosY"),  CW_USEDEFAULT );
    g_WPleft= RegGetInt( hKey, TEXT("iWindowPosX"),  CW_USEDEFAULT );
    g_WPDX=   RegGetInt( hKey, TEXT("iWindowPosDX"), CW_USEDEFAULT );
    g_WPDY=   RegGetInt( hKey, TEXT("iWindowPosDY"), CW_USEDEFAULT );
    

    fMLE_is_broken= RegGetInt( hKey, TEXT("fMLE_is_broken"), FALSE );  // assume edit control works

    if( hKey )
    {
        RegCloseKey( hKey );
    }

}

/*
 * lstrncmpi( str1, str2, len )
 * compares two strings, str1 and str2, up
 * to length 'len' ignoring case.  If they
 * are equal, we will return 0.  Otherwise not 0.
 */

static
INT lstrncmpi( PTCHAR sz1, PTCHAR sz2 )
{
    TCHAR ch1, ch2;
    while( *sz1 )
    {
        ch1= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz1++ );
        ch2= (TCHAR) (INT_PTR) CharUpper( (LPTSTR) (INT_PTR) *sz2++ );
        if( ch1 != ch2 )
            return 1;
    }
    return 0;                // they are equal
}

static int NPRegister (HANDLE hInstance);

/* GetFileName
 *
 * Parse off filename from command line and put
 * into lpFileName
 */

LPTSTR GetFileName( LPTSTR lpFileName, LPTSTR lpCmdLine )
{
   LPTSTR lpTemp = lpFileName;
   HANDLE hFindFile;
   WIN32_FIND_DATA info;

   /*
   ** Allow for filenames surrounded by double and single quotes
   ** like in longfilenames.
   */
   if( *lpCmdLine == TEXT('\"') || *lpCmdLine == TEXT('\'') )
   {
      TCHAR chMatch = *lpCmdLine;
      DWORD dwSize=0;

      // Copy over filename
      while( *(++lpCmdLine) && (*lpCmdLine != chMatch) && (dwSize<MAX_PATH) )
      {
         *lpTemp++ = *lpCmdLine;
         dwSize++;
      }

      // NULL terminate the filename (no embedded quotes allowed in filenames)
      *lpTemp = TEXT('\0');
   }
   else
   {
      lstrcpyn(lpFileName, lpCmdLine,MAX_PATH);
   }

   /*
   ** Check to see if the unaltered filename exists.  If it does then don't
   ** append a default extension.
   */
   hFindFile= FindFirstFile( lpFileName, &info );

   if( hFindFile != INVALID_HANDLE_VALUE )
   {
      FindClose( hFindFile );
   }
   else
   {
      /*
      ** Add default extension and try again
      */
      AddExt( lpFileName );

      hFindFile= FindFirstFile( lpFileName, &info );

      if( hFindFile != INVALID_HANDLE_VALUE )
      {
         FindClose( hFindFile );
      }
   }

   // return the pointer to the end of the filename.
   return lpCmdLine;
}

/* SizeStrings - Get the total size of the resource strings   */
/* returns size in 'chars' or zero if failure                 */
/* we do this in case the international people really change  */
/* the size of resources.                                     */

/* Read all the strings into a buffer to size them.  Since we  */
/* don't know the maximum size of string resource, we may have */
/* to change the size of the read buffer.  This is done with   */
/* a simple doubling algorithm.                                */

INT SizeStrings(HANDLE hInstance)
{
    INT    iElementSize=280;  // current max size of string
    INT    total;             // total size of resources
    PTCHAR Buf;               // buffer to try putting resources into
    INT    ids;               // identifier number for resource
    INT    len;               // length of one resource

    while( 1 )   // keep looping til all strings can be read
    {
        if( !(Buf= LocalAlloc( LPTR, ByteCountOf(iElementSize) ) ) )
            return 0;    // failure
        for( ids=0, total=0; ids < CSTRINGS; ids++ )
        {
            len= LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), Buf, iElementSize );

            if( len >= iElementSize-1 )
            {
                #if DBG
                    ODS(TEXT("notepad: resource string too long!\n"));
                #endif
                break;
            }
            total += len+1;  // account for null terminator
        }
        LocalFree( Buf );
        if( ids >= CSTRINGS )
            break;
        iElementSize= iElementSize*2;
    }
    return( total );
}


/* InitStrings - Get all text strings from resource file */
BOOL InitStrings (HANDLE hInstance)
{
    TCHAR*   pch;
    INT      cchRemaining;
    INT      ids, cch;

    // allocate memory and lock it down forever.  we have pointers into it.
    // the localrealloc() function will not work well for freeing
    // unused memory because it may (and did) move memory.

    cchRemaining= SizeStrings( hInstance );
    if( !cchRemaining )
        return( FALSE );       // fail because we are out of memory

    pch= LocalAlloc( LPTR, ByteCountOf(cchRemaining) );
    if( !pch )
        return( FALSE );

    cchRemaining= (INT)LocalSize( pch ) / sizeof(TCHAR);
    if( cchRemaining == 0 )    // can't alloc memory - failure
        return( FALSE );

    for( ids = 0; ids < CSTRINGS; ids++ )
    {
       cch= 1 + LoadString( hInstance, (UINT) (UINT_PTR) (*rgsz[ids]), pch, cchRemaining );
       *rgsz[ids]= pch;
       pch += cch;

       if( cch > cchRemaining )   // should never happen
       {
           MessageBox( NULL, TEXT("Out of RC string space!!"),
                      TEXT("DEV Error!"), MB_OK);
           return( FALSE );
       }

       cchRemaining -= cch;
    }

    /* Get header and footer strings */

    lstrcpyn( chPageText[HEADER], szHeader, PT_LEN ); 
    lstrcpyn( chPageText[FOOTER], szFooter, PT_LEN ); 

    chMerge= *szMerge;
    return (TRUE);
}

/*
 * SkipBlanks( pszText )
 * skips blanks or tabs to either next character or EOL
 * returns pointer to same.
 */
PTCHAR SkipBlanks( PTCHAR pszText )
{
    while( *pszText == TEXT(' ') || *pszText == TEXT('\t') )
        pszText++;

    return pszText;
}


// if /.SETUP option exists in the command line process it.
BOOL ProcessSetupOption (LPTSTR lpszCmdLine)
{
    INT iSta= 0;
    /* Search for /.SETUP in the command line */
    if( !lstrncmpi( TEXT("/.SETUP"), lpszCmdLine ) )
    {
        fRunBySetup = TRUE;
        /* Save system menu handle for INITMENUPOPUP message */
        hSysMenuSetup =GetSystemMenu(hwndNP, FALSE);
        /* Allow exit on ^C, ^D and ^Z                      */
        /* Note that LoadAccelerators must be called before */
        /* TranslateAccelerator is called, true here        */
        hAccel = LoadAccelerators(hInstanceNP, TEXT("SlipUpAcc"));
        lpszCmdLine += 7;
    }
    else
        return FALSE;

    /* Don't offer a minimize button */
    SetWindowLong( hwndNP, GWL_STYLE,
                   WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                   WS_THICKFRAME |                  WS_MAXIMIZEBOX |
                   WS_VSCROLL    | WS_HSCROLL);

    /* skip blanks again to get to filename */
    lpszCmdLine= SkipBlanks( lpszCmdLine );

    if (*lpszCmdLine)
    {
        /* Get the filename. */
        GetFileName(szFileName, lpszCmdLine);

        fp= CreateFile( szFileName,             // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE, // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  //file attributes
                        NULL);                  // hnd of file attrs

        if( fp == INVALID_HANDLE_VALUE )
        {
           DWORD dwErr;

           // Check GetLastError to see why we failed
           dwErr = GetLastError ();
           switch (dwErr)
           {
              case ERROR_ACCESS_DENIED:
                 iSta= AlertBox( hwndNP, szNN, szACCESSDENY, szFileName,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;

              case ERROR_FILE_NOT_FOUND:
                 iSta= AlertBox(hwndNP, szNN, szFNF, szFileName,
                      MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONEXCLAMATION);
                 if( iSta == IDYES )
                 {
                    fp= CreateFile( szFileName,            // filename
                                    GENERIC_READ|GENERIC_WRITE,  // access
                                    FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                    NULL,                  // security descrp
                                    OPEN_ALWAYS,           // how to create
                                    FILE_ATTRIBUTE_NORMAL, // file attributes
                                    NULL);                 // hnd of file attrs
                 }
                 break;

              case ERROR_INVALID_NAME:
                 iSta= AlertBox( hwndNP, szNN, szNVF, szFileName,
                           MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;

              default:
                 iSta= AlertBox(hwndNP, szNN, szDiskError, szFileName,
                          MB_APPLMODAL | MB_OKCANCEL | MB_ICONEXCLAMATION);
                 break;
           }
        }

        if (fp == INVALID_HANDLE_VALUE)
           return (FALSE);
        LoadFile(szFileName, fInitFileType );    // load setup file
    }

    if( iSta == IDCANCEL )
       return( IDCANCEL );
    else
       return( IDYES );
}

/*
 * ProcessShellOptions(lpszCmdLine)
 *
 * If the command line has any options specified by the shell
 * process them.
 * Currently /P <filename> - prints the given file
 *           /PT "filename" "printer name" "Driver dll" "port"
 */
BOOL ProcessShellOptions (LPTSTR lpszCmdLine, int cmdShow)
{
    BOOL   bDefPrinter = TRUE;
    LPTSTR lpszAfterFileName;


    // Is it PrintTo ?
    if( lstrncmpi( TEXT("/PT"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+3 );
        bDefPrinter = FALSE;
    }
    // Or is it Print ?
    else if ( lstrncmpi( TEXT("/P"), lpszCmdLine ) == 0)
    {
        lpszCmdLine= SkipBlanks( lpszCmdLine+2 );
    }
    else
        return FALSE;

    if (!*lpszCmdLine)
       return FALSE;

    /* Added as per Bug #10923 declaring that the window should show up
     * and then the printing should begin.   29 July 1991  Clark Cyr
     */

    ShowWindow(hwndNP, cmdShow);

    /* Get the filename; have the pointer to the end of the filename */
    lpszAfterFileName= GetFileName (szFileName, lpszCmdLine) + 1;

    if (!bDefPrinter)
    {
        UINT index;
 
        /* extract the printer name from the command line. */
        if (!*lpszAfterFileName)
            return FALSE;

        lpszAfterFileName = SkipBlanks( lpszAfterFileName );

        /* (since we are passing multiple arguments here, the filename, */
        /* the printername have to be in quotes. */
        if( *lpszAfterFileName != TEXT('\"') )
            return FALSE;

        // Copy over printername
        lpszAfterFileName++;            // skip over quote 
        index= 0;
        while( *(lpszAfterFileName)              && 
               *lpszAfterFileName != TEXT('\"' ) &&
               (index+1 < sizeof(szPrinterName)/sizeof(szPrinterName[0]) ) )
        {
            szPrinterName[index++] = *lpszAfterFileName++;
        }

        // NULL terminate the printername (no embedded quotes allowed in printernames)
        szPrinterName[index] = TEXT('\0');
    }


    fp= CreateFile( szFileName,             // filename
                    GENERIC_READ,           // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                    NULL,                   // security descriptor
                    OPEN_EXISTING,          // how to create
                    FILE_ATTRIBUTE_NORMAL,  // file attributes
                    NULL);                  // hnd of file attrs to copy

    if( fp == INVALID_HANDLE_VALUE )
    {
       TCHAR* pszMsg;

       // select reasonable error message based on GetLastError

       switch( GetLastError() )
       {
          case ERROR_ACCESS_DENIED:
          case ERROR_NETWORK_ACCESS_DENIED:
              pszMsg= szACCESSDENY;
              break;

          case ERROR_FILE_NOT_FOUND:
              pszMsg= szFNF;
              break;

          case ERROR_INVALID_NAME:
              pszMsg= szNVF;
              break;

          default:
              pszMsg= szDiskError;
              break;
       }

       AlertBox(hwndNP, szNN, pszMsg, szFileName,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       return (TRUE);
    }

    /* load the file into the edit control */
    LoadFile( szFileName, fInitFileType );         // get print file


    /* print the file */

    if (bDefPrinter)
    {
        PrintIt( DoNotUseDialog );
    }
    else
    {
        PrintIt( NoDialogNonDefault );
    }


    return (TRUE);
}

/* CreateFilter
 *
 * Creates filters for GetOpenFileName.
 *
 */

VOID CreateFilter(PTCHAR szFilterSpec )
{
    PTCHAR pszFilterSpec;

    /* construct default filter string in the required format for
     * the new FileOpen and FileSaveAs dialogs
     * if you add to this, make sure CCHFILTERMAX is large enough.
     */

    // .txt first for compatibility
    pszFilterSpec= szFilterSpec;
    lstrcpy( pszFilterSpec, szAnsiText );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy( pszFilterSpec, TEXT("*.txt"));
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    // and last, all files
    lstrcpy( pszFilterSpec, szAllFiles );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.*") );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    *pszFilterSpec = TEXT('\0');

}

// EnumProc
//
// Callback function for EnumFonts
//
// Purpose: sets lfCharSet in passed logfont to a valid lfCharSet
//          and terminates enumeration.
//

int CALLBACK EnumProc( 
    LOGFONT*     pLf,
    TEXTMETRIC*  pTm,
    DWORD        dwType,
    LPARAM       lpData )
{

    ((LOGFONT*) lpData)-> lfCharSet= pLf->lfCharSet;

    return( 0 );  // stop enumeration
}


/* One time initialization */
INT FAR NPInit (HANDLE hInstance, HANDLE hPrevInstance,
                LPTSTR lpCmdLine, INT cmdShow)
{
    HDC    hDisplayDC;     /* screen DC                */
    RECT   rcT1;           /* for sizing edit window   */
    RECT   rcStatus;       /* rect for the status window */
    INT    iSta;
    WINDOWPLACEMENT wp;    /* structure to place window at the correct position */
    INT    iParts[2];
    HMENU  hMenu;          // handle to the menu.


    /* determine the message number to be used for communication with
     * Find dialog
     */
    if (!(wFRMsg = RegisterWindowMessage ((LPTSTR)FINDMSGSTRING)))
         return FALSE;
    if (!(wHlpMsg = RegisterWindowMessage ((LPTSTR)HELPMSGSTRING)))
         return FALSE;

    /* open a global DC to the display */

    hDisplayDC= GetDC(NULL);
    if( !hDisplayDC )
        return FALSE;

    /* Go load strings */
    if (!InitStrings (hInstance))
        return FALSE;

    InitLocale();     // localize strings etc.

    /* Load the arrow and hourglass cursors. */
    hStdCursor= LoadCursor( NULL,
           (LPTSTR) (INT_PTR) (GetSystemMetrics(SM_PENWINDOWS) ? IDC_ARROW : IDC_IBEAM ));
    hWaitCursor= LoadCursor( NULL, IDC_WAIT );

    /* Load accelerators. */
    hAccel= LoadAccelerators(hInstance, TEXT("MainAcc"));
    if( !hWaitCursor || !hAccel )
        return FALSE;

    if( !hPrevInstance )
    {
       if( !NPRegister( hInstance ) )
          return (FALSE);
    }

    hInstanceNP= hInstance;

    /* init. fields of PRINTDLG struct.. */
    /* Inserted here since command line print statements are valid. */
    g_PageSetupDlg.lStructSize   = sizeof(PAGESETUPDLG);
    g_PageSetupDlg.hDevMode      = NULL;
    g_PageSetupDlg.hDevNames     = NULL;
    g_PageSetupDlg.hInstance     = hInstance;
    SetPageSetupDefaults();

    //
    // Pick up information saved in registry
    //

    GetGlobals();


    hwndNP= CreateWindow(  szNotepad, 
                           TEXT(""),
                           WS_OVERLAPPED | WS_CAPTION     | WS_SYSMENU     |
                           WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | 0,
                           g_WPleft,     // x
                           g_WPtop,      // y
                           g_WPDX,       // width
                           g_WPDY,       // height
                           (HWND)NULL,   // parent or owner
                           (HMENU)NULL,  // menu or child window
                           hInstance,    // application instance
                           NULL);        // window creation data

    g_PageSetupDlg.hwndOwner     = hwndNP;

    if( !hwndNP )
        return FALSE;
   
    // On multimon machines, the previous position stored of notepad may
    // not be in the display area. call SetWindowPlacement to fix this.

    // If the information specified in WINDOWPLACEMENT would result in a window 
    // that is completely off the screen, the system will automatically adjust 
    // the coordinates so that the window is visible, taking into account 
    // changes in screen resolution and multiple monitor configuration. 

    // g_WPDX and g_WPDY are CW_USEDEFAULT when notepad is started for the
    // first time on the user machine.
    if (g_WPDX != CW_USEDEFAULT && g_WPDY != CW_USEDEFAULT)
    {
        memset(&wp, 0, sizeof(wp));
        wp.length = sizeof(wp);        
        wp.rcNormalPosition.left = g_WPleft;
        wp.rcNormalPosition.right = g_WPleft + g_WPDX;
        wp.rcNormalPosition.top = g_WPtop;
        wp.rcNormalPosition.bottom = g_WPtop + g_WPDY;

        // don't check the return value; if this call fails for any reason,
        // just go on with the position of the notepad in the above CreateWindow() call.
        SetWindowPlacement(hwndNP, &wp);
    }

    /* File Drag Drop support added 03/26/91 - prototype only. w-dougw   */
    /* All processing of drag/drop files is done the under WM_DROPFILES  */
    /* message.                                                          */
    DragAcceptFiles( hwndNP,TRUE ); /* Process dragged and dropped files. */

    GetClientRect( hwndNP, (LPRECT) &rcT1 );

    if (!(hwndEdit = CreateWindowEx(WS_EX_CLIENTEDGE,
                     TEXT("Edit"), TEXT(""),
                     (fWrap) ? ES_STD : (ES_STD | WS_HSCROLL),
                     0, 0, rcT1.right, rcT1.bottom - 100,
                     hwndNP, (HMENU)ID_EDIT, hInstance, (LPVOID)NULL)))
        return FALSE;


    // create a status window.
    hwndStatus = CreateStatusWindow ((fStatus?WS_VISIBLE:0)|WS_BORDER|WS_CHILD|WS_CLIPSIBLINGS, TEXT(""), hwndNP, ID_STATUS_WINDOW);
    if ( !hwndStatus )
        return FALSE;
    UpdateStatusBar( TRUE );

    GetClientRect( hwndStatus, (LPRECT) &rcStatus );

    // determine height of statusbar window and save...
    dyStatus = rcStatus.bottom - rcStatus.top;

    iParts[0] = 3 * (rcStatus.right-rcStatus.left)/4;
    iParts[1] = -1;

    // Divide the status window into two parts
    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts[0]); 
 

    // handle word wrap now if set in registry

    SendMessage( hwndEdit, EM_FMTLINES, fWrap, 0L );  // tell MLE

	// if wordwrap, disable the statusbar
    if (fWrap)
    {
        hMenu = GetMenu(hwndNP);
        EnableMenuItem(GetSubMenu(hMenu, 3), M_STATUSBAR, MF_GRAYED);
    }

    FontStruct.lfHeight= -MulDiv(iPointSize,
                                 GetDeviceCaps(hDisplayDC,LOGPIXELSY),
                                 720);
    hFont= CreateFontIndirect( &FontStruct );

    //
    // Make sure the font mapper gives us the same face name.
    //
    // If the locale changes, a font that use to work just fine gets mapped to
    // a different facename because of support for the charset does not exist
    // in the new locale.
    //
    // In this case, we will find one lfCharSet that does exist for this FaceName
    // and use that for the CreateFontIndirect.
    //

    {
        HFONT hPrev;
        TCHAR szTextFace[LF_FACESIZE];

        // Get the facename that was really used.

        hPrev= SelectObject( hDisplayDC, hFont );
        GetTextFace( hDisplayDC, sizeof(szTextFace)/sizeof(TCHAR), (LPTSTR) &szTextFace[0] );
        SelectObject( hDisplayDC, hPrev );

        // if not the same, get a lfCharSet that does exist in this font

        if( lstrcmpi( szTextFace, FontStruct.lfFaceName ) != 0 )
        {
            EnumFonts( hDisplayDC, FontStruct.lfFaceName, (FONTENUMPROC) EnumProc, (LPARAM) &FontStruct );
            DeleteObject( hFont );   

            hFont= CreateFontIndirect( &FontStruct );
        }
    }

    SendMessage (hwndEdit, WM_SETFONT, (WPARAM) hFont, MAKELPARAM(FALSE, 0));
    ReleaseDC( NULL, hDisplayDC );

    /* we will not verify that a unicode font is available until
    ** we actually need it.  Perhaps we'll get lucky, and only deal
    ** with ascii files.
    */

    szSearch[0] = (TCHAR) 0;
    /*
     * Win32s does not allow local memory handles to be passed to Win3.1.
     * So, hEdit is used for transferring text to and from the edit control.
     * Before reading text into it, it must be reallocated to a proper size.
     */
    hEdit = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, ByteCountOf(1));

    /* limit text for safety's sake. */
    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    /* get visible window on desktop; helps taskman  find it */
    SetTitle( szUntitled );
    ShowWindow( hwndNP, cmdShow );
    SetCursor( hStdCursor );

    /* Scan for initial /A or /W to override automatic file typing for
     * 'notepad /p file' or 'notepad file'
     */
    lpCmdLine= SkipBlanks( lpCmdLine );
    fInitFileType= FT_UNKNOWN;
    if( !lstrncmpi( TEXT("/A"), lpCmdLine ) )
        fInitFileType= FT_ANSI;
    else if( !lstrncmpi( TEXT("/W"), lpCmdLine ) )
        fInitFileType= FT_UNICODE;

    if( fInitFileType != FT_UNKNOWN )    // skip over option
        lpCmdLine= SkipBlanks( lpCmdLine+2 );

    /* check for /.SETUP option first.
       if /.SETUP absent, check for SHELL options /P
       Whenever a SHELL option is processed, post a WM_CLOSE msg.
       */
    if( iSta= ProcessSetupOption( lpCmdLine ) )
    {
        if( iSta == IDCANCEL )
        {
            return( FALSE );
        }
    }
    else if( ProcessShellOptions( lpCmdLine, cmdShow ) )
    {
        PostMessage( hwndNP, WM_CLOSE, 0, 0L );
        return TRUE;
    }
    else if( *lpCmdLine )
    {
        /* Get the filename. */
        GetFileName( szFileName, lpCmdLine );
        fp= CreateFile( szFileName,             // filename
                        GENERIC_READ,           // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                        NULL,                   // security descriptor
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL);                  // hnd of file attrs to copy

        if( fp == INVALID_HANDLE_VALUE )
        {
           // If the file can't be opened, maybe the user wants a new
           // one created.

           if( GetLastError() == ERROR_FILE_NOT_FOUND )
           {
              INT iSta;

              iSta= AlertBox( hwndNP, szNN, szFNF, szFileName,
                     MB_APPLMODAL | MB_YESNOCANCEL | MB_ICONEXCLAMATION);
              if( iSta == IDCANCEL )
              {
                  return( FALSE );
              }

              if( iSta == IDYES )
              {
                 fp= CreateFile( szFileName,            // filename
                                 GENERIC_READ|GENERIC_WRITE,  // access
                                 FILE_SHARE_READ|FILE_SHARE_WRITE, // share
                                 NULL,                  // security descrp
                                 OPEN_ALWAYS,           // how to create
                                 FILE_ATTRIBUTE_NORMAL, // file attributes
                                 NULL);                 // hnd of file attrs
              }

           }
           else
           {
               AlertUser_FileFail(szFileName);
               // now open an untitled file instead of the file that we failed
               // to read.
               SetTitle( szUntitled );
               lstrcpy(szFileName, szUntitled);
           }
        }

        if( fp != INVALID_HANDLE_VALUE )
        {
           LoadFile( szFileName, fInitFileType );   // get file specified on command line
        }
    }

    CreateFilter( szOpenFilterSpec );
    CreateFilter( szSaveFilterSpec );

    /* init. some fields of the OPENFILENAME struct used by fileopen and
     * filesaveas, but NEVER changed.
     */
    memset( &OFN, 0, sizeof(OFN) );
    OFN.lStructSize       = sizeof(OPENFILENAME);
    OFN.hwndOwner         = hwndNP;
    OFN.nMaxFile          = MAX_PATH;
    OFN.hInstance         = hInstance;

    /* init.fields of the FINDREPLACE struct used by FindText() */
    memset( &FR, 0, sizeof(FR) );
    FR.lStructSize        = sizeof(FINDREPLACE);       /* Don't hard code it */
    FR.hwndOwner          = hwndNP;


    /* Force a scroll to current selection (which could be at eof if
       we loaded a log file.) */
    {
       DWORD  dwStart, dwEnd;

       SendMessage( hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd );
       SendMessage( hwndEdit, EM_SETSEL, dwStart, dwEnd );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }



    if (PRIMARYLANGID(LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0))) == LANG_JAPANESE) {
        /*
         * If current HKL is Japanese, handle the result string at once.
         */
        SendMessage(hwndEdit, EM_SETIMESTATUS,
                                EMSIS_COMPOSITIONSTRING, EIMES_GETCOMPSTRATONCE);
    }

     return TRUE;
}

/* ** Notepad class registration proc */
BOOL NPRegister (HANDLE hInstance)
{
    WNDCLASSEX   NPClass;
    PWNDCLASSEX  pNPClass = &NPClass;

/* Bug 12191: If Pen Windows is running, make the background cursor an
 * arrow instead of the edit control ibeam.  This way the user will know
 * where they can use the pen for writing vs. what will be considered a
 * mouse action.   18 October 1991       Clark Cyr
 */
    pNPClass->cbSize        = sizeof(NPClass);
    pNPClass->hCursor       = LoadCursor(NULL, GetSystemMetrics(SM_PENWINDOWS)
                                               ? IDC_ARROW : IDC_IBEAM);
    pNPClass->hIcon         = LoadIcon(hInstance,
                                      (LPTSTR) MAKEINTRESOURCE(ID_ICON));

    pNPClass->hIconSm       = LoadImage(hInstance,
                                        MAKEINTRESOURCE(ID_ICON),
                                        IMAGE_ICON, 16, 16,
                                        LR_DEFAULTCOLOR);
    pNPClass->lpszMenuName  = (LPTSTR) MAKEINTRESOURCE(ID_MENUBAR);
    pNPClass->hInstance     = hInstance;
    pNPClass->lpszClassName = szNotepad;
    pNPClass->lpfnWndProc   = NPWndProc;
    pNPClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    pNPClass->style         = 0; // was CS_BYTEALIGNCLIENT (obsolete)
    pNPClass->cbClsExtra    = 0;
    pNPClass->cbWndExtra    = 0;

    if (!RegisterClassEx((LPWNDCLASSEX)pNPClass))
        return (FALSE);

    return (TRUE);
}


/* Get Locale info from the Registry, and initialize global vars  */

void FAR InitLocale (void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\notepad.c ===
/*
 *   Notepad application
 *   Copyright (C) 1984-2001 Microsoft Inc.
 */


#include "precomp.h"
#include <htmlhelp.h>

#define DeepTrouble() MessageBox(hwndNP, szErrSpace, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);

UINT     lGotoLine;                  /* line number to goto to */

TCHAR    chMerge;
HWND     hwndNP = 0;                 /* handle to notepad parent window   */
HWND     hwndStatus = 0;             /* handle to notepad status window   */
HWND     hwndEdit = 0;               /* handle to main text control item  */
HANDLE   hEdit;                      /* Handle to storage for edit item   */
HWND     hDlgFind = NULL;            /* handle to modeless FindText window */
HANDLE   hStdCursor;                 /* handle to arrow or beam cursor    */
HANDLE   hWaitCursor;                /* handle to hour glass cursor       */
HANDLE   hInstanceNP;                /* Module instance handle            */
HANDLE   hFont;                      /* handle to Unicode font            */
LOGFONT  FontStruct;                 /* font dialog structure             */
INT      iPointSize=120;             /* current point size unit=1/10 pts  */
TCHAR    szFileName[MAX_PATH];       /* Current notepad filename          */
TCHAR    szSearch[CCHKEYMAX];        /* Search string                     */
TCHAR    szReplace[CCHKEYMAX];       /* replace string                    */

BOOL     fUntitled = TRUE;           /* TRUE iff notepad has no title                  */
BOOL     fStatus = FALSE;            /* status bar shown?                              */
BOOL     fLastStatus = FALSE;        /* status bar status when wordwrap was turned off */
INT      dyStatus;                   /* height of status bar                           */


HMENU    hSysMenuSetup;              /* Save Away for disabled Minimize   */

DWORD    dwEmSetHandle = 0;          /* Is EM_SETHANDLE in process?       */
HANDLE   hAccel;                     /* Handle to accelerator table       */
BOOL     fRunBySetup = FALSE;        /* Did SlipUp WinExec us??           */
BOOL     fWrap = 0;                  /* Flag for word wrap                */
TCHAR    szNotepad[] = TEXT("Notepad");/* Name of notepad window class    */

BOOL     fInSaveAsDlg = FALSE;

// Edit control used to AV is EM_FMTLINES was turned off when cursor was near the end
// To get around this, notepad moved to cursor to 0,0 when it turned off wordwrap.
// Users were not happy, so we will put up with possible AVs.  Note: as of June 27, 2001
// we could not repro the AV behavior, so perhaps it is not there anymore.

BOOL     fMLE_is_broken= FALSE;     

/* variables for the new File/Open, File/Saveas,Find Text and Print dialogs */
OPENFILENAME OFN;                     /* passed to the File Open/save APIs */
TCHAR szOpenFilterSpec[CCHFILTERMAX]; /* default open filter spec          */
TCHAR szSaveFilterSpec[CCHFILTERMAX]; /* default save filter spec          */
NP_FILETYPE g_ftOpenedAs=FT_UNKNOWN;  /* current file was opened           */
NP_FILETYPE g_ftSaveAs;               /* current file was opened           */

FINDREPLACE FR;                       /* Passed to FindText()              */
PAGESETUPDLG g_PageSetupDlg;
UINT wFRMsg;                          /* message used in communicating     */
                                      /* with Find/Replace dialog          */

DWORD dwCurrentSelectionStart = 0L;   /* WM_ACTIVATEAPP selection pos      */
DWORD dwCurrentSelectionEnd   = 0L;   /* WM_ACTIVATEAPP selection pos      */
UINT wHlpMsg;                         /* message used in invoking help     */

/* Strings loaded from resource file passed to LoadString at initialization time */
/* To add resource string:
 * 1) create IDS_ macro definition in notepad.h
 * 2) create string in resource file
 * 3) create 'TCHAR*' variable directly below and in notepad.h file
 * 4) add &variable to rgsz
 * 5) increment CSTRINGS
 */
TCHAR *szDiskError =(TCHAR *)IDS_DISKERROR;  /* Can't open File, check disk  */
TCHAR *szFNF       =(TCHAR *)IDS_FNF;        /* File not found               */
TCHAR *szSCBC      =(TCHAR *)IDS_SCBC;       /* Save changes before closing? */
TCHAR *szUntitled  =(TCHAR *)IDS_UNTITLED;   /* Untitled                     */
TCHAR *szNpTitle   =(TCHAR *)IDS_NOTEPAD;    /* Notepad -                    */
TCHAR *szCFS       =(TCHAR *)IDS_CFS;        /* Can't find string            */
TCHAR *szErrSpace  =(TCHAR *)IDS_ERRSPACE;   /* Memory space exhausted       */
TCHAR *szFTL       =(TCHAR *)IDS_FTL;        /* File too large for notepad   */
TCHAR *szNN        =(TCHAR *)IDS_NN;         /* Notepad name                 */

TCHAR *szCommDlgInitErr = (TCHAR*)IDS_COMMDLGINIT; /* common dialog error %x */
TCHAR *szPDIE      =(TCHAR*) IDS_PRINTDLGINIT; /* Print dialog init error    */
TCHAR *szCP        =(TCHAR*) IDS_CANTPRINT;  /* Can't print                  */
TCHAR *szNVF       =(TCHAR*) IDS_NVF;        /* Not a valid filename.        */
TCHAR *szCREATEERR =(TCHAR*) IDS_CREATEERR;  /* cannot create file           */
TCHAR *szNoWW      =(TCHAR*) IDS_NOWW;       /* Too much text to word wrap   */
TCHAR *szMerge     =(TCHAR*) IDS_MERGE1;     /* search string for merge      */
TCHAR *szHelpFile  =(TCHAR*) IDS_HELPFILE;   /* Name of helpfile.            */
TCHAR *szHeader    =(TCHAR*) IDS_HEADER;
TCHAR *szFooter    =(TCHAR*) IDS_FOOTER;
TCHAR *szLetters   =(TCHAR*) IDS_LETTERS;    /* formatting letters in pagesetup */

TCHAR *szAnsiText    = (TCHAR*)IDS_ANSITEXT; /* File/Open ANSI filter spec. string */
TCHAR *szAllFiles    = (TCHAR*)IDS_ALLFILES;   /* File/Open Filter spec. string */
TCHAR *szOpenCaption = (TCHAR*)IDS_OPENCAPTION; /* caption for File/Open dlg */
TCHAR *szSaveCaption = (TCHAR*)IDS_SAVECAPTION; /* caption for File/Save dlg */
TCHAR *szCannotQuit  = (TCHAR*)IDS_CANNOTQUIT;  /* cannot quit during a WM_QUERYENDSESSION */
TCHAR *szLoadDrvFail = (TCHAR*)IDS_LOADDRVFAIL;  /* LOADDRVFAIL from PrintDlg */
TCHAR *szACCESSDENY  = (TCHAR*)IDS_ACCESSDENY; /* Access denied on Open */
TCHAR *szErrUnicode  = (TCHAR*)IDS_ERRUNICODE;  /* Unicode character existence error */
TCHAR *szFontTooBig  = (TCHAR*)IDS_FONTTOOBIG; /* font too big or page too small */

TCHAR *szCommDlgErr   = (TCHAR*) IDS_COMMDLGERR; /* common dialog error %x */
TCHAR *szLineError    = (TCHAR*) IDS_LINEERROR;   /* line number error        */
TCHAR *szLineTooLarge = (TCHAR*) IDS_LINETOOLARGE;/* line number out of range */
TCHAR *szFtAnsi       = (TCHAR*) IDS_FT_ANSI;
TCHAR *szFtUnicode    = (TCHAR*) IDS_FT_UNICODE;
TCHAR *szFtUnicodeBe  = (TCHAR*) IDS_FT_UNICODEBE;
TCHAR *szFtUtf8       = (TCHAR*) IDS_FT_UTF8;
TCHAR *szCurrentPage  = (TCHAR*) IDS_CURRENT_PAGE;

// strings for the status bar
TCHAR *szLineCol        = (TCHAR*) IDS_LINECOL;
TCHAR *szCompressedFile = (TCHAR*) IDS_COMPRESSED_FILE;  
TCHAR *szEncryptedFile  = (TCHAR*) IDS_ENCRYPTED_FILE;   
TCHAR *szHiddenFile     = (TCHAR*) IDS_HIDDEN_FILE;      
TCHAR *szOfflineFile    = (TCHAR*) IDS_OFFLINE_FILE;     
TCHAR *szReadOnlyFile   = (TCHAR*) IDS_READONLY_FILE;    
TCHAR *szSystemFile     = (TCHAR*) IDS_SYSTEM_FILE;      
TCHAR *szFile           = (TCHAR*) IDS_FILE;             


TCHAR **rgsz[CSTRINGS] = {
        &szDiskError,
        &szFNF,
        &szSCBC,
        &szUntitled,
        &szErrSpace,
        &szCFS,
        &szNpTitle,
        &szFTL,
        &szNN,
        &szCommDlgInitErr,
        &szPDIE,
        &szCP,
        &szNVF,
        &szCREATEERR,
        &szNoWW,
        &szMerge,
        &szHelpFile,
        &szAnsiText,
        &szAllFiles,
        &szOpenCaption,
        &szSaveCaption,
        &szCannotQuit,
        &szLoadDrvFail,
        &szACCESSDENY,
        &szErrUnicode,
        &szCommDlgErr,
        &szFontTooBig,
        &szLineError,
        &szLineTooLarge,
        &szFtAnsi,
        &szFtUnicode,
        &szFtUnicodeBe,
        &szFtUtf8,
        &szCurrentPage,
        &szHeader,
        &szFooter,
        &szLineCol,
        &szCompressedFile,
        &szEncryptedFile,
        &szHiddenFile,
        &szOfflineFile,
        &szReadOnlyFile,
        &szSystemFile,
        &szFile,
        &szLetters,
};


HANDLE   fp;          /* file pointer */


#if 0
VOID DisplayFont( LOGFONT* pf )
{
    TCHAR dbuf[100];

    ODS(TEXT("-----------------------\n"));
    wsprintf(dbuf,TEXT("lfHeight          %d\n"),pf->lfHeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"),pf->lfWidth ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"),pf->lfEscapement); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"),pf->lfOrientation); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"),pf->lfWeight); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"),pf->lfItalic); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderLine       %d\n"),pf->lfUnderline); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"),pf->lfStrikeOut); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"),pf->lfCharSet); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"),pf->lfOutPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecision   %d\n"),pf->lfClipPrecision); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"),pf->lfQuality); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"),pf->lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"),pf->lfFaceName); ODS(dbuf);

}
#endif

static TCHAR  szPath[MAX_PATH];

void FileDragOpen(void);
VOID NpResetMenu(HWND hWnd);
BOOL SignalCommDlgError(VOID);
VOID ReplaceSel( BOOL bView );

/* FreeGlobal, frees  all global memory allocated. */

void NEAR PASCAL FreeGlobal()
{
    if(g_PageSetupDlg.hDevMode)
    {
        GlobalFree(g_PageSetupDlg.hDevMode);
    }

    if(g_PageSetupDlg.hDevNames)
    {
        GlobalFree(g_PageSetupDlg.hDevNames);
    }

    g_PageSetupDlg.hDevMode=  NULL; // make sure they are zero for PrintDlg
    g_PageSetupDlg.hDevNames= NULL;
}

VOID PASCAL SetPageSetupDefaults( VOID )
{
    TCHAR szIMeasure[ 2 ];

    g_PageSetupDlg.lpfnPageSetupHook= PageSetupHookProc;
    g_PageSetupDlg.lpPageSetupTemplateName= MAKEINTRESOURCE(IDD_PAGESETUP);

    GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2 );

    g_PageSetupDlg.Flags= PSD_MARGINS  |
            PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGESETUPTEMPLATE;

    if (szIMeasure[ 0 ] == TEXT( '1' ))
    {
        //  English measure (in thousandths of inches).
        g_PageSetupDlg.Flags |= PSD_INTHOUSANDTHSOFINCHES;
        g_PageSetupDlg.rtMargin.top    = 1000;
        g_PageSetupDlg.rtMargin.bottom = 1000;
        g_PageSetupDlg.rtMargin.left   = 750;
        g_PageSetupDlg.rtMargin.right  = 750;
    }
    else
    {
        //  Metric measure (in hundreths of millimeters).
        g_PageSetupDlg.Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
        g_PageSetupDlg.rtMargin.top    = 2500;
        g_PageSetupDlg.rtMargin.bottom = 2500;
        g_PageSetupDlg.rtMargin.left   = 2000;
        g_PageSetupDlg.rtMargin.right  = 2000;
    }

}

/* Standard window size proc */
void NPSize (int cxNew, int cyNew)
{

    /* Invalidate the edit control window so that it is redrawn with the new
     * margins. Needed when comming up from iconic and when doing word wrap so
     * the new margins are accounted for.
     */

    InvalidateRect(hwndEdit, (LPRECT)NULL, TRUE);

    // the height of the edit window depends on whether the status bar is
    // displayed.
    MoveWindow (hwndEdit, 0, 0, cxNew, cyNew - (fStatus?dyStatus:0), TRUE);

}

// NpSaveDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while saving.
//

const DWORD s_SaveAsHelpIDs[]=
    {
        IDC_FILETYPE, IDH_FILETYPE,
        IDC_ENCODING, IDH_FILETYPE,
        0, 0
    };

UINT_PTR APIENTRY NpSaveDialogHookProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    INT id;
    POINT pt;
    TCHAR* szSelect;        // selected type

    switch( msg )
    {
        case WM_INITDIALOG:
            // Warning: the order here must be the same as NP_FILETYPE

            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtAnsi );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicode );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicodeBe );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUtf8 );

            szSelect= szFtAnsi;         // default
            g_ftSaveAs= g_ftOpenedAs;   // default: save as same type as opened
            switch( g_ftSaveAs )
            {
                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                case FT_UTF8:      szSelect= szFtUtf8;      break;
                default: break;
            }

            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );
            break;

        case WM_COMMAND:
            g_ftSaveAs= (NP_FILETYPE) SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_GETCURSEL, 0, 0 );
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;
    }
    return( FALSE );
}


// NpOpenDialogHookProc
//
// Common dialog hook procedure for handling
// the file type while opening.
//

UINT_PTR APIENTRY NpOpenDialogHookProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    INT id;
    POINT pt;
    TCHAR* szSelect;        // selected type
    static TCHAR  szPrevFileName[MAX_PATH] = TEXT(""); 

    switch( msg )
    {
        case WM_INITDIALOG:
            // Warning: the order here must be the same as NP_FILETYPE

            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtAnsi );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicode );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUnicodeBe );
            SendDlgItemMessage(hWnd, IDC_FILETYPE,CB_ADDSTRING, 0, (LPARAM) szFtUtf8 );

            szSelect= szFtAnsi;         // default
            switch( g_ftOpenedAs )
            {
                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                case FT_UTF8:      szSelect= szFtUtf8;      break;
                default: break;
            }

            // set the current filetype.
            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );
            break;

        case WM_COMMAND:
            g_ftOpenedAs= (NP_FILETYPE) SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_GETCURSEL, 0, 0 );
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle,
                      szHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {
                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);
            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if ( id != IDC_FILETYPE && id != IDC_ENCODING)
                break;

            WinHelp( (HWND)   wParam,
                              szHelpFile,
                              HELP_CONTEXTMENU,
                      (ULONG_PTR) s_SaveAsHelpIDs);
            return TRUE;

            
         case WM_NOTIFY:
         {
            LPOFNOTIFY pofn;
            TCHAR      szFileName[MAX_PATH]; 
            BYTE       szFileBuffer[BUFFER_TEST_SIZE];
            HANDLE     hFile;
            DWORD      dwBytesRead;
            
            // process the message when the file selection changes.
            pofn = (LPOFNOTIFY)lParam;
            switch (pofn->hdr.code)
            {
                case CDN_SELCHANGE:
                {                        
                    // get the filename.
                    if (CommDlg_OpenSave_GetFilePath(GetParent(hWnd), szFileName, sizeof(szFileName)/sizeof(TCHAR)) > 0)
                    {
                        // if same file as the previous file, don't do anything.
                        if (lstrcmpi(szFileName, szPrevFileName) == 0)
                            break;

                        // open the file.
                        hFile = CreateFile(szFileName,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (hFile != INVALID_HANDLE_VALUE)
                        {
                            // if the file read fails, just quit.
                            if ( (ReadFile(hFile, szFileBuffer, BUFFER_TEST_SIZE, &dwBytesRead, NULL) <= 0) || dwBytesRead == 0)
                            {
                                CloseHandle(hFile);
                                break;
                            }

                            // determine the file type based on dwBytesRead bytes of the file.
                            g_ftOpenedAs = fDetermineFileType(szFileBuffer, dwBytesRead);

                            // set the dropdown filetype to the filetype we think based on the initial part of the file.
                            szSelect = szFtAnsi;         // default
                            switch( g_ftOpenedAs )
                            {
                                case FT_UNICODE:   szSelect= szFtUnicode;   break;
                                case FT_UNICODEBE: szSelect= szFtUnicodeBe; break;
                                case FT_UTF8:      szSelect= szFtUtf8;      break;
                                default: break;
                            }

                            SendDlgItemMessage( hWnd, IDC_FILETYPE, CB_SELECTSTRING, (WPARAM) -1, (LPARAM)szSelect );            

                            // cleanup.
                            lstrcpy(szPrevFileName, szFileName);
                            CloseHandle(hFile);                           

                        }
                    }                                    

                    break;
                }
            }

         }
                    
    }
    return( FALSE );
}

// GotoAndScrollInView
//
// Put the cursor at the begining of a line, and scroll the
// editbox so the user can see it.
//
// If there is a failure, it just leaves the cursor where it is.
//

VOID GotoAndScrollInView( INT OneBasedLineNumber )
{
    UINT CharIndex;
    CharIndex= (UINT) SendMessage( hwndEdit,
                                   EM_LINEINDEX,
                                   OneBasedLineNumber-1,
                                   0 );
    if( CharIndex != (UINT) -1 )
    {
        SendMessage( hwndEdit, EM_SETSEL, CharIndex, CharIndex);
        SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
    }

}



/* ** Notepad command proc - called whenever notepad gets WM_COMMAND
      message.  wParam passed as cmd */
INT NPCommand(
    HWND     hwnd,
    WPARAM   wParam,
    LPARAM   lParam )
{
    HWND     hwndFocus;
    LONG     lSel;
    TCHAR    szNewName[MAX_PATH] = TEXT("");      /* New file name */
    FARPROC  lpfn;
    LONG     style;
    DWORD    rc;
    RECT     rcClient;

    switch (LOWORD(wParam))
    {
        case M_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case M_NEW:
            New(TRUE);
            break;

        case M_OPEN:
            if (CheckSave(FALSE))
            {
                NP_FILETYPE  g_ftOldOpenedAs = g_ftOpenedAs;

                /* set up the variable fields of the OPENFILENAME struct.
                 * (the constant fields have been set in NPInit()
                 */
                OFN.lpstrFile         = szNewName;
                lstrcpy(szNewName, TEXT("*.txt") ); /* set default selection */
                OFN.lpstrTitle        = szOpenCaption;

                /* ALL non-zero long pointers must be defined immediately
                 * before the call, as the DS might move otherwise.
                 * 12 February 1991    clarkc
                 */
                OFN.lpstrFilter       = szOpenFilterSpec;
                OFN.lpstrDefExt       = TEXT("txt");
                /* Added OFN_FILEMUSTEXIST to eliminate problems in LoadFile.
                 * 12 February 1991    clarkc
                 */
                OFN.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                                     OFN_EXPLORER         |
                                     OFN_ENABLESIZING     |
                                     OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

                OFN.nFilterIndex   = FILE_TEXT;
              
                // show encoding listbox
                OFN.lpTemplateName= TEXT("NpEncodingDialog");
                OFN.lpfnHook= NpOpenDialogHookProc;


                if( GetOpenFileName( (LPOPENFILENAME)&OFN ) )
                {
                   HANDLE oldfp= fp;                  

                   fp= CreateFile( szNewName,            // filename
                                   GENERIC_READ,         // access mode
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,                 // security descriptor
                                   OPEN_EXISTING,        // how to create
                                   FILE_ATTRIBUTE_NORMAL,// file attributes
                                   NULL);                // hnd to file attrs
                   /* Try to load the file and reset fp if failed */
                   if( !LoadFile( szNewName, g_ftOpenedAs ) )
                   {
                      fp= oldfp;
                      g_ftOpenedAs = g_ftOldOpenedAs;
                   }
                }
                else
                {
                    g_ftOpenedAs = g_ftOldOpenedAs;
                    SignalCommDlgError();
                }
            }
            break;

        case M_SAVE:
            /* set up the variable fields of the OPENFILENAME struct.
             * (the constant fields have been sel in NPInit()
             */
            g_ftSaveAs = g_ftOpenedAs;
            if( !fUntitled && SaveFile( hwndNP, szFileName, FALSE ) )
               break;

            /* fall through */

        case M_SAVEAS:

            OFN.lpstrFile       = szNewName;
            OFN.lpstrTitle      = szSaveCaption;
            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */
            OFN.Flags = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                        OFN_EXPLORER         |
                        OFN_ENABLESIZING     |
                        OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName= TEXT("NpEncodingDialog");
            OFN.lpfnHook= NpSaveDialogHookProc;

            /* ALL non-zero long pointers must be defined immediately
             * before the call, as the DS might move otherwise.
             * 12 February 1991    clarkc
             */
            OFN.lpstrFilter       = szSaveFilterSpec;
            OFN.lpstrDefExt       = TEXT("txt");

            if (!fUntitled)
            {
                lstrcpyn(szNewName, szFileName, MAX_PATH); /* set default selection */
            }
            else
            {
                lstrcpy (szNewName, TEXT("*.txt") );
            }

            fInSaveAsDlg = TRUE;

            OFN.nFilterIndex= FILE_TEXT;

            //
            // Do common dialog to save file
            //

            if (GetSaveFileName(&OFN))
            {

               if( SaveFile(hwnd, szNewName, TRUE) )
               {
                  lstrcpyn( szFileName, szNewName, MAX_PATH);
                  g_ftOpenedAs= g_ftSaveAs;
               }
            }
            else
            {
                SignalCommDlgError();
            }

            fInSaveAsDlg = FALSE;
            break;

        case M_SELECTALL:
            {
                HMENU    hMenu;

                hMenu = GetMenu(hwndNP);
                lSel = (LONG) SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, 0L);
                SendMessage (hwndEdit, EM_SETSEL, 0, lSel );
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
                EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_GRAYED);
                break;
            }

        case M_REPLACE:
            if( hDlgFind )
            {
               SetFocus( hDlgFind );
            }
            else
            {
               FR.Flags= FR_HIDEWHOLEWORD | FR_REPLACE;
               FR.lpstrReplaceWith= szReplace;
               FR.wReplaceWithLen= CCHKEYMAX;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = ReplaceText( &FR );
            }
            break;

        case M_FINDNEXT:
            if (szSearch[0])
            {
               Search(szSearch);
               break;
            }
            /* else fall thro' a,d bring up "find" dialog */

        case M_FIND:
            if (hDlgFind)
            {
               SetFocus(hDlgFind);
            }
            else
            {
               FR.Flags= FR_DOWN | FR_HIDEWHOLEWORD;
               FR.lpstrReplaceWith= NULL;
               FR.wReplaceWithLen= 0;
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = FindText((LPFINDREPLACE)&FR);
            }
            break;

        case M_GOTO:
            {
                INT  Result;

                Result= (INT)DialogBox( hInstanceNP,
                                        MAKEINTRESOURCE(IDD_GOTODIALOG),
                                        hwndNP,
                                        GotoDlgProc );

                //
                // move cursor only if ok pressed and line number ok
                //

                if( Result == 0 )
                {
                    GotoAndScrollInView( lGotoLine );
                }
            }
            break;

        case M_ABOUT:
            ShellAbout(hwndNP,
                       szNN,
                       TEXT(""),
                       LoadIcon(hInstanceNP,
                                (LPTSTR)MAKEINTRESOURCE(ID_ICON)));

            break;

        case M_HELP:
            HtmlHelpA(GetDesktopWindow(), "notepad.chm", HH_DISPLAY_TOPIC, 0L);
            break;

        case M_CUT:
        case M_COPY:
        case M_CLEAR:
            {
                DWORD dwSelStart;
                DWORD dwSelEnd;

                // if nothing selected, then nothing to do.

                SendMessage( hwndEdit, 
                             EM_GETSEL, 
                             (WPARAM) &dwSelStart, 
                             (LPARAM) &dwSelEnd);
                if( dwSelStart == dwSelEnd ) {
                   break;
                }
            }

        case M_PASTE:
            /* If notepad parent or edit window has the focus,
               pass command to edit window.
               make sure line resulting from paste will not be too long. */
            hwndFocus = GetFocus();
            if (hwndFocus == hwndEdit || hwndFocus == hwndNP)
            {
                PostMessage(hwndEdit, LOWORD(wParam), 0, 0);
            }
            break;

        case M_DATETIME:
            InsertDateTime(FALSE);
            break;

        case M_UNDO:
            SendMessage (hwndEdit, EM_UNDO, 0, 0L);
            break;

        case M_WW:
            style= (!fWrap) ? ES_STD : (ES_STD | WS_HSCROLL);
            if( NpReCreate( style ) )
            {
                fWrap= !fWrap;
            }
            else
            {
                MessageBox(hwndNP, szNoWW, szNN,
                           MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
            }

            // disable the status bar
            // Line numbers when wordwrap is on are very confusing for now.  Just turn them
            // off until we better understand what the user wants to see.
            if (fWrap)
            {
                HMENU hMenu;

                // Uncheck the StatusBar and remove it.
                fLastStatus= fStatus;      // remember for when wordwrap  gets turned off
                if( fStatus ) 
                {
                    SendMessage(hwnd, WM_COMMAND, M_STATUSBAR, 0L);
                }

                hMenu = GetMenu(hwndNP);
                CheckMenuItem (GetSubMenu(hMenu, 3), M_STATUSBAR, MF_UNCHECKED);
                EnableMenuItem(GetSubMenu(hMenu, 3), M_STATUSBAR, MF_GRAYED);
            }
            // enable the status bar
            else
            {
                HMENU hMenu;

                hMenu = GetMenu(hwndNP);
                EnableMenuItem(GetSubMenu(hMenu, 3), M_STATUSBAR, MF_ENABLED);

                // change the statusbar status to what it was before wordwrap was turned on
                if( fLastStatus ) 
                {
                   SendMessage( hwnd, WM_COMMAND, M_STATUSBAR, 0L);
                }
            }

            break;

        case M_STATUSBAR:

            // hide/show the statusbar and also redraw the edit window accordingly.
            GetClientRect(hwndNP, &rcClient);

            if ( fStatus )
            {
                fStatus = FALSE;
                ShowWindow ( hwndStatus, SW_HIDE );
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
            }
            else
            {
                fStatus = TRUE;
                NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
                UpdateStatusBar( TRUE );
                ShowWindow( hwndStatus, SW_SHOW );
            }
            break;

        case ID_EDIT:
            break;

        case M_PRINT:
            PrintIt( UseDialog );
            break;

        case M_PAGESETUP:
            TryPrintDlgAgain:
            
            if( PageSetupDlg(&g_PageSetupDlg) )
            {
                //  We know it's okay to copy these strings over...
                lstrcpy(chPageText[HEADER], chPageTextTemp[HEADER]);
                lstrcpy(chPageText[FOOTER], chPageTextTemp[FOOTER]);
            }
            else
            {
                rc= CommDlgExtendedError();

                if( rc == PDERR_PRINTERNOTFOUND ||
                    rc == PDERR_DNDMMISMATCH    ||
                    rc == PDERR_DEFAULTDIFFERENT )
                  {
                      FreeGlobal();
                      g_PageSetupDlg.hDevMode= g_PageSetupDlg.hDevNames= 0;
                      goto TryPrintDlgAgain;
                  }

                // Check for Dialog Failure

                SignalCommDlgError( );

            }
            break;

        case M_SETFONT:
        {
            CHOOSEFONT  cf;
            HFONT       hFontNew;
            HDC         hDisplayDC;     // display DC

            hDisplayDC= GetDC(NULL);    // try to get display DC
            if( !hDisplayDC )
                break;

            // calls the font chooser (in commdlg)
            // We set lfHeight; choosefont returns ipointsize
            //

            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = hwnd;
            cf.lpLogFont = &FontStruct;         // filled in by init
            FontStruct.lfHeight= -MulDiv(iPointSize,GetDeviceCaps(hDisplayDC,LOGPIXELSY),720);
 
            // We filter out useless stuff here
            // We tried CF_NOSCRIPTSEL, but the FE had fits.
            //    Even though it looks useless, it changes the font that gets mapped on FE builds.
            //    Even though we ignore the lfCharSet that gets returned, we have the "right"
            //    font according to the FE guys.  It might make sense to use lfCharSet to
            //    convert the ansi file when it is converted to Unicode, but this might be
            //    confusing.
 
            cf.Flags = CF_INITTOLOGFONTSTRUCT |
                       CF_SCREENFONTS         | 
                       CF_NOVERTFONTS         |
                       // CF_NOSCRIPTSEL         |  // windows bug# 7770 (April 10,2001)
                       0;
            cf.rgbColors = 0;                   // only if cf_effects
            cf.lCustData = 0;                   // for hook function
            cf.lpfnHook = (LPCFHOOKPROC) NULL;
            cf.lpTemplateName = (LPTSTR) NULL;
            cf.hInstance = NULL;
            cf.lpszStyle = NULL;                // iff cf_usestyle
            cf.nFontType = SCREEN_FONTTYPE;
            cf.nSizeMin  = 0;  // iff cf_limitsize
            cf.nSizeMax  = 0;  // iff cf_limitsize
            ReleaseDC( NULL, hDisplayDC );

            if( ChooseFont(&cf) )
            {
                SetCursor( hWaitCursor );        // may take some time
                
                hFontNew= CreateFontIndirect(&FontStruct);
                if( hFontNew )
                {
                   DeleteObject( hFont );
                   hFont= hFontNew;
                   SendMessage( hwndEdit, WM_SETFONT,
                               (WPARAM)hFont, MAKELPARAM(TRUE, 0));
                   iPointSize= cf.iPointSize;  // remember for printer
                }
                SetCursor( hStdCursor );
            }
            break;
        }

        default:
            return FALSE;
    }
    return TRUE;
}


// for some reason, this procedure tries to maintain
// a valid 'fp' even though I believe it does not need
// to be.
void FileDragOpen(void)
{
    HANDLE oldfp;

    oldfp= fp;       // remember in case of error

    if( CheckSave(FALSE) )
    {

         fp= CreateFile( szPath,               // filename
                         GENERIC_READ,         // access mode
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         NULL,                 // security descriptor
                         OPEN_EXISTING,        // how to create
                         FILE_ATTRIBUTE_NORMAL,// file attributes
                         NULL);                // hnd to file attrs

       if( fp == INVALID_HANDLE_VALUE )
       {
          AlertUser_FileFail( szPath );

          // Restore fp to original file.
          fp= oldfp;
       }
       /* Try to load the file and reset fp if failed */
       else if( !LoadFile( szPath, FT_UNKNOWN ) )
       {
           fp= oldfp;
       }
    }
}


/* Proccess file drop/drag options. */
void doDrop (WPARAM wParam, HWND hwnd)
{
   /* If user dragged/dropped a file regardless of keys pressed
    * at the time, open the first selected file from file manager. */

    if (DragQueryFile ((HANDLE)wParam, 0xFFFFFFFF, NULL, 0)) /* # of files dropped */
    {
       DragQueryFile ((HANDLE)wParam, 0, szPath, CharSizeOf(szPath));
       SetActiveWindow (hwnd);
       FileDragOpen();
    }
    DragFinish ((HANDLE)wParam);  /* Delete structure alocated for WM_DROPFILES*/
}

/* ** if notepad is dirty, check to see if user wants to save contents */
BOOL FAR CheckSave (BOOL fSysModal)
{
    INT    mdResult = IDOK;
    TCHAR  szNewName[MAX_PATH] = TEXT("");      /* New file name */
    TCHAR *pszFileName;

/* If it's untitled and there's no text, don't worry about it */
    if (fUntitled && !SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, (LPARAM)0))
        return (TRUE);

    if (SendMessage (hwndEdit, EM_GETMODIFY, 0, 0L))
    {
       if( fUntitled )
           pszFileName= szUntitled;
       else
           pszFileName= szFileName;

       // put up message box
       fInSaveAsDlg= TRUE;     // inform wm_queryendsession that we are trying to save

       mdResult= AlertBox( hwndNP, szNN, szSCBC, pszFileName,
       (WORD)((fSysModal ? MB_SYSTEMMODAL :
                           MB_APPLMODAL)|MB_YESNOCANCEL|MB_ICONEXCLAMATION));
       fInSaveAsDlg= FALSE;

       if( mdResult == IDYES )
       {
          if( fUntitled )
          {
             lstrcpy( szNewName, TEXT("*.txt") );
SaveFilePrompt:
             OFN.lpstrFile        = szNewName;
             OFN.lpstrTitle       = szSaveCaption;

            /* Added OFN_PATHMUSTEXIST to eliminate problems in SaveFile.
             * 12 February 1991    clarkc
             */

            OFN.Flags = OFN_HIDEREADONLY     | OFN_OVERWRITEPROMPT |
                        OFN_NOREADONLYRETURN | OFN_PATHMUSTEXIST   |
                        OFN_EXPLORER         |
                        OFN_ENABLESIZING     |
                        OFN_ENABLETEMPLATE   | OFN_ENABLEHOOK;

            OFN.lpTemplateName= TEXT("NpEncodingDialog");
            OFN.lpfnHook= NpSaveDialogHookProc;

            /* ALL non-zero long pointers must be defined immediately
             * before the call, as the DS might move otherwise.
             * 12 February 1991    clarkc
             */
             OFN.lpstrFilter       = szSaveFilterSpec;
             OFN.lpstrDefExt       = TEXT("txt");

             OFN.nFilterIndex= FILE_TEXT;

             //
             // Set dialog checkmark by current file type
             //

             fInSaveAsDlg = TRUE;
             if (GetSaveFileName(&OFN))
             {
                // since SaveFile() uses near ptr to name (obs.)
                lstrcpy(szNewName, OFN.lpstrFile);
                if( SaveFile(hwndNP, szNewName, TRUE) )
                {
                   lstrcpy(szFileName, szNewName);
                   g_ftOpenedAs= g_ftSaveAs;
                }
                else
                {      // Fixing close without saving file when disk-full
                   lstrcpy(szNewName, szFileName);
                   goto SaveFilePrompt;
                }
             }
             else
             {
                mdResult= IDCANCEL;       /* Don't exit Program */
                if( CommDlgExtendedError() )/* Dialog box failed, Lo-mem*/
                   DeepTrouble();
             }

             fInSaveAsDlg = FALSE;
          }
          else
          {
            // initialize the save type.
             g_ftSaveAs = g_ftOpenedAs;
             if( SaveFile(hwndNP, szFileName, FALSE) )
                return(TRUE);
             lstrcpy(szNewName, szFileName);
             goto SaveFilePrompt;
          }
       }
    }
    return (mdResult != IDCANCEL);
}


/* Notepad window class procedure */
LRESULT FAR NPWndProc(
        HWND       hwnd,
        UINT       message,
        WPARAM     wParam,
        LPARAM     lParam)
{
    RECT rc;
    LPFINDREPLACE lpfr;
    DWORD dwFlags;
    HANDLE hMenu;
    INT iParts[2];


    switch (message)
    {
/* If we're being run by Setup and it's the system menu, be certain that
 * the minimize menu item is disabled.  Note that hSysMenuSetup is only
 * initialized if Notepad is being run by Setup.  Don't use it outside
 * the fRunBySetup conditional!    28 June 1991    Clark Cyr
 */
        case WM_INITMENUPOPUP:
            if (fRunBySetup && HIWORD(lParam))
               EnableMenuItem(hSysMenuSetup,SC_MINIMIZE,MF_GRAYED|MF_DISABLED);
            break;

        case WM_SYSCOMMAND:
            if (fRunBySetup)
            {
                /* If we have been spawned by SlipUp we need to make sure the
                 * user doesn't minimize us or alt tab/esc away.
                 */
                if (wParam == SC_MINIMIZE ||
                    wParam == SC_NEXTWINDOW ||
                    wParam == SC_PREVWINDOW)
                    break;
            }
            DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_SETFOCUS:
            if (!IsIconic(hwndNP))
            {
               SetFocus(hwndEdit);
            }
            break;

        case WM_KILLFOCUS:
            SendMessage (hwndEdit, message, wParam, lParam);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        case WM_CLOSE:

            // Save any globals in the registry if need be

            SaveGlobals();

            if (CheckSave(FALSE))
            {
                /* Exit help */
                if(!WinHelp(hwndNP, (LPTSTR)szHelpFile, HELP_QUIT, 0))
                    DeepTrouble();

                DestroyWindow(hwndStatus);
                DestroyWindow(hwndNP);
                DeleteObject(hFont);
            }

            break;

        case WM_QUERYENDSESSION:
            if (fInSaveAsDlg)
            {
                MessageBeep (0);
                MessageBeep (0);
                MessageBox (hwndNP, szCannotQuit, szNN, MB_OK|MB_SYSTEMMODAL);
                return FALSE;
            }
            else
                return (CheckSave(TRUE));
            break;


        case WM_ACTIVATEAPP:
            if (wParam)
            {
            /* This causes the caret position to be at the end of the selection
             * but there's no way to ask where it was or set it if known.  This
             * will cause a caret change when the selection is made from bottom
             * to top.
             */
                if( dwCurrentSelectionStart != 0 || dwCurrentSelectionEnd != 0 )
                {
                   SendMessage( hwndEdit, EM_SETSEL,
                                dwCurrentSelectionStart,
                                dwCurrentSelectionEnd );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );
                }
            }
            else
            {
                SendMessage( hwndEdit, EM_GETSEL,
                            (WPARAM) &dwCurrentSelectionStart,
                            (LPARAM) &dwCurrentSelectionEnd);
                if (dwCurrentSelectionStart == dwCurrentSelectionEnd)
                {
                    dwCurrentSelectionStart = 0L;
                    dwCurrentSelectionEnd = 0L;
                }
                else
                {
                   SendMessage (hwndEdit, EM_SETSEL, dwCurrentSelectionStart,
                                dwCurrentSelectionEnd);
                   SendMessage (hwndEdit, EM_SCROLLCARET, 0, 0);
                }
            }
            break;

        case WM_ACTIVATE:
            if ((LOWORD(wParam) == WA_ACTIVE       ||
                 LOWORD(wParam) == WA_CLICKACTIVE) &&
                !IsIconic(hwndNP)
               )
               {
                   // active doesn't always mean foreground (ntbug# 53048)
                   if( GetForegroundWindow() == hwndNP )
                   {
                       SetFocus(GetForegroundWindow());
                   }
               }
            break;

        case WM_SIZE:
            switch (wParam)
            {
                case SIZENORMAL:
                case SIZEFULLSCREEN:

                    // resize the status window.
                    SendMessage (hwndStatus, WM_SIZE, 0, 0L);
                    iParts[0] = 3 * (MAKEPOINTS(lParam).x)/4;
                    iParts[1] = -1;

                    // Divide the status window into two parts
                    SendMessage(hwndStatus, SB_SETPARTS, (WPARAM) sizeof(iParts)/sizeof(INT), (LPARAM) &iParts[0]); 

                    NPSize(MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y);
                    break;

                case SIZEICONIC:
                    return (DefWindowProc(hwnd, message, wParam, lParam));
                    break;
                }
            break;

        case WM_INITMENU:
            NpResetMenu( hwnd );
            break;

        //
        // Some keyboards come with a "Search" button which the shell team
        // wanted us to handle.  See ntbug# 380067
        //

        case WM_APPCOMMAND:

            if( ( GET_APPCOMMAND_LPARAM(lParam) == APPCOMMAND_BROWSER_SEARCH ) ) 
            {
                NPCommand(hwnd, M_FIND, 0);
                break;
            }
            // otherwise fall through
 
        case WM_COMMAND:

            if ((HWND)(lParam) == hwndEdit &&
                (HIWORD(wParam) == EN_ERRSPACE ||
                 HIWORD(wParam) == EN_MAXTEXT))
            {
                if (dwEmSetHandle == SETHANDLEINPROGRESS)
                    dwEmSetHandle = SETHANDLEFAILED;
                else
                    DeepTrouble();
                return 0L;
            }

            if (!NPCommand(hwnd, wParam, lParam))
               return (DefWindowProc(hwnd, message, wParam, lParam));
            break;


        case WM_WININICHANGE:
            // Ignore for now.
            // If you put this back in, be sure it handles both
            // the metric change and the decimal change.
            //NpWinIniChange ();
            break;

        case WM_DROPFILES: /*case added 03/26/91 for file drag/drop support*/
            doDrop (wParam,hwnd);
            break;

        case PWM_CHECK_HKL: /* private message: corresponding to HKL change message */
            {
                LPARAM lParam = 0;

                if (PRIMARYLANGID(LOWORD((DWORD) (INT_PTR) GetKeyboardLayout(0))) == LANG_JAPANESE) {
                    /*
                     * If new current HKL is Japanese, handle the result string at once.
                     */
                    lParam = EIMES_GETCOMPSTRATONCE;
                }
                SendMessage(hwndEdit, EM_SETIMESTATUS, EMSIS_COMPOSITIONSTRING, lParam);
            }
            break;

        default:
            /* this can be a message from the modeless Find Text window */
            if (message == wFRMsg)
            {
                BOOL bStatus;    // true if found text

                lpfr = (LPFINDREPLACE)lParam;
                dwFlags = lpfr->Flags;

                fReverse = (dwFlags & FR_DOWN      ? FALSE : TRUE);
                fCase    = (dwFlags & FR_MATCHCASE ? TRUE  : FALSE);

                if( dwFlags & FR_FINDNEXT )
                {
                    SetCursor( hWaitCursor );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACE )
                {
                    //
                    // Replace current selection if it matches
                    // then highlight the next occurence of the string.
                    //

                    SetCursor( hWaitCursor );
                    ReplaceSel( TRUE );
                    Search( szSearch );
                    SetCursor( hStdCursor );
                }
                else if( dwFlags & FR_REPLACEALL )
                {
                   //
                   // The replace dialog doesn't allow reverse searches
                   // but just it cases it changes, for it to false.
                   //
                   if( fReverse )
                   {
                       fReverse= FALSE;
                   }

                   //
                   // Replace all occurances of text in the file
                   // starting from the top.  Reset the selection
                   // to the top of the file.
                   //
                   SetCursor( hWaitCursor );
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   do
                   {
                      ReplaceSel( FALSE );
                      bStatus= Search( szSearch );
                   }
                   while( bStatus );
                   SetCursor( hStdCursor );
                   //
                   // back to the top of the file.
                   //
                   SendMessage( hwndEdit, EM_SETSEL, 0, 0 );
                   SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
                   UpdateStatusBar( TRUE );

                }
                else if (dwFlags & FR_DIALOGTERM)
                    hDlgFind = NULL;   /* invalidate modeless window handle */
                break;
            }
            return (DefWindowProc(hwnd, message, wParam, lParam));
    }
    return (0L);
}

LPTSTR SkipProgramName (LPTSTR lpCmdLine)
{
    LPTSTR  p = lpCmdLine;
    BOOL    bInQuotes = FALSE;

    //
    // Skip executable name
    //
    for (p; *p; p = CharNext(p))
    {
       if ((*p == TEXT(' ') || *p == TEXT('\t')) && !bInQuotes)
          break;

       if (*p == TEXT('\"'))
          bInQuotes = !bInQuotes;
    }

    while (*p == TEXT(' ') || *p == TEXT('\t'))
       p++;

    return (p);
}

/* ** Main loop */

INT WINAPI WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpAnsiCmdLine,
   INT cmdShow)
{
    MSG msg;
    VOID (FAR PASCAL *lpfnRegisterPenApp)(WORD, BOOL) = NULL;
    LPTSTR lpCmdLine = GetCommandLine ();
    HWINEVENTHOOK hEventHook = NULL;


/* PenWindow registration must be before creating an edit class window.
 * Moved here, along with goto statement below for appropriate cleanup.
 *                 10 July 1991    ClarkC
 */
    if ((FARPROC) lpfnRegisterPenApp = GetProcAddress((HINSTANCE)(INT_PTR)(GetSystemMetrics(SM_PENWINDOWS)),
        "RegisterPenApp"))
        (*lpfnRegisterPenApp)(1, TRUE);

    if (!NPInit(hInstance, hPrevInstance, SkipProgramName (lpCmdLine), cmdShow))
    {
       msg.wParam = FALSE;
       goto UnRegisterPenWindows;
    }

    // set an event hook to get the cursor position! this event hook is used to update
    // the line & column position of the caret shown in the statusbar.
    hEventHook = SetWinEventHook(EVENT_OBJECT_LOCATIONCHANGE, EVENT_OBJECT_LOCATIONCHANGE, NULL, WinEventFunc, 
                                (DWORD) GetCurrentProcessId(), 0, WINEVENT_OUTOFCONTEXT);
 
    while (GetMessage((LPMSG)&msg, (HWND)NULL, 0, 0))
    {
        //
        // To handle IME status when active KL is changed.
        //
        if (msg.message == WM_INPUTLANGCHANGEREQUEST) {
            //
            // WM_INPUTLANGCHANGE will be *sent* to WndProc,
            // so there's no chance to catch WM_INPUTLANGCHANGE from the frame window.
            // Instead, we post the private message to check the active HKL later.
            //
            PostMessage(hwndNP, PWM_CHECK_HKL, 0, 0);
        }

        if (!hDlgFind || !IsDialogMessage(hDlgFind, &msg))
        {
            if (TranslateAccelerator(hwndNP, hAccel, (LPMSG)&msg) == 0)
            {
               TranslateMessage ((LPMSG)&msg);
               DispatchMessage ((LPMSG)&msg);
            }
        }
    }

    /* Clean up any global allocations */

    FreeGlobal();

    LocalFree( hEdit );

    if (hEventHook)
        UnhookWinEvent(hEventHook);

UnRegisterPenWindows:

    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);

    return (int)(msg.wParam);
}


// WinEventFunc is called whenever the location of the caret changes
// in the edit window. The function updates the statusbar with the current
// line number, column of the caret.  This event is called when the mouse is moved.
// If the caret moves without mouse input, the UpdateStatusBar is called.
//
// UpdateStatusBar( TRUE ) is called to force the display being changed.

static DWORD iLastCol;
static DWORD iLastLine;

VOID UpdateStatusBar( BOOL fForceStatus )
{
    DWORD SelStart, SelEnd;
    UINT  iLine, iCol;
    TCHAR szStatusText[128];

    // get the current caret position.
    SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

    // the line numbers are 1 based instead 0 based. hence add 1.
    iLine = (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
    iCol = SelStart - (UINT)SendMessage( hwndEdit, EM_LINEINDEX, iLine-1, 0 ) + 1;

    // don't bother to update status if it hasn't changed
    if( fForceStatus || (iCol!=iLastCol) || (iLine!=iLastLine) )
    {
        // prepare and display the statusbar.
        // make sure you don't overflow the buffer boundary.
        _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, iLine, iCol);
        szStatusText[ sizeof(szStatusText)/sizeof(TCHAR) -1 ] = TEXT('\0');
        SetStatusBarText(szStatusText, 1);
            
    }

    iLastCol=  iCol;
    iLastLine= iLine;

};

VOID CALLBACK WinEventFunc(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject,
                      LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime)
{
    UpdateStatusBar( FALSE );

}


#define MAX_UNTITLED_LENGTH 50   /* max chars of "untitled" */

/* ** Set Window caption text */
void FAR SetTitle( TCHAR  *sz )
{
    TCHAR    szWindowText[MAX_PATH+MAX_UNTITLED_LENGTH];
    TCHAR    szFileName[MAX_PATH];
    HANDLE   hFindFile;
    WIN32_FIND_DATA info;
    TCHAR    szStatusText[128] = TEXT("");
    DWORD    dwAttributes;

    // if "untitled" then don't do all this work...
    if( lstrcmp( sz, szUntitled ) == 0 )
    {
       // don't check return: if the string gets truncated, 
       // it will just be a short version of "Untitled" in some language.
       // Whoever translated "untitled" to something > 260 chars is strange
       StringCchCopy( szWindowText, 
                      sizeof(szWindowText)/sizeof(TCHAR), 
                      szUntitled );
    }
    else
    {
       // get the attributes for file. these will be shown
       // in the status bar.
       dwAttributes = GetFileAttributes(sz);

       // Get real(file system) name for the file.
       hFindFile= FindFirstFile( sz, &info );

       if( hFindFile != INVALID_HANDLE_VALUE )
       {
          // don't check return.  cFileName is MAX_PATH long
          StringCchCopy( szFileName, MAX_PATH, info.cFileName );
          FindClose( hFindFile );
       }
       else
       {
          // don't check return.  Truncation fine for UI.
          StringCchCopy( szFileName, MAX_PATH, sz );
       }

       GetFileTitle(szFileName, szWindowText, MAX_PATH);



       // Removed the left part of the status bar to show file properties.
       // The correct way to fix it is to make sure that the correct delimiters (like commas),
       // and correct order is used for various localized builds.
#ifdef UNUSED_STATUSBARCODE
       // prepare the status bar text and show 
       // if the file has any special properties (such as hidden, readonly etc.)

        if (dwAttributes & FILE_ATTRIBUTE_COMPRESSED)
            if ((lstrlen(szStatusText) + lstrlen(szCompressedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)
                lstrcpy(szStatusText, szCompressedFile);

        if (dwAttributes & FILE_ATTRIBUTE_ENCRYPTED)   
            if ((lstrlen(szStatusText) + lstrlen(szEncryptedFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szEncryptedFile);

        if (dwAttributes & FILE_ATTRIBUTE_HIDDEN)
            if ((lstrlen(szStatusText) + lstrlen(szHiddenFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szHiddenFile);

        if (dwAttributes & FILE_ATTRIBUTE_OFFLINE)
            if ((lstrlen(szStatusText) + lstrlen(szOfflineFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szOfflineFile);

        if (dwAttributes & FILE_ATTRIBUTE_READONLY)
        {
            if ((lstrlen(szStatusText) + lstrlen(szReadOnlyFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szReadOnlyFile);
        }

        if (dwAttributes & FILE_ATTRIBUTE_SYSTEM)
            if ((lstrlen(szStatusText) + lstrlen(szSystemFile) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)            
                lstrcat(szStatusText, szSystemFile);

        // if the status did get updated by file properties
        if (*szStatusText != TEXT('\0'))
        {
            // get rid of the last comma
            szStatusText[lstrlen(szStatusText)-1] = TEXT(' ');

            if ((lstrlen(szStatusText) + lstrlen(szFile)) < sizeof(szStatusText)/sizeof(TCHAR) - 1)           
                lstrcat(szStatusText, szFile);
        }

#endif

    }

    // set the status bar. the Line and Col count is 1 initially for
    // the newly opened file as the caret position is at the first character.
    // SetStatusBarText(szStatusText, 0);
    _sntprintf(szStatusText, sizeof(szStatusText)/sizeof(TCHAR) -1, szLineCol, 1, 1);
    SetStatusBarText(szStatusText, 1);

    lstrcat(szWindowText, szNpTitle);
    SetWindowText(hwndNP, (LPTSTR)szWindowText);

}

/* ** Given filename which may or maynot include path, return pointer to
      filename (not including path part.) */
LPTSTR PASCAL far PFileInPath(
    LPTSTR sz)
{
    LPTSTR pch = sz;
    LPTSTR psz;

    /* Strip path/drive specification from name if there is one */
    /* Ripped out AnsiPrev calls.     21 March 1991  clarkc     */
    for (psz = sz; *psz; psz = CharNext(psz))
      {
        if ((*psz == TEXT(':')) || (*psz == TEXT('\\')))
            pch = psz;
      }

    if (pch != sz)   /* If found slash or colon, return the next character */
        pch++;       /* increment OK, pch not pointing to DB character     */

    return(pch);
}

/* ** Enable or disable menu items according to selection state
      This routine is called when user tries to pull down a menu. */

VOID NpResetMenu( HWND hwnd )
{
    INT     mfcc;   /* menuflag for cut, copy  find, findnext */
    BOOL    fCanUndo;
    HANDLE  hMenu;
    BOOL    fPaste= FALSE;
    UINT    uSelState;
    DWORD   dwSelStart;
    DWORD   dwSelEnd;

    hMenu = GetMenu(hwndNP);

    // cut, copy and delete only get enabled if there is text selected.

    SendMessage( hwndEdit, 
                 EM_GETSEL, 
                 (WPARAM) &dwSelStart,
                 (LPARAM) &dwSelEnd);

    mfcc= (dwSelStart == dwSelEnd ) ? MF_GRAYED : MF_ENABLED;

    EnableMenuItem(GetSubMenu(hMenu, 1), M_CUT, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_COPY, mfcc);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_CLEAR, mfcc);

    // check if the selectall is gray (that means the user has already
    // done select-all) and if the user has deselected - if so, time
    // to re-enable selectall menu.

    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if ((uSelState == MF_GRAYED) && (mfcc == MF_GRAYED))
    {
        EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
    }

    // paste is enabled if there is text in the clipboard

    if( OpenClipboard(hwnd) )
    {
        fPaste= IsClipboardFormatAvailable(CF_TEXT);
        CloseClipboard();
    }
    EnableMenuItem(GetSubMenu(hMenu, 1), M_PASTE, fPaste ? MF_ENABLED : MF_GRAYED);

    // enable the find/find next iff there is some text in the edit window

    mfcc= MF_GRAYED;
    if( SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0 ) )
    {
        mfcc= MF_ENABLED;
    }

    EnableMenuItem( GetSubMenu(hMenu,1), M_FIND,     mfcc );
    EnableMenuItem( GetSubMenu(hMenu,1), M_FINDNEXT, mfcc );


    // enable 'goto' iff wordwrap is off;  MLE doesn't give good results if word wrap on

    EnableMenuItem(GetSubMenu(hMenu, 1), M_GOTO, fWrap ? MF_GRAYED : MF_ENABLED );

    // enable Undo only if editcontrol says we can do it.

    fCanUndo = (BOOL) SendMessage(hwndEdit, EM_CANUNDO, 0, 0L);
    EnableMenuItem(GetSubMenu(hMenu, 1), M_UNDO, fCanUndo ? MF_ENABLED : MF_GRAYED);

    // check the word wrap item correctly

    CheckMenuItem(GetSubMenu(hMenu, 2), M_WW, fWrap ? MF_CHECKED : MF_UNCHECKED);

    // check the status bar

    CheckMenuItem (GetSubMenu(hMenu, 3), M_STATUSBAR, fStatus ? MF_CHECKED: MF_UNCHECKED );


}


void FAR NpWinIniChange(VOID)
{
   InitLocale ();
}

/* ** Scan sz1 for merge spec.    If found, insert string sz2 at that point.
      Then append rest of sz1 NOTE! Merge spec guaranteed to be two chars.
      returns TRUE if it does a merge, false otherwise. */
BOOL MergeStrings(
    TCHAR    *szSrc,
    TCHAR    *szMerge,
    TCHAR    *szDst)
    {
    register    TCHAR *pchSrc;
    register    TCHAR *pchDst;

    pchSrc = szSrc;
    pchDst = szDst;

    /* Find merge spec if there is one. */
    while ( *pchSrc != chMerge)
        {
        *pchDst++ = *pchSrc;

        /* If we reach end of string before merge spec, just return. */
        if (!*pchSrc++)
            return FALSE;

        }

    /* If merge spec found, insert sz2 there. (check for null merge string */
    if (szMerge)
        {
        while (*szMerge)
            *pchDst++ = *szMerge++;
        }

    /* Jump over merge spec */
    pchSrc++,pchSrc++;

    /* Now append rest of Src String */
    while (*pchDst++ = *pchSrc++);
    return TRUE;

    }

/* ** Post a message box */
INT FAR AlertBox(
    HWND    hwndParent,
    TCHAR    *szCaption,
    TCHAR    *szText1,
    TCHAR    *szText2,
    UINT     style)
{
    INT iResult;                      // result of function
    INT iAllocSize;                   // size needed for message
    TCHAR*  pszMessage;               // combined message

    // Allocate a message buffer assuming there will be a merge.
    // If we cannot do the allocation, tell the user something
    // related to the original problem. (not the allocation failure)
    // Then pray that MessageBox can get enough memory to actually work.

    iAllocSize= (lstrlen(szText1) + (szText2 ? lstrlen(szText2) : 0) + 1 ) * sizeof(TCHAR);

    pszMessage= (TCHAR*) LocalAlloc( LPTR, iAllocSize );

    if( pszMessage )
    {
        MergeStrings( szText1, szText2, pszMessage );
        iResult= MessageBox( hwndParent, pszMessage, szCaption, style );
        LocalFree( (HLOCAL) pszMessage );
    }
    else
    {
        iResult= MessageBox( hwndParent, szText1, szCaption, style );
    }

    return( iResult );
}

// SignalCommDlgError
//
// If a common dialog error occurred, put up reasonable message box.
//
// returns: TRUE if error occurred, FALSE if no error.
//

typedef struct tagMAPERROR
{
    DWORD   rc;            // return code from CommDlgExtendedError()
    PTCHAR* ppszMsg;       // text of message pointer
} MAPERROR;

// errors not in this list get generic "common dialog error %x" message.
static TCHAR* szNull= TEXT("");

MAPERROR maperror[]=
{
    CDERR_DIALOGFAILURE,  &szErrSpace,
    CDERR_INITIALIZATION, &szCommDlgInitErr,
    CDERR_MEMLOCKFAILURE, &szPDIE,
    CDERR_LOADSTRFAILURE, &szErrSpace,
    CDERR_FINDRESFAILURE, &szErrSpace,
    PDERR_LOADDRVFAILURE, &szLoadDrvFail,
    PDERR_GETDEVMODEFAIL, &szErrSpace,
    PDERR_NODEFAULTPRN,   &szNull,          // don't report; common dialog does already
};

BOOL SignalCommDlgError(VOID)
{
    DWORD rc;               // return code
    TCHAR* pszMsg;          // message
    INT    i;
    TCHAR  szBuf[200];      // just for common dialog failure

    rc= CommDlgExtendedError();

    // no failure - just return

    if( rc == 0 )
    {
        return FALSE;
    }

    // some sort of error - pick up message

    pszMsg= NULL;
    for( i=0; i< sizeof(maperror)/sizeof(maperror[0]); i++ )
    {
        if( rc == maperror[i].rc )
        {
            pszMsg= *maperror[i].ppszMsg;
        }
    }

    // if no known mapping - tell user the actual return code
    // this may be a bit confusing, but rare hopefully.

    if( !pszMsg )
    {
        _sntprintf(szBuf, sizeof(szBuf)/sizeof(TCHAR) -1, szCommDlgErr, rc);
        pszMsg= szBuf;
    }

    // popup if there is any message to give user

    if( *pszMsg )
    {
        MessageBox(hwndNP, pszMsg, szNN, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);
    }

    return TRUE;

}

// ReplaceSel
//
// Replace the current selection with string from FR struct
// if the current selection matches our search string.
//
// MLE will show selection if bView is true.
//


VOID ReplaceSel( BOOL bView )
{
    DWORD StartSel;    // start of selected text
    DWORD EndSel;      // end of selected text

    HANDLE hEText;
    TCHAR* pStart;
    DWORD  ReplaceWithLength;  // length of replacement string
    DWORD  FindWhatLength;

    ReplaceWithLength= lstrlen(FR.lpstrReplaceWith);
    FindWhatLength= lstrlen(FR.lpstrFindWhat);

    SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &StartSel, (LPARAM) &EndSel );
    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return;
    }

    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return;
    }

    if(  (EndSel-StartSel) == FindWhatLength )
    {
       if( (fCase &&
            !_tcsncmp(  FR.lpstrFindWhat, pStart+StartSel, FindWhatLength) ) ||
           (!fCase &&
           ( 2 == CompareString(LOCALE_USER_DEFAULT,
                  NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                  FR.lpstrFindWhat, FindWhatLength,
                  pStart+StartSel,  FindWhatLength ) ) ) )
        {
            SendMessage( hwndEdit, EM_REPLACESEL,
                         TRUE, (LPARAM) FR.lpstrReplaceWith);
            SendMessage( hwndEdit, EM_SETSEL,
                         StartSel, StartSel+ReplaceWithLength );

            if( bView )
            {
                SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
    }

    LocalUnlock( hEText );
}

// GotoDlgProc
//
// Handle the Goto Dialog window processing
//
// Returns:
//
// 1 if successfull
// 0 if not (cancelled)
//
// Modifies global lGotoLine
//

const DWORD s_GotoHelpIDs[] = {
    IDC_GOTO, IDH_GOTO,
    0, 0
};

#define GOTOBUFSIZE 100
INT_PTR CALLBACK GotoDlgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    TCHAR szBuf[GOTOBUFSIZE];
    UINT LineNum;
    DWORD SelStart, SelEnd;
    POINT pt;
    INT id;

    switch (message)
    {
        //
        // initialize input field to size of file
        //
        case WM_INITDIALOG:
            SendMessage(hwndEdit,EM_GETSEL,(WPARAM) &SelStart,(WPARAM)&SelEnd);

            // the line numbers are 1 based instead 0 based. hence add 1.
            LineNum= (UINT)SendMessage( hwndEdit, EM_LINEFROMCHAR, SelStart, 0 ) + 1;
            wsprintf(szBuf, TEXT("%d"), LineNum);
            SetDlgItemText( hDlg, IDC_GOTO, szBuf );
            SetFocus( hDlg );
            return TRUE;
            break;

        // context sensitive help.
        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;

        case WM_CONTEXTMENU:

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) s_GotoHelpIDs);
            break;


        case WM_COMMAND:

            switch (LOWORD(wParam))
            {
                UINT CharIndex;

                case IDC_GOTO:
                    return TRUE;
                    break;

                case IDOK:
                    GetDlgItemText( hDlg, IDC_GOTO, szBuf, GOTOBUFSIZE );

                    // convert all unicode numbers to range L'0' to L'9'

                    FoldString( MAP_FOLDDIGITS, szBuf, -1, szBuf, GOTOBUFSIZE);
                    lGotoLine= _ttol( szBuf );

                    //
                    // see if valid line number
                    //

                    CharIndex= (UINT)SendMessage( hwndEdit,
                                            EM_LINEINDEX,
                                            lGotoLine-1,
                                            0);
                    if( lGotoLine > 0 && CharIndex != -1 )
                    {
                        EndDialog(hDlg, 0);  // successfull
                        return TRUE;
                    }

                    //
                    // Invalid line number
                    // warning user and set to reasonable value
                    //

                    MessageBox( hDlg, szLineTooLarge, szLineError, MB_OK );

                    LineNum= (UINT)SendMessage( hwndEdit, EM_GETLINECOUNT, 0, 0 );
                    wsprintf(szBuf, TEXT("%d"), LineNum);
                    SetDlgItemText( hDlg, IDC_GOTO, szBuf );
                    SetFocus( hDlg );
                    break;

                case IDCANCEL :
                    EndDialog(hDlg, 1 );   // cancelled
                    return TRUE;
                    break;

                default:

                    break;

            } // switch (wParam)

            break;

       default:

             break;

    } // switch (message)


    return FALSE;     // Didn't process a message


} // GotoDlgProc()


// This procedure looks at the iSize bytes pointed by lpFileContents and
// determines based on that the encoding of the file (Ansi, Unicode, Reverse Unicode, UTF8)


NP_FILETYPE fDetermineFileType(LPBYTE lpFileContents, UINT iSize)
{
    NP_FILETYPE ftFileType = FT_ANSI;
    LPTSTR szBuf = (LPTSTR) lpFileContents;

    if (iSize <= 1)
        return ftFileType;

    switch(*szBuf)        
    {
        // look for the standard BOMs.
        case BYTE_ORDER_MARK:
            ftFileType = FT_UNICODE;
            break;

        case REVERSE_BYTE_ORDER_MARK:
            ftFileType = FT_UNICODEBE;
            break;

        // UTF bom has 3 bytes.
        case BOM_UTF8_HALF:            
            if (iSize > 2 && ((BYTE) *((lpFileContents)+2) == BOM_UTF8_2HALF) )
            {
                ftFileType = FT_UTF8;
            }
            break;

        default:
            // Is the file unicode without BOM ?
            if (IsInputTextUnicode(lpFileContents, iSize))
            {
                ftFileType = FT_UNICODE;
            }      
            else
            {
                // Is the file UTF-8 even though it doesn't have UTF-8 BOM ?
                if (IsTextUTF8(lpFileContents, iSize))
                {
                    ftFileType = FT_UTF8;
                }
                // well, it is most likely an ansi file.
                else
                {
                    ftFileType = FT_ANSI;
                }
            }
            break;
        }             

    return ftFileType;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\npfile.c ===
/*
 * npfile.c  - Routines for file i/o for notepad
 *   Copyright (C) 1984-2001 Microsoft Inc.
 */

#include "precomp.h"


HANDLE  hFirstMem;
CHAR    BOM_UTF8[3]= {(BYTE) 0xEF, (BYTE) 0xBB, (BYTE)0xBF};



//****************************************************************
//
//   ReverseEndian
//
//   Purpose: copies unicode character from one endian source
//            to another.
//
//            may work on lpDst == lpSrc
//

VOID ReverseEndian( PTCHAR lpDst, PTCHAR lpSrc, DWORD nChars )
{
    DWORD  cnt;

    for( cnt=0; cnt < nChars; cnt++,lpDst++,lpSrc++ )
    {
        *lpDst= (TCHAR) (((*lpSrc<<8) & 0xFF00) + ((*lpSrc>>8)&0xFF));
    }
}

//*****************************************************************
//
//   AnsiWriteFile()
//
//   Purpose     : To simulate the effects of _lwrite() in a Unicode
//                 environment by converting to ANSI buffer and
//                 writing out the ANSI text.
//   Returns     : TRUE is successful, FALSE if not
//                 GetLastError() will have the error code.
//
//*****************************************************************

BOOL AnsiWriteFile(HANDLE  hFile,    // file to write to
                   UINT uCodePage,   // code page to convert unicode to
                   DWORD  dwFlags,   // flags for WideCharToMultiByte conversion
                   LPVOID lpBuffer,  // unicode buffer
                   DWORD nChars)     // number of unicode chars
{
    LPSTR   lpAnsi;              // pointer to allocate buffer
    BOOL    fDefCharUsed;        // flag that conversion wasn't perfect
    BOOL*   pfDefCharUsed;       // pointer to flag
    DWORD   nBytesWritten;       // number of bytes written
    BOOL    bStatus;             // status from conversion and writefile
    DWORD   nBytes;              // number of ascii character to produce
    
    //
    // WideCharToMultiByte fails to convert zero characters.
    // If we get a request to write 0 chars, just return.  We are done.
    // 

    if( nChars == 0 )
    {
       return( TRUE );
    }

    pfDefCharUsed= NULL;
    if( uCodePage != CP_UTF8 )
    {
        pfDefCharUsed= &fDefCharUsed;
    }

    // 
    // Calculate number of bytes to write
    // The caller calculated the number of bytes to write
    // but it might be wrong because the user approved data loss.
    // Do the calculation here (again) in case the dwFlags are different.
    // FEATURE: We could optimize this in the case where the dwFlags did not
    // change.  
    //

    nBytes= 
    WideCharToMultiByte( uCodePage,             // code page
                         dwFlags,               // performance and mapping flags
                        (LPWSTR) lpBuffer,      // wide char buffer
                         nChars,                // chars in wide char buffer
                         NULL,                  // output buffer
                         0,                     // size of output buffer
                         NULL,                  // char to sub. for unmapped chars (use default)
                         pfDefCharUsed);        // flag to set if default char used

    if( nBytes == 0 )
    {
        return( FALSE );
    }

    //
    // Allocate buffer to convert to
    //

    lpAnsi= (LPSTR) LocalAlloc( LPTR, nBytes + 1 );

    if( !lpAnsi )
    {
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
       return (FALSE);
    }

    bStatus= 
    WideCharToMultiByte( uCodePage,             // code page
                         dwFlags,               // performance and mapping flags
                        (LPWSTR) lpBuffer,      // wide char buffer
                         nChars,                // chars in wide char buffer
                         lpAnsi,                // resultant ascii string
                         nBytes,                // size of ascii string buffer
                         NULL,                  // char to sub. for unmapped chars (use default)
                         pfDefCharUsed);        // flag to set if default char used

    if( bStatus ) 
    {
        bStatus= WriteFile( hFile, lpAnsi, nBytes, &nBytesWritten, NULL );
    }

    LocalFree( lpAnsi );

    return( bStatus );

} // end of AnsiWriteFile()


// Routines to deal with the soft EOL formatting.
//
// MLE Actually inserts characters into the text being under edit, so they
// have to be removed before saving the file.
//
// It turns out that MLE will get confused if the current line is bigger than
// the current file, so we will reset the cursor to 0,0 to keep it from looking stupid.
// Should be fixed in MLE, but...
//


static DWORD dwStartSel;    // saved start of selection
static DWORD dwEndSel;      // saved end of selection

VOID ClearFmt(VOID) 
{

    if( fWrap )
    {
        if( fMLE_is_broken ) 
        {
            GotoAndScrollInView( 1 );
        }
        else 
        {
           SendMessage( hwndEdit, EM_GETSEL, (WPARAM) &dwStartSel, (LPARAM) &dwEndSel );
           SendMessage( hwndEdit, EM_SETSEL, (WPARAM) 0, (LPARAM) 0 ); 
        }

        SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)FALSE, 0 );   // remove soft EOLs
    }

}

VOID RestoreFmt(VOID)
{
    UINT CharIndex;

    if( fWrap )
    {
        if( fMLE_is_broken ) 
        {
            NpReCreate( ES_STD );     // slow but it works
        }
        else
        {
            SendMessage( hwndEdit, EM_FMTLINES, (WPARAM)TRUE, 0 );   // add soft EOLs
            SendMessage( hwndEdit, EM_SETSEL, (WPARAM) dwStartSel, (LPARAM) dwEndSel);
        }
    }


}

/* Save notepad file to disk.  szFileSave points to filename.  fSaveAs
   is TRUE iff we are being called from SaveAsDlgProc.  This implies we must
   open file on current directory, whether or not it already exists there
   or somewhere else in our search path.
   Assumes that text exists within hwndEdit.    30 July 1991  Clark Cyr
 */

BOOL FAR SaveFile (HWND hwndParent, TCHAR *szFileSave, BOOL fSaveAs )
{
    LPTSTR    lpch;
    UINT      nChars;
    BOOL      flag;
    BOOL      fNew = FALSE;
    BOOL      fDefCharUsed = FALSE;
    BOOL*     pfDefCharUsed;
    static    WCHAR wchBOM = BYTE_ORDER_MARK;
    static    WCHAR wchRBOM= REVERSE_BYTE_ORDER_MARK;
    HLOCAL    hEText;                // handle to MLE text
    DWORD     nBytesWritten;         // number of bytes written
    DWORD     nAsciiLength;          // length of equivalent ascii file
    UINT      cpTemp= CP_ACP;        // code page to convert to
    DWORD     dwFlags;               // flags for WideCharToMultiByte


    // Obs: If saving to an existing file, make sure correct disk is in drive 
    // March 14, 2002: The user may have changed the diskette to one without
    // the named file.  Don't complain that it is not there.
    // TODO: fold code and figure out why one has file_share_write
    if (!fSaveAs)
    {
       fp= CreateFile( szFileSave,                 // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ,            // share mode
                       NULL,                       // security descriptor
                       OPEN_ALWAYS,                // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs

       if( fp != INVALID_HANDLE_VALUE )
       {
          fNew= (GetLastError() != ERROR_ALREADY_EXISTS );
       }
    }
    else
    {

       // Carefully open the file.  Do not truncate it if it exists.
       // set the fNew flag if it had to be created.
       // We do all this in case of failures later in the process.

       fp= CreateFile( szFileSave,                 // name of file
                       GENERIC_READ|GENERIC_WRITE, // access mode
                       FILE_SHARE_READ|FILE_SHARE_WRITE,  // share mode
                       NULL,                       // security descriptor
                       OPEN_ALWAYS,                // how to create
                       FILE_ATTRIBUTE_NORMAL,      // file attributes
                       NULL);                      // hnd of file with attrs

       if( fp != INVALID_HANDLE_VALUE )
       {
          fNew= (GetLastError() != ERROR_ALREADY_EXISTS );
       }
    }

    if( fp == INVALID_HANDLE_VALUE )
    {            
        AlertBox( hwndParent, szNN, szCREATEERR, szFileSave,
                        MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return FALSE;       
    }


    // if wordwrap, remove soft carriage returns 
    // Also move the cursor to a safe place to get around MLE bugs
    
    if( fWrap ) 
    {
       ClearFmt();
    }

    /* Must get text length after formatting */
    nChars = (UINT)SendMessage (hwndEdit, WM_GETTEXTLENGTH, 0, (LPARAM)0);

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0,0 );
    if(  !hEText || !(lpch= (LPTSTR) LocalLock(hEText) ))
    {
       AlertUser_FileFail( szFileSave );
       goto CleanUp;
    }



       
    // Determine the SaveAs file type, and write the appropriate BOM.
    // If the filetype is UTF-8 or Ansi, do the conversion.
    switch(g_ftSaveAs)
    {
    case FT_UNICODE:
        WriteFile( fp, &wchBOM, ByteCountOf(1), &nBytesWritten, NULL );
        flag= WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
        break;

    case FT_UNICODEBE:
        WriteFile( fp, &wchRBOM, ByteCountOf(1), &nBytesWritten, NULL );
        ReverseEndian( lpch, lpch,nChars );
        flag= WriteFile(fp, lpch, ByteCountOf(nChars), &nBytesWritten, NULL);
        ReverseEndian( lpch, lpch, nChars );
        break;

    // If it UTF-8, write the BOM (3 bytes), set the code page and fall 
    // through to the default case.
    case FT_UTF8:
        WriteFile( fp, &BOM_UTF8, 3, &nBytesWritten, NULL );        
        // fall through to convert and write the file

    default:

        if (g_ftSaveAs != FT_UTF8)
        {
            //
            // Always use the current locale code page to do the translation
            // If the user changes locales, they will need to know what locale
            // this version of the file was saved with.  Since we don't save that
            // information, the user may be in trouble.  Unicode would save his bacon.
            //

            cpTemp= GetACP();

            pfDefCharUsed= &fDefCharUsed;
            dwFlags= WC_NO_BEST_FIT_CHARS;
        }
        else 
        {
            cpTemp= CP_UTF8;
            pfDefCharUsed= NULL;    // these must be NULL and 0 for this code page
            dwFlags= 0;
        }
        

        nAsciiLength= WideCharToMultiByte( cpTemp,
                                           dwFlags,
                                           (LPWSTR)lpch,
                                           nChars,
                                           NULL,
                                           0,
                                           NULL,          // if no conversion, use default char
                                           pfDefCharUsed);

        // If we can't round-trip the character, warn the user.
        // If we don't use WC_NO_BEST_FIT_CHARS, WCTMB() will convert some characters
        // without setting the fDefCharUsed (for example alt-233)
        // This fixes ntbug9:367586

        if( fDefCharUsed || (nChars && (nAsciiLength==0) ) )
        {
            if ( AlertBox( hwndParent, szNN, szErrUnicode, szFileSave, 
                  MB_APPLMODAL|MB_OKCANCEL|MB_ICONEXCLAMATION) == IDCANCEL)
               goto CleanUp;          
           
            // User has approved loss of data, so try conversion with flags
            // that allow loss.   ntbug9: 435042

            dwFlags= 0;
        }
        flag= AnsiWriteFile( fp, cpTemp, dwFlags, lpch, nChars );
        break;
    }


    if (!flag)
    {
       SetCursor(hStdCursor);     /* display normal cursor */

       AlertUser_FileFail( szFileSave );
CleanUp:
       SetCursor( hStdCursor );
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       if( hEText )
           LocalUnlock( hEText );
       if (fNew)
          DeleteFile (szFileSave);
       /* if wordwrap, insert soft carriage returns */
       if (fWrap) 
       {
           RestoreFmt();
       }
       return FALSE;
    }
    else
    {
       SetEndOfFile (fp);
       g_ftOpenedAs = g_ftSaveAs;
       SendMessage (hwndEdit, EM_SETMODIFY, FALSE, 0L);
       SetTitle (szFileSave);
       fUntitled = FALSE;
    }

    CloseHandle (fp); fp=INVALID_HANDLE_VALUE;

    if( hEText )
        LocalUnlock( hEText );

    /* if wordwrap, insert soft carriage returns */
    if (fWrap)
    {
       RestoreFmt();
    }

    /* Display the hour glass cursor */
    SetCursor(hStdCursor);

    return TRUE;

} // end of SaveFile()

/* Read contents of file from disk.
 * Do any conversions required.
 * File is already open, referenced by handle fp
 * Close the file when done.
 * If typeFlag>=0, then use it as filetype, otherwise do automagic guessing.
 */

BOOL FAR LoadFile (TCHAR * sz, INT typeFlag )
{
    UINT      len, i, nChars;
    LPTSTR    lpch=NULL;
    LPTSTR    lpBuf;
    LPSTR     lpBufAfterBOM;
    BOOL      fLog=FALSE;
    TCHAR*    p;
    TCHAR     szSave[MAX_PATH]; /* Private copy of current filename */
    BOOL      bUnicode=FALSE;   /* true if file detected as unicode */
    BOOL      bUTF8=FALSE;      /* true if file detected as UTF-8 */
    DWORD     nBytesRead;       // number of bytes read
    BY_HANDLE_FILE_INFORMATION fiFileInfo;
    BOOL      bStatus;          // boolean status
    HLOCAL    hNewEdit=NULL;    // new handle for edit buffer
    HANDLE    hMap;             // file mapping handle
    TCHAR     szNullFile[2];    // fake null mapped file
    INT       cpTemp = CP_ACP;
    NP_FILETYPE ftOpenedAs=FT_UNKNOWN;


    if( fp == INVALID_HANDLE_VALUE )
    {
       AlertUser_FileFail( sz );
       return (FALSE);
    }

    //
    // Get size of file
    // We use this heavy duty GetFileInformationByHandle API
    // because it finds bugs.  It takes longer, but it only is
    // called at user interaction time.
    //

    bStatus= GetFileInformationByHandle( fp, &fiFileInfo );
    len= (UINT) fiFileInfo.nFileSizeLow;

    // NT may delay giving this status until the file is accessed.
    // i.e. the open succeeds, but operations may fail on damaged files.

    if( !bStatus )
    {
        AlertUser_FileFail( sz );
        CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;
        return( FALSE );
    }

    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.


    // If the file is too big, fail now.
    // -1 not valid because we need a zero on the end.
    //
    // bug# 168148: silently fails to open 2.4 gig text file on win64
    // Caused by trying to convert ascii file to unicode which overflowed
    // the dword length handled by multibytetowidechar conversion.
    // Since no one will be happy with the performance of the MLE with
    // a file this big, we will just refuse to open it now.
    //
    // For example, on a Pentium 173 MHz with 192 Megs o'RAM (Tecra 8000) 
    // I got these results:
    //
    // size   CPU-time
    //    0    .12
    //    1    .46
    //    2    .77
    //    3   1.041
    //    4   1.662
    //    5   2.092
    //    6   2.543
    //    7   3.023
    //    8   3.534
    //    9   4.084
    //   10   4.576
    //   16   8.371
    //   32  23.142
    //   64  74.426
    //
    //  Curve fitting these numbers to cpu-time=a+b*size+c*size*size
    //     we get a really good fit with cpu= .24+.28*size+.013*size*size
    //
    // For 1 gig, this works out to be 3.68 hours.  2 gigs=14.6 hours
    //
    // And the user isn't going to be happy with adding or deleting characters
    // with the MLE control.  It wants to keep the memory stuctures uptodate
    // at all times.
    //
    // Going to richedit isn't a near term solution either:
    //
    // size    CPU-time
    // 2       3.8
    // 4       9.0
    // 6      21.9
    // 8      30.4
    // 10     65.3
    // 16   1721 or >3.5 hours (it was still running when I killed it)
    //
    //
    // feature: should we only bail if not unicode?
    //

    if( len >=0x40000000 || fiFileInfo.nFileSizeHigh != 0 )
    {
       AlertBox( hwndNP, szNN, szFTL, sz,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       CloseHandle (fp); fp=INVALID_HANDLE_VALUE;
       return (FALSE);
    }

    SetCursor(hWaitCursor);                // physical I/O takes time

    //
    // Create a file mapping so we don't page the file to
    // the pagefile.  This is a big win on small ram machines.
    //

    if( len != 0 )
    {
        lpBuf= NULL;

        hMap= CreateFileMapping( fp, NULL, PAGE_READONLY, 0, len, NULL );

        if( hMap )
        {
            lpBuf= MapViewOfFile( hMap, FILE_MAP_READ, 0,0,len);
            CloseHandle( hMap );
        }
    }
    else  // file mapping doesn't work on zero length files
    {
        lpBuf= (LPTSTR) &szNullFile;
        *lpBuf= 0;  // null terminate
    }

    CloseHandle( fp ); fp=INVALID_HANDLE_VALUE;

    if( lpBuf == NULL )
    {
        SetCursor( hStdCursor );
        AlertUser_FileFail( sz );
        return( FALSE );
    }


    //
    // protect access to the mapped file with a try/except so we
    // can detect I/O errors.
    //

    //
    // WARNING: be very very careful.  This code is pretty fragile.
    // Files across the network, or RSM files (tape) may throw excepts
    // at random points in this code.  Anywhere the code touches the
    // memory mapped file can cause an AV.  Make sure variables are
    // in consistent state if an exception is thrown.  Be very careful
    // with globals.

    __try
    {
    /* Determine the file type and number of characters
     * If the user overrides, use what is specified.
     * Otherwise, we depend on 'IsTextUnicode' getting it right.
     * If it doesn't, bug IsTextUnicode.
     */

    lpBufAfterBOM= (LPSTR) lpBuf;
    if( typeFlag == FT_UNKNOWN )
    {
        switch(*lpBuf)
        {
        case BYTE_ORDER_MARK:
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            // don't count the BOM.
            nChars= len / sizeof(TCHAR) -1;
            break;

        case REVERSE_BYTE_ORDER_MARK:
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODEBE;

            // don't count the BOM.
            nChars= len / sizeof(TCHAR) -1;
            break;

        // UTF bom has 3 bytes; if it doesn't have UTF BOM just fall through ..
        case BOM_UTF8_HALF:            
            if (len > 2 && ((BYTE) *(((LPSTR)lpBuf)+2) == BOM_UTF8_2HALF) )
            {
                bUTF8= TRUE;
                cpTemp= CP_UTF8;
                ftOpenedAs= FT_UTF8;
                // Ignore the first three bytes.
                lpBufAfterBOM= (LPSTR)lpBuf + 3;
                len -= 3;
                break;
            }

        default:

            // Is the file unicode without BOM ?
            if ((bUnicode= IsInputTextUnicode((LPSTR) lpBuf, len)))
            {
                ftOpenedAs= FT_UNICODE;
                nChars= len / sizeof(TCHAR);
            }      
            else
            {
                // Is the file UTF-8 even though it doesn't have UTF-8 BOM.
                if ((bUTF8= IsTextUTF8((LPSTR) lpBuf, len)))
                {
                    ftOpenedAs= FT_UTF8;
                    cpTemp= CP_UTF8;
                }
                // well, not it must be an ansi file!
                else
                {
                    ftOpenedAs= FT_ANSI;
                    cpTemp= CP_ACP;
                }
            }
            break;
        }             
    }
    else
    {
        switch(typeFlag)
        {
        case FT_UNICODE:
                        
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            nChars= len / sizeof(TCHAR);

            // don't count the BOM.
            if (*lpBuf == BYTE_ORDER_MARK)
                nChars--;
            break;

        case FT_UNICODEBE:
                        
            bUnicode= TRUE;
            ftOpenedAs= FT_UNICODE;

            nChars= len / sizeof(TCHAR);

            // don't count the BOM.
            if (*lpBuf == REVERSE_BYTE_ORDER_MARK)
                nChars--;
            break;


        case FT_UTF8:
            
            bUTF8= TRUE;
            cpTemp= CP_UTF8;
            ftOpenedAs= FT_UTF8;
                      
            if (len > 2 && ((*lpBuf == BOM_UTF8_HALF) && ((BYTE) *(((LPSTR)lpBuf)+2) == BOM_UTF8_2HALF)) )
            {                
                // Ignore the first three bytes.
                lpBufAfterBOM= (LPSTR)lpBuf + 3;
                len -= 3;
                break;
            }
            break;


        case FT_ANSI:
        default:

            ftOpenedAs= FT_ANSI;
            cpTemp= CP_ACP;
        break;
        }
    }


    // find out no. of chars present in the string.
    if (!bUnicode)
    {
        nChars = MultiByteToWideChar (cpTemp,
                                      0,
                                      (LPSTR)lpBufAfterBOM,
                                      len,
                                      NULL,
                                      0);
    }

    //
    // Don't display text until all done.
    //

    SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);

    // Reset selection to 0

    SendMessage(hwndEdit, EM_SETSEL, 0, 0L);
    SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);

    // resize the edit buffer
    // if we can't resize the memory, inform the user

    if (!(hNewEdit= LocalReAlloc(hEdit,ByteCountOf(nChars + 1),LMEM_MOVEABLE)))
    {
      /* Bug 7441: New() causes szFileName to be set to "Untitled".  Save a
       *           copy of the filename to pass to AlertBox.
       *  17 November 1991    Clark R. Cyr
       */
       lstrcpy(szSave, sz);
       New(FALSE);

       /* Display the hour glass cursor */
       SetCursor(hStdCursor);

       AlertBox( hwndNP, szNN, szFTL, szSave,
                 MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
       if( lpBuf != (LPTSTR) &szNullFile )
       {
           UnmapViewOfFile( lpBuf );
       }

       // let user see old text

       SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);
       return FALSE;
    }

    /* Transfer file from temporary buffer to the edit buffer */
    lpch= (LPTSTR) LocalLock(hNewEdit);

    if( bUnicode )
    {
       /* skip the Byte Order Mark */
       if (*lpBuf == BYTE_ORDER_MARK)
       {
          CopyMemory (lpch, lpBuf + 1, ByteCountOf(nChars));
       }
       else if( *lpBuf == REVERSE_BYTE_ORDER_MARK )
       {
          ReverseEndian( lpch, lpBuf+1, nChars );          
       }
       else
       {
          CopyMemory (lpch, lpBuf, ByteCountOf(nChars));
       }
    }
    else
    {      
       nChars = MultiByteToWideChar (cpTemp,
                                     0,
                                     (LPSTR)lpBufAfterBOM,
                                     len,
                                     (LPWSTR)lpch,
                                     nChars);
       
    }

    g_ftOpenedAs= ftOpenedAs;   // got everything; update global safe now

    } 
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AlertBox( hwndNP, szNN, szDiskError, sz,
            MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );
        nChars= 0;   // don't deal with it.
    }

    /* Free file mapping */
    if( lpBuf != (LPTSTR) &szNullFile )
    {
        UnmapViewOfFile( lpBuf );
    }


    if( lpch ) 
    {

       // Fix any NUL character that came in from the file to be spaces.

       for (i = 0, p = lpch; i < nChars; i++, p++)
       {
          if( *p == (TCHAR) 0 )
             *p= TEXT(' ');
       }
      
       // null terminate it.  Safe even if nChars==0 because it is 1 TCHAR bigger

       *(lpch+nChars)= (TCHAR) 0;      /* zero terminate the thing */
   
       // Set 'fLog' if first characters in file are ".LOG"
   
       fLog= *lpch++ == TEXT('.') && *lpch++ == TEXT('L') &&
             *lpch++ == TEXT('O') && *lpch == TEXT('G');
    }
   
    if( hNewEdit )
    {
       LocalUnlock( hNewEdit );

       // now it is safe to set the global edit handle

       hEdit= hNewEdit;
    }

    lstrcpy( szFileName, sz );
    SetTitle( sz );
    fUntitled= FALSE;

  /* Pass handle to edit control.  This is more efficient than WM_SETTEXT
   * which would require twice the buffer space.
   */

  /* Bug 7443: If EM_SETHANDLE doesn't have enough memory to complete things,
   * it will send the EN_ERRSPACE message.  If this happens, don't put up the
   * out of memory notification, put up the file to large message instead.
   *  17 November 1991     Clark R. Cyr
   */
    dwEmSetHandle = SETHANDLEINPROGRESS;
    SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, (LPARAM)0);
    if (dwEmSetHandle == SETHANDLEFAILED)
    {
       SetCursor(hStdCursor);

       dwEmSetHandle = 0;
       AlertBox( hwndNP, szNN, szFTL, sz,MB_APPLMODAL|MB_OK|MB_ICONEXCLAMATION);
       New (FALSE);
       SendMessage (hwndEdit, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
       return (FALSE);
    }
    dwEmSetHandle = 0;

    PostMessage (hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L);

    /* If file starts with ".LOG" go to end and stamp date time */
    if (fLog)
    {
       SendMessage( hwndEdit, EM_SETSEL, (WPARAM)nChars, (LPARAM)nChars);
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0);
       InsertDateTime(TRUE);
    }

    /* Move vertical thumb to correct position */
    SetScrollPos (hwndNP,
                  SB_VERT,
                  (int) SendMessage (hwndEdit, WM_VSCROLL, EM_GETTHUMB, 0L),
                  TRUE);

    /* Now display text */
    SendMessage( hwndEdit, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0 );
    InvalidateRect( hwndEdit, (LPRECT)NULL, TRUE );
    UpdateWindow( hwndEdit );

    SetCursor(hStdCursor);

    return( TRUE );

} // end of LoadFile()

/* New Command - reset everything
 */

void FAR New (BOOL  fCheck)
{
    HANDLE hTemp;
    TCHAR* pSz;

    if (!fCheck || CheckSave (FALSE))
    {
       SendMessage( hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)TEXT("") );
       fUntitled= TRUE;
       lstrcpy( szFileName, szUntitled );
       SetTitle(szFileName );
       SendMessage( hwndEdit, EM_SETSEL, 0, 0L );
       SendMessage( hwndEdit, EM_SCROLLCARET, 0, 0 );

       // resize of 1 NULL character i.e. zero length

       hTemp= LocalReAlloc( hEdit, sizeof(TCHAR), LMEM_MOVEABLE );
       if( hTemp )
       {
          hEdit= hTemp;
       }

       // null terminate the buffer.  LocalReAlloc won't do it
       // because in all cases it is not growing which is the
       // only time it would zero out anything.

       pSz= LocalLock( hEdit );
       *pSz= TEXT('\0');
       LocalUnlock( hEdit );

       SendMessage (hwndEdit, EM_SETHANDLE, (WPARAM)hEdit, 0L);
       szSearch[0] = (TCHAR) 0;
    }

} // end of New()

/* If sz does not have extension, append ".txt"
 * This function is useful for getting to undecorated filenames
 * that setup apps use.  DO NOT CHANGE the extension.  Too many setup
 * apps depend on this functionality.
 */

void FAR AddExt( TCHAR* sz )
{
    TCHAR*   pch1;
    int      ch;
    DWORD    dwSize;

    dwSize= lstrlen(sz);

    pch1= sz + dwSize;   // point to end

    ch= *pch1;
    while( ch != TEXT('.') && ch != TEXT('\\') && ch != TEXT(':') && pch1 > sz)
    {
        //
        // backup one character.  Do NOT use CharPrev because
        // it sometimes doesn't actually backup.  Some Thai
        // tone marks fit this category but there seems to be others.
        // This is safe since it will stop at the beginning of the
        // string or on delimiters listed above.  bug# 139374 2/13/98
        //
        // pch1= (TCHAR*)CharPrev (sz, pch1);
        pch1--;  // back up
        ch= *pch1;
    }

    if( *pch1 != TEXT('.') )
    {
       if( dwSize + sizeof(".txt") <= MAX_PATH ) {  // avoid buffer overruns
           lstrcat( sz, TEXT(".txt") );
       }
    }

}


/* AlertUser_FileFail( LPTSTR szFileName )
 *
 * szFileName is the name of file that was attempted to open.
 * Some sort of failure on file open.  Alert the user
 * with some monologue box.  At least give him decent
 * error messages.
 */

VOID FAR AlertUser_FileFail( LPTSTR szFileName )
{
    TCHAR msg[256];     // buffer to format message into
    DWORD dwStatus;     // status from FormatMessage
    UINT  style= MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION;

    // Check GetLastError to see why we failed
    dwStatus=
    FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   GetLastError(),
                   GetUserDefaultUILanguage(),
                   msg,  // where message will end up
                   CharSizeOf(msg), NULL );
    if( dwStatus )
    {
          MessageBox( hwndNP, msg, szNN, style );
    }
    else
    {
        AlertBox( hwndNP, szNN, szDiskError, szFileName, style );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\npprint.c ===
/*
 * npprint.c -- Code for printing from notepad.
 * Copyright (C) 1984-1995 Microsoft Inc.
 */

#define NOMINMAX
#include "precomp.h"

//#define DBGPRINT

/* indices into chBuff */
#define LEFT   0
#define CENTER 1
#define RIGHT  2

INT     tabSize;                    /* Size of a tab for print device in device units*/
HWND    hAbortDlgWnd;
INT     fAbort;                     /* true if abort in progress      */
INT     yPrintChar;                 /* height of a character          */


RECT rtMargin;

/* left,center and right string for header or trailer */
#define MAXTITLE MAX_PATH
TCHAR chBuff[RIGHT+1][MAXTITLE];

/* date and time stuff for headers */
#define MAXDATE MAX_PATH
#define MAXTIME MAX_PATH
TCHAR szFormattedDate[MAXDATE]=TEXT("Y");   // formatted date (may be internationalized)
TCHAR szFormattedTime[MAXTIME]=TEXT("Y");   // formatted time (may be internaltionalized)
SYSTEMTIME PrintTime;                       // time we started printing


INT xPrintRes;          // printer resolution in x direction
INT yPrintRes;          // printer resolution in y direction
INT yPixInch;           // pixels/inch
INT xPhysRes;           // physical resolution x of paper
INT yPhysRes;           // physical resolution y of paper

INT xPhysOff;           // physical offset x
INT yPhysOff;           // physical offset y

INT dyTop;              // width of top border (pixels)
INT dyBottom;           // width of bottom border
INT dxLeft;             // width of left border
INT dxRight;            // width of right border

INT iPageNum;           // global page number currently being printed

/* define a type for NUM and the base */
typedef long NUM;
#define BASE 100L

/* converting in/out of fixed point */
#define  NumToShort(x,s)   (LOWORD(((x) + (s)) / BASE))
#define  NumRemToShort(x)  (LOWORD((x) % BASE))

/* rounding options for NumToShort */
#define  NUMFLOOR      0
#define  NUMROUND      (BASE/2)
#define  NUMCEILING    (BASE-1)

#define  ROUND(x)  NumToShort(x,NUMROUND)
#define  FLOOR(x)  NumToShort(x,NUMFLOOR)

/* Unit conversion */
#define  InchesToCM(x)  (((x) * 254L + 50) / 100)
#define  CMToInches(x)  (((x) * 100L + 127) / 254)

void     DestroyAbortWnd(void) ;
VOID     TranslateString(TCHAR *);

BOOL CALLBACK AbortProc(HDC hPrintDC, INT reserved)
{
    MSG msg;

    while( !fAbort && PeekMessage((LPMSG)&msg, NULL, 0, 0, TRUE) )
    {
       if( !hAbortDlgWnd || !IsDialogMessage( hAbortDlgWnd, (LPMSG)&msg ) )
       {
          TranslateMessage( (LPMSG)&msg );
          DispatchMessage( (LPMSG)&msg );
       }
    }
    return( !fAbort );

    UNREFERENCED_PARAMETER(hPrintDC);
    UNREFERENCED_PARAMETER(reserved);
}


INT_PTR CALLBACK AbortDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    static HMENU hSysMenu;

    switch( msg )
    {
       case WM_COMMAND:
          fAbort= TRUE;
          DestroyAbortWnd();
          return( TRUE );

       case WM_INITDIALOG:
          hSysMenu= GetSystemMenu( hwnd, FALSE );
          SetDlgItemText( hwnd, ID_FILENAME,
             fUntitled ? szUntitled : PFileInPath(szFileName) );
          SetFocus( hwnd );
          return( TRUE );

       case WM_INITMENU:
          EnableMenuItem( hSysMenu, (WORD)SC_CLOSE, (DWORD)MF_GRAYED );
          return( TRUE );
    }
    return( FALSE );

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}


/*
 * print out the translated header/footer string in proper position.
 * uses globals xPrintWidth, ...
 *
 * returns 1 if line was printed, otherwise 0.
 */

INT PrintHeaderFooter (HDC hDC, INT nHF)
{
    SIZE    Size;    // to compute the width of each string
    INT     yPos;    // y position to print
    INT     xPos;    // x position to print

    if( *chPageText[nHF] == 0 )   // see if anything to do
        return 0;                // we didn't print

    TranslateString( chPageText[nHF] );

    // figure out the y position we are printing

    if( nHF == HEADER )
        yPos= dyTop;
    else
        yPos= yPrintRes - dyBottom - yPrintChar;

    // print out the various strings
    // N.B. could overprint which seems ok for now

    if( *chBuff[LEFT] )     // left string
    {
        TextOut( hDC, dxLeft, yPos, chBuff[LEFT], lstrlen(chBuff[LEFT]) );
    }

    if( *chBuff[CENTER] )   // center string
    {
        GetTextExtentPoint32( hDC, chBuff[CENTER], lstrlen(chBuff[CENTER]), &Size );
        xPos= (xPrintRes-dxRight+dxLeft)/2 - Size.cx/2;
        TextOut( hDC, xPos, yPos, chBuff[CENTER], lstrlen(chBuff[CENTER]) );
    }

    if( *chBuff[RIGHT] )    // right string
    {
        GetTextExtentPoint32( hDC, chBuff[RIGHT], lstrlen(chBuff[RIGHT]), &Size );
        xPos= xPrintRes - dxRight - Size.cx;
        TextOut( hDC, xPos, yPos, chBuff[RIGHT], lstrlen(chBuff[RIGHT]) );
    }
    return 1;              // we did print something
}
/*
 * GetResolutions
 *
 * Gets printer resolutions.
 * sets globals: xPrintRes, yPrintRes, yPixInch
 *
 */

VOID GetResolutions(HDC hPrintDC)
{
    xPrintRes = GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes = GetDeviceCaps( hPrintDC, VERTRES );
    yPixInch  = GetDeviceCaps( hPrintDC, LOGPIXELSY );

    xPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALWIDTH );
    yPhysRes  = GetDeviceCaps( hPrintDC, PHYSICALHEIGHT );

    xPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETX );
    yPhysOff  = GetDeviceCaps( hPrintDC, PHYSICALOFFSETY );
}

/* GetMoreText
 *
 * Gets the next line of text from the MLE, returning a pointer
 * to the beginning and just past the end.
 *
 * linenum    - index into MLE                                   (IN)
 * pStartText - start of MLE                                     (IN)
 * ppsStr     - pointer to where to put pointer to start of text (OUT)
 * ppEOL      - pointer to where to put pointer to just past EOL (OUT)
 *
 */

VOID GetMoreText( INT linenum, PTCHAR pStartText, PTCHAR* ppsStr, PTCHAR* ppEOL )
{
    INT Offset;        // offset in 'chars' into edit buffer
    INT nChars;        // number of chars in line

    Offset= (INT)SendMessage( hwndEdit, EM_LINEINDEX, linenum, 0 );

    nChars= (INT)SendMessage( hwndEdit, EM_LINELENGTH, Offset, 0 );

    *ppsStr= pStartText + Offset;

    *ppEOL= (pStartText+Offset) + nChars;
}

#ifdef DBGPRINT
TCHAR dbuf[100];
VOID ShowMargins( HDC hPrintDC )
{
    INT xPrintRes, yPrintRes;
    RECT rct;
    HBRUSH hBrush;

    xPrintRes= GetDeviceCaps( hPrintDC, HORZRES );
    yPrintRes= GetDeviceCaps( hPrintDC, VERTRES );
    hBrush= GetStockObject( BLACK_BRUSH );

    if ( hBrush )
    {
        SetRect( &rct, 0,0,xPrintRes-1, yPrintRes-1 );
        FrameRect( hPrintDC, &rct, hBrush );
        SetRect( &rct, dxLeft, dyTop, xPrintRes-dxRight, yPrintRes-dyBottom );
        FrameRect( hPrintDC, &rct, hBrush );
    }
}

VOID PrintLogFont( LOGFONT lf )
{
    wsprintf(dbuf,TEXT("lfHeight          %d\n"), lf.lfHeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWidth           %d\n"), lf.lfWidth         ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfEscapement      %d\n"), lf. lfEscapement   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOrientation     %d\n"), lf.lfOrientation   ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfWeight          %d\n"), lf.lfWeight        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfItalic          %d\n"), lf.lfItalic        ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfUnderline       %d\n"), lf.lfUnderline     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfStrikeOut       %d\n"), lf.lfStrikeOut     ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfCharSet         %d\n"), lf.lfCharSet       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfOutPrecision    %d\n"), lf.lfOutPrecision  ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfClipPrecison    %d\n"), lf.lfClipPrecision ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfQuality         %d\n"), lf.lfQuality       ); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfPitchAndFamily  %d\n"), lf.lfPitchAndFamily); ODS(dbuf);
    wsprintf(dbuf,TEXT("lfFaceName        %s\n"), lf.lfFaceName      ); ODS(dbuf);
}
#endif

// GetPrinterDCviaDialog
//
// Use the common dialog PrintDlgEx() function to get a printer DC to print to.
//
// Returns: valid HDC or INVALID_HANDLE_VALUE if error.
//

HDC GetPrinterDCviaDialog( VOID )
{
    PRINTDLGEX pdTemp;
    HDC hDC;
    HRESULT hRes;

    //
    // Get the page setup information
    //

    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
    }

    //
    // Initialize the dialog structure
    //

    ZeroMemory( &pdTemp, sizeof(pdTemp) );

    pdTemp.lStructSize= sizeof(pdTemp);

    pdTemp.hwndOwner= hwndNP;
    pdTemp.nStartPage= START_PAGE_GENERAL;
    
    // FEATURE: We turn off multiple copies seen 'notepad' doesn't do it.
    //          But this will work on many print drivers esp. if using EMF printing.
    //          We may want to add our own code to do the multiple copies

    pdTemp.Flags= PD_NOPAGENUMS  | PD_RETURNDC | PD_NOCURRENTPAGE |
                  PD_USEDEVMODECOPIESANDCOLLATE  |
                  PD_NOSELECTION | 0;

    // if use set printer in PageSetup, use it here too.

    if( g_PageSetupDlg.hDevMode )
    {
        pdTemp.hDevMode= g_PageSetupDlg.hDevMode;
    }

    if( g_PageSetupDlg.hDevNames )
    {
        pdTemp.hDevNames= g_PageSetupDlg.hDevNames;
    }


    //
    // let user select printer
    //

    hRes= PrintDlgEx( &pdTemp );

    //
    // get DC if valid return
    //

    hDC= INVALID_HANDLE_VALUE;

    if( hRes == S_OK )
    {
        if( (pdTemp.dwResultAction == PD_RESULT_PRINT) || (pdTemp.dwResultAction == PD_RESULT_APPLY) )
        {
            if( pdTemp.dwResultAction == PD_RESULT_PRINT )
            {
                hDC= pdTemp.hDC;
            }
            
            //
            // Get the page setup information for the printer selected in case it was
            // the first printer added by the user through notepad.
            //
            if( !g_PageSetupDlg.hDevMode ) 
            {
                g_PageSetupDlg.Flags |= (PSD_RETURNDEFAULT|PSD_NOWARNING );
                PageSetupDlg(&g_PageSetupDlg);
                g_PageSetupDlg.Flags &= ~(PSD_RETURNDEFAULT|PSD_NOWARNING);
            }

            // change devmode if user pressed print or apply
            g_PageSetupDlg.hDevMode= pdTemp.hDevMode;
            g_PageSetupDlg.hDevNames= pdTemp.hDevNames;
        }       
    }

    // FEATURE: free hDevNames

    return( hDC );
}

INT NpPrint( PRINT_DIALOG_TYPE type)
{
    HDC hPrintDC;

    SetCursor( hWaitCursor );

    switch( type )
    {
        case UseDialog:
            hPrintDC= GetPrinterDCviaDialog();
            break;
        case NoDialogNonDefault:
            hPrintDC= GetNonDefPrinterDC();
            break;
        case DoNotUseDialog:
        default:
            hPrintDC= GetPrinterDC();
            break;
    }

    if( hPrintDC == INVALID_HANDLE_VALUE )
    {
        SetCursor( hStdCursor );
        return( 0 );   // message already given
    }

    return( NpPrintGivenDC( hPrintDC ) );

}

INT NpPrintGivenDC( HDC hPrintDC )
{
    HANDLE     hText= NULL;          // handle to MLE text
    HFONT      hPrintFont= NULL;     // font to print with
    HANDLE     hPrevFont= NULL;      // previous font in hPrintDC

    BOOL       fPageStarted= FALSE;  // true if StartPage called for this page
    BOOL       fDocStarted=  FALSE;  // true if StartDoc called
    PTCHAR     pStartText= NULL;     // start of edit text (locked hText)
    TEXTMETRIC Metrics;
    TCHAR      msgbuf[MAX_PATH];     // Document name for tracking print job
    INT        nLinesPerPage;        // not inc. header and footer
    // iErr will contain the first error discovered ie it is sticky
    // This will be the value returned by this function.
    // It does not need to translate SP_* errors except for SP_ERROR which should be
    // GetLastError() right after it is first detected.
    INT        iErr=0;               // error return
    DOCINFO    DocInfo;
    LOGFONT    lfPrintFont;          // local version of FontStruct
    LCID       lcid;                 // locale id

    fAbort = FALSE;
    hAbortDlgWnd= NULL;

    SetCursor( hWaitCursor );

    GetResolutions( hPrintDC );

    // Get the time and date for use in the header or trailer.
    // We use the GetDateFormat and GetTimeFormat to get the
    // internationalized versions.

    GetLocalTime( &PrintTime );       // use local, not gmt

    lcid= GetUserDefaultLCID();

    GetDateFormat( lcid, DATE_LONGDATE, &PrintTime, NULL, szFormattedDate, MAXDATE );

    GetTimeFormat( lcid, 0,             &PrintTime, NULL, szFormattedTime, MAXTIME );


   /*
    * This part is to select the current font to the printer device.
    * We have to change the height because FontStruct was created
    * assuming the display.  Using the remembered pointsize, calculate
    * the new height.
    */

    lfPrintFont= FontStruct;                          // make local copy
    lfPrintFont.lfHeight= -(iPointSize*yPixInch)/(72*10);
    lfPrintFont.lfWidth= 0;

    //
    // convert margins to pixels
    // ptPaperSize is the physical paper size, not the printable area.
    // do the mapping in physical units
    //

    SetMapMode( hPrintDC, MM_ANISOTROPIC );

    SetViewportExtEx( hPrintDC,
                      xPhysRes,
                      yPhysRes,
                      NULL );

    SetWindowExtEx( hPrintDC,
                    g_PageSetupDlg.ptPaperSize.x,
                    g_PageSetupDlg.ptPaperSize.y,
                    NULL );

    rtMargin = g_PageSetupDlg.rtMargin;

    LPtoDP( hPrintDC, (LPPOINT) &rtMargin, 2 );

    SetMapMode( hPrintDC,MM_TEXT );    // restore to mm_text mode

    hPrintFont= CreateFontIndirect(&lfPrintFont);

    if( !hPrintFont )
    {
        goto ErrorExit;
    }

    hPrevFont= SelectObject( hPrintDC, hPrintFont );
    if( !hPrevFont )
    {
        goto ErrorExit;
    }

    SetBkMode( hPrintDC, TRANSPARENT );
    if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
    {
        goto ErrorExit;
    }

    // The font may not a scalable (say on a bubblejet printer)
    // In this case, just pick some font
    // For example, FixedSys 9 pt would be non-scalable

    if( !(Metrics.tmPitchAndFamily & (TMPF_VECTOR | TMPF_TRUETYPE )) )
    {
        // remove just created font

        hPrintFont= SelectObject( hPrintDC, hPrevFont );  // get old font
        DeleteObject( hPrintFont );

        memset( lfPrintFont.lfFaceName, 0, LF_FACESIZE*sizeof(TCHAR) );

        hPrintFont= CreateFontIndirect( &lfPrintFont );
        if( !hPrintFont )
        {
            goto ErrorExit;
        }

        hPrevFont= SelectObject( hPrintDC, hPrintFont );
        if( !hPrevFont )
        {
            goto ErrorExit;
        }

        if( !GetTextMetrics( hPrintDC, (LPTEXTMETRIC) &Metrics ) )
        {
            goto ErrorExit;
        }
    }
    yPrintChar= Metrics.tmHeight+Metrics.tmExternalLeading;  /* the height */

    tabSize = Metrics.tmAveCharWidth * 8; /* 8 ave char width pixels for tabs */

    // compute margins in pixels

    dxLeft=   max(rtMargin.left - xPhysOff,0);
    dxRight=  max(rtMargin.right  - (xPhysRes - xPrintRes - xPhysOff), 0 );
    dyTop=    max(rtMargin.top  - yPhysOff,0);
    dyBottom= max(rtMargin.bottom - (yPhysRes - yPrintRes - yPhysOff), 0 );

#ifdef DBGPRINT
    {
        TCHAR dbuf[100];
        RECT rt= g_PageSetupDlg.rtMargin;
        POINT pt;

        wsprintf(dbuf,TEXT("Print pOffx %d  pOffy %d\n"),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETX),
                 GetDeviceCaps(hPrintDC, PHYSICALOFFSETY));
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALWIDTH: %d\n"), xPhysRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("HORZRES: %d\n"),xPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PHYSICALOFFSETX: %d\n"),xPhysOff);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("LOGPIXELSX: %d\n"),
                 GetDeviceCaps(hPrintDC,LOGPIXELSX));
        ODS(dbuf);

        GetViewportOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Viewport org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        GetWindowOrgEx( hPrintDC, (LPPOINT) &pt );
        wsprintf(dbuf,TEXT("Window org:  %d %d\n"), pt.x, pt.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PrintRes x: %d  y: %d\n"),xPrintRes, yPrintRes);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("PaperSize  x: %d  y: %d\n"),
                 g_PageSetupDlg.ptPaperSize.x,
                 g_PageSetupDlg.ptPaperSize.y );
        ODS(dbuf);
        wsprintf(dbuf,TEXT("unit margins:  l: %d  r: %d  t: %d  b: %d\n"),
                 rt.left, rt.right, rt.top, rt.bottom);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("pixel margins: l: %d  r: %d  t: %d  b: %d\n"),
                 rtMargin.left, rtMargin.right, rtMargin.top, rtMargin.bottom);
        ODS(dbuf);

        wsprintf(dbuf,TEXT("dxLeft %d  dxRight %d\n"),dxLeft,dxRight);
        ODS(dbuf);
        wsprintf(dbuf,TEXT("dyTop %d  dyBot %d\n"),dyTop,dyBottom);
        ODS(dbuf);
    }
#endif


    /* Number of lines on a page with margins  */
    /* two lines are used by header and footer */
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    if( *chPageText[HEADER] )
        nLinesPerPage--;
    if( *chPageText[FOOTER] )
        nLinesPerPage--;


    /*
    ** There was a bug in NT once where a printer driver would
    ** return a font that was larger than the page size which
    ** would then cause Notepad to constantly print blank pages
    ** To keep from doing this we check to see if we can fit ANYTHING
    ** on a page, if not then there is a problem so quit.  MarkRi 8/92
    */
    if( nLinesPerPage <= 0 )
    {
FontTooBig:
        MessageBox( hwndNP, szFontTooBig, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION );

        SetLastError(0);          // no error

ErrorExit:
        iErr= GetLastError();     // remember the first error

ExitWithThisError:                // preserve iErr (return SP_* errors)

        if( hPrevFont )
        {
            SelectObject( hPrintDC, hPrevFont );
            DeleteObject( hPrintFont );
        }

        if( pStartText )          // were able to lock hText
            LocalUnlock( hText );

        if( fPageStarted )
        {
            if( EndPage( hPrintDC ) <= 0 )
            {
                // if iErr not already set then set it to the new error code.
                if( iErr == 0 )
                {
                    iErr= GetLastError();
                }
       
            }
        }    

        if( fDocStarted )
        {
            if( fAbort ) {
               AbortDoc( hPrintDC );
            }
            else {
               if( EndDoc( hPrintDC ) <= 0 )
               {
                   // if iErr not already set then set it to the new error code.
                   if (iErr == 0)
                   {
                       iErr= GetLastError();
                   }
               }
            }
        }    

        DeleteDC( hPrintDC );

        DestroyAbortWnd();

        SetCursor( hStdCursor );

        if (!fAbort)
        {
            return( iErr );
        }
        else
        {
            return( SP_USERABORT );
        }
    }



    if( (iErr= SetAbortProc (hPrintDC, AbortProc)) < 0 )
    {
        goto ExitWithThisError;
    }

    // get printer to MLE text
    hText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hText )
    {
        goto ErrorExit;
    }
    pStartText= LocalLock( hText );
    if( !pStartText )
    {
        goto ErrorExit;
    }

    GetWindowText( hwndNP, msgbuf, CharSizeOf(msgbuf) );

    EnableWindow( hwndNP, FALSE );    // Disable window to prevent reentrancy

    hAbortDlgWnd= CreateDialog(         hInstanceNP,
                              (LPTSTR)  MAKEINTRESOURCE(IDD_ABORTPRINT),
                                        hwndNP,
                                        AbortDlgProc);

    if( !hAbortDlgWnd )
    {
        goto ErrorExit;
    }

    DocInfo.cbSize= sizeof(DOCINFO);
    DocInfo.lpszDocName= msgbuf;
    DocInfo.lpszOutput= NULL;
    DocInfo.lpszDatatype= NULL; // Type of data used to record print job
    DocInfo.fwType= 0; // not DI_APPBANDING

    SetLastError(0);      // clear error so it reflects errors in the future

    if( StartDoc( hPrintDC, &DocInfo ) <= 0 )
    {
        iErr = GetLastError();
        goto ExitWithThisError;
    }
    fDocStarted= TRUE;


    // Basicly, this is just a loop surrounding the DrawTextEx API.
    // We have to calculate the printable area which will not include
    // the header and footer area.
    {
    INT iTextLeft;        // amount of text left to print
    INT iSta;              // status
    UINT dwDTFormat;       // drawtext flags
    DRAWTEXTPARAMS dtParm; // drawtext control
    RECT rect;             // rectangle to draw in
    UINT dwDTRigh = 0;     // drawtext flags (RTL)

    iPageNum= 1;
    fPageStarted= FALSE;

    // calculate the size of the printable area for the text
    // not including the header and footer

    ZeroMemory( &rect, sizeof(rect) );

    rect.left= dxLeft; rect.right= xPrintRes-dxRight;
    rect.top=  dyTop;  rect.bottom= yPrintRes-dyBottom;

    if( *chPageText[HEADER] != 0 )
    {
        rect.top += yPrintChar;
    }

    if( *chPageText[FOOTER] != 0 )
    {
        rect.bottom -= yPrintChar;
    }

    iTextLeft= lstrlen(pStartText);

    //Get the edit control direction.
    if (GetWindowLong(hwndEdit, GWL_EXSTYLE) & WS_EX_RTLREADING)
        dwDTRigh = DT_RIGHT | DT_RTLREADING;


    while(  !fAbort && (iTextLeft>0) )
    {
        #define MAXSTATUS 100
        TCHAR szPagePrinting[MAXSTATUS+1];

        // update abort dialog box to inform user where we are in the printing
        _sntprintf( szPagePrinting, MAXSTATUS, szCurrentPage, iPageNum ); 
        SetDlgItemText( hAbortDlgWnd, ID_PAGENUMBER, szPagePrinting );

        PrintHeaderFooter( hPrintDC, HEADER );

        ZeroMemory( &dtParm, sizeof(dtParm) );

        dtParm.cbSize= sizeof(dtParm);
        dtParm.iTabLength= tabSize;

        dwDTFormat= DT_EDITCONTROL | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX |
                    DT_WORDBREAK | dwDTRigh | 0;

        if( StartPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= TRUE;

        #ifdef DBGPRINT
        ShowMargins(hPrintDC);
        #endif

        /* Ignore errors in printing.  EndPage or StartPage will find them */
        iSta= DrawTextEx( hPrintDC,
                          pStartText,
                          iTextLeft,
                          &rect,
                          dwDTFormat,
                          &dtParm);

        PrintHeaderFooter( hPrintDC, FOOTER );

        if( EndPage( hPrintDC ) <= 0 )
        {
            iErr= GetLastError();            
            goto ExitWithThisError;
        }
        fPageStarted= FALSE;

        iPageNum++;

        // if we can't print a single character (too big perhaps)
        // just bail now.
        if( dtParm.uiLengthDrawn == 0 )
        {
            goto FontTooBig;
        }

        pStartText += dtParm.uiLengthDrawn;
        iTextLeft  -= dtParm.uiLengthDrawn;

    }


    }

    iErr=0;        // no errors
    goto ExitWithThisError;

}


VOID DestroyAbortWnd (void)
{
    EnableWindow(hwndNP, TRUE);
    DestroyWindow(hAbortDlgWnd);
    hAbortDlgWnd = NULL;
}



const DWORD s_PageSetupHelpIDs[] = {
    ID_HEADER_LABEL,       IDH_PAGE_HEADER,
    ID_HEADER,             IDH_PAGE_HEADER,
    ID_FOOTER_LABEL,       IDH_PAGE_FOOTER,
    ID_FOOTER,             IDH_PAGE_FOOTER,
    0, 0
};

/*******************************************************************************
*
*  PageSetupHookProc
*
*  DESCRIPTION:
*     Callback procedure for the PageSetup common dialog box.
*
*  PARAMETERS:
*     hWnd, handle of PageSetup window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

UINT_PTR CALLBACK PageSetupHookProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    INT   id;    /* ID of dialog edit controls */
    POINT pt;

    switch (Message)
    {

        case WM_INITDIALOG:
            for (id = ID_HEADER; id <= ID_FOOTER; id++)
            {
                SendDlgItemMessage(hWnd, id, EM_LIMITTEXT, PT_LEN-1, 0L);
                SetDlgItemText(hWnd, id, chPageText[id - ID_HEADER]);
            }

            SendDlgItemMessage(hWnd, ID_HEADER, EM_SETSEL, 0,
                               MAKELONG(0, PT_LEN-1));
            return TRUE;

        case WM_DESTROY:
            //  We don't know if the user hit OK or Cancel, so we don't
            //  want to replace our real copies until we know!  We _should_ get
            //  a notification from the common dialog code!
            for( id = ID_HEADER; id <= ID_FOOTER; id++ )
            {
                GetDlgItemText(hWnd, id, chPageTextTemp[id - ID_HEADER],PT_LEN);
            }
            break;

        case WM_HELP:
            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID(((LPHELPINFO) lParam)-> hItemHandle);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, szHelpFile,
                HELP_WM_HELP, (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            //
            //  If the user clicks on any of our labels, then the wParam will
            //  be the hwnd of the dialog, not the static control.  WinHelp()
            //  handles this, but because we hook the dialog, we must catch it
            //  first.
            //
            if( hWnd == (HWND) wParam )
            {

                GetCursorPos(&pt);
                ScreenToClient(hWnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hWnd, pt);

            }

            //
            //  We only want to intercept help messages for controls that we are
            //  responsible for.
            //

            id = GetDlgCtrlID((HWND) wParam);

            if (id < ID_HEADER || id > ID_FOOTER_LABEL)
                break;

            WinHelp((HWND) wParam, szHelpFile, HELP_CONTEXTMENU,
                (UINT_PTR) (LPVOID) s_PageSetupHelpIDs);
            return TRUE;

    }

    return FALSE;

}

/***************************************************************************
 * VOID TranslateString(TCHAR *src)
 *
 * purpose:
 *    translate a header/footer strings
 *
 * supports the following:
 *
 *    &&    insert a & char
 *    &f    current file name or (untitled)
 *    &d    date in Day Month Year
 *    &t    time
 *    &p    page number
 *    &p+num  set first page number to num
 *
 * Alignment:
 *    &l, &c, &r for left, center, right
 *
 * params:
 *    IN/OUT  src     this is the string to translate
 *
 *
 * used by:
 *    Header Footer stuff
 *
 * uses:
 *    lots of c lib stuff
 *
 ***************************************************************************/


VOID TranslateString (TCHAR * src)
{
    TCHAR        buf[MAX_PATH];
    TCHAR       *ptr;
    INT          page;
    INT          nAlign=CENTER;    // current string to add chars to
    INT          foo;
    INT          nIndex[RIGHT+1];  // current lengths of (left,center,right)
    struct tm   *newtime;
    time_t       long_time;
    INT          iLen;             // length of strings

    nIndex[LEFT]   = 0;
    nIndex[CENTER] = 0;
    nIndex[RIGHT]  = 0;


    /* Get the time we need in case we use &t. */
    time (&long_time);
    newtime = localtime (&long_time);


    while (*src)   /* look at all of source */
    {
        while (*src && *src != TEXT('&'))
        {
            chBuff[nAlign][nIndex[nAlign]] = *src++;
            nIndex[nAlign] += 1;
        }

        if (*src == TEXT('&'))   /* is it the escape char? */
        {
            src++;

            if (*src == szLetters[0] || *src == szLetters[1])
            {                      /* &f file name (no path) */
                if (!fUntitled)
                {
                    GetFileTitle(szFileName, buf, CharSizeOf(buf));
                }
                else
                {
                    lstrcpy(buf, szUntitled);
                }

                /* Copy to the currently aligned string. */
                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );

                    /* Update insertion position. */
                    nIndex[nAlign] += lstrlen (buf);
                }

            }
            else if (*src == szLetters[2] || *src == szLetters[3])  /* &P or &P+num page */
            {
                src++;
                page = 0;
                if (*src == TEXT('+'))       /* &p+num case */
                {
                    src++;
                    while (_istdigit(*src))
                    {
                        /* Convert to int on-the-fly*/
                        page = (10*page) + (*src) - TEXT('0');
                        src++;
                    }
                }

                wsprintf( buf, TEXT("%d"), iPageNum+page );  // convert to chars

                if( nIndex[nAlign] + lstrlen(buf) < MAXTITLE )
                {
                    lstrcpy( chBuff[nAlign] + nIndex[nAlign], buf );
                    nIndex[nAlign] += lstrlen (buf);
                }
                src--;
            }
            else if (*src == szLetters[4] || *src == szLetters[5])   /* &t time */
            {
                iLen= lstrlen( szFormattedTime );

                /* extract time */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedTime, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == szLetters[6] || *src == szLetters[7])   /* &d date */
            {
                iLen= lstrlen( szFormattedDate );

                /* extract day month day */
                if( nIndex[nAlign] + iLen < MAXTITLE )
                {
                    _tcsncpy (chBuff[nAlign] + nIndex[nAlign], szFormattedDate, iLen);
                    nIndex[nAlign] += iLen;
                }
            }
            else if (*src == TEXT('&'))       /* quote a single & */
            {
                if( nIndex[nAlign] + 1 < MAXTITLE )
                {
                    chBuff[nAlign][nIndex[nAlign]] = TEXT('&');
                    nIndex[nAlign] += 1;
                }
            }
            /* Set the alignment for whichever has last occured. */
            else if (*src == szLetters[8] || *src == szLetters[9])   /* &c center */
                nAlign=CENTER;
            else if (*src == szLetters[10] || *src == szLetters[11]) /* &r right */
                nAlign=RIGHT;
            else if (*src == szLetters[12] || *src == szLetters[13]) /* &d date */
                nAlign=LEFT;

            src++;
        }
     }
     /* Make sure all strings are null-terminated. */
     for (nAlign= LEFT; nAlign <= RIGHT ; nAlign++)
        chBuff[nAlign][nIndex[nAlign]] = (TCHAR) 0;

}

/* GetPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */

HANDLE GetPrinterDC (VOID)
{
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;
    HDC hDC;


    if( !g_PageSetupDlg.hDevNames )   /* Retrieve default printer if none selected. */
    {
        g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
        PageSetupDlg(&g_PageSetupDlg);
        g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;
    }

    if( !g_PageSetupDlg.hDevNames )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    lpDevNames= (LPDEVNAMES) GlobalLock (g_PageSetupDlg.hDevNames);


    lpDevMode= NULL;

    if( g_PageSetupDlg.hDevMode )
       lpDevMode= (LPDEVMODE) GlobalLock( g_PageSetupDlg.hDevMode );

    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *  will be NULL after GlobalLock()
     */

    /* The lpszOutput name is null so CreateDC will use the current setting
     * from PrintMan.
     */

    hDC= CreateDC (((LPTSTR)lpDevNames)+lpDevNames->wDriverOffset,
                      ((LPTSTR)lpDevNames)+lpDevNames->wDeviceOffset,
                      NULL,
                      lpDevMode);

    GlobalUnlock( g_PageSetupDlg.hDevNames );

    if( g_PageSetupDlg.hDevMode )
        GlobalUnlock( g_PageSetupDlg.hDevMode );


    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* GetNonDefPrinterDC() - returns printer DC or INVALID_HANDLE_VALUE if none. */
/*                        using the name of the Printer server */

HANDLE GetNonDefPrinterDC (VOID)
{
    HDC     hDC;
    HANDLE  hPrinter;
    DWORD   dwBuf;
    DRIVER_INFO_1  *di1;



    // open the printer and retrieve the driver name.
    if (!OpenPrinter(szPrinterName, &hPrinter, NULL))
    {
        return INVALID_HANDLE_VALUE;
    }

    // get the buffer size.
    GetPrinterDriver(hPrinter, NULL, 1, NULL, 0, &dwBuf);
    di1 = (DRIVER_INFO_1  *) LocalAlloc(LPTR, dwBuf);
    if (!di1)
    {
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    if (!GetPrinterDriver(hPrinter, NULL, 1, (LPBYTE) di1, dwBuf, &dwBuf))
    {
        LocalFree(di1);
        ClosePrinter(hPrinter);
        return INVALID_HANDLE_VALUE;
    }

    // Initialize the PageSetup dlg to default values.
    // using default printer's value for another printer !!
    g_PageSetupDlg.Flags |= PSD_RETURNDEFAULT;
    PageSetupDlg(&g_PageSetupDlg);
    g_PageSetupDlg.Flags &= ~PSD_RETURNDEFAULT;

    // create printer dc with default initialization.
    hDC= CreateDC (di1->pName, szPrinterName, NULL, NULL);

    // cleanup.
    LocalFree(di1);
    ClosePrinter(hPrinter);

    if( hDC == NULL )
    {
        MessageBox( hwndNP, szLoadDrvFail, szNN, MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
        return INVALID_HANDLE_VALUE;
    }

    return hDC;
}


/* PrintIt() - print the file, giving popup if some error */

void PrintIt(PRINT_DIALOG_TYPE type)
{
    INT iError;
    TCHAR* szMsg= NULL;
    TCHAR  msg[400];       // message info on error

    /* print the file */

    iError= NpPrint( type );

    if(( iError != 0) &&
       ( iError != SP_APPABORT )     &&
       ( iError != SP_USERABORT ) )
    {
        // translate any known spooler errors
        if( iError == SP_OUTOFDISK   ) iError= ERROR_DISK_FULL;
        if( iError == SP_OUTOFMEMORY ) iError= ERROR_OUTOFMEMORY;
        if( iError == SP_ERROR       ) iError= GetLastError();
        /* SP_NOTREPORTED not handled.  Does it happen? */


        //
        // iError may be 0 because the user aborted the printing.
        // Just ignore.
        //

        if( iError == 0 ) return;

        // Get system to give reasonable error message
        // These will also be internationalized.

        if(!FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           iError,
                           GetUserDefaultUILanguage(),
                           msg,  // where message will end up
                           CharSizeOf(msg), NULL ) )
        {
            szMsg= szCP;   // couldn't get system to say; give generic msg
        }
        else
        {
            szMsg= msg;
        }

        AlertBox( hwndNP, szNN, szMsg, fUntitled ? szUntitled : szFileName,
                  MB_APPLMODAL | MB_OK | MB_ICONEXCLAMATION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\npmisc.c ===
/*
 * misc notepad functions
 * Copyright (C) 1984-2000 Microsoft Corporation
 */

#include "precomp.h"

BOOL fCase = FALSE;         // Flag specifying case sensitive search 
BOOL fReverse = FALSE;      // Flag for direction of search 

extern HWND hDlgFind;       // handle to modeless FindText window 

LPTSTR ReverseScan(
    LPTSTR lpSource,
    LPTSTR lpLast,
    LPTSTR lpSearch,
    BOOL fCaseSensitive )
{
   TCHAR cLastCharU;
   TCHAR cLastCharL;
   INT   iLen;

   cLastCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cLastCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   iLen = lstrlen(lpSearch);

   if (!lpLast)
      lpLast = lpSource + lstrlen(lpSource);

   do
   {
      if (lpLast == lpSource)
         return NULL;

      --lpLast;

      if (fCaseSensitive)
      {
         if (*lpLast != *lpSearch)
            continue;
      }
      else
      {
           if( !( *lpLast == cLastCharU || *lpLast == cLastCharL ) )
            continue;
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpLast, lpSearch, iLen))
            break;
      }
      else
      {
         //
         // compare whole string using locale specific comparison.
         // do not use C runtime version since it may be wrong.
         //

         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpLast,   iLen,
                    lpSearch, iLen) )
            break;
      }
   } while (TRUE);

   return lpLast;
}

LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive )
{
   TCHAR cFirstCharU;
   TCHAR cFirstCharL;
   int iLen = lstrlen(lpSearch);

   cFirstCharU= (TCHAR) (INT_PTR) CharUpper( (LPTSTR)(INT_PTR)(*lpSearch) );
   cFirstCharL= (TCHAR) (INT_PTR) CharLower( (LPTSTR)(INT_PTR)(*lpSearch) );

   while (*lpSource)
   {
      if (fCaseSensitive)
      {
         if (*lpSource != *lpSearch)
         {
            lpSource++;
            continue;
         }
      }
      else
      {
         if( !( *lpSource == cFirstCharU || *lpSource == cFirstCharL ) )
         {
            lpSource++;
            continue;
         }
      }

      if (fCaseSensitive)
      {
         if (!_tcsncmp( lpSource, lpSearch, iLen))
            break;
      }
      else
      {
         if( 2 == CompareString( LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE | SORT_STRINGSORT | NORM_STOP_ON_NULL,
                    lpSource, iLen,
                    lpSearch, iLen) )
            break;
      }

      lpSource++;
   }

   return *lpSource ? lpSource : NULL;
}


// search forward or backward in the edit control text for the given pattern
// It is the responsibility of the caller to set the cursor

BOOL Search (TCHAR * szKey)
{
    BOOL      bStatus= FALSE;
    TCHAR   * pStart, *pMatch;
    DWORD     StartIndex, LineNum, EndIndex;
    DWORD     SelStart, SelEnd, i;
    HANDLE    hEText;           // handle to edit text
    UINT      uSelState;
    HMENU     hMenu;
    BOOL      bSelectAll = FALSE;


    if (!*szKey)
        return( bStatus );

    SendMessage(hwndEdit, EM_GETSEL, (WPARAM)&SelStart, (LPARAM)&SelEnd);


    // when we finish the search, we highlight the text found, and continue 
    // the search after the end of the highlighted position (in forward 
    // case) or from the begining of the highlighted position in the reverse
    // direction (in reverse case). this would break if the user has 
    // selected all text. this hack would take care of it. (this is consistent
    // with VC editors' search too.

    hMenu = GetMenu(hwndNP);
    uSelState = GetMenuState(GetSubMenu(hMenu, 1), M_SELECTALL, MF_BYCOMMAND);
    if (uSelState == MF_GRAYED)
    {
        bSelectAll = TRUE;
        SelStart = SelEnd =0;
    }


    //
    // get pointer to edit control text to search
    //

    hEText= (HANDLE) SendMessage( hwndEdit, EM_GETHANDLE, 0, 0 );
    if( !hEText )  // silently return if we can't get it
    {
        return( bStatus );
    }
    pStart= LocalLock( hEText );
    if( !pStart )
    {
        return( bStatus );
    }

    if (fReverse)
    {
        // Get current line number 
        LineNum= (DWORD)SendMessage(hwndEdit, EM_LINEFROMCHAR, SelStart, 0);
        // Get index to start of the line
        StartIndex= (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, LineNum, 0);
        // Set upper limit for search text
        EndIndex= SelStart;
        pMatch= NULL;

        // Search line by line, from LineNum to 0
        i = LineNum;
        while (TRUE)
        {
            pMatch= ReverseScan(pStart+StartIndex,pStart+EndIndex,szKey,fCase);
            if (pMatch)
               break;
            // current StartIndex is the upper limit for the next search 
            EndIndex= StartIndex;

            if (i)
            {
                // Get start of the next line
                i-- ;
                StartIndex = (DWORD)SendMessage(hwndEdit, EM_LINEINDEX, i, 0);
            }
            else
               break ;
        }
    }
    else
    {
            pMatch= ForwardScan(pStart+SelEnd, szKey, fCase);
    }

    LocalUnlock(hEText);

    if (pMatch == NULL)
    {
        //
        // alert user on not finding any text unless it is replace all
        //
        if( !(FR.Flags & FR_REPLACEALL) )
        {
            HANDLE hPrevCursor= SetCursor( hStdCursor );
            AlertBox( hDlgFind ? hDlgFind : hwndNP,
                      szNN,
                      szCFS,
                      szSearch,
                      MB_APPLMODAL | MB_OK | MB_ICONINFORMATION);
            SetCursor( hPrevCursor );
        }
    }
    else
    {
        SelStart = (DWORD)(pMatch - pStart);
        SendMessage( hwndEdit, EM_SETSEL, SelStart, SelStart+lstrlen(szKey));

        // since we are selecting the found text, enable SelectAll again.
        if (bSelectAll)
        {
            EnableMenuItem(GetSubMenu(hMenu, 1), M_SELECTALL, MF_ENABLED);
        }

        //
        // show the selected text unless it is replace all
        //

        if( !(FR.Flags & FR_REPLACEALL) )
        {
            SendMessage(hwndEdit, EM_SCROLLCARET, 0, 0);
            UpdateStatusBar( TRUE );
        }
        bStatus= TRUE;   // found
    }

    return( bStatus );
}

// Recreate notepad edit window, get text from old window and put in new window. 
// Called when user changes style from wrap on/off 
//
// Called with the style of the new window
//

BOOL NpReCreate( long style )
{
    RECT    rcT1;
    HWND    hwndT1;
    HANDLE  hT1;
    int     cchTextNew;
    TCHAR*  pchText;
    BOOL    fWrapIsOn = ((style & WS_HSCROLL) != 0);
    HCURSOR hPrevCursor;
    BOOL    bModified;     // modify flag from old edit buffer

    // if wordwrap, remove soft carriage returns 

    hPrevCursor= SetCursor( hWaitCursor );     // this may take some time...
    if( fWrapIsOn ) 
    {
        GotoAndScrollInView(1);  // get around MLE bug

        SendMessage(hwndEdit, EM_FMTLINES, FALSE, 0L);
    }

    bModified= (SendMessage( hwndEdit, EM_GETMODIFY, 0,0 ) != 0);

    cchTextNew= (int)SendMessage( hwndEdit, WM_GETTEXTLENGTH, 0, 0L );
    hT1= LocalAlloc( LMEM_MOVEABLE, ByteCountOf(cchTextNew + 1) );
    if( !hT1 )
    {
        // failed, restore wordwrap; insert soft carriage returns
        if( fWrapIsOn )
        {
            SendMessage(hwndEdit, EM_FMTLINES, TRUE, 0L);
        }
        SetCursor( hPrevCursor );
        return FALSE;
    }

    GetClientRect( hwndNP, (LPRECT)&rcT1 );

    //
    // save the current edit control text.
    //

    pchText= LocalLock (hT1);
    SendMessage( hwndEdit, WM_GETTEXT, cchTextNew+1, (LPARAM)pchText );
    hwndT1= CreateWindowEx( WS_EX_CLIENTEDGE,
        TEXT("Edit"),
        TEXT(""), // pchText
        style,
        0,
        0,
        rcT1.right,
        rcT1.bottom,
        hwndNP,
        (HMENU)ID_EDIT,
        hInstanceNP, NULL );
    if( !hwndT1 )
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )      // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        LocalUnlock(hT1);
        LocalFree(hT1);
        return FALSE;
    }

    //
    // The user can "add" styles to the edit window after it is
    // created (like WS_EX_RTLREADING) when language packs are installed.
    // Preserve these styles when changing the word wrap.
    //

    SetWindowLong( hwndT1 ,
                   GWL_EXSTYLE ,
                   GetWindowLong( hwndEdit , GWL_EXSTYLE )|WS_EX_CLIENTEDGE ) ;

    // Set font before set text to save time calculating
    SendMessage( hwndT1, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0) );

    if (!SendMessage (hwndT1, WM_SETTEXT, 0, (LPARAM) pchText))
    {
        SetCursor( hPrevCursor );
        if( fWrapIsOn )   // restore wordwrap
        {
            SendMessage( hwndEdit, EM_FMTLINES, TRUE, 0L );
        }
        DestroyWindow( hwndT1 );
        LocalUnlock( hT1 );
        LocalFree( hT1 );
        return FALSE;
    }
    LocalUnlock(hT1);


    DestroyWindow( hwndEdit );     // out with the old
    hwndEdit = hwndT1;             // in with the new

    // free the earlier allocated memory in hEdit

    if (hEdit)
        LocalFree(hEdit);

    hEdit = hT1;

    // limit text for safety's sake.

    PostMessage( hwndEdit, EM_LIMITTEXT, (WPARAM)CCHNPMAX, 0L );

    ShowWindow(hwndNP, SW_SHOW);
    SendMessage( hwndEdit, EM_SETMODIFY, bModified, 0L );
    SetFocus(hwndEdit);

    SetCursor( hPrevCursor );   // restore cursor

    // redraw the status bar

    if( fStatus )
    {
        RECT rcClient;
        GetClientRect(hwndNP, &rcClient);
        NPSize(rcClient.right - rcClient.left, rcClient.bottom - rcClient.top);
        UpdateStatusBar( TRUE );
        ShowWindow( hwndStatus, SW_SHOW );
   }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\nputf.c ===
/*
 * nputf.c  - Routines for utf text processing for notepad
 *
 *   Copyright (C) 1998-2001 Microsoft Inc.
 */

#include "precomp.h"


/* IsTextUTF8
 *
 * UTF-8 is the encoding of Unicode based on Internet Society RFC2279
 * ( See http://www.cis.ohio-state.edu/htbin/rfc/rfc2279.html )
 *
 * Basicly:
 * 0000 0000-0000 007F - 0xxxxxxx  (ascii converts to 1 octet!)
 * 0000 0080-0000 07FF - 110xxxxx 10xxxxxx    ( 2 octet format)
 * 0000 0800-0000 FFFF - 1110xxxx 10xxxxxx 10xxxxxx (3 octet format)
 * (this keeps going for 32 bit unicode) 
 * 
 *
 * Return value:  TRUE, if the text is in UTF-8 format.
 *                FALSE, if the text is not in UTF-8 format.
 *                We will also return FALSE is it is only 7-bit ascii, so the right code page
 *                will be used.
 *
 *                Actually for 7 bit ascii, it doesn't matter which code page we use, but
 *                notepad will remember that it is utf-8 and "save" or "save as" will store
 *                the file with a UTF-8 BOM.  Not cool.
 */


INT IsTextUTF8( LPSTR lpstrInputStream, INT iLen )
{
    INT   i;
    DWORD cOctets;  // octets to go in this UTF-8 encoded character
    UCHAR chr;
    BOOL  bAllAscii= TRUE;

    cOctets= 0;
    for( i=0; i < iLen; i++ ) {
        chr= *(lpstrInputStream+i);

        if( (chr&0x80) != 0 ) bAllAscii= FALSE;

        if( cOctets == 0 )  {
            //
            // 7 bit ascii after 7 bit ascii is just fine.  Handle start of encoding case.
            //
            if( chr >= 0x80 ) {  
               //
               // count of the leading 1 bits is the number of characters encoded
               //
               do {
                  chr <<= 1;
                  cOctets++;
               }
               while( (chr&0x80) != 0 );

               cOctets--;                        // count includes this character
               if( cOctets == 0 ) return FALSE;  // must start with 11xxxxxx
            }
        }
        else {
            // non-leading bytes must start as 10xxxxxx
            if( (chr&0xC0) != 0x80 ) {
                return FALSE;
            }
            cOctets--;                           // processed another octet in encoding
        }
    }

    //
    // End of text.  Check for consistency.
    //

    if( cOctets > 0 ) {   // anything left over at the end is an error
        return FALSE;
    }

    if( bAllAscii ) {     // Not utf-8 if all ascii.  Forces caller to use code pages for conversion
        return FALSE;
    }

    return TRUE;
}


/* IsInputTextUnicode
 * Verify if the input stream is in Unicode format.
 *
 * Return value:  TRUE, if the text is in Unicode format.
 *
 * 29 June 1998          
 */


INT IsInputTextUnicode  (LPSTR lpstrInputStream, INT iLen)
{
    INT  iResult= ~0; // turn on IS_TEXT_UNICODE_DBCS_LEADBYTE
    BOOL bUnicode;

    bUnicode= IsTextUnicode( lpstrInputStream, iLen, &iResult);

    // this code is not required as IsTextUnicode does the required checks
    // and it's legal to have a unicode char with a DBCS leading byte!

#ifdef UNUSEDCODE
{

    if (bUnicode                                         &&
       ((iResult & IS_TEXT_UNICODE_STATISTICS)    != 0 ) &&
       ((iResult & (~IS_TEXT_UNICODE_STATISTICS)) == 0 )    )
    {
        CPINFO cpiInfo;
        CHAR* pch= (CHAR*)lpstrInputStream;
        INT  cb;

        //
        // If the result depends only upon statistics, check
        // to see if there is a possibility of DBCS.
        // Only do this check if the ansi code page is DBCS
        //

        GetCPInfo( CP_ACP, &cpiInfo);

        if( cpiInfo.MaxCharSize > 1 )
        {
            for( cb=0; cb<iLen; cb++ )
            {
                if( IsDBCSLeadByte(*pch++) )
                {
                    return FALSE;
                }
            }
        }
     }
}

#endif

     return bUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\mkuni\mkuni.c ===
/****************************************************************************

    PROGRAM: MkUni.c

    PURPOSE: Creates a text file with unicode characters

    FUNCTIONS:

****************************************************************************/

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "mkuni.h"


#define REVERSE    0
#define LINE_SIZE  1000

#define ASCIIEOL TEXT("\r\n")
#define UNILINESEP 0x2028
#define UNIPARASEP 0x2029

struct __range {
	int	low;
	int	high;
	LPTSTR	pDes;
} range[] = {
            {0x20,  0x7f,   TEXT("ANSI") },
            {0xa0,  0xff,   TEXT("Latin") },
            {0x100, 0x17f,  TEXT("European Latin") },
            {0x180, 0x1f0,  TEXT("Extended Latin") },
            {0x250, 0x2a8,  TEXT("Standard Phonetic") },
            {0x2b0, 0x2e9,  TEXT("Modifier Letters") },
            {0x300, 0x341,  TEXT("Generic Diacritical") },
            {0x370, 0x3f5,  TEXT("Greek") },
            {0x400, 0x486,  TEXT("Cyrillic") },
            {0x490, 0x4cc,  TEXT("Extended Cyrillic") },
            {0x5b0, 0x5f5,  TEXT("Hebrew") },
            {0x0600,0x06F9, TEXT("Arabic") },
            {0x0900,0x0970, TEXT("Devanagari") },
            {0x0E00,0x0E5B, TEXT("Thai") },
            {0x1000,0x104C, TEXT("Tibetan") },
            {0x10A0,0x10FB, TEXT("Georgian") },
            {0x20a0,0x20aa, TEXT("Currency Symbols") },
            {0x2100,0x2138, TEXT("Letterlike Symbols") },
            {0x2153,0x2182, TEXT("Number Forms") },
            {0x2190,0x21ea, TEXT("Arrows") },
            {0x2200,0x22f1, TEXT("Math Operators") },
            {0x2500,0x257F, TEXT("Form and Chart Components") },
            {0x25A0,0x25EE, TEXT("Geometric Shapes") },
            {0x2600,0x266F, TEXT("Miscellaneous Dingbats") },
            {0x3000,0x303F, TEXT("CJK Symbols and Punctuations") },            
            {0x3040,0x309E, TEXT("Hiragana") },
            {0x3100,0x312C, TEXT("Bopomofo") },
            {0x3131,0x318E, TEXT("Hangul Elements") },
            {0,     0,      TEXT("terminating entry") },
            };

/****************************************************************************

    FUNCTION: putu(FILE*pf, TCHAR c)

    PURPOSE: writes a character to the file.
             (Reverses the order of leadbytes if the flag is set)

****************************************************************************/

void
putu(FILE*pf, TCHAR c)
{
    TCHAR chr=c;

    if( REVERSE )
        chr= ( c<<8 ) + ( ( c>>8 ) &0xFF);


	fwrite((void*)&chr, 1, sizeof(TCHAR), pf);
}


/****************************************************************************

    FUNCTION: putust(FILE*pf, LPTSTR pc)

    PURPOSE: writes a string to the file.

****************************************************************************/

void
putust(FILE*pf, LPTSTR pc)
{
	while (*pc)
		putu(pf, *pc++);
}


/****************************************************************************

    FUNCTION: main(int, char**)

    PURPOSE: write sample unicode file

****************************************************************************/

int _cdecl main(int argc, char**argv)
{
    struct __range*pr = range;
    int	    i;
    FILE    *pf;
    FILE    *pfo;
    char    lpstrLine[LINE_SIZE];

    if(!(pf = fopen("unicode.txt", "wb")))
        return FALSE;

    // Task1: Write all the unicode ranges and all the characters 
    // in those ranges to the output file.
    putu(pf, (TCHAR)0xfeff);
    while (pr->low != 0) {
    	putust(pf, TEXT("<<< "));
    	putust(pf, pr->pDes);
    	putust(pf, TEXT(" >>>"));
    	putust(pf, ASCIIEOL );
    	for (i=pr->low ; i<=pr->high ; i++)
    	    putu(pf, (TCHAR)i);
    	putust(pf, ASCIIEOL);
    	pr++;
    }

    putust(pf, TEXT("Unicode Line separator here ->"));
    putu(pf, UNILINESEP );
    putust(pf, TEXT("<- Unicode line separator"));
    putust( pf, ASCIIEOL );
    
    putust(pf, TEXT("Unicode Paragraph separator here ->"));
    putu(pf, UNIPARASEP );
    putust(pf, TEXT("<- Unicode paragraph separator"));
    putust( pf, ASCIIEOL );

    fclose( pf );

    // Task2: Write all the characters codes and information
    // on each character code to an output file.
    if (!(pf = fopen( "names2.txt", "r" )))
        return FALSE;

    if (!(pfo = fopen("unicodes.txt", "wb")))
        return FALSE;

    // The first character should be 0xFEFF in the file, 
    // indicating that it's an unicode file.
    putu( pfo, (TCHAR)0xfeff);

    // Read the input file (names2.txt) which has information
    // on every unicode character.
    do
    {
    WCHAR wLineBuffer[LINE_SIZE];
    int i, num;

        if (!memset(lpstrLine, 0, LINE_SIZE))
        {
            _tprintf(TEXT("Something wrong - failed in Memset!!\n") );
            break;
        }
       
        // fgets returns NULL on eof or on an error condition
        if( fgets( lpstrLine, LINE_SIZE, pf) == NULL )
        {
            if (!feof(pf))
               _tprintf(TEXT("Error occured while reading names2.txt.\n") );

            break;
        }

        i = 0;
        
        // Find the first newline (if there is any) and replace it by \0.
        while((lpstrLine[i]!= '\n') && (lpstrLine[i]!='\r') && (lpstrLine[i]!='\0'))
        {
            i++;
        }

        lpstrLine[i]= '\0';
       
        // If the line has the character code (for which info is given)
        // grab and "display" that.
        num= -1;
        sscanf( lpstrLine, "%x", &num);

        if( num != -1 )
        {
            putu( pfo, (TCHAR) num );
            putust( pfo, TEXT(": ") );
        }
        else
        {
            putust( pfo,TEXT("   ") );
        }
        // Convert it to the world of unicodes.
        if (MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, lpstrLine, -1, 
                        wLineBuffer, LINE_SIZE ))
            putust(pfo, wLineBuffer);

        putust( pfo, ASCIIEOL );

    }
    while( TRUE );

    fclose( pfo );
    fclose( pf );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\notepad\mkuni\mkuni.h ===
#define ID_ASCII                    105
#define ID_LATIN                    106
#define ID_LATIN_E                  107
#define ID_LATIN_X                  108
#define ID_PHONETIC                 109
#define ID_MODIFIER                 110
#define ID_DIACRITICAL              111
#define ID_GREEK                    112
#define ID_CYRILLIC                 113
#define ID_CYRILLIC_X               114
#define ID_HEBREW                   115
#define ID_CURRENCY                 116
#define ID_LETTERS                  117
#define ID_ARROWS                   118
#define ID_MATH                     119
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\dialogs.h ===
/* Dialog box ids */
#define DTPROP                      100
#define IDD_EDIT                    101
#define IDD_LISTBOX                 102
#define IDD_AUTO                    103
#define IDD_MANUAL                  104
#define IDD_UPDATE                  105
#define IDD_FREEZE                  106
#define IDD_CHANGE                  107
#define IDD_PLAY                    108

#define DTINVALIDLINK               200

#define DTCHANGETEXT                300
#define IDD_LABEL                   301
#define IDD_ICONTEXT                302

#define DTCHANGECMDTEXT             400
#define IDD_COMMAND                 401

#define DTFAILEDUPDATE              502
#define IDD_CONTINUEEDIT            503
#define IDD_UPDATEEXIT              504
#define IDD_TEXT                    505

#define ICONDLG                     600
#define IDD_NAME                    601
#define IDD_ICON                    602
#define IDD_BROWSE                  603
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\cmdlink.c ===
/* cmdlink.c - Handles command line/pseudo-link objects.
 */

#include "packager.h"
#include <shellapi.h>

DECLSPEC_IMPORT BOOL SafeOpenPromptForPackager(HWND hwnd, PCWSTR pszFile, BOOL bFromCommandLine);

DWORD CmlWaitForChildProc( LPVOID lpv ) 
{
    if (WaitForSingleObject((HANDLE)lpv, INFINITE) == 0) 
    {
        if (gfInvisible) 
        {
            PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }
    }

    CloseHandle((HANDLE)lpv);

    return 0;
}


void _CmlExecute(LPCSTR pszFile, LPCSTR pszParams)
{
    HRESULT hr;

    WCHAR szUrlName[MAX_PATH];
    WCHAR szDialogName[MAX_PATH];
    BOOL bResult;
    SHELLEXECUTEINFO sexi = {0};
    DWORD err = NO_ERROR;

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFile, -1, szUrlName, ARRAYSIZE(szUrlName));
    StringCchCopyW(szDialogName, ARRAYSIZE(szDialogName), szUrlName);
    if(pszParams && *pszParams)
    {
        StringCchCatW(szDialogName, ARRAYSIZE(szDialogName), L" ");
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszParams, -1, szUrlName, ARRAYSIZE(szUrlName));
        StringCchCatW(szDialogName, ARRAYSIZE(szDialogName),szUrlName);
    }

    if(SafeOpenPromptForPackager(NULL, szDialogName, TRUE))
    {
        // Now we can execute the link file.
        sexi.cbSize = sizeof(sexi);
        sexi.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_NOZONECHECKS ;
        sexi.lpFile =  pszFile;
        sexi.lpParameters = pszParams;
        sexi.nShow = SW_SHOWNORMAL;

        if (ShellExecuteEx(&sexi)) 
        {
            if (sexi.hProcess != NULL)
            {
                // Start a thread to wait on the app and close packager once it has ended
                DWORD id;
                HANDLE hThd = CreateThread(NULL, 0, CmlWaitForChildProc, sexi.hProcess, 0, &id );
                if (hThd) 
                {
                    CloseHandle(hThd);
                }
                else
                {
                    CloseHandle(sexi.hProcess);
                    err = GetLastError();
                }
            } 
        } 
        else
        {
            err = GetLastError();
        }

        if (err != NO_ERROR)
            ErrorMessage((err == ERROR_NO_ASSOCIATION) ? E_FAILED_TO_FIND_ASSOCIATION : E_FAILED_TO_EXECUTE_COMMAND);
    }
}

/* CmlActivate() - Activate the command line/pseudo-linked file.
 */
VOID CmlActivate(LPCML lpcml)
{
    LPSTR pchTemp = lpcml->szCommand;
    CHAR chSave = 0;
    BOOL fInQuote = FALSE;

    /* skip leading spaces */
    while (*pchTemp && *pchTemp == CHAR_SPACE)
        pchTemp = CharNext(pchTemp);


    /* find first non-quoted space */
    for (; *pchTemp && (*pchTemp != CHAR_SPACE || fInQuote); pchTemp = CharNext(pchTemp))
    {
        if (*pchTemp == CHAR_QUOTE) 
        {
            fInQuote = !fInQuote;
        }
    }

    if (*pchTemp)
    {
        chSave = *pchTemp;
        *pchTemp++ = 0;
    }

    DPRINT("packager: Calling ShellExecute");
    _CmlExecute(lpcml->szCommand, pchTemp);
    DPRINT("packager: Back from ShellExecute");

    if (chSave)
        *(--pchTemp) = chSave;
}



/* CmlClone() -
 */
LPCML
CmlClone(
    LPCML lpcml
    )
{
    return CmlCreate(lpcml->szCommand, lpcml->fCmdIsLink);
}



/* CmlCreate() -
 */
LPCML
CmlCreateWorker(
    LPSTR lpstrCmd,
    BOOL fCmdIsLink,
    BOOL fFileName)
{
    HANDLE hdata = NULL;
    LPCML lpcml = NULL;

    if (!(hdata = GlobalAlloc(GMEM_MOVEABLE, sizeof(CML))) ||
        !(lpcml = (LPCML)GlobalLock(hdata)))
        goto errRtn;

    // Store the data in the window itself
    lpcml->hdata = hdata;
    lpcml->fCmdIsLink = fCmdIsLink;

    /*
     * If it is not a single filename,
     *      or the filename does not have a space in it,
     *      or the 'filename' has double qoute characters in it, then
     * just copy it without quoting.
     */
    if (!fFileName || strchr( lpstrCmd, CHAR_SPACE ) == NULL ||
            strchr( lpstrCmd, CHAR_QUOTE ) != NULL)

        StringCchCopy(lpcml->szCommand, ARRAYSIZE(lpcml->szCommand), lpstrCmd);

    else {
        LPSTR psz = lpcml->szCommand;
        *psz++ = CHAR_QUOTE;
        StringCchCopy(psz, ARRAYSIZE(lpcml->szCommand) - 1, lpstrCmd);
        StringCchCat(lpcml->szCommand, ARRAYSIZE(lpcml->szCommand), SZ_QUOTE);
    }
    CmlFixBounds(lpcml);

    return lpcml;

errRtn:
    ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);

    if (lpcml)
        GlobalUnlock(hdata);

    if (hdata)
        GlobalFree(hdata);

    return NULL;
}



/* CmlDelete() - Wipe out the command line.
 */
VOID
CmlDelete(
    LPCML lpcml
    )
{
    HANDLE hdata;

    if (lpcml)
    {
        GlobalUnlock(hdata = lpcml->hdata);
        GlobalFree(hdata);
    }
}



/* CmlDraw() - Draw the command line, centered nicely.
 */
VOID
CmlDraw(
    LPCML lpcml,
    HDC hdc,
    LPRECT lprc,
    INT xHSB,
    BOOL fFocus
    )
{
    HFONT hfont;
    RECT rcFocus;
    CHAR szDesc[CBSTRINGMAX];
    CHAR szFile[CBCMDLINKMAX];
    CHAR szMessage[CBSTRINGMAX + CBCMDLINKMAX];
    RECT rc;

    hfont = SelectObject(hdc, ghfontChild);

    if (lpcml->fCmdIsLink)
    {
        LoadString(ghInst, IDS_LINKTOFILE, szDesc, CharCountOf(szDesc));
        StringCchCopy(szFile, ARRAYSIZE(szFile), lpcml->szCommand);
        Normalize(szFile);
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, (LPSTR)szFile);

        DrawText(hdc, szMessage, -1, lprc, DT_SINGLELINE | DT_NOPREFIX |
            DT_CENTER | DT_VCENTER);

        if (fFocus)
        {
            rcFocus = *lprc;
            DrawText(hdc, szMessage, -1, &rcFocus, DT_CALCRECT | DT_SINGLELINE |
                DT_NOPREFIX | DT_LEFT | DT_TOP);
            OffsetRect(&rcFocus, (lprc->left + lprc->right - rcFocus.right) /
                2, (lprc->top + lprc->bottom - rcFocus.bottom) / 2);
            DrawFocusRect(hdc, &rcFocus);
        }
    }
    else
    {
        rc = *lprc;

        // We should have scroll bars, the text is wider than the window
        if (rc.right < lpcml->rc.right)
        {
            rc.right = lpcml->rc.right;
            OffsetRect(&rc, -xHSB, 0);
        }

        DrawText(hdc, lpcml->szCommand, -1, &rc, DT_SINGLELINE | DT_NOPREFIX |
            DT_CENTER | DT_VCENTER);

        if (fFocus)
            DrawFocusRect(hdc, &rc);
    }

    if (hfont)
        SelectObject(hdc, hfont);
}



/* CmlFixBounds() -
 */
VOID
CmlFixBounds(
    LPCML lpcml
    )
{
    HDC hdc;
    HFONT hfont;

    // Figure out how large the text region will be
    if (*lpcml->szCommand)
    {
        if (hdc = GetWindowDC(ghwndFrame))
        {
            hfont = SelectObject(hdc, ghfontChild);

            SetRect(&(lpcml->rc), 0, 0, 20000, 100);
            DrawText(hdc, lpcml->szCommand, -1, &(lpcml->rc), DT_CALCRECT |
                DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

            if (hfont)
                SelectObject(hdc, hfont);

            ReleaseDC(ghwndFrame, hdc);
        }
    }
    else
    {
        SetRect(&(lpcml->rc), 0, 0, 0, 0);
    }

    PostMessage(ghwndPane[CONTENT], WM_FIXSCROLL, 0, 0L);
}



/* CmlReadFromNative() - Read a command line object from the native data.
 */
LPCML
CmlReadFromNative(
    LPSTR *lplpstr
    )
{
    BOOL fCmdIsLink;
    WORD w;
    CHAR szCmd[CBCMDLINKMAX];

    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    fCmdIsLink = (BOOL)w;
    StringCchCopy(szCmd, ARRAYSIZE(szCmd), *lplpstr);
    *lplpstr += lstrlen(szCmd) + 1;

    return CmlCreate(szCmd, fCmdIsLink);
}



/* CmlWriteToNative() - Write a command line object to the native data.
 */
DWORD
CmlWriteToNative(
    LPCML lpcml,
    LPSTR *lplpstr
    )
{
    WORD w;

    if (lplpstr)
    {
        w = (WORD)lpcml->fCmdIsLink;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        MemWrite(lplpstr, (LPSTR)lpcml->szCommand,
            lstrlen(lpcml->szCommand) + 1);
    }

    return sizeof(WORD) + lstrlen(lpcml->szCommand) + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\dlgprocs.c ===
/* dlgprocs.c - Packager-specific dialog routines.
 */

#include "packager.h"
#include <shellapi.h>
#include <commdlg.h>
#include "dialogs.h"
// #include "..\..\library\shell.h"

// HACK: Copied from shsemip.h
#ifdef WINNT
    WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPWSTR pwszIconPath, UINT cchIconPath, int *piIconIndex);
    int  PkgPickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cbIconPath, int *piIconIndex);
#else
    WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPSTR pwszIconPath, UINT cchIconPath, int *piIconIndex);
#   define PkgPickIconDlg(h, s, c, p)  PickIconDlg(h, s, c, p)
#endif

#define CBCUSTFILTER 40

static CHAR szPathField[CBPATHMAX];
static CHAR szDirField[CBPATHMAX];
static CHAR szStarDotEXE[] = "*.EXE";
static CHAR szShellDll[] = "shell32.dll";
static CHAR szCommand[CBCMDLINKMAX];
static CHAR szIconText[CBPATHMAX];



/*--------------------------------------------------------------------------*/
/*                                      */
/*  MyDialogBox() -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

INT_PTR MyDialogBox(
    UINT idd,
    HWND hwndParent,
    DLGPROC lpfnDlgProc
    )
{
    return DialogBoxAfterBlock(MAKEINTRESOURCE(idd), hwndParent, lpfnDlgProc);
}



#ifdef WINNT
/*
 * NT's PickIconDlg is UNICODE only, so thunk it here
 */

/* PkgPickIconDlg() -
 *
 *  hwnd        - window
 *  pszIconPath - ANSI path for icon suggested icon file (also output buffer that holds real icon file)
 *  cchIconPath - size of the buffer in chars pointed to pszIconPath. NOT the string length!
 *  piIconIndex - receives the index of the icon
 *
 */
int  PkgPickIconDlg(HWND hwnd, LPSTR pszIconPath, UINT cchIconPath, int *piIconIndex) {
    WCHAR wszPath[MAX_PATH+1];
    int iRet;

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszIconPath, -1, wszPath, ARRAYSIZE(wszPath));

    iRet = PickIconDlg(hwnd, wszPath, cchIconPath, piIconIndex);
    wszPath[MAX_PATH] = L'\0'; // Make sure text is zero terminated, even if it is garbage

    WideCharToMultiByte( CP_ACP, 0, wszPath, -1, pszIconPath, cchIconPath, NULL, NULL );

    return iRet;
}
#endif

/* IconDialog() -
 *
 */
BOOL
IconDialog(
    LPIC lpic
    )
{
    char szIconPath[MAX_PATH];
    int iDlgIcon = lpic->iDlgIcon;
    StringCchCopy(szIconPath, ARRAYSIZE(szIconPath), (*lpic->szIconPath) ? lpic->szIconPath : szShellDll);

    if (PkgPickIconDlg(ghwndPane[APPEARANCE],
                    szIconPath, sizeof(szIconPath)/sizeof(char), &iDlgIcon))
    {
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), szIconPath);
        lpic->iDlgIcon = iDlgIcon;
        GetCurrentIcon(lpic);
        return TRUE;
    }

    return FALSE;
}



/* ChangeCmdLine() - Summons the Command Line... dialog.
 *
 */
BOOL
ChangeCmdLine(
    LPCML lpcml
    )
{
    StringCchCopy(szCommand, ARRAYSIZE(szCommand), lpcml->szCommand);

    if (DialogBoxAfterBlock(MAKEINTRESOURCE(DTCHANGECMDTEXT),
        ghwndPane[CONTENT], fnChangeCmdText) != IDOK)
        return FALSE;

    StringCchCopy(lpcml->szCommand, ARRAYSIZE(lpcml->szCommand), szCommand);
    CmlFixBounds(lpcml);

    return TRUE;
}



/* ChangeLabel() - Summons the Label... dialog.
 *
 */
VOID
ChangeLabel(
    LPIC lpic
    )
{
    INT iPane = APPEARANCE;

    StringCchCopy(szIconText, ARRAYSIZE(szIconText), lpic->szIconText);

    if (DialogBoxAfterBlock(MAKEINTRESOURCE(DTCHANGETEXT),
        ghwndPane[iPane], fnChangeText)
        && lstrcmp(lpic->szIconText, szIconText))
    {
        // label has changed, set the undo object.
        if (glpobjUndo[iPane])
            DeletePaneObject(glpobjUndo[iPane], gptyUndo[iPane]);

        gptyUndo[iPane]  = ICON;
        glpobjUndo[iPane] = IconClone (lpic);
        StringCchCopy(lpic->szIconText, ARRAYSIZE(lpic->szIconText), szIconText);
    }
}



/**************************** Dialog Functions ****************************/
/* fnChangeCmdText() - Command Line... dialog procedure.
 */
INT_PTR CALLBACK
fnChangeCmdText(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPSTR psz;

    switch (msg)
    {
        case WM_INITDIALOG:
            SetDlgItemText(hDlg, IDD_COMMAND, szCommand);
            SendDlgItemMessage(hDlg, IDD_COMMAND, EM_LIMITTEXT, CBCMDLINKMAX - 1, 0L);
            PostMessage(hDlg, WM_NEXTDLGCTL,
                (WPARAM)GetDlgItem(hDlg, IDD_COMMAND), 1L);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDD_LABEL:
                    PostMessage(hDlg, WM_NEXTDLGCTL,
                        (WPARAM)GetDlgItem(hDlg, IDD_COMMAND), 1L);
                    break;

                case IDOK:
                    GetDlgItemText(hDlg, IDD_COMMAND, szCommand, CBCMDLINKMAX);
                    /*
                     * Eat leading spaces to make Afrikaners in high places
                     * happy.
                     */
                    psz = szCommand;
                    while(*psz == CHAR_SPACE)
                        psz++;

                    if( psz != szCommand ) {
                        LPSTR pszDst = szCommand;

                        while(*psz) {
                            *pszDst++ = *psz++;
                        }

                        /* copy null across */
                        *pszDst = *psz;
                    }

                // FALL THROUGH TO IDCANCEL

                case IDCANCEL:
                    EndDialog(hDlg, LOWORD(wParam));
            }
    }

    return FALSE;
}



/* fnProperties() - Link Properties... dialog
 */
INT_PTR CALLBACK
fnProperties(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndLB = GetDlgItem(hDlg, IDD_LISTBOX);

    switch (msg)
    {
    case WM_REDRAW:
        SendMessage(hwndLB, WM_SETREDRAW, 0, 0L);

    case WM_INITDIALOG:
        {
            BOOL fChangeLink = TRUE;
            HANDLE hData = NULL;
            LONG otFocus;
            LPSTR lpstrData = NULL;
            LPSTR lpstrTemp;
            LPOLEOBJECT lpObject;
            LPVOID lpobjFocus;
            LPVOID lpobjFocusUndo;
            OLEOPT_UPDATE update;
            CHAR szType[CBMESSAGEMAX];
            CHAR szFull[CBMESSAGEMAX * 4];
            INT idButton;
            INT iPane;

            iPane = (GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]);
            lpobjFocus = glpobj[iPane];
            lpobjFocusUndo = glpobjUndo[iPane];
            lpObject = ((LPPICT)lpobjFocus)->lpObject;

            // Reset the list box
            SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

            if (msg == WM_INITDIALOG)
            {
                // If it wasn't a link it doesn't belong
                OleQueryType(lpObject, &otFocus);

                if (otFocus != OT_LINK)
                {
                    ghwndError = ghwndFrame;
                    EndDialog(hDlg, TRUE);
                    break;
                }

                PicSaveUndo(lpobjFocus);
                ghwndError = hDlg;
            }

            //
            // Redrawing the string, get the update options and
            // the button state for IDD_AUTO/IDD_MANUAL.
            //
            Error(OleGetLinkUpdateOptions(lpObject, &update));

            switch (update)
            {
            case oleupdate_always:
                LoadString(ghInst, IDS_AUTO, szType, CBMESSAGEMAX);
                idButton    = IDD_AUTO;
                break;

            case oleupdate_oncall:
                LoadString(ghInst, IDS_MANUAL, szType, CBMESSAGEMAX);
                idButton    = IDD_MANUAL;
                break;

            default:
                LoadString(ghInst, IDS_CANCELED, szType, CBMESSAGEMAX);
                idButton = -1;

                // Disable the change link button
                fChangeLink = FALSE;
            }

            //
            // Retrieve the server name (try it from Undo
            // if the object has been frozen)
            //
            if (Error(OleGetData(lpObject, gcfLink, &hData)) || !hData)
            {
                OleQueryType(lpObject, &otFocus);
                if (otFocus != OT_STATIC)
                {
                    ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                    return TRUE;
                }

                if (gptyUndo[iPane] == PICTURE &&
                    (Error(OleGetData(((LPPICT)lpobjFocusUndo)->lpObject,
                    gcfLink, &hData)) || !hData))
                {
                    ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                    return TRUE;
                }
            }

            // The link format is:  "szClass0szDocument0szItem00"
            if (hData && (lpstrData = GlobalLock(hData)))
            {
                // Retrieve the server's class ID
                RegGetClassId(szFull, ARRAYSIZE(szFull), lpstrData);
                StringCchCat(szFull, ARRAYSIZE(szFull), "\t");

                // Display the Document and Item names
                while (*lpstrData++)
                    ;

                // Strip off the path name and drive letter
                lpstrTemp = lpstrData;
                while (*lpstrTemp)
                {
                    if (*lpstrTemp == '\\' || *lpstrTemp == ':')
                        lpstrData = lpstrTemp + 1;

                    if (gbDBCS)
                    {
                        lpstrTemp = CharNext(lpstrTemp);
                    }
                    else
                    {
                        lpstrTemp++;
                    }
                }

                // Append the file name
                StringCchCat(szFull, ARRAYSIZE(szFull), lpstrData);
                StringCchCat(szFull, ARRAYSIZE(szFull), "\t");

                // Append the item name
                while (*lpstrData++)
                    ;

                StringCchCat(szFull, ARRAYSIZE(szFull), lpstrData);
                StringCchCat(szFull, ARRAYSIZE(szFull), "\t");

                GlobalUnlock(hData);
            }
            else
            {
                StringCchCopy(szFull, ARRAYSIZE(szFull), "\t\t\t");
            }

            // Append the type of link
            StringCchCat(szFull, ARRAYSIZE(szFull), szType);

            // Draw the link in the list box
            SendMessage(hwndLB, LB_INSERTSTRING, (WPARAM) - 1, (LPARAM)szFull);

            if (msg == WM_REDRAW)
            {
                SendMessage(hwndLB, WM_SETREDRAW, 1, 0L);
                InvalidateRect(hwndLB, NULL, TRUE);
                Dirty();
            }

            // Uncheck those buttons that shouldn't be checked
            if (IsDlgButtonChecked(hDlg, IDD_AUTO) && (idButton != IDD_AUTO))
                CheckDlgButton(hDlg, IDD_AUTO, FALSE);

            if (IsDlgButtonChecked(hDlg, IDD_MANUAL) && (idButton != IDD_MANUAL))
                CheckDlgButton(hDlg, IDD_MANUAL, FALSE);

            // Check the dialog button, as appropriate
            if ((idButton == IDD_AUTO) || (idButton == IDD_MANUAL))
                CheckDlgButton(hDlg, idButton, TRUE);

            // Enable the other buttons appropriately
            EnableWindow(GetDlgItem(hDlg, IDD_CHANGE),
                ((otFocus != OT_STATIC) && fChangeLink));
            EnableWindow(GetDlgItem(hDlg, IDD_EDIT), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_PLAY), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_AUTO), (otFocus != OT_STATIC));
            EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), (otFocus != OT_STATIC));

            return TRUE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDCANCEL:
                PostMessage(ghwndFrame, WM_COMMAND, IDM_UNDO, 0L);

            case IDOK:
                ghwndError = ghwndFrame;
                EndDialog(hDlg, TRUE);
                return TRUE;

            default:
                break;
        }

        SendMessage(ghwndPane[GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]],
            WM_COMMAND, wParam, 0L);

        switch (LOWORD(wParam))
        {
            // Dismiss the dialog on Edit/Activate
            case IDD_EDIT:
            case IDD_PLAY:
                ghwndError = ghwndFrame;
                EndDialog(hDlg, TRUE);
                return TRUE;

            default:
                break;
        }

        break;
    }

    return FALSE;
}



/* fnChangeText() - Label... dialog
 */
INT_PTR CALLBACK
fnChangeText(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hDlg, IDD_ICONTEXT, szIconText);
        SendDlgItemMessage(hDlg, IDD_ICONTEXT, EM_LIMITTEXT, 39, 0L);
        PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDD_ICONTEXT),
             1L);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_LABEL:
            PostMessage(hDlg, WM_NEXTDLGCTL,
                (WPARAM)GetDlgItem(hDlg, IDD_ICONTEXT), 1L);
            break;

        case IDOK:
            GetDlgItemText(hDlg, IDD_ICONTEXT, szIconText, CBMESSAGEMAX);
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
    }

    return FALSE;
}



/* fnInvalidLink() - Invalid Link dialog
 *
 * This is the two button "Link unavailable" dialog box.
 */
INT_PTR CALLBACK
fnInvalidLink(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDD_CHANGE:
            EndDialog(hDlg, LOWORD(wParam));
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\function.h ===
//
// cmdlink.c
//

VOID CmlActivate(LPCML lpcml);
LPCML CmlClone(LPCML lpcml);
LPCML CmlCreateWorker(LPSTR lpstrCmd, BOOL fCmdIsLink, BOOL fFilename);

#define CmlCreate(lpstrCmd, fCmdIsLink)     \
        CmlCreateWorker(lpstrCmd, fCmdIsLink, FALSE)

#define CmlCreateFromFilename(lpstrCmd, fCmdIsLink) \
        CmlCreateWorker(lpstrCmd, fCmdIsLink, TRUE)

VOID CmlDelete(LPCML lpcml);
VOID CmlDraw(LPCML lpcml, HDC hdc, LPRECT lprc, INT xHSB, BOOL fFocus);
VOID CmlFixBounds(LPCML lpcml);
LPCML CmlReadFromNative(LPSTR *lplpstr);
DWORD CmlWriteToNative(LPCML lpcml, LPSTR *lplpstr);


//
// dlgprocs.c
//

INT_PTR MyDialogBox(UINT idd, HWND hwndParent, DLGPROC lpfnDlgProc);
BOOL IconDialog(LPIC lpic);
BOOL ChangeCmdLine(LPCML lpcml);
VOID ChangeLabel(LPIC lpic);
INT_PTR CALLBACK fnChangeCmdText(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK fnProperties(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK fnChangeText(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK fnInvalidLink(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);


//
// embed.c
//

BOOL EmbActivate(LPEMBED lpembed, UINT wVerb);
LPEMBED EmbCreate(LPSTR lpstrFile);
VOID EmbDelete(LPEMBED lpembed);
VOID EmbDraw(LPEMBED lpembed, HDC hdc, LPRECT lprc, BOOL fFocus);
LPEMBED EmbReadFromNative(LPSTR *lplpstr);
DWORD EmbWriteToNative(LPEMBED lpembed, LPSTR *lplpstr);
VOID EmbWriteToFile(LPEMBED lpembed, INT fh);
VOID EmbRead(LPEMBED lpembed);
BOOL EmbDoVerb(LPEMBED lpembed, UINT wVerb);
BOOL EmbActivateThroughOle(LPEMBED lpembed, LPSTR lpdocname, UINT wVerb);
INT CALLBACK EmbCallBack(LPOLECLIENT lpclient, OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject);
VOID EmbDeleteLinkObject(LPEMBED lpembed);


//
// filedlgs.c
//

VOID OfnInit(VOID);
BOOL OfnGetName(HWND hwnd, UINT msg);
HANDLE OfnGetNewLinkName(HWND hwnd, HANDLE hData);
VOID Normalize(LPSTR lpstrFile);


//
// icon.c
//

LPIC IconClone(LPIC lpic);
LPIC IconCreateFromFile(LPSTR lpstrFile);
LPIC IconCreateFromObject(LPOLEOBJECT lpObject);
VOID IconDelete(LPIC lpic);
VOID IconDraw(LPIC lpic, HDC hdc, LPRECT lprc, BOOL fFocus, INT cxImage,
    INT cyImage);
LPIC IconReadFromNative(LPSTR *lplpstr);
DWORD IconWriteToNative(LPIC lpic, LPSTR *lplpstr);
VOID GetCurrentIcon(LPIC lpic);


//
// packager.c
//

LRESULT CALLBACK FrameWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID SetTitle(BOOL fRegistering);
VOID InitFile(VOID);
VOID ErrorMessage(UINT id);
BOOL ProcessMessage(VOID);
LPSTR Contains(LPSTR lpString, LPSTR lpPattern);
VOID Dirty(VOID);
VOID DeregisterDoc(VOID);
VOID Raise(INT iPane);
INT_PTR MessageBoxAfterBlock(HWND hwndParent, LPSTR lpText, LPSTR lpCaption,
    UINT fuStyle);
INT_PTR DialogBoxAfterBlock(LPCSTR lpTemplate, HWND hwndParent,
    DLGPROC lpDialogFunc);


//
// pane.c
//

BOOL InitPaneClasses(VOID);
BOOL InitPanes(VOID);
VOID EndPanes(VOID);
LRESULT CALLBACK SubtitleWndProc(HWND hWnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
LRESULT CALLBACK PaneWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK SplitterFrame(HWND hWnd, UINT msg, WPARAM wParam,
    LPARAM lParam);
VOID DeletePane(INT iPane, BOOL fDeleteUndo);
VOID DeletePaneObject(LPVOID lpobj, INT objType);


//
// picture.c
//

BOOL InitClient(VOID);
VOID EndClient(VOID);
LPPICT PicCreate(LPOLEOBJECT lpObject, LPRECT lprcObject);
VOID PicDelete(LPPICT lppict);
BOOL PicDraw(LPPICT lppict, HDC hDC, LPRECT lprc, INT xHSB, INT yVSB,
    BOOL fPicture, BOOL fFocus);
LPPICT PicPaste(BOOL fPaste, LPSTR lpstrName);
BOOL Error(OLESTATUS olestat);
INT CALLBACK CallBack(LPOLECLIENT lpclient, OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject);
VOID WaitForObject(LPOLEOBJECT lpObject);
BOOL PicSetUpdateOptions(LPPICT lppict, UINT idCmd);
LPPICT PicReadFromNative(LPSTR *lplpstr, LPSTR lpstrName);
DWORD PicWriteToNative(LPPICT lppict, LPOLEOBJECT lpObject, LPSTR *lplpstr);
VOID Hourglass(BOOL fOn);
VOID PicActivate(LPPICT lppict, UINT idCmd);
VOID PicUpdate(LPPICT lppict);
VOID PicFreeze(LPPICT lppict);
VOID PicChangeLink(LPPICT lppict);
BOOL PicCopy(LPPICT lppict);
VOID PicSaveUndo(LPPICT lppict);
LPPICT PicFromFile(BOOL fEmbedded, LPSTR szFile);

typedef int (__stdcall *PCALL_BACK)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
LPOLECLIENT PicCreateClient(PCALL_BACK fnCallBack, LPOLECLIENTVTBL lpclivtbl);


//
// register.c
//

VOID RegInit(VOID);
VOID RegGetClassId(LPSTR lpstrName, DWORD nameBufferSize, LPSTR lpstrClass);
INT RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, LPSTR lpstrFilterSpec);
VOID RegGetExeName(LPSTR lpstrExe, LPSTR lpstrClass, DWORD dwBytes);


//
// server.c
//

BOOL InitServer(VOID);
VOID DeleteServer(LPSAMPSRVR lpsrvr);
VOID DestroyServer(VOID);
LPSAMPDOC InitDoc(LPSAMPSRVR lpsrvr, LHSERVERDOC lhdoc, LPSTR lptitle);
VOID ChangeDocName(LPSAMPDOC *lplpdoc, LPSTR lpname);
BOOL SendDocChangeMsg(LPSAMPDOC lpdoc, UINT options);
LPSAMPDOC CreateNewDoc(LPSAMPSRVR lpsrvr, LHSERVERDOC lhdoc, LPSTR lpstr);
LPSAMPDOC CreateDocFromFile(LPSAMPSRVR lpsrvr, LHSERVERDOC lhdoc, LPSTR lpstr);
BOOL CopyObjects(VOID);
LPSAMPITEM CreateNewItem(LPSAMPDOC lpdoc);
HANDLE GetNative(BOOL fClip);
BOOL PutNative(HANDLE hdata);
HANDLE GetLink(VOID);
HANDLE GetMF(VOID);
VOID InitEmbedded(BOOL fCreate);
LPSAMPITEM AddItem(LPSAMPITEM lpitem);
BOOL DeleteItem(LPSAMPITEM lpitem);
VOID EndEmbedding(VOID);


//
// stream.c
//

VOID SetFile(STREAMOP sop, INT fh, LPSTR *lplpstr);
DWORD ReadStream(LPAPPSTREAM lpStream, LPSTR lpstr, DWORD cb);
DWORD PosStream(LPAPPSTREAM lpStream, LONG pos, INT iorigin);
DWORD WriteStream(LPAPPSTREAM lpStream, LPSTR lpstr, DWORD cb);
DWORD MemRead(LPSTR *lplpStream, LPSTR lpItem, DWORD dwSize);
DWORD MemWrite(LPSTR *lplpStream, LPSTR lpItem, DWORD dwSize);


//
// virtable.c
//

OLESTATUS SrvrOpen(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrCreate(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
    LPSTR lpclassname, LPSTR lpdocname, LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrCreateFromTemplate(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
    LPSTR lpclassname, LPSTR lpdocname, LPSTR lptemplatename,
    LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrEdit(LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, LPSTR lpclassname,
    LPSTR lpdocname, LPOLESERVERDOC *lplpoledoc);
OLESTATUS SrvrExit(LPOLESERVER lpolesrvr);
OLESTATUS SrvrRelease(LPOLESERVER lpolesrvr);
OLESTATUS SrvrExecute(LPOLESERVER lpolesrvr, HANDLE hCmds);

OLESTATUS DocSave(LPOLESERVERDOC lpoledoc);
OLESTATUS DocClose(LPOLESERVERDOC lpoledoc);
OLESTATUS DocRelease(LPOLESERVERDOC lpoledoc);
OLESTATUS DocGetObject(LPOLESERVERDOC lpoledoc, LPSTR lpitemname,
    LPOLEOBJECT *lplpoleobject, LPOLECLIENT lpoleclient);
OLESTATUS DocSetHostNames(LPOLESERVERDOC lpoledoc, LPSTR lpclientName,
    LPSTR lpdocName);
OLESTATUS DocSetDocDimensions(LPOLESERVERDOC lpoledoc, LPRECT lprc);
OLESTATUS DocSetColorScheme(LPOLESERVERDOC lpoledoc, LPLOGPALETTE lppal);
OLESTATUS DocExecute(LPOLESERVERDOC lpoledoc, HANDLE hCmds);

OLESTATUS ItemDelete(LPOLEOBJECT lpoleobject);
OLESTATUS ItemGetData(LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat,
    LPHANDLE lphandle);
OLESTATUS ItemSetData(LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat,
    HANDLE hdata);
OLESTATUS ItemDoVerb(LPOLEOBJECT lpoleobject, UINT wVerb, BOOL fShow,
    BOOL fActivate);
OLESTATUS ItemShow(LPOLEOBJECT lpoleobject, BOOL fActivate);
OLESTATUS ItemSetBounds(LPOLEOBJECT lpoleobject, LPRECT lprc);
OLESTATUS ItemSetTargetDevice(LPOLEOBJECT lpoleobject, HANDLE h);
OLECLIPFORMAT ItemEnumFormats(LPOLEOBJECT lpobject, OLECLIPFORMAT cfFormat);
LPVOID ItemQueryProtocol(LPOLEOBJECT lpoleobject, LPSTR lpprotocol);
OLESTATUS ItemSetColorScheme(LPOLEOBJECT lpoleobject, LPLOGPALETTE lppal);

BOOL IsOleServerDoc(LPSTR lpdocname);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\globals.c ===
//
// Module: globals.c
//
// Global variables for the Object Packager.
//
//

#include "packager.h"


INT gcxIcon;
INT gcyIcon;
INT gcxArrange;                     // Icon text wrap boundary
INT gcyArrange;
INT giXppli = DEF_LOGPIXELSX;       // Number of pixels per logical
INT giYppli = DEF_LOGPIXELSY;       // inch along width and height

BOOL gfEmbObjectOpen = FALSE;
BOOL gfBlocked = FALSE;
BOOL gfEmbedded = FALSE;            // Editing an embedded object?
BOOL gfInvisible = FALSE;           // Editing invisibly?
BOOL gfOleClosed = FALSE;           // Should we send Ole_Closed or not?
BOOL gfEmbeddedFlag = FALSE;        // Editing with /Embedded flag?
BOOL gfDocCleared = FALSE;
BOOL gfServer = FALSE;              // Is the server loaded?
BOOL gfDocExists = FALSE;

HANDLE ghInst;                      // Unique instance identifier
HACCEL ghAccTable;                  // Application specific accelerator table
HBRUSH ghbrBackground = NULL;       // Fill brush used to paint background
HFONT ghfontTitle = NULL;
HFONT ghfontChild;                  // Font for caption bar
HCURSOR ghcurWait;                  // Hourglass cursor

HWND ghwndFrame;                    // Main window
HWND ghwndBar[CCHILDREN];
HWND ghwndPane[CCHILDREN];
HWND ghwndPict;
HWND ghwndError = NULL;             // Parent window when Error popup happens

INT gnCmdShowSave;                  // Show flags; saved if started invisibly
UINT gcOleWait = 0;                 // OLE asynchronous transaction counter
LHCLIENTDOC glhcdoc = 0;	   // Handle to client document "link"
LPSAMPDOC gvlptempdoc = NULL;
LPAPPSTREAM glpStream = NULL;
LPOLECLIENT glpclient = NULL;
LPVOID glpobj[CCHILDREN];
LPVOID glpobjUndo[CCHILDREN];
HANDLE ghServer = NULL;             // Handle to server memory block
LPSAMPSRVR glpsrvr = NULL;          // Pointer to OLE server memory
LPSAMPDOC glpdoc = NULL;            // Pointer to current OLE document
DWORD gcbObject;
PANETYPE gpty[CCHILDREN];
PANETYPE gptyUndo[CCHILDREN];

OLECLIPFORMAT gcfFileName = 0;      // Clipboard format "FileName"
OLECLIPFORMAT gcfLink = 0;          // Clipboard format "ObjectLink"
OLECLIPFORMAT gcfNative = 0;        // Clipboard format "Native"
OLECLIPFORMAT gcfOwnerLink = 0;     // Clipboard format "OwnerLink"

CHAR gszClientName[CCLIENTNAMEMAX]; // Name of the client application
CHAR gszFileName[CBPATHMAX];
CHAR gszCaption[CCHILDREN][CBMESSAGEMAX];
CHAR gszProtocol[] = "StdFileEditing";
CHAR gszSProtocol[] = "Static";
CHAR gszTemp[] = "Fake Object";
CHAR gszAppClassName[] = "Package"; // Not NLS specific

CHAR szAppName[CBMESSAGEMAX];       // Application name
CHAR szUntitled[CBMESSAGEMAX];      // "(Untitled)" string FEATURE this is misnamed and used funny
CHAR szUndo[CBSHORTSTRING];         // "Undo %s" string
CHAR szContent[CBMESSAGEMAX];
CHAR szAppearance[CBMESSAGEMAX];
CHAR szDummy[CBSHORTSTRING];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\filedlgs.c ===
/* filedlgs.c - Handles the Windows 3.1 common dialogs.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include <commdlg.h>


static CHAR szCustFilterSpec[CBFILTERMAX];
static CHAR szFilterSpec[CBFILTERMAX];
static CHAR szLinkCaption[CBMESSAGEMAX];
static CHAR szImportFile[CBMESSAGEMAX];
static CHAR szExportFile[CBMESSAGEMAX];
static OPENFILENAME gofn;


static VOID AddExtension(LPOPENFILENAME lpOFN);



/* OfnInit() - Initializes the standard file dialog gofn structure.
 */
VOID
OfnInit(
    VOID
    )
{
    LPSTR lpstr;

    gofn.lStructSize         = sizeof(OPENFILENAME);
    gofn.hInstance           = ghInst;
    gofn.nMaxCustFilter      = CBFILTERMAX;
    gofn.nMaxFile            = CBPATHMAX;
    gofn.lCustData           = 0;
    gofn.lpfnHook            = NULL;
    gofn.lpTemplateName      = NULL;
    gofn.lpstrFileTitle      = NULL;

    LoadString(ghInst, IDS_IMPORTFILE, szImportFile, CBMESSAGEMAX);
    LoadString(ghInst, IDS_EXPORTFILE, szExportFile, CBMESSAGEMAX);
    LoadString(ghInst, IDS_CHANGELINK, szLinkCaption, CBMESSAGEMAX);
    LoadString(ghInst, IDS_ALLFILTER,  szFilterSpec, CBFILTERMAX);

    StringCchCat(szFilterSpec, ARRAYSIZE(szFilterSpec), "*.*");
}



/* OfnGetName() - Calls the standard file dialogs to get a file name
 */
BOOL
OfnGetName(
    HWND hwnd,
    UINT msg
    )
{
    gofn.hwndOwner           = hwnd;
    gofn.nFilterIndex        = 1;
    gofn.lpstrCustomFilter   = szCustFilterSpec;
    gofn.lpstrDefExt         = NULL;
    gofn.lpstrFile           = gszFileName;
    gofn.lpstrFilter         = szFilterSpec;
    gofn.lpstrInitialDir     = NULL;
    gofn.Flags               = OFN_HIDEREADONLY;

    Normalize(gszFileName);

    switch (msg)
    {
        case IDM_IMPORT:
            gofn.lpstrTitle = szImportFile;
            gofn.Flags |= OFN_FILEMUSTEXIST;

            return GetOpenFileName(&gofn);

        case IDM_EXPORT:
            gofn.lpstrTitle = szExportFile;
            gofn.Flags |= (OFN_PATHMUSTEXIST | OFN_NOREADONLYRETURN);

            return GetSaveFileName(&gofn);

        default:
            break;
    }

    return FALSE;
}



/* OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 */
HANDLE
OfnGetNewLinkName(
    HWND hwnd,
    HANDLE hData
    )
{
    BOOL fSuccess = FALSE;
    HANDLE hData2 = NULL;
    HANDLE hData3 = NULL;
    LPSTR lpstrData = NULL;
    LPSTR lpstrFile = NULL;
    LPSTR lpstrLink = NULL;
    LPSTR lpstrPath = NULL;
    LPSTR lpstrTemp = NULL;
    CHAR szDocFile[CBPATHMAX];
    CHAR szDocPath[CBPATHMAX];
    CHAR szServerFilter[4 * CBPATHMAX];

    // this may have to GlobalAlloc(), if a class supports
    // multiple extensions, like Pbrush then we could be in
    // trouble. I covered PBRUSH case by making array size 256

    // Get the link information
    if (!(lpstrData = GlobalLock(hData)))
        goto Error;

    // Figure out the link's path name and file name
    lpstrTemp = lpstrData;
    while (*lpstrTemp++)
        ;

    lpstrPath = lpstrFile = lpstrTemp;

    while (*(lpstrTemp = CharNext(lpstrTemp)))
    {
        if (*lpstrTemp == '\\')
            lpstrFile = lpstrTemp + 1;
    }

    // Copy the document name
    StringCchCopy(szDocFile, ARRAYSIZE(szDocFile), lpstrFile);
    *(lpstrFile - 1) = 0;

    // Copy the path name
    StringCchCopy(szDocPath, ARRAYSIZE(szDocPath), ((lpstrPath != lpstrFile) ? lpstrPath : ""));

    // If no directory, be sure the path points to the root
    if (lstrlen(szDocPath) == 2)
        StringCchCat(szDocPath, ARRAYSIZE(szDocPath), "\\");

    if (lpstrPath != lpstrFile)                 /* Restore the backslash */
        *(lpstrFile - 1) = '\\';

    while (*lpstrFile != '.' && *lpstrFile)     /* Get the extension */
        lpstrFile++;

    // Make a filter that respects the link's class name
    gofn.hwndOwner           = hwnd;
    gofn.nFilterIndex        = RegMakeFilterSpec(lpstrData, lpstrFile, szServerFilter);
    gofn.lpstrDefExt         = NULL;
    gofn.lpstrFile           = szDocFile;
    gofn.lpstrFilter         = szServerFilter;
    gofn.lpstrInitialDir     = szDocPath;
    gofn.lpstrTitle          = szLinkCaption;
    gofn.lpstrCustomFilter   = szCustFilterSpec;
    gofn.Flags               = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

    // If we get a file...
    if (GetOpenFileName(&gofn))
    {
        if (!(hData2 = GlobalAlloc(GMEM_ZEROINIT, CBPATHMAX *
            2)) || !(lpstrLink = lpstrTemp = GlobalLock(hData2)))
            goto Error;

        // ...add on the correct extension
        AddExtension(&gofn);

        // ... copy the server name
        while (*lpstrTemp++ = *lpstrData++)
            ;

        // ... copy the document name
        lstrcpy(lpstrTemp, szDocFile);
        lpstrTemp += lstrlen(lpstrTemp) + 1;
        lpstrData += lstrlen(lpstrData) + 1;

        // ... copy the item name
        while (*lpstrTemp++ = *lpstrData++)
            ;

        *lpstrTemp = 0;

        // ... and compress the memory block to minimal size
        GlobalUnlock(hData2);
        hData3 = GlobalReAlloc(hData2, (DWORD)(lpstrTemp - lpstrLink + 1), 0);

        if (!hData3)
            hData3 = hData2;

        fSuccess = TRUE;
    }

Error:
    if (!fSuccess)
    {
        if (lpstrLink)
            GlobalUnlock(hData2);

        if (hData2)
            GlobalFree(hData2);

        hData3 = NULL;
    }

    if (lpstrData)
        GlobalUnlock(hData);

    return hData3;
}



/* Normalize() - Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 */
VOID
Normalize(
    LPSTR lpstrFile
    )
{
    LPSTR lpstrBackslash = NULL;
    LPSTR lpstrTemp = lpstrFile;
    BOOL fInQuote = FALSE;
    BOOL fQState = FALSE;

    while (*lpstrTemp)
    {
        if (*lpstrTemp == CHAR_QUOTE)
            fInQuote = !fInQuote;

        if (*lpstrTemp == '\\') {
            fQState = fInQuote;
            lpstrBackslash = lpstrTemp;
        }

        if (gbDBCS)
        {
            lpstrTemp = CharNext(lpstrTemp);
        }
        else
        {
            lpstrTemp++;
        }
    }

    if (lpstrBackslash) {
        if (fQState)
            *lpstrFile++ = CHAR_QUOTE;

        MoveMemory(lpstrFile, lpstrBackslash + 1,
            lstrlen(lpstrBackslash) * sizeof(lpstrBackslash[0]) );
    }
}



/* AddExtension() - Adds the extension corresponding to the filter dropdown.
 */
static VOID
AddExtension(
    LPOPENFILENAME lpOFN
    )
{
    LPSTR lpstrFilter = (LPSTR)lpOFN->lpstrFilter;

    // If the user didn't specify an extension, use the default
    if (lpOFN->nFileExtension == (UINT)lstrlen(lpOFN->lpstrFile)
        && lpOFN->nFilterIndex)
    {
        // Skip to the appropriate filter
        while (*lpstrFilter && --lpOFN->nFilterIndex)
        {
            while (*lpstrFilter++)
                ;

            while (*lpstrFilter++)
                ;
        }

        // If we got to the filter, retrieve the extension
        if (*lpstrFilter)
        {
            while (*lpstrFilter++)
                ;

            lpstrFilter++;

            // Copy the extension
            if (lpstrFilter[1] != '*')
                lstrcat(lpOFN->lpstrFile, lpstrFilter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\globals.h ===
//
// Module: globals.h
//
// Global variable declarations for the Object Packager.
//
//


extern INT gcxIcon;
extern INT gcyIcon;
extern INT gcxArrange;              // Icon text wrap boundary
extern INT gcyArrange;
extern INT giXppli;                 // Number of pixels per logical
extern INT giYppli;                 // inch along width and height

extern BOOL gfEmbObjectOpen;
extern BOOL gfBlocked;
extern BOOL gfEmbedded;             // Editing an embedded object?
extern BOOL gfInvisible;            // Editing invisibly?
extern BOOL gfOleClosed;            // Should we send Ole_Closed or not?
extern BOOL gfEmbeddedFlag;         // Editing with /Embedded flag?
extern BOOL gfDocCleared;
extern BOOL gfServer;               // Is the server loaded?
extern BOOL gfDocExists;
extern BOOL gbDBCS;                 // Are we running in DBCS mode?

extern HANDLE ghInst;               // Unique instance identifier
extern HACCEL ghAccTable;           // Application specific accelerator table
extern HBRUSH ghbrBackground;       // Fill brush used to paint background
extern HFONT ghfontTitle;
extern HFONT ghfontChild;           // Font for caption bar
extern HCURSOR ghcurWait;           // Hourglass cursor

extern HWND ghwndFrame;             // Main window
extern HWND ghwndBar[];
extern HWND ghwndPane[];
extern HWND ghwndPict;
extern HWND ghwndError;             // Parent window when Error popup happens

extern INT gnCmdShowSave;           // Show flags; saved if started invisibly
extern UINT gcOleWait;              // OLE asynchronous transaction counter
extern LHCLIENTDOC glhcdoc;         // Handle to client document "link"
extern LPSAMPDOC gvlptempdoc;
extern LPAPPSTREAM glpStream;
extern LPOLECLIENT glpclient;
extern LPVOID glpobj[];
extern LPVOID glpobjUndo[];
extern HANDLE ghServer;             // Handle to server memory block
extern LPSAMPSRVR glpsrvr;          // Pointer to OLE server memory
extern LPSAMPDOC glpdoc;            // Pointer to current OLE document
extern DWORD gcbObject;
extern PANETYPE gpty[];
extern PANETYPE gptyUndo[];

extern OLECLIPFORMAT gcfFileName;   // Clipboard format "FileName"
extern OLECLIPFORMAT gcfLink;       // Clipboard format "ObjectLink"
extern OLECLIPFORMAT gcfNative;     // Clipboard format "Native"
extern OLECLIPFORMAT gcfOwnerLink;  // Clipboard format "OwnerLink"

extern CHAR gszClientName[CCLIENTNAMEMAX];        // Name of the client application
extern CHAR gszFileName[];
extern CHAR gszCaption[][CBMESSAGEMAX];
extern CHAR gszProtocol[];
extern CHAR gszSProtocol[];
extern CHAR gszTemp[];
extern CHAR gszAppClassName[];      // Not NLS specific

extern CHAR szAppName[];            // Application name
extern CHAR szUntitled[CBMESSAGEMAX];           // "(Untitled)" string FEATURE this is misnamed and used funny
extern CHAR szUndo[];               // "Undo %s" string
extern CHAR szContent[];
extern CHAR szAppearance[];
extern CHAR szDummy[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\embed.c ===
/* embed.c - Contains the routines for pseudo-embedding objects.
 *
 * Copyright (c) Microsoft Corporation, 1991-
 *
 * Why is it called pseudo-embedding?  Because it is not embedding
 * the object in the OLE sense; rather, it just pulls the entire
 * file into memory.
 */
#define _SECOND ((ULONGLONG) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)

#include "packager.h"
#include <shellapi.h>
#include "dialogs.h"
#include <wininet.h>
// #include <shell.h>        // For RealShellExecute() call.

#define OLEVERB_EDIT 1


static CHAR szDefTempFile[] = "PKG";
static OLECLIENTVTBL embClivtbl;
static BOOL bOleReleaseError = OLE_OK;
static HWND hTaskWnd;
static INT cEmbWait = 0;


DWORD MainWaitOnChild(LPVOID lpv);
static VOID ReplaceExtension(LPSTR lpstrTempFile, LPSTR lpstrOrigFile);
static DWORD GetFileLength(INT fh);
BOOL CALLBACK GetTaskWndProc(HWND hwnd, LPARAM lParam);
static BOOL EmbError(OLESTATUS retval);



BOOL _EmbExecute(LPCSTR pszFile, LPEMBED lpembed)
{
    DWORD err = NO_ERROR;
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT;
    sei.lpFile = pszFile;
    sei.nShow = SW_SHOWNORMAL;

    if (ShellExecuteEx(&sei)) 
    {
        if (lpembed->hContents)
        {
            GlobalFree(lpembed->hContents);
            lpembed->aTempName = AddAtom(pszFile);
            lpembed->dwSize    = 0;
            lpembed->hContents = NULL;
        }
        
        if (sei.hProcess)
        {
            // Start a thread to wait on the app and close packager once it has ended
            DWORD id;
            HANDLE hThd = CreateThread(NULL, 0, MainWaitOnChild, sei.hProcess, 0, &id );
            if (hThd) 
            {
                CloseHandle(hThd);
            }
            else
            {
                CloseHandle(sei.hProcess);
                err = GetLastError();
            }
        } 
        else
        {
            if (gfInvisible)
                PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }
    } 
    else
    {
        err = GetLastError();
    }

    if (err != NO_ERROR)
    {
        ErrorMessage((err == ERROR_NO_ASSOCIATION) ? E_FAILED_TO_FIND_ASSOCIATION : E_FAILED_TO_EXECUTE_COMMAND);
    }
    
    return  (err == NO_ERROR);
}

// Taken from shell code but slightly modified to eliminate problesm with finding ":" in the url
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = CharNext(pszPath))
        {
            switch (*pszPath)
            {
                case TEXT('.'):
                    pszDot = pszPath;   // remember the last dot
                    break;

                case '\\':
                case TEXT(' '):         // extensions can't have spaces
                    pszDot = NULL;      // forget last dot, it was in a directory
                    break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}

/* EmbActivate() - Performs activation of a pseudo-embedded file.
 *
 * Notes:  Assumes that lpstrFile is in the OEM character set.
 */
BOOL EmbActivate(LPEMBED lpembed, UINT wVerb)
{
    LPSTR lpFileData = NULL;

    CHAR szFileName[CBPATHMAX];
    CHAR szDefPath[CBPATHMAX];
    CHAR szTemp[CBPATHMAX];
    INT fh;
    BOOL fError = TRUE;
    LPSTR pExt = NULL;
    CHAR szCacheName[MAX_PATH];
    CHAR szUrlName[MAX_PATH + 20];
    FILETIME ftNow = {0};
    FILETIME ft = {0};
    SYSTEMTIME sysTime;
    ULONGLONG qwResult;
    //
    // If no hContents, we launched the server at some point...
    // so use the same temporary file name.
    //
    if (!lpembed->hContents)
    {
        if (lpembed->bOleSvrFile)
            return EmbDoVerb(lpembed, wVerb);

        if (lpembed->hTask)
        {
            hTaskWnd = NULL;
            EnumTaskWindows(lpembed->hTask, GetTaskWndProc, 0);

            if (hTaskWnd)
                BringWindowToTop(hTaskWnd);

            return TRUE;
        }

        if (!GetAtomName(lpembed->aTempName, szCacheName, ARRAYSIZE(szCacheName)))
            goto errRtn;
    }
    else
    {
        if (!GetAtomName(lpembed->aFileName, szFileName, ARRAYSIZE(szFileName))
            || !(lpFileData = GlobalLock(lpembed->hContents)))
            goto errRtn;

        GlobalUnlock(lpembed->hContents);

        // Find the extension -- we need it for the urlcache funcion
        pExt = PathFindExtension(szFileName);
        if('.' == *pExt)    // not expecting the '.'
            pExt++;

        GetSystemTime(&sysTime);
        SystemTimeToFileTime(&sysTime, &ft);

        // Create a fake URL in the format expected -- While not totally unique, close enough for our purposes (4 billion)
        StringCchPrintf(szUrlName, ARRAYSIZE(szUrlName), TEXT("Packager%u:%s"), ft.dwLowDateTime, szFileName);
        // So, now I'm pointing at the ext, and I have a fake url name, so
        if(!CreateUrlCacheEntry(szUrlName, ARRAYSIZE(szCacheName), pExt, szCacheName, 0))
            goto errRtn;

        if ((fh = _lcreat(szCacheName, 0)) < 0)
            goto errRtn;

        if (_lwrite(fh, lpFileData, lpembed->dwSize) < lpembed->dwSize)
        {
            _lclose(fh);
            DeleteFile(szCacheName);
            goto errRtn;
        }

        _lclose(fh);

        // exire this in 12 hours (arbitrarily longer than a work day) since we can't always clean it up ourselves.
        // Normally we'd only care about it for a very short time, and it probably
        // wouldn't hurt to have it cleaned up if it was open anyway.
        SystemTimeToFileTime(&sysTime, &ftNow);
        // Copy the time into a quadword.
        qwResult = (((ULONGLONG) ft.dwHighDateTime) << 32) + ft.dwLowDateTime;
        qwResult += (12 * _HOUR);
        // Copy the result back into the FILETIME structure.
        ft.dwLowDateTime  = (DWORD) (qwResult & 0xFFFFFFFF );
        ft.dwHighDateTime = (DWORD) (qwResult >> 32 ); 

        if(!CommitUrlCacheEntry(
            szUrlName, 
            szCacheName,
            ft,
            ftNow,
            0,
            NULL,
            0,
            pExt,
            szUrlName))
        {
            goto errRtn;
        }

    }

    if (lpembed->bOleSvrFile)
    {
        fError = !EmbActivateThroughOle(lpembed, szCacheName, wVerb);
        if (!fError)
        {
            GlobalFree(lpembed->hContents);
            lpembed->aTempName = AddAtom(szCacheName);
            lpembed->dwSize    = 0;
            lpembed->hContents = NULL;
        }

        goto errRtn;
    }

    // Try to execute the file
    lpembed->hTask = NULL;
    fError = !_EmbExecute(szCacheName, lpembed);
    if (fError)
    {
        DeleteFile(szCacheName);
    }

errRtn:
    if (fError)
    {
        if (gfInvisible)
            PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
    }
    else
    {
        Dirty();
    }

    return !fError;
}


/*****************************************************************************\
* MainWaitOnChild
*
* Waits for the specified child process to exit, then posts a message
* back to the main window.
*
* Arguments:
*
*   LPVOID lpv - Handle to the child process to wait on.
*
* Returns:
*   0
*
\*****************************************************************************/

DWORD
MainWaitOnChild(
    LPVOID lpv
    )
{
    if (WaitForSingleObject((HANDLE)lpv, INFINITE) == 0)
    {
        PostMessage(ghwndFrame, WM_READEMBEDDED, 0, 0);
    }

    CloseHandle((HANDLE)lpv);

    GetLastError(); //This seems ominous

    return 0;
}



/* EmbCreate() - Performs the pseudo-embedding of a file.
 *
 * Notes:  Assumes that lpstrFile is in the OEM character set.
 *
 *         This function is used by File Import..., is called
 *         when the Embed modifier is used on Drag&Drop, and
 *         is also used when Paste-ing a File manager file.
 */
LPEMBED
EmbCreate(
    LPSTR lpstrFile
    )
{
    ATOM aFileName = 0;
    BOOL fError = TRUE;
    DWORD dwSize = 0;
    HANDLE hdata = NULL;
    HANDLE hFileData = NULL;
    LPEMBED lpembed = NULL;
    LPSTR lpFileData = NULL;
    INT fh = 0;

    if (lpstrFile)
    {
        if ((fh = _lopen(lpstrFile, OF_READ | OF_SHARE_DENY_WRITE)) == HFILE_ERROR)
        {
            ErrorMessage(IDS_ACCESSDENIED);
            goto errRtn;
        }

        // Seek to EOF, then to the top of the file.
        dwSize = GetFileLength(fh);
        if (0 == dwSize)
        {
            ErrorMessage(IDS_NOZEROSIZEFILES);
            goto errRtn;
        }

        if (!(aFileName = AddAtom(lpstrFile))
            || !(hFileData = GlobalAlloc(GMEM_MOVEABLE, dwSize))
            || !(lpFileData = GlobalLock(hFileData)))
        {
            ErrorMessage(IDS_LOWMEM);
            goto errRtn;
        }

        if (_lread(fh, lpFileData, dwSize) != dwSize)
        {
            ErrorMessage(E_FAILED_TO_READ_FILE);
            goto errRtn;
        }
    }

    if (!(hdata = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(EMBED)))
        || !(lpembed = (LPEMBED)GlobalLock(hdata)))
    {
        ErrorMessage(IDS_LOWMEM);
        goto errRtn;
    }

    lpembed->aFileName = aFileName;
    lpembed->dwSize = dwSize;
    lpembed->hContents = hFileData;
    lpembed->hdata = hdata;
    lpembed->bOleSvrFile = IsOleServerDoc(lpstrFile);
    fError = FALSE;

errRtn:
    if (fh)
        _lclose(fh);

    if (lpFileData)
        GlobalUnlock(hFileData);

    if (fError)
    {
        if (hdata)
            GlobalFree(hdata);

        if (aFileName)
            DeleteAtom(aFileName);

        if (hFileData)
            GlobalFree(hFileData);
    }

    return lpembed;
}



/* EmbDelete() - Deallocate the pseudo-embedded file.
 */
VOID
EmbDelete(
    LPEMBED lpembed
    )
{
    HANDLE  hdata;

    if (!lpembed)
        return;

    if (lpembed->lpLinkObj)
    {
        EmbRead(glpobj[CONTENT]);
        EmbDeleteLinkObject(lpembed);
    }
    else {
        /* If the task is active, there's nothing we can do */
#if 0
        if (lpembed->hSvrInst)
            TermToolHelp(lpembed);
#endif  //FEATURE: Does anything need to be done for this case? Like terminating the waiting thread, perhaps?
    }

    if (lpembed->aFileName)
    {
        DeleteAtom(lpembed->aFileName);
        lpembed->aFileName = 0;
    }

    if (lpembed->aTempName)
    {
        DeleteAtom(lpembed->aTempName);
        lpembed->aTempName = 0;
    }

    if (lpembed->hContents)
    {
        GlobalFree(lpembed->hContents);
        lpembed->dwSize = 0;
        lpembed->hContents = NULL;
    }

    GlobalUnlock(hdata = lpembed->hdata);
    GlobalFree(hdata);
}



/* EmbDraw() - Draw the pseudo-embedded object.
 *
 * Note:  This drawing is DESCRIPTION-ONLY.
 */
VOID
EmbDraw(
    LPEMBED lpembed,
    HDC hdc,
    LPRECT lprc,
    BOOL fFocus
    )
{
    RECT rcFocus;
    CHAR szEmbedFile[CBMESSAGEMAX];
    CHAR szFileName[CBPATHMAX];
    CHAR szMessage[CBMESSAGEMAX + CBPATHMAX];

    if (GetAtomName(lpembed->aFileName, szFileName, CBPATHMAX)
        && LoadString(ghInst, IDS_EMBEDFILE, szEmbedFile, CBMESSAGEMAX))
    {
        Normalize(szFileName);
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szEmbedFile, (LPSTR)szFileName);

        DrawText(hdc, szMessage, -1, lprc,
            DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        if (fFocus)
        {
            rcFocus = *lprc;
            DrawText(hdc, szMessage, -1, &rcFocus, DT_CALCRECT | DT_NOPREFIX |
                DT_LEFT | DT_TOP | DT_SINGLELINE);
            OffsetRect(&rcFocus, (lprc->left + lprc->right - rcFocus.right) /
                2, (lprc->top + lprc->bottom - rcFocus.bottom) / 2);
            DrawFocusRect(hdc, &rcFocus);
        }
    }
}



/* EmbReadFromNative() - Reads a pseudo-embedded object from memory.
 *
 * Notes:  This function is called by GetNative().
 */
LPEMBED
EmbReadFromNative(
    LPSTR *lplpstr
    )
{
    BOOL fError = TRUE;
    DWORD dwSize;
    HANDLE hData = NULL;
    LPEMBED lpembed = NULL;
    LPSTR lpData = NULL;
    CHAR szFileName[CBPATHMAX];

    MemRead(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));
    MemRead(lplpstr, (LPSTR)szFileName, dwSize);
    MemRead(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));

    if (!(lpembed = EmbCreate(NULL))
        || !(hData = GlobalAlloc(GMEM_MOVEABLE, dwSize))
        || !(lpData = GlobalLock(hData)))
        goto errRtn;

    MemRead(lplpstr, (LPSTR)lpData, dwSize);

    lpembed->aFileName = AddAtom(szFileName);
    lpembed->dwSize = dwSize;
    lpembed->hContents = hData;
    lpembed->bOleSvrFile = IsOleServerDoc(szFileName);
    fError = FALSE;

errRtn:
    if (lpData)
        GlobalUnlock(hData);

    if (fError)
    {
        if (hData)
            GlobalFree(hData);

        if (lpembed)
        {
            EmbDelete(lpembed);
            lpembed = NULL;
        }
    }

    return lpembed;
}



/* EmbWriteToNative() - Used to save pseudo-embed to memory.
 *
 * Note:  This function is called by GetNative().
 */
DWORD
EmbWriteToNative(
    LPEMBED lpembed,
    LPSTR *lplpstr
    )
{
    BOOL fError = TRUE;
    DWORD cBytes = 0;
    DWORD dwSize;
    HANDLE hData = NULL;
    LPSTR lpData = NULL;
    LPSTR lpFileData = NULL;
    CHAR szFileName[CBPATHMAX];
    INT fhTemp = -1;
    CHAR * hplpstr;

    if (!GetAtomName(lpembed->aFileName, szFileName, CBPATHMAX))
        goto errRtn;

    if (!lplpstr)
    {
        cBytes = lstrlen(szFileName) + 1 + sizeof(dwSize);
    }
    else
    {
        dwSize = lstrlen(szFileName) + 1;
        MemWrite(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));
        MemWrite(lplpstr, (LPSTR)szFileName, dwSize);
    }

    // Read from memory if it's there; otherwise, it's executing
    if (lpembed->hContents)
    {
        cBytes += sizeof(lpembed->dwSize) + lpembed->dwSize;

        if (lplpstr)
        {
            if (!(lpFileData = GlobalLock(lpembed->hContents)))
                goto errRtn;

            MemWrite(lplpstr, (LPSTR)&(lpembed->dwSize), sizeof(lpembed->dwSize));
            MemWrite(lplpstr, (LPSTR)lpFileData, lpembed->dwSize);
        }
    } else {
        int i;

        if (!GetAtomName(lpembed->aTempName, szFileName, CBPATHMAX))
            goto errRtn;

        for (i = 0; i < 5; i++ ) {
            int j;

            fhTemp = _lopen(szFileName, OF_READ | OF_SHARE_DENY_WRITE);

            if (fhTemp != HFILE_ERROR) {
                break;
            }

            /*
             * We could not open the file.  It is probably still open by the
             * server.  Wait 5 seconds for the server to finish closing the
             * file and then try again.
             */
            for (j=0; j<25; j++) {
                MSG msg;
                PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
                Sleep(200);
            }
        }

        /*
         * If after 25 seconds we still could not open the file, then it
         * must be screwed
         */
        if (fhTemp == HFILE_ERROR)
            goto errRtn;

        dwSize = GetFileLength(fhTemp);

        if (!lplpstr)
            cBytes += sizeof(dwSize) + dwSize;
        else
        {
            MemWrite(lplpstr, (LPSTR)&dwSize, sizeof(dwSize));
            _lread(fhTemp, *lplpstr, dwSize);

            // Increment the pointer being read into
            hplpstr = *lplpstr;
            hplpstr += dwSize;
            *lplpstr = hplpstr;
        }
    }

    fError = FALSE;

errRtn:
    if (fhTemp >= 0)
    {
        _lclose(fhTemp);
        if (!fError && lplpstr && !(lpembed->hTask || lpembed->lpLinkObj))
            DeleteFile(szFileName);
    }

    if (lpData)
        GlobalUnlock(hData);

    if (hData)
        GlobalFree(hData);

    if (lpFileData)
        GlobalUnlock(lpembed->hContents);

    return (fError ? ((DWORD)(-1L)) : cBytes);
}



/* EmbWriteToFile() - Used to save pseudo-embed to a file.
 *
 * Note:  This function is called by File Export...
 */
VOID
EmbWriteToFile(
    LPEMBED lpembed,
    INT fh
    )
{
    BOOL fError = TRUE;
    DWORD dwSize;
    HANDLE hData = NULL;
    LPSTR lpData = NULL;
    LPSTR lpFileData = NULL;
    CHAR szTempName[CBPATHMAX];
    INT fhTemp = -1;
    CHAR szMessage[CBMESSAGEMAX];

    // Read from memory if it's there
    if (lpembed->hContents)
    {
        if (!(lpFileData = GlobalLock(lpembed->hContents)))
            goto errRtn;

        if (_lwrite(fh, lpFileData, lpembed->dwSize) != lpembed->dwSize)
            goto errRtn;
    }
    else
    {
        // otherwise, it is/was executing
        if (lpembed->hTask && !gfInvisible)
        {
            // Object being edited, snapshot current contents?
            LoadString(ghInst, IDS_ASKCLOSETASK, szMessage, CBMESSAGEMAX);
            BringWindowToTop(ghwndFrame);
            switch (MessageBoxAfterBlock(ghwndError, szMessage, szAppName,
                 MB_OKCANCEL))
            {
                case IDOK:
                    break;

                case IDCANCEL:
                    return;
            }
        }

        if (!GetAtomName(lpembed->aTempName, szTempName, CBPATHMAX)
            || (fhTemp = _lopen(szTempName, OF_READ | OF_SHARE_DENY_WRITE)) == HFILE_ERROR)
            goto errRtn;

        dwSize = GetFileLength(fhTemp);
        while (dwSize && !(hData = GlobalAlloc(GMEM_MOVEABLE, dwSize)))
            dwSize = dwSize >> 1;

        if (!dwSize || !(lpData = GlobalLock(hData)))
            goto errRtn;

        while (dwSize)
        {
            dwSize = _lread(fhTemp, lpData, dwSize);

            if (dwSize)
                _lwrite(fh, lpData, dwSize);
        }
    }

    fError = FALSE;

errRtn:
    if (fhTemp >= 0)
    {
        _lclose(fhTemp);

        if (!fError && !lpembed->hTask)
            DeleteFile(gszFileName);
    }

    if (lpData)
        GlobalUnlock(hData);

    if (hData)
        GlobalFree(hData);

    if (lpFileData)
        GlobalUnlock(lpembed->hContents);
}



/* ReplaceExtension() - Replaces the extension of the temp file.
 *
 * This routine ensures that the temp file has the same extension as the
 * original file, so that the ShellExecute() will load the same file.
 */
static VOID
ReplaceExtension(
    LPSTR lpstrTempFile,
    LPSTR lpstrOrigFile
    )
{
    LPSTR lpstrBack = NULL;

    // Get temp file extension
    while (*lpstrTempFile)
    {
        if (*lpstrTempFile == '\\')
            lpstrBack = lpstrTempFile;

        if (gbDBCS)
        {
            lpstrTempFile = CharNext(lpstrTempFile);
        }
        else
        {
            lpstrTempFile++;
        }
    }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
        lpstrBack++;

    if (lpstrBack && *lpstrBack)
        lpstrTempFile = lpstrBack + 1;

    // Get original file extension
    while (*lpstrOrigFile)
    {
        if (*lpstrOrigFile == '\\')
            lpstrBack = lpstrOrigFile;

        if (gbDBCS)
        {
            lpstrOrigFile = CharNext(lpstrOrigFile);
        }
        else
        {
            lpstrOrigFile++;
        }
    }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
        lpstrBack++;

    if (lpstrBack && *lpstrBack)
    {
        lpstrOrigFile = lpstrBack + 1;

        // Move the extension on over
        lstrcpy(lpstrTempFile, lpstrOrigFile);
    }
    else
    {
         /* Wipe out the extension altogether */
        *lpstrTempFile = 0;
    }
}



/* GetFileLength() - Obtain the size of the temporary file used.
 *
 * Returns:         The length of the file in bytes.
 * Side effects:    Resets fh to the beginning of the file.
 */
static DWORD
GetFileLength(
    INT fh
    )
{
    DWORD dwSize;

    dwSize = _llseek(fh, 0L, 2);
    _llseek(fh, 0L, 0);

    return dwSize;
}



/* EmbRead() - Reads the contents back when the task has terminated.
 */
VOID
EmbRead(
    LPEMBED lpembed
    )
{
    BOOL fError = TRUE;
    DWORD dwSize;
    HANDLE hFileData = NULL;
    LPSTR lpFileData = NULL;
    CHAR szTempFileName[CBPATHMAX];
    INT fhTemp = -1;

    if (!lpembed || !lpembed->aTempName)
        return;

    if (!GetAtomName(lpembed->aTempName, szTempFileName, CBPATHMAX))
        return;

    if ((fhTemp = _lopen(szTempFileName, OF_READ | OF_SHARE_DENY_WRITE)) == HFILE_ERROR)
        goto errRtn;

    dwSize = GetFileLength(fhTemp);

    if (!(hFileData = GlobalAlloc(GMEM_MOVEABLE, dwSize))
        || !(lpFileData = GlobalLock(hFileData))
        || (_lread(fhTemp, lpFileData, dwSize) != dwSize))
        goto errRtn;

    DeleteAtom(lpembed->aTempName);
    lpembed->aTempName  = 0;
    lpembed->dwSize     = dwSize;
    lpembed->hContents  = hFileData;
    lpembed->hTask      = NULL;

    fError = FALSE;

errRtn:
    if (fhTemp >= 0)
    {
        _lclose(fhTemp);

        if (!fError)
            DeleteFile(szTempFileName);
    }

    if (lpFileData)
        GlobalUnlock(hFileData);

    if (fError && hFileData)
        GlobalFree(hFileData);
}



BOOL CALLBACK
GetTaskWndProc(
    HWND hwnd,
    LPARAM lParam
    )
{
    if (IsWindowVisible(hwnd))
    {
        hTaskWnd = hwnd;
        return FALSE;
    }

    return TRUE;
}



BOOL
EmbDoVerb(
    LPEMBED lpembed,
    UINT wVerb
    )
{
    if (wVerb == IDD_PLAY)
    {
        if (EmbError(OleActivate(lpembed->lpLinkObj, OLEVERB_PRIMARY, TRUE,
            TRUE, NULL, NULL)))
            return FALSE;
    }
    else
    {
        // it must be verb IDD_EDIT
        if (EmbError(OleActivate(lpembed->lpLinkObj, OLEVERB_EDIT, TRUE,
            TRUE, NULL, NULL)))
            return FALSE;
    }

    WaitForObject(lpembed->lpLinkObj);

    if (bOleReleaseError != OLE_OK)
    {
        bOleReleaseError = OLE_OK;
        return FALSE;
    }

    // if the verb is IDD_PLAY then we need not do any more
    if (wVerb == IDD_PLAY)
        return TRUE;

    // If the verb is IDD_EDIT, then we must show the server, and we will do
    // that by calling server's show method
    if (EmbError((*(lpembed->lpLinkObj)->lpvtbl->Show)(lpembed->lpLinkObj,
        TRUE)))
        return FALSE;

    WaitForObject(lpembed->lpLinkObj);

    if (bOleReleaseError != OLE_OK)
    {
        bOleReleaseError = OLE_OK;
        return FALSE;
    }

    return TRUE;
}



BOOL
EmbActivateThroughOle(
    LPEMBED lpembed,
    LPSTR lpdocname,
    UINT wVerb
    )
{
    bOleReleaseError = OLE_OK;

    if (!(lpembed->lpclient = PicCreateClient(&EmbCallBack, &embClivtbl)))
        return FALSE;

    if (EmbError(OleCreateLinkFromFile(gszProtocol, lpembed->lpclient, NULL,
        lpdocname, NULL, glhcdoc, gszCaption[CONTENT], &lpembed->lpLinkObj,
        olerender_none, 0)))
        return  FALSE;

    WaitForObject(lpembed->lpLinkObj);

    if (bOleReleaseError == OLE_OK)
    {
        if (gfEmbObjectOpen = EmbDoVerb(lpembed, wVerb))
            return TRUE;
    }

    EmbDeleteLinkObject(lpembed);

    return FALSE;
}



/* EmbCallBack() - Routine that OLE client DLL calls when events occur.
 */
INT CALLBACK
EmbCallBack(
    LPOLECLIENT lpclient,
    OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject
    )
{
    switch (flags)
    {
    case OLE_CLOSED:
    case OLE_SAVED:
    case OLE_CHANGED:
        break;

    case OLE_RELEASE:
        if (cEmbWait)
            --cEmbWait;

        bOleReleaseError = OleQueryReleaseError(lpObject);
        break;

    default:
        break;
    }

    return 0;
}



VOID
EmbDeleteLinkObject(
    LPEMBED lpembed
    )
{
    HGLOBAL hg;

    bOleReleaseError = OLE_OK;

    if (!lpembed->lpLinkObj)
        return;

    WaitForObject(lpembed->lpLinkObj);

    if (!EmbError(OleDelete(lpembed->lpLinkObj)))
        WaitForObject (lpembed->lpLinkObj);

    lpembed->lpLinkObj = NULL;

    if (lpembed->lpclient)
    {
        if (hg = GlobalHandle(lpembed->lpclient))
        {
            GlobalUnlock(hg);
            GlobalFree(hg);
        }

        lpembed->lpclient = NULL;
    }

    gfEmbObjectOpen = FALSE;
    bOleReleaseError = OLE_OK;
}



static BOOL
EmbError(
    OLESTATUS retval
    )
{
    switch (retval)
    {
    case OLE_WAIT_FOR_RELEASE:
        cEmbWait++;
        return FALSE;

    case OLE_OK:
        return FALSE;

    default:
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\icon.c ===
/* icon.c - Handles Icon + Caption objects.
 */

#include "packager.h"
#include <shellapi.h>
// #include <shlapip.h>


static LPIC IconCreate(VOID);
void GetDisplayName(LPSTR szName, LPCSTR szPath);



/* IconClone() -
 *
 * Clones an appearance pane icon.
 */
LPIC
IconClone(
    LPIC lpic
    )
{
    LPIC lpicNew;

    if (lpicNew = IconCreate())
    {
        // Get the icon
        StringCchCopy(lpicNew->szIconPath, ARRAYSIZE(lpicNew->szIconPath), lpic->szIconPath);
        lpicNew->iDlgIcon = lpic->iDlgIcon;
        GetCurrentIcon(lpicNew);

        // Get the icon text
        StringCchCopy(lpicNew->szIconText, ARRAYSIZE(lpicNew->szIconText), lpic->szIconText);
    }

    return lpicNew;
}



/* IconCreate() -
 */
static LPIC
IconCreate(
    VOID
    )
{
    HANDLE hdata = NULL;
    LPIC lpic = NULL;

    if (!(hdata = GlobalAlloc(GMEM_MOVEABLE, sizeof(IC)))
        || !(lpic = (LPIC)GlobalLock(hdata)))
        goto errRtn;

    // Store the data in the window itself
    lpic->hdata = hdata;
    lpic->hDlgIcon = NULL;
    lpic->iDlgIcon = 0;
    *lpic->szIconPath = 0;
    *lpic->szIconText = 0;

    return lpic;

errRtn:
    ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);

    if (lpic)
        GlobalUnlock(hdata);

    if (hdata)
        GlobalFree(hdata);

    return NULL;
}



/* IconCreateFromFile() -
 *
 * Allows an appearance pane icon to be created automatically if
 * a file is dropped, imported, or pasted into the packager.
 */
LPIC
IconCreateFromFile(
    LPSTR lpstrFile
    )
{
    LPIC lpic;

    if (lpic = IconCreate())
    {
        // Get the icon
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), lpstrFile);
        lpic->iDlgIcon = 0;

        if (*(lpic->szIconPath))
            GetCurrentIcon(lpic);

        // Get the icon text
        GetDisplayName(lpic->szIconText, lpstrFile);
    }

    return lpic;
}



/* IconCreateFromObject() -
 *
 * Allows an appearance pane icon to be created automatically if an
 * OLE object is dropped into the appearance pane.
 */
LPIC
IconCreateFromObject(
    LPOLEOBJECT lpObject
    )
{
    DWORD otObject;
    HANDLE hdata;
    LPIC lpic = NULL;
    LPSTR lpdata;

    OleQueryType(lpObject, &otObject);

    if ((otObject == OT_LINK
        && Error(OleGetData(lpObject, gcfLink, &hdata)))
        || (otObject == OT_EMBEDDED
        && Error(OleGetData(lpObject, gcfOwnerLink, &hdata))))
        hdata = NULL;

    if (hdata && (lpdata = GlobalLock(hdata)))
    {
        if (lpic = IconCreate())
        {
            // Get the icon
            RegGetExeName(lpic->szIconPath, lpdata, CBPATHMAX);
            lpic->iDlgIcon = 0;
            GetCurrentIcon(lpic);

            // Get the icon text
            switch (otObject)
            {
            case OT_LINK:
                while (*lpdata++)
                    ;

                StringCchCopy(lpic->szIconText, ARRAYSIZE(lpic->szIconText), lpdata);
                Normalize(lpic->szIconText);
                break;

            case OT_EMBEDDED:
                RegGetClassId(lpic->szIconText, ARRAYSIZE(lpic->szIconText), lpdata);
                break;
            }

            GlobalUnlock(hdata);
        }
    }

    return lpic;
}



/* IconDelete() - Used to clear the appearance pane of icon stuff.
 */
VOID
IconDelete(
    LPIC lpic
    )
{
    HANDLE hdata;

    if (!lpic)
        return;

    if (lpic->hDlgIcon)
        DestroyIcon(lpic->hDlgIcon);

    GlobalUnlock(hdata = lpic->hdata);
    GlobalFree(hdata);
}



/* IconDraw() - Used to draw the icon and its caption.
 */
VOID
IconDraw(
    LPIC lpic,
    HDC hdc,
    LPRECT lprc,
    BOOL fFocus,
    INT cxImage,
    INT cyImage
    )
{
    BOOL fMF;
    HFONT hfont = NULL;
    RECT rcText;
    DWORD dwLayout;

    hfont = SelectObject(hdc, ghfontTitle);
    if (!(fMF = (cxImage && cyImage)))
    {
        // Figure out how large the text region will be
        if (*(lpic->szIconText))
        {
            SetRect(&rcText, 0, 0, gcxArrange - 1, gcyArrange - 1);
            DrawText(hdc, lpic->szIconText, -1, &rcText,
                DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);
        }
        else
        {
            SetRect(&rcText, 0, 0, 0, 0);
        }

        // Figure out the image dimensions
        cxImage = (gcxIcon > rcText.right) ? gcxIcon : rcText.right;
        cyImage = gcyIcon + rcText.bottom;
    }

    // Draw the icon
    if (lpic->hDlgIcon)
    {
        // Do not mirror the Icon.
        dwLayout = GetLayout(hdc);
        if ((dwLayout != GDI_ERROR) && (dwLayout & LAYOUT_RTL)) {
            SetLayout(hdc, dwLayout | LAYOUT_BITMAPORIENTATIONPRESERVED);
        }
        DrawIcon(hdc, (lprc->left + lprc->right - gcxIcon) / 2,
            (lprc->top + lprc->bottom - cyImage) / 2, lpic->hDlgIcon);
        if ((dwLayout != GDI_ERROR) && (dwLayout & LAYOUT_RTL)) {
            SetLayout(hdc, dwLayout);
        }
    }

    // Draw the icon text
    if (*(lpic->szIconText))
    {
        if (fMF)
        {
            SetBkMode(hdc, TRANSPARENT);
            SetTextAlign(hdc, TA_CENTER);
            TextOut(hdc, cxImage / 2, gcyIcon + 1, lpic->szIconText,
                lstrlen(lpic->szIconText));
        }
        else
        {
            OffsetRect(&rcText, (lprc->left + lprc->right - cxImage) / 2,
                (lprc->top + lprc->bottom - cyImage) / 2 + gcyIcon);
            DrawText(hdc, lpic->szIconText, -1, &rcText,
                DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);
        }
    }

    if (hfont)
        SelectObject(hdc, hfont);

    if (fFocus && cxImage && cyImage)
    {
        RECT rcFocus;

        SetRect(&rcFocus, (lprc->left + lprc->right - cxImage) / 2, (lprc->top +
            lprc->bottom - cyImage) / 2, (lprc->left + lprc->right + cxImage) /
            2, (lprc->top + lprc->bottom + cyImage) / 2);
        DrawFocusRect(hdc, &rcFocus);
    }
}



/* IconReadFromNative() - Used to retrieve the icon object from memory.
 */
LPIC
IconReadFromNative(
    LPSTR *lplpstr
    )
{
    LPIC lpic;
    WORD w;

    if (lpic = IconCreate())
    {
        StringCchCopy(lpic->szIconText, ARRAYSIZE(lpic->szIconText), *lplpstr);
        *lplpstr += lstrlen(lpic->szIconText) + 1;
        StringCchCopy(lpic->szIconPath, ARRAYSIZE(lpic->szIconPath), *lplpstr);
        *lplpstr += lstrlen(lpic->szIconPath) + 1;
        MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
        lpic->iDlgIcon = (INT)w;
        GetCurrentIcon(lpic);
    }

    return lpic;
}



/* IconWriteToNative() - Used to write the icon object to memory.
 */
DWORD
IconWriteToNative(
    LPIC lpic,
    LPSTR *lplpstr
    )
{
    DWORD cBytes;
    WORD w;

    if (lplpstr)
    {
        // Now, write out the icon text and the icon
        cBytes = lstrlen(lpic->szIconText) + 1;
        MemWrite(lplpstr, (LPSTR)lpic->szIconText, cBytes);

        cBytes = lstrlen(lpic->szIconPath) + 1;
        MemWrite(lplpstr, (LPSTR)lpic->szIconPath, cBytes);
        w = (WORD)lpic->iDlgIcon;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
    }

    return (lstrlen(lpic->szIconText) + 1 + lstrlen(lpic->szIconPath) + 1 +
        sizeof(WORD));
}



VOID
GetCurrentIcon(
    LPIC lpic
    )
{
    WORD wIcon = (WORD)lpic->iDlgIcon;

    if (lpic->hDlgIcon)
        DestroyIcon(lpic->hDlgIcon);

    if (!(lpic->hDlgIcon = ExtractAssociatedIcon(ghInst, lpic->szIconPath,
            &wIcon)))
        lpic->hDlgIcon = LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION));

}

//
//  get the nice name to show to the user given a filename
//
//  FEATURE: we realy should just call the shell!!!
//
void GetDisplayName(LPSTR szName, LPCSTR szPath)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    BOOL   IsLFN;

    StringCchCopy(szName, MAX_PATH, szPath);    // verified

    h = FindFirstFile(szPath, &fd);

    if (h != INVALID_HANDLE_VALUE)
    {
        FindClose(h);
        StringCchCopy(szName, MAX_PATH, fd.cFileName);

        IsLFN = !(fd.cAlternateFileName[0] == 0 ||
            lstrcmp(fd.cFileName, fd.cAlternateFileName) == 0);

        if (!IsLFN)
        {
            AnsiLower(szName);
            AnsiUpperBuff(szName, 1);
        }
    }
    else
    {
        Normalize(szName);          // strip path part
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\ids.h ===
/*
 * ids.h - Header file for OLE demo's resource file.
 */


/* Application resource ID */
#define ID_APPLICATION  1
#define SPLIT           2

/* File menu */
#define IDM_UPDATE      0x101
#define IDM_IMPORT      0x102
#define IDM_EXPORT      0x103
#define IDM_EXIT        0x104
#define IDM_NEW         0x106

/* Edit menu */
#define POS_EDITMENU    1
#define IDM_UNDO        0x200
#define IDM_CUT         0x201
#define IDM_COPY        0x202
#define IDM_PASTE       0x203
#define IDM_PASTELINK   0x204
#define IDM_CLEAR       0x206
#define IDM_LINKS       0x208
#define IDM_INSERTICON  0x209
#define IDM_LABEL       0x20a
#define IDM_COMMAND     0x20b
#define IDM_COPYPACKAGE 0x20d
#define IDM_PICT        0x20e
#define IDM_DESC        0x20f
#define IDM_NEXTWINDOW  0x210

/* Object popup menu */
#define POS_OBJECT      12      // position of Object item in Edit menu
#define IDM_OBJECT      0x220
#define IDM_VERBMIN     0x221
#define IDM_VERBMAX     0x230


/* Help menu */
#define IDM_INDEX       0x0280
#define IDM_SEARCH      0x0281
#define IDM_USINGHELP   0x0282
#define IDM_ABOUT       0x0283


#define IDM_LINKDONE    0x307


/* Pop up menu */
#define IDM_EMBEDFILE   0x2c0
#define IDM_LINKFILE    0x2c1

/* String table constants */
#define IDS_APPNAME         0x100
#define IDS_UNTITLED        0x101
#define IDS_MAYBESAVE       0x102
#define IDS_FILTER          0x106
#define IDS_CHANGELINK      0x108
#define IDS_ALLFILTER       0x109
#define IDS_CONTENT         0x10f
#define IDS_DESCRIPTION     0x110
#define IDS_PICTURE         0x111
#define IDS_APPEARANCE      0x112
#define IDS_INSERTICON      0x113
#define IDS_VIEW            0x114
#define IDS_LINKTOFILE      0x115
#define IDS_IMPORTFILE      0x116
#define IDS_EXPORTFILE      0x117
#define IDS_EMBEDFILE       0x118
#define IDS_MAYBEUPDATE     0x119
#define IDS_FROZEN          0x11a
#define IDS_OBJECT          0x11b
#define IDS_ASKCLOSETASK    0x120
#define IDS_OVERWRITE       0x121
#define IDS_PRIMARY_VERB    0x122
#define IDS_SECONDARY_VERB  0x123
#define IDS_FAILEDUPDATE    0x124
#define IDS_OBJECT_MENU     0x125
#define IDS_UNDO_MENU       0x126
#define IDS_CONTENT_OBJECT  0x127
#define IDS_APPEARANCE_OBJECT 0x128
#define IDS_GENERIC         0x129
#define IDS_EDIT            0x12a
#define IDS_EMBNAME_CONTENT 0x12b
#define IDS_INVALID_FILENAME 0x12c
#define IDS_POPUPVERBS        0x12d
#define IDS_SINGLEVERB        0x12e

/* Error messages */
#define E_FAILED_TO_READ_FILE           0x201
#define E_FAILED_TO_SAVE_FILE           0x202
#define E_FAILED_TO_READ_OBJECT         0x206
#define E_FAILED_TO_DELETE_OBJECT       0x207
#define E_CLIPBOARD_COPY_FAILED         0x209
#define E_GET_FROM_CLIPBOARD_FAILED     0x20a
#define E_FAILED_TO_CREATE_CHILD_WINDOW 0x20b
#define E_FAILED_TO_CREATE_OBJECT       0x20c
#define E_UNEXPECTED_RELEASE            0x20e
#define E_FAILED_TO_LAUNCH_SERVER       0x20f
#define E_FAILED_TO_UPDATE              0x210
#define E_FAILED_TO_FREEZE              0x211
#define E_FAILED_TO_UPDATE_LINK         0x212
#define E_FAILED_TO_REGISTER_SERVER     0x214
#define E_FAILED_TO_REGISTER_DOCUMENT   0x215
#define E_FAILED_TO_RECONNECT_OBJECT    0x217
#define E_FAILED_TO_EXECUTE_COMMAND     0x21a
#define E_FAILED_TO_FIND_ASSOCIATION    0x21b

#define W_STATIC_OBJECT                 0x301
#define W_FAILED_TO_CLONE_UNDO          0x302
#define W_FAILED_TO_NOTIFY              0x305

#define IDS_AUTO                        0x400
#define IDS_MANUAL                      0x401
#define IDS_CANCELED                    0x402

#define IDS_BROWSE                      0x500
#define IDS_CHNGICONPROGS               0x508
#define IDS_ACCESSDENIED                0x509
#define IDS_LOWMEM                      0x510
#define IDS_NOICONSTITLE                0x511
#define IDS_NOICONSMSG                  0x512
#define IDS_NOZEROSIZEFILES             0x513
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\packager.h ===
/* packager.h - Constants, types, and exports from the main module.
 */

#include <windows.h>
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x)/sizeof(x[0]))
#endif

#ifdef STRICT
#   undef STRICT
#   define PACKGR_STRICT
#endif

#define SERVERONLY
#include <ole.h>

#ifdef PACKGR_STRICT
#   define STRICT
#   undef PACKGR_STRICT
#endif

#include "ids.h"


#define HIMETRIC_PER_INCH   2540    // Number of HIMETRIC units per inch
#define DEF_LOGPIXELSX      96      // Default values for pixels per
#define DEF_LOGPIXELSY      96      // logical inch

#define KEYNAMESIZE         300     // Maximum registration key length

#define CCLIENTNAMEMAX      50      // Maximum length of client app name
#define CBCMDLINKMAX        500
#define CBMESSAGEMAX        128
#define CBSTRINGMAX         256     // Maximum lenght of a string in the res.
#define CBSHORTSTRING       20
#define CBFILTERMAX         50      // Max # chars in a filter specification
#define CBPATHMAX           260     // Most chars in a fully qual. filename

#define CharCountOf(a)      (sizeof(a) / sizeof(a[0]))

#define CITEMSMAX           100

#define APPEARANCE          0
#define CONTENT             1
#define CCHILDREN           2       // Number of panes which precede

#define OLE_PLAY            0
#define OLE_EDIT            1

#define WM_FIXSCROLL        (WM_USER+100)
#define WM_REDRAW           (WM_USER+101)
#define WM_READEMBEDDED     (WM_USER+102)


#define CHAR_SPACE          TEXT(' ')
#define CHAR_QUOTE          TEXT('"')

#define SZ_QUOTE            TEXT("\"")

typedef enum
{
    NOTHING,
    CMDLINK,
    ICON,
    PEMBED,
    PICTURE
} PANETYPE;


typedef enum
{
    SOP_FILE,
    SOP_MEMORY
}
STREAMOP;


typedef struct _APPSTREAM
{
    LPOLESTREAMVTBL lpstbl;
    INT fh;
} APPSTREAM, *LPAPPSTREAM;


typedef struct _EMBED           // embed
{
    ATOM aFileName;
    ATOM aTempName;
    DWORD dwSize;
    HANDLE hContents;
    HANDLE hdata;
    HANDLE hTask;
    HANDLE hSvrInst;
    BOOL bOleSvrFile;
    LPOLECLIENT lpclient;       // At activation time we check whether the file
    LPOLEOBJECT lpLinkObj;      // is a OLE server file. If so, we will create
                                // a link to it, and activate it in OLE fashion
} EMBED, *LPEMBED;


typedef struct _CML             // cml
{
    HANDLE hdata;
    RECT rc;                    // HACK:  Same location as in PICT
    BOOL fCmdIsLink;
    CHAR szCommand[CBCMDLINKMAX];
} CML, *LPCML;


typedef struct _IC              // ic
{
    HANDLE hdata;
    HICON hDlgIcon;
    CHAR szIconPath[CBPATHMAX];
    CHAR szIconText[CBPATHMAX];
    INT iDlgIcon;
} IC, *LPIC;


typedef struct _PICT            // pict
{
    HANDLE hdata;
    RECT rc;                    // HACK:  Same location as in CML
    LPOLEOBJECT lpObject;
    BOOL fNotReady;             // TRUE if object creation is not complete
} PICT, *LPPICT;


typedef struct _SAMPSRVR        // srvr
{
    OLESERVER olesrvr;          // Server
    HANDLE hsrvr;               // Handle to server memory block
    LHSERVER lhsrvr;            // Registration handle
} PBSRVR, *LPSAMPSRVR;


typedef struct _SAMPDOC         // doc
{
    OLESERVERDOC oledoc;        // Document
    HANDLE hdoc;                // Handle to document memory block
    LHSERVERDOC lhdoc;          // Registration handle
    ATOM aName;                 // Document name atom
} PBDOC, *LPSAMPDOC;


typedef struct _SAMPITEM        // item
{
    OLEOBJECT oleobject;        // Object
    HANDLE hitem;               // Handle to item memory block
    LPOLECLIENT lpoleclient;
    INT ref;                    // # of references to document
    ATOM aName;                 // Item name atom
} ITEM, *LPSAMPITEM;


#include "globals.h"

#include "function.h"


#if DBG_PRNT
#define DPRINT(s)   OutputDebugString(TEXT(s) TEXT("\n"))
#else
#define DPRINT(s)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\packgr32.c ===
#if 0
    This is a completely empty C file that is here only to placate the
    BUILD program.
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\packager.c ===
/* packager.c - OLE object wrapping application
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include <shellapi.h>
#include "dialogs.h"
#include <htmlhelp.h>

#define MenuFlag(b)    ((b) ? MF_ENABLED : MF_GRAYED)

/* 4-Oct-93 #2695 v-katsuy */
                         // win31#2174: 12/26/92 : fixing frame window initial position
/* The width of the Packager Frame window is nearly equal to 640.
   This value must be changed, when the design will be changed.
*/
#define JPFRAMEWIDTH 640

// Pointer to function RegisterPenApp()
VOID (CALLBACK *RegPen)(WORD, BOOL) = NULL;


static BOOL gfDirty = FALSE;                // TRUE if file needs to be written
static CHAR szEmbedding[] = "-Embedding";   // Not NLS specific
static CHAR szEmbedding2[] = "/Embedding";  // Not NLS specific
static CHAR szFrameClass[] = "AppClass";    // Not NLS specific
static CHAR szObjectMenu[CBSHORTSTRING];    // "&Object" menu string
static CHAR szEdit[CBSHORTSTRING];          // "Edit" string
static CHAR szHelpFile[] = "PACKAGER.CHM";  // packager.chm

static BOOL InitApplication(VOID);
static BOOL InitInstance(VOID);
static VOID EndInstance(VOID);
static VOID SaveAsNeeded(VOID);
static BOOL WriteToFile(VOID);
static BOOL ReadFromFile(LPSTR lpstrFile);
static OLESTATUS ProcessCmdLine(LPSTR lpCmdLine, INT nCmdShow);
static VOID WaitForAllObjects(VOID);
static VOID UpdateMenu(HMENU hmenu);
static VOID UpdateObjectMenuItem(HMENU hMenu);
static VOID ExecuteVerb(INT iVerb);
INT_PTR CALLBACK fnFailedUpdate(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
static VOID SendOleClosed(VOID);
static VOID CreateUntitled(VOID);
static VOID MakePenAware(VOID);
static VOID MakePenUnaware(VOID);
static VOID MakeMenuString(CHAR *szCtrl, CHAR *szMenuStr, CHAR *szVerb,
    CHAR *szClass, CHAR *szObject);


BOOL gbDBCS = FALSE;                 // TRUE if we're running in DBCS mode


/* WinMain() - Main Windows routine
 */
INT WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    INT nCmdShow
    )
{
    MSG msg;
    LCID lcid;

//DebugBreak(); 
    // Store the application instance number
    ghInst = hInstance;

    // Check DBCSness
    lcid = GetThreadLocale();

    gbDBCS = ( (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
               (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
               (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE)
              );


    // Initialize application global information (window classes)
    if (!hPrevInstance)
    {
        if (!InitApplication())
            return FALSE;
    }

    // Initialize instance-specific information
    if (!InitInstance() || !InitClient())
        goto errRtn;

    if (!(gfServer = InitServer()))
        goto errRtn;

    MakePenAware();

    if (ProcessCmdLine(lpCmdLine, nCmdShow) != OLE_OK)
    {
        DeleteServer(glpsrvr);
        goto errRtn;
    }

    // if blocking happened in SrvrOpen(), then wait for object to be created
    if (gfBlocked)
        WaitForObject(((LPPICT)(glpobj[CONTENT]))->lpObject);

    // Main message loop
    while (TRUE)
    {
        if (gfBlocked && glpsrvr)
        {
            BOOL bMore = TRUE;
            LHSERVER lhsrvr = glpsrvr->lhsrvr;

            gfBlocked = FALSE;
            while (bMore)
            {
                if (OleUnblockServer (lhsrvr, &bMore) != OLE_OK)
                    break;

                if (gfBlocked)
                    break;
            }
        }

        if (!GetMessage(&msg, NULL, 0, 0))
            break;

        if (!TranslateAccelerator(ghwndFrame, ghAccTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        //
        // to support activation of file based object though Ole mechanism
        // we create a linked object out of file and then activate it. But
        // we don't get any notification when server closes the document.
        // Using the following mechanism we find it out and then grab the
        // contents from file
        //
        if (gfEmbObjectOpen)
        {
            LPEMBED lpembed = (LPEMBED)(glpobj[CONTENT]);

            if (lpembed != NULL && OleQueryOpen(lpembed->lpLinkObj) != OLE_OK)
            {
                gfEmbObjectOpen = FALSE;
                EmbRead(lpembed);
                EmbDeleteLinkObject(lpembed);

                if (gfInvisible)
                    PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
            }
        }
    }

    goto cleanup;

errRtn:
    if (ghwndFrame)
        DestroyWindow(ghwndFrame);

cleanup:

    EndClient();
    MakePenUnaware();
    EndInstance();

    return FALSE;
}



/* InitApplication() - Do application "global" initialization.
 *
 * This function registers the window classes used by the application.
 * Returns:  TRUE iff successful.
 */
static BOOL
InitApplication(
    VOID
    )
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = FrameWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ghInst;
    wc.hIcon = LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION));
    wc.hCursor = LoadCursor(ghInst, MAKEINTRESOURCE(SPLIT));
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName = MAKEINTRESOURCE(ID_APPLICATION);
    wc.lpszClassName = szFrameClass;

    if (!RegisterClass(&wc))
        return FALSE;

    return InitPaneClasses();
}



/* InitInstance() - Handles the instance-specific initialization.
 *
 * This function creates the main application window.
 * Returns:  TRUE iff successful.
 */
static BOOL
InitInstance(
    VOID
    )
{
    HDC hDC;

    ghAccTable = LoadAccelerators(ghInst, MAKEINTRESOURCE(ID_APPLICATION));
    ghbrBackground = GetSysColorBrush(COLOR_APPWORKSPACE);
    ghcurWait = LoadCursor(NULL, IDC_WAIT);

    // Load the string resources
    LoadString(ghInst, IDS_APPNAME, szAppName, CBMESSAGEMAX);
    LoadString(ghInst, IDS_UNTITLED, szUntitled, CBMESSAGEMAX);

    // Create the Main Window

    if (gbDBCS)
    {
        /* 4-Oct-93 #2695 v-katsuy */
        // win31#2174: 12/26/92 : fixing frame window initial position
        if (!(ghwndError = ghwndFrame =
            CreateWindow(szFrameClass, szAppName,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
            | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
            CW_USEDEFAULT, CW_USEDEFAULT,
                // Following values are calculated when the window size is changed.
                // Default posiotion of a window is desided here, so dumy values
                // must be set here.
                JPFRAMEWIDTH, JPFRAMEWIDTH  * 7 / 18,
            NULL, NULL, ghInst, NULL)))
            return FALSE;
    }
    else
    {
        if (!(ghwndError = ghwndFrame =
            CreateWindow(szFrameClass, szAppName,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
            | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
            CW_USEDEFAULT, CW_USEDEFAULT,
            CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, ghInst, NULL)))
            return FALSE;
    }


    // Initialize the registration database
    RegInit();

    // Set the correct caption string
    OfnInit();
    glpobj[CONTENT] = glpobj[APPEARANCE] = NULL;
    glpobjUndo[CONTENT] = glpobjUndo[APPEARANCE] = NULL;

    LoadString(ghInst, IDS_EDIT, szEdit, CBSHORTSTRING);
    LoadString(ghInst, IDS_OBJECT_MENU, szObjectMenu, CBSHORTSTRING);
    LoadString(ghInst, IDS_UNDO_MENU, szUndo, CBSHORTSTRING);
    LoadString(ghInst, IDS_GENERIC, szDummy, CBSHORTSTRING);
    LoadString(ghInst, IDS_CONTENT_OBJECT, szContent, CBMESSAGEMAX);
    LoadString(ghInst, IDS_APPEARANCE_OBJECT, szAppearance, CBMESSAGEMAX);

    // Initialize global variables with LOGPIXELSX and LOGPIXELSY
    if (hDC = GetDC (NULL))
    {
        giXppli = GetDeviceCaps(hDC, LOGPIXELSX);
        giYppli = GetDeviceCaps(hDC, LOGPIXELSY);
        ReleaseDC(NULL, hDC);
    }

    return InitPanes();
}



/* EndInstance() - Instance-specific termination code.
 */
static VOID
EndInstance(
    VOID
    )
{
    EndPanes();
}



/* FrameWndProc() - Frame window procedure.
 *
 * This function is the message handler for the application frame window.
 */
LRESULT CALLBACK
FrameWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fSuccess = FALSE;

    if (SplitterFrame(hwnd, msg, wParam, lParam))
        return DefWindowProc(hwnd, msg, wParam, lParam);

    switch (msg)
    {
    case WM_READEMBEDDED:
        if (gpty[CONTENT] == PEMBED)
        {
            EmbRead(glpobj[CONTENT]);

            if (gfInvisible)
                PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }

        break;

    case WM_INITMENU:
        UpdateMenu((HMENU)wParam);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDM_NEXTWINDOW:
            // Special trickery works because APP = 0 & CONTENT = 1
            Raise(GetTopWindow(hwnd) != ghwndPane[CONTENT]);
            break;

        case IDM_NEW:
            // Save the current file (if needed)
            SaveAsNeeded();

            // delete the current doc, and create untitled document
            CreateUntitled();
            break;

        case IDM_IMPORT:
            if (!OfnGetName(hwnd, IDM_IMPORT))
                break;

            Hourglass(TRUE);
            DeletePane(CONTENT, TRUE);
            if (ReadFromFile(gszFileName))
            {
                InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                Dirty();

                if (!gpty[APPEARANCE])
                {
                    if (glpobj[APPEARANCE] = IconCreateFromFile(gszFileName))
                    {
                        gpty[APPEARANCE] = ICON;
                        InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                    }
                }
            }

            Hourglass(FALSE);
            break;

        case IDM_EXPORT:
            if (!OfnGetName(hwnd, IDM_EXPORT))
                return 0L;          /* Operation cancelled */

            Hourglass(TRUE);

            if (!WriteToFile())
                ErrorMessage(E_FAILED_TO_SAVE_FILE);

            Hourglass(FALSE);
            break;

        case IDM_UPDATE:
            {
                OLESTATUS retval;

                if (Error(OleSavedClientDoc(glhcdoc)))
                    ErrorMessage(W_FAILED_TO_NOTIFY);

                if ((retval = OleSavedServerDoc (glpdoc->lhdoc)) == OLE_OK)
                {
                    gfDirty = FALSE;
                }
                else if (retval == OLE_ERROR_CANT_UPDATE_CLIENT)
                {
                    //
                    // The client doesn't take updates on Save. Let the
                    // user explicitly update and exit, or continue with
                    // the editing.
                    //
                    if (!MyDialogBox(DTFAILEDUPDATE, ghwndFrame, fnFailedUpdate))
                    {
                        // update the object and exit
                        gfOleClosed = TRUE;
                        DeregisterDoc();
                        DeleteServer(glpsrvr);
                    }
                }
                else
                {
                    Error(retval);
                }

                break;
            }

        case IDM_EXIT:
            SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
            return 0L;
            break;

        case IDM_COMMAND:
            Raise(CONTENT);
            DeletePane(CONTENT, FALSE);

            if (gptyUndo[CONTENT] != CMDLINK)
                glpobj[CONTENT] = CmlCreate("", FALSE);
            else
                glpobj[CONTENT] = CmlClone(glpobjUndo[CONTENT]);

            if (glpobj[CONTENT])
                gpty[CONTENT] = CMDLINK;

            if (glpobj[CONTENT] && ChangeCmdLine(glpobj[CONTENT]))
            {
                InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                Dirty();
            }
            else
            {
                CmlDelete(glpobj[CONTENT]);
                gpty[CONTENT] = NOTHING;
                glpobj[CONTENT] = NULL;
                SendMessage(ghwndPane[CONTENT], WM_COMMAND, IDM_UNDO, 0L);
            }

            break;

        case IDM_INSERTICON:
            PostMessage (ghwndBar[APPEARANCE], WM_COMMAND, IDM_INSERTICON, 0L);
            break;

        case IDM_DESC:
        case IDM_PICT:
            PostMessage(ghwndBar[CONTENT], WM_COMMAND, wParam, 0L);
            break;

        case IDM_LABEL:
            Raise(APPEARANCE);

            if (gpty[APPEARANCE] != ICON)
                break;

            ChangeLabel(glpobj[APPEARANCE]);
            InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
            Dirty();
            break;

        case IDM_COPYPACKAGE:
            if (!CopyObjects())
                ErrorMessage(E_CLIPBOARD_COPY_FAILED);

            break;

        case IDM_PASTE:
            // Check to see if we are pasting a packaged object
            if (IsClipboardFormatAvailable(gcfNative)
                && IsClipboardFormatAvailable(gcfOwnerLink))
            {
                HANDLE hData;
                HANDLE hData2;
                LPSTR lpData;

                OpenClipboard(ghwndFrame);
                hData = GetClipboardData(gcfOwnerLink);

                if (lpData = GlobalLock(hData))
                {
                    // If it's the packager, get the native data
                    if (!lstrcmpi(lpData, gszAppClassName)
                        && (hData2 = GetClipboardData(gcfNative)))
                        fSuccess = PutNative(hData2);

                    // Unlock the clipboard Owner Link data
                    GlobalUnlock(hData);
                }

                CloseClipboard();
            }

            // Did we successfully read the native data?
            if (fSuccess)
                break;

            // ... guess not (maybe not Package!)
            PostMessage(GetTopWindow(hwnd), msg, wParam, lParam);
            break;

        case IDM_OBJECT:
            ExecuteVerb(0);     // Execute the ONLY verb
            break;

        case IDM_INDEX:
            HtmlHelp(ghwndFrame, szHelpFile, HH_DISPLAY_TOPIC, 0L);
            break;

        case IDM_ABOUT:
            ShellAbout(hwnd, szAppName, "",
                LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION)));
            break;

        default:
            if ((LOWORD(wParam) >= IDM_VERBMIN)
                && (LOWORD(wParam) <= IDM_VERBMAX))
            {
                // An object verb has been selected
                // (Hmm.  Did you know that an 'object verb' was a noun?)
                ExecuteVerb(LOWORD(wParam) - IDM_VERBMIN);
            }
            else
            {
                PostMessage(GetTopWindow(hwnd), msg, wParam, lParam);
            }

            break;
        }

        break;

    case WM_CLOSE:
        //
        // Update if necessary by notifying the server that we are closing
        // down, and revoke the server.
        //
        SaveAsNeeded();
        SendOleClosed();
        DeleteServer(glpsrvr);

        return 0L;

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0L;

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 0L;
}



/* SetTitle() - Sets the window caption to the current filename.
 *
 * If gszFileName is NULL, the caption will be set to "(Untitled)".
 * If DocSetHostNames() is called with a client app name, that name
 * will be prepended.
 *
 * For the Embedded case, the "Embedded #n" string is stored in
 * "Untitled", and is always displayed regardless of the file name.
 */
VOID
SetTitle(
    BOOL fRegistering
    )
{
    CHAR szTitle[CBMESSAGEMAX + CBPATHMAX];

    if (!gfEmbedded)
    {
        StringCchPrintf(szTitle, ARRAYSIZE(szTitle), "%s%s%s - %s", gszClientName,
            (*gszClientName) ? " " : "",
            szAppName, szUntitled);
    }
    else
    {
        CHAR szEmbnameContent[CBSHORTSTRING];

        LoadString(ghInst, IDS_EMBNAME_CONTENT, szEmbnameContent, CBSHORTSTRING);

        if (gbDBCS)
        {
            //#3997: 2/19/93: changed Window title
            StringCchPrintf(szTitle, ARRAYSIZE(szTitle), "%s - %s %s", szAppName, szUntitled,
                             szEmbnameContent);
        }
        else
        {
            StringCchPrintf(szTitle, ARRAYSIZE(szTitle), "%s - %s %s", szAppName, szEmbnameContent,
                 szUntitled);
        }

    }

    // Perform the client document registration
    if (glhcdoc)
    {
        if (Error(OleRenameClientDoc(glhcdoc, szUntitled)))
            ErrorMessage(W_FAILED_TO_NOTIFY);

        if (!fRegistering)
            ChangeDocName(&glpdoc, szUntitled);
    }
    else
    {
        if (Error(OleRegisterClientDoc(gszAppClassName, szUntitled, 0L, &glhcdoc)))
        {
            ErrorMessage(W_FAILED_TO_NOTIFY);
            glhcdoc = 0;
        }

        // New file, so re-register it
        if (!fRegistering)
            glpdoc = InitDoc(glpsrvr, 0, szUntitled);
    }

    if (IsWindow(ghwndFrame))
        SetWindowText(ghwndFrame, szTitle);
}



/* InitFile() - Reinitializes the title bar, etc... when editing a New file.
 */
VOID
InitFile(
    VOID
    )
{
    gfDirty = FALSE;

    // Deregister the edited document, and wipe out the objects.
    DeregisterDoc();

    // Reset the title bar, and register the OLE client document
    SetTitle(FALSE);
}



/* SaveAsNeeded() - Saves the file if it has been modified. It's assumed that
 *                  after this routine is called this document is going to be
 *                  closed. If that's not true, then this routine may have to
 *                  be rewritten.
 */
static VOID
SaveAsNeeded(
    VOID
    )
{
    gfOleClosed = FALSE;

    if (gfDirty && gfEmbedded && (glpobj[APPEARANCE] || glpobj[CONTENT]))
    {
        CHAR sz[CBMESSAGEMAX];
        CHAR sz2[CBMESSAGEMAX + CBPATHMAX];

        if (gfInvisible)
        {
            SendDocChangeMsg(glpdoc, OLE_CLOSED);
            return;
        }

        LoadString(ghInst, gfEmbedded ? IDS_MAYBEUPDATE : IDS_MAYBESAVE, sz,
             CBMESSAGEMAX);
        StringCchPrintf(sz2, ARRAYSIZE(sz2), sz, (LPSTR)szUntitled);

        // Ask "Do you wish to save your changes?"
        if (MessageBoxAfterBlock(ghwndFrame, sz2, szAppName,
            MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
            gfOleClosed = TRUE;
            return;
        }
        // If not saving changes, revert the document
        else if (OleRevertClientDoc(glhcdoc))
        {
            ErrorMessage(W_FAILED_TO_NOTIFY);
        }
    }
}



/* WriteToFile() - Writes the current document to a file.
 *
 * Returns:  TRUE iff successful.
 */
static BOOL
WriteToFile(
    VOID
    )
{
    BOOL fSuccess = FALSE;
    OFSTRUCT reopenbuf;
    INT fh;

    CHAR szDesc[CBSTRINGMAX];
    CHAR szMessage[CBSTRINGMAX + CBPATHMAX];

    if (OpenFile(gszFileName, &reopenbuf, OF_EXIST) != -1)
    {
        // File exists, query for overwrite!
        LoadString(ghInst, IDS_OVERWRITE, szDesc, CharCountOf(szDesc));
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, gszFileName);
        if (MessageBoxAfterBlock(ghwndFrame, szMessage, szAppName,
            MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            return TRUE;
    }

    // Take care of this earlier?
    if ((fh = _lcreat((LPSTR)gszFileName, 0)) <= 0)
    {
        LoadString(ghInst, IDS_INVALID_FILENAME, szDesc, CharCountOf(szDesc));
        StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, gszFileName);
        MessageBoxAfterBlock(ghwndFrame, szMessage, szAppName, MB_OK);
        return FALSE;
    }

    Hourglass(TRUE);

    // Go to the top of the file
    _llseek(fh, 0L, 0);

    EmbWriteToFile(glpobj[CONTENT], fh);
    fSuccess = TRUE;

    // Close the file, and return
    _lclose(fh);
    gfDirty = FALSE;
    Hourglass(FALSE);

    return fSuccess;
}



/* ReadFromFile() - Reads OLE objects from a file.
 *
 * Reads as many objects as it can, in upwards order (better error recovery).
 * Returns: TRUE iff successful.
 */
static BOOL
ReadFromFile(
    LPSTR lpstrFile
    )
{
    BOOL fSuccess = FALSE;

    Hourglass(TRUE);

    // Read in each object and get them in the right order
    if (!(glpobj[CONTENT] = EmbCreate(lpstrFile)))
    {
        goto Error;
    }

    gpty[CONTENT] = PEMBED;

    fSuccess = TRUE;

Error:
    gfDirty = FALSE;
    Hourglass(FALSE);

    return fSuccess;
}



/* ErrorMessage() - Pops up a message box containing a string table message.
 *
 * Pre:  Assigns "ghwndError" to be its parent, so focus will return properly.
 */
VOID
ErrorMessage(
    UINT id
    )
{
    CHAR sz[300];

    if (IsWindow(ghwndError))
    {
        LoadString(ghInst, id, sz, 300);
        MessageBoxAfterBlock(ghwndError, sz, szAppName,
            MB_OK | MB_ICONEXCLAMATION);
    }
}



/* ProcessMessage() - Spin in a message dispatch loop.
 */
BOOL
ProcessMessage(
    VOID
    )
{
    BOOL fReturn;
    MSG msg;

    if (fReturn = GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(ghwndFrame, ghAccTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return fReturn;
}



/* Contains() - Determines whether a string matches a pattern.
 * This could be more intelligent, but it is scarcely executed.
 *
 * Returns: Non-NULL iff lpPattern is a substring of lpString.
 */
LPSTR
Contains(
    LPSTR lpString,
    LPSTR lpPattern
    )
{
    LPSTR lpSubstr;
    LPSTR lpPat;

    for (;;)
    {
        // Match the first character
        while (*lpString && *lpString != *lpPattern)
            lpString++;

        // We are at the end of the string, fail...
        if (!(*lpString))
            return NULL;

        // If we have a match, try to match the entire pattern string
        lpPat = lpPattern;
        lpSubstr = lpString;
        while (*lpPat && *lpSubstr && *lpPat == *lpSubstr)
        {
            lpPat++;
            lpSubstr++;
        }

        // We are at the end of the pattern, success!  Wipe out the pattern
        if (!(*lpPat))
            return lpString;

        // We are at the end of the string, failure...
        if (!(*lpSubstr))
            return NULL;

        lpString++;
    }
}



/* ProcessCmdLine() - Processes the command line options.
 */
static OLESTATUS
ProcessCmdLine(
    LPSTR lpCmdLine,
    INT nCmdShow
    )
{
    OLESTATUS retval = OLE_OK;

    // Does the command line contain "/Embedding"?
    if (gfEmbeddedFlag = gfInvisible =
        (Contains(lpCmdLine, szEmbedding) || Contains(lpCmdLine, szEmbedding2)))
    {
        // If we have a file name, register it NOW!
        lpCmdLine += lstrlen(szEmbedding);

        while (*lpCmdLine && *lpCmdLine == ' ')
            lpCmdLine++;

        if (*lpCmdLine)
        {
            retval = (glpsrvr->olesrvr.lpvtbl->Open)
                ((LPOLESERVER)glpsrvr, 0, lpCmdLine,
                (LPOLESERVERDOC *)&glpdoc);

            if (retval != OLE_OK)
                return retval;
        }

        gfDirty = FALSE;
        gnCmdShowSave = nCmdShow;

    }
    else
    {
        ShowWindow(ghwndFrame, nCmdShow);
        SendMessage(ghwndFrame, WM_COMMAND, IDM_NEW, 0L);
    }

    return retval;
}



/* Dirty() - This function is called each time the document is soiled.
 */
VOID
Dirty(
    VOID
    )
{
    gfDirty = TRUE;
    SendDocChangeMsg(glpdoc, OLE_CHANGED);
}



/* WaitForAllObjects() - Wait for asynchronous operations to complete.
 *
 * We don't use ProcessMessage() because we want to terminate as quickly
 * as possible, and we don't want to allow any structured user input.
 */
static VOID
WaitForAllObjects(
    VOID
    )
{
    MSG msgWait;

    if (gcOleWait)
    {
        while (gcOleWait)
        {
            if (GetMessage(&msgWait, NULL, 0, 0))
                DispatchMessage(&msgWait);
        }
    }
}



/* DeregisterDoc() - Deregisters the currently edited document.
 */
VOID
DeregisterDoc(
    VOID
    )
{
    gfDocCleared = TRUE;

    SendOleClosed();

    // Destroy all the objects
    DeletePane(APPEARANCE, TRUE);
    DeletePane(CONTENT, TRUE);

    // Wait for the objects to be deleted
    WaitForAllObjects();

    if (glpdoc)
    {
        LHSERVERDOC lhdoc = glpdoc->lhdoc;

        glpdoc = NULL;
        OleRevokeServerDoc(lhdoc);
    }

    // Release the document
    if (glhcdoc)
    {
        if (Error(OleRevokeClientDoc(glhcdoc)))
            ErrorMessage(W_FAILED_TO_NOTIFY);

        glhcdoc = 0;
    }
}



static VOID
UpdateMenu(
    HMENU hmenu
    )
{
    INT iPane;
    INT mf;

    iPane = (GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]);
    EnableMenuItem(hmenu, IDM_EXPORT, MenuFlag(gpty[CONTENT] == PEMBED));
    EnableMenuItem(hmenu, IDM_CLEAR, MenuFlag(gpty[iPane]));
    EnableMenuItem(hmenu, IDM_UNDO, MenuFlag(gptyUndo[iPane]));

    EnableMenuItem(hmenu, IDM_UPDATE, (gfEmbedded ? MF_ENABLED : MF_GRAYED));

    if (((iPane == APPEARANCE) && gpty[iPane]) || (gpty[iPane] == PICTURE))
    {
        EnableMenuItem(hmenu, IDM_CUT, MF_ENABLED);
        EnableMenuItem(hmenu, IDM_COPY, MF_ENABLED);
    }
    else
    {
        EnableMenuItem(hmenu, IDM_CUT, MF_GRAYED);
        EnableMenuItem(hmenu, IDM_COPY, MF_GRAYED);
    }

    if (gpty[iPane] == PICTURE)
    {
        LPPICT lppict = glpobj[iPane];
        DWORD ot;

        mf = MF_GRAYED;
        if (lppict->lpObject)
        {
            OleQueryType(lppict->lpObject, &ot);

            // Enable Links... only if we have a linked object
            mf = MenuFlag(ot == OT_LINK);
        }

        EnableMenuItem(hmenu, IDM_LINKS, mf);
        EnableMenuItem(hmenu, IDM_LABEL, MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hmenu, IDM_LINKS, MF_GRAYED);
        EnableMenuItem(hmenu, IDM_LABEL, MenuFlag(gpty[APPEARANCE] == ICON));
    }

    UpdateObjectMenuItem(GetSubMenu(hmenu, POS_EDITMENU));
    mf = MenuFlag(OleQueryCreateFromClip(gszProtocol, olerender_draw, 0) ==
        OLE_OK
        || OleQueryCreateFromClip(gszSProtocol, olerender_draw, 0) == OLE_OK);
    EnableMenuItem(hmenu, IDM_PASTE, mf);

    if (iPane == CONTENT)
    {
        if (IsClipboardFormatAvailable(gcfFileName)) {
            EnableMenuItem(hmenu, IDM_PASTELINK, MF_ENABLED);
        }
        else
        {
            mf = MenuFlag(OleQueryLinkFromClip(gszProtocol, olerender_draw, 0)
                == OLE_OK);
            EnableMenuItem(hmenu, IDM_PASTELINK, mf);
        }
    }
    else
    {
        EnableMenuItem(hmenu, IDM_PASTELINK, MF_GRAYED);
    }

    mf = MenuFlag(gpty[CONTENT] && gpty[APPEARANCE]);
    EnableMenuItem(hmenu, IDM_COPYPACKAGE, mf);
}



/* UpdateObjectMenuItem - If there are items in the selection, add the
 *                        menu, with a possible popup depending on the
 *                        number of verbs.
 */
static VOID
UpdateObjectMenuItem(
    HMENU hMenu
    )
{
    INT cVerbs = 0;             /* how many verbs in list */
    HWND hwndItem = NULL;
    INT iPane;
    LONG objtype;
    LPPICT lpPict;
    CHAR szWordOrder2[10];
    CHAR szWordOrder3[10];

    if (!hMenu)
        return;

    DeleteMenu(hMenu, POS_OBJECT, MF_BYPOSITION);

    LoadString(ghInst, IDS_POPUPVERBS, szWordOrder2, sizeof(szWordOrder2));
    LoadString(ghInst, IDS_SINGLEVERB, szWordOrder3, sizeof(szWordOrder3));

    //
    // CASES:
    //  object supports 0 verbs          "<Object Class> Object"
    //  object supports 1 verb == edit   "<Object Class> Object"
    //  object supports 1 verb != edit   "<verb> <Object Class> Object"
    //  object supports more than 1 verb "<Object Class> Object" => verbs
    //

    iPane = ((hwndItem = GetTopWindow(ghwndFrame)) == ghwndPane[CONTENT]);
    lpPict = glpobj[iPane];

    if (lpPict
        && OleQueryType(lpPict->lpObject, &objtype) == OLE_OK
        && hwndItem
        && gpty[iPane] == PICTURE
        && objtype != OT_STATIC)
    {
        HANDLE hData = NULL;
        LPSTR lpstrData;

        if (OleGetData(lpPict->lpObject, (OLECLIPFORMAT) (objtype == OT_LINK ?
            gcfLink : gcfOwnerLink), &hData) == OLE_OK)
        {
            // Both link formats are:  "szClass0szDocument0szItem00"
            if (lpstrData = GlobalLock(hData))
            {
                DWORD dwSize = KEYNAMESIZE;
                CHAR szClass[KEYNAMESIZE], szBuffer[200];
                CHAR szVerb[KEYNAMESIZE];
                HANDLE hPopupNew = NULL;

                // get real language class of object in szClass for menu
                if (RegQueryValue(HKEY_CLASSES_ROOT, lpstrData,
                    szClass, &dwSize))
                    StringCchCopy(szClass, ARRAYSIZE(szClass), lpstrData);    /* if above call failed */
                GlobalUnlock(hData);

                // append class key
                for (cVerbs = 0; ; ++cVerbs)
                {
                    dwSize = KEYNAMESIZE;
                    StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), 
                        "%s\\protocol\\StdFileEditing\\verb\\%d",
                        lpstrData, cVerbs);

                    if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer,
                        szVerb, &dwSize))
                        break;

                    if (hPopupNew == NULL)
                        hPopupNew = CreatePopupMenu();

                    InsertMenu(hPopupNew, (UINT)-1, MF_BYPOSITION,
                        IDM_VERBMIN + cVerbs, szVerb);
                }

                if (cVerbs == 0)
                {
                    MakeMenuString(szWordOrder3, szBuffer, szEdit,
                        szClass, szObjectMenu);
                    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION,
                        IDM_VERBMIN, szBuffer);
                }
                else if (cVerbs == 1)
                {
                    MakeMenuString(szWordOrder3, szBuffer, szVerb,
                        szClass, szObjectMenu);
                    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION,
                        IDM_VERBMIN, szBuffer);
                    DestroyMenu(hPopupNew);
                }
                else
                {
                    // > 1 verbs
                    MakeMenuString(szWordOrder2, szBuffer, NULL,
                        szClass, szObjectMenu);
                    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION |
                        MF_POPUP, (UINT_PTR)hPopupNew, szBuffer);
                }

                EnableMenuItem(hMenu, POS_OBJECT,
                    MF_ENABLED | MF_BYPOSITION);

                return;
            }
        }
    }

    // error if got to here
    InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, 0, szObjectMenu);
    EnableMenuItem(hMenu, POS_OBJECT, MF_GRAYED | MF_BYPOSITION);
}



/* ExecuteVerb() - Find the proper verb to execute for each selected item
 */
static VOID
    ExecuteVerb(
    INT iVerb
    )
{
    HWND hwndItem;
    INT iPane;
    RECT rc;

    iPane = ((hwndItem = GetTopWindow(ghwndFrame)) == ghwndPane[CONTENT]);

    GetClientRect(hwndItem, (LPRECT) & rc);

    // Execute the correct verb for this object
    if (Error(OleActivate(((LPPICT)(glpobj[iPane]))->lpObject, iVerb, TRUE,
        TRUE, hwndItem, &rc)))
    {
        if (OleQueryReleaseError(((LPPICT)(glpobj[iPane]))->lpObject) == OLE_ERROR_LAUNCH )
            ErrorMessage(E_FAILED_TO_LAUNCH_SERVER);
    }
    else
    {
        LONG ot;

        WaitForObject(((LPPICT)(glpobj[iPane]))->lpObject);
        if (!glpobj[iPane])
            return;

        OleQueryType(((LPPICT)(glpobj[iPane]))->lpObject, &ot);
        if (ot == OT_EMBEDDED)
            Error(OleSetHostNames(((LPPICT)(glpobj[iPane]))->lpObject,
                gszAppClassName,
                (iPane == CONTENT) ? szContent : szAppearance));
    }
}



VOID
Raise(
    INT iPane
    )
{
    if (GetTopWindow(ghwndFrame) != ghwndPane[iPane])
        SendMessage(ghwndPane[iPane], WM_LBUTTONDOWN, 0, 0L);
}



INT_PTR CALLBACK
fnFailedUpdate(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{

    switch (msg)
    {
        case WM_INITDIALOG:
            {
                CHAR szMsg[200];
                CHAR szStr[100];

                LoadString(ghInst, IDS_FAILEDUPDATE, szStr, sizeof(szStr));
                StringCchPrintf((LPSTR)szMsg, ARRAYSIZE(szMsg), szStr, gszClientName, szAppName);
                SetDlgItemText(hDlg, IDD_TEXT, szMsg);

                return TRUE; // default Push button gets the focus
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                case IDD_CONTINUEEDIT:
                    EndDialog(hDlg, TRUE);
                    break;

                case IDD_UPDATEEXIT:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}



static VOID
SendOleClosed(
    VOID
    )
{
    // Do this first, so the data can be updated as needed
    if (glpdoc)
    {
        if (gfOleClosed)
        {
            SendDocChangeMsg(glpdoc, OLE_CLOSED);
            gfOleClosed = FALSE;
        }
    }
}



static VOID
CreateUntitled(
    VOID
    )
{
    if (gfEmbedded)      /* Unembed if embedded */
        EndEmbedding();

    if (gvlptempdoc = InitDoc(glpsrvr, 0, szUntitled))
    {
        InitFile();      /* Reset the file */
        glpdoc = gvlptempdoc;
        SetTitle(TRUE);
        gvlptempdoc = NULL;
        gfDocExists  = TRUE;
        gfDocCleared = FALSE;
    }
    else
    {
        ErrorMessage(E_FAILED_TO_REGISTER_DOCUMENT);
    }
}



static VOID
MakePenAware(
    VOID
    )
{

    HANDLE hPenWin = NULL;

    if ((hPenWin = LongToHandle(GetSystemMetrics(SM_PENWINDOWS))) != NULL)
    {
        // We do this fancy GetProcAddress simply because we don't
        // know if we're running Pen Windows.

        if ((RegPen = (VOID (CALLBACK *)(WORD, BOOL))GetProcAddress(hPenWin, "RegisterPenApp")) != NULL)
            (*RegPen)(1, TRUE);
    }

}



static VOID
MakePenUnaware(
    VOID
    )
{
    if (RegPen != NULL)
        (*RegPen)(1, FALSE);
}



INT_PTR MessageBoxAfterBlock(
    HWND hwndParent,
    LPSTR lpText,
    LPSTR lpCaption,
    UINT fuStyle
    )
{
    if (glpsrvr && !gfBlocked && (OleBlockServer(glpsrvr->lhsrvr) == OLE_OK))
        gfBlocked = TRUE;

    return MessageBox((gfInvisible ? NULL : hwndParent), lpText, lpCaption,
         fuStyle | MB_TOPMOST);
}



INT_PTR DialogBoxAfterBlock(
    LPCSTR lpTemplate,
    HWND hwndParent,
    DLGPROC lpDialogFunc
    )
{
    if (glpsrvr && !gfBlocked && (OleBlockServer(glpsrvr->lhsrvr) == OLE_OK))
        gfBlocked = TRUE;

    return DialogBox(ghInst, lpTemplate, (gfInvisible ? NULL : hwndParent),
        lpDialogFunc);
}



static VOID
MakeMenuString(
    CHAR *szCtrl,
    CHAR *szMenuStr,
    CHAR *szVerb,
    CHAR *szClass,
    CHAR *szObject
    )
{
    register CHAR c;
    CHAR *pStr;

    while (c = *szCtrl++)
    {
        switch (c)
        {
            case 'c': // class
            case 'C': // class
                pStr = szClass;
                break;

            case 'v': // class
            case 'V': // class
                pStr = szVerb;
                break;

            case 'o': // object
            case 'O': // object
                pStr = szObject;
                break;

            default:
                *szMenuStr++ = c;
                *szMenuStr = '\0'; // just in case
                continue;
        }

        if (pStr) // should always be true
        {
            StringCchCopy(szMenuStr, ARRAYSIZE(szMenuStr), pStr);
            szMenuStr += lstrlen(pStr); // point to '\0'

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\pane.c ===
/* pane.c - This file contains the multi-pane handling routines.
 *
 * Copyright (c) 1991-, Microsoft Corporation.
 * All rights reserved.
 */


#include "packager.h"
#include <shellapi.h>
#include "dialogs.h"


//#define  OLESVR_SUPPORT           /* enable support for OLE server files */


#define DRAG_EMBED  2                   // Ctrl + Drag
#define DRAG_LINK   6                   // Ctrl + Shift + Drag


static HBRUSH hbrBlack;                 // Black brush
static HCURSOR hcurSplit;
static HWND hwndDesc;
static HWND hwndInsertIcon = NULL;
static HWND hwndView = NULL;
static INT cxBorder;                    // WS_BORDER border width
static INT cyBorder;
static INT cxFudge = 0;                 // Fudge factors for good appearance
static INT cyFudge = 0;
static INT cxMinWidth;
static INT cxView;
static INT cxSplit;                     // Splitter bar width
static INT cxPict;
static INT cxDesc;
static INT cxInsertIcon;
static INT cxMin[CCHILDREN];
static INT cyHeight;
static INT xSplit = 0;
static CHAR szButton[] = "button";
static CHAR szStatic[] = "static";
static CHAR szPaneClass[] = "PaneClass";
static CHAR szSubtitleClass[] = "SubTitleClass";
static CHAR szDescription[CBMESSAGEMAX];
static CHAR szView[CBMESSAGEMAX];
static CHAR szPicture[CBMESSAGEMAX];
static CHAR szInsertIcon[CBMESSAGEMAX];
static CHAR szDropFile[CBPATHMAX];
static BOOL fHScrollEnable = FALSE;
static BOOL fVScrollEnable = FALSE;


static BOOL MakeWindows(VOID);
static INT GetTextLen(HDC hdc, LPSTR lpstr);
static VOID RecalibrateScroll(INT iPane, DWORD lParam);
static VOID Undo(INT iPane);
static VOID CalcWindows(BOOL fFirst);
static INT Constrain(INT x, INT right);
static VOID CopyOther(VOID);


/* InitPaneClasses() - Do application "global" initialization.
 *
 * This function registers the window classes used by the application.
 * Returns:  TRUE if successful.
 */
BOOL
InitPaneClasses(
    VOID
    )
{
    WNDCLASS  wc;

    wc.style            = 0;
    wc.lpfnWndProc      = SubtitleWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInst;
    wc.hIcon            = LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(ID_APPLICATION);
    wc.lpszClassName    = szSubtitleClass;

    if (!RegisterClass(&wc))
        return FALSE;

    wc.style            = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc      = PaneWndProc;
    wc.cbClsExtra       = 0;
    // Reserve space for the item specific data handle
    wc.cbWndExtra       = sizeof(LPVOID);
    wc.hInstance        = ghInst;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = szPaneClass;

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/* InitPanes() - Handles the instance-specific initialization.
 *
 * This function creates the main application window.
 * Returns:  TRUE if successful.
 */
BOOL
InitPanes(
    VOID
    )
{
    LOGFONT lf;
    CHARSETINFO csinfo;
    LCID lcid = GetThreadLocale();
    DWORD dwCp = GetACP();

    hbrBlack = GetStockObject(BLACK_BRUSH);
    hcurSplit = LoadCursor(ghInst, MAKEINTRESOURCE(SPLIT));
    gcxIcon = GetSystemMetrics(SM_CXICON);
    gcyIcon = GetSystemMetrics(SM_CYICON);

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    SystemParametersInfo(SPI_ICONHORIZONTALSPACING, 0, &gcxArrange, FALSE);
    SystemParametersInfo(SPI_ICONVERTICALSPACING, 0, &gcyArrange, FALSE);

    // ANSI app needs to make sure it has the right charset for text rendering
    if (TranslateCharsetInfo(&dwCp, &csinfo, TCI_SRCCODEPAGE))
        lf.lfCharSet = (BYTE) csinfo.ciCharset;

    // Lock down font size to 8 point size since we won't adjust window size 
    lf.lfHeight = -MulDiv(8, giYppli, 72);
    lf.lfWidth = 0;

    ghfontTitle = CreateFontIndirect(&lf);
    if (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE)
        lf.lfWeight = FW_NORMAL;
    else
        lf.lfWeight = FW_BOLD;
    ghfontChild = CreateFontIndirect(&lf);


    if (!(ghfontTitle || ghfontChild))
    {
        if (ghfontTitle)
            DeleteObject(ghfontTitle);

        return FALSE;
    }

    LoadString(ghInst, IDS_CONTENT, gszCaption[CONTENT], CBMESSAGEMAX);
    LoadString(ghInst, IDS_VIEW, szView, CBMESSAGEMAX);
    LoadString(ghInst, IDS_DESCRIPTION, szDescription, CBMESSAGEMAX);
    LoadString(ghInst, IDS_PICTURE, szPicture, CBMESSAGEMAX);
    LoadString(ghInst, IDS_APPEARANCE, gszCaption[APPEARANCE], CBMESSAGEMAX);
    LoadString(ghInst, IDS_INSERTICON, szInsertIcon, CBMESSAGEMAX);

    // Create the window panes
    if (!MakeWindows())
        return FALSE;

    CalcWindows(TRUE);

    // Give the focus to the content pane
    PostMessage(ghwndPane[CONTENT], WM_LBUTTONDOWN, 0, 0L);

    return TRUE;
}



/* EndPaneInstance() - Instance-specific termination code.
 */
VOID
EndPanes(
    VOID
    )
{
    if (ghfontTitle)
        DeleteObject(ghfontTitle);

    if (ghfontChild)
        DeleteObject(ghfontChild);
}



/* MakeWindows() - Make the window panes.
 */
static BOOL
MakeWindows(
    VOID
    )
{
    if (ghwndBar[CONTENT] =
        CreateWindow(szSubtitleClass, gszCaption[CONTENT], WS_CHILD | WS_VISIBLE,
        0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL))
    {

        hwndView = CreateWindow(szStatic, szView,
            WS_CHILD | WS_VISIBLE | SS_LEFT | SS_CENTERIMAGE,
            0, 0, 0, 0, ghwndBar[CONTENT], NULL, ghInst, NULL);

        hwndDesc = CreateWindow(szButton, szDescription,
            WS_CHILD | BS_AUTORADIOBUTTON | WS_VISIBLE | WS_GROUP,
            0, 0, 0, 0, ghwndBar[CONTENT], (HMENU)IDM_DESC, ghInst, NULL);

        ghwndPict = CreateWindow(szButton, szPicture,
            WS_CHILD | BS_AUTORADIOBUTTON | WS_VISIBLE,
            0, 0, 0, 0, ghwndBar[CONTENT], (HMENU)IDM_PICT, ghInst, NULL);


        if (hwndView && hwndDesc && ghwndPict)
        {
            // Use the appropriate dialog font
            SendMessage(ghwndBar[CONTENT], WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            SendMessage(hwndView, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            SendMessage(hwndDesc, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            SendMessage(ghwndPict, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
            CheckRadioButton(ghwndBar[CONTENT], IDM_PICT, IDM_DESC, IDM_DESC);
            EnableWindow(ghwndPict, FALSE);
        }
        else
        {
            goto Error;
        }
    }
    else
    {
        goto Error;
    }

    if (ghwndBar[APPEARANCE] =
        CreateWindow(szSubtitleClass, gszCaption[APPEARANCE],
        WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL))
    {
        hwndInsertIcon =
            CreateWindow(szButton, szInsertIcon,
            WS_CHILD | BS_PUSHBUTTON | WS_VISIBLE,
            0, 0, 0, 0, ghwndBar[APPEARANCE], (HMENU)IDM_INSERTICON,
            ghInst, NULL);

        if (hwndInsertIcon)
        {
            SendMessage(ghwndBar[APPEARANCE], WM_SETFONT, (WPARAM)ghfontChild,
                 TRUE);
            SendMessage(hwndInsertIcon, WM_SETFONT, (WPARAM)ghfontChild, TRUE);
        }
        else
        {
            goto Error;
        }
    }
    else
    {
        goto Error;
    }

    ghwndPane[APPEARANCE] =
        CreateWindowEx(WS_EX_CLIENTEDGE, szPaneClass, NULL,
        WS_BORDER | WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
        0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL);

    ghwndPane[CONTENT] =
        CreateWindowEx(WS_EX_CLIENTEDGE, szPaneClass, NULL,
        WS_BORDER | WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
        0, 0, 0, 0, ghwndFrame, NULL, ghInst, NULL);

    if (!ghwndPane[APPEARANCE] || !ghwndPane[CONTENT])
        goto Error;

    EnableScrollBar(ghwndPane[APPEARANCE], SB_HORZ, ESB_DISABLE_BOTH);
    EnableScrollBar(ghwndPane[APPEARANCE], SB_VERT, ESB_DISABLE_BOTH);
    EnableScrollBar(ghwndPane[CONTENT], SB_HORZ, ESB_DISABLE_BOTH);
    EnableScrollBar(ghwndPane[CONTENT], SB_VERT, ESB_DISABLE_BOTH);

    DragAcceptFiles(ghwndPane[CONTENT], TRUE);

    return TRUE;

Error:
    if (ghwndBar[CONTENT])
    {
        if (hwndView)
            DestroyWindow(hwndView);

        if (hwndDesc)
            DestroyWindow(hwndDesc);

        if (ghwndPict)
            DestroyWindow(ghwndPict);

        DestroyWindow(ghwndBar[CONTENT]);
    }

    if (ghwndBar[APPEARANCE])
    {
        if (hwndInsertIcon)
            DestroyWindow(hwndInsertIcon);

        DestroyWindow(ghwndBar[APPEARANCE]);
    }

    if (ghwndPane[APPEARANCE])
        DestroyWindow(ghwndPane[APPEARANCE]);

    if (ghwndPane[CONTENT])
        DestroyWindow(ghwndPane[CONTENT]);

    return FALSE;
}



/* SubtitleWndProc() - "Appearance" and "Content" bar window procedure.
 */
LRESULT CALLBACK
SubtitleWndProc(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    RECT rcCaption;
    INT iPane;

    iPane = (hWnd == ghwndBar[CONTENT]);

    switch (msg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDM_INSERTICON:
                    Raise(APPEARANCE);
                    DeletePane(APPEARANCE, FALSE);

                    if (gptyUndo[APPEARANCE] != ICON)
                        glpobj[APPEARANCE] = IconCreateFromFile("");
                    else
                        glpobj[APPEARANCE] = IconClone(glpobjUndo[APPEARANCE]);

                    if (glpobj[APPEARANCE])
                        gpty[APPEARANCE] = ICON;

                    if (glpobj[APPEARANCE] && IconDialog(glpobj[APPEARANCE]))
                    {
                        InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                        Dirty();
                    }
                    else
                    {
                        IconDelete(glpobj[APPEARANCE]);
                        gpty[APPEARANCE] = NOTHING;
                        glpobj[APPEARANCE] = NULL;
                        SendMessage(ghwndPane[APPEARANCE], WM_COMMAND,
                            IDM_UNDO, 0);
                    }

                    break;

                case IDM_DESC:
                    if (!IsDlgButtonChecked(ghwndBar[CONTENT], IDM_DESC))
                        CheckRadioButton(ghwndBar[CONTENT], IDM_PICT,
                            IDM_DESC, IDM_DESC);

                    if (fHScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_HORZ,
                            ESB_DISABLE_BOTH);

                    if (fVScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_VERT,
                            ESB_DISABLE_BOTH);

                    InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);

                    goto defProcess;

                case IDM_PICT:
                    if (!IsDlgButtonChecked(ghwndBar[CONTENT], IDM_PICT)
                        && IsWindowEnabled(GetDlgItem(ghwndBar[CONTENT],
                        IDM_PICT)))
                        CheckRadioButton(ghwndBar[CONTENT], IDM_PICT,
                            IDM_DESC, IDM_PICT);

                    if (fHScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_HORZ,
                            ESB_ENABLE_BOTH);

                    if (fVScrollEnable)
                        EnableScrollBar(ghwndPane[iPane], SB_VERT,
                            ESB_ENABLE_BOTH);

                    InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                    // Fall through

                default:
defProcess:
                    if (GetTopWindow(ghwndFrame) != ghwndPane[iPane])
                    {
                        if (gbDBCS)
                        {
                            /* 4-Oct-93 #2701 v-katsuy */
                             //win31#1203: 12/26/92:fixing Focus Line Scroll
                             //delete Focus Rect on another pane
                            InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                        }
                        BringWindowToTop(ghwndPane[iPane]);
                        InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                        InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                        if (LOWORD(wParam) == IDM_PICT
                            || LOWORD(wParam) == IDM_DESC)
                            UpdateWindow(ghwndPane[CONTENT]);
                    }
            }

            break;

        case WM_LBUTTONDOWN:
            if (GetTopWindow(ghwndFrame) != ghwndPane[iPane])
                SendMessage(ghwndPane[iPane], WM_LBUTTONDOWN, 0, 0);

            break;

        case WM_PAINT:
            {
                HFONT hfontOld;

                GetClientRect(hWnd, &rcCaption);
                BeginPaint(hWnd, &ps);

                if (GetTopWindow(ghwndFrame) == ghwndPane[iPane])
                {
                    SetTextColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    SetBkColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHT));
                }
                else
                {
                    SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
                    SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
                }

                hfontOld = SelectObject(ps.hdc, ghfontChild);
                rcCaption.left += cxFudge;
                DrawText(ps.hdc, gszCaption[iPane], -1, &rcCaption,
                    DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOCLIP);
                SelectObject(ps.hdc, hfontOld);

                EndPaint(hWnd, &ps);
            }

            break;

        case WM_SIZE:
            if (iPane == APPEARANCE)
            {
                if (hwndInsertIcon)
                {
                    GetClientRect(hWnd, &rcCaption);

                    SetWindowPos(hwndInsertIcon, 0,
                        rcCaption.right - cxInsertIcon, cyFudge, 0, 0,
                        SWP_NOSIZE | SWP_NOZORDER);

                    InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                }
            }
            else
            {
                if (hwndView)
                {
                    BOOL bChinese = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE;
                    GetClientRect(hWnd, &rcCaption);
                    SetWindowPos(hwndView, 0,
                                 bChinese ?
                                   rcCaption.right - cxDesc - cxPict - cxView - 15 :
                                   rcCaption.right - cxDesc - cxPict - cxView,
                                   0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

                    SetWindowPos(hwndDesc, 0,
                                 rcCaption.right - cxDesc - cxPict,
                                 cyFudge, 0, 0,
                                 SWP_NOSIZE | SWP_NOZORDER);

                    SetWindowPos(ghwndPict, 0,
                                 rcCaption.right - cxPict,
                                 cyFudge, 0, 0,
                                 SWP_NOSIZE | SWP_NOZORDER);

                    InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                }
            }

            break;

        default:
            return DefWindowProc(hWnd, msg, wParam, lParam);
    }

    return 0L;
}



static INT
GetTextLen(
    HDC hdc,
    LPSTR lpstr
    )
{
    SIZE Size;

    GetTextExtentPoint32(hdc, lpstr, lstrlen(lpstr), &Size);

    return Size.cx + (cxFudge * 2);
}



LRESULT CALLBACK
PaneWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fFocus;
    LPVOID lpobjTemp;
    PAINTSTRUCT ps;
    RECT rc;
    CHAR szFile[CBPATHMAX];
    INT iOld;
    INT iPane;
    INT iPos;
    INT Max;
    INT Min;
    INT nBar;

    iPane = (hwnd == ghwndPane[CONTENT]);

    switch (msg)
    {
        case WM_HSCROLL:
        case WM_VSCROLL:
            // If not the content pane in picture mode, break
            if (gpty[iPane] == PICTURE
                && iPane == CONTENT
                && !IsDlgButtonChecked(ghwndBar[CONTENT], IDM_PICT))
                break;

            // Can't scroll anything but cmd line and picture
            if (gpty[iPane] != PICTURE && gpty[iPane] != CMDLINK)
                break;

            nBar = (msg == WM_HSCROLL ? SB_HORZ : SB_VERT);
            iOld = iPos = GetScrollPos(hwnd, nBar);

            switch (LOWORD(wParam))
            {
                case SB_LINEUP:
                    iPos--;
                    break;

                case SB_LINEDOWN:
                    iPos++;
                    break;

                case SB_PAGEUP:
                case SB_PAGEDOWN:
                    GetClientRect(hwnd, &rc);
                    if (LOWORD(wParam) == SB_PAGEUP)
                        iPos -= (rc.bottom - rc.top + 1);
                    else
                        iPos += (rc.bottom - rc.top + 1);

                    break;

                case SB_THUMBPOSITION:
                    iPos = (INT)HIWORD(wParam);
                    break;
            }

            // Make sure that iPos is in the range
            GetScrollRange(hwnd, nBar, &Min, &Max);

            if (iPos < Min)
                iPos = Min;
            if (iPos > Max)
                iPos = Max;

            SetScrollPos(hwnd, nBar, iPos, TRUE);

            if (msg == WM_HSCROLL)
                ScrollWindow(hwnd, iOld - iPos, 0, NULL, NULL);
            else
                ScrollWindow(hwnd, 0, iOld - iPos, NULL, NULL);

            UpdateWindow(hwnd);
            break;

        case WM_LBUTTONDOWN:
            if (GetTopWindow(ghwndFrame) != hwnd)
            {
                BringWindowToTop(hwnd);
                InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
            }

            break;

        case WM_PAINT:
            GetClientRect(hwnd, &rc);
            BeginPaint(hwnd, &ps);
            if (fFocus = (ghwndPane[iPane] == GetTopWindow(ghwndFrame)))
            {
                SetTextColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
                SetBkColor(ps.hdc, GetSysColor(COLOR_HIGHLIGHT));
            }
            else
            {
                SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWTEXT));
                SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW));
            }

            switch (gpty[iPane])
            {
                case CMDLINK:
                    CmlDraw(glpobj[iPane], ps.hdc, &rc,
                        GetScrollPos(hwnd, SB_HORZ), fFocus);
                    break;

                case PEMBED:
                    EmbDraw(glpobj[iPane], ps.hdc, &rc, fFocus);
                    break;

                case ICON:
                    IconDraw(glpobj[iPane], ps.hdc, &rc, fFocus, 0, 0);
                    break;

                case PICTURE:
                    PicDraw(glpobj[iPane], ps.hdc, &rc,
                        GetScrollPos(hwnd, SB_HORZ),
                        GetScrollPos(hwnd, SB_VERT),
                        hwnd == ghwndPane[APPEARANCE] ||
                        IsDlgButtonChecked(ghwndBar[CONTENT], IDM_PICT), fFocus);
                    break;

                default:
                    FillRect(ps.hdc, &rc, ghbrBackground);
                    break;
            }

            EndPaint(hwnd, &ps);
            break;

        case WM_FIXSCROLL:
            GetClientRect(hwnd, &rc);
            lParam = ((DWORD)rc.bottom << 16) | (DWORD)rc.right;

            // Fall through

        case WM_SIZE:
            if (gpty[iPane] == PICTURE || gpty[iPane] == CMDLINK)
                RecalibrateScroll(iPane, (DWORD)lParam);

            break;

        case WM_DESTROY:
            DeletePane(iPane, TRUE);
            break;

        case WM_DROPFILES:
            {
                BYTE bKeyState = 0;

                // Retrieve the file name
                DragQueryFile((HANDLE)wParam, 0, szDropFile, CBPATHMAX);

                DragFinish((HANDLE)wParam);

                // We got dropped on, so bring ourselves to the top
                BringWindowToTop(ghwndFrame);
                BringWindowToTop(hwnd);

                // See what the user wants us to do
                bKeyState = ((GetKeyState(VK_SHIFT) < 0) << 2)
                    | ((GetKeyState(VK_CONTROL) < 0) << 1)
                    | ((GetKeyState(VK_MENU) < 0));

                switch (bKeyState)
                {
                    case DRAG_LINK:
                        PostMessage(hwnd, WM_COMMAND, IDM_LINKFILE, 0L);
                        break;

                    case DRAG_EMBED:
                    default:
                        PostMessage(hwnd, WM_COMMAND, IDM_EMBEDFILE, 0L);
                        break;
                }

                break;
            }

        case WM_LBUTTONDBLCLK:
            // Alt + Double Click = Properties
            if (gpty[iPane] == PICTURE && GetKeyState(VK_MENU) < 0)
            {
                wParam = IDM_LINKS;
            }
            else
            {
                if (gpty[iPane] == PEMBED)
                {
                    //
                    // If the server is a OLE server, we want to activate in
                    // OLE fashion. But from users perspective it should not
                    // look like an object. So for non-objects double-click
                    // implies show the server. We should try to do the same
                    // thing while editing ole server files.
                    //
                    wParam = IDD_EDIT;
                }
                else
                {
                    wParam  = IDD_PLAY;
                }
            }

            msg = WM_COMMAND;
            lParam = 0;

            // Fall through

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDM_COPY:
                case IDM_CUT:
                    switch (gpty[iPane])
                    {
                        case PICTURE:
                            PicCopy(glpobj[iPane]);

                        default:
                            if (iPane == APPEARANCE)
                                CopyOther();
                            break;
                    }

                    if (LOWORD(wParam) == IDM_COPY)
                        break;

                    // Fall through to delete the selection

                case IDM_CLEAR:
                    DeletePane(iPane, FALSE);
                    break;

                case IDM_LINKS:
                    {
                        LONG objtype;

                        OleQueryType(((LPPICT)glpobj[iPane])->lpObject, &objtype);
                        if (objtype == OT_LINK)
                            DialogBoxAfterBlock(MAKEINTRESOURCE(DTPROP),
                                ghwndPane[iPane], fnProperties);

                        break;
                    }
                case IDM_LINKFILE:
                    if(SUCCEEDED(StringCchCopy(szFile, ARRAYSIZE(szFile), szDropFile)))
                    {
                        wParam = IDM_PASTELINK;
                        goto CreateFromFile;
                    }
                 
                    break;

                case IDM_EMBEDFILE:
                    if(SUCCEEDED(StringCchCopy(szFile, ARRAYSIZE(szFile), szDropFile)))
                    {
                        wParam = IDM_PASTE;
                        goto CreateFromFile;
                    }
                    break;

                case IDM_PASTE:
                case IDM_PASTELINK:
                    // Try to paste a file name from the File Manager
                    if (iPane == CONTENT)
                    {
                        HANDLE hdata;
                        LPSTR lpstrFile;

                        if (IsClipboardFormatAvailable(gcfFileName))
                        {
                            if (!OpenClipboard(ghwndFrame))
                                break;

                            if (!(hdata = GetClipboardData(gcfFileName)) || !(lpstrFile =
                                GlobalLock(hdata)))
                            {
                                CloseClipboard();
                                break;
                            }

                            StringCchCopy(szFile, ARRAYSIZE(szFile), lpstrFile);
                            GlobalUnlock(hdata);
                            CloseClipboard();

CreateFromFile:

#ifdef OLESVR_SUPPORT
                            if (IsOleServerDoc (szFile))
                            {
                                lpobjTemp = PicFromFile((wParam == IDM_PASTE),
                                    szFile);
                                if (!lpobjTemp)
                                {
                                    ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                                    break;
                                }

                                goto StuffNewObject;
                            }
                            else
                            {
#endif
                                DeletePane(CONTENT, FALSE);
                                if (wParam == IDM_PASTE)
                                {
                                    if (glpobj[CONTENT] = EmbCreate(szFile))
                                        gpty[CONTENT] = PEMBED;
                                }
                                else
                                {
                                    if (glpobj[CONTENT] =
                                           CmlCreateFromFilename(szFile, TRUE))
                                        gpty[CONTENT] = CMDLINK;
                                }
#ifdef OLESVR_SUPPORT
                            }
#endif
                            InvalidateRect(ghwndPane[CONTENT], NULL, TRUE);
                            Dirty();

                            if (!gpty[APPEARANCE])
                            {
                                if (glpobj[APPEARANCE] =
                                    IconCreateFromFile(szFile))
                                {
                                    gpty[APPEARANCE] = ICON;
                                    InvalidateRect(ghwndPane[APPEARANCE],
                                        NULL, TRUE);
                                }
                            }

                            break;
                        }
                    }

                    // Not a file name, try to paste an OLE object
                    if (!(lpobjTemp = PicPaste(LOWORD(wParam) == IDM_PASTE,
                                                gszCaption[iPane])))
                    {
                        ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                        break;
                    }
#ifdef OLESVR_SUPPORT

StuffNewObject:

#endif
                    DeletePane(iPane, FALSE);
                    glpobj[iPane] = lpobjTemp;
                    gpty[iPane] = PICTURE;
                    SendMessage(ghwndPane[iPane], WM_FIXSCROLL, 0, 0L);
                    InvalidateRect(ghwndPane[iPane], NULL, TRUE);
                    Dirty();

                    if (iPane == CONTENT)
                    {
                        EnableWindow(ghwndPict, TRUE);

                        if (!gpty[APPEARANCE])
                        {
                            if (glpobj[APPEARANCE] = IconCreateFromObject(
                                ((LPPICT)glpobj[iPane])->lpObject))
                            {
                                gpty[APPEARANCE] = ICON;
                                InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
                            }
                        }
                    }

                    Dirty();
                    break;

                case IDD_EDIT:          /* Edit the icon form */
                case IDD_PLAY:
                    switch (gpty[iPane])
                    {
                        case CMDLINK:
                            CmlActivate(glpobj[iPane]);
                            break;

                        case PEMBED:
                            EmbActivate(glpobj[iPane], LOWORD(wParam));
                            break;

                        case PICTURE:
                            PicActivate(glpobj[iPane], LOWORD(wParam));
                            break;

                        default:
                            break;
                    }

                    break;

                case IDD_UPDATE:        /* Update the (link) object */
                    if (gpty[iPane] == PICTURE)
                        PicUpdate(glpobj[iPane]);

                    break;

                case IDD_FREEZE:        /* Make the object static */
                    if (gpty[iPane] == PICTURE)
                        PicFreeze(glpobj[iPane]);

                    break;

                case IDD_CHANGE:
                    if (gpty[iPane] == PICTURE)
                        PicChangeLink(glpobj[iPane]);

                    break;

                case IDM_UNDO:
                    Undo(iPane);
                    break;

                case IDD_AUTO:          /* Change the (link) update options */
                case IDD_MANUAL:
                    if (gpty[iPane] == PICTURE
                        && !PicSetUpdateOptions(glpobj[iPane], LOWORD(wParam)))
                        break;

                case IDM_LINKDONE:      /* The link update has completed */
                    PostMessage(ghwndError, WM_REDRAW, 0, 0L);
                    break;

                default:
                    break;
            }

            break;

        default:
            return (DefWindowProc(hwnd, msg, wParam, lParam));
    }

    return 0;
}



LRESULT CALLBACK
SplitterFrame(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT rc;

    switch (msg)
    {
        case WM_SIZE:
            if (wParam != SIZEICONIC && ghwndBar[APPEARANCE])
            {
                GetClientRect(hWnd, &rc);

                // Make sure the splitter bar is still valid
                xSplit = Constrain(xSplit, rc.right);
                CalcWindows(FALSE);

                // Invalidate the splitter bar, forcing a repaint
                rc.left = xSplit - cxSplit / 2 - cxBorder;
                rc.right = xSplit + cxSplit / 2 + cxBorder;
                InvalidateRect(hWnd, &rc, TRUE);
            }

            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                RECT rcBlack;

                BeginPaint(hWnd, &ps);
                GetClientRect(hWnd, &rc);

                SetRect(&rcBlack, xSplit - cxSplit / 2 - cxBorder,
                    rc.top, xSplit + cxSplit / 2 + cxBorder,
                    rc.top + cyHeight + cyBorder);
                FillRect(ps.hdc, &rcBlack, hbrBlack);

                SetRect(&rcBlack, xSplit - cxSplit / 2 - cxBorder,
                    rc.bottom - GetSystemMetrics(SM_CYHSCROLL) + 1,
                    xSplit + cxSplit / 2 + cxBorder,
                    rc.bottom);
                FillRect(ps.hdc, &rcBlack, hbrBlack);

                EndPaint(hWnd, &ps);
                break;
            }

        case WM_GETMINMAXINFO:
            {
                LPPOINT rgpt = (LPPOINT)lParam;

                rgpt[3].x = cxMinWidth;
                rgpt[3].y = cyHeight * 6;
                break;
            }

        case WM_LBUTTONDOWN:
            {
                MSG msg1;
                INT x;
                INT y;
                INT dy;
                HDC hdc;
                HCURSOR hcurOld;

                if (IsIconic(hWnd))
                    break;

                x  = LOWORD(lParam);
                GetClientRect(hWnd, &rc);
                y  = 0;
                dy = rc.bottom;

                // Constrain the splitter bar...
                x = Constrain(x, rc.right);
                hdc = GetDC(hWnd);

                // split bar loop
                PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy, PATINVERT);
                SetCapture(hWnd);
                hcurOld = SetCursor(hcurSplit);

                while (GetMessage(&msg1, NULL, 0, 0))
                {
                    if (msg1.message >= WM_MOUSEFIRST
                        && msg1.message <= WM_MOUSELAST)
                    {
                        if (msg1.message == WM_LBUTTONUP
                            || msg1.message == WM_LBUTTONDOWN)
                            break;

                        if (msg1.message == WM_MOUSEMOVE)
                        {
                            ScreenToClient(hWnd, &msg1.pt);
                            x = Constrain(x, rc.right);

                            // erase old
                            PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy,
                                PATINVERT);

                            // put down new
                            x = Constrain(msg1.pt.x, rc.right);
                            PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy,
                                PATINVERT);
                        }
                    }
                    else
                    {
                        DispatchMessage(&msg1);
                    }
                }

                SetCursor(hcurOld);
                ReleaseCapture();

                // Constrain the splitter bar...
                x = Constrain(x, rc.right);

                // erase old
                PatBlt(hdc, x - cxSplit / 2, y, cxSplit, dy, PATINVERT);

                ReleaseDC(hWnd, hdc);

                if (msg1.wParam != VK_ESCAPE)
                {
                    xSplit = x;
                    CalcWindows(FALSE);
                    InvalidateRect(ghwndBar[APPEARANCE], NULL, TRUE);
                    InvalidateRect(ghwndBar[CONTENT], NULL, TRUE);
                }

                break;
            }

        default:
            return FALSE;
    }

    return TRUE;
}



VOID
DeletePane(
    INT iPane,
    BOOL fDeleteUndo
    )
{
    // Delete the last Undo object
    if (glpobjUndo[iPane])
        DeletePaneObject(glpobjUndo[iPane], gptyUndo[iPane]);

    // If we don't wish to keep an undo, delete the object too!
    if (fDeleteUndo)
    {
        DeletePaneObject(glpobj[iPane], gpty[iPane]);
        gptyUndo[iPane] = NOTHING;
        glpobjUndo[iPane] = NULL;
    }
    else
    {
        gptyUndo[iPane] = gpty[iPane];
        glpobjUndo[iPane] = glpobj[iPane];
    }

    // Handle the buttons and such
    if (gpty[iPane] == PICTURE || gpty[iPane] == CMDLINK)
    {
        CHAR szUndoName[CBMESSAGEMAX];

        EnableScrollBar(ghwndPane[iPane], SB_HORZ, ESB_DISABLE_BOTH);
        EnableScrollBar(ghwndPane[iPane], SB_VERT, ESB_DISABLE_BOTH);

        if (gpty[iPane] == PICTURE)
        {
            if (iPane == CONTENT)
            {
                CheckRadioButton(ghwndBar[CONTENT], IDM_PICT, IDM_DESC, IDM_DESC);
                EnableWindow(ghwndPict, FALSE);
            }

            // If the Undo object isn't deleted already, rename it
            if (!fDeleteUndo)
            {
                if(SUCCEEDED(StringCchPrintf(szUndoName, ARRAYSIZE(szUndoName), szUndo, gszCaption[iPane])))
                {
                    OleRename(((LPPICT)glpobjUndo[iPane])->lpObject, szUndoName);
                }
            }
        }
    }

    glpobj[iPane] = NULL;
    gpty[iPane]   = NOTHING;

    if (IsWindow(ghwndPane[iPane]))
        InvalidateRect(ghwndPane[iPane], NULL, TRUE);
}



static VOID
RecalibrateScroll(
    INT iPane,
    DWORD lParam
    )
{
    INT cxDel;
    INT cyDel;
    BOOL bDesc = FALSE;
    LPPICT lppict = (LPPICT)glpobj[iPane];

    // Compute the amount of scrolling possible
    cxDel = lppict->rc.right - lppict->rc.left - (INT)(lParam & 0xffff);
    cyDel = lppict->rc.bottom - lppict->rc.top - (INT)(lParam >> 16);

    // Normalize the scroll bar lengths
    if (cxDel < 0)
        cxDel = 0;

    if (cyDel < 0)
        cyDel = 0;

    if (iPane == CONTENT)
    {
        bDesc = IsDlgButtonChecked(ghwndBar[iPane], IDM_DESC);
        fHScrollEnable = cxDel;
        fVScrollEnable = cyDel;
    }

    EnableScrollBar(ghwndPane[iPane], SB_HORZ,
        (cxDel && !bDesc) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

    EnableScrollBar(ghwndPane[iPane], SB_VERT,
        (cyDel && !bDesc) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);

    // Ensure that the thumb is at a meaningful position
    if (GetScrollPos(ghwndPane[iPane], SB_HORZ) > cxDel)
        SetScrollPos(ghwndPane[iPane], SB_HORZ, cxDel, TRUE);

    if (GetScrollPos(ghwndPane[iPane], SB_VERT) > cyDel)
        SetScrollPos(ghwndPane[iPane], SB_VERT, cyDel, TRUE);
}



static VOID
Undo(
    INT iPane
    )
{
    DWORD ot;
    LPPICT lppict;
    LPVOID lpobjTemp;
    INT ptyTemp;

    if (gpty[iPane] == PICTURE)
    {
        lppict = glpobj[iPane];

        // Close the old object
        if (lppict->lpObject)
        {
            OleQueryType(lppict->lpObject, &ot);
            if (ot != OT_STATIC)
                Error(OleClose(lppict->lpObject));
        }

        OleRename(lppict->lpObject, gszTemp);
    }

    if (gptyUndo[iPane] == PICTURE)
    {
        lppict = glpobjUndo[iPane];

        // Try to reconnect the new object if it's a link
        if (lppict->lpObject)
        {
            OleQueryType(lppict->lpObject, &ot);
            if (ot == OT_LINK && Error(OleReconnect(lppict->lpObject)))
                ErrorMessage(E_FAILED_TO_RECONNECT_OBJECT);
        }

        OleRename(lppict->lpObject, gszCaption[iPane]);
    }

    if (gpty[iPane] == PICTURE)
    {
        CHAR szUndoName[CBMESSAGEMAX];

        lppict = glpobj[iPane];
        if(SUCCEEDED(StringCchPrintf(szUndoName, ARRAYSIZE(szUndoName), szUndo, gszCaption[iPane])))
        {
            OleRename(lppict->lpObject, szUndoName);
        }
    }

    // Handle the buttons and enable/disable scroll bars

    // Going from picture to non-picture, disable all special things
    if (gptyUndo[iPane] != PICTURE && gpty[iPane] == PICTURE)
    {
        if (iPane == CONTENT)
        {
            CheckRadioButton(ghwndBar[CONTENT], IDM_PICT, IDM_DESC, IDM_DESC);
            EnableWindow(ghwndPict, FALSE);
        }

        EnableScrollBar(ghwndPane[iPane], SB_HORZ, ESB_DISABLE_BOTH);
        EnableScrollBar(ghwndPane[iPane], SB_VERT, ESB_DISABLE_BOTH);
    }

    if (gptyUndo[iPane] == PICTURE || gptyUndo[iPane] == CMDLINK)
    {
        SendMessage(ghwndPane[iPane], WM_FIXSCROLL, 0, 0L);

        if (gptyUndo[iPane] == PICTURE)
        {
            // Going from non-picture to picture, enable button
            if (gpty[iPane] != PICTURE && iPane == CONTENT)
                EnableWindow(ghwndPict, TRUE);
        }
    }

    lpobjTemp = glpobj[iPane];
    glpobj[iPane] = glpobjUndo[iPane];
    glpobjUndo[iPane] = lpobjTemp;

    ptyTemp = gpty[iPane];
    gpty[iPane] = gptyUndo[iPane];
    gptyUndo[iPane] = ptyTemp;

    InvalidateRect(ghwndPane[iPane], NULL, TRUE);
    Dirty();
}



static VOID
CalcWindows(
    BOOL fFirst
    )
{
    if (fFirst)
    {
        // Figure out the length of the text strings, and all dimensions
        HDC hdc = GetWindowDC(ghwndFrame);
        if (hdc)
        {
            cxBorder = GetSystemMetrics(SM_CXBORDER);
            cyBorder = GetSystemMetrics(SM_CYBORDER);
            cxFudge = cxBorder * 2;
            cyFudge = cyBorder * 2;
            cxSplit = cxBorder * 4;

            if (gbDBCS)
            {
                /* #3963 13-Dec-93 v-katsuy */
                /* ORIGINALBUG! Window width calculated for just "&Picture".
                 *  This width should be calculate
                 *  [Radiobutton] + [Text](not include '&').
                 */
                CHAR  szTemp[CBMESSAGEMAX];
                LPSTR lpText, lpTemp;

                for (lpText = szPicture, lpTemp = szTemp; *lpText; ) {
                    if (*lpText == '&')
                        lpText++;
                    else
                        *lpTemp++ = *lpText++;
                }
                *lpTemp = 0;
                cxPict = GetTextLen(hdc, szTemp) + cxFudge * 2
                       + GetSystemMetrics(SM_CXSIZE); // for radiobutton 

                for (lpText = szDescription, lpTemp = szTemp; *lpText; ) {
                    if (*lpText == '&')
                        lpText++;
                    else
                        *lpTemp++ = *lpText++;
                }
                *lpTemp = 0;
                cxDesc = GetTextLen(hdc, szTemp)
                       + GetSystemMetrics(SM_CXSIZE); // for radiobutton
            }
            else
            {
                cxPict = GetTextLen(hdc, szPicture) + cxFudge * 2;
                cxDesc = GetTextLen(hdc, szDescription);
            }

            cxView = GetTextLen(hdc, szView);
            cxInsertIcon = GetTextLen(hdc, szInsertIcon) + cxFudge;

            cxMin[CONTENT] = cxPict + cxDesc + cxView +
                GetTextLen(hdc, gszCaption[CONTENT]) + cxFudge;
            cxMin[APPEARANCE] = cxInsertIcon +
                GetTextLen(hdc, gszCaption[APPEARANCE]) + cxFudge;
            cyHeight = GetSystemMetrics(SM_CYMENU) + cyFudge * 2;
            ReleaseDC(ghwndFrame, hdc);

            cxMinWidth = cxMin[APPEARANCE] + cxMin[CONTENT] + cxSplit +
                GetSystemMetrics(SM_CXFRAME) + cxFudge;

            // Compute all the window sizes that we can
            SetWindowPos(ghwndFrame, 0, 0, 0,
                cxMinWidth + cxFudge * 20,
                cxMinWidth * 7 / 18,
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(hwndInsertIcon, 0, 0, 0,
                cxInsertIcon - cxFudge,
                GetSystemMetrics(SM_CYMENU),
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(hwndView, 0, 0, 0,
                cxView, cyHeight - cyFudge,
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(ghwndPict, 0, 0, 0,
                (cxPict - cxFudge) << 1,
                GetSystemMetrics(SM_CYMENU),
                SWP_NOMOVE | SWP_NOZORDER);
            SetWindowPos(hwndDesc, 0, 0, 0,
                cxDesc, GetSystemMetrics(SM_CYMENU),
                SWP_NOMOVE | SWP_NOZORDER);
        }
    }
    else
    {
        RECT rc;

        GetClientRect(ghwndFrame, &rc);

        // Move the windows to the appropriate locations
        SetWindowPos(ghwndBar[APPEARANCE], 0, 0, 0,
            xSplit - cxSplit / 2 - cxBorder, cyHeight, SWP_NOZORDER);

        SetWindowPos(ghwndBar[CONTENT], 0,
            xSplit + cxSplit / 2 + cxBorder,
            0,
            rc.right - (xSplit + cxSplit / 2) + 1 - cxBorder,
            cyHeight,
            SWP_NOZORDER);

        SetWindowPos(ghwndPane[APPEARANCE], 0,
            -cxBorder,
            cyHeight,
            cxBorder + xSplit - cxSplit / 2,
            rc.bottom + cyBorder - cyHeight,
            SWP_NOZORDER);

        SetWindowPos(ghwndPane[CONTENT], 0,
            xSplit + cxSplit / 2,
            cyHeight,
            cxBorder + rc.right - (xSplit + cxSplit / 2) + 1,
            rc.bottom + cyBorder - cyHeight,
            SWP_NOZORDER);
    }
}



static INT
Constrain(
    INT x,
    INT right
    )
{
    // Constrain the splitter bar...
    if (x < cxMin[APPEARANCE] + cxSplit / 2 - 1)
        return cxMin[APPEARANCE] + cxSplit / 2 - 1;
    else if (x > (right - cxMin[CONTENT] - cxSplit / 2 + 1))
        return right - cxMin[CONTENT] - cxSplit / 2 + 1;

    return x;
}



/* CopyOther() - Copies the picture in appearance pane
 *
 * Returns:  none
 */
static VOID
CopyOther(
    VOID
    )
{
    HANDLE hdata;

    if (OpenClipboard(ghwndFrame))
    {
        Hourglass(TRUE);
        EmptyClipboard();

        if (hdata = GetMF())
            SetClipboardData(CF_METAFILEPICT, hdata);

        CloseClipboard();
        Hourglass(FALSE);
    }
}



VOID
DeletePaneObject(
    LPVOID lpobj,
    INT objType
    )
{
    switch (objType)
    {
        case CMDLINK:
            CmlDelete(lpobj);
            break;

        case PEMBED:
            EmbDelete(lpobj);
            break;

        case ICON:
            IconDelete(lpobj);
            break;

        case PICTURE:
            PicDelete(lpobj);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\register.c ===
/* register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"

TCHAR gszAppName[] = "packager.exe";

/* RegInit() - Prepare the registration database for calls.
 */
VOID
RegInit(
    VOID
    )
{
    CHAR sz[CBMESSAGEMAX];
    CHAR szVerb[CBMESSAGEMAX];
    DWORD dwBytes = CBMESSAGEMAX;
    static TCHAR szAppClassID[] = TEXT("{0003000C-0000-0000-C000-000000000046}");



    // If the server is not in the registration database, add it
    if (RegQueryValue(HKEY_CLASSES_ROOT, gszAppClassName, sz, &dwBytes))
    {
        HKEY hkey;

        if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hkey))
            return;

        // Add the server name string
        LoadString(ghInst, IDS_FILTER, sz, CBMESSAGEMAX);
        RegSetValue(HKEY_CLASSES_ROOT, gszAppClassName, REG_SZ, sz,
            lstrlen(sz) + 1);

        // Add the server execute string  (don't forget the terminating zero
        // on "packgr32.exe")

        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\protocol\\StdFileEditing\\server");
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, gszAppName,
                (lstrlen(gszAppName) + 1));

        // Primary verb
        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\protocol\\StdFileEditing\\verb\\0");
        LoadString(ghInst, IDS_PRIMARY_VERB, szVerb, CBMESSAGEMAX);
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, szVerb, sizeof(szVerb));

        // Secondary verb
        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\protocol\\StdFileEditing\\verb\\1");
        LoadString(ghInst, IDS_SECONDARY_VERB, szVerb, CBMESSAGEMAX);
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, szVerb, sizeof(szVerb));

        // CLSID
        StringCchCopy(sz, ARRAYSIZE(sz), gszAppClassName);
        StringCchCat(sz, ARRAYSIZE(sz), "\\CLSID");
        RegSetValue(HKEY_CLASSES_ROOT, sz, REG_SZ, szAppClassID, sizeof(szAppClassID));
        RegCloseKey(hkey);
    }

    // If the CLSID is not in the registration database, add it
    dwBytes = CBMESSAGEMAX;

    StringCchCopy(sz, ARRAYSIZE(sz), "CLSID\\");
    StringCchCat(sz, ARRAYSIZE(sz), szAppClassID);
    if (RegQueryValue(HKEY_CLASSES_ROOT, sz, szVerb, &dwBytes))
    {
        HKEY hkey;

        if (RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hkey))
            return;

        // Add the CLSID name string
        RegSetValue(hkey, szAppClassID, REG_SZ, gszAppClassName, lstrlen(gszAppClassName) + 1);

        // Add the OLE class
        StringCchCopy(sz, ARRAYSIZE(sz), szAppClassID);
        StringCchCat(sz, ARRAYSIZE(sz), "\\Ole1Class");
        RegSetValue(hkey, sz, REG_SZ, gszAppClassName, lstrlen(gszAppClassName) + 1);

        // Add the prog id
        StringCchCopy(sz, ARRAYSIZE(sz), szAppClassID);
        StringCchCat(sz, ARRAYSIZE(sz), "\\ProgID");
        RegSetValue(hkey, sz, REG_SZ, gszAppClassName, lstrlen(gszAppClassName) + 1);

        RegCloseKey(hkey);
    }
}



/* RegGetClassId() - Retrieves the string name of a class.
 *
 * Note:  Classes are guaranteed to be in ASCII, but should
 *        not be used directly as a rule because they might
 *        be meaningless if running non-English Windows.
 */
VOID
RegGetClassId(
    LPSTR lpstrName,
    DWORD nameBufferSize,
    LPSTR lpstrClass
    )
{
    DWORD dwSize = KEYNAMESIZE;
    CHAR szName[KEYNAMESIZE];

    if (!RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, szName, &dwSize))
    {
        StringCchCopy(lpstrName, nameBufferSize, szName);  // potential overrun fixed
    }
    else
        StringCchCopy(lpstrName, nameBufferSize, lpstrClass);
}



/* RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * This function returns a filter spec, to be used in the "Change Link"
 * standard dialog box, which contains all the default extensions which
 * are associated with the given class name.  Again, the class names are
 * guaranteed to be in ASCII.
 *
 * Returns:  The index nFilterIndex stating which filter item matches the
 *           extension, or 0 if none is found.
 */
INT
RegMakeFilterSpec(
    LPSTR lpstrClass,
    LPSTR lpstrExt,
    LPSTR lpstrFilterSpec
    )
{
    DWORD dwSize;
    CHAR szClass[KEYNAMESIZE];
    CHAR szName[KEYNAMESIZE];
    CHAR szString[KEYNAMESIZE];
    UINT i;
    INT idWhich = 0;
    INT idFilterIndex = 0;
    LPSTR pMaxStr = lpstrFilterSpec + 4 * MAX_PATH; // Per caller size

    for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE);)
    {
        dwSize = KEYNAMESIZE;
        if (*szName == '.'              /* Default Extension... */  /* ... so, get the class name */
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)
            /* ... and if the class name matches (null class is wildcard) */
            && (!lpstrClass || !lstrcmpi(lpstrClass, szClass)))
        {
            /* ... get the class name string */
            dwSize = KEYNAMESIZE;
            if(!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize))
            {
                idWhich++;      /* Which item of the combo box is it? */

                // If the extension matches, save the filter index
                if (lpstrExt && !lstrcmpi(lpstrExt, szName))
                    idFilterIndex = idWhich;

                //
                // Copy over "<Class Name String> (*<Default Extension>)"
                // e.g. "Server Picture (*.PIC)"
                //

                // because lpstrFilterSpec changes, we need to check all the concats now
                if(lpstrFilterSpec + 
                    (lstrlen(szString) + 
                    lstrlen(" (*") + 
                    lstrlen(szName) +
                    lstrlen(")") +
                    lstrlen("*") +
                    lstrlen(szName) +
                    1) >= pMaxStr)
                {
                    break;
                }

                lstrcpy(lpstrFilterSpec, szString);
                lstrcat(lpstrFilterSpec, " (*");
                lstrcat(lpstrFilterSpec, szName);
                lstrcat(lpstrFilterSpec, ")");
                lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;

                // Copy over "*<Default Extension>" (e.g. "*.PIC")
                lstrcpy(lpstrFilterSpec, "*");  
                lstrcat(lpstrFilterSpec, szName);
                lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
            }
        }
    }

    // Add another NULL at the end of the spec
    *lpstrFilterSpec = 0;

    return idFilterIndex;
}



VOID
RegGetExeName(
    LPSTR lpstrExe,
    LPSTR lpstrClass,
    DWORD dwBytes
    )
{
    // Add the server execute string
    CHAR szServer[KEYNAMESIZE];
    if(SUCCEEDED(StringCchCopy(szServer,  ARRAYSIZE(szServer), lpstrClass)))
    {
        if(SUCCEEDED(StringCchCat(szServer, ARRAYSIZE(szServer), "\\protocol\\StdFileEditing\\server")))
        {
            RegQueryValue(HKEY_CLASSES_ROOT, szServer, lpstrExe, &dwBytes);
        }
        else
        {
            *lpstrExe = 0;
        }
    }
    else
    {
        *lpstrClass = 0;
        *lpstrExe = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\picture.c ===
/* picture.c - This file contains OLE object handling routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include "dialogs.h"


static OLECLIENTVTBL clientTbl;
static OLESTREAMVTBL streamTbl;


static VOID PicGetBounds(LPOLEOBJECT lpObject, LPRECT lprc);

/* InitClient() - Initialize the OLE client structures.
 */
BOOL
InitClient(
    VOID
    )
{
    gcfFileName  = (OLECLIPFORMAT)RegisterClipboardFormat("FileName");
    gcfLink      = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    gcfNative    = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    gcfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");

    glpclient = PicCreateClient(&CallBack, (LPOLECLIENTVTBL)&clientTbl);

    if (!(glpStream = (LPAPPSTREAM)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(APPSTREAM))))
        goto Error;

    glpStream->lpstbl = (LPOLESTREAMVTBL)&streamTbl;
    streamTbl.Get = (DWORD (CALLBACK*)(LPOLESTREAM, void FAR*, DWORD))ReadStream;
    streamTbl.Put = (DWORD (CALLBACK*)(LPOLESTREAM, OLE_CONST void FAR*, DWORD))WriteStream;

    return TRUE;

Error:
    if (glpStream)
    {
        GlobalFree(glpStream);
    	glpStream = NULL;
    }

    if (glpclient)
    {
        GlobalFree(glpclient);
        glpclient = NULL;
    }

    return FALSE;
}



/* EndClient() - Clean up for termination.
 */
VOID
EndClient(
    VOID
    )
{
    if (glpStream)
    {
	GlobalFree(glpStream);
        glpStream = NULL;
    }

    if (glpclient)
    {
	GlobalFree(glpclient);
        glpclient = NULL;
    }
}



/* PicCreate() -
 */
LPPICT
PicCreate(
    LPOLEOBJECT lpObject,
    LPRECT lprcObject
    )
{
    HANDLE hpict = NULL;
    LPPICT lppict = NULL;
    RECT rc;

    if (lpObject)
    {
        if (!(hpict = GlobalAlloc(GMEM_MOVEABLE, sizeof(PICT)))
            || !(lppict = (LPPICT)GlobalLock(hpict)))
            goto errRtn;

        //
        // If size of window is specified, use it; otherwise, retrieve
        // the size of the item synchronously.
        //
        if (lprcObject)
            rc = *lprcObject;
        else {
            SetRectEmpty(&rc);
            PicGetBounds(lpObject, &rc);
        }

        // Store the data in the window itself
        lppict->hdata = hpict;
        lppict->lpObject = lpObject;
        lppict->rc = rc;
        lppict->fNotReady = FALSE;
    }

    return lppict;

errRtn:
    ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);

    if (lppict)
        GlobalUnlock(hpict);

    if (hpict)
        GlobalFree(hpict);

    return NULL;
}



/* PicDelete() - Deletes an object (called when the item window is destroyed).
 */
VOID
PicDelete(
    LPPICT lppict
    )
{
    HANDLE hdata;
    LPOLEOBJECT lpObject;

    if (!lppict)
        return;

    if (lppict && lppict->lpObject)
    {
        lpObject = lppict->lpObject;
        lppict->lpObject = NULL;
        // Wait until the object isn't busy
        WaitForObject(lpObject);

        if (Error(OleDelete(lpObject)))
            ErrorMessage(E_FAILED_TO_DELETE_OBJECT);

        // Wait until the object deletion is complete
        WaitForObject(lpObject);
    }

    GlobalUnlock(hdata = lppict->hdata);
    GlobalFree(hdata);
}



/* PicDraw() - Draws the item associated with hwnd in the DC hDC.
 */
BOOL
PicDraw(
    LPPICT lppict,
    HDC hDC,
    LPRECT lprc,
    INT xHSB,
    INT yVSB,
    BOOL fPicture,
    BOOL fFocus
    )
{
    BOOL fSuccess = FALSE;
    DWORD ot;
    HANDLE hdata;
    HFONT hfont;
    LPOLEOBJECT lpObjectUndo;
    LPSTR lpdata;
    RECT rc;
    RECT rcFocus;
    CHAR szDesc[CBMESSAGEMAX];
    CHAR szFileName[CBPATHMAX];
    CHAR szMessage[CBMESSAGEMAX + CBPATHMAX];
    INT iDelta;
    INT iPane;

    iPane = (lppict == glpobj[CONTENT]);
    lpObjectUndo = (gptyUndo[iPane] == PICTURE)
        ? ((LPPICT)glpobjUndo[iPane])->lpObject : NULL;

    // If drawing the Picture, offset by scroll bars and draw
    if (fPicture)
    {
        if (IsRectEmpty(&(lppict->rc)))
            PicGetBounds(lppict->lpObject, &(lppict->rc));

        rc = lppict->rc;

        // If image is smaller than pane, center horizontally
        if ((iDelta = lprc->right - lppict->rc.right) > 0)
            OffsetRect(&rc, iDelta >> 1, 0);
        else /* else, use the scroll bar value */
            OffsetRect(&rc, -xHSB, 0);

        // If image is smaller than pane, center vertically
        if ((iDelta = lprc->bottom - lppict->rc.bottom) > 0)
            OffsetRect(&rc, 0, iDelta >> 1);
        else /* else, use the scroll bar value */
            OffsetRect(&rc, 0, -yVSB);

        // If we have an object, call OleDraw()
        fSuccess = !Error(OleDraw(lppict->lpObject, hDC, &rc, NULL, NULL));

        if (fFocus)
            DrawFocusRect(hDC, &rc);

        return fSuccess;
    }

    // Otherwise, draw the description string
    OleQueryType(lppict->lpObject, &ot);

    if ((ot == OT_LINK
        && Error(OleGetData(lppict->lpObject, gcfLink, &hdata)))
        || (ot == OT_EMBEDDED
        && Error(OleGetData(lppict->lpObject, gcfOwnerLink, &hdata)))
        || (ot == OT_STATIC
        && (!lpObjectUndo || Error(OleGetData(lpObjectUndo, gcfOwnerLink,
        &hdata)))))
    {
        LoadString(ghInst, IDS_OBJECT, szFileName, CBMESSAGEMAX);
        LoadString(ghInst, IDS_FROZEN, szDesc, CBMESSAGEMAX);
        goto DrawString;
    }

    if (hdata && (lpdata = GlobalLock(hdata)))
    {
        switch (ot)
        {
            case OT_LINK:
                while (*lpdata++)
                    ;
                
                // return value ignored
                if(SUCCEEDED(StringCchCopy(szFileName, ARRAYSIZE(szFileName), lpdata)))
                {
                    Normalize(szFileName);
                    LoadString(ghInst, IDS_LINKTOFILE, szDesc, CBMESSAGEMAX);
                }

                break;

            case OT_EMBEDDED:
                RegGetClassId(szFileName, ARRAYSIZE(szFileName), lpdata);
                LoadString(ghInst, IDS_EMBEDFILE, szDesc, CBMESSAGEMAX);
                break;

            case OT_STATIC:
                RegGetClassId(szFileName, ARRAYSIZE(szFileName), lpdata);
                LoadString(ghInst, IDS_FROZEN, szDesc, CBMESSAGEMAX);
                break;
        }

        GlobalUnlock(hdata);

DrawString:
        if(SUCCEEDED(StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szDesc, szFileName)))  // return value ignored
        {

            hfont = SelectObject(hDC, ghfontChild);
            DrawText(hDC, szMessage, -1, lprc,
                DT_NOPREFIX | DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            if (fFocus)
            {
                rcFocus = *lprc;
                DrawText(hDC, szMessage, -1, &rcFocus,
                    DT_CALCRECT | DT_NOPREFIX | DT_LEFT | DT_TOP | DT_SINGLELINE);
                OffsetRect(&rcFocus, (lprc->left + lprc->right - rcFocus.right) / 2,
                    (lprc->top + lprc->bottom - rcFocus.bottom) / 2);
                DrawFocusRect(hDC, &rcFocus);
            }

            if (hfont)
                SelectObject(hDC, hfont);

            fSuccess = TRUE;
        }
    }

    return fSuccess;
}



/* PicPaste() - Retrieves an object from the clipboard.
 */
LPPICT
PicPaste(
    BOOL fPaste,
    LPSTR lpstrName
    )
{
    LPOLEOBJECT lpObject;

    if (!OpenClipboard(ghwndFrame))
        return NULL;                    /* Couldn't open the clipboard */

    Hourglass(TRUE);

    // Don't replace the current object unless we're successful
    if (fPaste)
    {
        if (Error(OleCreateFromClip(gszProtocol, glpclient, glhcdoc, lpstrName,
            &lpObject, olerender_draw, 0)))
        {
            if (Error(OleCreateFromClip(gszSProtocol, glpclient, glhcdoc,
                lpstrName, &lpObject, olerender_draw, 0)))
                lpObject = NULL;

        }
    }
    else if (Error(OleCreateLinkFromClip(
        gszProtocol, glpclient, glhcdoc, lpstrName, &lpObject,
        olerender_draw, 0)))
    {
        lpObject = NULL;
    }

    CloseClipboard();
    Hourglass(FALSE);

    if (!lpObject)
        return NULL;

    return PicCreate(lpObject, NULL);
}



/* Error() - check for OLE function error conditions
 *
 * This function increments gcOleWait as appropriate.
 *
 * Pre:      Initialize ghwndError to where the focus should return.
 *
 * Returns:  TRUE  if an immediate error occurred.
 */
BOOL
Error(
    OLESTATUS olestat
    )
{
    DWORD ot;
    INT iPane;

    switch (olestat)
    {
        case OLE_WAIT_FOR_RELEASE:
            gcOleWait++;
            return FALSE;

        case OLE_OK:
            return FALSE;

        case OLE_ERROR_STATIC:              /* Only happens w/ dbl click */
            ErrorMessage(W_STATIC_OBJECT);
            break;

        case OLE_ERROR_ADVISE_PICT:
        case OLE_ERROR_OPEN:                /* Invalid link? */
        case OLE_ERROR_NAME:
            iPane = (GetTopWindow(ghwndFrame) == ghwndPane[CONTENT]);
            if ((LPPICT)glpobj[iPane] == NULL)
            {
                ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
                return FALSE;
            }
            else
            {
                OleQueryType(((LPPICT)glpobj[iPane])->lpObject, &ot);
                if (ot == OT_LINK)
                {
                    if (ghwndError == ghwndFrame)
                    {
                        if (DialogBoxAfterBlock (
                            MAKEINTRESOURCE(DTINVALIDLINK), ghwndError,
                            fnInvalidLink) == IDD_CHANGE)
                            PostMessage(ghwndFrame, WM_COMMAND, IDM_LINKS, 0L);
                    }
                    else
                    {
                        // Failed, but already in Link Properties!!
                        ErrorMessage(E_FAILED_TO_UPDATE_LINK);
                    }

                    return FALSE;
                }
            }

            break;

        default:
            break;
    }

    return TRUE;
}



/* CallBack() - Routine that OLE client DLL calls when events occur.
 *
 * This routine is called when the object has been updated and may
 * need to be redisplayed; if asynchronous operations have completed;
 * and if the application allows the user to cancel long operations
 * (like Painting, or other asynchronous operations).
 */
INT CALLBACK
CallBack(
    LPOLECLIENT lpclient,
    OLE_NOTIFICATION flags,
    LPOLEOBJECT lpObject
    )
{
    INT iPane;

    switch (flags)
    {
        case OLE_CLOSED:
            if (gfInvisible)
                PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
            else
                SetFocus(ghwndError);

            break;

        case OLE_SAVED:
        case OLE_CHANGED:
            {
                //
                // The OLE libraries make sure that we only receive
                // update messages according to the Auto/Manual flags.
                //
                iPane = (gpty[CONTENT] == PICTURE
                    && ((LPPICT)glpobj[CONTENT])->lpObject == lpObject);

                if (gpty[iPane] == PICTURE)
                {
                    ((LPPICT)glpobj[iPane])->fNotReady = FALSE;
                    InvalidateRect(ghwndPane[iPane], NULL, TRUE);
                    SetRect(&(((LPPICT)glpobj[iPane])->rc), 0, 0, 0, 0);
                    Dirty();
                }

                break;
            }

        case OLE_RELEASE:
            {
                if (gcOleWait)
                    gcOleWait--;
                else
                    ErrorMessage(E_UNEXPECTED_RELEASE);

                switch (Error(OleQueryReleaseError(lpObject)))
                {
                    case FALSE:
                        switch (OleQueryReleaseMethod(lpObject))
                        {
                            case OLE_SETUPDATEOPTIONS:
                                iPane = (gpty[CONTENT] == PICTURE
                                    && ((LPPICT)glpobj[CONTENT])->lpObject ==
                                    lpObject);

                                PostMessage(ghwndPane[iPane], WM_COMMAND,
                                    IDM_LINKDONE, 0L);

                            default:
                                break;
                        }

                        break;

                    case TRUE:
                        switch (OleQueryReleaseMethod(lpObject))
                        {
                            case OLE_DELETE:
                                ErrorMessage(E_FAILED_TO_DELETE_OBJECT);
                                break;

                            case OLE_LOADFROMSTREAM:
                                ErrorMessage(E_FAILED_TO_READ_OBJECT);
                                break;

                            case OLE_LNKPASTE:
                                ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
                                break;

                            case OLE_ACTIVATE:
                                ErrorMessage(E_FAILED_TO_LAUNCH_SERVER);
                                break;

                            case OLE_UPDATE:
                                ErrorMessage(E_FAILED_TO_UPDATE);
                                break;

                            case OLE_RECONNECT:
                                ErrorMessage(E_FAILED_TO_RECONNECT_OBJECT);
                                break;
                        }

                        break;
                }

                break;
            }

        case OLE_QUERY_RETRY:
            // if lpObject doesn't match any one of these 4 objects, it means
            // that PicDelete() has been called on lpObject, so there is no
            // point in continueing the RETRIES.
            // See PicDelete() code for more info.
            if ((glpobj[CONTENT]
                && lpObject == ((LPPICT)glpobj[CONTENT])->lpObject)
                || (glpobj[APPEARANCE]
                && lpObject == ((LPPICT) glpobj[APPEARANCE])->lpObject)
                || (glpobjUndo[CONTENT]
                && lpObject == ((LPPICT) glpobjUndo[CONTENT])->lpObject)
                || (glpobjUndo[APPEARANCE]
                && lpObject == ((LPPICT) glpobjUndo[APPEARANCE])->lpObject))
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }

        case OLE_QUERY_PAINT:
            return TRUE;

        default:
            break;
    }

    return 0;
}



/* WaitForObject() - Waits, dispatching messages, until the object is free.
 *
 * If the object is busy, spin in a dispatch loop.
 */
VOID
WaitForObject(
    LPOLEOBJECT lpObject
    )
{
    while (OleQueryReleaseStatus(lpObject) == OLE_BUSY)
        ProcessMessage();
}



/* PicSetUpdateOptions() - Sets the update options of the object.
 *
 * Returns:  TRUE if the command completed synchronously.
 */
BOOL
PicSetUpdateOptions(
    LPPICT lppict,
    UINT idCmd
    )
{
    OLESTATUS olestat = OLE_ERROR_GENERIC;

    olestat = OleSetLinkUpdateOptions(
        lppict->lpObject,
        (idCmd == IDD_AUTO) ? oleupdate_always : oleupdate_oncall);

    if (Error(olestat))
        ErrorMessage(E_FAILED_TO_UPDATE_LINK);

    return (olestat == OLE_OK);
}



/* PicReadFromNative() - Reads an object from the pointer lpstr.
 *
 * SIDE EFFECT:  Advances the pointer past the object.
 */
LPPICT
PicReadFromNative(
    LPSTR *lplpstr,
    LPSTR lpstrName
    )
{
    LPOLEOBJECT lpObject;
    LPSTR lpstrStart;
    RECT rcObject;
    WORD w;

    // Save current position of file pointer
    lpstrStart = *lplpstr;
    SetFile(SOP_MEMORY, 0, lplpstr);

    // Load the new object
    if (Error(OleLoadFromStream((LPOLESTREAM)glpStream, gszProtocol, glpclient,
        glhcdoc, lpstrName, &lpObject)))
    {
        // Reset file pointer, and try again
        *lplpstr = lpstrStart;
        SetFile(SOP_MEMORY, 0, lplpstr);

        // Read it with the "Static" protocol
        if (Error(OleLoadFromStream((LPOLESTREAM)glpStream, gszSProtocol,
            glpclient, glhcdoc, lpstrName, &lpObject)))
            return NULL;
    }

    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.left = (INT)w;
    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.top = (INT)w;
    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.right = (INT)w;
    MemRead(lplpstr, (LPSTR)&w, sizeof(WORD));
    rcObject.bottom = (INT)w;

    // Create a window at the right place, and display the object
    return PicCreate(lpObject, &rcObject);
}



/* PicWriteToNative() - Writes an object to memory.
 *
 * SIDE EFFECT:  Moves pointer to end of written object
 */
DWORD
PicWriteToNative(
    LPPICT lppict,
    LPOLEOBJECT lpObject,
    LPSTR *lplpstr
    )
{
    DWORD cb = 0L;
    WORD w;

    // Save the object
    SetFile(SOP_MEMORY, 0, lplpstr);

    if (Error(OleSaveToStream(lpObject, (LPOLESTREAM)glpStream)))
        goto Done;

    cb += gcbObject;

    if (lplpstr)
    {
        w = (WORD)lppict->rc.left;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        w = (WORD)lppict->rc.top;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        w = (WORD)lppict->rc.right;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
        w = (WORD)lppict->rc.bottom;
        MemWrite(lplpstr, (LPSTR)&w, sizeof(WORD));
    }

    cb += (DWORD)(4 * sizeof(WORD));

Done:
    return cb;
}



/* Hourglass() - Puts up the hourglass as needed.
 */
VOID
Hourglass(
    BOOL fOn
    )
{
    static HCURSOR hcurSaved = NULL;    // Cursor saved when hourglass is up
    static UINT cWait = 0;              // Number of "Hourglass"es up

    if (fOn)
    {
        if (!(cWait++))
            hcurSaved = SetCursor(ghcurWait);
    }
    else
    {
        if (!(--cWait) && hcurSaved)
        {
            SetCursor(hcurSaved);
            hcurSaved = NULL;
        }
    }
}



VOID
PicActivate(
    LPPICT lppict,
    UINT idCmd
    )
{
    DWORD ot;
    DWORD ot2;
    RECT rc;
    INT iPane;
    BOOL bAlreadyOpen = FALSE;

    iPane = (lppict == glpobj[CONTENT]);
    OleQueryType(lppict->lpObject, &ot);
    if (ot != OT_STATIC)
    {
        // Compute the window dimensions
        GetClientRect(ghwndPane[iPane], &rc);
        bAlreadyOpen = (OleQueryOpen(lppict->lpObject) == OLE_OK);

        // Open the object
        if (Error(OleActivate(lppict->lpObject,
            (idCmd == IDD_PLAY ? OLE_PLAY : OLE_EDIT),
            TRUE, TRUE, ghwndPane[iPane], &rc)))
        {
            ErrorMessage(E_FAILED_TO_LAUNCH_SERVER);
            goto errRtn;
        }
        else
        {
            WaitForObject(lppict->lpObject);
            if (!glpobj[iPane])
                goto errRtn;

            OleQueryType(lppict->lpObject, &ot2);
            if (ot2 == OT_EMBEDDED)
                Error(OleSetHostNames(lppict->lpObject, gszAppClassName,
                    (iPane == CONTENT) ? szContent : szAppearance));
        }

        return;
    }
    else
    {
        ErrorMessage(W_STATIC_OBJECT);
    }

errRtn:
    if (gfInvisible && !bAlreadyOpen)
        PostMessage(ghwndFrame, WM_SYSCOMMAND, SC_CLOSE, 0L);
}



VOID
PicUpdate(
    LPPICT lppict
    )
{
    DWORD ot;

    OleQueryType(lppict->lpObject, &ot);
    if (ot == OT_LINK)
    {
        if (Error(OleUpdate(lppict->lpObject)))
            ErrorMessage(E_FAILED_TO_UPDATE);
    }
}



VOID
PicFreeze(
    LPPICT lppict
    )
{
    DWORD ot;
    LPOLEOBJECT lpObject;
    INT iPane;

    iPane = (lppict == glpobj[CONTENT]);
    OleQueryType(lppict->lpObject, &ot);
    if (ot != OT_STATIC)
    {
        if (Error(OleObjectConvert(lppict->lpObject, gszSProtocol, glpclient,
             glhcdoc, gszCaption[iPane], &lpObject)))
        {
            ErrorMessage(E_FAILED_TO_FREEZE);
            return;
        }

        if (Error(OleDelete(lppict->lpObject)))
            ErrorMessage(E_FAILED_TO_DELETE_OBJECT);

        lppict->lpObject = lpObject;

        // Redraw the list box contents
        PostMessage(ghwndError, WM_REDRAW, 0, 0L);
    }
}



VOID
PicChangeLink(
    LPPICT lppict
    )
{
    HANDLE hData;
    OLESTATUS olestat;

    // Change the link information
    olestat = OleGetData(lppict->lpObject, gcfLink, &hData);
    if (!Error(olestat) && hData)
    {
        hData = OfnGetNewLinkName(ghwndError, hData);
        if (hData && !Error(OleSetData(lppict->lpObject, gcfLink, hData)))
            PostMessage(ghwndError, WM_REDRAW, 0, 0L);
    }
}



/* PicCopy() - Puts an object onto the clipboard.
 *
 * Returns:  TRUE iff successful.
 */
BOOL
PicCopy(
    LPPICT lppict
    )
{
    BOOL fSuccess = FALSE;

    // If we can't open the clipboard, fail
    if (!lppict->lpObject || !OpenClipboard(ghwndFrame))
        return FALSE;

    // Empty the clipboard
    EmptyClipboard();

    // Successful if we managed to copy to the clipboard
    fSuccess = !Error(OleCopyToClipboard(lppict->lpObject));

    CloseClipboard();
    return fSuccess;
}



/* PicGetBounds() -
 */
static VOID
PicGetBounds(
    LPOLEOBJECT lpObject,
    LPRECT lprc
    )
{
    if (IsRectEmpty(lprc))
    {
        switch (OleQueryBounds(lpObject, lprc))
        {
            case OLE_WAIT_FOR_RELEASE:
                Hourglass(TRUE);
                gcOleWait++;
                WaitForObject(lpObject);
                Hourglass(FALSE);

            case OLE_OK:
                // Map from HIMETRIC into screen coordinates
                lprc->right = MulDiv(giXppli,
                    lprc->right - lprc->left, HIMETRIC_PER_INCH);
                lprc->bottom = MulDiv (giYppli,
                    lprc->top - lprc->bottom, HIMETRIC_PER_INCH);
                lprc->left = 0;
                lprc->top = 0;

            default:
                break;
        }
    }
}


/* PicSaveUndo() - Saves a copy of the object for Undo.
 */
VOID
PicSaveUndo(
    LPPICT lppict
    )
{
    INT iPane = (lppict == glpobj[CONTENT]);
    LPOLEOBJECT lpObject;

    // Clone the object
    if (Error(OleClone(lppict->lpObject, glpclient, glhcdoc, gszTemp, &lpObject))
        || !lpObject)
    {
        ErrorMessage(W_FAILED_TO_CLONE_UNDO);
    }
    else
    {
        // Save the undo, delete the prior Undo
        DeletePane(iPane, FALSE);
        OleRename(lpObject, gszCaption[iPane]);
        glpobj[iPane] = PicCreate(lpObject, &(lppict->rc));
        gpty[iPane] = PICTURE;

        if (iPane == CONTENT)
            EnableWindow(ghwndPict, TRUE);
    }
}



/* PicPaste() - Creates object from a file
 */
LPPICT
PicFromFile(
    BOOL fEmbedded,
    LPSTR szFile
    )
{
    HRESULT hr;
    LPOLEOBJECT lpObject;

    Hourglass(TRUE);

    // Don't replace the current object unless we're successful
    if (fEmbedded)
    {
        hr = OleCreateFromFile(gszProtocol, glpclient, NULL, szFile,
                    glhcdoc, gszCaption[CONTENT], &lpObject, olerender_draw, 0);
    }
    else
    {
        hr = OleCreateLinkFromFile(gszProtocol, glpclient, NULL, szFile,
                    NULL, glhcdoc, gszCaption[CONTENT], &lpObject, olerender_draw, 0);
    }

    Hourglass(FALSE);

    if (FAILED(hr))
        return NULL;

    WaitForObject(lpObject);

    return PicCreate(lpObject, NULL);
}



LPOLECLIENT
PicCreateClient(
    PCALL_BACK fnCallBack,
    LPOLECLIENTVTBL lpclivtbl
    )
{
    LPOLECLIENT pclient;
    if (!(pclient = (LPOLECLIENT)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENT))))
        return NULL;

    pclient->lpvtbl = lpclivtbl;
    pclient->lpvtbl->CallBack = fnCallBack;

    return pclient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\stream.c ===
/* stream.c - OLE stream I/O routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"


static LPSTR *glplpstr;
static STREAMOP gsop;



/* SetFile() - Set the file to be written.
 */
VOID
SetFile(
    STREAMOP sop,
    INT fh,
    LPSTR *lplpstr
    )
{
    switch (gsop = sop)
    {
        case SOP_FILE:
            glpStream->fh = fh;
            break;

        case SOP_MEMORY:
            gcbObject = 0L;
            glplpstr = lplpstr;
            break;
    }
}



/* ReadStream() - Read bytes from memory, from a file, or just count them.
 */
DWORD
ReadStream(
    LPAPPSTREAM lpStream,
    LPSTR lpstr,
    DWORD cb
    )
{
    switch (gsop)
    {
        case SOP_FILE:
            return _lread(lpStream->fh, lpstr, cb);
            break;

        case SOP_MEMORY:
            gcbObject += cb;

            if (glplpstr)
                MemRead(glplpstr, lpstr, cb);

            break;
    }

    return cb;
}



/* PosStream() - Reset the position of the file pointer.
 *
 * Note:  This is never used; luckily, or it would mess up the count.
 */
DWORD
PosStream(
    LPAPPSTREAM lpStream,
    LONG pos,
    INT iorigin)
{
    return _llseek(lpStream->fh, pos, iorigin);
}



/* WriteStream() - Write bytes to memory, to a file, or just count them.
 */
DWORD
WriteStream(
    LPAPPSTREAM lpStream,
    LPSTR lpstr,
    DWORD cb
    )
{
    switch (gsop)
    {
        case SOP_FILE:
            return _lwrite(lpStream->fh, lpstr, cb);

        case SOP_MEMORY:
            gcbObject += cb;

            if (glplpstr)
                MemWrite(glplpstr, lpstr, cb);

            break;
    }

    return cb;
}



/********************* Memory read/write functions ********************/
/* MemRead() - Read bytes from the memory (stream).
 */
DWORD
MemRead(
    LPSTR *lplpStream,
    LPSTR lpItem,
    DWORD dwSize
    )
{
    DWORD cb;
    CHAR *hpDest = lpItem;
    CHAR *hpSrc = *lplpStream;

    for (cb = dwSize; cb; cb--)
        *hpDest++ = *hpSrc++;

    *lplpStream = hpSrc;

    return dwSize;
}



/* MemWrite() - Write bytes to the memory (stream).
 */
DWORD
MemWrite(
    LPSTR *lplpStream,
    LPSTR lpItem,
    DWORD dwSize
    )
{
    DWORD cb;
    CHAR *hpDest = *lplpStream;
    CHAR *hpSrc = lpItem;

    for (cb = dwSize; cb; cb--)
        *hpDest++ = *hpSrc++;

    *lplpStream = hpDest;

    return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\virtable.c ===
/* virtable.c - This module contains the OLE virtual table/private routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"
#include "dialogs.h"


//#define  OLESVR_SUPPORT     /* enable support for OLE server files */


static CHAR szLink[] = "/Link";             // Appended to end of link packages



/**************************** Server functions *****************************/
/* SrvrOpen() - Wraps a filename that is passed into a command line.
 */
OLESTATUS
SrvrOpen(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc
    )
{
    LPSAMPDOC lpdoc;
    LPSTR lpstrLink = NULL;
    OLESTATUS retval = OLE_OK;
    LPOLEOBJECT lpObject = NULL;

    DPRINT("pkg: SrvrOpen");

    if (lpstrLink = Contains(lpdocname, szLink))
        *lpstrLink = '\0';

    if (!(lpdoc = (LPSAMPDOC)CreateDocFromFile(
        (LPSAMPSRVR)lpolesrvr, lhdoc, lpdocname)))
        return OLE_ERROR_GENERIC;

    // Generate a command line
    BringWindowToTop(ghwndPane[CONTENT]);

    if (gpty[CONTENT])
        DeletePane(CONTENT, TRUE);

#ifdef OLESVR_SUPPORT
    if (IsOleServerDoc (lpdocname))
    {
        gpty[CONTENT] = PICTURE;

        if (lpstrLink)
        {
            if (Error(OleCreateLinkFromFile(gszProtocol, glpclient, NULL,
                lpdocname, NULL, glhcdoc, gszCaption[CONTENT], &lpObject,
                olerender_draw, 0)))
                retval = OLE_ERROR_OPEN;
        }
        else
        {
            if (Error(OleCreateFromFile(gszProtocol, glpclient, NULL, lpdocname,
                glhcdoc, gszCaption[CONTENT], &lpObject, olerender_draw, 0)))
                retval = OLE_ERROR_OPEN;
        }

        if (retval == OLE_OK)
        {
            glpobj[CONTENT] = PicCreate(lpObject, NULL);
            ((LPPICT)glpobj[CONTENT])->fNotReady = TRUE;
            OleBlockServer(((LPSAMPSRVR)lpolesrvr)->lhsrvr);
            gfBlocked = TRUE;
        }
        else
        {
            DeregisterDoc();
            return retval;
        }
    }
    else
    {
#endif
        if (lpstrLink)
        {
            if (glpobj[CONTENT] = CmlCreateFromFilename(lpdocname, TRUE))
                gpty[CONTENT] = CMDLINK;
        }
        else
        {
            if (glpobj[CONTENT] = (LPVOID)EmbCreate(lpdocname))
                gpty[CONTENT] = PEMBED;
        }

        if (glpobj[CONTENT] == NULL)
            retval = OLE_ERROR_OPEN;

#ifdef OLESVR_SUPPORT
    }
#endif

    // If no appearance pane (which should be always), try to make one
    if (!gpty[APPEARANCE])
    {
        if (glpobj[APPEARANCE] = IconCreateFromFile(lpdocname))
        {
            gpty[APPEARANCE] = ICON;
            InvalidateRect(ghwndPane[APPEARANCE], NULL, TRUE);
        }
    }

    // Restore the character we so rudely mashed
    if (lpstrLink)
        *lpstrLink = szLink[0];

    // Save the document and change the menus
    InitEmbedded(FALSE);
    *lplpoledoc = (LPOLESERVERDOC)lpdoc;

    return retval;
}



/* SrvrCreate() - Create a new (embedded) object.
 */
OLESTATUS
SrvrCreate(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpclassname,
    LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc
    )
{

    DPRINT("pkg: SrvrCreate");

    // Initialize the new image
    InitFile();

    if (!(*lplpoledoc = (LPOLESERVERDOC)CreateNewDoc((LPSAMPSRVR)lpolesrvr,
        lhdoc, lpdocname)))
        return OLE_ERROR_GENERIC;

    InitEmbedded(TRUE);

    return OLE_OK;
}



/* SrvrCreateFromTemplate() - Create a new (embedded) object from a file.
 */
OLESTATUS
SrvrCreateFromTemplate(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpclassname,
    LPSTR lpdocname,
    LPSTR lptemplatename,
    LPOLESERVERDOC *lplpoledoc
    )
{
    LPSAMPDOC lpdoc;

    DPRINT("pkg: SrvrCreateFromTemplate");

    if (!(lpdoc = (LPSAMPDOC)CreateDocFromFile((LPSAMPSRVR)lpolesrvr, lhdoc,
        lptemplatename)))
        return OLE_ERROR_GENERIC;

    // Save the document and change the menus
    *lplpoledoc = (LPOLESERVERDOC)lpdoc;
    InitEmbedded(FALSE);

    StringCchCopy(szUntitled, ARRAYSIZE(szUntitled), lpdocname);
    SetTitle(TRUE);
    return OLE_OK;
}



/* SrvrEdit() - Open an (embedded) object for editing.
 */
OLESTATUS
SrvrEdit(
    LPOLESERVER lpolesrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpclassname,
    LPSTR lpdocname,
    LPOLESERVERDOC *lplpoledoc
    )
{
    DPRINT("pkg: SrvrEdit");

    if (!(*lplpoledoc = (LPOLESERVERDOC)CreateNewDoc((LPSAMPSRVR)lpolesrvr,
        lhdoc, lpdocname)))
        return OLE_ERROR_MEMORY;

    InitEmbedded(FALSE);

    return OLE_OK;
}



/* SrvrExit() - Called to cause the OLE server to be revoked.
 */
OLESTATUS
SrvrExit(
    LPOLESERVER lpolesrvr
    )
{
    DPRINT("pkg: SrvrExit");
    DeleteServer((LPSAMPSRVR)lpolesrvr);
    return OLE_OK;

}



/* SrvrRelease() - Called so that the server memory can be freed.
 *
 * Note:    This call may occur in isolation without a SrvrExit()
 *          call.  If this occurs, we still revoke the server.
 */
OLESTATUS
SrvrRelease(
    LPOLESERVER lpolesrvr
    )
{
    DPRINT("pkg: SrvrRelease");
    if (gvlptempdoc)
        return OLE_OK;

    if (gfInvisible || (gfEmbeddedFlag && !gfDocExists))
        DeleteServer((LPSAMPSRVR)lpolesrvr);

    if (ghServer)
        DestroyServer();

    return OLE_OK;
}



/* SrvrExecute() - Called to execute DDE commands
 */
OLESTATUS
SrvrExecute(
    LPOLESERVER lpolesrvr,
    HANDLE hCmds
    )
{
    DPRINT("pkg: SrvrExecute");
    return OLE_ERROR_PROTOCOL;
}



/************************** Document functions *************************/
/* DocSave() - OLE callback to save the document.
 */
OLESTATUS
DocSave(
    LPOLESERVERDOC lpoledoc
    )
{
    DPRINT("pkg: DocSave");
    return OLE_OK;
}



/* DocClose() - OLE callback when the document is to be closed.
 *
 * This command has no additional effects; since we are not an MDI application
 * we don't close the child window.  The window is destroyed when the server
 * function "Release" is called.
 */
OLESTATUS
DocClose(
    LPOLESERVERDOC lpoledoc
    )
{
    DPRINT("pkg: DocClose");
    DeregisterDoc();
    return OLE_OK;
}



/* DocRelease() - Deallocate document memory.
 */
OLESTATUS
DocRelease(
    LPOLESERVERDOC lpoledoc
    )
{
    LPSAMPDOC lpdoc = (LPSAMPDOC)lpoledoc;
    HANDLE hdoc;

    DPRINT("pkg: DocRelase");
    if (lpdoc)
    {
        if (!gfDocCleared)
        {
            glpdoc = NULL;
            DeregisterDoc();
        }

        GlobalDeleteAtom(lpdoc->aName);
        LocalUnlock(hdoc = lpdoc->hdoc);
        LocalFree(hdoc);
        gfDocExists = FALSE;
    }

    return OLE_OK;
}



/* DocGetObject() - Create a new object within the current document
 */
OLESTATUS
DocGetObject(
    LPOLESERVERDOC lpoledoc,
    LPSTR lpitemname,
    LPOLEOBJECT *lplpoleobject,
    LPOLECLIENT lpoleclient
    )
{
    LPSAMPITEM lpitem;

    DPRINT("pkg: DocGetObject");

    //
    // Always create a new item in this case, it's much easier than
    // worrying about the sub-rectangle bitmap.
    //
    lpitem = CreateNewItem((LPSAMPDOC)lpoledoc);
    lpitem->lpoleclient = lpoleclient;
    if (*lpitemname)
    {
        lpitem->aName = AddAtom(lpitemname);
    }
    else
    {
        lpitem->aName = 0;
    }

    if (!(*lplpoleobject = (LPOLEOBJECT)AddItem(lpitem)))
        return OLE_ERROR_GENERIC;

    return OLE_OK;
}



/* DocSetHostNames() - Sets the title bar to the correct document name.
 *
 * Note:    The format is "<lpclientName> <app name> - <lpdocName>".
 */
OLESTATUS
DocSetHostNames(
    LPOLESERVERDOC lpoledoc,
    LPSTR lpclientName,
    LPSTR lpdocName
    )
{
    DPRINT("pkg: DocSetHostnames");
    StringCchCopy(szUntitled, ARRAYSIZE(szUntitled), lpdocName);
    StringCchCopy(gszClientName, ARRAYSIZE(gszClientName), lpclientName);

    SetTitle(TRUE);
    return OLE_OK;
}



/* DocSetDocDimensions() - OLE callback to change the document dimensions.
 *
 * Note:    This command is unsupported.  It is the client application's
 *          responsibility to report errors (as needed).
 */
OLESTATUS
DocSetDocDimensions(
    LPOLESERVERDOC lpoledoc,
    LPRECT lprc
    )
{
    DPRINT("pkg: DocSetDocDimensions");
    return OLE_ERROR_GENERIC;
}



/* DocSetColorScheme() - OLE callback to change the document colors.
 *
 * Note:    This command is unsupported.  It is the client application's
 *          responsibility to report errors (as needed).
 */
OLESTATUS
DocSetColorScheme(
    LPOLESERVERDOC lpoledoc,
    LPLOGPALETTE lppal
    )
{
    DPRINT("pkg: DocSetColorScheme");
    return OLE_ERROR_GENERIC;
}



/* DocExecute() - Called to execute DDE commands
 */
OLESTATUS
DocExecute(
    LPOLESERVERDOC lpoledoc,
    HANDLE hCmds
    )
{
    DPRINT("pkg: DocExecute");
    return OLE_ERROR_PROTOCOL;
}



/**************************** Item functions ***************************/
/* ItemDelete() - Free memory associated with the current item.
 */
OLESTATUS
ItemDelete(
    LPOLEOBJECT lpoleobject
    )
{
    DPRINT("pkg: ItemDelete");
    DeleteItem((LPSAMPITEM)lpoleobject);

    return OLE_OK;              /* Add error checking later */
}



/* ItemGetData() - Used by the client to obtain the item data.
 */
OLESTATUS
ItemGetData(
    LPOLEOBJECT lpoleobject,
    OLECLIPFORMAT cfFormat,
    LPHANDLE lphandle
    )
{

    DPRINT("pkg: ItemGetData");
    if ((gpty[CONTENT] == PICTURE) && ((LPPICT)glpobj[CONTENT])->fNotReady)
        return OLE_BUSY;

    if (cfFormat == gcfNative)
    {
        if (*lphandle = GetNative(FALSE))
            return OLE_OK;

    }
    else if (cfFormat == CF_METAFILEPICT)
    {
        if (*lphandle = GetMF())
            return OLE_OK;

    }
    else if (cfFormat == gcfOwnerLink)
    {
        if (*lphandle = GetLink())
            return OLE_OK;
    }

    // Clipboard format not supported
    return OLE_ERROR_GENERIC;
}



/* ItemSetData() - Used by the client to paste data into a server.
 *
 * Read in the embedded object data in Native format.  This will
 * not be called unless we are editing the correct document.
 */
OLESTATUS
ItemSetData(
    LPOLEOBJECT lpoleobject,
    OLECLIPFORMAT cfFormat,
    HANDLE hdata
    )
{
    LPSAMPITEM lpitem = (LPSAMPITEM)lpoleobject;

    DPRINT("pkg: ItemSetData");
    if (cfFormat == gcfNative && !PutNative(hdata))
    {
        SendMessage(ghwndFrame, WM_COMMAND, IDM_NEW, 0L);
        GlobalFree(hdata);

        return OLE_ERROR_GENERIC;
    }

    GlobalFree(hdata);

    return OLE_OK;
}



/* ItemDoVerb() - Play/Edit the object.
 *
 * This routine is called when the user tries to run an object that
 * is wrapped by the packager.
 */
OLESTATUS
ItemDoVerb(
    LPOLEOBJECT lpoleobject,
    UINT wVerb,
    BOOL fShow,
    BOOL fActivate
    )
{

    DPRINT("pkg: ItemDoVerb");
    switch (wVerb)
    {
        case OLE_PLAY:
            if (fShow)
                return (*(lpoleobject->lpvtbl->Show))(lpoleobject, fActivate);
            break;

        case OLE_EDIT:
            if (fShow && fActivate)
            {
                if (gfInvisible)
                {
                    ShowWindow(ghwndFrame, gnCmdShowSave);
                    gfInvisible = FALSE;
                }

                // If iconic, restore the window; then give it the focus.
                if (IsIconic(ghwndFrame))
                    SendMessage(ghwndFrame, WM_SYSCOMMAND, SC_RESTORE, 0L);

                BringWindowToTop(ghwndFrame);
            }

        default:
            break;
    }

    return OLE_OK;
}



/* ItemShow() - Show the item.
 *
 * This routine is called when the user tries to edit an object in a
 * client application, and the server is already active.
 */
OLESTATUS
ItemShow(
    LPOLEOBJECT lpoleobject,
    BOOL fActivate
    )
{
    HWND hwndItem;

    DPRINT("pkg: ItemShow");
    if (fActivate
        && (hwndItem = GetTopWindow(ghwndFrame))
        && (gpty[(hwndItem == ghwndPane[CONTENT])] == NOTHING))
    {
        //
        //  Lets assume that in this case the client has
        //  attempted an InsertObject operation with
        //  the Package class. (5.30.91) v-dougk
        //
        if (gfInvisible)
        {
            ShowWindow(ghwndFrame, SW_SHOW);
            gfInvisible = FALSE;
        }

        BringWindowToTop(ghwndFrame);
    }
    else
    {
        PostMessage(hwndItem, WM_COMMAND, IDD_PLAY, 0L);
    }

    return OLE_OK;
}



/* ItemSetBounds() - Set the item's size.
 *
 * Note:    This command is not supported.
 */
OLESTATUS
ItemSetBounds(
    LPOLEOBJECT lpoleobject,
    LPRECT lprc
    )
{
    DPRINT("pkg: ItemSetBounds");
    return OLE_ERROR_GENERIC;
}



/* ItemSetTargetDevice() - Changes the target device for item display.
 *
 * Note:    This command is not supported.
 */
OLESTATUS
ItemSetTargetDevice(
    LPOLEOBJECT lpoleobject,
    HANDLE h
    )
{
    DPRINT("pkg: ItemSetTargetDevice");
    if (h)
        GlobalFree(h);

    return OLE_ERROR_GENERIC;
}



/* ItemEnumFormats() - Enumerate formats which are renderable.
 *
 * This is called by the OLE libraries to get a format for screen display.
 * Currently, only Metafile and Native are supported.
 */
OLECLIPFORMAT
ItemEnumFormats(
    LPOLEOBJECT lpobject,
     OLECLIPFORMAT cfFormat
     )
{
    DPRINT("pkg: ItemEnumFormats");
    if (!cfFormat)
        return CF_METAFILEPICT;

    if (cfFormat == CF_METAFILEPICT)
        return gcfNative;

    return 0;
}



/* ItemQueryProtocol() - Tells whether the given protocol is supported.
 *
 * Returns:  lpoleobject iff the protocol is "StdFileEditing".
 */
LPVOID
ItemQueryProtocol(
    LPOLEOBJECT lpoleobject,
    LPSTR lpprotocol
    )
{
    DPRINT("pkg: ItemQueryProtocol");
    return (!lstrcmpi(lpprotocol, "StdFileEditing") ? lpoleobject : NULL);
}



/* ItemSetColorScheme() - Denotes the palette to be used for item display.
 *
 * Note:    This command is not supported.
 */
OLESTATUS
ItemSetColorScheme(
    LPOLEOBJECT lpoleobject,
    LPLOGPALETTE lppal
    )
{
    DPRINT("pkg: ItemSetColorScheme");
    return OLE_ERROR_GENERIC;
}



BOOL IsOleServerDoc(LPSTR lpdocname)
{
    // 06/11/02 The OLE code path does not execute in XPSP1.  Further, we want to ensure that we are going
    // through the ShellExecute path so that we get the new ShellExecute security warning for
    // the termporary internet directory.  Therefore, we will always return FALSE here, a least for now.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\pbrush\pbrush.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "pbrush.h"

extern int _cdecl ShellMessageBox(HINSTANCE hAppInst, HWND hWnd, LPCSTR
        lpcText, LPCSTR lpcTitle, UINT fuStyle, ...);
// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    return WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

}


const char szFile[] = "mspaint.exe";

//---------------------------------------------------------------------------
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    ShellExecute(HWND_DESKTOP, NULL, szFile, lpCmdLine, NULL, nCmdShow);
    ExitProcess(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\pbrush\pbrush.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#include <windows.h>
#include <shellapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\packager\server.c ===
/* server.c - This module contains the OLE server worker/public routines.
 *
 * Created by Microsoft Corporation.
 */

#include "packager.h"


#define CBLINKMAX           260


/*
 * This server only supports one document per instance.  The items are
 * just rectangles over the document, possibly overlapping.
 */

static LHCLIENTDOC lhClipDoc = 0;
static OLESERVERDOCVTBL vdocvtbl;           // Document virtual table
static OLEOBJECTVTBL vitemvtbl;             // Item virtual table
static OLESERVERVTBL vsrvrvtbl;             // Server virtual table
static LPSAMPITEM vlpitem[CITEMSMAX];       // Pointers to active OLE items
static INT cItems = 0;                      // Number of active OLE items
static CHAR szClip[] = "Clipboard";


static VOID DeleteDoc(LPSAMPDOC lpdoc);
static BOOL SendItemChangeMsg(LPSAMPITEM lpitem, UINT options);
static INT FindItem(LPSAMPITEM lpitem);



/************ Server initialization and termination routines **********/
/* InitServer() - Initializes the OLE server
 */
BOOL
InitServer(
    VOID
    )
{
    // Allocate the server block
    if (!(ghServer = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(PBSRVR)))
        || !(glpsrvr = (LPSAMPSRVR)LocalLock(ghServer)))
        goto errRtn;

    // Initialize the server, document, and item virtual tables
    vsrvrvtbl.Open                  = SrvrOpen;
    vsrvrvtbl.Create                = SrvrCreate;
    vsrvrvtbl.CreateFromTemplate    = SrvrCreateFromTemplate;
    vsrvrvtbl.Edit                  = SrvrEdit;
    vsrvrvtbl.Exit                  = SrvrExit;
    vsrvrvtbl.Release               = SrvrRelease;
    vsrvrvtbl.Execute               = SrvrExecute;

    vdocvtbl.Save                   = DocSave;
    vdocvtbl.Close                  = DocClose;
    vdocvtbl.SetHostNames           = DocSetHostNames;
    vdocvtbl.SetDocDimensions       = DocSetDocDimensions;
    vdocvtbl.GetObject              = DocGetObject;
    vdocvtbl.Release                = DocRelease;
    vdocvtbl.SetColorScheme         = DocSetColorScheme;
    vdocvtbl.Execute                = DocExecute;

    vitemvtbl.QueryProtocol         = ItemQueryProtocol;
    vitemvtbl.Release               = ItemDelete;
    vitemvtbl.Show                  = ItemShow;
    vitemvtbl.DoVerb                = ItemDoVerb;
    vitemvtbl.GetData               = ItemGetData;
    vitemvtbl.SetData               = ItemSetData;
    vitemvtbl.SetTargetDevice       = ItemSetTargetDevice;
    vitemvtbl.SetBounds             = ItemSetBounds;
    vitemvtbl.EnumFormats           = ItemEnumFormats;
    vitemvtbl.SetColorScheme        = ItemSetColorScheme;


    // Try to register the server
    glpsrvr->olesrvr.lpvtbl = &vsrvrvtbl;
    if (Error(OleRegisterServer(gszAppClassName, (LPOLESERVER)glpsrvr,
        (LONG_PTR * )&glpsrvr->lhsrvr, ghInst, OLE_SERVER_MULTI)))
        goto errRtn;

    // Initialize the client name
    lstrcpy(gszClientName, "");

    return TRUE;

errRtn:
    ErrorMessage(E_FAILED_TO_REGISTER_SERVER);

    // If we failed, clean up
    if (glpsrvr)
    {
        LocalUnlock(ghServer);
        glpsrvr = NULL;
    }

    if (ghServer)
        LocalFree(ghServer);

    ghServer = NULL;

    return FALSE;
}



/* DeleteServer() - Revokes the OLE server.
 */
VOID
DeleteServer(
    LPSAMPSRVR lpsrvr
    )
{
    if (gfServer)
    {
        gfServer = FALSE;
        OleRevokeServer(lpsrvr->lhsrvr);
    }
}



/* DestroyServer() - Deallocates the OLE server.
 */
VOID
DestroyServer(
    VOID
    )
{
    if (ghServer)
    {
        // Release the server virtual table and info
        LocalUnlock(ghServer);
        LocalFree(ghServer);
        ghServer = NULL;

        // Destroy the window only when we're all through
        DestroyWindow(ghwndFrame);
        gfServer = FALSE;
    }
}



/********************* Document support functions ********************/
/* InitDoc() - Initialize and register the document with the OLE library.
 */
LPSAMPDOC
InitDoc(
    LPSAMPSRVR lpsrvr,
    LHSERVERDOC lhdoc,
    LPSTR lptitle
    )
{
    HANDLE hdoc = NULL;
    LPSAMPDOC lpdoc = NULL;

    if (!(hdoc = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(PBDOC)))
        || !(lpdoc = (LPSAMPDOC)LocalLock(hdoc)))
        goto errRtn;

    lpdoc->hdoc = hdoc;
    lpdoc->aName = GlobalAddAtom(lptitle);
    lpdoc->oledoc.lpvtbl = &vdocvtbl;

    if (!lhdoc)
    {
        if (Error(OleRegisterServerDoc(lpsrvr->lhsrvr, lptitle,
            (LPOLESERVERDOC)lpdoc, (LHSERVERDOC * ) & lpdoc->lhdoc)))
            goto errRtn;
    }
    else
    {
        lpdoc->lhdoc = lhdoc;
    }

    gfDocExists  = TRUE;
    gfDocCleared = FALSE;
    return lpdoc;

errRtn:
    ErrorMessage(E_FAILED_TO_REGISTER_DOCUMENT);

    // Clean up
    if (lpdoc)
        LocalUnlock(hdoc);

    if (hdoc)
        LocalFree(hdoc);

    return NULL;
}



/* DeleteDoc() - Notify the OLE library that the document is to be deleted.
 */
static VOID
DeleteDoc(
    LPSAMPDOC lpdoc
    )
{
    if (gfOleClosed)
        SendDocChangeMsg(lpdoc, OLE_CLOSED);

    OleRevokeServerDoc(lpdoc->lhdoc);
}



/* ChangeDocName() - Notify the OLE library that the document name is changing.
 */
VOID
ChangeDocName(
    LPSAMPDOC *lplpdoc,
    LPSTR lpname
    )
{
    // If the document exists, delete and re-register.
    if (*lplpdoc)
    {
        GlobalDeleteAtom((*lplpdoc)->aName);
        (*lplpdoc)->aName = GlobalAddAtom(lpname);

        //
        // If the document contains items, just notify the children.
        // If we aren't embedded, always delete and re-register.
        //
        OleRenameServerDoc((*lplpdoc)->lhdoc, lpname);
        if (gfEmbedded && cItems)
            return;

        DeleteDoc(*lplpdoc);
    }

    *lplpdoc = InitDoc(glpsrvr, 0, lpname);
}



/* SendDocChangeMsg() - Notify the client that the document has changed.
 */
BOOL
SendDocChangeMsg(
    LPSAMPDOC lpdoc,
    UINT options
    )
{
    BOOL fSuccess = FALSE;
    INT i;

    for (i = 0; i < cItems; i++)
    {
        if (SendItemChangeMsg(vlpitem[i], options))
            fSuccess = TRUE;
    }

    return fSuccess;
}



/* CreateNewDoc() - Called when a document is newly created.
 *
 * Returns: hDocument if document successfully created, NULL otherwise.
 * Note:    This function is only called when the document is being
 *          created through OLE actions.
 */
LPSAMPDOC
CreateNewDoc(
    LPSAMPSRVR lpsrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpstr
    )
{
    glpdoc = InitDoc(lpsrvr, lhdoc, lpstr);
    StringCchCopy(szUntitled, ARRAYSIZE(szUntitled), lpstr); 
    SetTitle(TRUE);

    return glpdoc;
}



/* CreateDocFromFile() - Called when a document is to be created from a file.
 *
 * Returns: hDocument if document successfully created, NULL otherwise.
 * Note:    This function is only called when the document is being
 *          created through OLE actions.  The file name is temporarily
 *          set to load the file, then it is reset to "".  This is so
 *          that we won't save back to the template if we exit.
 */
LPSAMPDOC
CreateDocFromFile(
    LPSAMPSRVR lpsrvr,
    LHSERVERDOC lhdoc,
    LPSTR lpstr
    )
{
    // Initialize document
    if (!(glpdoc = InitDoc(lpsrvr, lhdoc, lpstr)) || !(*lpstr))
        return NULL;

    lstrcpy(szUntitled, lpstr); // This could overrun, but I don't see how I can check the length of the lpstr coming in
    SetTitle(TRUE);

    return glpdoc;
}



/********************** Item support functions ************************/
/* CopyObjects() - Copies selection to the clipboard.
 */
BOOL
CopyObjects(
    VOID
    )
{
    HANDLE hdata;

    // If we can't open the clipboard, fail
    if (!OpenClipboard(ghwndFrame))
        return FALSE;

    Hourglass(TRUE);

    // Empty the clipboard
    EmptyClipboard();

    //
    // Copy the clipboard contents.
    //
    // Start with Native Data - which will just contain all the objects
    // which intersect with the selection rectangle.
    //
    if (hdata = GetNative(TRUE))
    {
        SetClipboardData(gcfNative, hdata);
        OleSavedClientDoc(lhClipDoc);
    }

    if (lhClipDoc)
    {
        OleRevokeClientDoc(lhClipDoc);
    lhClipDoc = 0;
    }

    if (hdata = GetLink())
        SetClipboardData(gcfOwnerLink, hdata);

    //
    // Metafile data:  Re-invert the image before putting
    // it onto the clipboard.
    //
    if (hdata = GetMF())
        SetClipboardData(CF_METAFILEPICT, hdata);

    CloseClipboard();
    Hourglass(FALSE);

    return TRUE;
}



/* CreateNewItem() - Allocate a new item.
 *
 * Note:    lpitem->rc will be filled out by the caller.
 */
LPSAMPITEM
CreateNewItem(
    LPSAMPDOC lpdoc
    )
{
    HANDLE hitem = NULL;
    LPSAMPITEM lpitem = NULL;

    // Now create the item
    if (!(hitem = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof(ITEM)))
        || !(lpitem = (LPSAMPITEM)GlobalLock(hitem)))
        goto errRtn;

    lpitem->hitem = hitem;
    lpitem->oleobject.lpvtbl = &vitemvtbl;
    return lpitem;

errRtn:
    if (lpitem)
        GlobalUnlock(hitem);

    if (hitem)
        GlobalFree(hitem);

    return NULL;
}



/* SendItemChangeMsg() - Notify the client that the item has changed.
 */
static BOOL
SendItemChangeMsg(
    LPSAMPITEM lpitem,
    UINT options
    )
{
    if (lpitem->lpoleclient)
    {
        (*lpitem->lpoleclient->lpvtbl->CallBack)
            (lpitem->lpoleclient, options, (LPOLEOBJECT)lpitem);

        return TRUE;
    }

    return FALSE;
}



/******************** Data reading/writing functions *********************/
/* GetNative(fClip) - Write the item native format to a memory block.
 *
 * This function will just write the objects which intersect
 * with the selection rectangle into a memory block.  If we
 * are running as an embedded instance, return ALL items, even
 * those which are not in the selection area.  Then we will
 * never lose objects that we move out of the selection area
 * when editing an embedded object.
 *
 * Args: fClip - TRUE means native data is for copying to clipboard
 *
 * Returns: A handle containing the native format, or NULL.
 */
HANDLE
GetNative(
    BOOL fClip
    )
{
    BOOL fSuccess = FALSE;
    DWORD cBytes = 0L;
    HANDLE hdata = NULL;
    LPSTR lpdata = NULL;
    DWORD cEmbWrite;
    LPOLEOBJECT lpobjapp = NULL;
    LPOLEOBJECT lpobjcon = NULL;
    LPPICT lpcPict;
    LPPICT lpaPict;
    WORD w;

    // Compute the size of the appearance
    lpaPict = glpobj[APPEARANCE];
    lpcPict = glpobj[CONTENT];

    switch (gpty[APPEARANCE])
    {
        case ICON:
            cBytes += IconWriteToNative(glpobj[APPEARANCE], NULL);
            break;

        case PICTURE:
            if (fClip)
            {
                if (Error(OleRegisterClientDoc(
                    gszAppClassName, szClip, 0L, &lhClipDoc)))
                    goto Error;

                if (Error(OleClone(
                    lpaPict->lpObject, glpclient, lhClipDoc,
                    szAppearance, &lpobjapp)))
                    goto Error;

                cBytes += PicWriteToNative(lpaPict, lpobjapp, NULL);
            }
            else
            {
                cBytes += PicWriteToNative(lpaPict, lpaPict->lpObject, NULL);
            }

            break;

        default:
            break;
    }

    // Compute the content size
    switch (gpty[CONTENT])
    {
        case CMDLINK:
            cBytes += CmlWriteToNative(glpobj[CONTENT], NULL);
            break;

        case PEMBED:    /* EmbWrite returns -1L if the user cancels */
            cEmbWrite = EmbWriteToNative(glpobj[CONTENT], NULL);

            if (cEmbWrite == (DWORD) - 1L)
                return FALSE;

            cBytes += cEmbWrite;
            break;

        case PICTURE:
            if (fClip)
            {
                if (!lhClipDoc && (Error(OleRegisterClientDoc(
                    gszAppClassName, szClip, 0L, &lhClipDoc))))
                    goto Error;

                if (Error(OleClone(lpcPict->lpObject, glpclient,
                    lhClipDoc, szContent, &lpobjcon)))
                    goto Error;

                cBytes += PicWriteToNative(lpcPict, lpobjcon, NULL);
            }
            else
            {
                cBytes += PicWriteToNative(lpcPict, lpcPict->lpObject, NULL);
            }

            break;

        default:
            break;
    }

    if (cBytes == 0L) // then no data
        goto Error;

    cBytes += (DWORD)(2 * sizeof(WORD));

    // Allocate a memory block for the data
    if (!(hdata = GlobalAlloc(GMEM_ZEROINIT, cBytes)) ||
        !(lpdata = (LPSTR)GlobalLock(hdata)))
        goto Error;

    // Write out the appearance
    w = (WORD)gpty[APPEARANCE];
    MemWrite(&lpdata, (LPSTR)&w, sizeof(WORD));
    switch (gpty[APPEARANCE])
    {
        case ICON:
            IconWriteToNative(glpobj[APPEARANCE], &lpdata);
            break;

        case PICTURE:
            if (fClip)
                PicWriteToNative(lpaPict, lpobjapp, &lpdata);
            else
                PicWriteToNative(lpaPict, lpaPict->lpObject, &lpdata);

            break;

        default:
            break;
    }

    // Write out the content
    w = (WORD)gpty[CONTENT];
    MemWrite(&lpdata, (LPSTR)&w, sizeof(WORD));

    switch (gpty[CONTENT])
    {
        case CMDLINK:
            CmlWriteToNative(glpobj[CONTENT], &lpdata);
            break;

        case PEMBED:
            EmbWriteToNative(glpobj[CONTENT], &lpdata);
            break;

        case PICTURE:
            if (fClip)
                PicWriteToNative(lpcPict, lpobjcon, &lpdata);
            else
                PicWriteToNative(lpcPict, lpcPict->lpObject, &lpdata);

            break;

        default:
            break;
    }

    fSuccess = TRUE;

Error:
    if (lpobjcon)
        OleRelease (lpobjcon);

    if (lpobjapp)
        OleRelease (lpobjapp);

    if (lpdata)
        GlobalUnlock(hdata);

    if (!fSuccess && hdata)
    {
        GlobalFree(hdata);
        hdata = NULL;
    }

    return hdata;
}



/* PutNative() - Read the item native data from a selector.
 *
 * Reads as many objects as it can, in upwards order (better error recovery).
 * Note:  It may be worthwhile to scale the object(s) to the window here.
 *
 * Returns: TRUE iff successful.
 */
BOOL
PutNative(
    HANDLE hdata
    )
{
    BOOL fSuccess = FALSE;
    LPSTR lpdata;
    WORD w;

    if (!(lpdata = (LPSTR)GlobalLock(hdata)))
        goto Error;

    // Delete any previous panes
    DeletePane(APPEARANCE, TRUE);
    DeletePane(CONTENT, TRUE);

    // Read in the appearance
    MemRead(&lpdata, (LPSTR)&w, sizeof(WORD));
    gpty[APPEARANCE] = w;
    switch (gpty[APPEARANCE])
    {
        case ICON:
            if (!(glpobj[APPEARANCE] = IconReadFromNative(&lpdata)))
                gpty[APPEARANCE] = NOTHING;

            break;

        case PICTURE:
            if (glpobj[APPEARANCE] =
                PicReadFromNative(&lpdata, gszCaption[APPEARANCE]))
            {
                SendMessage(ghwndPane[APPEARANCE], WM_FIXSCROLL, 0, 0L);
                break;
            }

        default:
            gpty[APPEARANCE] = NOTHING;
            break;
    }

    // Read the content
    MemRead(&lpdata, (LPSTR)&w, sizeof(WORD));
    gpty[CONTENT] = w;
    switch (gpty[CONTENT])
    {
        case CMDLINK:
            if (!(glpobj[CONTENT] = CmlReadFromNative(&lpdata)))
                gpty[CONTENT] = NOTHING;

            break;

        case PEMBED:
            if (!(glpobj[CONTENT] = (LPVOID)EmbReadFromNative(&lpdata)))
                gpty[CONTENT] = NOTHING;

            break;

        case PICTURE:
            if (glpobj[CONTENT] =
                (LPVOID)PicReadFromNative(&lpdata, gszCaption[CONTENT]))
            {
                SendMessage(ghwndPane[CONTENT], WM_FIXSCROLL, 0, 0L);
                EnableWindow(ghwndPict, TRUE);
                break;
            }

        default:
            gpty[CONTENT] = NOTHING;
            break;
    }

    fSuccess = TRUE;
    InvalidateRect(ghwndFrame, NULL, TRUE);

Error:
    if (lpdata)
        GlobalUnlock(hdata);

    return fSuccess;
}



/* GetLink() - Retrieves ObjectLink/OwnerLink information.
 *
 * This function returns a string describing the selected area.
 */
HANDLE
GetLink(
    VOID
    )
{
    CHAR pchlink[CBLINKMAX];
    INT cblink;
    HANDLE hlink;
    LPSTR lplink;

    // Link data - <App name>\0<Doc name>\0<Item name>\0\0
    StringCchCopy((LPSTR)pchlink, ARRAYSIZE(pchlink), gszAppClassName);   // ok const
    cblink = lstrlen((LPSTR)pchlink) + 1;

    // Copy the file name
    StringCchCopy((LPSTR)(pchlink + cblink), ARRAYSIZE(pchlink) - cblink, szDummy);    // szDummy size = 20
    cblink += lstrlen((LPSTR)(pchlink + cblink)) + 1;

    // Copy the item name
    StringCchCopy((LPSTR)(pchlink + cblink), ARRAYSIZE(pchlink) - cblink, szDummy);
    cblink += lstrlen((LPSTR)(pchlink + cblink)) + 1;
    pchlink[cblink++] = 0;       /* throw in another NULL at the end */

    // Allocate a memory block for the data
    if (!(hlink = GlobalAlloc(GMEM_ZEROINIT, cblink)) ||
        !(lplink = (LPSTR)GlobalLock(hlink)))
        goto Error;

    // Copy the data, then return the memory block
    MemWrite(&lplink, (LPSTR)pchlink, cblink);
    GlobalUnlock(hlink);
    return hlink;

Error:
    if (hlink)
        GlobalFree(hlink);

    return NULL;
}



/* GetMF() - Retrieve a metafile of the selected area.
 *
 * Note:    Originally, tried to Blt directly from the Window DC.  This
 *          doesn't work very well because when the window is obscured,
 *          the obscured portion shows up when the link is updated.
 */
HANDLE
GetMF(
    VOID
    )
{
    BOOL fError = TRUE;
    HANDLE hdata = NULL;
    HDC hdcMF = NULL;
    HDC hdcWnd = NULL;
    HFONT hfont;
    HANDLE hmfpict;
    LPMETAFILEPICT lpmfpict;
    LPIC lpic;
    LPPICT lppict;
    RECT rcTemp;
    RECT rcText;
    INT cxImage;
    INT cyImage;

    hmfpict = GlobalAlloc(GMEM_ZEROINIT, sizeof(METAFILEPICT));
    if (!hmfpict)
        goto Error;

    lpmfpict = (LPMETAFILEPICT)GlobalLock(hmfpict);

    // If the picture has a metafile, use it!
    if (gpty[APPEARANCE] == PICTURE)
    {
        LPMETAFILEPICT  lpmfpictOrg = NULL;

        if (Error(OleGetData(
            ((LPPICT)glpobj[APPEARANCE])->lpObject, CF_METAFILEPICT, &hdata))
            || !hdata
            || !(lpmfpictOrg = (LPMETAFILEPICT)GlobalLock(hdata)))
            goto NoPicture;

        // Copy the metafile
        lpmfpict->hMF = CopyMetaFile(lpmfpictOrg->hMF, NULL);
        GlobalUnlock(hdata);

        // If we failed, just draw it
        if (!lpmfpict->hMF)
            goto NoPicture;

        // Finish filling in the metafile header
        lpmfpict->mm   = lpmfpictOrg->mm;
        lpmfpict->xExt = lpmfpictOrg->xExt;
        lpmfpict->yExt = lpmfpictOrg->yExt;

        GlobalUnlock(hmfpict);
        return hmfpict;
    }

NoPicture:
    // Get the window DC, and make a DC compatible to it.
    if (!(hdcWnd = GetDC(NULL)))
        goto Error;

    switch (gpty[APPEARANCE])
    {
        case ICON:
            lpic = (LPIC)glpobj[APPEARANCE];

            // Set the icon text rectangle, and the icon font
            SetRect(&rcText, 0, 0, gcxArrange, gcyArrange);
            hfont = SelectObject(hdcWnd, ghfontTitle);

            // Figure out how large the text region will be
            // since this is going in a metafile we will not wrap
            // the icon text

            DrawText(hdcWnd, lpic->szIconText, -1, &rcText,
                DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

            if (hfont)
                SelectObject(hdcWnd, hfont);

            // Compute the image size
            rcText.right++;
            cxImage = (rcText.right > gcxIcon) ? rcText.right : gcxIcon;
            cyImage = gcyIcon + rcText.bottom + 1;
            break;

        case PICTURE:
            lppict  = (LPPICT)glpobj[APPEARANCE];
            cxImage = lppict->rc.right - lppict->rc.left + 1;
            cyImage = lppict->rc.bottom - lppict->rc.top + 1;
            break;

        default:
            cxImage = GetSystemMetrics(SM_CXICON);
            cyImage = GetSystemMetrics(SM_CYICON);
            break;
    }

    cxImage += cxImage / 4; // grow the image a bit

    cyImage += cyImage / 8;

    // Create the metafile
    if (!(hdcMF = CreateMetaFile(NULL)))
        goto Error;

    // Initialize the metafile
    SetWindowOrgEx(hdcMF, 0, 0, NULL);
    SetWindowExtEx(hdcMF, cxImage - 1, cyImage - 1, NULL);

    //
    // Fill in the background
    //
    // We displace back to (0, 0) because that's where the BITMAP resides.
    //
    SetRect(&rcTemp, 0, 0, cxImage, cyImage);
    switch (gpty[APPEARANCE])
    {
        case ICON:
            IconDraw(glpobj[APPEARANCE], hdcMF, &rcTemp, FALSE, cxImage, cyImage);
            break;

        case PICTURE:
            PicDraw(glpobj[APPEARANCE], hdcMF, &rcTemp, 0, 0, TRUE, FALSE);
            break;

        default:
            DrawIcon(hdcMF, 0, 0, LoadIcon(ghInst, MAKEINTRESOURCE(ID_APPLICATION)));
            break;
    }

    // Map to device independent coordinates
    rcTemp.right =
        MulDiv((rcTemp.right - rcTemp.left), HIMETRIC_PER_INCH, giXppli);
    rcTemp.bottom =
        MulDiv((rcTemp.bottom - rcTemp.top), HIMETRIC_PER_INCH, giYppli);

    // Finish filling in the metafile header
    lpmfpict->mm = MM_ANISOTROPIC;
    lpmfpict->xExt = rcTemp.right;
    lpmfpict->yExt = rcTemp.bottom;
    lpmfpict->hMF = CloseMetaFile(hdcMF);

    fError = FALSE;

Error:
    if (hdcWnd)
        ReleaseDC(NULL, hdcWnd);

    // If we had an error, return NULL
    if (fError && hmfpict)
    {
        GlobalUnlock(hmfpict);
        GlobalFree(hmfpict);
        hmfpict = NULL;
    }

    return hmfpict;
}



/* InitEmbedded() - Perform operations specific to editing embedded objects.
 *
 * This routine changes the menu items as appropriate.
 */
VOID
InitEmbedded(
    BOOL fCreate
    )
{
    HMENU hmenu;

    if (hmenu = GetMenu(ghwndFrame))
        EnableMenuItem(hmenu, IDM_UPDATE, fCreate ? MF_GRAYED : MF_ENABLED);

    gfEmbedded = TRUE;
}



/***************** Item circular queue/utility functions *****************/
/* AddItem() - Add an item to the global item list.
 */
LPSAMPITEM
AddItem(
    LPSAMPITEM lpitem
    )
{
    INT i;
    HANDLE hitem;

    i = FindItem((LPSAMPITEM)lpitem);
    if (i < cItems)
    {
        vlpitem[i]->ref++;

        // Free the duplicate item
        GlobalUnlock(hitem = lpitem->hitem);
        GlobalFree(hitem);
    }
    else
    {
        if (i < CITEMSMAX)
        {
            vlpitem[cItems] = (LPSAMPITEM)lpitem;
            vlpitem[cItems++]->ref = 1;
        }
        else
        {
            return NULL;
        }
    }

    return vlpitem[i];
}



/* DeleteItem() - Delete an item from the global item list.
 *
 * Returns: TRUE iff successful.
 */
BOOL
DeleteItem(
    LPSAMPITEM lpitem
    )
{
    BOOL fFound;
    HANDLE hitem;
    INT i;

    i = FindItem(lpitem);

    if ((fFound = (i < cItems && vlpitem[i]->ref))
        && !(--vlpitem[i]->ref))
    {
        // Free the item
        GlobalUnlock(hitem = vlpitem[i]->hitem);
        GlobalFree(hitem);

        // Shift everything else down
        cItems--;
        for ( ; i < cItems; i++)
            vlpitem[i] = vlpitem[i + 1];
    }

    return fFound;
}



/* FindItem() - Locate an item in the global item list.
 */
static INT
FindItem(
    LPSAMPITEM lpitem
    )
{
    BOOL fFound = FALSE;
    INT i;

    for (i = 0; i < cItems && !fFound;)
    {
        if (lpitem->aName == vlpitem[i]->aName)
        {
            fFound = TRUE;
        }
        else
        {
            i++;
        }
    }

    return i;
}



/* EndEmbedding() - Return to normal editing.
 *
 * This routine changes the menu items as appropriate.
 */
VOID
EndEmbedding(
    VOID
    )
{
    HMENU hmenu;

    // Fix the "Untitled" string
    LoadString(ghInst, IDS_UNTITLED, szUntitled, CBMESSAGEMAX);

    if (hmenu = GetMenu(ghwndFrame))
        EnableMenuItem(hmenu, IDM_UPDATE, MF_GRAYED);

    gfEmbedded = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\debug.h ===
//
// Debugging macros
//
#if DBG
#   define  DBG_CODE    1

void DbgPrintf( LPTSTR szFmt, ... );
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText );
//HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
// HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
void MemExitCheckWorker(void);


//#   define  MemAlloc( f, s )    MemAllocWorker( __FILE__, __LINE__, f, s )
//#   define  MemFree( h )        MemFreeWorker( __FILE__, __LINE__, h )
#   define  MEM_EXIT_CHECK()    MemExitCheckWorker()
#   define  DBGSTOP( t )        DbgStopX( __FILE__, __LINE__, TEXT(t) )
#   define  DBGSTOPX( f, l, t ) DbgStopX( f, l, TEXT(t) )
#   define  DBGPRINTF(p)        DbgPrintf p
#   define  DBGOUT(t)           DbgPrintf( TEXT("SYSCPL.CPL: %s\n"), TEXT(t) )
#else
//#   define  MemAlloc( f, s )    LocalAlloc( f, s )
//#   define  MemFree( h )        LocalFree( h )
#   define  MEM_EXIT_CHECK()
#   define  DBGSTOP( t )
#   define  DBGSTOPX( f, l, t )
#   define  DBGPRINTF(p)
#   define  DBGOUT(t)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\conv.c ===
//---------------------------------------------------------------------------
//  Package Title  ratpak
//  File           conv.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-97 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains conversion, input and output routines for numbers rationals
//  and longs.
//
//
//
//---------------------------------------------------------------------------

#include <stdio.h>
#include <tchar.h>      // TCHAR version of sprintf
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <shlwapi.h>
#include <ratpak.h>

BOOL fparserror=FALSE;
BOOL gbinexact=FALSE;

// digits 0..64 used by bases 2 .. 64
TCHAR digits[65]=TEXT("0123456789")
TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
TEXT("abcdefghijklmnopqrstuvwxyz_@");

// ratio of internal 'digits' to output 'digits'
// Calculated elsewhere as part of initialization and when base is changed
long ratio;    // int(log(2L^BASEXPWR)/log(nRadix))

// Used to strip trailing zeroes, and prevent combinatorial explosions
BOOL stripzeroesnum( PNUMBER pnum, long starting );

// returns int(lognRadix(x)) quickly.
long longlognRadix( long x );


//----------------------------------------------------------------------------
//
//    FUNCTION: fail
//
//    ARGUMENTS: pointer to an error message.
//
//    RETURN: None
//
//    DESCRIPTION: fail dumps the error message then throws an exception
//
//----------------------------------------------------------------------------

void fail( IN long errmsg )

{
#ifdef DEBUG
    fprintf( stderr, "%s\n", TEXT("Out of Memory") );
#endif
    throw( CALC_E_OUTOFMEMORY );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: _destroynum
//
//    ARGUMENTS: pointer to a number
//
//    RETURN: None
//
//    DESCRIPTION: Deletes the number and associated allocation
//
//-----------------------------------------------------------------------------

void _destroynum( IN PNUMBER pnum )

{
    if ( pnum != NULL )
        {
        zfree( pnum );
        }
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: _destroyrat
//
//    ARGUMENTS: pointer to a rational
//
//    RETURN: None
//
//    DESCRIPTION: Deletes the rational and associated
//    allocations.
//
//-----------------------------------------------------------------------------

void _destroyrat( IN PRAT prat )

{
    if ( prat != NULL )
        {
        destroynum( prat->pp );
        destroynum( prat->pq );
        zfree( prat );
        }
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: _createnum
//
//    ARGUMENTS: size of number in 'digits'
//
//    RETURN: pointer to a number
//
//    DESCRIPTION: allocates and zeroes out number type.
//
//-----------------------------------------------------------------------------

PNUMBER _createnum( IN long size )

{
    PNUMBER pnumret=NULL;

    // sizeof( MANTTYPE ) is the size of a 'digit'
    pnumret = (PNUMBER)zmalloc( (int)(size+1) * sizeof( MANTTYPE ) +
        sizeof( NUMBER ) );
    if ( pnumret == NULL )
        {
        fail( CALC_E_OUTOFMEMORY );
        }
    return( pnumret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: _createrat
//
//    ARGUMENTS: none
//
//    RETURN: pointer to a rational
//
//    DESCRIPTION: allocates a rational structure but does not
//    allocate the numbers that make up the rational p over q
//    form.  These number pointers are left pointing to null.
//
//-----------------------------------------------------------------------------


PRAT _createrat( void )

{
    PRAT prat=NULL;

    prat = (PRAT)zmalloc( sizeof( RAT ) );

    if ( prat == NULL )
        {
        fail( CALC_E_OUTOFMEMORY );
        }
    prat->pp = NULL;
    prat->pq = NULL;
    return( prat );
}



//-----------------------------------------------------------------------------
//
//    FUNCTION: numtorat
//
//    ARGUMENTS: pointer to a number, nRadix number is in.
//
//    RETURN: Rational representation of number.
//
//    DESCRIPTION: The rational representation of the number
//    is guaranteed to be in the form p (number with internal
//    base   representation) over q (number with internal base
//    representation)  Where p and q are integers.
//
//-----------------------------------------------------------------------------

PRAT numtorat( IN PNUMBER pin, IN unsigned long nRadix )

{
    PRAT pout=NULL;
    PNUMBER pnRadixn=NULL;
    PNUMBER qnRadixn=NULL;

    DUPNUM( pnRadixn, pin );

    qnRadixn=longtonum( 1, nRadix );

    // Ensure p and q start out as integers.
    if ( pnRadixn->exp < 0 )
        {
        qnRadixn->exp -= pnRadixn->exp;
        pnRadixn->exp = 0;
        }

    createrat(pout);

    // There is probably a better way to do this.
    pout->pp = numtonRadixx( pnRadixn, nRadix, ratio );
    pout->pq = numtonRadixx( qnRadixn, nRadix, ratio );


    destroynum( pnRadixn );
    destroynum( qnRadixn );

    return( pout );
}



//----------------------------------------------------------------------------
//
//    FUNCTION: nRadixxtonum
//
//    ARGUMENTS: pointer to a number, base requested.
//
//    RETURN: number representation in nRadix requested.
//
//    DESCRIPTION: Does a base conversion on a number from
//    internal to requested base. Assumes number being passed
//    in is really in internal base form.
//
//----------------------------------------------------------------------------

PNUMBER nRadixxtonum( IN PNUMBER a, IN unsigned long nRadix )

{
    PNUMBER sum=NULL;
    PNUMBER powofnRadix=NULL;
    unsigned long bitmask;
    unsigned long cdigits;
    MANTTYPE *ptr;

    sum = longtonum( 0, nRadix );
    powofnRadix = longtonum( BASEX, nRadix );

    // A large penalty is paid for conversion of digits no one will see anyway.
    // limit the digits to the minimum of the existing precision or the
    // requested precision.
    cdigits = maxout + 1;
    if ( cdigits > (unsigned long)a->cdigit )
        {
        cdigits = (unsigned long)a->cdigit;
        }

    // scale by the internal base to the internal exponent offset of the LSD
    numpowlong( &powofnRadix, a->exp + (a->cdigit - cdigits), nRadix );

    // Loop over all the relative digits from MSD to LSD
    for ( ptr = &(MANT(a)[a->cdigit-1]); cdigits > 0 && !fhalt;
        ptr--, cdigits-- )
        {
        // Loop over all the bits from MSB to LSB
        for ( bitmask = BASEX/2; bitmask > 0; bitmask /= 2 )
            {
            addnum( &sum, sum, nRadix );
            if ( *ptr & bitmask )
                {
                sum->mant[0] |= 1;
                }
            }
        }

    // Scale answer by power of internal exponent.
    mulnum( &sum, powofnRadix, nRadix );

    destroynum( powofnRadix );
    sum->sign = a->sign;
    return( sum );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: numtonRadixx
//
//    ARGUMENTS: pointer to a number, nRadix of that number.
//       previously calculated ratio
//
//    RETURN: number representation in internal nRadix.
//
//    DESCRIPTION: Does a nRadix conversion on a number from
//    specified nRadix to requested nRadix.  Assumes the nRadix
//    specified is the nRadix of the number passed in.
//
//-----------------------------------------------------------------------------

PNUMBER numtonRadixx( IN PNUMBER a, IN unsigned long nRadix, IN long ratio )

{
    PNUMBER pnumret = NULL;        // pnumret is the number in internal form.
    PNUMBER thisdigit = NULL;      // thisdigit holds the current digit of a
                                   // being summed into result.
    PNUMBER powofnRadix = NULL;    // offset of external base exponent.
    MANTTYPE *ptrdigit;            // pointer to digit being worked on.
    long idigit;                   // idigit is the iterate of digits in a.


    pnumret = longtonum( 0, BASEX );

    ptrdigit = MANT(a);

    // Digits are in reverse order, back over them LSD first.
    ptrdigit += a->cdigit-1;


    for ( idigit = 0; idigit < a->cdigit; idigit++ )
        {
        mulnumx( &pnumret, num_nRadix );
        // WARNING:
        // This should just smack in each digit into a 'special' thisdigit.
        // and not do the overhead of recreating the number type each time.
        thisdigit = longtonum( *ptrdigit--, BASEX );
        addnum( &pnumret, thisdigit, BASEX );
        destroynum( thisdigit );
        }
    DUPNUM( powofnRadix, num_nRadix );

    // Calculate the exponent of the external base for scaling.
    numpowlongx( &powofnRadix, a->exp );

    // ... and scale the result.
    mulnumx( &pnumret, powofnRadix );

    destroynum( powofnRadix );

    // And propagate the sign.
    pnumret->sign = a->sign;

    return( pnumret );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: inrat
//
//  ARGUMENTS:
//              fMantIsNeg true if mantissa is less than zero
//              pszMant a string representation of a number
//              fExpIsNeg  true if exponent is less than zero
//              pszExp a string representation of a number
//
//  RETURN: prat    representation of string input.
//          Or NULL if no number scanned.
//
//  EXPLANATION: This is for calc.
//
//
//-----------------------------------------------------------------------------

PRAT inrat( IN BOOL fMantIsNeg, IN LPTSTR pszMant, IN BOOL fExpIsNeg,
    IN LPTSTR pszExp )

{
    PNUMBER pnummant=NULL;              // holds mantissa in number form.
    PNUMBER pnumexp=NULL;               // holds exponent in number form.
    PRAT pratexp=NULL;                  // holds exponent in rational form.
    PRAT prat=NULL;                     // holds exponent in rational form.
    long expt;                          // holds exponent

    // Deal with Mantissa
    if ( ( pszMant == NULL ) || ( *pszMant == TEXT('\0') ) )
        {
        // Preset value if no mantissa
        if ( ( pszExp == NULL ) || ( *pszExp == TEXT('\0') ) )
            {
            // Exponent not specified, preset value to zero
            DUPRAT(prat,rat_zero);
            }
        else
            {
            // Exponent specified, preset value to one
            DUPRAT(prat,rat_one);
            }
        }
    else
        {
        // Mantissa specified, convert to number form.
        pnummant = innum( pszMant );
        if ( pnummant == NULL )
            {
            return( NULL );
            }
        prat = numtorat( pnummant, nRadix );
        // convert to rational form, and cleanup.
        destroynum(pnummant);
        }

    if ( ( pszExp == NULL ) || ( *pszExp == TEXT('\0') ) )
        {
        // Exponent not specified, preset value to zero
        expt=0;
        }
    else
        {
        // Exponent specified, convert to number form.
        // Don't use native stuff, as it is restricted in the bases it can
        // handle.
        pnumexp = innum( pszExp );
        if ( pnumexp == NULL )
            {
            return( NULL );
            }

        // Convert exponent number form to native integral form,  and cleanup.
        expt = numtolong( pnumexp, nRadix );
        destroynum( pnumexp );
        }


    // Convert native integral exponent form to rational multiplier form.
    pnumexp=longtonum( nRadix, BASEX );
    numpowlongx(&(pnumexp),abs(expt));
    createrat(pratexp);
    DUPNUM( pratexp->pp, pnumexp );
    pratexp->pq = longtonum( 1, BASEX );
    destroynum(pnumexp);

    if ( fExpIsNeg )
        {
        // multiplier is less than 1, this means divide.
        divrat( &prat, pratexp );
        }
    else
        {
        if ( expt > 0 )
            {
            // multiplier is greater than 1, this means divide.
            mulrat(&prat, pratexp);
            }
        // multiplier can be 1, in which case it'd be a waste of time to
        // multiply.
        }

    if ( fMantIsNeg )
        {
        // A negative number was used, adjust the sign.
        prat->pp->sign *= -1;
        }
    return( prat );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: innum
//
//  ARGUMENTS:
//              TCHAR *buffer
//
//  RETURN: pnumber representation of string input.
//          Or NULL if no number scanned.
//
//  EXPLANATION: This is a state machine,
//
//    State      Description            Example, ^shows just read position.
//                                                which caused the transition
//
//    START      Start state            ^1.0
//    MANTS      Mantissa sign          -^1.0
//    LZ         Leading Zero           0^1.0
//    LZDP       Post LZ dec. pt.       000.^1
//    LD         Leading digit          1^.0
//    DZ         Post LZDP Zero         000.0^1
//    DD         Post Decimal digit     .01^2
//    DDP        Leading Digit dec. pt. 1.^2
//    EXPB       Exponent Begins        1.0e^2
//    EXPS       Exponent sign          1.0e+^5
//    EXPD       Exponent digit         1.0e1^2 or  even 1.0e0^1
//    EXPBZ      Exponent begin post 0  0.000e^+1
//    EXPSZ      Exponent sign post 0   0.000e+^1
//    EXPDZ      Exponent digit post 0  0.000e+1^2
//    ERR        Error case             0.0.^
//
//    Terminal   Description
//
//    DP         '.'
//    ZR         '0'
//    NZ         '1'..'9' 'A'..'Z' 'a'..'z' '@' '_'
//    SG         '+' '-'
//    EX         'e' '^' e is used for nRadix 10, ^ for all other nRadixs.
//
//-----------------------------------------------------------------------------

#define DP 0
#define ZR 1
#define NZ 2
#define SG 3
#define EX 4

#define START    0
#define MANTS    1
#define LZ       2
#define LZDP     3
#define LD       4
#define DZ       5
#define DD       6
#define DDP      7
#define EXPB     8
#define EXPS     9
#define EXPD     10
#define EXPBZ    11
#define EXPSZ    12
#define EXPDZ    13
#define ERR      14

#if defined( DEBUG )
char *statestr[] = {
    "START",
    "MANTS",
    "LZ",
    "LZDP",
    "LD",
    "DZ",
    "DD",
    "DDP",
    "EXPB",
    "EXPS",
    "EXPD",
    "EXPBZ",
    "EXPSZ",
    "EXPDZ",
    "ERR",
};
#endif

// New state is machine[state][terminal]
char machine[ERR+1][EX+1]= {
    //        DP,     ZR,      NZ,      SG,     EX
    // START
        {     LZDP,   LZ,      LD,      MANTS,  ERR },
    // MANTS
        {     LZDP,   LZ,      LD,      ERR,    ERR },
    // LZ
        {     LZDP,   LZ,      LD,      ERR,    EXPBZ },
    // LZDP
        {     ERR,    DZ,      DD,      ERR,    EXPB },
    // LD
        {     DDP,    LD,      LD,      ERR,    EXPB },
    // DZ
        {     ERR,    DZ,      DD,      ERR,    EXPBZ },
    // DD
        {     ERR,    DD,      DD,      ERR,    EXPB },
    // DDP
        {     ERR,    DD,      DD,      ERR,    EXPB },
    // EXPB
        {     ERR,    EXPD,    EXPD,    EXPS,   ERR },
    // EXPS
        {     ERR,    EXPD,    EXPD,    ERR,    ERR },
    // EXPD
        {     ERR,    EXPD,    EXPD,    ERR,    ERR },
    // EXPBZ
        {     ERR,    EXPDZ,   EXPDZ,   EXPSZ,  ERR },
    // EXPSZ
        {     ERR,    EXPDZ,   EXPDZ,   ERR,    ERR },
    // EXPDZ
        {     ERR,    EXPDZ,   EXPDZ,   ERR,    ERR },
    // ERR
        {     ERR,    ERR,     ERR,     ERR,    ERR }
};


PNUMBER innum( IN TCHAR *buffer )

{
    int c;                    // c is character being worked on currently.
    int state;                // state is the state of the input state machine.
    long exps = 1L;           // exps is exponent sign ( +/- 1 )
    long expt = 0L;           // expt is exponent mantissa, should be unsigned
    long length = 0L;         // length is the length of the input string.
    MANTTYPE *pmant;          //
    PNUMBER pnumret=NULL;     //

    length = _tcslen(buffer);
    createnum( pnumret, length );
    pnumret->sign = 1L;
    pnumret->cdigit = 0;
    pnumret->exp = 0;
    pmant = MANT(pnumret)+length-1;
    state = START;
    fparserror=FALSE;        // clear global flag for parse error initially.
    while ( ( c = *buffer ) && c != TEXT('\n') )
        {
        int dp;
        dp = 0;
        // Added code to deal with international decimal point.
        while ( szDec[dp] && ( szDec[dp] == *buffer ) )
            {
            dp++;
            buffer++;
            }
        if ( dp )
            {
            if ( szDec[dp] == TEXT('\0') )
                {
                // OK pretend that was a decimal point for the state machine
                c = TEXT('.');
                buffer--;
                }
            else
                {
                // Backup that was no decimal point
                buffer -= (dp-1);
                c = *buffer++;
                }
            }
        switch ( c )
            {
        case TEXT('-'):
        case TEXT('+'):
            state=machine[state][SG];
            break;
        case TEXT('.'):
            state=machine[state][DP];
            break;
        case TEXT('0'):
            state=machine[state][ZR];
            break;
        case TEXT('^'):
        case TEXT('e'):
            if ( ( c == TEXT('^') ) || ( nRadix == 10 ) )
                {
                state=machine[state][EX];
                break;
                }
        // WARNING tricky dropthrough in the TEXT('e') as a digit case!!!
        default:
            state=machine[state][NZ];
            break;
            }
        switch ( state )
            {
        case MANTS:
            pnumret->sign = ( ( c == TEXT('-') ) ? -1 : 1);
            break;
        case EXPSZ:
        case EXPS:
            exps = ( ( c == TEXT('-') ) ? -1 : 1);
            break;
        case EXPDZ:
        case EXPD:
            {
            TCHAR *ptr;               // offset into digit table.
            if ( ( nRadix <= 36 ) && ( nRadix > 10 ) )
                {
                c = toupper( c );
                }
            ptr = _tcschr( digits, (TCHAR)c );
            if ( ptr != NULL )
                {
                expt *= nRadix;
                expt += (long)(ptr - digits);
                }
            else
                {
                state=ERR;
                }
            }
            break;
        case LD:
            pnumret->exp++;
        case DD:
            {
            TCHAR *ptr;               // offset into digit table.
            if ( ( nRadix <= 36 ) && ( nRadix > 10 ) )
                {
                // Allow upper and lower case letters as equivalent, base
                // is in the range where this is not ambiguous.
                c = toupper( c );
                }
            ptr = _tcschr( digits, (TCHAR)c );
            if ( ptr != NULL && ( (ptr - digits) < nRadix ) )
                {
                *pmant-- = (MANTTYPE)(ptr - digits);
                pnumret->exp--;
                pnumret->cdigit++;
                }
            else
                {
                state=ERR;
                // set global flag for parse error just in case anyone cares.
                fparserror=TRUE;
                }
            }
            break;
        case DZ:
            pnumret->exp--;
            break;
        case LZ:
        case LZDP:
        case DDP:
            break;
            }
        buffer++;
        }
    if ( state == DZ || state == EXPDZ )
        {
        pnumret->cdigit = 1;
        pnumret->exp=0;
        pnumret->sign=1;
        }
    else
        {
        while ( pnumret->cdigit < length )
            {
            pnumret->cdigit++;
            pnumret->exp--;
            }
        pnumret->exp += exps*expt;
        }


    if ( pnumret->cdigit == 0 )
        {
        destroynum( pnumret );
        pnumret = NULL;
        }
    stripzeroesnum( pnumret, maxout );
    return( pnumret );
}



//-----------------------------------------------------------------------------
//
//    FUNCTION: longtorat
//
//    ARGUMENTS: long
//
//    RETURN: Rational representation of long input.
//
//    DESCRIPTION: Converts long input to rational (p over q)
//    form, where q is 1 and p is the long.
//
//-----------------------------------------------------------------------------

PRAT longtorat( IN long inlong )

{
    PRAT pratret=NULL;
    createrat( pratret );
    pratret->pp = longtonum(inlong, BASEX );
    pratret->pq = longtonum(1L, BASEX );
    return( pratret );
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: realtorat
//
//    ARGUMENTS: double real value.
//
//    RETURN: Rational representation of the double
//
//    DESCRIPTION: returns the rational (p over q)
//    representation of the double.
//
//-----------------------------------------------------------------------------

PRAT realtorat( IN double real )

{
#if !defined( CLEVER )
    // get clever later, right now hack something to work
    TCHAR *ptr;
    PNUMBER pnum=NULL;
    PRAT prat=NULL;
    if ( ( ptr = (TCHAR*)zmalloc( 60 * sizeof(TCHAR) ) ) != NULL )
        {
        wnsprintf( ptr, 60, TEXT("%20.20le"), real );
        pnum=innum( ptr );
        prat = numtorat( pnum, nRadix );
        destroynum( pnum );
        zfree( ptr );
        return( prat );
        }
    else
        {
        return( NULL );
        }
#else
    int i;
    union {
        double real;
        BYTE split[8];
    } unpack;
    long expt;
    long ratio;
    MANTTYPE *pmant;
    PNUMBER pnumret = NULL;
    PRAT pratret = NULL;

    createrat( pratret );

    if ( real == 0.0 )
        {
        pnumret=longtonum( 0L, 2L );
        }
    else
        {
        unpack.real=real;

        expt=unpack.split[7]*0x100+(unpack.split[6]>>4)-1023;
        createnum( pnumret, 52 );
        pmant = MANT(pnumret);
        for ( i = 63; i > 10; i-- )
            {
            *pmant++ = (MANTTYPE)((unpack.split[i/8]&(1<<(i%8)))!=0);
            }
        pnumret->exp=expt-52;
        pnumret->cdigit=52;
        }

    ratio = 1;
    while ( ratio > BASEX )
        {
        ratio *= 2;
        }

    pratret->pp = numtonRadixx( pnumret, 2, ratio );
    destroynum( pnumret );

    pratret->pq=longtonum( 1L, BASEX );

    if ( pratret->pp->exp < 0 )
        {
        pratret->pq->exp -= pratret->pp->exp;
        pratret->pp->exp = 0;
        }

    return( pratret );
#endif
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: longtonum
//
//    ARGUMENTS: long input and nRadix requested.
//
//    RETURN: number
//
//    DESCRIPTION: Returns a number representation in the
//    base   requested of the long value passed in.
//
//-----------------------------------------------------------------------------

PNUMBER longtonum( IN long inlong, IN unsigned long nRadix )

{
    MANTTYPE *pmant;
    PNUMBER pnumret=NULL;

    createnum( pnumret, MAX_LONG_SIZE );
    pmant = MANT(pnumret);
    pnumret->cdigit = 0;
    pnumret->exp = 0;
    if ( inlong < 0 )
        {
        pnumret->sign = -1;
        inlong *= -1;
        }
    else
        {
        pnumret->sign = 1;
        }

    do    {
        *pmant++ = (MANTTYPE)(inlong % nRadix);
        inlong /= nRadix;
        pnumret->cdigit++;
        } while ( inlong );

    return( pnumret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: rattolong
//
//    ARGUMENTS: rational number in internal base.
//
//    RETURN: long
//
//    DESCRIPTION: returns the long representation of the
//    number input.  Assumes that the number is in the internal
//    base.
//
//-----------------------------------------------------------------------------

long rattolong( IN PRAT prat )

{
    long lret;
    PRAT pint = NULL;

    if ( rat_gt( prat, rat_dword ) || rat_lt( prat, rat_min_long ) )
        {
        // Don't attempt rattolong of anything too big or small
        throw( CALC_E_DOMAIN );
        }

    DUPRAT(pint,prat);

    intrat( &pint );
    divnumx( &(pint->pp), pint->pq );
    DUPNUM( pint->pq, num_one );

    lret = numtolong( pint->pp, BASEX );

    destroyrat(pint);

    return( lret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: numtolong
//
//    ARGUMENTS: number input and base   of that number.
//
//    RETURN: long
//
//    DESCRIPTION: returns the long representation of the
//    number input.  Assumes that the number is really in the
//    base   claimed.
//
//-----------------------------------------------------------------------------

long numtolong( IN PNUMBER pnum, IN unsigned long nRadix )

{
    long lret;
    long expt;
    long length;
    MANTTYPE *pmant;

    lret = 0;
    pmant = MANT( pnum );
    pmant += pnum->cdigit - 1;

    expt = pnum->exp;
    length = pnum->cdigit;
    while ( length > 0  && length + expt > 0 )
        {
        lret *= nRadix;
        lret += *(pmant--);
        length--;
        }
    while ( expt-- > 0 )
        {
        lret *= (long)nRadix;
        }
    lret *= pnum->sign;
    return( lret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: BOOL stripzeroesnum
//
//    ARGUMENTS:            a number representation
//
//    RETURN: TRUE if stripping done, modifies number in place.
//
//    DESCRIPTION: Strips off trailing zeroes.
//
//-----------------------------------------------------------------------------

BOOL stripzeroesnum( IN OUT PNUMBER pnum, long starting )

{
    MANTTYPE *pmant;
    long cdigits;
    BOOL fstrip = FALSE;

    // point pmant to the LeastCalculatedDigit
    pmant=MANT(pnum);
    cdigits=pnum->cdigit;
    // point pmant to the LSD
    if ( cdigits > starting )
        {
        pmant += cdigits - starting;
        cdigits = starting;
        }

    // Check we haven't gone too far, and we are still looking at zeroes.
    while ( ( cdigits > 0 ) && !(*pmant) )
        {
        // move to next significant digit and keep track of digits we can
    // ignore later.
        pmant++;
        cdigits--;
        fstrip = TRUE;
        }

    // If there are zeroes to remove.
    if ( fstrip )
        {
        // Remove them.
        memmove( MANT(pnum), pmant, (int)(cdigits*sizeof(MANTTYPE)) );
        // And adjust exponent and digit count accordingly.
        pnum->exp += ( pnum->cdigit - cdigits );
        pnum->cdigit = cdigits;
        }
    return( fstrip );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: putnum
//
//    ARGUMENTS: number representation
//          fmt, one of FMT_FLOAT FMT_SCIENTIFIC or
//          FMT_ENGINEERING
//
//    RETURN: String representation of number.
//
//    DESCRIPTION: Converts a number to it's string
//    representation.  Returns a string that should be
//    zfree'd after use.
//
//-----------------------------------------------------------------------------

TCHAR *putnum(IN int* pcchNum, IN PNUMBER *ppnum, IN int fmt )

{
    TCHAR *psz;
    TCHAR *pret;
    long expt;        // Actual number of digits to the left of decimal
    long eout;        // Displayed exponent.
    long cexp;        // the size of the exponent needed.
    long elen;
    long length;
    MANTTYPE *pmant;
    int fsciform=0;    // If true scientific form is called for.
    PNUMBER pnum;
    PNUMBER round=NULL;
    long oldfmt = fmt;


    pnum=*ppnum;
    stripzeroesnum( pnum, maxout+2 );
    length = pnum->cdigit;
    expt = pnum->exp+length;
    if ( ( expt > maxout ) && ( fmt == FMT_FLOAT ) )
        {
        // Force scientific mode to prevent user from assuming 33rd digit is
        // exact.
        fmt = FMT_SCIENTIFIC;
        }


    // Make length small enough to fit in pret.
    if ( length > maxout )
        {
        length = maxout;
        }

    eout=expt-1;
    cexp = longlognRadix( expt );

    // 2 for signs, 1 for 'e'(or leading zero), 1 for dp, 1 for null and
    // 10 for maximum exponent size.
    int cchNum = (maxout + 16);
    pret = (TCHAR*)zmalloc( cchNum * sizeof(TCHAR) );
    if (pcchNum)
    {
        *pcchNum = cchNum;
    }
    psz = pret;

    if (!psz)
        {
        fail( CALC_E_OUTOFMEMORY );
        }

    // If there is a chance a round has to occour, round.
    if (
        // if number is zero no rounding.
        !zernum( pnum ) &&
        // if number of digits is less than the maximum output no rounding.
        pnum->cdigit >= maxout
        )
        {
        // Otherwise round.
        round=longtonum( nRadix, nRadix );
        divnum(&round, num_two, nRadix );

        // Make round number exponent one below the LSD for the number.
        round->exp = pnum->exp + pnum->cdigit - round->cdigit - maxout;
        round->sign = pnum->sign;
        }

    if ( fmt == FMT_FLOAT )
        {
        // cexp will now contain the size required by exponential.
        // Figure out if the exponent will fill more space than the nonexponent field.
        if ( ( length - expt > maxout + 2 ) || ( expt > maxout + 3 ) )
            {
            // Case where too many zeroes are to the right or left of the
            // decimal pt. And we are forced to switch to scientific form.
            fmt = FMT_SCIENTIFIC;
            }
        else
            {
            // Minimum loss of precision occours with listing leading zeros
            // if we need to make room for zeroes sacrifice some digits.
            if ( length + abs(expt) < maxout )
                {
                if ( round )
                    {
                    round->exp -= expt;
                    }
                }
            }
        }
    if ( round != NULL )
    	{
        BOOL fstrip=FALSE;
        long offset;
    	addnum( ppnum, round, nRadix );
    	pnum=*ppnum;
        offset=(pnum->cdigit+pnum->exp) - (round->cdigit+round->exp);
        fstrip = stripzeroesnum( pnum, offset );
        destroynum( round );
        if ( fstrip )
            {
            // WARNING: nesting/recursion, too much has been changed, need to
            // refigure format.
            return( putnum( pcchNum, &pnum, oldfmt ) );
            }
    	}
    else
    	{
        stripzeroesnum( pnum, maxout );
    	}

    // Set up all the post rounding stuff.
    pmant = MANT(pnum)+pnum->cdigit-1;

    if (
        // Case where too many digits are to the left of the decimal or
        // FMT_SCIENTIFIC or FMT_ENGINEERING was specified.
        ( fmt == FMT_SCIENTIFIC ) ||
        ( fmt == FMT_ENGINEERING ) )

        {
        fsciform=1;
        if ( eout != 0 )
            {

            if ( fmt == FMT_ENGINEERING )
                {
                expt = (eout % 3);
                eout -= expt;
                expt++;

                // Fix the case where 0.02e-3 should really be 2.e-6 etc.
                if ( expt < 0 )
                    {
                    expt += 3;
                    eout -= 3;
                    }

                }
            else
                {
                expt = 1;
                }
            }
        }
    else
        {
        fsciform=0;
        eout=0;
        }

    // Make sure negative zeroes aren't allowed.
    if ( ( pnum->sign == -1 ) && ( length > 0 ) )
        {
        *psz++ = TEXT('-');
        }

    if ( ( expt <= 0 ) && ( fsciform == 0 ) )
        {
        *psz++ = TEXT('0');
        *psz++ = szDec[0];
        // Used up a digit unaccounted for.
        }
    while ( expt < 0 )
        {
        *psz++ = TEXT('0');
        expt++;
        }

    while ( length > 0 )
        {
        expt--;
        *psz++ = digits[ *pmant-- ];
        length--;
        // Be more regular in using a decimal point.
        if ( expt == 0 )
            {
            *psz++ = szDec[0];
            }
        }

    while ( expt > 0 )
        {
        *psz++ = TEXT('0');
        expt--;
        // Be more regular in using a decimal point.
        if ( expt == 0 )
            {
            *psz++ = szDec[0];
            }
        }


    if ( fsciform )
        {
        if ( nRadix == 10 )
            {
            *psz++ = TEXT('e');
            }
        else
            {
            *psz++ = TEXT('^');
            }
        *psz++ = ( eout < 0 ? TEXT('-') : TEXT('+') );
        eout = abs( eout );
        elen=0;
        do
            {
            // should this be eout % nRadix?  or is that insane?
            *psz++ = digits[ eout % nRadix ];
            elen++;
            eout /= nRadix;
            } while ( eout > 0 );
        *psz = TEXT('\0');
        _tcsrev( &(psz[-elen]) );
        }
    *psz = TEXT('\0');
    return( pret );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: putrat
//
//  ARGUMENTS:
//              PRAT *representation of a number.
//              long representation of base  to  dump to screen.
//              fmt, one of FMT_FLOAT FMT_SCIENTIFIC or FMT_ENGINEERING
//
//  RETURN: string
//
//  DESCRIPTION: returns a string representation of rational number passed
//  in, at least to the maxout digits.  String returned should be zfree'd
//  after use.
//
//  NOTE: It may be that doing a GCD() could shorten the rational form
//       And it may eventually be worthwhile to keep the result.  That is
//       why a pointer to the rational is passed in.
//
//-----------------------------------------------------------------------------

TCHAR *putrat(OUT int* pcchNum,  IN OUT PRAT *pa, IN unsigned long nRadix, IN int fmt )

{
    TCHAR *psz;
    PNUMBER p=NULL;
    PNUMBER q=NULL;
    long scaleby=0;


    // Convert p and q of rational form from internal base to requested base.

    // Scale by largest power of BASEX possible.

    scaleby=min((*pa)->pp->exp,(*pa)->pq->exp);
    if ( scaleby < 0 )
        {
        scaleby = 0;
        }
    (*pa)->pp->exp -= scaleby;
    (*pa)->pq->exp -= scaleby;

    p = nRadixxtonum( (*pa)->pp, nRadix );

    q = nRadixxtonum( (*pa)->pq, nRadix );

    // finally take the time hit to actually divide.
    divnum( &p, q, nRadix );

    psz = putnum(pcchNum, &p, fmt );
    destroynum( p );
    destroynum( q );
    return( psz );
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: gcd
//
//  ARGUMENTS:
//              PNUMBER representation of a number.
//              PNUMBER representation of a number.
//
//  RETURN: Greatest common divisor in internal BASEX PNUMBER form.
//
//  DESCRIPTION: gcd uses remainders to find the greatest common divisor.
//
//  ASSUMPTIONS: gcd assumes inputs are integers.
//
//  NOTE: Before GregSte and TimC proved the TRIM macro actually kept the
//        size down cheaper than GCD, this routine was used extensively.
//        now it is not used but might be later.
//
//-----------------------------------------------------------------------------

PNUMBER gcd( IN PNUMBER a, IN PNUMBER b )

{
    PNUMBER r=NULL;
    PNUMBER tmpa=NULL;
    PNUMBER tmpb=NULL;

    if ( lessnum( a, b ) )
        {
        DUPNUM(tmpa,b);
        if ( zernum(a) )
            {
            return(tmpa);
            }
        DUPNUM(tmpb,a);
        }
    else
        {
        DUPNUM(tmpa,a);
        if ( zernum(b) )
            {
            return(tmpa);
            }
        DUPNUM(tmpb,b);
        }

    remnum( &tmpa, tmpb, nRadix );
    while ( !zernum( tmpa ) )
        {
        // swap tmpa and tmpb
        r = tmpa;
        tmpa = tmpb;
        tmpb = r;
        remnum( &tmpa, tmpb, nRadix );
        }
    destroynum( tmpa );
    return( tmpb );

}

//-----------------------------------------------------------------------------
//
//  FUNCTION: longfactnum
//
//  ARGUMENTS:
//              long integer to factorialize.
//              long integer representing base   of answer.
//
//  RETURN: Factorial of input in nRadix PNUMBER form.
//
//  NOTE:  Not currently used.
//
//-----------------------------------------------------------------------------

PNUMBER longfactnum( IN long inlong, IN unsigned long nRadix )

{
    PNUMBER lret=NULL;
    PNUMBER tmp=NULL;
    PNUMBER tmp1=NULL;

    lret = longtonum( 1, nRadix );

    while ( inlong > 0 )
        {
        tmp = longtonum( inlong--, nRadix );
        mulnum( &lret, tmp, nRadix );
        destroynum( tmp );
        }
    return( lret );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: longprodnum
//
//  ARGUMENTS:
//              long integer to factorialize.
//              long integer representing base of answer.
//
//  RETURN: Factorial of input in base PNUMBER form.
//
//-----------------------------------------------------------------------------

PNUMBER longprodnum( IN long start, IN long stop, IN unsigned long nRadix )

{
    PNUMBER lret=NULL;
    PNUMBER tmp=NULL;

    lret = longtonum( 1, nRadix );

    while ( start <= stop )
        {
        if ( start )
            {
            tmp = longtonum( start, nRadix );
            mulnum( &lret, tmp, nRadix );
            destroynum( tmp );
            }
        start++;
        }
    return( lret );
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: numpowlong
//
//    ARGUMENTS: root as number power as long and nRadix of
//               number.
//
//    RETURN: None root is changed.
//
//    DESCRIPTION: changes numeric representation of root to
//    root ** power. Assumes nRadix is the nRadix of root.
//
//-----------------------------------------------------------------------------

void numpowlong( IN OUT PNUMBER *proot, IN long power,
                IN unsigned long nRadix )

{
    PNUMBER lret=NULL;

    lret = longtonum( 1, nRadix );

    while ( power > 0 )
        {
        if ( power & 1 )
            {
            mulnum( &lret, *proot, nRadix );
            }
        mulnum( proot, *proot, nRadix );
        TRIMNUM(*proot);
        power >>= 1;
        }
    destroynum( *proot );
    *proot=lret;

}

//-----------------------------------------------------------------------------
//
//    FUNCTION: ratpowlong
//
//    ARGUMENTS: root as rational, power as long.
//
//    RETURN: None root is changed.
//
//    DESCRIPTION: changes rational representation of root to
//    root ** power.
//
//-----------------------------------------------------------------------------

void ratpowlong( IN OUT PRAT *proot, IN long power )

{
    if ( power < 0 )
        {
        // Take the positive power and invert answer.
        PNUMBER pnumtemp = NULL;
        ratpowlong( proot, -power );
        pnumtemp = (*proot)->pp;
        (*proot)->pp  = (*proot)->pq;
        (*proot)->pq = pnumtemp;
        }
    else
        {
        PRAT lret=NULL;

        lret = longtorat( 1 );

        while ( power > 0 )
            {
            if ( power & 1 )
                {
                mulnumx( &(lret->pp), (*proot)->pp );
                mulnumx( &(lret->pq), (*proot)->pq );
                }
            mulrat( proot, *proot );
            trimit(&lret);
            trimit(proot);
            power >>= 1;
            }
        destroyrat( *proot );
        *proot=lret;
        }
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: longlog10
//
//    ARGUMENTS: number as long.
//
//    RETURN: returns int(log10(abs(number)+1)), useful in formatting output
//
//-----------------------------------------------------------------------------

long longlognRadix( long x )

{
    long ret = 0;
    x--;
    if ( x < 0 )
        {
        x = -x;
        }
    while ( x )
        {
        ret++;
        x /= nRadix;
        }
    return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\basex.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak                                                   
//  File           basex.c                                                    
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)            
//  Copyright      (C) 1995-97 Microsoft                                    
//  Date           03-14-97                                                 
//                                                                          
//                                                                          
//  Description                                                             
//                                                                          
//     Contains number routines for internal base computations, these assume   
//  internal base is a power of 2.                                          
//                                                                          
//-----------------------------------------------------------------------------

#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <ratpak.h>


// WARNING: This assumes return of a 64 bit entity is in edx:eax
// This assumption SHOULD always be true on X86
#pragma warning( disable : 4035 )
DWORDLONG __inline Mul32x32( IN DWORD a, IN DWORD b )

{
#ifdef _X86_ 
    __asm {
    mov eax, b
        mul a
        }
#else
    return (DWORDLONG)a * b;
#endif
}
#pragma warning( default : 4035 )

// Yeah well when the F__KING COMPILER gets a clue I'll change this back to 
// an inline (as opposed to the compiler looking at fastcall putting the args
// in registers, oh and then a) not making this inline, and b) pushing the 
// values anyway!

#ifdef _X86_ 
    #define Shr32xbase(x) \
            __asm { mov eax,DWORD PTR [x] } \
            __asm { mov edx,DWORD PTR [x+4] } \
            __asm { shrd eax,edx,BASEXPWR } \
            __asm { shr edx,BASEXPWR } \
            __asm { mov DWORD PTR [x],eax } \
            __asm { mov DWORD PTR [x+4],edx }
#else
    #define Shr32xbase(x) (x >>= BASEXPWR);
#endif



void _mulnumx( PNUMBER *pa, PNUMBER b );

//----------------------------------------------------------------------------
//
//    FUNCTION: mulnumx
//
//    ARGUMENTS: pointer to a number and a second number, the
//               base is always BASEX.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa *= b.
//    This is a stub which prevents multiplication by 1, this is a big speed
//    improvement.
//
//----------------------------------------------------------------------------

void __inline mulnumx( PNUMBER *pa, PNUMBER b )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {
        // If b is not one we multiply
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 1 || (*pa)->exp != 0 )
            { 
            // pa and b are both nonone.
            _mulnumx( pa, b );
            }
        else
            {
            // if pa is one and b isn't just copy b. and adjust the sign.
            long sign = (*pa)->sign;
            DUPNUM(*pa,b);
            (*pa)->sign *= sign;
            }
        }
    else
        {
        // B is +/- 1, But we do have to set the sign.
        (*pa)->sign *= b->sign;
        }
}

//----------------------------------------------------------------------------
//
//    FUNCTION: _mulnumx
//
//    ARGUMENTS: pointer to a number and a second number, the
//               base is always BASEX.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa *= b.
//    Assumes the base is BASEX of both numbers.  This algorithm is the
//    same one you learned in gradeschool, except the base isn't 10 it's
//    BASEX.
//
//----------------------------------------------------------------------------

void _mulnumx( PNUMBER *pa, PNUMBER b )

{
    PNUMBER c=NULL;         // c will contain the result.
    PNUMBER a=NULL;         // a is the dereferenced number pointer from *pa
    MANTTYPE *ptra;         // ptra is a pointer to the mantissa of a.
    MANTTYPE *ptrb;         // ptrb is a pointer to the mantissa of b.
    MANTTYPE *ptrc;         // ptrc is a pointer to the mantissa of c.
    MANTTYPE *ptrcoffset;   // ptrcoffset, is the anchor location of the next
                            // single digit multiply partial result.
    long iadigit=0;         // Index of digit being used in the first number.
    long ibdigit=0;         // Index of digit being used in the second number.
    MANTTYPE      da=0;     // da is the digit from the fist number.
    TWO_MANTTYPE  cy=0;     // cy is the carry resulting from the addition of
                            // a multiplied row into the result.
    TWO_MANTTYPE  mcy=0;    // mcy is the resultant from a single 
                            // multiply, AND the carry of that multiply.
    long  icdigit=0;        // Index of digit being calculated in final result.

    a=*pa;

    ibdigit = a->cdigit + b->cdigit - 1;
    createnum( c,  ibdigit + 1 );
    c->cdigit = ibdigit;
    c->sign = a->sign * b->sign;

    c->exp = a->exp + b->exp;
    ptra = MANT(a);
    ptrcoffset = MANT(c);

    for (  iadigit = a->cdigit; iadigit > 0; iadigit-- )
        {
        da =  *ptra++;
        ptrb = MANT(b);
        
        // Shift ptrc, and ptrcoffset, one for each digit 
        ptrc = ptrcoffset++;

        for ( ibdigit = b->cdigit; ibdigit > 0; ibdigit-- )
            {
            cy = 0;
            mcy = Mul32x32( da, *ptrb );
            if ( mcy )
                {
                icdigit = 0;
                if ( ibdigit == 1 && iadigit == 1 )
                    {
                    c->cdigit++;
                    }
                }
            // If result is nonzero, or while result of carry is nonzero...
            while ( mcy || cy )
                {
                
                // update carry from addition(s) and multiply.
                cy += (TWO_MANTTYPE)ptrc[icdigit]+((DWORD)mcy&((DWORD)~BASEX));
                
                // update result digit from 
                ptrc[icdigit++]=(MANTTYPE)((DWORD)cy&((DWORD)~BASEX));
                
                // update carries from
                Shr32xbase( mcy );
                Shr32xbase( cy );
                }
            *ptrb++;
            *ptrc++;
            }
        }
    
    // prevent different kinds of zeros, by stripping leading duplicate zeroes.
    // digits are in order of increasing significance.
    while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
        {
        c->cdigit--;
        }

    destroynum( *pa );
    *pa=c;
}
//-----------------------------------------------------------------------------
//
//    FUNCTION: numpowlongx
//
//    ARGUMENTS: root as number power as long
//               number.
//
//    RETURN: None root is changed.
//
//    DESCRIPTION: changes numeric representation of root to
//    root ** power. Assumes base BASEX
//    decomposes the exponent into it's sums of powers of 2, so on average
//    it will take n+n/2 multiplies where n is the highest on bit.
//
//-----------------------------------------------------------------------------

void numpowlongx( IN OUT PNUMBER *proot, IN long power )

{
    PNUMBER lret=NULL;

    lret = longtonum( 1, BASEX );

    // Once the power remaining is zero we are done.
    while ( power > 0 )
        {
        // If this bit in the power decomposition is on, multiply the result
        // by the root number.
        if ( power & 1 )
            {
            mulnumx( &lret, *proot );
            }

        // multiply the root number by itself to scale for the next bit (i.e.
        // square it.
        mulnumx( proot, *proot );

        // move the next bit of the power into place.
        power >>= 1;
        }
    destroynum( *proot );
    *proot=lret;
    
}

void _divnumx( PNUMBER *pa, PNUMBER b );

//----------------------------------------------------------------------------
//
//    FUNCTION: divnumx
//
//    ARGUMENTS: pointer to a number a second number.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa /= b.
//    Assumes nRadix is the internal nRadix representation.
//    This is a stub which prevents division by 1, this is a big speed
//    improvement.
//
//----------------------------------------------------------------------------

void __inline divnumx( PNUMBER *pa, PNUMBER b )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {
        // b is not one.
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 1 || (*pa)->exp != 0 )
            {
            // pa and b are both not one.
            _divnumx( pa, b );
            }
        else
            {
            // if pa is one and b is not one, just copy b, and adjust the sign.
            long sign = (*pa)->sign;
            DUPNUM(*pa,b);
            (*pa)->sign *= sign;
            }
        }
    else
        {
        // b is one so don't divide, but set the sign.
        (*pa)->sign *= b->sign;
        }
}

//----------------------------------------------------------------------------
//
//    FUNCTION: _divnumx
//
//    ARGUMENTS: pointer to a number a second number.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa /= b.
//    Assumes nRadix is the internal nRadix representation.
//
//----------------------------------------------------------------------------

void _divnumx( PNUMBER *pa, PNUMBER b )

{
    PNUMBER a=NULL;         // a is the dereferenced number pointer from *pa
    PNUMBER c=NULL;         // c will contain the result.
    PNUMBER lasttmp = NULL; // lasttmp allows a backup when the algorithm
                            // guesses one bit too far.
    PNUMBER tmp = NULL;     // current guess being worked on for divide.
    PNUMBER rem = NULL;     // remainder after applying guess.
    long cdigits;           // count of digits for answer.
    MANTTYPE *ptrc;         // ptrc is a pointer to the mantissa of c.

    long thismax = maxout+ratio; // set a maximum number of internal digits
                                 // to shoot for in the divide.

    a=*pa;
    if ( thismax < a->cdigit )
        {
        // a has more digits than precision specified, bump up digits to shoot 
        // for.
        thismax = a->cdigit;
        }

    if ( thismax < b->cdigit )
        {
        // b has more digits than precision specified, bump up digits to shoot 
        // for.
        thismax = b->cdigit;
        }

    // Create c (the divide answer) and set up exponent and sign.
    createnum( c, thismax + 1 );
    c->exp = (a->cdigit+a->exp) - (b->cdigit+b->exp) + 1;
    c->sign = a->sign * b->sign;

    ptrc = MANT(c) + thismax;
    cdigits = 0;

    DUPNUM( rem, a );
    rem->sign = b->sign;
    rem->exp = b->cdigit + b->exp - rem->cdigit;

    while ( cdigits++ < thismax && !zernum(rem) )
        {
        long digit = 0;
        *ptrc = 0;
        while ( !lessnum( rem, b ) )
            {
            digit = 1;
            DUPNUM( tmp, b );
            destroynum( lasttmp );
            lasttmp=longtonum( 0, BASEX );
            while ( lessnum( tmp, rem ) )
                {
                destroynum( lasttmp );
                DUPNUM(lasttmp,tmp);
                addnum( &tmp, tmp, BASEX );
                digit *= 2;
                }
            if ( lessnum( rem, tmp ) )
                {    
                // too far, back up...
                destroynum( tmp );
                digit /= 2;
                tmp=lasttmp;
                lasttmp=NULL;
                }

            tmp->sign *= -1;
            addnum( &rem, tmp, BASEX ); 
            destroynum( tmp );
            destroynum( lasttmp );
            *ptrc |= digit;
            }
        rem->exp++;
        ptrc--;
        }
    cdigits--;
    if ( MANT(c) != ++ptrc )
        {
        memmove( MANT(c), ptrc, (int)(cdigits*sizeof(MANTTYPE)) );
        }

    if ( !cdigits )
        {   
        // A zero, make sure no wierd exponents creep in
        c->exp = 0;
        c->cdigit = 1;
        }
    else
        {
        c->cdigit = cdigits;
        c->exp -= cdigits;
        // prevent different kinds of zeros, by stripping leading duplicate 
        // zeroes. digits are in order of increasing significance.
        while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
            {
            c->cdigit--;
            }
        }

    destroynum( rem );

    destroynum( *pa );
    *pa=c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\calcerr.h ===
//
// CalcErr.h
//
// Defines the error codes thrown by ratpak and caught by Calculator
//
//
//  Ratpak errors are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-------+---------------------+-------------------------------+
//  |S|   R   |    Facility         |               Code            |
//  +-+-------+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail
//
//      R - Reserved - not currently used for anything
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the actual error code
//
// This format is based losely on an OLE HRESULT and is compatible with the
// SUCCEEDED and FAILED marcos as well as the HRESULT_CODE macro

// CALC_E_DIVIDEBYZERO
//
// The current operation would require a divide by zero to complete
#define CALC_E_DIVIDEBYZERO     ((DWORD)0x80000000)

// CALC_E_DOMAIN
//
// The given input is not within the domain of this function
#define CALC_E_DOMAIN           ((DWORD)0x80000001)

// CALC_E_INDEFINITE
//
// The result of this function is undefined
#define CALC_E_INDEFINITE        ((DWORD)0x80000002)

// CALC_E_POSINFINITY
//
// The result of this function is Positive Infinity.
#define CALC_E_POSINFINITY      ((DWORD)0x80000003)

// CALC_E_NEGINFINITY
//
// The result of this function is Negative Infinity
#define CALC_E_NEGINFINITY      ((DWORD)0x80000004)

// CALC_E_ABORTED
//
// The user aborted the completion of this function
#define CALC_E_ABORTED          ((DWORD)0x80000005)

// CALC_E_INVALIDRANGE
//
// The given input is within the domain of the function but is beyond
// the range for which calc can successfully compute the answer
#define CALC_E_INVALIDRANGE     ((DWORD)0x80000006)

// CALC_E_OUTOFMEMORY
//
// There is not enough free memory to complete the requested function
#define CALC_E_OUTOFMEMORY      ((DWORD)0x80000007)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\debug.c ===
//------------------------------------------------------------*
//  File name:    DEBUG.C
//
//  Description:  Debug helper code for System control panel
//                applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-1996
//  All rights reserved
//
//  History
//      10-Nov-1996 JonPa       Created it.
//
//------------------------------------------------------------*
#include <windows.h>
#include <shlwapi.h>
#include "debug.h"

///////////////////////////////////////////////////////////////
//      Constants
///////////////////////////////////////////////////////////////

#ifdef DBG_CODE

#define CCH_LABEL (sizeof(DWORD) * 2)   // 64 BITS == 8 ANSI chars

#define CB_TAG     sizeof(DWORD)
#define DW_TAG      ((DWORD)(0x434C4143))   // 'CALC'

#define DW_TAG2     ((DWORD)(0x444F4F47))   // 'GOOD'

#define CH_FILL     '*'

///////////////////////////////////////////////////////////////
//      Structures and Types
///////////////////////////////////////////////////////////////

//
// NOTE!!!!
//
// The HOBJHDR structure MUST be a multiple of 8 bytes (64bits) in len!
// otherwise this code will *FAULT* on ALPHA machines!
//

typedef struct HHO *PHHO;

struct HHO {
    PHHO    phhoNext;
    PHHO    phhoPrev;
    CHAR    szFile[CCH_LABEL];
    DWORD   iLine;
    DWORD   cBytesData;
    DWORD   dwTmp;
    DWORD   dwTag2;
};

typedef struct HHO HOBJHDR;

typedef struct {
    LPVOID  pvPtr;
    CHAR    szFile[CCH_LABEL];
    DWORD   iLine;
    CHAR    szFreedBy[CCH_LABEL];
    DWORD   iLineFreed;
} FREELOGREC, *PFREELOGREC;

///////////////////////////////////////////////////////////////
//      Global variables
///////////////////////////////////////////////////////////////

//
// Root of memory chain

HOBJHDR ghhoRoot = { &ghhoRoot, &ghhoRoot, { 'R', 'O', 'O', 'T' }, 0, sizeof(ghhoRoot) };


//
// Buffer used for OutputDebugString formatting (See DbgPrintf and DbgStopX)

TCHAR szDbgOutBuffer[1024];

//
// Buffer used for logging

#define CFLR_MAX    1024
FREELOGREC aflrFreeLog[CFLR_MAX];
PFREELOGREC g_pflrUnused = NULL;

#define NextFreeLogRec( pflr )    ((pflr >= &aflrFreeLog[CFLR_MAX-1]) ? aflrFreeLog : pflr+1)
#define PrevFreeLogRec( pflr )    ((pflr <= aflrFreeLog) ? &aflrFreeLog[CFLR_MAX-1] : pflr-1)

//---------------------------------------------------------------
//
// void DbgPrintf( LPTSTR szFmt, ... )
//
//  Formatted version of OutputDebugString
//
//  Parameters: Same as printf()
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
void DbgPrintf( LPTSTR szFmt, ... ) {
    va_list marker;

    va_start( marker, szFmt );

    wvnsprintf( szDbgOutBuffer, sizeof(szDbgOutBuffer)/sizeof(szDbgOutBuffer[0]), szFmt, marker );
    OutputDebugString( szDbgOutBuffer );

    va_end( marker );
}


//---------------------------------------------------------------
//
// void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText )
//
//  Print a string (with location id) and then break
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      szText      Text string to send to debug port
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText ) {
    int cch;

    wnsprintf( szDbgOutBuffer, sizeof(szDbgOutBuffer)/sizeof(szDbgOutBuffer[0]), TEXT("RATPAK (%hs %d) : %s\n"), mszFile, iLine, szText );

    OutputDebugString(szDbgOutBuffer);

    DebugBreak();
}

//---------------------------------------------------------------
//
// void MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes)
//
//  Debug replacement for LocalAlloc
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      uFlags      same as LocalAlloc
//      cBytes      same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes) {
    PHHO phhoNew;
    HLOCAL hMem;
    LPSTR psz;
    UINT i, cBytesAlloc;

    cBytesAlloc = cBytes;
    
    //
    // If fixed alloc...
    //
    if ((uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE)) != 0) {
        DBGSTOPX( szFile, iLine, "Attempting to allocate movable memory... Returning NULL");
        return NULL;
    }

    cBytesAlloc = cBytes + sizeof(HOBJHDR);
    
    // DWORD align Tag
    cBytesAlloc = ((cBytesAlloc + 3) & ~3);
    cBytesAlloc += CB_TAG;


    hMem = LocalAlloc( uFlags, cBytesAlloc );
    
    //
    // If a valid pointer, and it is a fixed pointer...
    //
    phhoNew = (PHHO)hMem;

    if (hMem != NULL) {


        phhoNew->phhoNext = ghhoRoot.phhoNext;
        ghhoRoot.phhoNext = phhoNew;
        phhoNew->phhoNext->phhoPrev = phhoNew;
        phhoNew->phhoPrev = &ghhoRoot;

        phhoNew->dwTag2 = DW_TAG2;

        for( psz = szFile; *psz != '\0'; psz++ );

        for( ; psz != szFile && *psz != ':' && *psz != '/' && *psz != '\\'; psz--);
        if (*psz == ':' || *psz == '/' || *psz == '\\')
            psz++;

        for( i = 0; i < CCH_LABEL; i++ ) {
            phhoNew->szFile[i] = *psz;
            if (*psz) {
                psz++;
            }
        }

        phhoNew->iLine = iLine;

        phhoNew->cBytesData = cBytes;

        phhoNew += 1;   // point phhoNew to 1st byte after structure
        
        // round up to nearest DWORD
        { LPBYTE pb = (LPBYTE)phhoNew + cBytes;

            cBytesAlloc -= CB_TAG;
            cBytes += sizeof(HOBJHDR);

            while( cBytes < cBytesAlloc ) {
                *pb++ = CH_FILL;
                cBytes++;
            }

            *((LPDWORD)pb) = DW_TAG;
        }
    }

    return (HLOCAL)phhoNew;
}

//---------------------------------------------------------------
//
// void MemFreeWorker( LPSTR szFile, int iLine, HLOCAL hMem )
//
//  Debug replacement for LocalFree
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      hMem        same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
HLOCAL MemFreeWorker( LPSTR szFile, int iLine, HLOCAL hMem ) {
    PHHO phhoMem;
    UINT uFlags;
    UINT cBytes, cBytesAlloc;
    LPSTR psz;
    INT  i;


    if (g_pflrUnused == NULL) {
        ZeroMemory( aflrFreeLog, sizeof(aflrFreeLog) );
        g_pflrUnused = aflrFreeLog;
    }

    if (hMem == NULL) {
        DBGSTOPX( szFile, iLine, "Freeing NULL handle!");
        return LocalFree(hMem);
    }

    phhoMem = (PHHO)hMem - 1;

    if (phhoMem->dwTag2 != DW_TAG2) {
        PFREELOGREC pflr;
        //
        // Our tag has been stompped on, see if we have already freed this object
        //
        for( pflr = PrevFreeLogRec(g_pflrUnused); pflr != g_pflrUnused; pflr = PrevFreeLogRec(pflr) ) {
            if (pflr->pvPtr == phhoMem) {
                DBGPRINTF((TEXT("RATPAK: Object may have already been freed by %.8hs line %d\n(that obj was allocated by %.8hs line %d)\n"),
                    pflr->szFreedBy, pflr->iLineFreed, pflr->szFile, pflr->iLine));
                break;
            }
        }

        DBGPRINTF((TEXT("RATPAK: Trashed memory object (0x%X%08X) was allocated in %.8hs line %d (%d bytes)\n"), (DWORD)(((DWORDLONG)hMem) >> 32), PtrToUlong(hMem), phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
        DBGSTOPX( szFile, iLine, "Either heap object trashed or not allocated object");
    }

    cBytes = phhoMem->cBytesData;

#if 0
    if (cBytes < 0) {
        // Not our object?
        DBGSTOPX( szFile, iLine, "Either heap object trashed or not allocated object");
        return LocalFree(hMem);
    }
#endif

    cBytes += sizeof(HOBJHDR);
    
    // DWORD align
    cBytesAlloc = (cBytes + 3) & ~3;

    { LPBYTE pb = (LPBYTE)(phhoMem);
        pb += cBytes;
        while( cBytes < cBytesAlloc ) {
            if (*pb++ != CH_FILL) {
                DBGPRINTF((TEXT("RATPAK: Trashed memory object (0x%08X) was allocated in %.8hs line %d (%d bytes)\n"),
                        hMem, phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
                DBGSTOPX( szFile, iLine, "End of structure overwritten");
            }
            cBytes++;
        }

        if (*((LPDWORD)pb) != DW_TAG) {
            DBGPRINTF((TEXT("RATPAK: Memory object (0x%08X) was not allocated!\n"), hMem));
            DBGSTOPX( szFile, iLine, "Freeing structure that was not allocated!");
            
            // Not our structure
            return LocalFree(hMem);
        }
    }
    
    // Our structure, check header
    if (phhoMem->phhoNext->phhoPrev != phhoMem || phhoMem->phhoPrev->phhoNext != phhoMem ) {
        DBGPRINTF((TEXT("RATPAK: Orphaned memory object (0x%08X) was allocated in %.8hs line %d (%d bytes)\n"),
                hMem, phhoMem->szFile, phhoMem->iLine, phhoMem->cBytesData));
        DBGSTOPX( szFile, iLine, "Attempting to free orphaned memory object");
    }

    phhoMem->phhoPrev->phhoNext = phhoMem->phhoNext;
    phhoMem->phhoNext->phhoPrev = phhoMem->phhoPrev;
    
    //
    // Log this free, incase we try and free it twice
    //
    
    // Mark as freed
    phhoMem->dwTag2 = 0;
    
    // Remember who alloc'ed obj
    g_pflrUnused->pvPtr = phhoMem;
    CopyMemory( g_pflrUnused->szFile, phhoMem->szFile, sizeof(g_pflrUnused->szFile) );
    g_pflrUnused->iLine = phhoMem->iLine;
    
    // Remember who freed the obj
    for( psz = szFile; *psz != '\0'; psz++ );

    for( ; psz != szFile && *psz != ':' && *psz != '/' && *psz != '\\'; psz--);
    if (*psz == ':' || *psz == '/' || *psz == '\\')
        psz++;

    for( i = 0; i < CCH_LABEL; i++ ) {
        g_pflrUnused->szFreedBy[i] = *psz;
        if (*psz) {
            psz++;
        }
    }
    g_pflrUnused->iLineFreed = iLine;
    
    // Point roaming ptr to next record and mark as unused
    g_pflrUnused = NextFreeLogRec(g_pflrUnused);
    ZeroMemory( g_pflrUnused, sizeof(*g_pflrUnused) );

    return LocalFree(phhoMem);
}

//---------------------------------------------------------------
//
//  void MemExitCheckWorker() {
//
//  Debug replacement for LocalFree
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      hMem        same as LocalAlloc
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//---------------------------------------------------------------
void MemExitCheckWorker( void ) {
    PHHO phho;

    for( phho = ghhoRoot.phhoNext; phho != &ghhoRoot; phho = phho->phhoNext ) {
        DBGPRINTF((TEXT("RATPAK: Exiting with out freeing object (Header=0x%08X) allocated in %.8hs line %d (%d bytes)\n"),
                phho, phho->szFile, phho->iLine, phho->cBytesData));
    }
}

#endif // DBG_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\exp.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           exp.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains exp, and log functions for rationals
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

//-----------------------------------------------------------------------------
//
//  FUNCTION: exprat
//
//  ARGUMENTS: x PRAT representation of number to exponentiate
//
//  RETURN: exp  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___
//   \  ]                                               X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j      j+1
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//-----------------------------------------------------------------------------

void _exprat( PRAT *px )

{
    CREATETAYLOR();

    addnum(&(pret->pp),num_one, BASEX); 
    addnum(&(pret->pq),num_one, BASEX); 
    DUPRAT(thisterm,pret);

    n2=longtonum(0L, BASEX);

    do    {
        NEXTTERM(*px, INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) && !fhalt );

    DESTROYTAYLOR();
}

void exprat( PRAT *px )

{
    PRAT pwr=NULL;
    PRAT pint=NULL;
    long intpwr;

    if ( rat_gt( *px, rat_max_exp ) || rat_lt( *px, rat_min_exp ) )
        {
        // Don't attempt exp of anything large.
        throw( CALC_E_DOMAIN );
        }

    DUPRAT(pwr,rat_exp);
    DUPRAT(pint,*px);

    intrat(&pint);

    intpwr = rattolong(pint);
    ratpowlong( &pwr, intpwr );

    subrat(px,pint);
    
    // It just so happens to be an integral power of e.
    if ( rat_gt( *px, rat_negsmallest ) && rat_lt( *px, rat_smallest ) )
        {
        DUPRAT(*px,pwr);
        }
    else
        {
        _exprat(px);
        mulrat(px,pwr);
        }

    destroyrat( pwr );
    destroyrat( pint );
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: lograt, _lograt
//
//  ARGUMENTS: x PRAT representation of number to logarithim
//
//  RETURN: log  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___
//   \  ]                                             j*(1-X)
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j      j+1
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   Number is scaled between one and e_to_one_half prior to taking the
//   log. This is to keep execution time from exploding.
//
//
//-----------------------------------------------------------------------------

void _lograt( PRAT *px )

{
    CREATETAYLOR();

    createrat(thisterm);
    
    // sub one from x
    (*px)->pq->sign *= -1;
    addnum(&((*px)->pp),(*px)->pq, BASEX);
    (*px)->pq->sign *= -1;

    DUPRAT(pret,*px);
    DUPRAT(thisterm,*px);

    n2=longtonum(1L, BASEX);
    (*px)->pp->sign *= -1;

    do    {
        NEXTTERM(*px, MULNUM(n2) INC(n2) DIVNUM(n2));
        TRIMTOP(*px);
        } while ( !SMALL_ENOUGH_RAT( thisterm ) && !fhalt );

    DESTROYTAYLOR();
}


void lograt( PRAT *px )

{
    BOOL fneglog;
    PRAT pwr=NULL;            // pwr is the large scaling factor.
    PRAT offset=NULL;        // offset is the incremental scaling factor.
    
    
    // Check for someone taking the log of zero or a negative number.
    if ( rat_le( *px, rat_zero ) )
        {
        throw( CALC_E_DOMAIN );
        }
    
    // Get number > 1, for scaling
    fneglog = rat_lt( *px, rat_one );
    if ( fneglog )
        {
        // WARNING: This is equivalent to doing *px = 1 / *px
        PNUMBER pnumtemp=NULL;
        pnumtemp = (*px)->pp;
        (*px)->pp = (*px)->pq;
        (*px)->pq = pnumtemp;
        }
    
    // Scale the number within BASEX factor of 1, for the large scale.
    // log(x*2^(BASEXPWR*k)) = BASEXPWR*k*log(2)+log(x)
    if ( LOGRAT2(*px) > 1 )
        {
        // Take advantage of px's base BASEX to scale quickly down to 
        // a reasonable range.
        long intpwr;
        intpwr=LOGRAT2(*px)-1;
        (*px)->pq->exp += intpwr;
        pwr=longtorat(intpwr*BASEXPWR);
        mulrat(&pwr,ln_two);
        // ln(x+e)-ln(x) looks close to e when x is close to one using some
        // expansions.  This means we can trim past precision digits+1.
        TRIMTOP(*px);
        }
    else
        {
        DUPRAT(pwr,rat_zero);
        }

    DUPRAT(offset,rat_zero);
    // Scale the number between 1 and e_to_one_half, for the small scale.
    while ( rat_gt( *px, e_to_one_half ) && !fhalt )
        {
        divrat( px, e_to_one_half );
        addrat( &offset, rat_one );
        }

    _lograt(px);
    
    // Add the large and small scaling factors, take into account
    // small scaling was done in e_to_one_half chunks.
    divrat(&offset,rat_two);
    addrat(&pwr,offset);
    
    // And add the resulting scaling factor to the answer.
    addrat(px,pwr);

    trimit(px);
    
    // If number started out < 1 rescale answer to negative.
    if ( fneglog )
        {
        (*px)->pp->sign *= -1;
        }

    destroyrat(pwr);
}
    
void log10rat( PRAT *px )

{
    lograt(px);
    divrat(px,ln_ten);
}


//---------------------------------------------------------------------------
//
//  FUNCTION: powrat
//
//  ARGUMENTS: PRAT *px, and PRAT y
//
//  RETURN: none, sets *px to *px to the y.
//
//  EXPLANATION: This uses x^y=e(y*ln(x)), or a more exact calculation where
//  y is an integer.
//  Assumes, all checking has been done on validity of numbers.
//
//
//---------------------------------------------------------------------------

void powrat( PRAT *px, PRAT y )

{
    PRAT podd=NULL;
    PRAT plnx=NULL;
    long sign=1;
    sign=( (*px)->pp->sign * (*px)->pq->sign );
    
    // Take the absolute value
    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;

    if ( zerrat( *px ) )
        {
        // *px is zero.
        if ( rat_lt( y, rat_zero ) )
            {
            throw( CALC_E_DOMAIN );
            }
        else if ( zerrat( y ) )
            {
            // *px and y are both zero, special case a 1 return.
            DUPRAT(*px,rat_one);
            // Ensure sign is positive.
            sign = 1;
            }
        }
    else 
        {
        PRAT pxint=NULL;
        DUPRAT(pxint,*px);
        subrat(&pxint,rat_one);
        if ( rat_gt( pxint, rat_negsmallest ) && 
             rat_lt( pxint, rat_smallest ) && ( sign == 1 ) )
            {
            // *px is one, special case a 1 return.
            DUPRAT(*px,rat_one);
            // Ensure sign is positive.
            sign = 1;
            }
        else
            {

            // Only do the exp if the number isn't zero or one
            DUPRAT(podd,y);
            fracrat(&podd);
            if ( rat_gt( podd, rat_negsmallest ) && rat_lt( podd, rat_smallest ) )
                {
                // If power is an integer let ratpowlong deal with it.
                PRAT iy = NULL;
                long inty;
                DUPRAT(iy,y);
                subrat(&iy,podd);
                inty = rattolong(iy);

                DUPRAT(plnx,*px);
                lograt(&plnx);
                mulrat(&plnx,iy);
                if ( rat_gt( plnx, rat_max_exp ) || rat_lt( plnx, rat_min_exp ) )
                    {
                    // Don't attempt exp of anything large or small.A
                    destroyrat(plnx);
                    destroyrat(iy);
                    throw( CALC_E_DOMAIN );
                    }
                destroyrat(plnx);
                ratpowlong(px,inty);
                if ( ( inty & 1 ) == 0 )
                    {
                    sign=1;
                    }
                destroyrat(iy);
                }
            else
                {
                // power is a fraction
                if ( sign == -1 )
                    {
                    // And assign the sign after computations, if appropriate.
                    if ( rat_gt( y, rat_neg_one ) && rat_lt( y, rat_zero ) )
                        {
                        // Check to see if reciprocal is odd.
                        DUPRAT(podd,rat_one);
                        divrat(&podd,y);
                        // Only interested in the absval for determining oddness.
                        podd->pp->sign = 1;
                        podd->pq->sign = 1;
                        divrat(&podd,rat_two);
                        fracrat(&podd);
                        addrat(&podd,podd);
                        subrat(&podd,rat_one);
                        if ( rat_lt( podd, rat_zero ) )
                            {
                            // Negative nonodd root of negative number.
                            destroyrat(podd);
                            throw( CALC_E_DOMAIN );
                            }
                        }
                    else
                        {
                        // Negative nonodd power of negative number.
                        destroyrat(podd);
                        throw( CALC_E_DOMAIN );
                        }

                     }
                 else
                     {
                     // If the exponent is not odd disregard the sign.
                     sign = 1;
                     }
    
                 lograt( px );
                 mulrat( px, y );
                 exprat( px );
                 }
             destroyrat(podd);
             }
        destroyrat(pxint);
        }
    (*px)->pp->sign *= sign;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\itrans.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           itrans.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains inverse sin, cos, tan functions for rationals
//
//  Special Information
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

void ascalerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    switch ( angletype )
        {
    case ANGLE_RAD:
        break;
    case ANGLE_DEG:
        divrat( pa, two_pi );
        mulrat( pa, rat_360 );
        break;
    case ANGLE_GRAD:
        divrat( pa, two_pi );
        mulrat( pa, rat_400 );
        break;
        }
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: asinrat, _asinrat
//
//  ARGUMENTS: x PRAT representation of number to take the inverse
//    sine of
//  RETURN: asin  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2 2
//   \  ]                                            (2j+1) X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)*(2j+3)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   If abs(x) > 0.85 then an alternate form is used
//      pi/2-sgn(x)*asin(sqrt(1-x^2)
//
//
//-----------------------------------------------------------------------------

void _asinrat( PRAT *px )

{
    CREATETAYLOR();
    DUPRAT(pret,*px); 
    DUPRAT(thisterm,*px);
    DUPNUM(n2,num_one);

    do
        {
        NEXTTERM(xx,MULNUM(n2) MULNUM(n2) 
            INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        }
    while ( !SMALL_ENOUGH_RAT( thisterm ) );
    DESTROYTAYLOR();
}

void asinanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    asinrat( pa );
    ascalerat( pa, angletype );
}

void asinrat( PRAT *px )

{
    long sgn;
    PRAT pret=NULL;
    PRAT phack=NULL;

    sgn = (*px)->pp->sign* (*px)->pq->sign;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    
    // Nasty hack to avoid the really bad part of the asin curve near +/-1.
    DUPRAT(phack,*px);
    subrat(&phack,rat_one);
    // Since *px might be epsilon near zero we must set it to zero.
    if ( rat_le(phack,rat_smallest) && rat_ge(phack,rat_negsmallest) )
        {
        destroyrat(phack);
        DUPRAT( *px, pi_over_two );
        }
    else
        {
        destroyrat(phack);
        if ( rat_gt( *px, pt_eight_five ) )
            {
            if ( rat_gt( *px, rat_one ) )
                {
                subrat( px, rat_one );
                if ( rat_gt( *px, rat_smallest ) )
                    {
                	throw( CALC_E_DOMAIN );
                    }
                else
                    {
                	DUPRAT(*px,rat_one);
                    }
                }
            DUPRAT(pret,*px);
            mulrat( px, pret );
            (*px)->pp->sign *= -1;
            addrat( px, rat_one );
            rootrat( px, rat_two );
            _asinrat( px );
            (*px)->pp->sign *= -1;
            addrat( px, pi_over_two );
            destroyrat(pret);
            }
        else
            {
            _asinrat( px );
            }
        }
    (*px)->pp->sign = sgn;
    (*px)->pq->sign = 1;
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: acosrat, _acosrat
//
//  ARGUMENTS: x PRAT representation of number to take the inverse
//    cosine of
//  RETURN: acos  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2 2
//   \  ]                                            (2j+1) X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)*(2j+3)
//   /__]
//   j=0
//
//   thisterm  = 1 ;  and stop when thisterm < precision used.
//           0                              n
//
//   In this case pi/2-asin(x) is used.  At least for now _acosrat isn't
//      called.
//
//-----------------------------------------------------------------------------

void acosanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    acosrat( pa );
    ascalerat( pa, angletype );
}

void _acosrat( PRAT *px )

{
    CREATETAYLOR();

    createrat(thisterm); 
    thisterm->pp=longtonum( 1L, BASEX );
    thisterm->pq=longtonum( 1L, BASEX ); 

    DUPNUM(n2,num_one);

    do
        {
        NEXTTERM(xx,MULNUM(n2) MULNUM(n2) 
            INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        }
    while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void acosrat( PRAT *px )

{
    long sgn;

    sgn = (*px)->pp->sign*(*px)->pq->sign;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    
    if ( rat_equ( *px, rat_one ) )
        {
        if ( sgn == -1 )
            {
            DUPRAT(*px,pi);
            }
        else
            {
            DUPRAT( *px, rat_zero );
            }
        }
    else
        {
        (*px)->pp->sign = sgn;
        asinrat( px );
        (*px)->pp->sign *= -1;
        addrat(px,pi_over_two);
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: atanrat, _atanrat
//
//  ARGUMENTS: x PRAT representation of number to take the inverse
//              hyperbolic tangent of
//
//  RETURN: atanh of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2
//   \  ]                                            (2j)*X (-1^j)
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   If abs(x) > 0.85 then an alternate form is used
//      asin(x/sqrt(q+x^2))
//
//   And if abs(x) > 2.0 then this form is used.
//
//   pi/2 - atan(1/x)
//
//-----------------------------------------------------------------------------

void atananglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    atanrat( pa );
    ascalerat( pa, angletype );
}

void _atanrat( PRAT *px )

{
    CREATETAYLOR();

    DUPRAT(pret,*px); 
    DUPRAT(thisterm,*px);

    DUPNUM(n2,num_one);

    xx->pp->sign *= -1;

    do    {
        NEXTTERM(xx,MULNUM(n2) INC(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void atan2rat( PRAT *py, PRAT x )

{
    if ( rat_gt( x, rat_zero ) )
        {
        if ( !zerrat( (*py) ) )
            {
            divrat( py, x);
            atanrat( py );
            }
        }
    else if ( rat_lt( x, rat_zero ) )
        {
        if ( rat_gt( (*py), rat_zero ) )
            {
            divrat( py, x);
            atanrat( py );
            addrat( py, pi );
            }
        else if ( rat_lt( (*py), rat_zero ) )
            {
            divrat( py, x);
            atanrat( py );
            subrat( py, pi );
            }
        else // (*py) == 0
            {
            DUPRAT( *py, pi );
            }
        }
    else // x == 0
        {
        if ( !zerrat( (*py) ) )
            {
            int sign;
            sign=(*py)->pp->sign*(*py)->pq->sign;
            DUPRAT( *py, pi_over_two );
            (*py)->pp->sign = sign;
            }
        else // (*py) == 0
            {
            DUPRAT( *py, rat_zero );
            }
        }
}

void atanrat( PRAT *px )

{
    long sgn;
    PRAT tmpx=NULL;

    sgn = (*px)->pp->sign * (*px)->pq->sign;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    
    if ( rat_gt( (*px), pt_eight_five ) )
        {
        if ( rat_gt( (*px), rat_two ) )
            {
            (*px)->pp->sign = sgn;
            (*px)->pq->sign = 1;
            DUPRAT(tmpx,rat_one);
            divrat(&tmpx,(*px));
            _atanrat(&tmpx);
            tmpx->pp->sign = sgn;
            tmpx->pq->sign = 1;
            DUPRAT(*px,pi_over_two);
            subrat(px,tmpx);
            destroyrat( tmpx );
            }
        else 
            {
            (*px)->pp->sign = sgn;
            DUPRAT(tmpx,*px);
            mulrat( &tmpx, *px );
            addrat( &tmpx, rat_one );
            rootrat( &tmpx, rat_two );
            divrat( px, tmpx );
            destroyrat( tmpx );
            asinrat( px );
            (*px)->pp->sign = sgn;
            (*px)->pq->sign = 1;
            }
        }
    else
        {
        (*px)->pp->sign = sgn;
        (*px)->pq->sign = 1;
        _atanrat( px );
        }
    if ( rat_gt( *px, pi_over_two ) )
        {
        subrat( px, pi );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\fact.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           fact.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains fact(orial) and supporting _gamma functions.
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

#define ABSRAT(x) (((x)->pp->sign=1),((x)->pq->sign=1))
#define NEGATE(x) ((x)->pp->sign *= -1)

//-----------------------------------------------------------------------------
//
//  FUNCTION: factrat, _gamma, gamma
//
//  ARGUMENTS:  x PRAT representation of number to take the sine of
//
//  RETURN: factorial of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//      n
//     ___    2j
//   n \  ]  A       1          A
//  A   \   -----[ ---- - ---------------]
//      /   (2j)!  n+2j   (n+2j+1)(2j+1)
//     /__]
//     j=0
//
//                        / oo
//                        |    n-1 -x     __
//  This was derived from |   x   e  dx = |
//                        |               | (n) { = (n-1)! for +integers}
//                        / 0
//
//  GregSte showed the above series to be within precision if A was chosen
//  big enough.
//                          A    n  precision
//  Based on the relation ne  = A 10            A was chosen as
//
//             precision
//  A = ln(Base         /n)+1
//  A += n*ln(A)  This is close enough for precision > base and n < 1.5
//
//
//-----------------------------------------------------------------------------


void _gamma( PRAT *pn )

{
    PRAT factorial=NULL;
    PNUMBER count=NULL;
    PRAT tmp=NULL;
    PRAT one_pt_five=NULL;
    PRAT a=NULL;
    PRAT a2=NULL;
    PRAT term=NULL;
    PRAT sum=NULL;
    PRAT err=NULL;
    PRAT mpy=NULL;
    PRAT ratprec = NULL;
    PRAT ratRadix = NULL;
    long oldprec;
    
    // Set up constants and initial conditions
    oldprec = maxout;
    ratprec = longtorat( oldprec );
    
    // Find the best 'A' for convergence to the required precision.
    a=longtorat( nRadix );
    lograt(&a);
    mulrat(&a,ratprec);

    // Really is -ln(n)+1, but -ln(n) will be < 1 
    // if we scale n between 0.5 and 1.5
    addrat(&a,rat_two);
    DUPRAT(tmp,a);
    lograt(&tmp);
    mulrat(&tmp,*pn);
    addrat(&a,tmp);
    addrat(&a,rat_one);
    
    // Calculate the necessary bump in precision and up the precision.
    // The following code is equivalent to 
    // maxout += ln(exp(a)*pow(a,n+1.5))-ln(nRadix));
    DUPRAT(tmp,*pn);
    one_pt_five=longtorat( 3L );
    divrat( &one_pt_five, rat_two );
    addrat( &tmp, one_pt_five );
    DUPRAT(term,a);
    powrat( &term, tmp );
    DUPRAT( tmp, a );
    exprat( &tmp );
    mulrat( &term, tmp );
    lograt( &term );
    ratRadix = longtorat( nRadix );
    DUPRAT(tmp,ratRadix);
    lograt( &tmp );
    subrat( &term, tmp );
    maxout += rattolong( term );
    
    // Set up initial terms for series, refer to series in above comment block.
    DUPRAT(factorial,rat_one); // Start factorial out with one
    count = longtonum( 0L, BASEX );

    DUPRAT(mpy,a);
    powrat(&mpy,*pn);
    // a2=a^2
    DUPRAT(a2,a);
    mulrat(&a2,a);
    
    // sum=(1/n)-(a/(n+1))
    DUPRAT(sum,rat_one);
    divrat(&sum,*pn);
    DUPRAT(tmp,*pn);
    addrat(&tmp,rat_one);
    DUPRAT(term,a);
    divrat(&term,tmp);
    subrat(&sum,term);

    DUPRAT(err,ratRadix);
    NEGATE(ratprec);
    powrat(&err,ratprec);
    divrat(&err,ratRadix);

    // Just get something not tiny in term
    DUPRAT(term, rat_two );    

    // Loop until precision is reached, or asked to halt.
    while ( !zerrat( term ) && rat_gt( term, err) && !fhalt )
        {
        addrat(pn,rat_two);
        
        // WARNING: mixing numbers and  rationals here.  
        // for speed and efficiency.
        INC(count);
        mulnumx(&(factorial->pp),count);
        INC(count)
        mulnumx(&(factorial->pp),count);

        divrat(&factorial,a2);

        DUPRAT(tmp,*pn);
        addrat( &tmp, rat_one );
        destroyrat(term);
        createrat(term);
        DUPNUM(term->pp,count);
        DUPNUM(term->pq,num_one);
        addrat( &term, rat_one );
        mulrat( &term, tmp );
        DUPRAT(tmp,a);
        divrat( &tmp, term );

        DUPRAT(term,rat_one);
        divrat( &term, *pn);
        subrat( &term, tmp);
        
        divrat (&term, factorial);
        addrat( &sum, term);
        ABSRAT(term);
        }
    
    // Multiply by factor.
    mulrat( &sum, mpy );
    
    // And cleanup
    maxout = oldprec;
    destroyrat(ratprec);
    destroyrat(err);
    destroyrat(term);
    destroyrat(a);
    destroyrat(a2);
    destroyrat(tmp);
    destroyrat(one_pt_five);

    destroynum(count);

    destroyrat(factorial);
    destroyrat(*pn);
    DUPRAT(*pn,sum);
    destroyrat(sum);
}

void factrat( PRAT *px )

{
    PRAT fact = NULL;
    PRAT frac = NULL;
    PRAT neg_rat_one = NULL;
    DUPRAT(fact,rat_one);

    DUPRAT(neg_rat_one,rat_one);
    neg_rat_one->pp->sign *= -1;

    DUPRAT( frac, *px );
    fracrat( &frac );

    // Check for negative integers and throw an error.
    if ( ( zerrat(frac) || ( LOGRATRADIX(frac) <= -maxout ) ) && 
		( (*px)->pp->sign * (*px)->pq->sign == -1 ) )
		{
        throw CALC_E_DOMAIN;
		}
    while ( rat_gt(  *px, rat_zero ) && !fhalt && 
        ( LOGRATRADIX(*px) > -maxout ) )
        {
        mulrat( &fact, *px );
        subrat( px, rat_one );
        }
    
    // Added to make numbers 'close enough' to integers use integer factorial.
    if ( LOGRATRADIX(*px) <= -maxout )
        {
        DUPRAT((*px),rat_zero);
        intrat(&fact);
        }

    while ( rat_lt(  *px, neg_rat_one ) && !fhalt )
        {
        addrat( px, rat_one );
        divrat( &fact, *px );
        }

    if ( rat_neq( *px, rat_zero ) )
        {
        addrat( px, rat_one );
        _gamma( px );
        mulrat( px, fact );
        }
    else
        {
        DUPRAT(*px,fact);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\logic.c ===
//---------------------------------------------------------------------------
//  Package Title  ratpak
//  File           num.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-99 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains routines for and, or, xor, not and other support
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <ratpak.h>

void lshrat( PRAT *pa, PRAT b )

{
    PRAT pwr=NULL;
    long intb;

    intrat(pa);
    if ( !zernum( (*pa)->pp ) )
        {
        // If input is zero we're done.
        if ( rat_gt( b, rat_max_exp ) )
            {
            // Don't attempt lsh of anything big
            throw( CALC_E_DOMAIN );
            }
        intb = rattolong(b);
        DUPRAT(pwr,rat_two);
        ratpowlong(&pwr,intb);
        mulrat(pa,pwr);
        destroyrat(pwr);
        }
}

void rshrat( PRAT *pa, PRAT b )

{
    PRAT pwr=NULL;
    long intb;

    intrat(pa);
    if ( !zernum( (*pa)->pp ) )
        { 
        // If input is zero we're done.
        if ( rat_lt( b, rat_min_exp ) )
            {
            // Don't attempt rsh of anything big and negative.
            throw( CALC_E_DOMAIN );
            }
        intb = rattolong(b);
        DUPRAT(pwr,rat_two);
        ratpowlong(&pwr,intb);
        divrat(pa,pwr);
        destroyrat(pwr);
       }
}

void boolrat( PRAT *pa, PRAT b, int func );
void boolnum( PNUMBER *pa, PNUMBER b, int func );


enum {
    FUNC_AND,
    FUNC_OR,
    FUNC_XOR
} BOOL_FUNCS;

void andrat( PRAT *pa, PRAT b )

{
    boolrat( pa, b, FUNC_AND );
}

void orrat( PRAT *pa, PRAT b )

{
    boolrat( pa, b, FUNC_OR );
}

void xorrat( PRAT *pa, PRAT b )

{
    boolrat( pa, b, FUNC_XOR );
}

//---------------------------------------------------------------------------
//
//    FUNCTION: boolrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa op= b;
//
//---------------------------------------------------------------------------

void boolrat( PRAT *pa, PRAT b, int func )

{
    PRAT tmp=NULL;
    intrat( pa );
    DUPRAT(tmp,b);
    intrat( &tmp );

    boolnum( &((*pa)->pp), tmp->pp, func );
    destroyrat(tmp);
}

//---------------------------------------------------------------------------
//
//    FUNCTION: boolnum
//
//    ARGUMENTS: pointer to a number a second number
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa &= b.
//    nRadix doesn't matter for logicals.
//    WARNING: Assumes numbers are unsigned.
//
//---------------------------------------------------------------------------

void boolnum( PNUMBER *pa, PNUMBER b, int func )

{
    PNUMBER c=NULL;
    PNUMBER a=NULL;
    MANTTYPE *pcha;
    MANTTYPE *pchb;
    MANTTYPE *pchc;
    long cdigits;
    long mexp;
    MANTTYPE da;
    MANTTYPE db;

    a=*pa;
    cdigits = max( a->cdigit+a->exp, b->cdigit+b->exp ) -
            min( a->exp, b->exp );
    createnum( c, cdigits );
    c->exp = min( a->exp, b->exp );
    mexp = c->exp;
    c->cdigit = cdigits;
    pcha = MANT(a);
    pchb = MANT(b);
    pchc = MANT(c);
    for ( ;cdigits > 0; cdigits--, mexp++ )
        {
        da = ( ( ( mexp >= a->exp ) && ( cdigits + a->exp - c->exp > 
                    (c->cdigit - a->cdigit) ) ) ? 
                    *pcha++ : 0 );
        db = ( ( ( mexp >= b->exp ) && ( cdigits + b->exp - c->exp > 
                    (c->cdigit - b->cdigit) ) ) ? 
                    *pchb++ : 0 );
        switch ( func )
            {
        case FUNC_AND:
            *pchc++ = da & db;
            break;
        case FUNC_OR:
            *pchc++ = da | db;
            break;
        case FUNC_XOR:
            *pchc++ = da ^ db;
            break;
            }
        }
    c->sign = a->sign;
    while ( c->cdigit > 1 && *(--pchc) == 0 )
        {
        c->cdigit--;
        }
    destroynum( *pa );
    *pa=c;
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: modrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes pointer.
//
//    DESCRIPTION: Does the rational equivalent of frac(*pa);
//
//-----------------------------------------------------------------------------

void modrat( PRAT *pa, PRAT b )

{
    PRAT tmp = NULL;

    if ( zerrat( b ) )
		{
		throw CALC_E_INDEFINITE;
		}
    DUPRAT(tmp,b);

    mulnumx( &((*pa)->pp), tmp->pq );
    mulnumx( &(tmp->pp), (*pa)->pq );
    remnum( &((*pa)->pp), tmp->pp, BASEX );
    mulnumx( &((*pa)->pq), tmp->pq );
    
    //Get *pa back in the integer over integer form.
    RENORMALIZE(*pa);

    destroyrat( tmp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\itransh.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           itransh.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-97 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//    Contains inverse hyperbolic sin, cos, and tan functions.
//
//  Special Information
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>


//-----------------------------------------------------------------------------
//
//  FUNCTION: asinhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the inverse
//    hyperbolic sine of
//  RETURN: asinh of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___                                                   2 2
//   \  ]                                           -(2j+1) X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j+2)*(2j+3)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   For abs(x) < .85, and
//
//   asinh(x) = log(x+sqrt(x^2+1))
//
//   For abs(x) >= .85
//
//-----------------------------------------------------------------------------

void asinhrat( PRAT *px )

{
    PRAT neg_pt_eight_five = NULL;

    DUPRAT(neg_pt_eight_five,pt_eight_five);
    neg_pt_eight_five->pp->sign *= -1;
    if ( rat_gt( *px, pt_eight_five) || rat_lt( *px, neg_pt_eight_five) )
        {
        PRAT ptmp = NULL;
        DUPRAT(ptmp,(*px)); 
        mulrat(&ptmp,*px);
        addrat(&ptmp,rat_one);
        rootrat(&ptmp,rat_two);
        addrat(px,ptmp);
        lograt(px);
        destroyrat(ptmp);
        }
    else
        {
        CREATETAYLOR();
        xx->pp->sign *= -1;

        DUPRAT(pret,(*px)); 
        DUPRAT(thisterm,(*px));

        DUPNUM(n2,num_one);

        do
            {
            NEXTTERM(xx,MULNUM(n2) MULNUM(n2) 
                INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
            }
        while ( !SMALL_ENOUGH_RAT( thisterm ) );

        DESTROYTAYLOR();
        }
    destroyrat(neg_pt_eight_five);
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: acoshrat
//
//  ARGUMENTS:  x PRAT representation of number to take the inverse
//    hyperbolic cose of
//  RETURN: acosh of x in PRAT form.
//
//  EXPLANATION: This uses 
//
//   acosh(x)=ln(x+sqrt(x^2-1))
//
//   For x >= 1
//
//-----------------------------------------------------------------------------

void acoshrat( PRAT *px )

{
    if ( rat_lt( *px, rat_one ) )
        {
        throw CALC_E_DOMAIN;
        }
    else
        {
        PRAT ptmp = NULL;
        DUPRAT(ptmp,(*px)); 
        mulrat(&ptmp,*px);
        subrat(&ptmp,rat_one);
        rootrat(&ptmp,rat_two);
        addrat(px,ptmp);
        lograt(px);
        destroyrat(ptmp);
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: atanhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the inverse
//              hyperbolic tangent of
//
//  RETURN: atanh of x in PRAT form.
//
//  EXPLANATION: This uses
//
//             1     x+1
//  atanh(x) = -*ln(----)
//             2     x-1
//
//-----------------------------------------------------------------------------

void atanhrat( PRAT *px )

{
    PRAT ptmp = NULL;
    DUPRAT(ptmp,(*px)); 
    subrat(&ptmp,rat_one);
    addrat(px,rat_one);
    divrat(px,ptmp);
    (*px)->pp->sign *= -1;
    lograt(px);
    divrat(px,rat_two);
    destroyrat(ptmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\num.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak                                                   
//  File           num.c                                                    
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)            
//  Copyright      (C) 1995-97 Microsoft                                    
//  Date           01-16-95                                                 
//                                                                          
//                                                                          
//  Description                                                             
//                                                                          
//     Contains number routines for add, mul, div, rem and other support       
//  and longs.                                                              
//                                                                          
//  Special Information                                                     
//                                                                          
//                                                                          
//-----------------------------------------------------------------------------

#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <ratpak.h>

//----------------------------------------------------------------------------
//
//    FUNCTION: addnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa += b.
//    Assumes nRadix is the base of both numbers.
//
//    ALGORITHM: Adds each digit from least significant to most
//    significant.
//
//
//----------------------------------------------------------------------------

void _addnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix );

void __inline addnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    if ( b->cdigit > 1 || b->mant[0] != 0 )
        {    // If b is zero we are done.
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 0 )
            { // pa and b are both nonzero.
            _addnum( pa, b, nRadix );
            }
        else
            { // if pa is zero and b isn't just copy b.
            DUPNUM(*pa,b);
            }
        }
}

void _addnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    PNUMBER c=NULL;     // c will contain the result.
    PNUMBER a=NULL;     // a is the dereferenced number pointer from *pa
    MANTTYPE *pcha;     // pcha is a pointer to the mantissa of a.
    MANTTYPE *pchb;     // pchb is a pointer to the mantissa of b.
    MANTTYPE *pchc;     // pchc is a pointer to the mantissa of c.
    long cdigits;       // cdigits is the max count of the digits results
                        // used as a counter.
    long mexp;          // mexp is the exponent of the result.
    MANTTYPE  da;       // da is a single 'digit' after possible padding.
    MANTTYPE  db;       // db is a single 'digit' after possible padding.
    MANTTYPE  cy=0;     // cy is the value of a carry after adding two 'digits'
    long  fcompla = 0;  // fcompla is a flag to signal a is negative.
    long  fcomplb = 0;  // fcomplb is a flag to signal b is negative.

    a=*pa;
    
    
    // Calculate the overlap of the numbers after alignment, this includes
    // necessary padding 0's
    cdigits = max( a->cdigit+a->exp, b->cdigit+b->exp ) -
            min( a->exp, b->exp );

    createnum( c, cdigits + 1 );
    c->exp = min( a->exp, b->exp );
    mexp = c->exp;
    c->cdigit = cdigits;
    pcha = MANT(a);
    pchb = MANT(b);
    pchc = MANT(c);
    
    // Figure out the sign of the numbers
    if ( a->sign != b->sign )
        {
        cy = 1;
        fcompla = ( a->sign == -1 );
        fcomplb = ( b->sign == -1 );
        }
    
    // Loop over all the digits, real and 0 padded. Here we know a and b are
    // aligned 
    for ( ;cdigits > 0; cdigits--, mexp++ )
        {
        
        // Get digit from a, taking padding into account.
        da = ( ( ( mexp >= a->exp ) && ( cdigits + a->exp - c->exp > 
                    (c->cdigit - a->cdigit) ) ) ? 
                    *pcha++ : 0 );
        // Get digit from b, taking padding into account.
        db = ( ( ( mexp >= b->exp ) && ( cdigits + b->exp - c->exp > 
                    (c->cdigit - b->cdigit) ) ) ? 
                    *pchb++ : 0 );
        
        // Handle complementing for a and b digit. Might be a better way, but
        // haven't found it yet.
        if ( fcompla )
            {
            da = (MANTTYPE)(nRadix) - 1 - da;
            }
        if ( fcomplb )
            {
            db = (MANTTYPE)(nRadix) - 1 - db;
            }
        
        // Update carry as necessary
        cy = da + db + cy;
        *pchc++ = (MANTTYPE)(cy % (MANTTYPE)nRadix);
        cy /= (MANTTYPE)nRadix;
        }
    
    // Handle carry from last sum as extra digit
    if ( cy && !(fcompla || fcomplb) )
        {
        *pchc++ = cy;
        c->cdigit++;
        }
    
    // Compute sign of result
    if ( !(fcompla || fcomplb) )
        {
        c->sign = a->sign;
        }
    else
        {
        if ( cy )
            {
            c->sign = 1;
            }
        else
            {
            // In this particular case an overflow or underflow has occoured 
            // and all the digits need to be complemented, at one time an 
            // attempt to handle this above was made, it turned out to be much 
            // slower on average.
            c->sign = -1;
            cy = 1;
            for ( ( cdigits = c->cdigit ), (pchc = MANT(c) ); 
                cdigits > 0; 
                cdigits-- )
                {
                cy = (MANTTYPE)nRadix - (MANTTYPE)1 - *pchc + cy;
                *pchc++ = (MANTTYPE)( cy % (MANTTYPE)nRadix );
                cy /= (MANTTYPE)nRadix;
                }
            }
        }
    
    // Remove leading zeroes, remember digits are in order of
    // increasing significance. i.e. 100 would be 0,0,1
    while ( c->cdigit > 1 && *(--pchc) == 0 )
        {
        c->cdigit--;
        }
    destroynum( *pa );
    *pa=c;
}

//----------------------------------------------------------------------------
//
//    FUNCTION: mulnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa *= b.
//    Assumes nRadix is the nRadix of both numbers.  This algorithm is the
//    same one you learned in gradeschool.
//
//----------------------------------------------------------------------------

void _mulnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix );

void __inline mulnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {    // If b is one we don't multiply exactly.
        if ( (*pa)->cdigit > 1 || (*pa)->mant[0] != 1 || (*pa)->exp != 0 )
            { // pa and b are both nonone.
            _mulnum( pa, b, nRadix );
            }
        else
            { // if pa is one and b isn't just copy b, and adjust the sign.
            long sign = (*pa)->sign;
            DUPNUM(*pa,b);
            (*pa)->sign *= sign;
            }
        }
    else
        {    // But we do have to set the sign.
        (*pa)->sign *= b->sign;
        }
}

void _mulnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    PNUMBER c=NULL;         // c will contain the result.
    PNUMBER a=NULL;         // a is the dereferenced number pointer from *pa
    MANTTYPE *pcha;         // pcha is a pointer to the mantissa of a.
    MANTTYPE *pchb;         // pchb is a pointer to the mantissa of b.
    MANTTYPE *pchc;         // pchc is a pointer to the mantissa of c.
    MANTTYPE *pchcoffset;   // pchcoffset, is the anchor location of the next
                            // single digit multiply partial result.
    long iadigit = 0;       // Index of digit being used in the first number.
    long ibdigit = 0;       // Index of digit being used in the second number.
    MANTTYPE  da = 0;       // da is the digit from the fist number.
    TWO_MANTTYPE  cy = 0;   // cy is the carry resulting from the addition of
                            // a multiplied row into the result.
    TWO_MANTTYPE  mcy = 0;  // mcy is the resultant from a single 
                            // multiply, AND the carry of that multiply.
    long  icdigit = 0;      // Index of digit being calculated in final result.

    a=*pa;
    ibdigit = a->cdigit + b->cdigit - 1;
    createnum( c,  ibdigit + 1 );
    c->cdigit = ibdigit;
    c->sign = a->sign * b->sign;

    c->exp = a->exp + b->exp;
    pcha = MANT(a);
    pchcoffset = MANT(c);

    for (  iadigit = a->cdigit; iadigit > 0; iadigit-- )
        {
        da =  *pcha++;
        pchb = MANT(b);
        
        // Shift pchc, and pchcoffset, one for each digit 
        pchc = pchcoffset++;

        for ( ibdigit = b->cdigit; ibdigit > 0; ibdigit-- )
            {
            cy = 0;
            mcy = (TWO_MANTTYPE)da * *pchb;
            if ( mcy )
                {
                icdigit = 0;
                if ( ibdigit == 1 && iadigit == 1 )
                    {
                    c->cdigit++;
                    }
                }
            // If result is nonzero, or while result of carry is nonzero...
            while ( mcy || cy )
                {
                
                // update carry from addition(s) and multiply.
                cy += (TWO_MANTTYPE)pchc[icdigit]+(mcy%(TWO_MANTTYPE)nRadix);
                
                // update result digit from 
                pchc[icdigit++]=(MANTTYPE)(cy%(TWO_MANTTYPE)nRadix);
                
                // update carries from
                mcy /= (TWO_MANTTYPE)nRadix;
                cy /= (TWO_MANTTYPE)nRadix;
                }
            *pchb++;
            *pchc++;
            }
        }
    
    // prevent different kinds of zeros, by stripping leading duplicate zeroes.
    // digits are in order of increasing significance.
    while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
        {
        c->cdigit--;
        }

    destroynum( *pa );
    *pa=c;
}


//----------------------------------------------------------------------------
//
//    FUNCTION: remnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa %= b.
//            Repeatedly subtracts off powers of 2 of b until *pa < b.
//
//
//----------------------------------------------------------------------------

void remnum( PNUMBER *pa, PNUMBER b, long nRadix )

{
    PNUMBER tmp = NULL;     // tmp is the working remainder.
    PNUMBER lasttmp = NULL; // lasttmp is the last remainder which worked.
    
    // Once *pa is less than b, *pa is the remainder.
    while ( !lessnum( *pa, b ) && !fhalt )
        {
        DUPNUM( tmp, b );
        if ( lessnum( tmp, *pa ) )
            {
            // Start off close to the right answer for subtraction.
            tmp->exp = (*pa)->cdigit+(*pa)->exp - tmp->cdigit;
            if ( MSD(*pa) <= MSD(tmp) )
                {
                // Don't take the chance that the numbers are equal.
                tmp->exp--;
                }
            }

        destroynum( lasttmp );
        lasttmp=longtonum( 0, nRadix );

        while ( lessnum( tmp, *pa ) ) 
            {
            DUPNUM( lasttmp, tmp );
            addnum( &tmp, tmp, nRadix );
            }

        if ( lessnum( *pa, tmp ) )
            {    
            // too far, back up...
            destroynum( tmp );
            tmp=lasttmp;
            lasttmp=NULL;
            }
        
        // Subtract the working remainder from the remainder holder.
        tmp->sign = -1*(*pa)->sign;
        addnum( pa, tmp, nRadix ); 

        destroynum( tmp );
        destroynum( lasttmp );

        } 
}


//---------------------------------------------------------------------------
//
//    FUNCTION: divnum
//
//    ARGUMENTS: pointer to a number a second number, and the
//               nRadix.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the number equivalent of *pa /= b.
//    Assumes nRadix is the nRadix of both numbers.
//
//---------------------------------------------------------------------------

void _divnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix );

void __inline divnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    if ( b->cdigit > 1 || b->mant[0] != 1 || b->exp != 0 )
        {    
    	// b is not one
        _divnum( pa, b, nRadix );
        }
    else
        {    // But we do have to set the sign.
        (*pa)->sign *= b->sign;
        }
}

void _divnum( PNUMBER *pa, PNUMBER b, unsigned long nRadix )

{
    PNUMBER a = NULL;
    PNUMBER c = NULL;
    PNUMBER tmp = NULL;
    PNUMBER rem = NULL;
    PLINKEDLIST pll = NULL;
    PLINKEDLIST pllrover = NULL;
    long digit;
    long cdigits;
    BOOL bret;
    MANTTYPE *ptrc;
    long thismax = maxout+2;

    a=*pa;
    if ( thismax < a->cdigit )
        {
        thismax = a->cdigit;
        }

    if ( thismax < b->cdigit )
        {
        thismax = b->cdigit;
        }

    createnum( c, thismax + 1 );
    c->exp = (a->cdigit+a->exp) - (b->cdigit+b->exp) + 1;
    c->sign = a->sign * b->sign;

    ptrc = MANT(c) + thismax;
    cdigits = 0;
    DUPNUM( rem, a );
    DUPNUM( tmp, b );
    tmp->sign = a->sign;
    rem->exp = b->cdigit + b->exp - rem->cdigit;
    
    // Build a table of multiplications of the divisor, this is quicker for 
    // more than nRadix 'digits'
    pll = (PLINKEDLIST)zmalloc( sizeof( LINKEDLIST ) );
    pll->pnum = longtonum( 0L, nRadix );
    pll->llprev = NULL;
    for ( cdigits = 1; cdigits < (long)nRadix; cdigits++ )
        {
        pllrover = (PLINKEDLIST)zmalloc( sizeof( LINKEDLIST ) );
        pllrover->pnum=NULL;
        DUPNUM( pllrover->pnum, pll->pnum );
        addnum( &(pllrover->pnum), tmp, nRadix );
        pllrover->llprev = pll;
        pll = pllrover;
        }
    destroynum( tmp );
    cdigits = 0;
    while ( cdigits++ < thismax && !zernum(rem) )
        {
        pllrover = pll;
        digit = nRadix - 1;
        do    {
            bret = lessnum( rem, pllrover->pnum );
            } while ( bret && --digit && ( pllrover = pllrover->llprev ) );
        if ( digit )
            {
            pllrover->pnum->sign *= -1;
            addnum( &rem, pllrover->pnum, nRadix );
            pllrover->pnum->sign *= -1;
            }
        rem->exp++;
        *ptrc-- = (MANTTYPE)digit;
        }
    cdigits--;
    if ( MANT(c) != ++ptrc )
        {
        memmove( MANT(c), ptrc, (int)(cdigits*sizeof(MANTTYPE)) );
        }
    
    // Cleanup table structure
    pllrover = pll;
    do    {
        pll = pllrover->llprev;
        destroynum( pllrover->pnum );
        zfree( pllrover );
        } while ( pllrover = pll );

    if ( !cdigits )
        {
        c->cdigit = 1;
        c->exp = 0;
        }
    else
        {
        c->cdigit = cdigits;
        c->exp -= cdigits;
        while ( c->cdigit > 1 && MANT(c)[c->cdigit-1] == 0 )
            {
            c->cdigit--;
            }
        }
    destroynum( rem );

    destroynum( *pa );
    *pa=c;
}


//---------------------------------------------------------------------------
//
//    FUNCTION: equnum
//
//    ARGUMENTS: two numbers.
//
//    RETURN: Boolean
//
//    DESCRIPTION: Does the number equivalent of ( a == b )
//    Only assumes that a and b are the same nRadix.
//
//---------------------------------------------------------------------------

BOOL equnum( PNUMBER a, PNUMBER b )

{
    long diff;
    MANTTYPE *pa;
    MANTTYPE *pb;
    long cdigits;
    long ccdigits;
    MANTTYPE  da;
    MANTTYPE  db;

    diff = ( a->cdigit + a->exp ) - ( b->cdigit + b->exp );
    if ( diff < 0 )
        {
        // If the exponents are different, these are different numbers.
        return( FALSE );
        }
    else
        {
        if ( diff > 0 )
            {
            // If the exponents are different, these are different numbers.
            return( FALSE );
            }
        else
            {
            // OK the exponents match.
            pa = MANT(a);
            pb = MANT(b);
            pa += a->cdigit - 1;
            pb += b->cdigit - 1;
            cdigits = max( a->cdigit, b->cdigit );
            ccdigits = cdigits;
            
            // Loop over all digits until we run out of digits or there is a
            // difference in the digits.
            for ( ;cdigits > 0; cdigits-- )
                {
                da = ( (cdigits > (ccdigits - a->cdigit) ) ? 
                    *pa-- : 0 );
                db = ( (cdigits > (ccdigits - b->cdigit) ) ? 
                    *pb-- : 0 );
                if ( da != db )
                    {
                    return( FALSE );
                    }
                }
            
            // In this case, they are equal.
            return( TRUE );
            }
        }
}

//---------------------------------------------------------------------------
//
//    FUNCTION: lessnum
//
//    ARGUMENTS: two numbers.
//
//    RETURN: Boolean
//
//    DESCRIPTION: Does the number equivalent of ( abs(a) < abs(b) )
//    Only assumes that a and b are the same nRadix, WARNING THIS IS AN.
//    UNSIGNED COMPARE!
//
//---------------------------------------------------------------------------

BOOL lessnum( PNUMBER a, PNUMBER b )

{
    long diff;
    MANTTYPE *pa;
    MANTTYPE *pb;
    long cdigits;
    long ccdigits;
    MANTTYPE  da;
    MANTTYPE  db;


    diff = ( a->cdigit + a->exp ) - ( b->cdigit + b->exp );
    if ( diff < 0 )
        {
        // The exponent of a is less than b
        return( TRUE );
        }
    else
        {
        if ( diff > 0 )
            {
            return( FALSE );
            }
        else
            {
            pa = MANT(a);
            pb = MANT(b);
            pa += a->cdigit - 1;
            pb += b->cdigit - 1;
            cdigits = max( a->cdigit, b->cdigit );
            ccdigits = cdigits;
            for ( ;cdigits > 0; cdigits-- )
                {
                da = ( (cdigits > (ccdigits - a->cdigit) ) ? 
                    *pa-- : 0 );
                db = ( (cdigits > (ccdigits - b->cdigit) ) ? 
                    *pb-- : 0 );
                diff = da-db;
                if ( diff )
                    {
                    return( diff < 0 );
                    }
                }
            // In this case, they are equal.
            return( FALSE );
            }
        }
}

//----------------------------------------------------------------------------
//
//    FUNCTION: zernum
//
//    ARGUMENTS: number
//
//    RETURN: Boolean
//
//    DESCRIPTION: Does the number equivalent of ( !a )
//
//----------------------------------------------------------------------------

BOOL zernum( PNUMBER a )

{
    long length;
    MANTTYPE *pcha;
    length = a->cdigit;
    pcha = MANT( a );
    
    // loop over all the digits until you find a nonzero or until you run 
    // out of digits
    while ( length-- > 0 )
        {
        if ( *pcha++ )
            {
            // One of the digits isn't zero, therefore the number isn't zero
            return( FALSE );
            }
        }
    // All of the digits are zero, therefore the number is zero
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\ratconst.h ===
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_one= {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_two= {
	1,
	1,
	0,
	{  2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_five= {
	1,
	1,
	0,
	{  5,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_six= {
	1,
	1,
	0,
	{  6,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_num_ten= {
	1,
	1,
	0,
	{  10,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_smallest = {
	1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_smallest = {
	1,
	4,
	0,
	{  0, 190439170, 901055854, 10097,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_negsmallest = {
	-1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_negsmallest = {
	1,
	4,
	0,
	{  0, 190439170, 901055854, 10097,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_pt_eight_five = {
	1,
	1,
	0,
	{  85,}
};
NUMBER init_q_pt_eight_five = {
	1,
	1,
	0,
	{  100,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_six = {
	1,
	1,
	0,
	{  6,}
};
NUMBER init_q_rat_six = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_two = {
	1,
	1,
	0,
	{  2,}
};
NUMBER init_q_rat_two = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_zero = {
	1,
	1,
	0,
	{  0,}
};
NUMBER init_q_rat_zero = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_one = {
	1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_one = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_neg_one = {
	-1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_neg_one = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_half = {
	1,
	1,
	0,
	{  1,}
};
NUMBER init_q_rat_half = {
	1,
	1,
	0,
	{  2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_ten = {
	1,
	1,
	0,
	{  10,}
};
NUMBER init_q_rat_ten = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_pi = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
NUMBER init_q_pi = {
	1,
	6,
	0,
	{  1288380402, 1120116153, 1860424692, 1944118326, 1583591604, 2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_two_pi = {
	1,
	6,
	0,
	{  251055792, 567796700, 1773504224, 1198217877, 428852897, 17,}
};
NUMBER init_q_two_pi = {
	1,
	6,
	0,
	{  1288380402, 1120116153, 1860424692, 1944118326, 1583591604, 2,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_pi_over_two = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
NUMBER init_q_pi_over_two = {
	1,
	6,
	0,
	{  429277156, 92748659, 1573365737, 1740753005, 1019699561, 5,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_one_pt_five_pi = {
	1,
	6,
	0,
	{  1241201312, 270061909, 1051574664, 1924965045, 1340320627, 70,}
};
NUMBER init_q_one_pt_five_pi = {
	1,
	6,
	0,
	{  1579671539, 1837970263, 1067644340, 523549916, 2119366659, 14,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_e_to_one_half = {
	1,
	6,
	0,
	{  256945612, 216219427, 223516738, 477442596, 581063757, 23,}
};
NUMBER init_q_e_to_one_half = {
	1,
	6,
	0,
	{  1536828363, 698484484, 1127331835, 224219346, 245499408, 14,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_exp = {
	1,
	6,
	0,
	{  943665199, 1606559160, 1094967530, 1759391384, 1671799163, 1123581,}
};
NUMBER init_q_rat_exp = {
	1,
	6,
	0,
	{  879242208, 2022880100, 617392930, 1374929092, 1367479163, 413342,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_ln_ten = {
	1,
	6,
	0,
	{  2086268922, 165794492, 1416063951, 1851428830, 1893239400, 65366841,}
};
NUMBER init_q_ln_ten = {
	1,
	6,
	0,
	{  26790652, 564532679, 783998273, 216030448, 1564709968, 28388458,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_ln_two = {
	1,
	6,
	0,
	{  1789230241, 1057927868, 715399197, 908801241, 1411265331, 3,}
};
NUMBER init_q_ln_two = {
	1,
	6,
	0,
	{  1559869847, 1930657510, 1228561531, 219003871, 593099283, 5,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rad_to_deg = {
	1,
	6,
	0,
	{  2127722024, 1904928383, 2016479213, 2048947859, 1578647346, 492,}
};
NUMBER init_q_rad_to_deg = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rad_to_grad = {
	1,
	6,
	0,
	{  2125526288, 684931327, 570267400, 129125085, 1038224725, 547,}
};
NUMBER init_q_rad_to_grad = {
	1,
	6,
	0,
	{  125527896, 283898350, 1960493936, 1672850762, 1288168272, 8,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_qword = {
	1,
	3,
	0,
	{  2147483647, 2147483647, 3,}
};
NUMBER init_q_rat_qword = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_dword = {
	1,
	2,
	0,
	{  2147483647, 1,}
};
NUMBER init_q_rat_dword = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_min_long = {
	-1,
	2,
	0,
	{  2147483647, 1,}
};
NUMBER init_q_rat_min_long = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_word = {
	1,
	1,
	0,
	{  65535,}
};
NUMBER init_q_rat_word = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_byte = {
	1,
	1,
	0,
	{  255,}
};
NUMBER init_q_rat_byte = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_400 = {
	1,
	1,
	0,
	{  400,}
};
NUMBER init_q_rat_400 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_360 = {
	1,
	1,
	0,
	{  360,}
};
NUMBER init_q_rat_360 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_200 = {
	1,
	1,
	0,
	{  200,}
};
NUMBER init_q_rat_200 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_180 = {
	1,
	1,
	0,
	{  180,}
};
NUMBER init_q_rat_180 = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_max_exp = {
	1,
	1,
	0,
	{  100000,}
};
NUMBER init_q_rat_max_exp = {
	1,
	1,
	0,
	{  1,}
};
// Autogenerated by _dumprawrat in support.c
NUMBER init_p_rat_min_exp = {
	-1,
	1,
	0,
	{  100000,}
};
NUMBER init_q_rat_min_exp = {
	1,
	1,
	0,
	{  1,}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\ratpak.h ===
#pragma warning( disable : 4200 )
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           ratpak.h
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-99 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Infinite precision math package header file, if you use ratpak.lib you
//  need to include this header.
//
//-----------------------------------------------------------------------------

#include "CalcErr.h"

#define BASEXPWR 31L    // Internal log2(BASEX)
#define BASEX 0x80000000 // Internal nRadix used in calculations, hope to raise
                        // this to 2^32 after solving scaling problems with
                        // overflow detection esp. in mul

typedef unsigned long MANTTYPE;
typedef unsigned __int64 TWO_MANTTYPE;

enum eNUMOBJ_FMT {
    FMT_FLOAT,        // returns floating point, or exponential if number is too big
    FMT_SCIENTIFIC,    // always returns scientific notation
    FMT_ENGINEERING    // always returns engineering notation such that exponent is a multiple of 3

};

enum eANGLE_TYPE {
    ANGLE_DEG,    // Calculate trig using 360 degrees per revolution
    ANGLE_RAD,    // Calculate trig using 2 pi  radians per revolution
    ANGLE_GRAD    // Calculate trig using 400 gradients per revolution

};

typedef enum eNUMOBJ_FMT NUMOBJ_FMT;
typedef enum eANGLE_TYPE ANGLE_TYPE;

typedef int BOOL;

//-----------------------------------------------------------------------------
//
//  NUMBER type is a representation of a generic sized generic nRadix number
//
//-----------------------------------------------------------------------------

typedef struct _number
    {
    long sign;        // The sign of the mantissa, +1, or -1
    long cdigit;    // The number of digits, or what passes for digits in the
                    // nRadix being used.
    long exp;       // The offset of digits from the nRadix point
                    // (decimal point in nRadix 10)
    MANTTYPE mant[0];
                    // This is actually allocated as a continuation of the
                    // NUMBER structure.
    } NUMBER, *PNUMBER, **PPNUMBER;


//-----------------------------------------------------------------------------
//
//  RAT type is a representation nRadix  on 2 NUMBER types.
//  pp/pq, where pp and pq are pointers to integral NUMBER types.
//
//-----------------------------------------------------------------------------

typedef struct _rat
    {
    PNUMBER pp;
    PNUMBER pq;
    } RAT, *PRAT;

//-----------------------------------------------------------------------------
//
//  LINKEDLIST is an aid for division, it contains foreward and reverse links
//  to a list of NUMBERS.
//
//-----------------------------------------------------------------------------

typedef struct _linkedlist
    {
    PNUMBER pnum;
    struct _linkedlist *llnext;
    struct _linkedlist *llprev;
    } LINKEDLIST, *PLINKEDLIST;




#if !defined( TRUE )
#define TRUE 1
#endif

#if !defined( FALSE )
#define FALSE 0
#endif

#define MAX_LONG_SIZE 33    // Base 2 requires 32 'digits'

//-----------------------------------------------------------------------------
//
// List of useful constants for evaluation, note this list needs to be
// initialized.
//
//-----------------------------------------------------------------------------

extern PNUMBER num_one;
extern PNUMBER num_two;
extern PNUMBER num_five;
extern PNUMBER num_six;
extern PNUMBER num_nRadix;
extern PNUMBER num_ten;

extern PRAT ln_ten;
extern PRAT ln_two;
extern PRAT rat_zero;
extern PRAT rat_neg_one;
extern PRAT rat_one;
extern PRAT rat_two;
extern PRAT rat_six;
extern PRAT rat_half;
extern PRAT rat_ten;
extern PRAT pt_eight_five;
extern PRAT pi;
extern PRAT pi_over_two;
extern PRAT two_pi;
extern PRAT one_pt_five_pi;
extern PRAT e_to_one_half;
extern PRAT rat_exp;
extern PRAT rad_to_deg;
extern PRAT rad_to_grad;
extern PRAT rat_qword;
extern PRAT rat_dword;
extern PRAT rat_word;
extern PRAT rat_byte;
extern PRAT rat_360;
extern PRAT rat_400;
extern PRAT rat_180;
extern PRAT rat_200;
extern PRAT rat_nRadix;
extern PRAT rat_smallest;
extern PRAT rat_negsmallest;
extern PRAT rat_max_exp;
extern PRAT rat_min_exp;
extern PRAT rat_min_long;


// MANT returns a long pointer to the mantissa of number 'a'
#define MANT(a) ((a)->mant)

// DUPNUM Duplicates a number taking care of allocation and internals
#define DUPNUM(a,b) destroynum(a);createnum( a, b->cdigit ); \
    memcpy( a, b, (int)( sizeof( NUMBER ) + ( b->cdigit )*(sizeof(MANTTYPE)) ) );

// DUPRAT Duplicates a rational taking care of allocation and internals
#define DUPRAT(a,b) destroyrat(a);createrat(a);DUPNUM((a)->pp,(b)->pp);DUPNUM((a)->pq,(b)->pq);

// LOG*RADIX calculates the integral portion of the log of a number in
// the base currently being used, only accurate to within ratio

#define LOGNUMRADIX(pnum) (((pnum)->cdigit+(pnum)->exp)*ratio)
#define LOGRATRADIX(prat) (LOGNUMRADIX((prat)->pp)-LOGNUMRADIX((prat)->pq))

// LOG*2 calculates the integral portion of the log of a number in
// the internal base being used, only accurate to within ratio

#define LOGNUM2(pnum) ((pnum)->cdigit+(pnum)->exp)
#define LOGRAT2(prat) (LOGNUM2((prat)->pp)-LOGNUM2((prat)->pq))

#if defined( DEBUG )
//-----------------------------------------------------------------------------
//
//   Debug versions of rational number creation and destruction routines.
//   used for debugging allocation errors.
//
//-----------------------------------------------------------------------------

#define createrat(y) y=_createrat();fprintf( stderr, "createrat %lx %s file= %s, line= %d\n", y, # y, __FILE__, __LINE__ )
#define destroyrat(x) fprintf( stderr, "destroyrat %lx file= %s, line= %d\n", x, __FILE__, __LINE__ ),_destroyrat(x),x=NULL
#define createnum(y,x) y=_createnum(x);fprintf( stderr, "createnum %lx %s file= %s, line= %d\n", y, # y, __FILE__, __LINE__ );
#define destroynum(x) fprintf( stderr, "destroynum %lx file= %s, line= %d\n", x, __FILE__, __LINE__ ),_destroynum(x),x=NULL
#else
#define createrat(y) y=_createrat()
#define destroyrat(x) _destroyrat(x),x=NULL
#define createnum(y,x) y=_createnum(x)
#define destroynum(x) _destroynum(x),x=NULL
#endif

//-----------------------------------------------------------------------------
//
//   Defines for checking when to stop taylor series expansions due to
//   precision satisfaction.
//
//-----------------------------------------------------------------------------

// RENORMALIZE, gets the exponents non-negative.
#define RENORMALIZE(x) if ( (x)->pp->exp < 0 ) { \
	(x)->pq->exp -= (x)->pp->exp; \
	(x)->pp->exp = 0; \
	} \
	if ( (x)->pq->exp < 0 ) { \
	(x)->pp->exp -= (x)->pq->exp; \
	(x)->pq->exp = 0; \
	}

// TRIMNUM ASSUMES the number is in nRadix form NOT INTERNAL BASEX!!!
#define TRIMNUM(x) if ( !ftrueinfinite ) { \
		long trim = (x)->cdigit - maxout-ratio;\
            if ( trim > 1 ) \
                { \
memmove( MANT(x), &(MANT(x)[trim]), sizeof(MANTTYPE)*((x)->cdigit-trim) ); \
                (x)->cdigit -= trim; \
                (x)->exp += trim; \
                } \
            }
// TRIMTOP ASSUMES the number is in INTERNAL BASEX!!!
#define TRIMTOP(x) if ( !ftrueinfinite ) { \
		long trim = (x)->pp->cdigit - (maxout/ratio) - 2;\
            if ( trim > 1 ) \
                { \
memmove( MANT((x)->pp), &(MANT((x)->pp)[trim]), sizeof(MANTTYPE)*((x)->pp->cdigit-trim) ); \
                (x)->pp->cdigit -= trim; \
                (x)->pp->exp += trim; \
                } \
            trim = min((x)->pp->exp,(x)->pq->exp);\
            (x)->pp->exp -= trim;\
            (x)->pq->exp -= trim;\
            }

#define CLOSE_ENOUGH_RAT(a,b) ( ( ( ( ( a->pp->cdigit + a->pp->exp ) - \
( a->pq->cdigit + a->pq->exp ) ) - ( ( b->pp->cdigit + b->pp->exp ) - \
( b->pq->cdigit + b->pq->exp ) ) ) * ratio > maxout ) || fhalt )

#define SMALL_ENOUGH_RAT(a) (zernum(a->pp) || ( ( ( a->pq->cdigit + a->pq->exp ) - ( a->pp->cdigit + a->pp->exp ) - 1 ) * ratio > maxout ) || fhalt )

//-----------------------------------------------------------------------------
//
//   Defines for setting up taylor series expansions for infinite precision
//   functions.
//
//-----------------------------------------------------------------------------

#define CREATETAYLOR() PRAT xx=NULL;\
    PNUMBER n2=NULL; \
    PRAT pret=NULL; \
    PRAT thisterm=NULL; \
    DUPRAT(xx,*px); \
    mulrat(&xx,*px); \
    createrat(pret); \
    pret->pp=longtonum( 0L, BASEX ); \
    pret->pq=longtonum( 0L, BASEX );

#define DESTROYTAYLOR() destroynum( n2 ); \
    destroyrat( xx );\
    destroyrat( thisterm );\
    destroyrat( *px );\
    trimit(&pret);\
    *px=pret;

// SUM(a,b) is the rational equivalent of a += b
#define SUM(a,b) addnum( &a, b, BASEX);

// INC(a) is the rational equivalent of a++
// Check to see if we can avoid doing this the hard way.
#define INC(a) if ( a->mant[0] < BASEX - 1 ) \
    { \
    a->mant[0]++; \
    } \
    else \
    { \
    addnum( &a, num_one, BASEX); \
    }

#define MSD(x) ((x)->mant[(x)->cdigit-1])
// MULNUM(b) is the rational equivalent of thisterm *= b where thisterm is
// a rational and b is a number, NOTE this is a mixed type operation for
// efficiency reasons.
#define MULNUM(b) mulnumx( &(thisterm->pp), b);

// DIVNUM(b) is the rational equivalent of thisterm /= b where thisterm is
// a rational and b is a number, NOTE this is a mixed type operation for
// efficiency reasons.
#define DIVNUM(b) mulnumx( &(thisterm->pq), b);

// NEXTTERM(p,d) is the rational equivalent of
// thisterm *= p
// d    <d is usually an expansion of operations to get thisterm updated.>
// pret += thisterm
#define NEXTTERM(p,d) mulrat(&thisterm,p);d addrat( &pret, thisterm )

// ONEOVER(x) is the rational equivalent of x=1/x
#define ONEOVER(x) {PNUMBER __tmpnum;__tmpnum=x->pp;x->pp=x->pq;x->pq=__tmpnum;}

#ifndef DOS
#   if defined(ALTERNATE_ALLOCATION)
//-----------------------------------------------------------------------------
//
//   WARNING if you change the allocation package you need to rebuild
//   ratpak.lib
//
//-----------------------------------------------------------------------------

extern void *zmalloc( IN unsigned long sze );
extern void zfree( IN double *pd );

#   else

#       ifdef USE_HEAPALLOC
//
// NT Heap macros.  Calling process must create a heap with HeapCreate()
//
#           define zmalloc(a)   HeapAlloc( hheap, 0, a )
#           define zfree(a)     HeapFree( hheap, 0, a )
#       elif DBG
//
// Debug heap workers
//
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
#           define zmalloc(a)   MemAllocWorker( __FILE__, __LINE__, LPTR, a )
#           define zfree(a)     MemFreeWorker( __FILE__, __LINE__, a )

#       else
//
// Windows heap macros
//
#           define zmalloc(a)   LocalAlloc( LPTR, a )
#           define zfree(a)     LocalFree( a )

#       endif

#   endif
#endif

//-----------------------------------------------------------------------------
//
//   External variables used in the math package.
//
//-----------------------------------------------------------------------------

extern BOOL fhalt;	// contains the command to halt execution if true.
extern BOOL fparserror;	// set to true if last innum ended in error, else false.
extern NUMOBJ_FMT fmt;	// contains the format to use
extern TCHAR szDec[5];     // extern decimal point representation
extern long nRadix;     // extern nRadix used for input and output routines
extern unsigned char ftrueinfinite; // set to true to allow infinite precision
                             // don't use unless you know what you are doing
                      // used to help decide when to stop calculating.
extern long maxout;   // Maximum digits nRadix <nRadix> to use for precision.
                      // used to help decide when to stop calculating.

extern long ratio;    // Internally calculated ratio of internal nRadix
                      // v.s. nRadix used for input output number routines

extern LPTSTR oom;     // Out of memory error message

typedef void ERRFUNC( LPTSTR szErr );
typedef ERRFUNC *LPERRFUNC;
extern LPERRFUNC glpErrFunc;    // This function will get called if an error
                        // occurs inside of ratpak.



#ifndef DOS
extern HANDLE hheap;  // hheap is a pointer used in allocation, ratpak.lib
                      // users responsibility to make sure this is set up
                      // for use with Heap{Alloc,Free} routines.
#endif


//-----------------------------------------------------------------------------
//
//   External functions defined in the math package.
//
//-----------------------------------------------------------------------------

// Call whenever radix changes and at start of program. (Obsolete)
extern void changeRadix( IN long nRadix );
// Call whenever precision changes and at start of program. (Obsolete)
extern void changePrecision( IN long nPrecision );

// Call whenever either nRadix or nPrecision changes, is smarter about
// recalculating constants.
// (Prefered replacement for the ChangeRadix and ChangePrecision calls.)
extern void ChangeConstants( IN long nRadix, IN long nPrecision );

extern BOOL equnum( IN PNUMBER a, IN PNUMBER b );     // returns true of a == b
extern BOOL lessnum( IN PNUMBER a, IN PNUMBER b );    // returns true of a < b
extern BOOL zernum( IN PNUMBER a );                // returns true of a == 0
extern BOOL zerrat( IN PRAT a );                   // returns true if a == 0/q
extern TCHAR *putnum(OUT int* pcchNum,  IN OUT PNUMBER *ppnum, IN int fmt );

// returns a text representation of a (*pa)
extern TCHAR *putrat(OUT int* pcchNum, IN OUT PRAT *pa, IN unsigned long nRadix, IN int fmt );

extern long longpow( IN unsigned long nRadix, IN long power );
extern long numtolong( IN PNUMBER pnum, IN unsigned long nRadix );
extern long rattolong( IN PRAT prat );
extern PNUMBER _createnum( IN long size );         // returns an empty number structure with size digits
extern PNUMBER nRadixxtonum( IN PNUMBER a, IN unsigned long nRadix );
extern PNUMBER binomial( IN long lroot, IN PNUMBER digitnum, IN PNUMBER c, IN PLINKEDLIST pll, IN unsigned long nRadix );
extern PNUMBER gcd( IN PNUMBER a, IN PNUMBER b );
extern PNUMBER innum( IN LPTSTR buffer );           // takes a text representation of a number and returns a number.

// takes a text representation of a number as a mantissa with sign and an exponent with sign.
extern PRAT inrat( IN BOOL fMantIsNeg, IN LPTSTR pszMant, IN BOOL fExpIsNeg, IN LPTSTR pszExp );

extern PNUMBER longfactnum( IN long inlong, IN unsigned long nRadix );
extern PNUMBER longprodnum( IN long start, IN long stop, IN unsigned long nRadix );
extern PNUMBER longtonum( IN long inlong, IN unsigned long nRadix );
extern PNUMBER numtonRadixx( IN PNUMBER a, IN unsigned long nRadix, IN long ratio );

// creates a empty/undefined rational representation (p/q)
extern PRAT _createrat( void );

// returns a new rat structure with the acos of x->p/x->q taking into account
// angle type
extern void acosanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

// returns a new rat structure with the acosh of x->p/x->q
extern void acoshrat( IN OUT PRAT *px );

// returns a new rat structure with the acos of x->p/x->q
extern void acosrat( IN OUT PRAT *px );

// returns a new rat structure with the asin of x->p/x->q taking into account
// angle type
extern void asinanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

extern void asinhrat( IN OUT PRAT *px );
// returns a new rat structure with the asinh of x->p/x->q

// returns a new rat structure with the asin of x->p/x->q
extern void asinrat( IN OUT PRAT *px );

// returns a new rat structure with the atan of x->p/x->q taking into account
// angle type
extern void atananglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

// returns a new rat structure with the atanh of x->p/x->q
extern void atanhrat( IN OUT PRAT *px );

// returns a new rat structure with the atan of x->p/x->q
extern void atanrat( IN OUT PRAT *px );

// returns a new rat structure with the atan2 of x->p/x->q, y->p/y->q
extern void atan2rat( IN OUT PRAT *py, IN PRAT y );

// returns a new rat structure with the cosh of x->p/x->q
extern void coshrat( IN OUT PRAT *px );

// returns a new rat structure with the cos of x->p/x->q
extern void cosrat( IN OUT PRAT *px );

// returns a new rat structure with the cos of x->p/x->q taking into account
// angle type
extern void cosanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

// returns a new rat structure with the exp of x->p/x->q this should not be called explicitly.
extern void _exprat( IN OUT PRAT *px );

// returns a new rat structure with the exp of x->p/x->q
extern void exprat( IN OUT PRAT *px );

// returns a new rat structure with the log base 10 of x->p/x->q
extern void log10rat( IN OUT PRAT *px );

// returns a new rat structure with the natural log of x->p/x->q
extern void lograt( IN OUT PRAT *px );

extern PRAT longtorat( IN long inlong );
extern PRAT numtorat( IN PNUMBER pin, IN unsigned long nRadix );
extern PRAT realtorat( IN double real );

extern void sinhrat( IN OUT PRAT *px );
extern void sinrat( IN OUT PRAT *px );

// returns a new rat structure with the sin of x->p/x->q taking into account
// angle type
extern void sinanglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

extern void tanhrat( IN OUT PRAT *px );
extern void tanrat( IN OUT PRAT *px );

// returns a new rat structure with the tan of x->p/x->q taking into account
// angle type
extern void tananglerat( IN OUT PRAT *px, IN ANGLE_TYPE angletype );

extern void _destroynum( IN PNUMBER pnum );
extern void _destroyrat( IN PRAT prat );
extern void addnum( IN OUT PNUMBER *pa, IN PNUMBER b, unsigned long nRadix );
extern void addrat( IN OUT PRAT *pa, IN PRAT b );
extern void andrat( IN OUT PRAT *pa, IN PRAT b );
extern void const_init( void );
extern void divnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN unsigned long nRadix );
extern void divnumx( IN OUT PNUMBER *pa, IN PNUMBER b );
extern void divrat( IN OUT PRAT *pa, IN PRAT b );
extern void fracrat( IN OUT PRAT *pa );
extern void factrat( IN OUT PRAT *pa );
extern void modrat( IN OUT PRAT *pa, IN PRAT b );
extern void gcdrat( IN OUT PRAT *pa );
extern void intrat( IN OUT PRAT *px);
extern void mulnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN unsigned long nRadix );
extern void mulnumx( IN OUT PNUMBER *pa, IN PNUMBER b );
extern void mulrat( IN OUT PRAT *pa, IN PRAT b );
extern void numpowlong( IN OUT PNUMBER *proot, IN long power, IN unsigned long nRadix );
extern void numpowlongx( IN OUT PNUMBER *proot, IN long power );
extern void orrat( IN OUT PRAT *pa, IN PRAT b );
extern void powrat( IN OUT PRAT *pa, IN PRAT b );
extern void ratpowlong( IN OUT PRAT *proot, IN long power );
extern void remnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN long nRadix );
extern void rootnum( IN OUT PNUMBER *pa, IN PNUMBER b, IN unsigned long nRadix );
extern void rootrat( IN OUT PRAT *pa, IN PRAT b );
extern void scale2pi( IN OUT PRAT *px );
extern void scale( IN OUT PRAT *px, IN PRAT scalefact );
extern void subrat( IN OUT PRAT *pa, IN PRAT b );
extern void xorrat( IN OUT PRAT *pa, IN PRAT b );
extern void lshrat( IN OUT PRAT *pa, IN PRAT b );
extern void rshrat( IN OUT PRAT *pa, IN PRAT b );
extern BOOL rat_equ( IN PRAT a, IN PRAT b );
extern BOOL rat_neq( IN PRAT a, IN PRAT b );
extern BOOL rat_gt( IN PRAT a, IN PRAT b );
extern BOOL rat_ge( IN PRAT a, IN PRAT b );
extern BOOL rat_lt( IN PRAT a, IN PRAT b );
extern BOOL rat_le( IN PRAT a, IN PRAT b );
extern void inbetween( IN PRAT *px, IN PRAT range );
extern DWORDLONG __inline Mul32x32( IN DWORD a, IN DWORD b );
//extern DWORDLONG __inline __fastcall Shr32xbase( IN DWORDLONG a );
extern void factnum( IN OUT PLINKEDLIST *ppllfact, PNUMBER pnum );
extern void trimit( IN OUT PRAT *px );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\rat.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           rat.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//  Contains mul, div, add, and other support functions for rationals.
//
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>


//-----------------------------------------------------------------------------
//
//    FUNCTION: gcdrat
//
//    ARGUMENTS: pointer to a rational.
//
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Divides p and q in rational by the G.C.D.
//    of both.  It was hoped this would speed up some
//    calculations, and until the above trimming was done it
//    did, but after trimming gcdratting, only slows things
//    down.
//
//-----------------------------------------------------------------------------

void gcdrat( PRAT *pa )

{
    PNUMBER pgcd=NULL;
    PRAT a=NULL;

    a=*pa;
    pgcd = gcd( a->pp, a->pq );

    if ( !zernum( pgcd ) )
        {
        divnumx( &(a->pp), pgcd );
        divnumx( &(a->pq), pgcd );
        }

    destroynum( pgcd );
    *pa=a;
    
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: fracrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes pointer.
//
//    DESCRIPTION: Does the rational equivalent of frac(*pa);
//
//-----------------------------------------------------------------------------

void fracrat( PRAT *pa )

{
    long trim;
    remnum( &((*pa)->pp), (*pa)->pq, BASEX );
    
    //Get *pa back in the integer over integer form.
    RENORMALIZE(*pa);
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: mulrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa *= b.
//    Assumes nRadix is the nRadix of both numbers.
//
//-----------------------------------------------------------------------------

void mulrat( PRAT *pa, PRAT b )
    
    {
    // Only do the multiply if it isn't zero.
    if ( !zernum( (*pa)->pp ) )
        {
        mulnumx( &((*pa)->pp), b->pp );
        mulnumx( &((*pa)->pq), b->pq );
        trimit(pa);
        }
    else
        {
        // If it is zero, blast a one in the denominator.
        DUPNUM( ((*pa)->pq), num_one );
        }

#ifdef MULGCD
    gcdrat( pa );
#endif

}

//-----------------------------------------------------------------------------
//
//    FUNCTION: divrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa /= b.
//    Assumes nRadix is the nRadix of both numbers.
//
//-----------------------------------------------------------------------------


void divrat( PRAT *pa, PRAT b )

{

    if ( !zernum( (*pa)->pp ) )
        {
        // Only do the divide if the top isn't zero.
        mulnumx( &((*pa)->pp), b->pq );
        mulnumx( &((*pa)->pq), b->pp );

        if ( zernum( (*pa)->pq ) )
            {
            // raise an exception if the bottom is 0.
            throw( CALC_E_DIVIDEBYZERO );
            }
        trimit(pa);
        }
    else
        {
        // Top is zero.
        if ( zerrat( b ) )
            {
            // If bottom is zero
            // 0 / 0 is indefinite, raise an exception.
            throw( CALC_E_INDEFINITE );
            }
        else
            {
            // 0/x make a unique 0.
            DUPNUM( ((*pa)->pq), num_one );
            }
        }

#ifdef DIVGCD
    gcdrat( pa );
#endif 

}

//-----------------------------------------------------------------------------
//
//    FUNCTION: subrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa += b.
//    Assumes base is internal througought.
//
//-----------------------------------------------------------------------------

void subrat( PRAT *pa, PRAT b )

{
    b->pp->sign *= -1;
    addrat( pa, b );
    b->pp->sign *= -1;
}

//-----------------------------------------------------------------------------
//
//    FUNCTION: addrat
//
//    ARGUMENTS: pointer to a rational a second rational.
//
//    RETURN: None, changes first pointer.
//
//    DESCRIPTION: Does the rational equivalent of *pa += b.
//    Assumes base is internal througought.
//
//-----------------------------------------------------------------------------

void addrat( PRAT *pa, PRAT b )

{
    PNUMBER bot=NULL;

    if ( equnum( (*pa)->pq, b->pq ) )
        {
        // Very special case, q's match., 
        // make sure signs are involved in the calculation
        // we have to do this since the optimization here is only 
        // working with the top half of the rationals.
        (*pa)->pp->sign *= (*pa)->pq->sign; 
        (*pa)->pq->sign = 1;
        b->pp->sign *= b->pq->sign; 
        b->pq->sign = 1;
        addnum( &((*pa)->pp), b->pp, BASEX );
        }
    else
        {
        // Usual case q's aren't the same.
        DUPNUM( bot, (*pa)->pq );
        mulnumx( &bot, b->pq );
        mulnumx( &((*pa)->pp), b->pq );
        mulnumx( &((*pa)->pq), b->pp );
        addnum( &((*pa)->pp), (*pa)->pq, BASEX );
        destroynum( (*pa)->pq );
        (*pa)->pq = bot;
        trimit(pa);
        
        // Get rid of negative zeroes here.
        (*pa)->pp->sign *= (*pa)->pq->sign; 
        (*pa)->pq->sign = 1;
        }

#ifdef ADDGCD
    gcdrat( pa );
#endif 

}



//-----------------------------------------------------------------------------
//
//  FUNCTION: rootrat
//
//  PARAMETERS: y prat representation of number to take the root of
//              n prat representation of the root to take.
//
//  RETURN: bth root of a in rat form.
//
//  EXPLANATION: This is now a stub function to powrat().
//
//-----------------------------------------------------------------------------

void rootrat( PRAT *py, PRAT n )

{
    PRAT oneovern=NULL;

    DUPRAT(oneovern,rat_one);
    divrat(&oneovern,n);

    powrat( py, oneovern );

    destroyrat(oneovern);
}


//-----------------------------------------------------------------------------
//
//    FUNCTION: zerrat
//
//    ARGUMENTS: Rational number.
//
//    RETURN: Boolean
//
//    DESCRIPTION: Returns true if input is zero.
//    False otherwise.
//
//-----------------------------------------------------------------------------

BOOL zerrat( PRAT a )

{
    return( zernum(a->pp) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\trans.c ===
//----------------------------------------------------------------------------
//  File           trans.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains sin, cos and tan for rationals
//
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>


void scalerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    switch ( angletype )
        {
    case ANGLE_RAD:
        scale2pi( pa );
        break;
    case ANGLE_DEG:
        scale( pa, rat_360 );
        break;
    case ANGLE_GRAD:
        scale( pa, rat_400 );
        break;
        }
}


//-----------------------------------------------------------------------------
//
//  FUNCTION: sinrat, _sinrat
//
//  ARGUMENTS:  x PRAT representation of number to take the sine of
//
//  RETURN: sin of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j+1   j
//   \  ]  X     -1
//    \   ---------
//    /    (2j+1)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                              -X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//-----------------------------------------------------------------------------


void _sinrat( PRAT *px )

{
    CREATETAYLOR();

    DUPRAT(pret,*px); 
    DUPRAT(thisterm,*px);

    DUPNUM(n2,num_one);
    xx->pp->sign *= -1;

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
    
    // Since *px might be epsilon above 1 or below -1, due to TRIMIT we need 
    // this trick here.
    inbetween(px,rat_one);
    
    // Since *px might be epsilon near zero we must set it to zero.
    if ( rat_le(*px,rat_smallest) && rat_ge(*px,rat_negsmallest) )
        {
        DUPRAT(*px,rat_zero);
        }
}

void sinrat( PRAT *px )
{
    scale2pi(px); 
    _sinrat(px); 
}

void sinanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    scalerat( pa, angletype );
    switch ( angletype )
        {
    case ANGLE_DEG:
        if ( rat_gt( *pa, rat_180 ) )
            {
            subrat(pa,rat_360);
            }
        divrat( pa, rat_180 );
        mulrat( pa, pi );
        break;
    case ANGLE_GRAD:
        if ( rat_gt( *pa, rat_200 ) )
            {
            subrat(pa,rat_400);
            }
        divrat( pa, rat_200 );
        mulrat( pa, pi );
        break;
        }
    _sinrat( pa );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: cosrat, _cosrat
//
//  ARGUMENTS:  x PRAT representation of number to take the cosine of
//
//  RETURN: cosin of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j   j
//   \  ]  X   -1
//    \   ---------
//    /    (2j)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                              -X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = 1 ;  and stop when thisterm < precision used.
//           0                              n
//
//-----------------------------------------------------------------------------


void _cosrat( PRAT *px )

{
    CREATETAYLOR();

    pret->pp=longtonum( 1L, nRadix );
    pret->pq=longtonum( 1L, nRadix );

    DUPRAT(thisterm,pret)

    n2=longtonum(0L, nRadix);
    xx->pp->sign *= -1;

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
    // Since *px might be epsilon above 1 or below -1, due to TRIMIT we need 
    // this trick here.
    inbetween(px,rat_one);
    // Since *px might be epsilon near zero we must set it to zero.
    if ( rat_le(*px,rat_smallest) && rat_ge(*px,rat_negsmallest) )
        {
        DUPRAT(*px,rat_zero);
        }
}

void cosrat( PRAT *px )
{
    scale2pi(px); 
    _cosrat(px); 
}

void cosanglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    scalerat( pa, angletype );
    switch ( angletype )
 