****************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::QueryHelpFile

    SYNOPSIS:   Returns the help file name to use for this instance of
                dialog

    NOTES:

    HISTORY:
        JonN        04-Dec-1992 Created

********************************************************************/

const TCHAR * NT_FIND_ACCOUNT_DIALOG::QueryHelpFile( ULONG ulHelpContext )
{
    return _pdlgUserBrowser->QueryHelpFile( ulHelpContext );
}


/*******************************************************************

    NAME:       NT_FIND_ACCOUNT_DIALOG::QueryHelpContext

    SYNOPSIS:   Returns the help context to use for this instance of
                dialog

    NOTES:

    HISTORY:
        JonN        04-Dec-1992 Created

********************************************************************/

ULONG NT_FIND_ACCOUNT_DIALOG::QueryHelpContext( void )
{
    ULONG ulHelpContextSearch = _pdlgUserBrowser->QueryHelpContextSearch();
    if ( ulHelpContextSearch == 0 )
    {
        ulHelpContextSearch = _pdlgUserBrowser->QueryHelpContext()
                              + USRBROWS_HELP_OFFSET_FINDUSER;
    }

    return ulHelpContextSearch;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\focthred.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1993                   **/
/**********************************************************************/

/*
    focthred.cxx
       Second thread for select computer dialog


    FILE HISTORY:
        YiHsinS		4-Mar-1993	Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::FOCUSDLG_DATA_THREAD

    SYNOPSIS:   Constructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

FOCUSDLG_DATA_THREAD::FOCUSDLG_DATA_THREAD( HWND hwndDlg,
                                            ULONG maskDomainSources,
                                            SELECTION_TYPE seltype,
                                            const TCHAR *pszSelection,
                                            ULONG nServerTypes )
    : WIN32_THREAD( TRUE, 0, SZ("NETUI2") ),
      _hwndDlg( hwndDlg ),
      _maskDomainSources( maskDomainSources ),
      _seltype( seltype ),
      _nlsSelection( pszSelection ),
      _nServerTypes( nServerTypes ),
      _eventExitThread( NULL, FALSE ),
      _fThreadIsTerminating( FALSE )
{
    if ( QueryError() )
        return;

    APIERR err = NERR_Success;
    if (  ((err = _eventExitThread.QueryError()) != NERR_Success )
       || ((err = _nlsSelection.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::~FOCUSDLG_DATA_THREAD

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

FOCUSDLG_DATA_THREAD::~FOCUSDLG_DATA_THREAD()
{
}

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::Main()

    SYNOPSIS:   Get the information needed to fill in the listbox
                with the requested data (domains, servers..)

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR FOCUSDLG_DATA_THREAD::Main( VOID )
{
    APIERR err = NERR_Success;
    FOCUSDLG_RETURN_DATA data;

    data.pEnumDomains = NULL;
    data.pEnumServers = NULL;
    data.pszSelection = NULL;

    BROWSE_DOMAIN_ENUM *pEnumDomains = data.pEnumDomains =
                       new BROWSE_DOMAIN_ENUM( _maskDomainSources );

    if ( pEnumDomains == NULL )
        err = ERROR_NOT_ENOUGH_MEMORY;

    if (  ( err == NERR_Success )
       && ((err = pEnumDomains->QueryError()) == NERR_Success )
       && ( !_fThreadIsTerminating )
       )
    {
        //
        // Get the default selection
        //
        if (  ( pEnumDomains->QueryDomainCount() > 0 )
           && ( !_fThreadIsTerminating )
           )
        {
            BOOL fFound = FALSE;
            const BROWSE_DOMAIN_INFO *pbdi;

            if (  ( _nlsSelection.QueryTextLength() != 0 )
               && ( !_fThreadIsTerminating )
               )
            {
                while ( (pbdi = pEnumDomains->Next()) != NULL )
                {
                    if ( ::stricmpf( pbdi->QueryDomainName(),
                                     _nlsSelection) == 0 )
                    {
                        fFound = TRUE;
                        if ( _fThreadIsTerminating )
                            break;
                    }
                }
                pEnumDomains->Reset();
            }

            if (  !fFound
               && ( !_fThreadIsTerminating )
               )
            {
                if ( _seltype == SEL_SRV_ONLY )
                    pbdi = pEnumDomains->FindFirst( BROWSE_WKSTA_DOMAIN );
                else
                    pbdi = pEnumDomains->FindFirst( BROWSE_LOGON_DOMAIN );

                if ( pbdi == NULL )
                {
                    pEnumDomains->Reset();
                    pbdi = pEnumDomains->Next();

                    // Since QueryDomainCount is greater than 0,
                    // there should be at least one pbdi.
                    UIASSERT( pbdi != NULL );
                }

                pEnumDomains->Reset();

                err = _nlsSelection.CopyFrom( pbdi->QueryDomainName());
            }

            data.pszSelection = _nlsSelection.QueryPch();

            //
            // Get the servers in the default selection if we need to.
            // If any error occurred, just ignore them since we already
            // have all the domain names.
            //
            if  (  !_fThreadIsTerminating
                && (  ( _seltype == SEL_SRV_ONLY )
                   || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN ))
                )
            {

                SERVER1_ENUM *pSrvEnum = new SERVER1_ENUM( NULL,
            						   _nlsSelection,
                                                           _nServerTypes );

                if ( pSrvEnum != NULL )
                {
                    if ( pSrvEnum->GetInfo() == NERR_Success)  // ignore errors
                    {
                        data.pEnumServers = pSrvEnum;
                    }
                    else
                    {
                        delete pSrvEnum;
                        pSrvEnum = NULL;
                    }
                }
            }
        }
    }

    if ( !_fThreadIsTerminating )
    {
        if ( err == NERR_Success )
        {
            ::SendMessage( _hwndDlg,
                           WM_FOCUS_LB_FILLED,
                           (WPARAM) FALSE,    // No error!
                           (LPARAM) &data );
        }
        else
        {
            ::SendMessage( _hwndDlg,
                           WM_FOCUS_LB_FILLED,
                           (WPARAM) TRUE,     // Error occurred!
                           (LPARAM) err );
        }
    }

    // The following cache will have already been freed if the
    // dialog got the SendMessage above.
    if ( data.pEnumDomains != NULL )
    {
        delete data.pEnumDomains;
        data.pEnumDomains = NULL;
    }

    if ( data.pEnumServers != NULL )
    {
        delete data.pEnumServers;
        data.pEnumServers = NULL;
    }

    switch ( ::WaitForSingleObject( _eventExitThread.QueryHandle(), INFINITE ))
    {
        // Time to exit the thread
        case WAIT_OBJECT_0:
            break;

        // These two should not have happened, not a mutex and wait infinite
        case WAIT_ABANDONED:
        case WAIT_TIMEOUT:
            UIASSERT( FALSE );
            break;

        default:
            err = ::GetLastError();
            break;
    }

    return err;

}  // FOCUSDLG_DATA_THREAD::Main

/*******************************************************************

    NAME:       FOCUSDLG_DATA_THREAD::PostMain()

    SYNOPSIS:   Clean up

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        YiHsinS		4-Mar-1993	Created

********************************************************************/

APIERR FOCUSDLG_DATA_THREAD::PostMain( VOID )
{
    TRACEEOL("FOCUSDLG_DATA_THREAD::PostMain - Deleting \"this\" for thread "
             << HEX_STR( (ULONG) QueryHandle() )) ;

    DeleteAndExit( NERR_Success ) ; // This method should never return

    UIASSERT( FALSE );

    return NERR_Success;

}  // FOCUSDLG_DATA_THREAD::PostMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\focusdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    focusdlg.cxx
    Common dialog for setting the app's focus

    FILE HISTORY:
        kevinl      14-Jun-91   Created
        rustanl     04-Sep-1991 Modified to let this dialog do more
                                work (rather than letting ADMIN_APP
                                do the work after this dialog is
                                dismissed)
        KeithMo     06-Oct-1991 Win32 Conversion.
        terryk      18-Nov-1991 Move from admin\common\src\adminapp\setfocus
                                to here
        terryk      26-Nov-1991 Remove an unnecessary comment
        KeithMo     07-Aug-1992 Added HelpContext parameters.
*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::BASE_SET_FOCUS_DLG

    SYNOPSIS:   Constructor

    ENTRY:      HWND hWnd - owner window handle

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
       kevinl   14-Jun-91       Created
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG
       KeithMo  22-Jul-1992     Added maskDomainSources & pszDefaultSelection.

********************************************************************/

BASE_SET_FOCUS_DLG::BASE_SET_FOCUS_DLG( const HWND wndOwner,
                                        SELECTION_TYPE seltype,
                                        ULONG maskDomainSources,
                                        const TCHAR * pszDefaultSelection,
                                        ULONG nHelpContext,
                                        const TCHAR *pszHelpFile,
                                        ULONG nServerTypes )
    :   DIALOG_WINDOW( ( seltype == SEL_SRV_ONLY
                         ||  seltype == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN
                         ||  seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
                           ? MAKEINTRESOURCE( IDD_SELECTCOMPUTER_DLG )
                           : MAKEINTRESOURCE( IDD_SELECTDOMAIN_DLG ),
                       wndOwner,
/* kkbugfix */  FALSE                  // Use Unicode form of dialog to
                                       // canonicalize the computernames
		),	
        _sleFocusPath( this, IDC_FOCUS_PATH, MAX_PATH ), // fix UpdateRasMode
                                                       // if maxlen changed
        _olb( this,
              IDC_DOMAIN_LB,
              seltype,
              nServerTypes),
        _sleGetInfo( this, IDC_SLE_GETINFO ),  // Always disabled
        _sltLBTitle( this, IDC_SEL_LB_TITLE ),
        _seltype(seltype),
        _nHelpContext( nHelpContext ),
        _nlsHelpFile(pszHelpFile),
        _sltBoundary( this, IDC_BOUNDARY ),
        _xyOriginal( 0, 0 ),
        _chkboxRasMode( this, IDC_LINK ),
        _sltRasModeMessage( this, IDC_LINK_MESSAGE ),
        _resstrRasServerSlow( IDS_SETFOCUS_SERVER_SLOW ),
        _resstrRasServerFast( IDS_SETFOCUS_SERVER_FAST ),
        _resstrRasDomainSlow( IDS_SETFOCUS_DOMAIN_SLOW ),
        _resstrRasDomainFast( IDS_SETFOCUS_DOMAIN_FAST ),
        _pDataThread( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   (err = _nlsHelpFile.QueryError()) != NERR_Success
        || (err = _resstrRasServerSlow.QueryError()) != NERR_Success
        || (err = _resstrRasServerFast.QueryError()) != NERR_Success
        || (err = _resstrRasDomainSlow.QueryError()) != NERR_Success
        || (err = _resstrRasDomainFast.QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    _pDataThread = new FOCUSDLG_DATA_THREAD( QueryHwnd(),
                                             maskDomainSources,
                                             _seltype,
                                             pszDefaultSelection,
                                             nServerTypes );

    err = ERROR_NOT_ENOUGH_MEMORY;
    if (  ( _pDataThread == NULL )
       || ( (err = _pDataThread->QueryError()) != NERR_Success )
       || ( (err = _pDataThread->Resume()) != NERR_Success )
       )
    {
        delete _pDataThread;
        _pDataThread = NULL;

        ReportError( err );
        return;
    }

    RESOURCE_STR nlsGettingInfo( IDS_APPLIB_WORKING_TEXT );
    if ( (err = nlsGettingInfo.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }
    _sleGetInfo.SetText( nlsGettingInfo );

    _olb.Show( FALSE );
    _sleGetInfo.Show( TRUE );
    _olb.Enable( FALSE );
    _sltLBTitle.Enable( FALSE );


    //  Since the Domain and Servers listbox now has a new selection, we call
    //  OnDomainLBChange to perform necessary updates.
    //  OnDomainLBChange();

    // give focus and select edit field
    SelectNetPathString();
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::~BASE_SET_FOCUS_DLG

    SYNOPSIS:   Destructor.

    HISTORY:
       kevinl   14-Jun-91       Created
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

BASE_SET_FOCUS_DLG::~BASE_SET_FOCUS_DLG()
{
    if ( _pDataThread != NULL )
    {
        _pDataThread->ExitThread();

        // Do not delete the thread object, it will delete itself.
        _pDataThread = NULL;
    }

}


/*******************************************************************

    NAME:     BASE_SET_FOCUS_DLG::SelectNetPathString

    SYNOPSIS: Set focus & select the network path.  Used after the network
              path is determined to be invalid.

    ENTRY:

    EXIT:     The string in the Network Path SLE will have the focus and
              be hi-lited.

    NOTES:

    HISTORY:
        Johnl   15-Mar-1991     Created - Part of solution to BUG 1218
       kevinl   14-Jun-91       Modified for SET_FOCUS_DLG
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

VOID BASE_SET_FOCUS_DLG::SelectNetPathString( VOID )
{
    _sleFocusPath.ClaimFocus();
    _sleFocusPath.SelectString();
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnDomainLBChange

    SYNOPSIS:   This method is called when the user takes an action in
                the Domain and Servers listbox.

    HISTORY:
       rustanl ??-Nov-91        Created
       kevinl   14-Jun-91       Significant modification to conform
                                to new functionality of the setfocus
                                dialog.  Specifically deals with domains
                                as valid selections...enterprises are
                                still considered incorrect selections.
       terryk   18-Nov-91       Change to BASE_SET_FOCUS_DLG
       KeithMo  23-Jul-1992     Can now handle an empty listbox.

********************************************************************/

VOID BASE_SET_FOCUS_DLG::OnDomainLBChange()
{
    //  Get the current listbox data item.  This item is a pointer to
    //  an OLLB_ENTRY.

    OLLB_ENTRY * pollbe = _olb.QueryItem();

    if( pollbe == NULL )
    {
        //
        //  Since the domain/server listbox is empty, we'll just
        //  clear the edit field.
        //

        _sleFocusPath.SetText( SZ("") );
        return;
    }

    //  Update the Set Focus on edit field.
    if ( pollbe->QueryLevel() == OLLBL_SERVER )
    {
        //  Allocate NLS_STR to fit \\server.   Initialize with
        //  two backslashes.
        ISTACK_NLS_STR( nlsServerName, MAX_PATH, SZ("\\\\") );

        UIASSERT( strlenf( pollbe->QueryServer() ) <= MAX_PATH );

        nlsServerName += pollbe->QueryServer();

        UIASSERT( nlsServerName.QueryError() == NERR_Success );

        _sleFocusPath.SetText( nlsServerName );
    }
    else if ( pollbe->QueryLevel() == OLLBL_DOMAIN )
    {
        if (  ( _seltype == SEL_SRV_ONLY )
           || ( _seltype == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN )
           || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
           )
        {
            //
            //  Since the user is requesting servers only,
            //  it doesn't make much sense to stick a domain
            //  name in the edit field.
            //

            _sleFocusPath.SetText( SZ("") );
            return;
        }

        _sleFocusPath.SetText( pollbe->QueryDomain() );
    }
    else        // Enterprise
    {
        UIASSERT( !SZ("This shouldn't happen, since we don't have an enterprise") );
        _sleFocusPath.ClearText();
    }
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::ProcessNetPath

    SYNOPSIS:   This method checks the Network Path field.
                If the field's contents contain a valid domain
                or server name then it will return TRUE,
                FALSE otherwise.

                If the SLE contains a string of the shape \\server
                or domainname and is validated then success is returned.

    ENTRY:      pnlsPath    Pointer to NLS_STR which will receive
                            the name of the network path.  The
                            value should only be used if this method
                            returns NERR_Success.

    EXIT:       On success, *pnlsPath will be the requested domain
                or server name.

    RETURNS:    An API return value, which is NERR_Success on success.

    HISTORY:
        kevinl      14-Jun-91       Created - modified version from the browser
        rustanl     05-Sep-1991     Changed return to to APIERR
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::ProcessNetPath( NLS_STR * pnlsPath, MSGID *pmsgid )
{
    UIASSERT( pnlsPath != NULL );
    UIASSERT( pmsgid != NULL );

    *pmsgid = 0 ;

    APIERR err = _sleFocusPath.QueryText( pnlsPath );
    if ( err != NERR_Success )
        return err;

    UIASSERT( pnlsPath->QueryError() == NERR_Success );

    if ( pnlsPath->strlen() == 0 )
    {
        *pmsgid = IDS_APPLIB_NO_SELECTION ;
        return ERROR_INVALID_PARAMETER;
    }

    // If the net name did not start with backslashes and we are only
    // selecting servers, append the backslashes.

    ISTR istrStart( *pnlsPath );
    if ( pnlsPath->QueryChar( istrStart ) != TCH('\\') )
    {
        if (  ( _seltype == SEL_SRV_ONLY )
           || ( _seltype == SEL_SRV_ONLY_BUT_DONT_EXPAND_DOMAIN )
           || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
           )
        {
            ALIAS_STR nls( SZ("\\\\") );
            if ( !pnlsPath->InsertStr( nls, istrStart ) )
                return pnlsPath->QueryError();
        }
    }

    //  We will attempt to check if the net name takes the form
    //  \\server, where "server" can be any non-empty
    //  string not containing backslashes.

    BOOL fIsDomain = FALSE;

    ISTR istr( *pnlsPath );
    if ( pnlsPath->QueryChar(   istr ) == TCH('\\') &&  //  backslash 0
         pnlsPath->QueryChar( ++istr ) == TCH('\\') &&  //  backslash 1
         pnlsPath->QueryChar( ++istr ) != TCH('\0') )
    {
        // The name has at least '\\' prepended so pass this string
        // minus the '\\' to the validation routine......

        err = ::I_MNetNameValidate( NULL, pnlsPath->QueryPch() + 2,
                                    NAMETYPE_COMPUTER, 0L );
        *pmsgid = IDS_APPLIB_NO_SELECTION ;
    }
    else
    {
        fIsDomain = TRUE;

        err = ::I_MNetNameValidate( NULL, pnlsPath->QueryPch(),
                                    NAMETYPE_DOMAIN, 0L );
        *pmsgid = IDS_APPLIB_NO_SELECTION ;
    }

    return err;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      UINT * pnRetVal         return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::Process ( UINT * pnRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pnRetVal ) ;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      BOOL * pfRetVal         BOOL return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::Process ( BOOL * pfRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pfRetVal ) ;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnUserMessage

    SYNOPSIS:   Handles WM_FOCUS_LB_FILLED messages.

    HISTORY:
        YiHsinS      10-Mar-1993     Created

********************************************************************/

BOOL BASE_SET_FOCUS_DLG::OnUserMessage( const EVENT & event )
{
    if ( event.QueryMessage() == WM_FOCUS_LB_FILLED )
    {
        AUTO_CURSOR autocur;

        BOOL fError = (BOOL) event.QueryWParam();
        if ( fError )
        {
            APIERR err;
            RESOURCE_STR nlsError( (APIERR) event.QueryLParam() );
            if ( (err = nlsError.QueryError()) != NERR_Success )
                ::MsgPopup( this, err );
            else
                _sleGetInfo.SetText( nlsError );
        }
        else
        {
            FOCUSDLG_RETURN_DATA *pData =
                     (FOCUSDLG_RETURN_DATA *) event.QueryLParam();
            UIASSERT( pData != NULL );

            _olb.FillAllInfo( pData->pEnumDomains,
                              pData->pEnumServers,
                              pData->pszSelection );

            _olb.Enable( TRUE );
            _sltLBTitle.Enable( TRUE );
            _sleGetInfo.Show( FALSE );
            _olb.Show( TRUE );

            delete pData->pEnumDomains;
            pData->pEnumDomains = NULL;
            delete pData->pEnumServers;
            pData->pEnumServers = NULL;
        }

        return TRUE;
    }

    return DIALOG_WINDOW::OnUserMessage( event );
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnCommand

    SYNOPSIS:   Handles WM_COMMAND messages.
                Currently it only processes selection change
                messages.  If the selection has changed then it
                calls OnDomainLBChange to update the listbox,
                otherwise it does nothing.

    HISTORY:
        kevinl      14-Jun-1991     Created
        KeithMo     06-Oct-1991     Now takes a CONTROL_EVENT.
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

BOOL BASE_SET_FOCUS_DLG::OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
    case IDC_DOMAIN_LB:
        switch ( event.QueryCode() )
        {
        case LBN_SETFOCUS:
            {
                if (_sleFocusPath.QueryTextLength( ) != 0 )
		    break;
                // fall through
            }
        case LBN_SELCHANGE:
            {
                OnDomainLBChange();
                return TRUE;
            }

        case LBN_DBLCLK:
            {
                OLLB_ENTRY *pollbe = _olb.QueryItem();

                if( ( pollbe != NULL ) &&
                    ( ( pollbe->QueryLevel() == OLLBL_SERVER ) ||
                      ( ( pollbe->QueryLevel() == OLLBL_DOMAIN ) &&
                        ( _seltype == SEL_DOM_ONLY ) ) ) )
                {
                    return OnOK();
                }

                break;
            }

        default:                // switch HIWORD( lParam )
            break;

        }
        break;


    case IDC_FOCUS_PATH:
        switch ( event.QueryCode() )
        {
        case EN_CHANGE:
            UpdateRasMode();
            break;

        default:                // switch HIWORD( lParam )
            break;

        }
        break;

    default:                    // switch cid
        break;

    }

    return DIALOG_WINDOW::OnCommand( event );
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::OnOK

    SYNOPSIS:   Validates current selection

    EXIT:       If the current selection was a well formed
                domain or server name then the dialog was
                dismissed and the selection returned.

    HISTORY:
        kevinl      14-Jun-1991     Created
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG
                                    Add SetNetworkFocus function call

********************************************************************/

BOOL BASE_SET_FOCUS_DLG::OnOK()
{
#ifdef TRACE
    const TCHAR * apszSettings[] = { SZ("SLOW"), SZ("FAST"), SZ("UNKNOWN") };
#endif

    AUTO_CURSOR autocur;

    NLS_STR nls;
    APIERR err = nls.QueryError();
    if ( err != NERR_Success )
    {
        ::MsgPopup( this, (MSGID)err );
        return TRUE;        // message was handled
    }

    MSGID msgid ;
    err = ProcessNetPath( &nls, &msgid );
    if ( err == NERR_Success )
    {
        FOCUS_CACHE_SETTING setting;
        if ( InRasMode() )
        {
            TRACEEOL( "BASE_SET_FOCUS_DLG::OnOK(): slowmode checkbox checked" );
            setting = FOCUS_CACHE_SLOW;
        }
        else
        {
            setting = ReadFocusCache( nls.QueryPch() );
            TRACEEOL( "BASE_SET_FOCUS_DLG: cache setting is " <<
                  apszSettings[setting] );

            if (setting == FOCUS_CACHE_SLOW)
            {
                TRACEEOL( "BASE_SET_FOCUS_DLG::OnOK(): slowmode checkbox explicitly unchecked" );
                setting = FOCUS_CACHE_FAST;
            }
        }

        TRACEEOL( "BASE_SET_FOCUS_DLG: calling SetNetworkFocus( \"" << nls
                  << "\", " << apszSettings[setting] << " )" );

        err = SetNetworkFocus( QueryHwnd(), nls.QueryPch(), setting );
    }

    switch(err)
    {
        case NERR_Success:
            Dismiss( TRUE );
            return TRUE;

        case IERR_DONT_DISMISS_FOCUS_DLG: // error is already handled, don't
                                          // popup the error again
            SelectNetPathString();
            return TRUE;

        case ERROR_INVALID_NAME:
        case ERROR_INVALID_PARAMETER:
            ::MsgPopup(this,(MSGID)((msgid==0)?ERROR_INVALID_PARAMETER:msgid));
            SelectNetPathString();
            break ;

        default:
            ::MsgPopup( this, (MSGID)err );
            SelectNetPathString();
            break ;

    }

    return TRUE;    // message was handled
}

/*******************************************************************

    NAME:           BASE_SET_FOCUS_DLG::SetNetworkFocus

    SYNOPSIS:

    EXIT:

    HISTORY:
        jonn        06-Aug-1992     De-inline'd

********************************************************************/

APIERR BASE_SET_FOCUS_DLG::SetNetworkFocus( HWND hwndOwner,
                                            const TCHAR * pszNetworkFocus,
                                            FOCUS_CACHE_SETTING setting )
{
    UNREFERENCED(hwndOwner);
    UNREFERENCED(pszNetworkFocus);
    UNREFERENCED(setting);
    return NERR_Success;
}


/*******************************************************************

    NAME:           BASE_SET_FOCUS_DLG::QueryHelpContext

    SYNOPSIS:       Returns the help context.

    EXIT:           returns 0

    HISTORY:
        kevinl      14-Jun-1991     Created
        terryk      18-Nov-91       Change to BASE_SET_FOCUS_DLG

********************************************************************/

ULONG BASE_SET_FOCUS_DLG::QueryHelpContext()
{
    return (QuerySuppliedHelpContext()) ;
}

/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::QueryHelpFile

    SYNOPSIS:   overwrites the default QueryHelpFile in DIALOG_WINDOW
                to use an app supplied help (rather than the one
                DIALOG_WINDOW will calculate for us) if we were given
                one at construct time.

    ENTRY:

    EXIT:

    RETURNS:    a pointer to a string which is the help file to use.

    NOTES:

    HISTORY:
        ChuckC   26-Cct-1992     Created

********************************************************************/
const TCHAR * BASE_SET_FOCUS_DLG::QueryHelpFile( ULONG nHelpContext )
{
    //
    // if we were given a helpfile & context at construct time and
    // the context requested matches that, we use the given help file.
    //
    const TCHAR *pszHelpFile = QuerySuppliedHelpFile() ;

    if (pszHelpFile && *pszHelpFile)
    {
        return pszHelpFile ;
    }
    return DIALOG_WINDOW::QueryHelpFile(nHelpContext) ;
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::ReadFocusCache

    SYNOPSIS:   Whenever the contents of the focus edit field change,
                and the dialog is expanded via ShowArea(), the contents
                of the RasMode checkbox will be changed according to
                the focus cache.  Subclasses should redefine this method
                if they support the RasMode checkbox and focus cache.

    HISTORY:
        JonN    24-Mar-1993     Created

********************************************************************/
FOCUS_CACHE_SETTING BASE_SET_FOCUS_DLG::ReadFocusCache( const TCHAR * pszFocus ) const
{
    UNREFERENCED( pszFocus );

    return FOCUS_CACHE_UNKNOWN;
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::UpdateRasMode

    SYNOPSIS:   Whenever the contents of the focus edit field change,
                and the dialog is expanded via ShowArea(), the contents
                of the RasMode checkbox will be changed according to
                the focus cache.

    HISTORY:
        JonN    24-Mar-1993     Created

********************************************************************/
VOID BASE_SET_FOCUS_DLG::UpdateRasMode()
{
    if ( IsExpanded() )
    {
        TCHAR pszFocus[ MAX_PATH+1 ];

        APIERR err = _sleFocusPath.QueryText( pszFocus, sizeof(pszFocus) );
        if (err != NERR_Success)
        {
            DBGEOL( "BASE_SET_FOCUS_DLG::UpdateRasMode(): failure " << err );
        }
        else
        {
            FOCUS_CACHE_SETTING setting = ReadFocusCache( pszFocus );
            switch ( setting )
            {
            case FOCUS_CACHE_SLOW:
            case FOCUS_CACHE_FAST:
                if (pszFocus[0] == (TCHAR)(TCH('\0')))
                {
                    _chkboxRasMode.SetCheck( FALSE );
                    _sltRasModeMessage.ClearText();
                }
                else
                {
                    BOOL fIsServer = (pszFocus[0] == (TCHAR)(TCH('\\')));
                    BOOL fIsSlow = (setting == FOCUS_CACHE_SLOW);
                    const TCHAR * pchRasMessage =
                        (fIsServer)
                          ? ( (fIsSlow)
                                ? _resstrRasServerSlow.QueryPch()
                                : _resstrRasServerFast.QueryPch() )
                          : ( (fIsSlow)
                                ? _resstrRasDomainSlow.QueryPch()
                                : _resstrRasDomainFast.QueryPch() );
                    NLS_STR nlsRasMessage( pchRasMessage );
                    ALIAS_STR nlsFocus( pszFocus );
                    if (   (err = nlsRasMessage.QueryError()) != NERR_Success
                        || (err = nlsRasMessage.InsertParams( nlsFocus ))
                                        != NERR_Success
                       )
                    {
                        DBGEOL( "BASE_SET_FOCUS_DLG::UpdateRasMode(): RasMessage failure " << err );
                        _sltRasModeMessage.ClearText();
                    }
                    else
                    {
                        _sltRasModeMessage.SetText( nlsRasMessage );
                    }

                    _chkboxRasMode.SetCheck( fIsSlow );
                }
                break;
            default:
                DBGEOL( "BASE_SET_FOCUS_DLG::UpdateRasMode(): invalid cache" );
                // fall through
            case FOCUS_CACHE_UNKNOWN:
                _chkboxRasMode.SetCheck( FALSE );
                _sltRasModeMessage.ClearText();
                break;
            }
        }
    }
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::ShowArea()

    SYNOPSIS:   Grows or shrinks the dialog based upon the BOOL
                parameter and the location of the boundary control.

    ENTRY:      BOOL fFull              if TRUE, expand the dialog;
                                        otherwise, show default size.

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      Calls virtual OnExpand() member when it is about to
                exposed the previously hidden controls.

    HISTORY:

********************************************************************/

#define EXP_MIN_USE_BOUNDARY 5

VOID BASE_SET_FOCUS_DLG::ShowArea( BOOL fFull )
{
    //  If this is the first call, save the size of the dialog

    if ( _xyOriginal.QueryHeight() <= 0 )
    {
        _xyOriginal = QuerySize() ;

        //  Hide and disable the boundary control
        _sltBoundary.Show( FALSE ) ;
        _sltBoundary.Enable( FALSE ) ;
    }

    //  Iterate over child controls; dis/enable child controls in
    //  the expanded region to preserve tab ordering, etc.

    ITER_CTRL itCtrl( this ) ;
    CONTROL_WINDOW * pcw ;
    XYPOINT xyBoundary( _sltBoundary.QueryPos() ) ;

    for ( ; pcw = itCtrl() ; )
    {
        if ( pcw != & _sltBoundary )
        {
            XYPOINT xyControl( pcw->QueryPos() ) ;
            if (   xyControl.QueryX() >= xyBoundary.QueryX()
                || xyControl.QueryY() >= xyBoundary.QueryY() )
            {
                pcw->Enable( fFull ) ;
            }
        }
    }

    if ( ! fFull )  // Initial display; show only the default area
    {
		// NTRAID#NTBUG9-574280-2002/03/07-artm  Prefast:  unnecessary redeclaration of xyBoundary
		// Variable already declared at function level (and in fact set to the exact
		// same value!).  Redeclaration does not appear to change execution; only
		// upsets prefast.
        XYPOINT xyBoundary = _sltBoundary.QueryPos() ;
        XYDIMENSION dimBoundary = _sltBoundary.QuerySize();
        XYRECT rWindow ;

        //  Compute location of the lower right-hand edge of the boundary
        //  control relative to the full (i.e., not client) window.

        xyBoundary.SetX( xyBoundary.QueryX() + dimBoundary.QueryWidth() ) ;
        xyBoundary.SetY( xyBoundary.QueryY() + dimBoundary.QueryHeight() ) ;
        xyBoundary.ClientToScreen( QueryHwnd() ) ;
        QueryWindowRect( & rWindow ) ;
        if (GetWindowLongPtr(QueryHwnd(), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
            xyBoundary.SetX( rWindow.QueryRight() - xyBoundary.QueryX() ) ;
        } else {
            xyBoundary.SetX( xyBoundary.QueryX() - rWindow.QueryLeft() ) ;
        }
        xyBoundary.SetY( xyBoundary.QueryY() - rWindow.QueryTop() ) ;

        //  Check if the boundary control is "close" to the edge of the
        //  dialog in either dimension.  If so, use the original value.

        if ( _xyOriginal.QueryHeight() - xyBoundary.QueryY() <= EXP_MIN_USE_BOUNDARY )
            xyBoundary.SetY( _xyOriginal.QueryHeight() ) ;

        if ( _xyOriginal.QueryWidth() - xyBoundary.QueryX() <= EXP_MIN_USE_BOUNDARY )
            xyBoundary.SetX( _xyOriginal.QueryWidth() ) ;

        //  Change the dialog size.
        SetSize( xyBoundary.QueryX(), xyBoundary.QueryY(), TRUE ) ;
    }
    else            //  Full display; expand the dialog to original size
    {
        //  Set size to original full extent
        SetSize( _xyOriginal.QueryWidth(), _xyOriginal.QueryHeight(), TRUE ) ;
    }
}


/*******************************************************************

    NAME:       BASE_SET_FOCUS_DLG::IsExpanded()

    SYNOPSIS:   Determines whether the dialog is expanded to full size.

    RETURNS:    TRUE iff the dialog is expanded

    HISTORY:

********************************************************************/
BOOL BASE_SET_FOCUS_DLG::IsExpanded() const
{
    return (   QuerySize().QueryHeight() == _xyOriginal.QueryHeight()
            && QuerySize().QueryWidth()  == _xyOriginal.QueryWidth()  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\fontpick.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    fontpick.cxx
        This is a wrapper for the Win32 Font Picker Common Dialog.

    FILE HISTORY:
        JonN            22-Sep-1993     Created

*/

#include "pchapplb.hxx"   // Precompiled header

#include "fontpick.hxx"


/*******************************************************************

    NAME:	WIN32_FONT_PICKER::Process

    SYNOPSIS:	Display font picker dialog

    ENTRY:	FONT * pfont  - store returned font here
                LOGFONT * plf - store font data here if specified
                CHOOSEFONT * pcf - parameters for dialog if specified

    NOTES:      Code based on example in ProgRef volume 2 pp. 689-691

    HISTORY:
        JonN            22-Sep-1993     Created

********************************************************************/

APIERR WIN32_FONT_PICKER::Process( OWNER_WINDOW * powin,
                                   BOOL * pfCancelled,
                                   FONT * pfont,
                                   LOGFONT * plf,
                                   CHOOSEFONT * pcf )
{
    ASSERT( powin != NULL && powin->QueryError() == NERR_Success );
    ASSERT( pfont == NULL || pfont->QueryError() == NERR_Success );
    ASSERT( pfCancelled != NULL );

    *pfCancelled = FALSE;

    LOGFONT lf;
    if (plf == NULL)
    {
        plf = &lf;
        ::memsetf( plf, 0, sizeof(LOGFONT) );
    }

    CHOOSEFONT cf;
    if (pcf == NULL)
    {
        pcf = &cf;
        InitCHOOSEFONT( pcf, plf, powin->QueryHwnd() );
    }

    APIERR err = NERR_Success;
    if ( !::ChooseFont( pcf ) )
    {
        //
        // returns FALSE with no extended error if user hits Cancel
        //
        err = ::CommDlgExtendedError();
        if (err == NO_ERROR)
        {
            *pfCancelled = TRUE;
            err = NERR_Success;
        }
        else
        {
            err = BLT::MapLastError( err );
        }
    }
    else if (pfont != NULL)
    {
        err = pfont->SetFont( *plf );
    }

    return err;
}


/*******************************************************************

    NAME:	WIN32_FONT_PICKER::InitCHOOSEFONT

    SYNOPSIS:	Initialize CHOOSEFONT to default values.  Clients can use
                this to fill in only the interesting fields,
                for example minimum / maximum font size

    ENTRY:	LOGFONT * plf - store pointer to this LOGFONT in CHOOSEFONT
                CHOOSEFONT * pcf - initialize this structure

    NOTES:      Code based on example in ProgRef volume 2 pp. 689-691

    HISTORY:
        JonN            23-Sep-1993     Created

********************************************************************/

VOID WIN32_FONT_PICKER::InitCHOOSEFONT( CHOOSEFONT * pcf,
                                        LOGFONT * plf,
                                        HWND hwndOwner )
{
    ASSERT( pcf != NULL && plf != NULL && hwndOwner != NULL );

    ::memsetf( pcf, 0, sizeof(CHOOSEFONT) );

    pcf->lStructSize = sizeof(CHOOSEFONT);
    pcf->hwndOwner   = hwndOwner;
    pcf->lpLogFont   = plf;
    pcf->Flags       = CF_SCREENFONTS;
    pcf->nFontType   = SCREEN_FONTTYPE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\fontedit.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    fontedit.cxx
	It contains the constructor of MLT_FONT, which the caller can
	specify the font for the MLT.
	It also contains the constructor of SLT_FONT, which is the same
	as MLT_FONT but it is for SLT.
	It also contains the constructor of MLE_FONT, which the caller can
	specify the font for the MLE.
	It also contains the constructor of SLE_FONT, which the caller can
	specify the font for the SLE.

    FILE HISTORY:
	terryk	21-Nov-1991	Created
	Yi-HsinS21-Feb-1992	Added SLE_FONT and MLE_FONT

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	MLT_FONT::MLT_FONT

    SYNOPSIS:	The is the same as normal MLT. However, the caller can
		specify the font type of the MLT.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		terryk	21-Nov-1991	Created

********************************************************************/

MLT_FONT::MLT_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : MLT( powin, cid ),
    _fontMLT( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontMLT.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontMLT.QueryHandle(), (LPARAM) FALSE );
}

/*******************************************************************

    NAME:	SLT_FONT::SLT_FONT

    SYNOPSIS:	The is the same as normal SLT. However, the caller can
		specify the font type of the SLT.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		terryk	21-Nov-1991	Created

********************************************************************/

SLT_FONT::SLT_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : SLT( powin, cid ),
    _fontSLT( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontSLT.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontSLT.QueryHandle(), (LPARAM) FALSE );
}

/*******************************************************************

    NAME:	MLE_FONT::MLE_FONT

    SYNOPSIS:	The is the same as normal MLE. However, the caller can
		specify the font type of the MLE.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		Yi-HsinS21-Feb-1992	Created

********************************************************************/

MLE_FONT::MLE_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : MLE( powin, cid ),
    _fontMLE( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontMLE.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontMLE.QueryHandle(), (LPARAM) FALSE );
}

/*******************************************************************

    NAME:	SLE_FONT::SLE_FONT

    SYNOPSIS:	The is the same as normal SLE. However, the caller can
		specify the font type of the SLT.

    ENTRY:	OWNER_WINDOW *powin - the pointer to the owner window
		CID cid - cid of the control
		enum FontType font - the specified font. The default is
		    FONT_DEFUALT

    HISTORY:
		Yi-HsinS21-Feb-1992	Created

********************************************************************/

SLE_FONT::SLE_FONT( OWNER_WINDOW *powin, CID cid, enum FontType font )
    : SLE( powin, cid ),
    _fontSLE( font )
{
    if ( QueryError() )
    {
	return;
    }

    if ( !_fontSLE.QueryError() )
	Command( WM_SETFONT, (WPARAM) _fontSLE.QueryHandle(), (LPARAM) FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\getfname.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    getfname.cxx

    Source file for the get filename classes.
    The class structure is the following:
                                BASE
                                  |
                            GET_FNAME_BASE_DLG
                            /              \
                GET_OPEN_FILENAME_DLG  GET_SAVE_FILENAME_DLG

    Since COMMDLG doesn't grok Unicode, this class must map between
    CHAR* and TCHAR* as appropriate.

    FILE HISTORY:
        terryk  09-Dec-1992     Created
        terryk  15-Jan-1992     Code review changed
        beng    30-Mar-1992     Added CHAR-TCHAR mapping
        YiHsinS 19-Jun-1992     Added CommDlgHookProc
        chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping (commdlg now unicode)
        YiHsinS 14-Aug-1992     Fixed unicode problem
*/

#include "pchapplb.hxx"   // Precompiled header

extern "C"
{
   // forward declaration
   // BOOL CommDlgHookProc( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam);

}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::GET_FNAME_BASE_DLG

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *pow - parent window

    HISTORY:
        terryk      09-Dec-1991 Created
        beng        30-Mar-1992 CHAR/TCHAR mapping
        beng        31-Jul-1992 Hacked out pszTemplate arg
        chuckc      08-Aug-1992 Remove CHAR-TCHAR mapping (commdlg now unicode)

********************************************************************/

GET_FNAME_BASE_DLG::GET_FNAME_BASE_DLG( OWNER_WINDOW *pow,
     					const TCHAR *pszHelpFile,
       					ULONG ulHelpContext )
    : BASE(),
    _hComdlg32Dll (NULL),
    _pfGetOpenFileName (NULL),
    _pfGetSaveFileName (NULL),
    _pfExtendedError (NULL),
    _bufFilename( (UINT) PATHLEN * sizeof(TCHAR) ),
    _bufFilenameTitle( (UINT)PATHLEN * sizeof(TCHAR) ),
    _bufFilter(0),
    _bufCustomFilter(0),
    _fInitOfn(FALSE),
    _nlsHelpFile( pszHelpFile ),
    _ulHelpContext( ulHelpContext ),
    _fHelpActive( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }


    APIERR err;
    if ((( err = _bufFilename.QueryError()) != NERR_Success ) ||
        (( err = _bufFilenameTitle.QueryError()) != NERR_Success ) ||
        (( err = _bufFilter.QueryError()) != NERR_Success ) ||
        (( err = _bufCustomFilter.QueryError()) != NERR_Success ) ||
        (( err = _nlsHelpFile.QueryError()) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    if (((_hComdlg32Dll = LoadLibrary (COMDLG32_DLL_NAME)) == NULL) ||
        ((_pfGetOpenFileName = (PF_GetOpenFileName) GetProcAddress (
                                _hComdlg32Dll,
                                GETOPENFILENAME_NAME)) == NULL) ||
        ((_pfGetSaveFileName = (PF_GetSaveFileName) GetProcAddress (
                                _hComdlg32Dll,
                                GETSAVEFILENAME_NAME)) == NULL) ||
        ((_pfExtendedError =    (PF_ExtendedError) GetProcAddress (
                                _hComdlg32Dll,
                                EXTENDEDERROR_NAME)) == NULL))
    {
        ReportError (GetLastError());
        return;
    }

    UIASSERT( pow != NULL );
    _szFileExt[0] = TCH('\0');   // Initialize to empty string

    // initialize the internal variable
    InitialOFN();

    _ofn.hwndOwner = pow->QueryHwnd();
    _ofn.lCustData = (LPARAM) this;

#if 0 // hacked out - sorry
    _ofn.hInstance = ::QueryInst();
    if ( pszTemplateName != NULL )
    {
        err = SetStringField(&_ofn.lpTemplateName, ALIAS_STR(pszTemplateName));
        if (err != NERR_Success)
        {
            ReportError(err);
            return;
        }
        SetEnableTemplate();
    }
#endif

}


GET_FNAME_BASE_DLG::~GET_FNAME_BASE_DLG()
{
    FreeLibrary (_hComdlg32Dll);

    if (_fInitOfn) // set in InitialOfn
    {
        delete[] ((void *)_ofn.lpstrTitle);
        delete[] ((void *)_ofn.lpstrInitialDir);

#if 0 // more hack
        delete[] _ofn.lpTemplateName;
#endif

    }

    if ( IsHelpActive() )
    {
        ::WinHelp( _ofn.hwndOwner,
                   (TCHAR *) (QueryHelpFile()->QueryPch()),
                   (UINT) HELP_QUIT,
                   0L );
    }


}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::InitialOFN

    SYNOPSIS:   Clear up the OPENFILENAME data structure.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

VOID GET_FNAME_BASE_DLG::InitialOFN()
{
    // initialize the OPENFILENAME data structure

    _ofn.lStructSize = sizeof( OPENFILENAME );
    _ofn.hwndOwner = NULL;
    _ofn.hInstance = NULL;
    _ofn.lpstrFilter = NULL;
    _ofn.lpstrCustomFilter = NULL;
    _ofn.nMaxCustFilter = 0;
    _ofn.nFilterIndex = 0;
    _ofn.lpstrFile = (TCHAR *)_bufFilename.QueryPtr();
    _ofn.lpstrFile[0]=TCH('\0');       // Initial the first character to NULL
    _ofn.nMaxFile = _bufFilename.QuerySize() / sizeof(TCHAR) ;
    _ofn.lpstrFileTitle = (TCHAR *)_bufFilenameTitle.QueryPtr();
    _ofn.lpstrFileTitle[0]=TCH('\0');  // Initial the first character to NULL
    _ofn.nMaxFileTitle = _bufFilenameTitle.QuerySize() / sizeof(TCHAR) ;
    _ofn.lpstrInitialDir = NULL;
    _ofn.lpstrTitle = NULL;
    _ofn.Flags = 0;
    _ofn.nFileOffset = 0;
    _ofn.nFileExtension = 0;
    _ofn.lpstrDefExt = NULL;
    _ofn.lCustData = 0;
    _ofn.lpfnHook = NULL;
    _ofn.lpTemplateName = NULL;

    // SetHookProc( (MFARPROC) ::CommDlgHookProc, (DWORD) this );

    // All clear
    _fInitOfn = TRUE;
}

VOID GET_FNAME_BASE_DLG::OnHelp( HWND hwnd )
{

    NLS_STR *pnlsHelpFile = QueryHelpFile();
    if( pnlsHelpFile->QueryTextLength() != 0 )
    {

#if defined(DEBUG)
        HEX_STR nlsHelpContext( QueryHelpContext() );
        if( pnlsHelpFile != NULL )
        {
            DBGEOL( SZ("Help called on file ") << *pnlsHelpFile << \
                    SZ(", context ") << nlsHelpContext );
        }
        else
        {
            DBGEOL(SZ("Help called on unknown context ") << nlsHelpContext);
        }
#endif

        if( !::WinHelp( _ofn.hwndOwner,
                        (TCHAR *) pnlsHelpFile->QueryPch(),
                        (UINT) HELP_CONTEXT,
                        (DWORD) QueryHelpContext()))
        {
            ::MsgPopup( hwnd,
                        IDS_BLT_WinHelpError,
                        MPSEV_ERROR,
                        MP_OK );
        }
        else
        {
            SetHelpActive( TRUE );
        }

    }

}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::QueryErrorCode()

    SYNOPSIS:

    HISTORY:
                CongpaY  11-Dec-1992     Created

********************************************************************/
APIERR GET_FNAME_BASE_DLG :: QueryErrorCode () const
{
    return pfExtendedError () ();
}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetFilter

    SYNOPSIS:   Set the define filter to the given strings

    ENTRY:      STRLIST & strlist - the list of filter strings. These
                    must be even number of strings in the string list. The
                    format must be something like:
                        "Write Files(*.TXT)",   "*.txt",
                        "Word Files(*.DOC;*.TXT)", "*.doc;*.txt"
                nFilterIndex - specified an index into the buffer
                    pointed by the lpstrFilter member. The system uses
                    the index value to obtain a pair of strings to use
                    as the initial filter description and filter pattern
                    for the dialog box. The first pair of strings has an
                    index value of 1. When the user dismisses the dialog
                    box, the system copies the index of the selected
                    filter strings into this location. If the number is
                    0, the custom filter will be used. If the number is
                    0 and the custom filter is NULL, the system will use
                    the first filter in the defined Filter ( this one ).
                    The number is the index of pair, i.e., 1 for the
                    first pair and 2 for the second pair.

    RETURNS:    APIERR - NERR_Success for succeed. Otherwise, it will
                    return the error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetFilter( STRLIST & slFilter,
                                      DWORD nFilterIndex )
{
    APIERR err = SetBuffer( &_bufFilter, slFilter );
    if ( err != NERR_Success )
    {
        return err;
    }

    _ofn.lpstrFilter = (TCHAR *)_bufFilter.QueryPtr();
    _ofn.nFilterIndex = nFilterIndex;

    // Initialize the file extension to the first file ext. in the filter
    TCHAR *pszFilter = (TCHAR *) _ofn.lpstrFilter;
    pszFilter += ::strlenf( pszFilter ) + 3;  // 3 : one for NULL char,
                                              //     and the other two for
                                              //     getting past "*."

    _ofn.lpstrDefExt = _szFileExt;
    ::strcpyf( (TCHAR *)_ofn.lpstrDefExt, pszFilter );

    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FILE_DLG::SetCustomFilter

    SYNOPSIS:   Set the define filter to the given strings

    ENTRY:      STRLIST & strlist - the list of filter strings. These
                    must be even number of strings in the string list. The
                    format must be something like:
                        "Write Files(*.TXT)",   "*.txt",
                        "Word Files(*.DOC;*.TXT)", "*.doc;*.txt"
                nFilterIndex - specifise an index into the buffer
                    pointed by the lpstrFilter member. The system uses
                    the index value to obtain a pair of strings to use
                    as the initial filter description and filter pattern
                    for the dialog box. The first pair of strings has an
                    index value of 1. When the user dismisses the dialog
                    box, the system copies the index of the selected
                    filter strings into this location. If the number is
                    0, the custom filter (this filter) will be used. If
                    the number is 0 and the custom filter is NULL, the
                    system will use the first filter in the defined Filter.

    RETURNS:    APIERR - NERR_Success for succeed. Otherwise, it will
                    return the error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetCustomFilter( STRLIST & slFilter,
                                            DWORD nFilterIndex)
{
    APIERR err = SetBuffer( &_bufCustomFilter, slFilter );
    if ( err != NERR_Success )
    {
        return err;
    }

    _ofn.lpstrCustomFilter = (TCHAR *)_bufCustomFilter.QueryPtr();
    _ofn.nFilterIndex = nFilterIndex;
    _ofn.nMaxCustFilter = _bufCustomFilter.QuerySize();

    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetBuffer

    SYNOPSIS:   Put the string list's strings into the buffer

    ENTRY:      BUFFER *pBuf - the buffer which receives the strings
                STRLIST & slFilter - the string list

    EXIT:       BUFFER *pBuf - it will fill with strings.  In a Unicode
                environment, these will be MBCS strings, for the
                non-Unicode COMMDLG.

    RETURNS:    APIERR - In case of not enough memory to resize the
                buffer.

    NOTES:      It will add an empty string at the end of the buffer.

    HISTORY:
                terryk  09-Dec-1991     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetBuffer( BUFFER *pBuf, STRLIST & slFilter )
{
    ITER_STRLIST iter( slFilter );
    APIERR err;
    NLS_STR *pnlsTemp;
    UINT cchBuffer = 0;
    UINT cnlsTotal = 0;

    // find total buffer size and number of strings
    while (( pnlsTemp = iter.Next() ) != NULL )
    {
        cchBuffer += pnlsTemp->QueryTextLength() + 1;
        cnlsTotal ++;
    }

    // we must have even number of string in the list
    if (( cnlsTotal % 2 ) != 0 )
    {
        UIASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    // Resize the buffer to fit all the strings plus 1 empty string
    if (( err = pBuf->Resize( (cchBuffer + 1) * sizeof( TCHAR ) ))
	!= NERR_Success )
    {
        // not enough memory...
        return err;
    }

    iter.Reset();
    TCHAR *pch = (TCHAR *)pBuf->QueryPtr();
    UINT cchRemaining = cchBuffer;
    while (( pnlsTemp = iter.Next() ) != NULL )
    {
        // put the strings into the buffer
        err = pnlsTemp->CopyTo( pch, cchRemaining * sizeof(TCHAR) );

        if ( err != NERR_Success )
            return err;

        pch += pnlsTemp->QueryTextLength() + 1;
        cchRemaining -= pnlsTemp->QueryTextLength() + 1;
    }
    // the last string must be NULL
    ASSERT(cchRemaining == 0);
    *pch = TCH('\0');

    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetHookProc

    SYNOPSIS:   Set the dialog call back hook function

    ENTRY:      MFARPROC lpfnHook - points to a hook function that
                    processes message intended for the dialog box. The
                    hook function should return FALSE to pass a message
                    on to the standard dialog procedure, or TRUE to
                    discard the message.
    NOTE:
                lCustData - specifics application-defined data that the
                system passes to the hook function. The system passes
                the data in the lParam parameter of the WM_INITDIALOG
                message. This is always set to "this" pointer.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

extern "C"
{
    typedef WORD (FAR PASCAL *FARHOOKPROC)(HWND, unsigned, WORD, LONG);
}

VOID GET_FNAME_BASE_DLG::SetHookProc( MFARPROC lpfnHook )
{
    SetEnableHook();

#ifdef WIN32
    _ofn.lpfnHook = (LPOFNHOOKPROC)lpfnHook;
#else
    _ofn.lpfnHook = (FARHOOKPROC)lpfnHook;
#endif

}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetInitialDir

    SYNOPSIS:   Set the initial directory to the given string.

    ENTRY:      const NLS_STR &nlsDir - the initial directory path

    RETURNS:    APIERR - in case of error while copying

    HISTORY:
                terryk  07-Jan-1992     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetInitialDir( const NLS_STR &nlsDir )
{
    return SetStringField((TCHAR **)&_ofn.lpstrInitialDir, nlsDir);
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetText

    SYNOPSIS:   Set the dialog window title to the given string

    ENTRY:      const NLS_STR &nlsText - the window title

    RETURNS:    APIERR - in case of error while copying

    HISTORY:
                terryk  07-Jan-1992     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetText( const NLS_STR &nlsText )
{
    return SetStringField((TCHAR **)&_ofn.lpstrTitle, nlsText);
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetFileExtension

    SYNOPSIS:   set the default extension string

    ENTRY:      const NLS_STR & nlsExt - default extension string

    RETURNS:    APIERR - return Copy string error.

    HISTORY:
                terryk  07-Jan-1992     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetFileExtension( const NLS_STR & nlsExt )
{
    _ofn.lpstrDefExt = _szFileExt;
    return nlsExt.CopyTo( (TCHAR *)_ofn.lpstrDefExt, nlsExt.QueryTextSize() );
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::SetStringField

    SYNOPSIS:   Sets a string field within the OFN (common code)

    ENTRY:      ppszDest  - Pointer to destination field
                nlsArg    - Given value, as NLS_STR

    RETURNS:    APIERR - return Copy string error.

    HISTORY:
        beng    30-Mar-1992     Created

********************************************************************/

APIERR GET_FNAME_BASE_DLG::SetStringField( TCHAR ** ppszDest,
                                           const NLS_STR & nlsArg )
{
    // Delete old value before alloc'ing new value.  While this prevents
    // retaining the old val in case of err, it minimizes heap fragmentation.

    delete[] *ppszDest;
    *ppszDest = NULL;

    UINT cchNeeded = nlsArg.QueryTextLength() + 1;

    TCHAR *pszNew = new TCHAR[cchNeeded];
    if (pszNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    APIERR err = nlsArg.CopyTo(pszNew, cchNeeded*sizeof(TCHAR) );
    if (err != NERR_Success)
        return err;

    *ppszDest = pszNew;
    return NERR_Success;
}


/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::QueryFilename

    SYNOPSIS:   get the user's inputed filename from the dialog box

    ENTRY:      NLS_STR *pnlsFilename - pointer to the receive buffer

    EXIT:       NLS_STR *pnlsFilename - user inputed filename

    RETURNS:    APIERR - return the string assignment error

    NOTES:      Use after Process is called.

    HISTORY:
                terryk  12-Dec-1991     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::QueryFilename( NLS_STR *pnlsFilename ) const
{
    UIASSERT( pnlsFilename != NULL );

    return pnlsFilename->CopyFrom( _ofn.lpstrFile );
}

/*******************************************************************

    NAME:       GET_FNAME_BASE_DLG::QueryFileTitle

    SYNOPSIS:   get the user inputed file title from the dialog box

    ENTRY:      NLS_STR *pnlsTitle - pointer to the receive buffer

    EXIT:       NLS_STR *pnlsTitle - user inputed file title

    RETURNS:    APIERR - return the string assignment error

    NOTES:      Use after Process is called.

    HISTORY:
                terryk  12-Dec-1991     Created
                beng    30-Mar-1992     CHAR/TCHAR mapping
                chuckc  08-Aug-1992     Remove CHAR-TCHAR mapping
					(commdlg now unicode)

********************************************************************/

APIERR GET_FNAME_BASE_DLG::QueryFileTitle( NLS_STR *pnlsTitle ) const
{
    UIASSERT( pnlsTitle != NULL );

    return pnlsTitle->CopyFrom( _ofn.lpstrFileTitle );
}


/*******************************************************************

    NAME:       GET_OPEN_FILENAME_DLG::GET_OPEN_FILENAME_DLG

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *pow - parent window
                const TCHAR * pszTemplateName - dialog template name

    HISTORY:
        terryk      09-Dec-1991 Created
        beng        31-Jul-1992 Hacked out template arg

********************************************************************/

GET_OPEN_FILENAME_DLG::GET_OPEN_FILENAME_DLG( OWNER_WINDOW *pow,
    					      const TCHAR *pszHelpFile,
					      ULONG ulHelpContext )
    : GET_FNAME_BASE_DLG( pow, pszHelpFile, ulHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       GET_OPEN_FILENAME_DLG::Process

    SYNOPSIS:   call GetOpenFileName to get the filename.

    ENTRY:      BOOL *pfRetVal - optional BOOL. If the user hits CANCEL,
                it will return FALSE. Otherwise, it will return TRUE.

    EXIT:       BOOL *pfRetVal - exit condition

    RETURNS:    APIERR - return the dialog error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_OPEN_FILENAME_DLG::Process( BOOL *pfRetVal )
{
    BOOL fRetVal = pfGetOpenFileName () ( QueryOFN() );
    if ( pfRetVal != NULL )
    {
        *pfRetVal = fRetVal;
    }
    return QueryErrorCode();
}


/*******************************************************************

    NAME:       GET_SAVE_FILENAME_DLG::GET_SAVE_FILENAME_DLG

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *pow - parent window

    HISTORY:
        terryk      09-Dec-1991 Created
        beng        31-Jul-1992 Hacked out template arg

********************************************************************/

GET_SAVE_FILENAME_DLG::GET_SAVE_FILENAME_DLG( OWNER_WINDOW *pow,
    					      const TCHAR *pszHelpFile,
					      ULONG ulHelpContext )
    : GET_FNAME_BASE_DLG( pow, pszHelpFile, ulHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       GET_SAVE_FILENAME_DLG::Process

    SYNOPSIS:   call GetSaveFileName to get the filename.

    ENTRY:      BOOL *pfRetVal - optional BOOL. If the user hits CANCEL,
                it will return FALSE. Otherwise, it will return TRUE.

    EXIT:       BOOL *pfRetVal - exit condition

    RETURNS:    APIERR - return the dialog error code.

    HISTORY:
                terryk  09-Dec-1991     Created

********************************************************************/

APIERR GET_SAVE_FILENAME_DLG::Process( BOOL *pfRetVal )
{
    BOOL fRetVal = pfGetSaveFileName () ( QueryOFN() );
    if ( pfRetVal != NULL )
    {
        *pfRetVal = fRetVal;
    }
    return QueryErrorCode();
}


/*******************************************************************

    NAME:       CommDlgHookProc

    SYNOPSIS:   Hook procedure into the common open file dialog
                and save file dialog. The main purpose of this
                hook procedure is to change the default file
                extension if the user changes selection.

    ENTRY:

    EXIT:

    RETURNS:    Returns TRUE is you want the commdlg to ignore this
                message. FALSE if you want it to handle this message.

    HISTORY:
                Yi-HsinS  19-Jun-1992     Created

********************************************************************/

static LPOPENFILENAME __plpOFN = NULL;

BOOL CommDlgHookProc( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam )
{

    UNREFERENCED( hDlg );

    if ( wMsg == WM_INITDIALOG )
    {
        __plpOFN = (LPOPENFILENAME) lParam;
        return TRUE;
    }

    CONTROL_EVENT e( wMsg, wParam, lParam );

    if ( e.QueryCid() == cmb1     // COMBO box of type
       && e.QueryMessage() == WM_COMMAND
       && e.QueryCode() == CBN_SELCHANGE
       )
    {
        INT iSel = (INT) ::SendMessage( (HWND) lParam, CB_GETCURSEL, 0, 0L );

        UIASSERT( __plpOFN != NULL );

        TCHAR *pszFilter = (TCHAR *)__plpOFN->lpstrFilter;

        for ( INT i = 0; i < iSel; i++ )
        {
             pszFilter += ::strlenf( pszFilter ) + 1;
             pszFilter += ::strlenf( pszFilter ) + 1;
        }

        pszFilter += ::strlenf( pszFilter ) + 1;
        pszFilter += 2;        // Get past "*."

        if ( *pszFilter == TCH('*') )
            pszFilter++;

        ::strcpyf( (TCHAR *)__plpOFN->lpstrDefExt, pszFilter );
        return TRUE;

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\getuser.cxx ===
/**********************************************************************/
/**                         Microsoft Windows NT                     **/
/**               Copyright(c) Microsoft Corp., 1992                 **/
/**********************************************************************/

/*
    GetUser.cxx

    This file contains the implementation for the User Browser "C" api.

    FILE HISTORY:
    AndyHe & JohnL  11-Oct-1992 Created
    AndyHe          30-Oct-1992 Modified per code review changes

*/

#include "pchapplb.hxx"   // Precompiled header

extern "C"
{
    // must be included after usrbrows.hxx

    #include <getuser.h>
    #include "mnet.h"
}

APIERR QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                NLS_STR * pnlsDomain );


//
//  Internal structure passed back to caller and used by all three calls
//
typedef struct tagUSBR {    // usbr
    BROWSER_SUBJECT_ITER    * piterUserSelection;
    NT_USER_BROWSER_DIALOG  * pdlgUserBrows ;
    NLS_STR                 * pnlsDomainName ;
    BROWSER_SUBJECT         * pBrowserSubject ;
    BOOL                      fExpandNames;
} USERBROW, *LPUSERBROW;

static BOOL fInit = FALSE ;

/*******************************************************************

    NAME:    OpenUserBrowser

    SYNOPSIS:    Allows the user to select from a list of users and passes
                a handle back to the caller to allow it to iterate through
                the selected users

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:

********************************************************************/

HUSERBROW    OpenUserBrowser( LPUSERBROWSER lpUserParms )
{
    APIERR err = NERR_Success ;

    if ( !fInit )
    {
        if (err = BLT::Init( NULL, 0, 0, 0, 0 ))
        {
            SetLastError( err ) ;
            return NULL ;
        }

        fInit = TRUE ;
    }
    AUTO_CURSOR niftycursor ;       // Put up an our glass

    // quick validation of parms passed in...

    if (lpUserParms == NULL)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return(NULL);
    }

    if ( lpUserParms->ulStructSize != sizeof( USERBROWSER ) )
    {
        SetLastError( ERROR_BAD_LENGTH );
        return(NULL);
    }

    // check for single select

    BOOL fSingle = (USRBROWS_SINGLE_SELECT & lpUserParms->Flags) ? TRUE : FALSE ;

    ULONG    ulFlags ;

    // check for valid flags...  is the Flags value only made up of valid flags?

    ulFlags = lpUserParms->Flags ;
    ulFlags &= (~USRBROWS_SHOW_ALL );
    ulFlags &= (~USRBROWS_INCL_ALL );
    ulFlags &= (~USRBROWS_EXPAND_USERS );
    ulFlags &= (~USRBROWS_DONT_SHOW_COMPUTER );
    ulFlags &= (~USRBROWS_SINGLE_SELECT  );

    if ( ulFlags )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return(NULL);
    }


    // Flags value is good but we've trashed it... reload

    ulFlags = lpUserParms->Flags ;

    lpUserParms->fUserCancelled = FALSE;

    LPCTSTR pszDCName = lpUserParms->pszInitialDomain ;
    DOMAIN_WITH_DC_CACHE domTarget( lpUserParms->pszInitialDomain, TRUE ) ;

    // if the initial domain passed in is not a server (no \\) then we
    // find a domain controller to be our server

    if ( lpUserParms->pszInitialDomain != NULL &&
         lpUserParms->pszInitialDomain[0] != TCH('\0') &&
         lpUserParms->pszInitialDomain[0] != TCH('\\') &&
         lpUserParms->pszInitialDomain[1] != TCH('\\')     )
    {
        if ( err = domTarget.GetInfo() )
        {
            SetLastError( err );
            return(NULL);
        }
        pszDCName = domTarget.QueryAnyDC() ;
    }

    //
    //  Create the dialog
    //

    NT_USER_BROWSER_DIALOG * pdlgUserBrows = new NT_USER_BROWSER_DIALOG(
             fSingle ? USRBROWS_SINGLE_DIALOG_NAME : USRBROWS_DIALOG_NAME,
             lpUserParms->hwndOwner,
             pszDCName,
             lpUserParms->ulHelpContext,
             ulFlags,
             lpUserParms->pszHelpFileName ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( pdlgUserBrows == NULL || (err = pdlgUserBrows->QueryError()) )
    {
        delete pdlgUserBrows ;
        SetLastError( err );
        return(NULL);
    }

    //
    //  Set the title if it isn't NULL
    //

    if ( lpUserParms->pszTitle != NULL )
    {
        pdlgUserBrows->SetText( lpUserParms->pszTitle ) ;
    }

    //
    // bring up the dialog and make sure the user hits OK...
    //

    BOOL fUserPressedOK ;
    if ( (err = pdlgUserBrows->Process( &fUserPressedOK )) ||
         !fUserPressedOK )
    {
        delete pdlgUserBrows ;

        if ( err == NERR_Success ) {            // user hit cancel or close
            lpUserParms->fUserCancelled = TRUE;
        }
        SetLastError( err );
        return(NULL);
    }


    // allocate the iterator

    BROWSER_SUBJECT_ITER * piterUserSelection = new BROWSER_SUBJECT_ITER(
            pdlgUserBrows ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( piterUserSelection == NULL || (err = piterUserSelection->QueryError()) )
    {
        delete pdlgUserBrows ;
        delete piterUserSelection ;

        SetLastError( err );
        return(NULL);
    }


    // store the name of the currently focused domain name
    // this will be used in the QueryQualifiedName call in the enum call

    NLS_STR * pnlsDomainName = new NLS_STR;

    err = ERROR_NOT_ENOUGH_MEMORY;

    if (pnlsDomainName == NULL ||
        (err = pnlsDomainName->QueryError()) ||
        (err = QueryLoggedOnDomainInfo( NULL, pnlsDomainName )) )
    {
        delete pdlgUserBrows ;
        delete pdlgUserBrows ;
        delete pnlsDomainName;

        SetLastError( err );
        return(NULL);
    }

    // allocate the block to pass back to the caller

    LPUSERBROW lpusbrInstance;

    lpusbrInstance = (LPUSERBROW) new USERBROW;

    if (lpusbrInstance == NULL) {
        delete piterUserSelection ;
        delete pdlgUserBrows ;
        delete pnlsDomainName ;

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }

    // fill in the block, return it to the caller and hope someday we get it
    // back to iterate and free.

    lpusbrInstance->fExpandNames       = lpUserParms->fExpandNames;
    lpusbrInstance->piterUserSelection = piterUserSelection;
    lpusbrInstance->pdlgUserBrows      = pdlgUserBrows;
    lpusbrInstance->pnlsDomainName     = pnlsDomainName;
    lpusbrInstance->pBrowserSubject    = NULL;

    return (HUSERBROW) lpusbrInstance ;
}




/*******************************************************************

    NAME:    EnumUserBrowserSelection

    SYNOPSIS:    Returns the next user selected by the user from the
                iterator created when the dialog box was displayed.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:        Calling program passes in rather large buffer which
                we fill in.

    HISTORY:

********************************************************************/

BOOL EnumUserBrowserSelection( HUSERBROW hHandle, LPUSERDETAILS lpUser, DWORD *plBufferSize )
{
    LPUSERBROW lpusbrInstance = (LPUSERBROW) hHandle;

    if (lpusbrInstance == NULL || lpusbrInstance->piterUserSelection == NULL)
    {
        SetLastError( ERROR_INVALID_HANDLE );
        return(FALSE);
    }

    APIERR err = NERR_Success ;

    const TCHAR * pszDisplay     = NULL;
    const TCHAR * pszAccount     = NULL;
    const TCHAR * pszFullName    = NULL;
    const TCHAR * pszDomain      = NULL;
    const TCHAR * pszComment     = NULL;

    PSID    psidUser;
    PSID    psidDomain;

    BROWSER_SUBJECT * pBrowserSubject = lpusbrInstance->pBrowserSubject;

    if ( pBrowserSubject == NULL ) {

        // use the iterator to grab the next user detail record that the
        // user selected

        if ( (err = lpusbrInstance->piterUserSelection->Next( &pBrowserSubject )) )
        {
            SetLastError( err );
            return(FALSE);
        }

        if ( pBrowserSubject == NULL ) {
            SetLastError( ERROR_NO_MORE_ITEMS );
            return(FALSE);
        }
    }

    lpusbrInstance->pBrowserSubject = NULL;        // zero out the current entry

    // we now have our object, get all the pointers we need

    pszFullName = pBrowserSubject->QueryFullName();
    pszComment = pBrowserSubject->QueryComment();
    pszAccount = pBrowserSubject->QueryAccountName();

    psidUser = pBrowserSubject->QuerySid()->QueryPSID();
    psidDomain = pBrowserSubject->QueryDomainSid()->QueryPSID();

    if ( (psidUser != NULL && IsValidSid(psidUser) == FALSE ) )
        psidUser = NULL;

    if ( (psidDomain != NULL && IsValidSid(psidDomain) == FALSE ) )
        psidDomain = NULL;

    if ( (psidUser != NULL && IsValidSid(psidUser) == FALSE ) ||
         (psidDomain != NULL && IsValidSid(psidDomain) == FALSE ) )
    {
        SetLastError( ERROR_INVALID_DATA );
        return(FALSE);
    }

    NLS_STR  nlsDisplayName ;

    if ((err = nlsDisplayName.QueryError()) ||
        (err = pBrowserSubject->QueryQualifiedName(
                        &nlsDisplayName,
                        lpusbrInstance->pnlsDomainName,
                        lpusbrInstance->fExpandNames ))  )
    {
        SetLastError( err );
        return(FALSE);
    }

    pszDisplay = nlsDisplayName.QueryPch();
    pszDomain = pBrowserSubject->QueryDomainName();

    // now calculate all the relavent field locations to see if it will fit.
    // min length is one for length of null, even if null

    UINT uiDisplayLen    = ( pszDisplay ? lstrlen(pszDisplay) : 0 ) + 1;
    UINT uiAccountLen    = ( pszAccount ? lstrlen(pszAccount) : 0 ) + 1;
    UINT uiFullNameLen   = ( pszFullName? lstrlen(pszFullName): 0 ) + 1;
    UINT uiDomainLen     = ( pszDomain  ? lstrlen(pszDomain ) : 0 ) + 1;
    UINT uiCommentLen    = ( pszComment ? lstrlen(pszComment) : 0 ) + 1;

    UINT uiSidUserLen    = ( psidUser   ? GetLengthSid(psidUser) : 0 ) + 1;
    UINT uiSidDomainLen  = ( psidDomain ? GetLengthSid(psidDomain) : 0 ) + 1;

    UINT_PTR uiTotalLength   = (UINT_PTR)lpUser + sizeof( USERDETAILS );

    // we're unicode so all string lengths are dword boundaries

    // sids must be on dword boundaries, these will be the first fields we
    // copy and we'll round up to the nearest dword

    uiTotalLength   = ( ( uiTotalLength + 8 ) & ~7 );
    uiTotalLength  -= (UINT_PTR)lpUser ;
                                              
    uiSidUserLen   = ( ( uiSidUserLen + 8 ) & 0xFFFFFFF8 );
    uiSidDomainLen = ( ( uiSidDomainLen + 8 ) & 0xFFFFFFFC );

    uiTotalLength += uiSidUserLen + uiSidDomainLen ;

    // strings that follow must start on a word boundary, round up

    uiTotalLength += uiDisplayLen * sizeof(TCHAR) ;
    uiTotalLength += uiAccountLen * sizeof(TCHAR) ;
    uiTotalLength += uiFullNameLen * sizeof(TCHAR) ;
    uiTotalLength += uiDomainLen * sizeof(TCHAR) ;
    uiTotalLength += uiCommentLen * sizeof(TCHAR) ;

    if (*plBufferSize <= uiTotalLength )
    {
        lpusbrInstance->pBrowserSubject = pBrowserSubject;
        *plBufferSize = (DWORD)uiTotalLength ;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return(FALSE);
    }

    // shouldn't fail from here on

    UINT_PTR uiTemp = (UINT_PTR) lpUser + sizeof( USERDETAILS );

    uiTemp   = ( ( uiTemp + 8 ) & ~7 );            // dword boundary for these!

    lpUser->psidUser   = (PSID) uiTemp ;

    uiTemp += uiSidUserLen ;                       // uiSidUserLen is dword divisible

    lpUser->psidDomain = (PSID) uiTemp ;

    uiTemp += uiSidDomainLen ;

    lpUser->pszFullName = (TCHAR *) uiTemp ;

    lpUser->pszAccountName = (TCHAR *)( (UINT_PTR) (lpUser->pszFullName) +
                             (uiFullNameLen * sizeof(TCHAR)) ) ;

    lpUser->pszDisplayName = (TCHAR *)( (UINT_PTR) (lpUser->pszAccountName) +
                             ( uiAccountLen * sizeof(TCHAR)) ) ;

    lpUser->pszDomainName  = (TCHAR *)( (UINT_PTR) (lpUser->pszDisplayName) +
                             ( uiDisplayLen * sizeof(TCHAR)) ) ;

    lpUser->pszComment     = (TCHAR *)( (UINT_PTR) (lpUser->pszDomainName) +
                             ( uiDomainLen * sizeof(TCHAR)) ) ;

    if (psidUser != NULL)
        CopySid( uiSidUserLen, lpUser->psidUser, psidUser );

    if (psidDomain != NULL)
        CopySid( uiSidDomainLen, lpUser->psidDomain, psidDomain );

    if (pszFullName != NULL)
        lstrcpy( lpUser->pszFullName, pszFullName );

    if (pszAccount != NULL)
        lstrcpy( lpUser->pszAccountName, pszAccount );

    if (pszComment != NULL)
        lstrcpy( lpUser->pszComment, pszComment );

    if (pszDisplay != NULL)
        lstrcpy( lpUser->pszDisplayName, pszDisplay );

    if (pszDomain != NULL)
        lstrcpy( lpUser->pszDomainName, pszDomain );

    lpUser->UserType = pBrowserSubject->QueryType() ;

    return TRUE ;
}




/*******************************************************************

    NAME:    CloseUserBrowser

    SYNOPSIS:    Frees all resources associated with an instance of User Browser

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:

********************************************************************/

BOOL    CloseUserBrowser( HUSERBROW hInstance )
{
    LPUSERBROW lpusbrInstance = (LPUSERBROW) hInstance;

    if (lpusbrInstance == NULL ||
        lpusbrInstance->piterUserSelection == NULL)
    {
        SetLastError( ERROR_INVALID_HANDLE );
        return(FALSE);
    }

    delete lpusbrInstance->piterUserSelection ;
    lpusbrInstance->piterUserSelection = NULL;

    delete lpusbrInstance->pdlgUserBrows ;
    delete lpusbrInstance->pnlsDomainName ;
    delete lpusbrInstance;

    return(TRUE);
}


/*******************************************************************

    NAME:    QueryLoggedOnDomainInfo

    SYNOPSIS:    Gets a DC from the domain the current user is logged onto or
        /and the domain the user is currently logged onto

    ENTRY:    pnlsDC - String to receive the DC name (may be NULL)
        pnlsDomain - String to receive the domain name (may be NULL)

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
    Johnl    10-Sep-1992    Created

********************************************************************/

APIERR QueryLoggedOnDomainInfo( NLS_STR * pnlsDC,
                NLS_STR * pnlsDomain )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsLoggedOnDomain( DNLEN+1 ) ;
    NLS_STR nlsLoggedOnDC( MAX_PATH+1 ) ;

    do { // error break out
    TCHAR achComputerName[MAX_COMPUTERNAME_LENGTH+1] ;
    DWORD cchComputerName = sizeof( achComputerName ) ;
    WKSTA_10 wksta10( NULL ) ;

    // get the computer name
    if ( !::GetComputerName( achComputerName, &cchComputerName ))
    {
        err = ::GetLastError() ;
        DBGEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
           "error getting the computer name, error " << err ) ;
        break ;
    }

    //
    // get the logon domain info from a WKSTA object
    //
    if ( (err = wksta10.QueryError()) ||
         (err = nlsLoggedOnDomain.QueryError()) ||
         (err = nlsLoggedOnDC.QueryError())     ||
         (err = wksta10.GetInfo())      ||
         (err = nlsLoggedOnDomain.CopyFrom( wksta10.QueryLogonDomain())) )
    {
        //
        //     If the network isn't started, then we have to be logged on
        //     locally.
        //

        if ( err )
        {
            err = NERR_Success ;
        }
        else
        {
            break ;
        }

        ALIAS_STR nlsComputer( achComputerName ) ;
        if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )) ||
             (err = nlsLoggedOnDC.CopyFrom( SZ("\\\\") )) ||
             (err = nlsLoggedOnDC.Append( nlsComputer )) )
        {
            ;
        }

        /* Don't need to continue. The wksta is not started, so we
         * use logged on domain==localmachine, or its an
         */
        break ;
    }

    /* Check if the logged on domain is the same as the computer
     * name.  If it is, then the user is logged on locally.
     */
    if( !::I_MNetComputerNameCompare( achComputerName,
                                      wksta10.QueryLogonDomain() ) )
    {
        TRACEEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
             " user is logged on locally") ;
        ALIAS_STR nlsComputer( achComputerName ) ;
        if ( (err = nlsLoggedOnDomain.CopyFrom( nlsComputer )) ||
         (err = nlsLoggedOnDC.CopyFrom( SZ("\\\\") )) ||
         (err = nlsLoggedOnDC.Append( nlsComputer )) )
        {
        break ;
        }

        /* Don't need to continue since the logged on domain is
         * the local machine.
         */
        break ;
    }

    //
    //   If not interested in a DC, then don't get one
    //
    if ( pnlsDC == NULL )
        break ;

    DOMAIN_WITH_DC_CACHE domLoggedOn( wksta10.QueryLogonDomain(),
                      TRUE ) ;

    if ( (err = domLoggedOn.GetInfo()) ||
         (err = nlsLoggedOnDC.CopyFrom( domLoggedOn.QueryPDC())) )
    {
        DBGEOL("ACL_TO_PERM_CONVERTER::QueryLoggedOnDomainInfo, " <<
           " error " << err << " on domain get info for " <<
           wksta10.QueryLogonDomain() ) ;
        break ;
    }
    } while (FALSE) ;


    if ( !err )
    {
    if ( pnlsDC != NULL )
        err = pnlsDC->CopyFrom( nlsLoggedOnDC ) ;

    if ( !err && pnlsDomain != NULL )
        err = pnlsDomain->CopyFrom( nlsLoggedOnDomain ) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\lbcolw.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lbcolw.cxx
    Listbox Column Width class implementation

    FILE HISTORY:
        CongpaY     12-Jan-1993 Created.
        JonN        23-Sep-1993 Added virtual ReloadColumnWidths

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       LB_COL_WIDTHS::LB_COL_WIDTHS

    SYNOPSIS:   Listbox column width class constructor.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        CongpaY        12-Jan-1993 Created.
        JonN           23-Sep-1993 Added virtual ReloadColumnWidths

********************************************************************/

LB_COL_WIDTHS::LB_COL_WIDTHS (HWND      hWnd,
                              HINSTANCE hmod,
                              const IDRESOURCE & idres,
                              UINT cColumns,
                              UINT cNonFontColumns)
  : BASE(),
    _cColumns (cColumns),
    _cNonFontColumns( cNonFontColumns ),
    _pdxWidth( NULL )
{
    ASSERT( _cNonFontColumns <= cColumns );

    DISPLAY_CONTEXT dc (hWnd);
    INT nCharWidth = dc.QueryAveCharWidth();

    do   // error break out.
    {
        _pdxWidth = new UINT[cColumns];

        if (_pdxWidth == NULL)
        {
            DBGEOL(   "LB_COL_WIDTHS::ctor: alloc error "
                   << ERROR_NOT_ENOUGH_MEMORY );
            ReportError (ERROR_NOT_ENOUGH_MEMORY);
            break;
        }

        APIERR err = ReloadColumnWidths( hWnd, hmod, idres );
        if (err != NERR_Success)
        {
            DBGEOL("LB_COL_WIDTHS::ctor: ReloadColumnWidths error " << err );
            ReportError( err );
            break;
        }

    } while (FALSE);
}


/*******************************************************************

    NAME:       LB_COL_WIDTHS::ReloadColumnWidths

    SYNOPSIS:   Reloads column widths.  Use this after changing fonts.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        JonN           23-Sep-1993 Added virtual ReloadColumnWidths
        JonN           27-Sep-1993 Select non-default font

********************************************************************/

APIERR LB_COL_WIDTHS::ReloadColumnWidths( HWND hWnd,
                                          HINSTANCE hmod,
                                          const IDRESOURCE & idres )
{
    APIERR err = NERR_Success;

    do   // error break out.
    {
        HRSRC hColWidthTable = ::FindResource (hmod,
                                               idres.QueryPsz(),
                                               RT_RCDATA);

        if (hColWidthTable == NULL)
        {
            err = ::GetLastError();
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: FindResource error "
                   << err );
            break;
        }

        HGLOBAL hColWidths = ::LoadResource (hmod, hColWidthTable);

        if (hColWidths == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: LoadResource error "
                   << err );
            break;
        }

        WORD * lpColWidths = (WORD *) ::LockResource (hColWidths);

        if (lpColWidths == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: LockResource error "
                   << err );
            break;
        }

        if ( (err = StretchForFonts( hWnd, lpColWidths )) != NERR_Success )
        {
            DBGEOL(   "LB_COL_WIDTHS::ReloadColumnWidths: StretchForFonts error "
                   << err );
        }

    } while (FALSE);

    return err;
}


/*******************************************************************

    NAME:       LB_COL_WIDTHS::StretchForFonts

    SYNOPSIS:   Adjusts a table of column widths to account for changes
                in the default font.  Redefine if, for example, you don't
                want to stretch an icon column.

    ENTRY:      hWnd -          Handle to the listbox window
                pdxRawWidth -   Raw width table

    HISTORY:
        JonN           27-Sep-1993 Created

********************************************************************/

APIERR LB_COL_WIDTHS::StretchForFonts(    HWND   hWnd,
                                          const WORD * pdxRawWidth )
{
    DISPLAY_CONTEXT dc (hWnd);

    INT nUnadjustedCharWidth = dc.QueryAveCharWidth();
    INT nAdjustedCharWidth = nUnadjustedCharWidth;

    /*
     *  If the listbox is using other than the default font, we must
     *  determine which font this is and select it in the DC.
     */
    HFONT hFont = (HFONT)::SendMessage( hWnd, WM_GETFONT, 0, 0L );
    if ( hFont != NULL )
    {
        // Font isn't the system font
        HFONT hFontSave = dc.SelectFont( hFont );
        nAdjustedCharWidth = dc.QueryAveCharWidth();
        (void) dc.SelectFont( hFontSave );
    }

    INT i;
    for (i = 0; i < (INT)_cNonFontColumns; i++)
    {
         _pdxWidth[i] = ((UINT) pdxRawWidth[i])* nUnadjustedCharWidth / 4 ;

    }

    for (i=_cNonFontColumns; i < (INT)_cColumns; i++)
    {
         _pdxWidth[i] = ((UINT) pdxRawWidth[i])* nAdjustedCharWidth / 4 ;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       LB_COL_WIDTHS::~LB_COL_WIDTHS

    SYNOPSIS:   Listbox column width class destructor.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        CongpaY        12-Jan-1993 Created.

********************************************************************/

LB_COL_WIDTHS::~LB_COL_WIDTHS (void)
{
    delete (_pdxWidth);
    _pdxWidth = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\olb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    olb.cxx
    Outline listbox implementation

    FILE HISTORY:
        rustanl     16-Nov-1991 Created
        rustanl     22-Mar-1991 Rolled in code review changes from CR
                                on 21-Mar-1991 attended by ChuckC,
                                TerryK, BenG, AnnMc, RustanL.
        gregj       01-May-1991 Added GUILTT support.
        terryk      07-Jun-1991 Added the parent class name in constructor
        beng        31-Jul-1991 Error handling changed
        beng        21-Feb-1992 BMID def'ns moved into applibrc.h
        chuckc      23-Feb-1992 Added SELECTION_TYPE to LM_OLLB
        KeithMo     23-Jul-1992 Added maskDomainSources and
                                pszDefaultSelection to LM_OLLB, uses
                                BROWSE_DOMAIN_ENUM object in FillDomains.
        KeithMo     16-Nov-1992 Performance tuning.

*/

#include "pchapplb.hxx"   // Precompiled header

//  --------------------  OLLB_ENTRY definition  ------------------------


/*******************************************************************

    NAME:       OLLB_ENTRY::OLLB_ENTRY

    SYNOPSIS:   Outline listbox item constructor

    ENTRY:      ollbl -         Indicates level in hierarchy (domain, or server)
                fExpanded -     Indicates whether or not the item should
                                take the expanded look.  Must be
                                FALSE for servers.
                                It may be either for domains, since these
                                are expandable/collapsable.
                pszDomain -     Pointer to name of domain (for domains),
                                and name of the domain in which a server
                                exists (for servers).
                pszServer -     Pointer to name of servers.  Must be NULL
                                for the domains.  The server
                                name should *not* be preceded by two
                                backslashes.  In other words, its length
                                should never exceed MAX_PATH.

    HISTORY:
        rustanl     16-Nov-1991 Created
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

OLLB_ENTRY::OLLB_ENTRY( OUTLINE_LB_LEVEL   ollbl,
                        BOOL               fExpanded,
                        const TCHAR      * pszDomain,
                        const TCHAR      * pszServer,
                        const TCHAR      * pszComment )
  : LBI(),
    _ollbl( ollbl ),
    _fExpanded( fExpanded ),
    _nlsDomain( pszDomain ),
    _nlsServer( pszServer ),
    _nlsComment( pszComment )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsDomain.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsServer.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsComment.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }
}


OLLB_ENTRY::~OLLB_ENTRY()
{
    // nothing else to do
}


/*******************************************************************

    NAME:       OLLB_ENTRY::Paint

    SYNOPSIS:   Paint an entry in the outline listbox

    NOTES:

    HISTORY:
        beng        05-Oct-1991 Win32 conversion
        beng        08-Nov-1991 Unsigned widths
        beng        21-Apr-1992 Fix BLT_LISTBOX -> LISTBOX

********************************************************************/


VOID OLLB_ENTRY::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                        GUILTT_INFO * pGUILTT ) const
{
    //  Note.  plb is assumed to point to an OUTLINE_LISTBOX object.

    UINT anColWidths[ 4 ];
    anColWidths[ 0 ] = QueryLevel() * COL_WIDTH_OUTLINE_INDENT;
    anColWidths[ 1 ] = COL_WIDTH_DM;
    anColWidths[ 2 ] = COL_WIDTH_SERVER - anColWidths[ 0 ];
    anColWidths[ 3 ] = COL_WIDTH_AWAP;

    const TCHAR * pszName = NULL;

    switch ( QueryType() )
    {
    case OLLBL_DOMAIN:
        pszName = QueryDomain();
        break;

    case OLLBL_SERVER:
        pszName = QueryServer();
        break;

    default:
        ASSERTSZ( FALSE, "Invalid OLLBL type!" );
        return;
    }

    STR_DTE strdteName( pszName );
    STR_DTE strdteComment( _nlsComment.QueryPch());

    DISPLAY_TABLE dt( 4, anColWidths );
    dt[ 0 ] = NULL;
    dt[ 1 ] = ((OUTLINE_LISTBOX *)plb)->QueryDmDte( QueryType(), _fExpanded );
    dt[ 2 ] = &strdteName;
    dt[ 3 ] = &strdteComment;

    dt.Paint( plb, hdc, prect, pGUILTT );
}


INT OLLB_ENTRY::Compare( const LBI * plbi ) const
{
    //
    //  Compare the domain names.
    //

    const NLS_STR * pnls = &(((const OLLB_ENTRY *)plbi)->_nlsDomain);

    INT result = _nlsDomain.strcmp( *pnls );

    if( result == 0 )
    {
        //
        //  The domains match, so compare the servers.
        //

		// NTRAID#NTBUG9-574280-2002/03/07-artm  Prefast: Redeclaration of pnls hides var in outer scope.
		// This is just sloppy coding.  Either use a different variable name, or just reassign the
		// pointer (the string it points to is constant, but the pointer itself isn't).
        const NLS_STR * pnls = &(((const OLLB_ENTRY *)plbi)->_nlsServer);

        result = _nlsServer.strcmp( *pnls );
    }

    return result;
}


WCHAR OLLB_ENTRY::QueryLeadingChar() const
{
    if ( QueryType() != OLLBL_DOMAIN )
    {
        ISTR istr( _nlsServer );

        return _nlsServer.QueryChar( istr );
    }
    else
    {
        ISTR istr( _nlsDomain );

        return _nlsDomain.QueryChar( istr );
    }
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::OUTLINE_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin    - pointer OWNER_WINDOW
                cid      - CID

    EXIT:       The object is constructed.

    HISTORY:
        beng        21-Feb-1992 Check ctor failure for DMID_DTE; fix CID

********************************************************************/

OUTLINE_LISTBOX::OUTLINE_LISTBOX( OWNER_WINDOW * powin, CID cid,
                                  BOOL fCanExpand )
    :   BLT_LISTBOX( powin, cid ),
        _nS( 0 ),
        _pdmiddteDomain( NULL ),
        _pdmiddteDomainExpanded( NULL ),
        _pdmiddteServer( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( fCanExpand )
    {
        _pdmiddteDomain = new DMID_DTE( BMID_DOMAIN_NOT_EXPANDED );
        _pdmiddteDomainExpanded = new DMID_DTE( BMID_DOMAIN_EXPANDED );
    }
    else
    {
        _pdmiddteDomain = new DMID_DTE( BMID_DOMAIN_CANNOT_EXPAND );
        _pdmiddteDomainExpanded = _pdmiddteDomain;
    }
    _pdmiddteServer = new DMID_DTE( BMID_SERVER );

    if ( _pdmiddteDomain == NULL ||
         _pdmiddteDomainExpanded == NULL ||
         _pdmiddteServer == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    APIERR err;
    if (  ((err = _pdmiddteDomain->QueryError()) != NERR_Success)
        ||((err = _pdmiddteDomainExpanded->QueryError()) != NERR_Success)
        ||((err = _pdmiddteServer->QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}


OUTLINE_LISTBOX::~OUTLINE_LISTBOX()
{

    delete _pdmiddteDomain;

    if (_pdmiddteDomainExpanded != _pdmiddteDomain)
        delete _pdmiddteDomainExpanded;

    _pdmiddteDomain = NULL;
    _pdmiddteDomainExpanded = NULL;

    delete _pdmiddteServer;
    _pdmiddteServer = NULL;
}


INT OUTLINE_LISTBOX::AddItem( OUTLINE_LB_LEVEL ollbl,
                              BOOL fExpanded,
                              const TCHAR * pszDomain,
                              const TCHAR * pszServerName,
                              const TCHAR * pszComment       )
{
    //  Note.  BLT_LISTBOX::AddItem will check for NULL and QueryError.
    //  Hence, this is not done here.
    return BLT_LISTBOX::AddItem( new OLLB_ENTRY( ollbl,
                                                 fExpanded,
                                                 pszDomain,
                                                 pszServerName,
                                                 pszComment     ));
}

/*
 *  OUTLINE_LISTBOX::FindItem
 *
 *  Finds a particular item in the listbox
 *
 *  Parameters:
 *      pszDomain       A pointer to the domain name to be searched for
 *      pszServer       A pointer to the server name to be searched for.
 *                      This server name should be a simple computer name
 *                      without preceding backslashes.  If NULL, the domain
 *                      itself is searched for.
 *
 *  Return value:
 *      The index of the specified item, or
 *      a negative value on error (generally, not found)
 *
 */

INT OUTLINE_LISTBOX::FindItem( const TCHAR * pszDomain,
                               const TCHAR * pszServer  ) const
{
    UIASSERT( pszDomain != NULL );

    //  Do a small check to make sure server name does not begin with
    //  backslashes (only one is checked for here, but that's probably
    //  enough for a small check).
    UIASSERT( pszServer == NULL || pszServer[0] != TCH('\\') );

    OLLB_ENTRY ollbe( (( pszServer == NULL ) ? OLLBL_DOMAIN : OLLBL_SERVER ),
                      FALSE, pszDomain, pszServer, NULL );
    if ( ollbe.QueryError() != NERR_Success )
        return -1;

    return BLT_LISTBOX::FindItem( ollbe );
}


INT OUTLINE_LISTBOX::AddDomain( const TCHAR * pszDomain,
                                const TCHAR * pszComment,
                                BOOL fExpanded )
{
    return AddItem( OLLBL_DOMAIN,
                    fExpanded,
                    pszDomain,
                    NULL,
                    pszComment );
}


/*******************************************************************

    NAME:       OUTLINE_LISTBOX::AddServer

    SYNOPSIS:   Adds a server to the listbox.  Marks the domain as
                expanded.

    ENTRY:      pszDomain -         Pointer to name of domain of server to
                                    be added
                pszServer -         Pointer to name of server.  The name
                                    is expected to have no preceding
                                    backslashes, i.e., its length should
                                    not exceed MAX_PATH.
                pszComment -        Pointer to comment.  May be NULL to
                                    indicate no comment.

    NOTES:
        This method marks the domain as expanded.  However, DeleteItem
        on the last server of a domain does not do the reverse.  If a
        client deletes all servers belonging to a domain, he must
        also change the expanded state of the domain.

    HISTORY:
        rustanl     16-Nov-1991     Created

********************************************************************/

INT OUTLINE_LISTBOX::AddServer( const TCHAR * pszDomain,
                                const TCHAR * pszServer,
                                const TCHAR * pszComment )
{
    INT iDomainIndex = FindItem( pszDomain, NULL );
    if ( iDomainIndex < 0 )
    {
        UIASSERT( !SZ("Trying to add server for which there is no domain") );
        return -1;      // don't add a server for which there is no domain
    }


    // Attempt to add the server

    INT iServerIndex = AddItem( OLLBL_SERVER,
                                FALSE,          // a server is never expanded
                                pszDomain,
                                pszServer,
                                pszComment );
    if ( iServerIndex >= 0 )
    {
        //  Server was successfully added

        //  Expand domain
        SetDomainExpanded( iDomainIndex );
    }

    return iServerIndex;
}


VOID OUTLINE_LISTBOX::SetDomainExpanded( INT i, BOOL f )
{
    if ( i < 0 )
    {
        UIASSERT( !SZ("Invalid index") );
        return;
    }

    OLLB_ENTRY * pollbe = QueryItem( i );
    if ( pollbe == NULL )
    {
        UIASSERT( !SZ("Invalid index") );
        return;
    }

    UIASSERT( pollbe->QueryType() == OLLBL_DOMAIN );

    BOOL fCurrent = pollbe->IsExpanded();
    if (( fCurrent && f ) || ( !fCurrent && !f ))
        return;     // nothing to do

    //  Set the expanded state to "expanded".  Then, invalidate the item
    //  so that it will be repainted later.
    pollbe->SetExpanded( f );
    InvalidateItem( i );
}


INT OUTLINE_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    static WCHAR vpwS[] = { 0xc, 0x2, 0x10, 0x10, 0x5, 0x13, 0x7, 0x3 };

    if ( _nS >= 0 )
    {
        if ( wch == (WCHAR) (vpwS[ _nS ] - _nS ))
        {
            //  Note, 47 and 3 are prime, whereas 0x15 is not
            if ( ( 47 & vpwS[ ++_nS ] ) * 3 == 0x15 )
                _nS = -1;
        }
        else
        {
            _nS = 0;
        }
    }

    return BLT_LISTBOX::CD_Char( wch, nLastPos );
}


DM_DTE * OUTLINE_LISTBOX::QueryDmDte( OUTLINE_LB_LEVEL ollbl,
                                      BOOL fExpanded ) const
{
    switch ( ollbl )
    {
    case OLLBL_DOMAIN:
        if ( fExpanded )
            return _pdmiddteDomainExpanded;

        return _pdmiddteDomain;

    case OLLBL_SERVER:
        UIASSERT( ! fExpanded );
        return _pdmiddteServer;

    default:
        break;

    }

    UIASSERT( !SZ("Invalid level number") );
    return NULL;
}



//  ----------------------------  LM_OLLB  --------------------------------


/*
 *  LM_OLLB::LM_OLLB
 *
 *  The constructor adds the names of the domains,
 *  and the servers of the logon domain to the listbox.
 *
 */

LM_OLLB::LM_OLLB( OWNER_WINDOW * powin,
                  CID cid,
                  SELECTION_TYPE seltype,
                  const TCHAR * pszDefaultSelection,
                  ULONG maskDomainSources,
                  ULONG nServerTypes )
    :   OUTLINE_LISTBOX( powin, cid, (seltype != SEL_DOM_ONLY) ),
        _seltype(seltype),
        _nServerTypes( nServerTypes )
{
    if ( QueryError() != NERR_Success )
        return;

    AUTO_CURSOR autocur;        // this constructor may take some time, so
                                // pull out the ol' AUTO_CURSOR

    //  Add the names of the domains

    APIERR err = FillDomains( maskDomainSources, pszDefaultSelection );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    // Expand the selected domain if we need servers only
    //
    if (  ( _seltype == SEL_SRV_ONLY )
       || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN )
       )
    {
        INT nCurrentItem = QueryCurrentItem();
        ExpandDomain( nCurrentItem );
        SetTopIndex( nCurrentItem );
    }
}

/*
 *  LM_OLLB::LM_OLLB
 *
 *  This form of constructor does not enumerate the domains or servers.
 *  FillAllInfo should be used in conjunction with this.
 *
 */
LM_OLLB::LM_OLLB( OWNER_WINDOW * powin,
                  CID cid,
                  SELECTION_TYPE seltype,
                  ULONG nServerTypes )
    :   OUTLINE_LISTBOX( powin, cid, (seltype != SEL_DOM_ONLY) ),
        _seltype(seltype),
        _nServerTypes( nServerTypes )
{
    if ( QueryError() != NERR_Success )
        return;

    Enable( FALSE );
    Show( FALSE );
}

VOID LM_OLLB::FillAllInfo( BROWSE_DOMAIN_ENUM *pEnumDomains,
                           SERVER1_ENUM       *pEnumServers,
                           const TCHAR        *pszSelection )
{
    UIASSERT( !IsEnabled() );
    UIASSERT( pEnumDomains != NULL );

    //
    //  Since BROWSE_DOMAIN_ENUM will always return a
    //  *sorted* list of domains, we can temporarily
    //  remove the LBS_SORT style from the listbox.
    //  This will eliminate a large number of client-
    //  server transitions as items are added to the
    //  listbox.
    //

    ULONG style = QueryStyle();
    SetStyle( style & ~LBS_SORT );

    //
    //  Add the domains to the listbox.
    //

    const BROWSE_DOMAIN_INFO * pbdi;

    while( ( pbdi = pEnumDomains->Next() ) != NULL )
    {
        AddDomain( pbdi->QueryDomainName(), NULL );
    }

    //
    //  Restore the original style bits.
    //

    if( style & LBS_SORT )
    {
        SetStyle( QueryStyle() | LBS_SORT );
    }

    INT iSelection = -1;
    if (  ( pszSelection != NULL && pszSelection[0] != TCH('\0') )
       && ( (iSelection = FindItem( pszSelection, NULL )) >= 0 )
       )
    {
        SelectItem( iSelection );

        //
        // Expand the selected domain if we need servers only
        // pEnumServers should be NULL if we are not selecting servers.
        //
        if ( pEnumServers != NULL )
        {
            UIASSERT(    ( _seltype == SEL_SRV_ONLY )
                      || ( _seltype == SEL_SRV_EXPAND_LOGON_DOMAIN ) )

            SERVER1_ENUM_ITER sei1( *pEnumServers );
            const SERVER1_ENUM_OBJ * psi1;

            while ( ( psi1 = sei1()) != NULL )
            {
                AddServer( pszSelection,
                           psi1->QueryName(),
                           psi1->QueryComment() );
            }
            SetTopIndex( iSelection );
        }
    }
    else
    {
        SelectItem( 0 );

        // Since pszSelection is empty, that means we should
        // ignore pEnumServers since it should be NULL.
    }

}

/*
 *  LM_OLLB::FillDomains
 *
 *  This method adds the domains to the listbox by calling AddDomain
 *  and AddIdempDomain.  Then, calls SelectItem to select the logon
 *  domain.
 *
 *  Parameters:
 *      maskDomainSources               - Set of one or more BROWSE_*_DOMAIN[S]
 *                                        flags.  This tells BROWSE_DOMAIN_ENUM
 *                                        where to get the domains for its
 *                                        list.
 *
 *      pszDefaultSelection             - The domain name to use as a default
 *                                        selection.  If NULL or doesn't exist
 *                                        in the list, then the first item
 *                                        is selected.
 *
 *  Return value:
 *      An error code, which is NERR_Success on success.
 *
 *  Assumptions:
 *      Wksta must be started and user must be logged on.
 *
 *      BROWSE_DOMAIN_ENUM returns domains in sorted order.
 */

APIERR LM_OLLB::FillDomains( ULONG maskDomainSources,
                             const TCHAR * pszDefaultSelection )
{
    //
    //  Create our domain enumerator.  The act of constructing
    //  this object causes a flurry of API madly trying to
    //  enumerate various domains.
    //

    BROWSE_DOMAIN_ENUM enumDomains( maskDomainSources );

    APIERR err = enumDomains.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Since BROWSE_DOMAIN_ENUM will always return a
        //  *sorted* list of domains, we can temporarily
        //  remove the LBS_SORT style from the listbox.
        //  This will eliminate a large number of client-
        //  server transitions as items are added to the
        //  listbox.
        //

        ULONG style = QueryStyle();
        SetStyle( style & ~LBS_SORT );

        //
        //  Add the domains to the listbox.
        //

        const BROWSE_DOMAIN_INFO * pbdi;

        while( ( pbdi = enumDomains.Next() ) != NULL )
        {
            AddDomain( pbdi->QueryDomainName(), NULL );
        }

        //
        //  Restore the original style bits.
        //

        SetStyle( style );
    }

    if( ( err == NERR_Success ) && ( QueryCount() > 0 ) )
    {
        //
        //  See if any specified domain exists.  If so, select
        //  it.  Otherwise, if the logon domain is in the list,
        //  select it.  Otherwise, select item #0.
        //

        INT iSelection = -1;

        if( pszDefaultSelection != NULL )
        {
            iSelection = FindItem( pszDefaultSelection, NULL );
        }

        if( iSelection < 0 )
        {
            const BROWSE_DOMAIN_INFO * pbdi;
            if ( _seltype == SEL_SRV_ONLY )
                pbdi = enumDomains.FindFirst( BROWSE_WKSTA_DOMAIN );
            else
                pbdi = enumDomains.FindFirst( BROWSE_LOGON_DOMAIN );

            if( pbdi != NULL )
            {
                iSelection = FindItem( pbdi->QueryDomainName(), NULL );
            }
        }

        if( iSelection < 0 )
        {
            iSelection = 0;
        }

        SelectItem( iSelection );
    }

    return err;

}


/*
 *  LM_OLLB::FillServers
 *
 *  Calls AddServer for every visible server of the given domain.
 *
 *  Parameters:
 *      pszDomain           The domain of interest
 *      pcServersAdded      Pointer to location receiving the number
 *                          of servers that were added by calling
 *                          AddServer.  *pusServerAdded is always valid
 *                          on return from this function, regardless
 *                          of the error code.  This is because an
 *                          error may occur in the middle of adding
 *                          servers.
 *
 *  Return value:
 *      An error code, which is NERR_Success on success.
 *
 */

APIERR LM_OLLB::FillServers( const TCHAR * pszDomain, UINT * pcServersAdded )
{
    *pcServersAdded = 0;

    AUTO_CURSOR autocur;

    //  CODEWORK.  Change the SERVER1_ENUM constructor so that the following
    //  cast can be removed.
    SERVER1_ENUM se1( NULL, (TCHAR *)pszDomain, _nServerTypes );

    APIERR usErr = se1.GetInfo();
    if ( usErr != NERR_Success )
    {
        return usErr;
    }


    //  Call AddServer for each server

    SERVER1_ENUM_ITER sei1( se1 );
    const SERVER1_ENUM_OBJ * psi1;

    while ( ( psi1 = sei1()) != NULL )
    {
        if ( AddServer( pszDomain,
                        psi1->QueryName(),
                        psi1->QueryComment() ) >= 0 )  // Server is added
        {
            (*pcServersAdded)++;
        }
    }

    return NERR_Success;
}


//
//  CODEWORK:
//
//  We now fill the listbox with the BROWSE_DOMAIN_ENUM enumerator.
//  Since the domains returned by this enumerator are all unique
//  (no duplicate) we no longer need AddIdempDomain.  We'll keep
//  around (#ifdef'd-out) just incase we need to revisit this
//  "domain comment" thang sometime in the future.
//

#if 0

/*
 *  LM_OLLB::AddIdempDomain
 *
 *  This method idempotently adds a domain to the listbox.  It returns
 *  the index of the domain.
 *
 *  Parameters:
 *      pszDomain               Pointer to domain name
 *      pszComment              Pointer to domain comment
 *
 *  Return value:
 *      Index of the given domain, or
 *      a negative value on failure.
 *
 *  Caveats:
 *      NOTE.  The domain comment is currently not used.  Although
 *      it is handled correctly from this function, all callers
 *      pass in NULL.  Is there a domain comment?  Will there ever be?
 *      If so, the callers should change.
 *
 */

INT LM_OLLB::AddIdempDomain( const TCHAR * pszDomain, const TCHAR * pszComment )
{
    INT iDomain = FindItem( pszDomain, NULL );

    if ( iDomain >= 0 )
    {
        //  Domain already exists

        //  CODEWORK.  Thor time frame.  Add the given comment if the
        //  found item, for some reason, does not have a comment.  (For
        //  efficiency, first make sure that pszComment specifies a comment.)
        //  However, don't replace an existing comment if there is one,
        //  even if the two comments differ.

        return iDomain;
    }

    return AddDomain( pszDomain, pszComment );
}

#endif


/*
 *  LM_OLLB::OnUserAction
 *
 *  This method is a virtual replacement of CONTROL_WINDOW::OnUserAction.
 *  It handles double clicks of domains to expand and collapse these.
 *
 *  Parameters:
 *      lParam      The message parameter (see CONTROL_WINDOW::OnUserAction)
 *
 *  Return value:
 *      Error code, which is NERR_Success on success.
 *
 */

APIERR LM_OLLB::OnUserAction( const CONTROL_EVENT & e )
{
    //  This method handles double clicks of domains

    if ( e.QueryCode() == LBN_DBLCLK )
    {
        INT i = QueryCurrentItem();
        UIASSERT( i >= 0 );                 // an item must be selected since
                                            // one was double clicked on

        OLLB_ENTRY * pollbe = QueryItem( i );
        UIASSERT( pollbe != NULL );         // i should be a valid item

        if ( pollbe->QueryType() == OLLBL_DOMAIN )
        {
            //  Toggle domain.
            return ToggleDomain( i );
        }

        return NERR_Success;

    }


    //  Call parent class for all other messages

    return OUTLINE_LISTBOX::OnUserAction( e );
}


/*******************************************************************

    NAME:       LM_OLLB::ToggleDomain

    SYNOPSIS:   calls ExpandDomain or CollapseDomain depending on the
                current state of the currently selected domain.

    ENTRY:      iDomain - The index of the domain to be toggled.

    RETURNS:
        Error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic number

********************************************************************/

APIERR LM_OLLB::ToggleDomain( INT iDomain )
{
    OLLB_ENTRY * pollbe = QueryItem( iDomain );

    UIASSERT( pollbe != NULL );
    if ( pollbe->QueryType() != OLLBL_DOMAIN )
    {
        UIASSERT( !SZ("iDomain must specify the index of a domain") );
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->IsExpanded())
        return CollapseDomain( iDomain );

    return ExpandDomain( iDomain );
}


/*******************************************************************

    NAME:       LM_OLLB::ExpandDomain

    SYNOPSIS:   Expands a domain.  On success, also selects it.

    ENTRY:      iDomain - Specifies the index of the domain to be expanded.

    RETURNS:
        An error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic number
        Yi-HsinS    20-Dec-1992     Adjust the listbox so that expanded
                                    items shows up

********************************************************************/

APIERR LM_OLLB::ExpandDomain( INT iDomain )
{
    // if constructed as DOMAIN ONLY, dont expand
    if (_seltype == SEL_DOM_ONLY)
        return(NERR_Success) ;

    OLLB_ENTRY * pollbe = QueryItem( iDomain );

    UIASSERT( pollbe != NULL );
    if ( pollbe->QueryType() != OLLBL_DOMAIN )
    {
        UIASSERT( !SZ("iDomain must specify the index of a domain") );
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->IsExpanded())
    {
        //  domain is already expanded; select the item, and return with
        //  success
        SelectItem( iDomain );
        return NERR_Success;
    }

    SetRedraw( FALSE );

    UINT cServersAdded = 0;

    APIERR err = FillServers( pollbe->QueryDomain(), &cServersAdded );

    SetRedraw( TRUE );
    if ( cServersAdded > 0 )
    {
        Invalidate( TRUE );
    }

    if ( ( err == NERR_Success ) && ( cServersAdded > 0 ) )
    {
        // Adjust the listbox according to how many servers are added
        // Warning: The following is a problem when LM_OLLB becomes
        //          LBS_OWNERDRAWVARIABLE with multi-line LBIs

        XYDIMENSION xydim = QuerySize();
        INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

        INT nTopIndex = QueryTopIndex();
        INT nBottomIndex = nTopIndex + nTotalItems - 1;

        if ( iDomain >= nTopIndex && iDomain <= nBottomIndex )
        {
            if ( cServersAdded >= (UINT) nTotalItems )
            {
                SetTopIndex( iDomain );
            }
            else
            {
                INT n = iDomain + cServersAdded;
                if ( n > nBottomIndex )
                {
                    SetTopIndex( nTopIndex + ( n - nBottomIndex ) );
                }
            }
        }
        else
        {
            SetTopIndex( iDomain );
        }
    }

    return err;
}


/*******************************************************************

    NAME:       LM_OLLB::CollapseDomain

    SYNOPSIS:   Collapses a given domain.  On success, also selects it.

    ENTRY:      iDomain - Specifies the index of the domain to be expanded.

    RETURNS:
        An error code, which is NERR_Success on success.

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic number

********************************************************************/

APIERR LM_OLLB::CollapseDomain( INT iDomain )
{
    // if constructed as DOMAIN ONLY, this becomes no-op
    if (_seltype == SEL_DOM_ONLY)
        return(NERR_Success) ;

    OLLB_ENTRY * pollbe = QueryItem( iDomain );

    //  We assert (( iDomain < 0 ) iff ( pollbe == NULL )).
    UIASSERT( ( iDomain < 0 && pollbe == NULL ) ||
              ( iDomain >= 0 && pollbe != NULL ));
    if ( iDomain < 0 || pollbe == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pollbe->QueryType() != OLLBL_DOMAIN )
    {
        UIASSERT( !SZ("iDomain must specify the index of a domain") );
        return ERROR_INVALID_PARAMETER;
    }

    //  Change the expanded state of the listbox item to "not expanded"
    if ( ! pollbe->IsExpanded())
    {
        //  Select the item, and then return.
        SelectItem( iDomain );
        return NERR_Success;
    }

    //  Now, we know we'll take some action which may take a little time.
    //  Hence, let AUTO_CURSOR kick in.
    AUTO_CURSOR autocur;

    SetRedraw( FALSE );
    SetDomainExpanded( iDomain, FALSE );

    //  Set iNext to the next item in the listbox.  This item, if any, is
    //  either another domain, or a server in the domain.
    INT iNext = iDomain + 1;
    BOOL fDeletedAny = FALSE;
    while ( ( pollbe = QueryItem( iNext )) != NULL &&
            pollbe->QueryType() == OLLBL_SERVER )
    {
        DeleteItem( iNext );
        fDeletedAny = TRUE;
    }

    SetRedraw( TRUE );
    if ( fDeletedAny )
    {
        Invalidate( TRUE );
    }

    //  To make sure that the domain is indeed in view in the listbox,
    //  select it .
    SelectItem( iDomain );

    return NERR_Success;
}


/*******************************************************************

    NAME:       LM_OLLB::CD_Char

    SYNOPSIS:   We catch the '+' and '-' keys to expand and collapse
                the domain if the current selection is a domain.

    ENTRY:      wch      - character typed
                nLastPos -  position in lb

    EXIT:

    RETURNS:

    HISTORY:
        Johnl       21-Jun-1991 Created
        beng        16-Oct-1991 Win32 conversion

********************************************************************/

INT LM_OLLB::CD_Char( WCHAR wch, USHORT nLastPos )
{
    if ( wch == (WCHAR) TCH('+') || wch == (WCHAR) TCH('-') )
    {
        OLLB_ENTRY * pollbe = QueryItem( nLastPos );

        if ( pollbe != NULL && pollbe->QueryType() == OLLBL_DOMAIN )
        {
            APIERR  err = NERR_Success ;
            if ( wch == (WCHAR)TCH('-') && pollbe->IsExpanded() )
            {
                err = CollapseDomain() ;
            }
            else if ( wch == (WCHAR) TCH('+') && !pollbe->IsExpanded() )
            {
                err = ExpandDomain() ;
            }

            if ( err != NERR_Success )
                MsgPopup( QueryOwnerHwnd(), err, MPSEV_ERROR ) ;

            return -2 ;
        }
    }

    return OUTLINE_LISTBOX::CD_Char( wch, nLastPos );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\lbnode.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    FILE HISTORY:
        kevinl      12-Oct-1991     Created
        kevinl      05-Nov-1991     Code Review changes attended by:
                                        DavidHov, Keithmo, o-simop
        Yi-HsinS    09-Nov-1992	    Added AbandonAllChildren()

*/

#include "pchapplb.hxx"   // Precompiled header


BOOL HIER_LBI::_fDestroyable = FALSE;


/*******************************************************************

    NAME:       HIER_LBI::HIER_LBI

    SYNOPSIS:   class constructor

    ENTRY:      fExpanded - Should this node show its' children.

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

HIER_LBI::HIER_LBI( BOOL fExpanded )
    : _phlbiParent( NULL ),
      _phlbiChild( NULL ),
      _phlbiLeft( this ),
      _phlbiRight( this ),
      _fShowChildren( fExpanded ),
      _dIndentPels( 0 ),
      _dDescendants( 1 )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       HIER_LBI::~HIER_LBI

    SYNOPSIS:   class destructor

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

HIER_LBI::~HIER_LBI()
{
    //
    // Delete all of the children of this node
    //
    while ( _phlbiChild != NULL )
        delete _phlbiChild;

    Abandon();                  // Disconnect the node from the tree
}


/*******************************************************************

    NAME:       HIER_LBI::SetDestroyable

    SYNOPSIS:   Set whether destroyable

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Outlined

********************************************************************/

VOID HIER_LBI::SetDestroyable( BOOL f )
{
    _fDestroyable = f;
}


/*******************************************************************

    NAME:       HIER_LBI::IsDestroyable

    SYNOPSIS:   Should the windows WM_DELETEITEM message also destruct
                this LBI?

    NOTES:
        This is a virtual member function.

    HISTORY:
        kevinl   05-Nov-1991  Created

********************************************************************/

BOOL HIER_LBI::IsDestroyable()
{
    return _fDestroyable;
}


/*******************************************************************

    NAME:       HIER_LBI::Adopt

    SYNOPSIS:   Add a child node.

    ENTRY:      phlbi  - Pointer to child node.
                fSort - Adopt in sorted order?

    RETURNS:    nothing; cannot fail.

    NOTES:      if fSort is set then the child is added according
                to the LBI's compare method otherwise the child is
                always added to the end of the sibling list.

    HISTORY:
        kevinl   12-Oct-1991  Stolen from REG_NODE

********************************************************************/

VOID HIER_LBI::Adopt( HIER_LBI * phlbi, BOOL fSort )
{
    UIASSERT( phlbi != NULL ) ;
    UIASSERT( phlbi->_phlbiRight == phlbi->_phlbiLeft );  // Assure that phlbi
    UIASSERT( phlbi->_phlbiRight == phlbi );               // has not been
                                                           // linked into the
                                                           // tree yet.

    if ( _phlbiChild )  // Do I have a child?
    {                    // Yes

         HIER_LBI * phlbiTemp = _phlbiChild;    // points to insertion point

        if ( fSort )
         {
             BOOL fAdd = FALSE;                 // Loop termination

             do
             {
                 //
                 // Three choices:
                 //    <0  -> phlbiTemp sorts before phlbi
                 //     0  -> phlbiTemp sorts the same as phlbi
                 //    >0  -> phlbiTemp sorts after phlbi
                 //
                 if ( phlbiTemp->Compare( phlbi ) < 0 )
                 {
                     phlbiTemp = phlbiTemp->_phlbiRight; // Move to next sibling
                 }
                 else
                     fAdd = TRUE;       // Found the proper insertion point

             }
             while ( (_phlbiChild != phlbiTemp) && !fAdd );

             //
             // Either Equal to the current LBI or it is Greater
             // than the current LBI, in any event we want to insert it
             // to the left of the current LBI pointed to by phlbiTemp
             //
         }

         //
         // If not sorted then phlbiTemp will equal _phlbiChild and this
         // will simply add the node to the end of the sibling list.
         //

         phlbi->_phlbiParent           = this ;
         phlbi->_phlbiRight            = phlbiTemp ;
         phlbi->_phlbiLeft             = phlbiTemp->_phlbiLeft ;
         phlbi->_phlbiLeft->_phlbiRight = phlbi ;
         phlbi->_phlbiRight->_phlbiLeft = phlbi ;

         if ( fSort && ( _phlbiChild == phlbiTemp) )    // First sibling
         {                                              // must change
             if ( phlbi->Compare( _phlbiChild ) < 0 )
                 _phlbiChild = phlbi;
         }
    }
    else
    {
        phlbi->_phlbiParent = this ;            // This is the first child.
        _phlbiChild = phlbi ;                   // Set the parent accordingly
    }

    phlbi->SetIndentLevel();                    // Initialize the indentation.

    phlbi->AdjustDescendantCount( 1 );          // Adjust the tree counters.
}

/*******************************************************************

    NAME:       HIER_LBI::AbandonAllChildren

    SYNOPSIS:   Remove all children of this HIER_LBI

    HISTORY:
        Yi-HsinS	09-Nov-1992	Created	

********************************************************************/
VOID HIER_LBI::AbandonAllChildren( VOID )
{
    while ( _phlbiChild != NULL )
        delete _phlbiChild;
}

/*******************************************************************

    NAME:       HIER_LBI::Abandon

    SYNOPSIS:   Remove a HIER_LBI's linkage to its parent
                and siblings.  It also adjusts the descendant count.

    HISTORY:
        kevinl   12-Oct-1991  Stolen from REG_NODE

********************************************************************/

VOID HIER_LBI::Abandon()
{
    HIER_LBI * phlbiSibling = NULL ;

    AdjustDescendantCount( -1 );                // Remove the node

    //  Delink this node from any siblings

    if ( _phlbiLeft != this )
    {
        phlbiSibling = _phlbiRight ;
        _phlbiRight->_phlbiLeft = _phlbiLeft ;
        _phlbiLeft->_phlbiRight = _phlbiRight ;
        _phlbiLeft = _phlbiRight = this ;
    }

    //  If this node anchors the parent's child chain, change it.

    if ( _phlbiParent )
    {
        if ( _phlbiParent->_phlbiChild == this )
            _phlbiParent->_phlbiChild = phlbiSibling ;
        _phlbiParent = NULL ;
    }
}


/*******************************************************************

    NAME:       HIER_LBI::QueryLBIndex

    SYNOPSIS:   Calculates the index of the given node in the listbox.

    RETURNS:    INT - the index that this node is in the listbox OR
                      -1 if an error was encountered.

    HISTORY:
        kevinl   23-Oct-1991  Created

********************************************************************/

INT HIER_LBI::QueryLBIndex( )
{
    HIER_LBI * phlbi = this;
    INT index = 0;

    while ( phlbi->_phlbiParent != NULL )               // Is this the ROOT?
    {
        //
        // Is this node the 1st sibling?
        //

         if ( phlbi->_phlbiParent->_phlbiChild == phlbi )
         {
             phlbi = phlbi->_phlbiParent;               // Move to parent

             if ( phlbi->_fShowChildren != TRUE )       // Is parent expanded?
                 return -1;                             // ERROR

             index++;
         }
         else
         {
             phlbi = phlbi->_phlbiLeft;                 // Move to left Sibling

             if ( phlbi->_fShowChildren )
                 index += phlbi->_dDescendants;         // Add descendant count
             else
                 index++;                               // Add 1 for the node
         }
    }

    return ( index - 1 );                               // Root is not displayed
}


/*******************************************************************

    NAME:       HIER_LBI::SetIndentLevel

    SYNOPSIS:   Calculates the indent level of this node and
                stores the value.

    EXIT:       The indent level is set

    HISTORY:
        kevinl   23-Oct-1991  Created

********************************************************************/

VOID HIER_LBI::SetIndentLevel()
{
    this->SetPelIndent( QueryIndentLevel() );
}

/*******************************************************************

    NAME:       HIER_LBI::QueryIndentLevel

    SYNOPSIS:   Calculates the indent level of this node

    RETURNS:    Returns the indent level

    EXIT:

    HISTORY:
        Yi-HsinS 04-Nov-1992   Created

********************************************************************/

INT HIER_LBI::QueryIndentLevel()
{
    INT ui = 0;                   // indent level

    //
    // Count the number of parents that this node has.  This number
    // corresponds to the indentation level.
    //
    for ( HIER_LBI * phlbi = this; phlbi->_phlbiParent; phlbi = phlbi->_phlbiParent )
        ui++;

    return ( ui - 1 );             // Save level  NOTE:
                                   // subtract the hidden root

}

/*******************************************************************

    NAME:       HIER_LBI::AdjustDescendantCount

    SYNOPSIS:   Each node has a descendant counter which corresponds to the
                number of visible children below this node.  This routine will
                walk up to the root or the first non-expanded parent and add
                iAdjustment to each of the parents descendant counter.

    ENTRY:      INT iAdjustment - value to add to each of the parents
                                  descendant counters.

    EXIT:       Each visible parent's descendant counter has been adjusted.

    HISTORY:
        kevinl   23-Oct-1991  Created

********************************************************************/

VOID HIER_LBI::AdjustDescendantCount( INT iAdjustment )
{
    HIER_LBI * phlbi = this;                    // Temp pointer

    while ( phlbi->_phlbiParent != NULL )       // Stop at root
    {
         phlbi = phlbi->_phlbiParent;           // Move up to next level
         if ( phlbi->QueryExpanded() )
             phlbi->_dDescendants += iAdjustment;
         else
             break;                             // Stop if parent not visible.
    }
}


/**********************************************************************

   NAME:        HIER_LBI::IsParent

   SYNOPSIS:    determines if the given node is a parent of this node.

   ENTRY:


   RETURN:


   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

BOOL HIER_LBI::IsParent( HIER_LBI * phlbiParent )
{
    if ( phlbiParent == NULL )
        return FALSE;                           // obviously not a parent

    HIER_LBI * phlbi = this;                    // Temp pointer

    while ( phlbi->_phlbiParent != NULL )       // Stop at root
    {
         phlbi = phlbi->_phlbiParent;           // Move up to next level
         if ( phlbi == phlbiParent )
             return TRUE;
    }

    return FALSE;
}


/**********************************************************************

    NAME:       HIER_LBI::SetPelIndent

    SYNOPSIS:   Sets the indentation value for the HIER_LBI, used in
                hierarchical listboxes.  This value is stored as pels.

    ENTRY:      ui - Level of indentation (0, 1, 2, ... )

    NOTES:      This is a virtual method which may be replaced in subclasses.

                THE DEFAULT INDENTATION THAT IS USED IS 20 PELS.  IF THIS
                IS NOT ADEQUATE, THEN DEFINE YOUR OWN METHOD TO OVERRIDE
                THIS ONE.

    HISTORY:
        kevinl      23-Oct-1991     Creation

**********************************************************************/

#define DEFAULT_INDENT 20

VOID HIER_LBI::SetPelIndent( UINT ui )
{
    _dIndentPels = ui * DEFAULT_INDENT;
}


/*******************************************************************

    NAME:       LBITREE::LBITREE

    SYNOPSIS:   class constructor

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

LBITREE::LBITREE()
{
    if ( QueryError() != NERR_Success )
        return;

    _hlbiRoot.SetExpanded();            // Show its' children.
}


/*******************************************************************

    NAME:       LBITREE::~LBITREE

    SYNOPSIS:   class destructor

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

LBITREE::~LBITREE()
{
    // Nothing to do
}


/*******************************************************************

    NAME:       LBITREE::AddNode

    SYNOPSIS:   Adds phlbiChild as a child of phlbiParent

    ENTRY:      phlbiParent - Node at which phlbiChild should be added.
                              If this is NULL then phlbiChild is added
                              to the Root.

                phlbiChild  - Node to add the the tree.

                fSort       - Should we add this node in sorted order?

    RETURNS:    INT - the index in the listbox at which the item is to be
                        inserted.

    HISTORY:
        kevinl   12-Oct-1991  Created

********************************************************************/

INT LBITREE::AddNode( HIER_LBI * phlbiParent, HIER_LBI * phlbiChild, BOOL fSort )
{
    UIASSERT( phlbiChild != NULL );

    if ( phlbiParent )
        phlbiParent->Adopt( phlbiChild, fSort );        // add to parent
    else
        _hlbiRoot.Adopt( phlbiChild, fSort );           // add to root

    return phlbiChild->QueryLBIndex();          // Return the index
}




HIER_LBI_ITERATOR::HIER_LBI_ITERATOR( HIER_LBI * phlbi, BOOL fChildIterator )
    : _phlbiStart( NULL ),
      _phlbiEnd( NULL )
{
    UIASSERT( phlbi != NULL );

    if ( fChildIterator )    // Iterate the children of this HIER_LBI
    {
       _phlbiStart = _phlbiEnd = phlbi->_phlbiChild;
    }
    else
    {
       _phlbiStart = _phlbiEnd = phlbi;
    }
}


HIER_LBI_ITERATOR::~HIER_LBI_ITERATOR()
{
    _phlbiStart = NULL;
    _phlbiEnd   = NULL;
}


HIER_LBI * HIER_LBI_ITERATOR::operator()()
{
    HIER_LBI * phlbiRet = _phlbiStart ? ( _phlbiStart = _phlbiStart->_phlbiRight ) : NULL;

    if ( _phlbiStart == _phlbiEnd )
        _phlbiStart = NULL;

    return phlbiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\hierlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    FILE HISTORY:
        kevinl      12-Oct-1991     Created
        kevinl      05-Nov-1991     Code Review changes attended by:
                                        DavidHov, Keithmo, o-simop
        Yi-HsinS    09-Nov-1992	    Added DeleteChildren()

*/

#include "pchapplb.hxx"   // Precompiled header

#define MIN(a,b)        (( a < b ) ? a : b )
#define MAX(a,b)        (( a < b ) ? b : a )

/**********************************************************************

   NAME:        HIER_LISTBOX::HIER_LISTBOX

   SYNOPSIS:    class constructor

   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

HIER_LISTBOX::HIER_LISTBOX( OWNER_WINDOW * powin, CID cid, BOOL fReadOnly,
                           enum FontType font, BOOL fSort )
    :   BLT_LISTBOX( powin, cid, fReadOnly, font ),
       _fSort( fSort )
{
    if ( QueryError() != NERR_Success )
        return;

    HIER_LBI::SetDestroyable( TRUE );

    _fMultSel = LIST_CONTROL::IsMultSel();

    DBGEOL("Extended Sel " << _fMultSel);
}


/**********************************************************************

   NAME:        HIER_LISTBOX::HIER_LISTBOX

   SYNOPSIS:    class constructor

   HISTORY:
      kevinl    12-Oct-1991 Created
      beng      22-Apr-1992 Classname arg elided

**********************************************************************/

HIER_LISTBOX::HIER_LISTBOX( OWNER_WINDOW * powin, CID cid,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle,
                            BOOL fReadOnly,
                            enum FontType font,
                            BOOL fSort )
    :   BLT_LISTBOX( powin, cid, xy, dxy, flStyle & ~LBS_SORT,
                     fReadOnly, font ),
       _fSort( fSort )
{
    if ( QueryError() != NERR_Success )
        return;

    HIER_LBI::SetDestroyable( TRUE );

    _fMultSel = LIST_CONTROL::IsMultSel();

    DBGEOL("Extended Sel " << _fMultSel);
}


/**********************************************************************

   NAME:        HIER_LISTBOX::~HIER_LISTBOX

   SYNOPSIS:    class destructor

   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

HIER_LISTBOX::~HIER_LISTBOX()
{
    DeleteAllItems();           // Remove the shadow class
}


/**********************************************************************

   NAME:        HIER_LISTBOX::AddItem

   SYNOPSIS:    add the specified item to the listbox

   ENTRY:       HIER_LBI * phlbi          Node to add
                 HIER_LBI * phlbiParent    Parent of phlbi
                 BOOL fSaveSelection      Should we preserve the selection?

   RETURN:      INT - the index of the item in the listbox, -1 on
                 error or 0 if the item is being added as a hidden item.

   HISTORY:
      kevinl    12-Oct-1991     Created
      Johnl     29-Jan-1992     Adding a hidden item is now non-fatal

**********************************************************************/

INT HIER_LISTBOX::AddItem( HIER_LBI * phlbi, HIER_LBI * phlbiParent, BOOL fSaveSelection )
{
    if ( phlbi == NULL )
        return -1;          //  Refuse to add NULL item.  This way, we can
                            //  guarantee that all items in the listbox
                            //  will be non-NULL.

    if ( phlbi->QueryError() != NERR_Success )
    {
        //  Refuse to add an item that was not constructed correctly.
        //  This way, we can guarantee that all items in the listbox
        //  will be correctly constructed.
        //  Before returning, delete the item.
        //
        delete phlbi;
        return -1;
    }

    INT dSel;

    if ( fSaveSelection )
    {
        if ( _fMultSel )
        {
            //
             // Preserve Selection State
             //
             DBGEOL("Preserve Selection not supported!");
        }
        else
            dSel = LIST_CONTROL::QueryCurrentItem();
    }

    /* AddNode only returns -1 if the item is hidden
     */
    INT i = _lbit.AddNode( phlbiParent, phlbi, _fSort );    // Modify the tree
    if ( i >= 0 )       // Are we visible?
    {
        if ( LIST_CONTROL::InsertItemData( i, phlbi ) < 0 ) // Add the LBI
        {
             delete phlbi;                              // Clean up
             return -1;
        }

         if ( fSaveSelection )     // Did the selection change?
         {
             if ( _fMultSel )
             {
                //
                 // Restore Selection State
                 //
                 DBGEOL("Restore Selection not supported!");
             }
             else
             {
                 if ( i <= dSel )
                     LIST_CONTROL::SelectItem( dSel + 1 );
                 else
                     LIST_CONTROL::SelectItem( dSel );
             }
         }
    }

    /* Map the case of adding a hidden item to a success
     */
    return ( i==-1 ? 0 : i) ;
}

/**********************************************************************

   NAME:        HIER_LISTBOX::AddSortedItems

   SYNOPSIS:    add the specified list of items to the listbox

   ENTRY:       HIER_LBI * * pphlbi          Node to add
                HIER_LBI * phlbiParent       Parent of phlbi
                BOOL fSaveSelection          Should we preserve the selection?

   RETURN:      INT - the index of the item in the listbox, -1 on
                 error or 0 if the item is being added as a hidden item.

   NOTES:       The list of items are added under phlbiParent as a whole block
                without regard to sorting order.  There should be no children
                under phlbiParent and all children should be added with this
                call!

   HISTORY:
      Johnl    26-Jan-1993     Created

**********************************************************************/

void HIER_LISTBOX::AddSortedItems( HIER_LBI * * pphlbi,
                                   INT          cItems,
                                   HIER_LBI *   phlbiParent,
                                   BOOL         fSaveSelection )
{
    INT dSel;
    if ( fSaveSelection )
    {
        if ( _fMultSel )
        {
            //
             // Preserve Selection State
             //
             DBGEOL("Preserve Selection not supported!");
        }
        else
            dSel = LIST_CONTROL::QueryCurrentItem();
		// NTRAID#NTBUG9-577061-2002/03/07-artm Prefast: dSel may not have been initialized.
		// If fSaveSelection && fMultSel, then dSel was never initialized.
		// In reality, dSel should probably be set to QueryCurrentItem() regardless.
		// Unless of course DBGEOL() is not just a debug build macro, but is actually
		// in the release build.
    }

    for ( INT i = 0 ; i < cItems ; i++ )
    {
        HIER_LBI * phlbi = *pphlbi++ ;

        if ( phlbi == NULL )
            continue ;          //  Refuse to add NULL item.  This way, we can
                                //  guarantee that all items in the listbox
                                //  will be non-NULL.

        if ( phlbi->QueryError() != NERR_Success )
        {
            //  Refuse to add an item that was not constructed correctly.
            //  This way, we can guarantee that all items in the listbox
            //  will be correctly constructed.
            //  Before returning, delete the item.
            //
            delete phlbi;
            continue ;
        }


        /* AddNode only returns -1 if the item is hidden
         */
        INT j = _lbit.AddNode( phlbiParent, phlbi, FALSE );    // Modify the tree
        if ( j >= 0 )       // Are we visible?
        {
            if ( LIST_CONTROL::InsertItemData( j, phlbi ) < 0 ) // Add the LBI
            {
                 delete phlbi;                              // Clean up
                 continue ;
            }

			// NTRAID#NTBUG9-577061-2002/03/07-artm Prefast: dSel may not have been initialized.
			// If fSaveSelection && fMultSel, then dSel was never initialized.
			// The bug is probably at point marked earlier in function where it should
			// have been initialized.
            if ( j <= dSel )
                dSel++;
        }
    }

    if ( fSaveSelection )
    {
        if ( _fMultSel )
        {
            //
            // Restore Selection State
            //
            DBGEOL("Restore Selection not supported!");
        }
        else
            LIST_CONTROL::SelectItem( dSel );

    }
}

/**********************************************************************

   NAME:        HIER_LISTBOX::DeleteItem

   SYNOPSIS:    delete the specified item from the listbox

   ENTRY:       INT i - item to be deleted
                 BOOL fSaveSelection      Should we preserve the selection?

   RETURN:      The return value is a count of the strings remaining in the
                list. The return value is LB_ERR if an error occurs.

   HISTORY:
      kevinl    12-Oct-1991     Created

**********************************************************************/

INT HIER_LISTBOX::DeleteItem( INT i, BOOL fSaveSelection )
{
    INT dSel = 0;
    INT dTopIndex = 0;
    BOOL fIsChild = FALSE;
    HIER_LBI * phlbiDeleted;
    HIER_LBI * phlbi;

    if ( fSaveSelection )
    {
        SetRedraw( FALSE );

        if ( _fMultSel )
        {
            //
             // Preserve Selection State
             //
             DBGEOL("Preserve Selection not supported!");
        }
        else
            dSel = LIST_CONTROL::QueryCurrentItem();

         dTopIndex = LIST_CONTROL::QueryTopIndex();

         phlbi = (HIER_LBI *)QueryItem( dTopIndex );

         phlbiDeleted = (HIER_LBI *)QueryItem( i );

         if ( phlbi )
             fIsChild = phlbi->IsParent( phlbiDeleted );
    }

    CollapseItem( i, FALSE );

    INT dcount = LIST_CONTROL::DeleteItem( i );   // Tell windows to delete
                                                   // the item

    if ( fSaveSelection && dcount != LB_ERR )
    {
         if ( i <= dSel )  // selection change?
         {
            if ( _fMultSel )
            {
                //
                // Restore Selection State
                //
                DBGEOL("Restore Selection not supported!");
            }
            else
                LIST_CONTROL::SelectItem( (dSel == i) ? -1 : MAX( 0, (dSel - 1) ) );
         }

         LIST_CONTROL::SetTopIndex( MIN( ((fIsChild) ? i : dTopIndex), (dcount - 1) ) );

         SetRedraw( TRUE );

         Invalidate();
    }

    return dcount;
}


/**********************************************************************

   NAME:        HIER_LISTBOX::AddChildren

   SYNOPSIS:    Enumerate the children of this node and add them to the
                 listbox.

   ENTRY:       phlbi - the HIER_LBI for whom we should enumerate the
                        children and add to the listbox

   RETURN:      NERR_Success on success otherwise an error is returned.

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

APIERR HIER_LISTBOX::AddChildren( HIER_LBI * phlbi )
{
    UNREFERENCED( phlbi );
    return NERR_Success;
}


/**********************************************************************

   NAME:        HIER_LISTBOX::RefreshChildren

   SYNOPSIS:    Called to alert the listbox writer that phlbi is
                about to be expanded but it already has data.  So,
                 if the implementor wishes, they may update the tree
                 at this point.

   ENTRY:       phlbi - the HIER_LBI for whom we should refresh the
                        children and adjust the listbox

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

VOID HIER_LISTBOX::RefreshChildren( HIER_LBI * phlbi )
{
    UNREFERENCED( phlbi );
    return;
}

/**********************************************************************

   NAME:        HIER_LISTBOX::DeleteChildren

   SYNOPSIS:    Collapse the given node and delete its children

   ENTRY:       phlbi - the HIER_LBI for whom we should delete the children

   RETURN:

   HISTORY:
       Yi-HsinS	09-Nov-1992     Created

**********************************************************************/

VOID HIER_LISTBOX::DeleteChildren( HIER_LBI * phlbi )
{
    if ( phlbi == NULL )
        return;

    // Collapse the item if it is not already collapsed
    CollapseItem( phlbi, FALSE );

    // Delete all children of the given HIER_LBI
    phlbi->AbandonAllChildren();

}

/**********************************************************************

   NAME:        HIER_LISTBOX::CollapseItem

   SYNOPSIS:    Collapse the item in the listbox (Don't show children)

   ENTRY:       INT i - item to be collapsed

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

VOID HIER_LISTBOX::CollapseItem( INT i, BOOL fInvalidate )
{
    CollapseItem( (HIER_LBI *) QueryItem( i ), fInvalidate );
}


/**********************************************************************

   NAME:        HIER_LISTBOX::CollapseItem

   SYNOPSIS:    Collapse the item in the listbox (Don't show children)

   ENTRY:       HIER_LBI * phlbi - item to be collapsed

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

VOID HIER_LISTBOX::CollapseItem( HIER_LBI * phlbi, BOOL fInvalidate )
{
    if ( phlbi == NULL )
        return;

    if ( phlbi->QueryExpanded() )       // Is it currently expanded?
    {
         //
         // Collapse node.
         //
         INT index = phlbi->QueryLBIndex() + 1; // Index of first child

         HIER_LBI::SetDestroyable( FALSE );     // Don't delete the lbi's

         if ( fInvalidate )
             SetRedraw( FALSE );                // don't flicker

         for (UINT count = phlbi->_dDescendants - 1; count; count-- )
             LIST_CONTROL::DeleteItem( index ); // remove the children

         //
         // Adjust the number of viewed children
         //
         phlbi->AdjustDescendantCount( -1 * (phlbi->_dDescendants - 1) );

         phlbi->_dDescendants = 1;              // Reset the counter


         if ( fInvalidate )
         {
             SetRedraw( TRUE );                 // O.k. to redraw
             Invalidate();                      // Force a repaint
         }

         HIER_LBI::SetDestroyable( TRUE );      // o.k. to delete lbi's

        phlbi->SetExpanded( FALSE );            // Node isn't expanded
    }
}


/**********************************************************************

   NAME:        HIER_LISTBOX::ExpandItem

   SYNOPSIS:    Expand the item in the listbox

   ENTRY:       INT i - item to be expanded

   RETURN:      NERR_Success on success otherwise the APIERR returned
                 from AddChildren

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

APIERR HIER_LISTBOX::ExpandItem( INT i )
{
    return ExpandItem( (HIER_LBI *)QueryItem( i ) );
}

/**********************************************************************

   NAME:        HIER_LISTBOX::ExpandItem

   SYNOPSIS:    Expand the item in the listbox

   ENTRY:       HIER_LBI * phlbi - item to be expanded

   RETURN:      NERR_Success on success otherwise the APIERR returned
                 from AddChildren

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

APIERR HIER_LISTBOX::ExpandItem( HIER_LBI * phlbi )
{
    if ( phlbi == NULL )
        return ERROR_INVALID_PARAMETER;

    phlbi->SetExpanded( TRUE );    // Set to expanded now, so that any
                                   // AddItems will be displayed.

    if ( phlbi->HasChildren() ) // Does this node have children?
    {
         //
         // Expand node.
         //
         SetRedraw( FALSE );            // Don't allow screen flicker

         RefreshChildren( phlbi );      // callout to allow refresh to work.

         INT dStart = phlbi->QueryLBIndex() + 1;  // Index for first child.

         //
         // Add all of the children on phlbi to the listbox starting
         // at index dStart
         //
         INT dEnd = ExpandChildren( dStart, phlbi->_phlbiChild );

         phlbi->AdjustDescendantCount( dEnd - dStart );  // Number of children
                                                         // added.

         phlbi->_dDescendants = dEnd - dStart + 1;       // Proper count.

         SetRedraw( TRUE );             // O.k to repaint

         Invalidate();                  // Force a repaint

    }
    else
    {
        APIERR err;

         err = AddChildren( phlbi );            // callout to get children

         if ( err != NERR_Success )
         {
            phlbi->SetExpanded( FALSE );        // Not expanded
             return err;
         }
    }

    if ( phlbi->_phlbiChild == NULL )           // No Children were added
        phlbi->SetExpanded( FALSE );            // Not expanded

    return NERR_Success;
}


/**********************************************************************

   NAME:        HIER_LISTBOX::ExpandChildren

   SYNOPSIS:    Adds all of the children of phlbi to the listbox in
                 Depth-first order.  Starting at listbox index dIndex.

   ENTRY:       INT dIndex - index of first child in listbox
                 HIER_LBI * phlbi - node to add.

   RETURNS:      INT - Last index.

   HISTORY:
      kevinl    23-Oct-1991     Created

**********************************************************************/

INT HIER_LISTBOX::ExpandChildren( INT dIndex, HIER_LBI * phlbi )
{
    HIER_LBI * phlbiSave = phlbi;       // Save first child.
    do
    {
         LIST_CONTROL::InsertItemData( dIndex++, phlbi );       // add to LB

         //
         // Does the node have children and are they currently visible?
         //
         // if so, expand this nodes children.
         //
        if ( phlbi->_phlbiChild && phlbi->QueryExpanded() )
            dIndex = ExpandChildren( dIndex, phlbi->_phlbiChild );

        phlbi = phlbi->_phlbiRight;     // move to the next sibling.
    }
    while ( phlbiSave != phlbi );       // Stop when we are back at the first
                                        // child.

    return dIndex;                      // return the last index.
}


/**********************************************************************

   NAME:        HIER_LISTBOX::OnDoubleClick

   SYNOPSIS:    This method will either expand or collapse the
                 selected HIER_LBI, based upon whether or not it
                 is currently expanded.

   ENTRY:       phlbi - the HIER_LBI that the user double clicked.

   HISTORY:
      kevinl    23-Oct-1991     Created
      YiHsinS   17-Dec-1992     Adjust the listbox after ExpandItem

**********************************************************************/

VOID HIER_LISTBOX::OnDoubleClick( HIER_LBI * phlbi )
{
    AUTO_CURSOR cur;                    // Hourglass during expand/Collapse

    if ( phlbi == NULL )
        return;

    if ( phlbi->QueryExpanded() )       // Do I have visible Children?
    {
        // See how many items will fit into the listbox
        // Warning: This will be a problem if HIER_LISTBOX becomes
        //          LBS_OWNERDRAWVARIABLE with Multi-line LBIs

        XYDIMENSION xydim = QuerySize();
        INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

        INT nCurrentIndex = QueryCurrentItem();

        CollapseItem( phlbi );          // Yes, then collapse

        if ( QueryCount() <= nTotalItems )
        {
            //
            // Show all items if all of them fit into the listbox
            //
            SetTopIndex( 0 );
        }
        else if (  ( nCurrentIndex == QueryTopIndex() ) 
                && ( nCurrentIndex == QueryCount() - 1 )
                )
        {
            //
            // If the only visible item is the current item, 
            // then make more items visible.
            //

            if ( nCurrentIndex - ( nTotalItems - 1) > 0 )  
                SetTopIndex ( nCurrentIndex - ( nTotalItems - 1) );
            else
                SetTopIndex ( 0 );
        }
    }
    else
    {
        ExpandItem( phlbi );            // No, then expand

        // See how many items will fit into the listbox
        // Warning: This will be a problem if HIER_LISTBOX becomes
        //          LBS_OWNERDRAWVARIABLE with Multi-line LBIs

        INT nChildrenAdded = phlbi->QueryDescendants() - 1;
        if ( nChildrenAdded > 0 )
        {
            XYDIMENSION xydim = QuerySize();
            INT nTotalItems = xydim.QueryHeight()/QuerySingleLineHeight();

            INT nTopIndex = QueryTopIndex();
            INT nBottomIndex = nTopIndex + nTotalItems - 1;
            INT nCurrentIndex = QueryCurrentItem();

            if ( nCurrentIndex >= nTopIndex && nCurrentIndex <= nBottomIndex )
            {
                if ( nChildrenAdded >= nTotalItems - 1 )
                {
                    SetTopIndex( nCurrentIndex );
                }
                else
                {
                    INT n = nCurrentIndex + nChildrenAdded;
                    if ( n > nBottomIndex )
                    {
                        SetTopIndex( nTopIndex + ( n - nBottomIndex ) );
                    }
                }
            }
            else
            {
                SetTopIndex( nCurrentIndex );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\password.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    password.cxx
    Class definitions for the RESOURCE_PASSWORD_DIALOG and
    BASE_PASSWORD_DIALOG classes.

    FILE HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.
        Yi-HsinS     5-Oct-1991 Modified for general usage
        ChuckC       2-Feb-1992 Modified to be more flexible. Broke into
                                two classes.
        KeithMo     07-Aug-1992 Added HelpContext parameters.
*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       BASE_PASSWORD_DIALOG::BASE_PASSWORD_DIALOG

    SYNOPSIS:   Constructor.

    ENTRY:      hwndParent              - The handle of the "owning" window

                pszResource             - The name of the resource

                sltTarget               - CID for target SLT

                pswdPass                - CID for passwd ctrl

                pszTarget               - The name of the target resource

                npasswordLen            - The maximum length of the password
                                          that the user is allowed to type in

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.
        Yi-HsinS     5-Oct-1991 Constructor takes a password length

********************************************************************/
BASE_PASSWORD_DIALOG::BASE_PASSWORD_DIALOG( HWND        hwndParent,
                                            const TCHAR *pszResource,
                                            CID         cidTarget,
                                            CID         cidPassword,
                                            ULONG       ulHelpContext,
                                            const TCHAR *pszTarget,
                                            UINT        npasswordLen,
                                            CID         cidTarget2,
                                            const TCHAR *pszTarget2,
                                            CID         cidText,
                                            const TCHAR *pszText)

  : DIALOG_WINDOW( pszResource, hwndParent ),
    _sltTarget( this, cidTarget ),
    _psltTarget2(NULL),
    _psltText (NULL),
    _passwdCtrl( this, cidPassword, npasswordLen ),
    _ulHelpContext(ulHelpContext)
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Display the target resource name.
    //

    _sltTarget.SetText( pszTarget );

    //  Display username stored in pszTarget2.
    if (cidTarget2 != 0)
    {
        _psltTarget2 = new SLT( this, cidTarget2 );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _psltTarget2 == NULL
            || (err = _psltTarget2->QueryError()) != NERR_Success )
        {
            ReportError( err );
            return;
        }
        _psltTarget2->SetText( pszTarget2 );
    }

    if (cidText != 0)
    {
        _psltText = new SLT( this, cidText );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _psltText == NULL
            || (err = _psltText->QueryError()) != NERR_Success )
        {
            ReportError( err );
            return;
        }
        _psltText->SetText( pszText );
    }

}

BASE_PASSWORD_DIALOG::~BASE_PASSWORD_DIALOG()
{
    delete _psltText;
    delete _psltTarget2;
}

/*******************************************************************

    NAME:       BASE_PASSWORD_DIALOG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog which was given
                to it diring construction.

    ENTRY:      None.

    EXIT:       None.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    NOTES:

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.

********************************************************************/
ULONG BASE_PASSWORD_DIALOG :: QueryHelpContext( void )
{
    return  _ulHelpContext ;
}

/*******************************************************************

    NAME:       RESOURCE_PASSWORD_DIALOG::RESOURCE_PASSWORD_DIALOG

    SYNOPSIS:   Constructor.

    ENTRY:      hwndParent              - The handle of the "owning" window

                pszResource             - The name of the resource

                sltTarget               - CID for target SLT

                pswdPass                - CID for passwd ctrl

                pszTarget               - The name of the target resource

                npasswordLen            - The maximum length of the password
                                          that the user is allowed to type in

                nHelpContext            - The help context for this dialog.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.
        Yi-HsinS     5-Oct-1991 Constructor takes a password length

********************************************************************/
RESOURCE_PASSWORD_DIALOG::RESOURCE_PASSWORD_DIALOG( HWND        hwndParent,
                                                    const TCHAR *pszTarget,
                                                    UINT        npasswordLen,
                                                    ULONG       nHelpContext )
  : BASE_PASSWORD_DIALOG( hwndParent,
                          MAKEINTRESOURCE( IDD_PASSWORD_DLG),
                          IDPW_RESOURCE,
                          IDPW_PASSWORD,
                          nHelpContext,
                          pszTarget,
                          npasswordLen )
{
    ;  // nothing more to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\prompt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
 *   prompt.cxx
 *   This file contains the class PROMPT_AND_CONNECT. The class is
 *   used for connecting to a resource and will pop up a dialog
 *   asking for the password to the resource.
 *
 *   FILE HISTORY:
 *     Yi-HsinS         8/15/91         Created
 *     KeithMo          07-Aug-1992     Added HelpContext parameters.
 *
 */

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:       PROMPT_AND_CONNECT::PROMPT_AND_CONNECT

    SYNOPSIS:   Class Constructor

    ENTRY:      hwndParent              - The parent window.
                pszTarget               - The name of the target resource.
                npasswordLen            - The length of the password expected
                pszDev                  - The device name to be used to connect
                nHelpContext            - The help context for the dialog.


    EXIT:       The object is constructed.

    HISTORY:
        Yi-HsinS    10/1/91     Created

********************************************************************/

PROMPT_AND_CONNECT::PROMPT_AND_CONNECT( HWND hwndParent,
                                        const TCHAR *pszTarget,
                                        ULONG nHelpContext,
                                        UINT npasswordLen,
                                        const TCHAR *pszDev )
     : _hwndParent(  hwndParent ),
       _nlsTarget( pszTarget ),
       _nlsDev ( pszDev ),
       _fConnected( FALSE ),
       _npasswordLen( npasswordLen),
       _nHelpContext( nHelpContext )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  (( err = _nlsTarget.QueryError() ) != NERR_Success )
       || (( err = _nlsDev.QueryError() ) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       PROMPT_AND_CONNECT::~PROMPT_AND_CONNECT

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    HISTORY:
        Yi-HsinS    10/1/91     Created

********************************************************************/

PROMPT_AND_CONNECT::~PROMPT_AND_CONNECT()
{
    if ( IsConnected() )
    {
        // Ignore error, we use USE_LOTS_OF_FORCE
        DEVICE dev(SZ("")) ;
        APIERR err ;

        err = dev.GetInfo() ;
        UIASSERT (err == NERR_Success) ; // shouldnt fail
        if (err == NERR_Success)
        {
            // Ignore disconnect error, we try our best and be done with it
            err = dev.Disconnect(_nlsTarget.QueryPch(), USE_LOTS_OF_FORCE) ;
            UIASSERT (err == NERR_Success) ;
        }
    }

}

/*******************************************************************

    NAME:       PROMPT_AND_CONNECT::Connect

    SYNOPSIS:   Main function to connect to the resource and use the
                device passed in if it exists

    ENTRY:

    EXIT:       The connection is established.

    HISTORY:
        Yi-HsinS    10/1/91     Created

********************************************************************/

APIERR PROMPT_AND_CONNECT::Connect( void )
{
     APIERR err = NERR_Success;

     if ( IsConnected() )
         return err;

     RESOURCE_PASSWORD_DIALOG *pdlg =
         new RESOURCE_PASSWORD_DIALOG( _hwndParent,
                                       _nlsTarget,
                                       SHPWLEN,
                                       _nHelpContext );

     BOOL fOK;
     err = ( (pdlg == NULL) ? ERROR_NOT_ENOUGH_MEMORY
                            : pdlg->QueryError() );

     if (  ( err == NERR_Success )
        && ( ( err = pdlg->Process( &fOK)) == NERR_Success )
        && ( fOK )
        )
     {
         NLS_STR nlsPassword( SHPWLEN );

         if (  ((err = nlsPassword.QueryError()) != NERR_Success )
            || ((err = pdlg->QueryPassword( &nlsPassword )) != NERR_Success )
            )
         {
            return err;
         }

         DEVICE dev(_nlsDev.QueryPch()) ;
         err = dev.GetInfo() ;
         if (err != NERR_Success)
             return err ;

         if ( (err = dev.Connect( _nlsTarget.QueryPch(),
                                  (TCHAR *) nlsPassword.QueryPch()))
                == NERR_Success)
         {
             _fConnected = TRUE;
         }

         RtlZeroMemory( (PVOID)nlsPassword.QueryPch(),
                        nlsPassword.QueryTextSize() );
     }

     delete pdlg;
     return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\sendmsg.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1989-1991          **/
/*****************************************************************/

/*
 *  sendmsg.cxx
 *      this module contains the code for the Send Message Dialog
 *      Base Class.
 *
 *  FILE HISTORY:
 *      ChuckC      19-Jul-1991     Culled from SHELL\SHELL\WNETDEV.CXX
 *
 */

#include "pchapplb.hxx"   // Precompiled header


//
//  Maximum number of characters in the message MLE.
//

#define MAX_MESSAGE_SIZE        8000    // characters, recommended by DanL


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::MS_DIALOG_BASE

    SYNOPSIS:   constructor

    ENTRY:      expects valid HWND for hDlg, a valid resource name
                in pszResource, and the CID to be used with the
                message text MLE in cidMsgText.

    HISTORY:
        ChuckC      06-Aug-1991 Took from wnetdev.cxx
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

MSG_DIALOG_BASE::MSG_DIALOG_BASE( HWND hDlg, const TCHAR *pszResource,
                                  CID cidMsgText )
   : DIALOG_WINDOW( pszResource, hDlg ),
     _mleTextMsg( this, cidMsgText, MAX_MESSAGE_SIZE )
{
    if ( QueryError() != NERR_Success )
        return;

    //  Direct the message edit control to add end-of-line
    //  character from wordwrapped text lines.
    //
    _mleTextMsg.SetFmtLines( TRUE );
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::~MSG_DIALOG_BASE

    SYNOPSIS:   this destructor does nothing

    HISTORY:
        ChuckC      06-Aug-1991     Created

********************************************************************/

MSG_DIALOG_BASE::~MSG_DIALOG_BASE()
{
   ;
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::OnOK

    SYNOPSIS:   replaces the OnOK in DIALOG_WINDOW. It calls the
                the GetAndSendText method to do the real work, and
                handles any errors that may return from that call.

    HISTORY:
        ChuckC      06-Aug-1991     Created

********************************************************************/

BOOL MSG_DIALOG_BASE::OnOK()
{
    /*
     * Attempt to send the message
     */
    APIERR usErr = GetAndSendText();

    /*
     * if success dismiss, else let subclass decide what to do
     */
    switch (usErr)
    {
    case NERR_Success:
        Dismiss(NERR_Success);
        break;

    default:
        (void) ActionOnError(usErr);
        break;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::ActionOnError

    SYNOPSIS:   allows a subclass to specify focus or any other
                action if an error occurs during send. Default
                is to report error, and then set focus on the MLE.

    ENTRY:      err contains an error code, which may be either
                base, net or UI.

    EXIT:       return TRUE if action is taken.

    HISTORY:
        ChuckC      06-Aug-1991     Created

********************************************************************/

BOOL MSG_DIALOG_BASE::ActionOnError( APIERR err )
{
    MsgPopup(this,err);
    _mleTextMsg.ClaimFocus();

    return(TRUE) ;
}


/*******************************************************************

    NAME:       MSG_DIALOG_BASE::GetAndSendText

    SYNOPSIS:   gets the list of target users, the text from the
                MLE, and calls NetMessageBufferSend.

    ENTRY:

    EXIT:       return NERR_Success if all is well, error code
                otherwise. This method does NOT report errors, nut
                lets its caller do so.

    HISTORY:
        ChuckC      06-Aug-1991     Stole from wnetdev.cxx

********************************************************************/

APIERR MSG_DIALOG_BASE::GetAndSendText()
{
    UINT cb = _mleTextMsg.QueryTextSize();
    if (cb <= sizeof(TCHAR))    // always has a terminating NULL
    {
        return( ERROR_GEN_FAILURE );
    }

    /*
     * Allocate a buffer for the number of characters + the nul
     * character.  Since this text could potentially be very long,
     * we use a BUFFER object.
     */
    BUFFER buf( cb );
    if ( buf.QueryError() != NERR_Success )
        return ( buf.QueryError() );

    APIERR err = _mleTextMsg.QueryText( (TCHAR*)buf.QueryPtr(),
                                        buf.QuerySize() );
    if (err == NERR_Success)
    {
        /*
         * Set cursor to hour glass.
         */
        AUTO_CURSOR autocur;

        STRLIST slUsers;
        err = QueryUsers(&slUsers);
        if (err != NERR_Success)
        {
            MsgPopup(this,err);
            return ( NERR_Success );
        }

        /*
         * create message object
         */
        LM_MESSAGE message;
        if ((err = message.QueryError()) != NERR_Success)
            return (err);

        /*
         * loop thru all users.
         */
        ITER_STRLIST  islUsers(slUsers);
        NLS_STR *pStr;
        APIERR errFirst = NERR_Success;
        while (pStr = islUsers())
        {
            /*
             * Note that we don't mention the nul character when
             *  we send the message.  This would result in one extra
             *  character displayed in WinPopup.
             */
            err  = message.SendBuffer ( (TCHAR *)pStr->QueryPch(),
                                        (TCHAR *)buf.QueryPtr(),
                                        (cb - sizeof(TCHAR)) );
            // if error, break out early
            if (err != NERR_Success && errFirst == NERR_Success)
                errFirst = err;
        }
        if (errFirst != NERR_Success)
            return (errFirst);
    }
    return (err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\openfile.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
 *  openfile.cxx
 *      this module contains the code for the Open File Dialog
 *      Base Class.
 *
 *  FILE HISTORY:
 *      ChuckC      06-Oct-1991         Stole from server manager
 *      beng        05-Mar-1992         wsprintf removal
 *      KeithMo     11-Sep-1992         Added dire warnings for dangerous
 *                                      closings.
 *
 */

#include "pchapplb.hxx"   // Precompiled header


//
//  This mask contains the permissions bits for "dangerous" opens.
//  Before we attempt to close any file opened with any of these
//  permissions, we give the user an especially dire warning.
//
//  NOTE:  Some code in this module depends on the following relationship:
//
//         ACCESS_EXEC > ACCESS_CREATE > ACCESS_WRITE > ACCESS_READ
//

#define DANGER_MASK     (ACCESS_EXEC | ACCESS_CREATE | ACCESS_WRITE)

#define NORMAL_MASK     (ACCESS_EXEC | ACCESS_CREATE | ACCESS_WRITE | ACCESS_READ)
#define ABNORMAL_MASK   (ACCESS_DELETE | ACCESS_ATRIB | ACCESS_PERM)



/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::OPEN_DIALOG_BASE

    SYNOPSIS:   OPEN_DIALOG_BASE class constructor.

    ENTRY:

    EXIT:

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        KeithMo     20-Aug-1991 Now inherits from PSEUDOSERVICE_DIALOG.
        KeithMo     20-Aug-1991 Now inherits from SRVPROP_OTHER_DIALOG.
        ChuckC      08-Oct-1991 Move to common place in applib, break
                                ties with previous parents.
        KeithMo     20-May-1992 Removed _nlsNotAvailable, uses "??" instead.
        beng        04-Aug-1992 Load dialog by ordinal

********************************************************************/
OPEN_DIALOG_BASE::OPEN_DIALOG_BASE( HWND  hwndOwner,
                                    UINT  idDialog,
                                    CID sltOpenCount,
                                    CID sltLockCount,
                                    CID pbClose,
                                    CID pbCloseAll,
                                    const TCHAR *pszServer,
                                    const TCHAR *pszBasePath,
                                    OPEN_LBOX_BASE *plbFiles )
  : DIALOG_WINDOW( idDialog, hwndOwner ),
    _sltOpenCount( this, sltOpenCount ),
    _sltLockCount( this, sltLockCount ),
    _pbClose     ( this, pbClose ),
    _pbCloseAll  ( this, pbCloseAll ),
    _pbOK        ( this, IDOK ),
    _nlsServer   ( pszServer ),
    _nlsBasePath ( pszBasePath ),
    _idClose     ( pbClose ),
    _idCloseAll  ( pbCloseAll ),
    _plbFiles    ( plbFiles )
{
    // usual check for ok-ness
    if( QueryError() != NERR_Success )
        return;

    // makes sure the strings constructed fine.
    APIERR err ;
    if ( (err = _nlsServer.QueryError() != NERR_Success) ||
         (err = _nlsBasePath.QueryError() != NERR_Success ) )
    {
        ReportError(err) ;
        return;
    }
}


/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::~OPEN_DIALOG_BASE

    SYNOPSIS:   OPEN_DIALOG_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/
OPEN_DIALOG_BASE::~OPEN_DIALOG_BASE()
{
    //  nothing more to do
}


/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::Refresh

    SYNOPSIS:   Refreshes the Open Resources dialog.

    EXIT:       The dialog is feeling relaxed and refreshed.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        05-Mar-1992 Use DEC_STR

********************************************************************/
VOID OPEN_DIALOG_BASE::Refresh()
{
    ULONG cOpenFiles;
    ULONG cFileLocks;
    ULONG cOpenNamedPipes;
    ULONG cOpenCommQueues;
    ULONG cOpenPrintQueues;
    ULONG cOtherResources;

    APIERR err = LM_SRVRES::GetResourceCount( QueryServer(),
                                              &cOpenFiles,
                                              &cFileLocks,
                                              &cOpenNamedPipes,
                                              &cOpenCommQueues,
                                              &cOpenPrintQueues,
                                              &cOtherResources );

    if( err == NERR_Success )
    {
        //  Update the open file & file lock counts.
        ULONG cOpenResources = cOpenFiles + cOpenNamedPipes + cOtherResources +
                               cOpenCommQueues + cOpenPrintQueues;

        // CODEWORK - wait for SLT_NUM
        // convert numbers to text and blast it out

        DEC_STR nlsOpenResources(cOpenResources);
        DEC_STR nlsLockCount(cFileLocks);
        ASSERT(!!nlsOpenResources && !!nlsLockCount);

        if (!!nlsOpenResources && !!nlsLockCount) // safety
        {
            _sltOpenCount.Enable( TRUE );
            _sltLockCount.Enable( TRUE );

            _sltOpenCount.SetText(nlsOpenResources);
            _sltLockCount.SetText(nlsLockCount);
        }
    }
    else
    {
        //  Since we couldn't retreive the file statistics,
        //  we'll just display ??.

        const TCHAR * pszNotAvailable = SZ("??");

        _sltOpenCount.Enable( FALSE );
        _sltLockCount.Enable( FALSE );

        _sltOpenCount.SetText( pszNotAvailable );
        _sltLockCount.SetText( pszNotAvailable );
    }

    //  Refresh the files listbox, and enable buttons as appropriate
    _plbFiles->Refresh();

    //
    // Move the focus to the OK button so it isn't lost when the close
    // buttons are disabled
    //

    if ( _plbFiles->QueryCount() == 0 )
    {
        _pbOK.ClaimFocus() ;
        _pbOK.MakeDefault() ;
    }

    _pbClose.Enable( _plbFiles->QuerySelCount() > 0 );
    _pbCloseAll.Enable( _plbFiles->QueryCount() > 0 );
}


/*******************************************************************

    NAME:       OPEN_DLG_BASE::OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Control Event

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        KeithMo     24-Mar-1992 Made NO the default button.

********************************************************************/
BOOL OPEN_DIALOG_BASE::OnCommand( const CONTROL_EVENT & event)
{
    //  Determine the control which is sending the command.
    if( event.QueryCid() == _idClose )
    {
        OPEN_LBI_BASE * polbi = _plbFiles->QueryItem();
        UIASSERT( polbi != NULL );

        // See if the user really wants to close this file.
        if( WarnCloseSingle( polbi ) )
        {
            //  Close the file And refresh dialog
            CloseFile( polbi );
            Refresh();
        }
        return TRUE;
    }
    else if ( event.QueryCid() == _idCloseAll )
    {
        // See if the user really wants to close *all* files.
        if( WarnCloseMulti() )
        {
            //
            //  Close ALL of the open files.
            //
            //  Note that the CloseFile() method does not touch
            //  the listbox.  Therefore, there is no need to
            //  mess around with the item count & item index
            //  after closing a file.
            //
            INT cItems = _plbFiles->QueryCount();
            for( INT i = 0 ; i < cItems ; i++ )
            {
                OPEN_LBI_BASE * polbi = _plbFiles->QueryItem( i );
                UIASSERT( polbi != NULL );
                if (polbi)
                    CloseFile( polbi );
            }

            //  Refresh the dialog.
            Refresh();
        }
        return TRUE;
    }
    else
    {
        // we are not interested, let parent handle
        return(FALSE) ;
    }
}

/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::CloseFile

    SYNOPSIS:   Closes a file on the remote server.

    ENTRY:      polbi                   - The OPEN_LBI_BASE item which
                                          represents the open file.

    EXIT:       If the file could not be deleted, then an error
                message popup is displayed.

    HISTORY:
        KeithMo     19-Aug-1991 Created.
        terryk      26-Aug-1991 Remove NetFileClose2
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

VOID OPEN_DIALOG_BASE::CloseFile( OPEN_LBI_BASE * polbi )
{
    //  This object represents the remote file.
    LM_FILE_2 file2( QueryServer(), polbi->QueryFileID() );

    //  Ensure the file object constructed properly.
    APIERR err = file2.QueryError();

    if( err == NERR_Success )
    {
        //
        //  The file object contructed properly, now close
        //  the remote file.
        //
        err = file2.CloseFile();

        //
        // if file is not found (already gone, just ignore)
        //
        if (err == NERR_FileIdNotFound)
             err = NERR_Success ;
    }

    if( err != NERR_Success )
    {
        //  Either the file object failed to construct or
        //  the file close failed.  Either way, tell the
        //  user the bad news.
        MsgPopup( this, err, MPSEV_ERROR );
    }
}


/*******************************************************************

    NAME:       OPEN_DIALOG_BASE::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

ULONG OPEN_DIALOG_BASE::QueryHelpContext()
{
    UIASSERT(FALSE) ;   // this ensures that someone does redefine the method
    return 0 ;
}


/*******************************************************************

    NAME:       OPEN_DLG_BASE :: WarnCloseSingle

    SYNOPSIS:   Warn the user before closing an individual resource.

    ENTRY:      plbi                    - The currently selected LBI.

    RETURNS:    BOOL                    - TRUE  if the wants to close the
                                          resource,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     11-Sep-1992 Created.

********************************************************************/
BOOL OPEN_DIALOG_BASE :: WarnCloseSingle( OPEN_LBI_BASE * plbi )
{
    UIASSERT( plbi != NULL );

    //
    //  Setup our potential insert strings.
    //

    ALIAS_STR nlsUser( plbi->QueryUserName() );
    ALIAS_STR nlsAccess( plbi->QueryAccessName() );
    ALIAS_STR nlsPath( plbi->QueryPath() );

    NLS_STR * apnls[4];

    //
    //  The message id.
    //

    MSGID idMsg = 0;

    if( plbi->QueryPermissions() & DANGER_MASK )
    {
        //
        //  The user has a file open for a "dangerous" access
        //  (write, create, or exec).
        //
        //      %1 = user name
        //      %2 = access permission
        //      %3 = resource name
        //

        apnls[0] = &nlsUser;
        apnls[1] = &nlsAccess;
        apnls[2] = &nlsPath;
        apnls[3] = NULL;

        idMsg = IDS_UI_CLOSE_WARN;
    }
    else
    {
        //
        //  The user has a file open for a boring (safe) access.
        //
        //      %1 = user name
        //      %2 = resource name
        //

        apnls[0] = &nlsUser;
        apnls[1] = &nlsPath;
        apnls[2] = NULL;

        idMsg = IDS_UI_CLOSE_FILE;
    }

    UIASSERT( idMsg != 0 );

    return( ::MsgPopup( this,
                        idMsg,
                        MPSEV_WARNING,
                        HC_DEFAULT_HELP,
                        MP_YESNO,
                        apnls,
                        MP_NO ) == IDYES );

}   // OPEN_DIALOG_BASE :: WarnCloseSingle


/*******************************************************************

    NAME:       OPEN_DLG_BASE :: WarnCloseMulti

    SYNOPSIS:   Warn the user before closing all open resources.

    RETURNS:    BOOL                    - TRUE  if the wants to close the
                                          resources,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     11-Sep-1992 Created.

********************************************************************/
BOOL OPEN_DIALOG_BASE :: WarnCloseMulti( VOID )
{
    //
    //  Get the number of items in the listbox.
    //

    INT cItems = _plbFiles->QueryCount();
    UIASSERT( cItems > 0 );

    //
    //  These items will keep track of the most "severe"
    //  open type encountered in the listbox.
    //

    ULONG         nMaxPerm   = 0;
    const TCHAR * pszMaxPerm = SZ("");

    //
    //  Scan for the most severe permission type.
    //

    for( INT i = 0 ; i < cItems ; i++ )
    {
        OPEN_LBI_BASE * plbi = _plbFiles->QueryItem( i );
        UIASSERT( plbi != NULL );

        if( plbi->QueryPermissions() > nMaxPerm )
        {
            nMaxPerm   = plbi->QueryPermissions();
            pszMaxPerm = plbi->QueryAccessName();
        }
    }

    //
    //  Potential insert strings.
    //

    ALIAS_STR nlsServer( QueryServer() );
    ALIAS_STR nlsPerm( pszMaxPerm );

    NLS_STR * apnls[2];

    //
    //  The message id.
    //

    MSGID idMsg = 0;

    if( nMaxPerm > ACCESS_READ )
    {
        //
        //  Somebody has a dangerous access.
        //

        apnls[0] = &nlsPerm;
        apnls[1] = NULL;

        idMsg = IDS_UI_CLOSE_LOSE_DATA;
    }
    else
    {
        //
        //  Everybody has boring access.
        //

        apnls[0] = &nlsServer;
        apnls[1] = NULL;

        idMsg = IDS_UI_CLOSE_ALL;
    }

    UIASSERT( idMsg != 0 );

    return( ::MsgPopup( this,
                        idMsg,
                        MPSEV_WARNING,
                        HC_DEFAULT_HELP,
                        MP_YESNO,
                        apnls,
                        MP_NO ) == IDYES );

}   // OPEN_DIALOG_BASE :: WarnCloseMulti


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::OPEN_LBOX_BASE

    SYNOPSIS:   OPEN_LBOX_BASE class constructor.

    ENTRY:      powOwner                - The "owning" window.

                cid                     - The listbox CID.

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

OPEN_LBOX_BASE::OPEN_LBOX_BASE( OWNER_WINDOW * powOwner,
                                CID            cid,
                                const NLS_STR &nlsServer,
                                const NLS_STR &nlsBasePath )
  : BLT_LISTBOX( powOwner, cid ),
    _nlsServer(nlsServer),
    _nlsBasePath(nlsBasePath)
{
    //  Ensure we constructed properly.
    if( QueryError() != NERR_Success)
        return;

    APIERR err ;
    if ( (err = _nlsServer.QueryError()) != NERR_Success ||
         (err = _nlsBasePath.QueryError()) != NERR_Success )
    {
        ReportError(err) ;
        return;
    }
}


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::~OPEN_LBOX_BASE

    SYNOPSIS:   OPEN_LBOX_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

OPEN_LBOX_BASE::~OPEN_LBOX_BASE()
{
    ;  // nothing more to do
}


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::Fill

    SYNOPSIS:   Fill the list of open files.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

APIERR OPEN_LBOX_BASE::Fill()
{
    AUTO_CURSOR Cursor;

    //  A level 3 file enumerator.
    FILE3_ENUM  enumFile3( _nlsServer.QueryPch(), _nlsBasePath.QueryPch() );

    //  See if the files are available.
    APIERR err = enumFile3.GetInfo();

    if( err != NERR_Success )
        return err;

    //
    //  Now that we know the file info is available,
    //  let's nuke everything in the listbox.
    //
    SetRedraw( FALSE );
    DeleteAllItems();

    //  For iterating the available files.
    FILE3_ENUM_ITER iterFile3( enumFile3 );
    const FILE3_ENUM_OBJ *pfi3;

    //  Iterate the files adding them to the listbox.
    while( ( err == NERR_Success ) && ( ( pfi3 = iterFile3( &err ) ) != NULL ) )
    {
        OPEN_LBI_BASE * polbi = CreateFileEntry(pfi3) ;

        if ( (polbi == NULL) || (AddItem( polbi ) < 0) )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break ;
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;
}


/*******************************************************************

    NAME:       OPEN_LBOX_BASE::Refresh

    SYNOPSIS:   Refreshes the list of open resources.

    EXIT:       The listbox is refreshed & redrawn.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method is now obsolete.  It will be replaced
                as soon as KevinL's WFC refreshing listbox code is
                available.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

APIERR OPEN_LBOX_BASE::Refresh()
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    APIERR err = Fill();

    if( err != NERR_Success )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        SetTopIndex( ( ( iTop < 0 ) || ( iTop >= cItems ) ) ? 0
                                                            : iTop );

        if( iCurrent < 0 )
        {
            iCurrent = 0;
        }
        else
        if( iCurrent >= cItems )
        {
            iCurrent = cItems - 1;
        }

        SelectItem( iCurrent );
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       OPEN_LBI_BASE::OPEN_LBI_BASE

    SYNOPSIS:   OPEN_LBI_BASE class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                uPermissions            - Open permissions.

                cLocks                  - Number of locks.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Use DMID_DTE passed into constructor.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        22-Nov-1991 Ctors for empty strings
        beng        05-Mar-1992 use DEC_STR

********************************************************************/

OPEN_LBI_BASE::OPEN_LBI_BASE( const TCHAR *pszUserName,
                              const TCHAR *pszPath,
                              ULONG        uPermissions,
                              ULONG        cLocks,
                              ULONG        ulFileID)
  : _ulFileID( ulFileID ),
    _uPermissions( uPermissions ),
    _nlsUserName( pszUserName ),
    _nlsAccess(), // init below
    _nlsLocks(cLocks), // DEC_STR
    _nlsPath( pszPath )
{
    if( QueryError() != NERR_Success )
        return;

    APIERR err;
    if( ( ( err = _nlsUserName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsAccess.QueryError() )   != NERR_Success ) ||
        ( ( err = _nlsPath.QueryError() )   != NERR_Success ) ||
        ( ( err = _nlsLocks.QueryError() )    != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Initialize the more complex strings.
    //

    //
    //  If this file is not opened with a "normal" access, but IS
    //  opened with an "abnormal" access, then map it to write.  This
    //  so we don't have to display "attrib" and "perm" and other
    //  access types most users would never understand anyway.
    //

    if( !( uPermissions & NORMAL_MASK   ) &&
         ( uPermissions & ABNORMAL_MASK ) )
    {
        uPermissions |= ACCESS_WRITE;
    }

    /*
     * see if we can find the right perm. if not, set to UNKNOWN
     * (which by the way, should not happen and hence the assert).
     */

    UINT idString = (uPermissions & ACCESS_EXEC)   ? IDS_UI_EXECUTE :
                    (uPermissions & ACCESS_CREATE) ? IDS_UI_CREATE :
                    (uPermissions & ACCESS_WRITE)  ? IDS_UI_WRITE :
                    (uPermissions & ACCESS_READ)   ? IDS_UI_READ :
                                                     IDS_UI_UNKNOWN;

    UIASSERT( idString != IDS_UI_UNKNOWN );
    err = _nlsAccess.Load( idString );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       OPEN_LBI_BASE::~OPEN_LBI_BASE

    SYNOPSIS:   OPEN_LBI_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

OPEN_LBI_BASE::~OPEN_LBI_BASE()
{
    //
    //  This space intentionally left blank.
    //
}


/*******************************************************************

    NAME:       OPEN_LBI_BASE::QueryLeadingChar

    SYNOPSIS:   Return the leading character of this item.

    RETURNS:    WCHAR - The leading character.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.

********************************************************************/

WCHAR OPEN_LBI_BASE::QueryLeadingChar() const
{
    ISTR istr( _nlsUserName );

    return _nlsUserName.QueryChar( istr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\sleican.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    slestrip.cxx
    This file contains the class ICANON_SLE which is basically the same as
    an SLE except that it uses the Netlib I_MNetNameValidate() to validate
    the contents of the sle.

    FILE HISTORY:
        Thomaspa	13-Feb-1992     Created

*/

#include "pchapplb.hxx"   // Precompiled header

/*******************************************************************

    NAME:	ICANON_SLE::ICANON_SLE

    SYNOPSIS:	Constructor - Same as SLE

    ENTRY:	powin	 - pointer OWNER_WINDOW
                cid      - CID
		usMaxLen - Maximum number of characters allowed to be typed in
		nIcanonCode - NameType to pass to I_MNetNameValidate()

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

ICANON_SLE::ICANON_SLE( OWNER_WINDOW * powin, CID cid,
		      UINT usMaxLen, INT nICanonCode)
    : SLE( powin, cid, usMaxLen ),
      _fUsesNetlib( ( nICanonCode == 0 ) ? FALSE : TRUE ),
      _nICanonCode( nICanonCode )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	ICANON_SLE::ICANON_SLE

    SYNOPSIS:	Constructor - Same as SLE

    ENTRY:	

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

ICANON_SLE::ICANON_SLE( OWNER_WINDOW * powin, CID cid,
	              XYPOINT xy, XYDIMENSION dxy,
	              ULONG flStyle, const TCHAR * pszClassName,
	              UINT usMaxLen, INT nICanonCode )
    : SLE( powin, cid, xy, dxy, flStyle, pszClassName, usMaxLen),
      _fUsesNetlib( ( nICanonCode == 0 ) ? FALSE : TRUE ),
      _nICanonCode( nICanonCode )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	ICANON_SLE::Validate

    SYNOPSIS:	Validate the contents using I_NetNameValidate

    ENTRY:	none

    EXIT:	TRUE if contents valid, FALSE otherwise

    NOTES:
		If _fUsesNetlib is FALSE, always return TRUE.

    HISTORY:
	thomaspa    21-Jan-1992 Created
	thomaspa    21-Jul-1992 Added error mapping.

********************************************************************/

APIERR ICANON_SLE::Validate()
{
    if ( !_fUsesNetlib )
    {
	return SLE::Validate();
    }


    NLS_STR nlsName;
    QueryText( &nlsName );

    APIERR err;
    if ( (err = nlsName.QueryError()) != NERR_Success )
    {
        return err;
    }
	
    // CODEWORK: Should we be using a Servername?

    err = ::I_MNetNameValidate(NULL,
				nlsName.QueryPch(),
				_nICanonCode,
				0L );

    // We should map some errors.
    // CODEWORK: The below should really be a table
    switch ( err )
    {
    case ERROR_INVALID_NAME:
        switch ( _nICanonCode )
        {
        case NAMETYPE_USER:
	    err = NERR_BadUsername;
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    return( err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\ssfdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    ssfdlg.cxx
        Standalone set focus dialog box source file

        It will display a standalone dialog box and get the domain or
        server name from the user. It will report to the caller the
        name if the user hits OK button.

    FILE HISTORY:
        terryk  18-Nov-91       Created
        terryk  19-Nov-91       remove ssfdlg.hxx reference
        KeithMo 07-Aug-1992     Added HelpContext parameters.

*/

#include "pchapplb.hxx"   // Precompiled header


/*******************************************************************

    NAME:       STANDALONE_SET_FOCUS_DLG::STANDALONE_SET_FOCUS_DLG

    SYNOPSIS:   Standalone Set Focus Dialog box constructor

    ENTRY:      HWND hWnd - the owner window handle
                NLS_STR *pnlsName - point to the NLS_STR which receives
                    the domain or server name

    HISTORY:
                terryk  18-Nov-1991     Created
                KeithMo 22-Jul-1992     Added maskDomainSources &
                                        pszDefaultSelection.

********************************************************************/

STANDALONE_SET_FOCUS_DLG::STANDALONE_SET_FOCUS_DLG(
                                            HWND wndOwner,
                                            NLS_STR *pnlsName,
                                            ULONG nHelpContext,
                                            SELECTION_TYPE seltype,
                                            ULONG maskDomainSources,
                                            const TCHAR * pszDefaultSelection,
                                            const TCHAR * pszHelpFile,
                                            ULONG nServerTypes )
    : BASE_SET_FOCUS_DLG( wndOwner,
                          seltype,
                          maskDomainSources,
                          pszDefaultSelection,
                          nHelpContext,
                          pszHelpFile,
                          nServerTypes ),
    _pnlsName( pnlsName )
{
    if ( _pnlsName == NULL )
    {
        ReportError( ERROR_INVALID_PARAMETER );
    }
}

/*******************************************************************

    NAME:       STANDALONE_SET_FOCUS_DLG::SetNetworkFocus

    SYNOPSIS:   It is called when the user hits the OK button. It will
                copy the domain or server name from the SLE to the
                default receive NLS_STR.

    ENTRY:      new domain or server name

    RETURNS:    APIERR - in case of assign error for the NLS_STR

    HISTORY:
                terryk  18-Nov-1991     Created

********************************************************************/

APIERR STANDALONE_SET_FOCUS_DLG::SetNetworkFocus( HWND hwndOwner,
                                                  const TCHAR * pszNetworkFocus,
                                                  FOCUS_CACHE_SETTING setting )
{
    UNREFERENCED(hwndOwner);
    UNREFERENCED(setting);

    *_pnlsName = pszNetworkFocus;
    return _pnlsName->QueryError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\slestrlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    slelbgrp.cxx

    This file contains the implementation for the SLE_STRLB_GROUP.



    FILE HISTORY:
        JohnL   11-Apr-1992     Created

*/

#include "pchapplb.hxx"   // Precompiled header

#ifndef min
#define min(a,b)   ((a)<(b) ? (a) : (b))
#endif

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::SLE_STRLB_GROUP

    SYNOPSIS:   Basic constructor/destructor for this group

    ENTRY:      powin - Pointer to owner window
                psleInput - Pointer to input SLE
                pStrLB - Pointer to string listbox
                pbuttonAdd - pointer to Add button
                pbuttonRemove - Pointer to Remove button

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

SLE_STRLB_GROUP::SLE_STRLB_GROUP( OWNER_WINDOW   * powin,
                                  SLE            * psleInput,
                                  STRING_LISTBOX * pStrLB,
                                  PUSH_BUTTON    * pbuttonAdd,
                                  PUSH_BUTTON    * pbuttonRemove )
    : CONTROL_GROUP ( NULL ),
      _pStrLB       ( pStrLB ),
      _psleInput    ( psleInput ),
      _pbuttonAdd   ( pbuttonAdd ),
      _pbuttonRemove( pbuttonRemove )
{
    if ( QueryError() )
        return ;

    UNREFERENCED( powin ) ;

    if ( pStrLB        == NULL ||
         psleInput     == NULL ||
         pbuttonAdd    == NULL ||
         pbuttonRemove == NULL )
    {
        ReportError( ERROR_INVALID_PARAMETER ) ;
        ASSERT( FALSE ) ;
        return ;
    }

    pStrLB->SetGroup( this ) ;
    psleInput->SetGroup( this ) ;
    pbuttonAdd->SetGroup( this ) ;
    pbuttonRemove->SetGroup( this ) ;

}

SLE_STRLB_GROUP::~SLE_STRLB_GROUP()
{
    _pStrLB = NULL ;
    _psleInput = NULL ;
    _pbuttonAdd = NULL ;
    _pbuttonRemove = NULL ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::Init

    SYNOPSIS:   Adds items to the string listbox and initializes the buttons
                appropriately.

    ENTRY:      pstrlist - Optional list of strings to initialize the string
                    listbox to.

    EXIT:       The listbox will be filled and the button state will be
                correct based on the contents of the controls.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

APIERR SLE_STRLB_GROUP::Init( STRLIST * pstrlist )
{
    if ( pstrlist != NULL )
    {
        ITER_STRLIST iterStrList( *pstrlist ) ;
        NLS_STR * pnls ;

        while ( (pnls = iterStrList.Next() ))
        {
            if ( QueryStrLB()->AddItemIdemp( *pnls ) < 0 )
            {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }
        }
    }

    if ( QueryStrLB()->QueryCount() > 0 )
    {
        QueryStrLB()->SelectItem( 0 ) ;
    }

    SetState() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::OnAdd

    SYNOPSIS:   Adds the current contents of the Input SLE to the listbox

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created
        KeithMo 12-Nov-1992     Moved major guts to W_Add virtual.

********************************************************************/

APIERR SLE_STRLB_GROUP::OnAdd( void )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsAlertDestName( 30 ) ;
    if ( (err = nlsAlertDestName.QueryError()) ||
         (err = QueryInputSLE()->QueryText( & nlsAlertDestName)) ||
         (err = W_Add(nlsAlertDestName)))
    {
        /* Fall through
         */
    }

    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::OnRemove

    SYNOPSIS:   Removes the currently selected item from the listbox and
                places the text into the input SLE

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

APIERR SLE_STRLB_GROUP::OnRemove( void )
{
    APIERR err = NERR_Success ;
    NLS_STR nlsAlertDestName( 30 ) ;
    if ( (err = nlsAlertDestName.QueryError()) ||
         (err = QueryStrLB()->QueryItemText( &nlsAlertDestName )) )
    {
        /* Fall through
         */
    }
    else
    {
        QueryInputSLE()->SetText( nlsAlertDestName ) ;
        QueryInputSLE()->SelectString() ;
        QueryInputSLE()->ClaimFocus() ;
        INT iCurrentSel = QueryStrLB()->QueryCurrentItem() ;
        QueryStrLB()->DeleteItem( iCurrentSel ) ;
        QueryStrLB()->SelectItem( min( iCurrentSel,
                                       QueryStrLB()->QueryCount()-1 )) ;
    }

    if ( QueryStrLB()->QueryCount() == 0 )
    {
        //QueryStrLB()->Enable( FALSE ) ;
    }

    SetState() ;
    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::W_Add

    SYNOPSIS:   Adds a string to the listbox

    ENTRY:      psz     - The string to add to the listbox.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        KeithMo 12-Nov-1992     Created from JohnL's original OnAdd.

********************************************************************/

APIERR SLE_STRLB_GROUP::W_Add( const TCHAR * psz )
{
    APIERR err = NERR_Success ;
    BOOL fSetSel = QueryStrLB()->QueryCount() == 0 ;

    if ( QueryStrLB()->AddItemIdemp( psz ) < 0 )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    else
    {
        QueryInputSLE()->ClearText() ;

        /* We put the focus into the SLE so we don't lose it when the "Add"
         * button is grayed
         */
        QueryInputSLE()->ClaimFocus() ;
    }

    /* If we went from a zero count to > 0 count, then select the first item
     */
    if ( fSetSel && QueryStrLB()->QueryCount() > 0 )
    {
        QueryStrLB()->Enable( TRUE ) ;
        QueryStrLB()->SelectItem( 0 ) ;
    }

    SetState() ;
    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::OnUserAction

    SYNOPSIS:   Watches the Input SLE and enabling the Add button appropriately
                Also catches the Add and Remove button presses.

    RETURNS:

    NOTES:      We know the only way a button changes is is somebody presses
                it.

                If we ever process any messages that doesn't modify the
                group, then we would return GROUP_NO_CHANGE instead of
                NERR_Success (which notifies our parent groups).

                If an error occurs, we simply return it and the dialog
                processing code will put up a Message box.

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

APIERR SLE_STRLB_GROUP::OnUserAction( CONTROL_WINDOW * pcwin,
                                      const CONTROL_EVENT & e )
{
    UNREFERENCED( e ) ;
    APIERR err = NERR_Success ;

    if ( pcwin == QueryInputSLE() )
    {
        QueryAddButton()->Enable( QueryInputSLE()->QueryTextLength() > 0 ) ;
    }
    else if ( pcwin == QueryAddButton() )
    {
        err = OnAdd() ;
    }
    else if ( pcwin == QueryRemoveButton() )
    {
        err = OnRemove() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       SLE_STRLB_GROUP::SetState

    SYNOPSIS:   Sets the button state based on the current contents of the
                controls

    NOTES:

    HISTORY:
        JohnL   11-Apr-1992     Created

********************************************************************/

void SLE_STRLB_GROUP::SetState( void ) const
{
    QueryAddButton()->Enable( QueryInputSLE()->QueryTextLength() > 0 ) ;
    QueryRemoveButton()->Enable( QueryStrLB()->QueryCount() > 0 ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\slestrip.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    slestrip.cxx
    This file contains the class SLE_STRIP which is basically the same as
    an ICANON_SLE except that QueryText is redefined to strip the leading or
    trailing characters or both.

    FILE HISTORY:
        Yi-HsinS	11-Oct-1991     Created

*/
#include "pchapplb.hxx"   // Precompiled header

#define STRING_TERMINATOR TCH('\0')

const TCHAR * SLE_STRIP :: QueryWhiteSpace ()
{
    return SZ(" \t") ;
}

/*******************************************************************

    NAME:	SLE_STRIP::SLE_STRIP

    SYNOPSIS:	Constructor - Same as ICANON_SLE

    ENTRY:	powin	 - pointer OWNER_WINDOW
                cid      - CID
		usMaxLen - Maximum number of characters allowed to be typed in

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

SLE_STRIP::SLE_STRIP( OWNER_WINDOW * powin, CID cid,
		      UINT usMaxLen, INT nNameType)
    : ICANON_SLE( powin, cid, usMaxLen, nNameType )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	SLE_STRIP::SLE_STRIP

    SYNOPSIS:	Constructor - Same as ICANON_SLE

    ENTRY:	

    EXIT:	The object is constructed.

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

SLE_STRIP::SLE_STRIP( OWNER_WINDOW * powin, CID cid,
	              XYPOINT xy, XYDIMENSION dxy,
	              ULONG flStyle, const TCHAR * pszClassName,
	              UINT usMaxLen, INT nNameType )
    : ICANON_SLE( powin, cid, xy, dxy, flStyle,
		  pszClassName, usMaxLen, nNameType)
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:	SLE_STRIP::QueryText

    SYNOPSIS:	Query the text in the SLE, the leading characters in
		pszBefore is stripped and the trailing characters in
		pszAfter is stripped off as well.

    ENTRY:	pszBuffer - Buffer
		cbBufSize - size of pszBuffer
		pszBefore - contains the characters to be stripped off
			    from the beginning of the text
		pszAfter  - contains the characters to be stripped off
			    at the end of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR SLE_STRIP::QueryText( TCHAR * pszBuffer,
			     UINT cbBufSize,
		             const TCHAR *pszBefore,
			     const TCHAR *pszAfter ) const
{
     UIASSERT( pszBuffer != NULL );

     APIERR err = NERR_Success;
     if ( ( err = ICANON_SLE::QueryText( pszBuffer, cbBufSize) )
			!= NERR_Success )
     {

         ALIAS_STR nls( pszBuffer);
         if (  ((err = ::TrimLeading( &nls, pszBefore )) != NERR_Success )
	    && ((err = ::TrimTrailing( &nls, pszAfter )) != NERR_Success )
	    )
         {
	    ;   // Nothing to do
         }
     }

     return err;

}


/*******************************************************************

    NAME:	SLE_STRIP::QueryText

    SYNOPSIS:	Query the text in the SLE, the leading characters in
		pszBefore is stripped and the trailing characters in
		pszAfter is stripped off as well.

    ENTRY:	pnls      - the place to put text to
		pszBefore - contains the characters to be stripped off
			    from the beginning of the text
		pszAfter  - contains the characters to be stripped off
			    at the end of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR SLE_STRIP::QueryText( NLS_STR * pnls,
		             const TCHAR *pszBefore,
			     const TCHAR *pszAfter ) const
{

     APIERR err = NERR_Success;
     if (  (( err = ICANON_SLE::QueryText( pnls )) != NERR_Success )
        || (( err = ::TrimLeading( pnls, pszBefore )) != NERR_Success )
	|| (( err = ::TrimTrailing( pnls, pszAfter )) != NERR_Success )
	)
     {
	 ;   // Nothing to do
     }

     return err;
}


/*******************************************************************

    NAME:	GLOBAL::TrimLeading

    SYNOPSIS:	The leading characters in pnls that belongs to pszBefore
		is stripped off.

    ENTRY:	pnls      - the string
		pszBefore - contains the characters to be stripped off
			    from the beginning of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR TrimLeading( NLS_STR *pnls, const TCHAR *pszBefore)
{
    // If pszBefore is NULL, just return success.
    if ( pszBefore == NULL )
	return NERR_Success;

    ALIAS_STR nlsBefore( pszBefore );
    ISTR istrStart( *pnls ) , istrEnd( *pnls );

    if ( pnls->strspn( &istrEnd, nlsBefore) )
        pnls->DelSubStr( istrStart, istrEnd);

    return pnls->QueryError();
}


/*******************************************************************

    NAME:	GLOBAL::TrimTrailing

    SYNOPSIS:	The trailing characters in pnls that belongs to pszAfter
		is stripped off.

    ENTRY:	pnls      - the string
		pszAfter  - contains the characters to be stripped off
			    at the end of the text

    EXIT:	

    RETURNS:

    HISTORY:
	Yi-HsinS     5-Oct-1991	Created

********************************************************************/

APIERR TrimTrailing( NLS_STR *pnls, const TCHAR *pszAfter)
{
    // If pszAfter is NULL, just return success.
    if ( pszAfter == NULL )
	return NERR_Success;

    ALIAS_STR nlsAfter( pszAfter );
    ISTR istrAfter( nlsAfter );
    BOOL fFound = TRUE;

    while ( fFound )
    {
	fFound = FALSE;
        istrAfter.Reset();

        while ( nlsAfter.QueryChar( istrAfter )  != STRING_TERMINATOR  )
        {
	    ISTR istr( *pnls );
	    if (  ( pnls->strrchr( &istr, nlsAfter.QueryChar( istrAfter )))
	       && ( istr.IsLastPos() )
	       )
	    {
		  pnls->DelSubStr( istr );
		  fFound = TRUE;
		  break;
	    }
	    ++istrAfter;

	}
    }

    return pnls->QueryError();
}

//  End of SLESTRIP.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\uidomain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uidomain.cxx
    This file contains the class definitions for the UI_DOMAIN class.

    The UI_DOMAIN class is somewhat similar to the "normal" DOMAIN class.
    In fact, UI_DOMAIN *contains* a DOMAIN object.  The only external
    difference is that UI_DOMAIN::GetInfo will prompt the user for
    the name of a known DC if either the MNetGetDCName or I_MNetGetDCList
    API fails.


    FILE HISTORY:
        KeithMo     30-Aug-1992     Created.

*/

#include "pchapplb.hxx"   // Precompiled header


//
//  The maximum computer name length accepted by the dialog.
//

#define UI_MAX_COMPUTERNAME_LENGTH      MAX_PATH



//
//  UI_DOMAIN methods.
//


/*******************************************************************

    NAME:       UI_DOMAIN :: UI_DOMAIN

    SYNOPSIS:   UI_DOMAIN class constructor.

    ENTRY:      wndOwner                - The "owning" window.

                hc                      - Help context to be used if a
                                          prompt dialog is necessary.

                pszDomainName           - Name of the target domain.

                fBackupDCsOK            - If TRUE, then QueryPDC may
                                          actually return a BDC.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
UI_DOMAIN :: UI_DOMAIN( PWND2HWND   & wndOwner,
                        ULONG         hc,
                        const TCHAR * pszDomainName,
                        BOOL          fBackupDCsOK )
  : BASE(),
    _wndOwner( wndOwner ),
    _hc( hc ),
    _nlsDomainName( pszDomainName ),
    _nlsBackupDC(),
    _fBackupDCsOK( fBackupDCsOK ),
    _pdomain( NULL )
{
    UIASSERT( pszDomainName != NULL );

    //
    //  Ensure everything constructed properly.
    //

    APIERR err;

    if( ( ( err = QueryError()                ) != NERR_Success ) ||
        ( ( err = _nlsDomainName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsBackupDC.QueryError()   ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // UI_DOMAIN :: UI_DOMAIN


/*******************************************************************

    NAME:       UI_DOMAIN :: ~UI_DOMAIN

    SYNOPSIS:   UI_DOMAIN class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
UI_DOMAIN :: ~UI_DOMAIN( VOID )
{
    delete _pdomain;
    _pdomain = NULL;

}   // UI_DOMAIN :: ~UI_DOMAIN


/*******************************************************************

    NAME:       UI_DOMAIN :: GetInfo

    SYNOPSIS:   Creates the actual DOMAIN object.  May prompt the
                user for a known DC in the domain.

    EXIT:       If successful, then a DOMAIN object is created.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
APIERR UI_DOMAIN :: GetInfo( VOID )
{
    UIASSERT( _pdomain == NULL );

    //
    //  Create the domain object.
    //

    _pdomain = new DOMAIN( _nlsDomainName );

    APIERR err = ( _pdomain == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                      : _pdomain->GetInfo();

    if( ( err != NERR_DCNotFound ) || !_fBackupDCsOK )
    {
        return err;
    }

    //
    //  We no longer need the domain object.
    //

    delete _pdomain;
    _pdomain = NULL;

    //
    //  Loop until either success or the user bags out.
    //

    while( TRUE )
    {
        //
        //  Prompt the user for a known DC in the domain.
        //

        BOOL fUserPressedOK = FALSE;
        PROMPT_FOR_ANY_DC_DLG * pDlg = new PROMPT_FOR_ANY_DC_DLG( _wndOwner,
                                                                  _hc,
                                                                  &_nlsDomainName,
                                                                  &_nlsBackupDC );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process( &fUserPressedOK );

        delete pDlg;

        if( err == NERR_Success )
        {
            //
            //  Ensure the string didn't barf.
            //

            err = _nlsBackupDC.QueryError();
        }

        if( err != NERR_Success )
        {
            break;
        }

        if( !fUserPressedOK )
        {
            //
            //  The user bagged-out.
            //

            err = NERR_DCNotFound;
            break;
        }

        //
        //  Determine if the specified server is really a DC
        //  in the target domain.  We do this by confirming
        //  that the machine's primary domain is the target
        //  domain and that the machine's role is backup or
        //  primary.
        //

        API_SESSION apisess( _nlsBackupDC );

        err = apisess.QueryError();

        if( err == NERR_Success )
        {
            WKSTA_10 wks( _nlsBackupDC );

            err = wks.QueryError();

            if( err == NERR_Success )
            {
                err = wks.GetInfo();
            }

            if( ( err == NERR_Success ) &&
                !::I_MNetComputerNameCompare( _nlsDomainName,
                                              wks.QueryWkstaDomain() ) )
            {
                //
                //  We now know that the server is indeed in
                //  the target domain.  Now verify that it's
                //  role is backup or primary.
                //

                SERVER_1 srv( _nlsBackupDC );

                err = srv.QueryError();

                if( err == NERR_Success )
                {
                    err = srv.GetInfo();
                }

                if( err == NERR_Success )
                {
                    if( srv.QueryServerType() &
                            ( SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ) )
                    {
                        //
                        //  It is a backup or primary, so exit the loop
                        //  with err == NERR_Success.
                        //

                        break;
                    }
                }
            }
        }

        if( ( err != NERR_Success         ) &&
            ( err != NERR_NameNotFound    ) &&
            ( err != NERR_NetNameNotFound ) &&
            ( err != ERROR_NOT_SUPPORTED  ) &&
            ( err != ERROR_BAD_NETPATH    ) &&
            ( err != ERROR_LOGON_FAILURE  ) )
        {
            //
            //  Something fatal happened.
            //

            break;
        }
    }

    return err;

}   // UI_DOMAIN :: GetInfo


/*******************************************************************

    NAME:       UI_DOMAIN :: QueryName

    SYNOPSIS:   Returns the name of the target domain.

    RETURNS:    const TCHAR *           - The target domain's name.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
const TCHAR * UI_DOMAIN :: QueryName( VOID ) const
{
    const TCHAR * pszName = NULL;

    if( _fBackupDCsOK && ( _pdomain == NULL ) )
    {
        pszName = _nlsDomainName;
    }
    else
    {
        pszName = _pdomain->QueryName();
    }

    return pszName;

}   // UI_DOMAIN :: QueryName


/*******************************************************************

    NAME:       UI_DOMAIN :: QueryPDC

    SYNOPSIS:   Returns the name of the target domain's PDC.  If
                the object was constructed with fBackupDCsOK, then
                this method may actually return the name of a BDC.

    RETURNS:    const TCHAR *           - The PDC (BDC??) in the domain.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
const TCHAR * UI_DOMAIN :: QueryPDC( VOID ) const
{
    const TCHAR * pszPDC = NULL;

    if( _fBackupDCsOK && ( _pdomain == NULL ) )
    {
        pszPDC = _nlsBackupDC;
    }
    else
    {
        pszPDC = _pdomain->QueryPDC();
    }

    return pszPDC;

}   // UI_DOMAIN :: QueryPDC


/*******************************************************************

    NAME:       UI_DOMAIN :: QueryAnyDC

    SYNOPSIS:   Returns the name of a DC in the target domain.

    RETURNS:    const TCHAR *           - The target domain's name.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
const TCHAR * UI_DOMAIN :: QueryAnyDC( VOID ) const
{
    const TCHAR * pszAnyDC = NULL;

    if( _fBackupDCsOK && ( _pdomain == NULL ) )
    {
        pszAnyDC = _nlsBackupDC;
    }
    else
    {
        pszAnyDC = _pdomain->QueryAnyDC();
    }

    return pszAnyDC;

}   // UI_DOMAIN :: QueryAnyDC



//
//  PROMPT_FOR_ANY_DC_DLG methods.
//


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: PROMPT_FOR_ANY_DC_DLG

    SYNOPSIS:   PROMPT_FOR_ANY_DC_DLG class constructor.

    ENTRY:      wndOwner                - The "owning" window.

                hc                      - Help context.

                pnlsDomainName          - Name of the target domain.

                pnlsKnownDC             - Will receive the DC name entered
                                          by the user.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
PROMPT_FOR_ANY_DC_DLG :: PROMPT_FOR_ANY_DC_DLG( PWND2HWND     & wndOwner,
                                                ULONG           hc,
                                                const NLS_STR * pnlsDomainName,
                                                NLS_STR       * pnlsKnownDC )
  : DIALOG_WINDOW( IDD_PROMPT_FOR_ANY_DC_DLG,
                   wndOwner ),
    _hc( hc ),
    _pnlsKnownDC( pnlsKnownDC ),
    _sltMessage( this, IDPDC_MESSAGE ),
    _sleKnownDC( this, IDPDC_SERVER, UI_MAX_COMPUTERNAME_LENGTH )
{
    UIASSERT( pnlsDomainName != NULL );
    UIASSERT( pnlsKnownDC != NULL );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Load the message string.
    //

    RESOURCE_STR nlsMessage( IDS_APPLIB_PROMPT_FOR_ANY_DC );

    APIERR err = nlsMessage.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Insert the domain name into the message string.
        //

        const NLS_STR * apnlsInsertParams[2];

        apnlsInsertParams[0] = pnlsDomainName;
        apnlsInsertParams[1] = NULL;

        err = nlsMessage.InsertParams( apnlsInsertParams );
    }

    if( err == NERR_Success )
    {
        _sltMessage.SetText( nlsMessage );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // PROMPT_FOR_ANY_DC_DLG :: PROMPT_FOR_ANY_DC_DLG


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: ~PROMPT_FOR_ANY_DC_DLG

    SYNOPSIS:   PROMPT_FOR_ANY_DC_DLG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
PROMPT_FOR_ANY_DC_DLG :: ~PROMPT_FOR_ANY_DC_DLG( VOID )
{
    _pnlsKnownDC = NULL;

}   // PROMPT_FOR_ANY_DC_DLG :: ~PROMPT_FOR_ANY_DC_DLG


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: OnOK

    SYNOPSIS:   Invoked when the user presses the OK button.

    RETURNS:    BOOL                    - TRUE  if we handled the message,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
BOOL PROMPT_FOR_ANY_DC_DLG :: OnOK( VOID )
{
    NLS_STR nlsServer;
    APIERR err = nlsServer.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Get the server from the edit field.
        //

        err = _sleKnownDC.QueryText( &nlsServer );
    }

    if( err == NERR_Success )
    {
        //
        //  Validate the server name.
        //

        if( ::I_MNetNameValidate( NULL,
                                  nlsServer,
                                  NAMETYPE_COMPUTER,
                                  0L ) != NERR_Success )
        {
            _sleKnownDC.SelectString();
            _sleKnownDC.ClaimFocus();

            err = IDS_APPLIB_PROMPT_DC_INVALID_SERVER;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Update the user's string.
        //

        err = _pnlsKnownDC->CopyFrom( SZ("\\\\") );

        if( err == NERR_Success )
        {
            err = _pnlsKnownDC->Append( nlsServer );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  All OK, dismiss the dialog.
        //

        Dismiss( TRUE );
    }
    else
    {
        //
        //  An error occurred somewhere along the way.
        //

        ::MsgPopup( this, err );
    }

    return TRUE;

}   // PROMPT_FOR_ANY_DC_DLG :: OnOK


/*******************************************************************

    NAME:       PROMPT_FOR_ANY_DC_DLG :: QueryHelpContext

    SYNOPSIS:   Returns the help context.

    RETURNS:    ULONG                   - The help context for this dialog.

    HISTORY:
        KeithMo     30-Aug-1992     Created.

********************************************************************/
ULONG PROMPT_FOR_ANY_DC_DLG :: QueryHelpContext( VOID )
{
    return _hc;

}   // PROMPT_FOR_ANY_DC_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\uix.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uix.cxx
    This file contains the class definitions for the classes related
    to NETUI Application Extension management.

    There are three categories of objects used to manipulate application
    extensions:

        Objects derived from UI_EXT represent the actual extensions.
        There is one such object for each extension loaded into the
        application.  All extension manipulation (activate, refresh,
        unload, etc) occur through these objects.

        Objects derived from UI_EXT_MGR represent extension managers.
        There is at most one extension manager "active" at any given
        time.  The extension manager is responsible for maintaining
        the list of extension objects and sending any "broadcast"
        notifications to each object.

        Objects derived from UI_EXT_MGR_IF represent extension manager
        interfaces.  These objects act as an interface between the
        extension manager and the application.  Whenever the extension
        manager needs to interact with the application (such as retrieving
        the list of available extensions) it is done through the interface
        object.

    The class hierarchy is structured as follows:

        BASE
        |
        +---UI_EXT
        |   |
        |   +---UI_BUTTON_EXT
        |   |
        |   +---UI_MENU_EXT
        |   |
        |   \---UI_TOOLBAR_EXT
        |
        +---UI_EXT_MGR
        |   |
        |   +---UI_BUTTON_EXT_MGR
        |   |
        |   +---UI_MENU_EXT_MGR
        |   |
        |   \---UI_TOOLBAR_EXT_MGR
        |
        \---UI_EXT_MGR_IF

    NOTE:   At the time this module was written (19-Oct-1992) only the
            MENU derivitives of UI_EXT and UI_EXT_MGR were implemented.
            The BUTTON and TOOLBAR class are shown in the above hierarchy
            for illustration purposes only.

    To integrate extension support into an application:

        0.  Subclass one of the UI_*_EXT classes (such as UI_MENU_EXT)
            to create an extension class for the particular application.
            For example, the Server Manager subclasses UI_MENU_EXT into
            SM_MENU_EXT.

            The class constructor is responsible for loading the DLL,
            validating the entrypoints, and negotiating the version
            number.

            The class destructor is responsible for sending any unload
            notifications to the extension.

            Override all of the pure virtuals in the parent class, such
            as Refresh() and Activate().

        1.  Subclass UI_EXT_MGR_IF to create an interface for the
            particular application.  For example, the NetUI Admin App
            "framework" subclasses UI_EXT_MGR_IF into AAPP_EXT_MGR_IF.

            Override all of the pure virtuals in the parent class.  For
            example, AAPP_EXT_MGR_IF "thunks" these virtuals over to
            corresponding ADMIN_APP virtuals.

        2.  At an appropriate time in the application, create a new
            *_EXT_MGR_IF object, then create a new UI_*_EXT_MGR object,
            giving it the address of the interface object.  The two are
            now bound together.

        3.  Invoke UI_*_EXT_MGR::LoadExtensions().  The extensions will
            be loaded.

        4.  At an appropriate time in the application, invoke the
            UI_*_EXT_MGR::ActivateExtension() method.  For example,
            ADMIN_APP does this in OnMenuCommand() if the menu ID is
            greater than some specific value (the initial ID delta).


    FILE HISTORY:
        KeithMo     19-Oct-1992     Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  UI_EXT methods.
//

/*******************************************************************

    NAME:       UI_EXT :: UI_EXT

    SYNOPSIS:   UI_EXT class constructor.

    ENTRY:      pszDllName              - Name of this extension's DLL.

                dwDelta                 - The menu/control ID delta
                                          for this extension.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT :: UI_EXT( const TCHAR * pszDllName,
                  DWORD         dwDelta )
  : BASE(),
    _dwVersion( 0 ),
    _nlsDllName( pszDllName ),
    _hDll( NULL ),
    _dwDelta( dwDelta )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT failed to construct" );
        return;
    }

    if( !_nlsDllName )
    {
        ReportError( _nlsDllName.QueryError() );
        return;
    }

}   // UI_EXT :: UI_EXT


/*******************************************************************

    NAME:       UI_EXT :: ~UI_EXT

    SYNOPSIS:   UI_EXT class destructor.

    EXIT:       The object is destroyed.  The DLL will be freed if
                it was actually loaded.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT :: ~UI_EXT( VOID )
{
    if( _hDll != NULL )
    {
        if( !::FreeLibrary( _hDll ) )
        {
            APIERR err = (APIERR)::GetLastError();

            DBGEOL( "UI_EXT::~UI_EXT - FreeLibrary returned " << err );
        }

        _hDll = NULL;
    }

}   // UI_EXT :: ~UI_EXT



//
//  UI_MENU_EXT methods.
//

/*******************************************************************

    NAME:       UI_MENU_EXT :: UI_MENU_EXT

    SYNOPSIS:   UI_MENU_EXT class constructor.

    ENTRY:      pszDllName              - Name of this extension's DLL.

                dwDelta                 - The menu/control ID delta
                                          for this extension.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT :: UI_MENU_EXT( const TCHAR * pszDllName,
                            DWORD         dwDelta )
  : UI_EXT( pszDllName, dwDelta ),
    _nlsMenuName(),
    _hMenu( NULL )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_MENU_EXT failed to construct" );
        return;
    }

    if( !_nlsMenuName )
    {
        ReportError( _nlsMenuName.QueryError() );
        return;
    }

}   // UI_MENU_EXT :: UI_MENU_EXT


/*******************************************************************

    NAME:       UI_MENU_EXT :: ~UI_MENU_EXT

    SYNOPSIS:   UI_MENU_EXT class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT :: ~UI_MENU_EXT( VOID )
{
    _hMenu = NULL;

}   // UI_MENU_EXT :: ~UI_MENU_EXT


/*******************************************************************

    NAME:       UI_MENU_EXT :: BiasMenuIds

    SYNOPSIS:   Applies a bias (delta) to each ID in a menu.

    ENTRY:      dwDelta                 - The delta to be applied to
                                          each ID.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method calls through to W_BiasMenuIds to do
                all of the (recursive) dirty work.

    HISTORY:
        KeithMo     20-Oct-1992     Created.

********************************************************************/
APIERR UI_MENU_EXT :: BiasMenuIds( DWORD  dwDelta )
{
    //
    //  Let W_BiasMenuIds handle the dirty work.
    //

    APIERR err = W_BiasMenuIds( QueryMenuHandle(), dwDelta );

    if( err != NERR_Success )
    {
        DBGEOL( "UI_MENU_EXT::BiasMenuIds - error " << err );
    }

    return err;

}   // UI_MENU_EXT :: BiasMenuIds


/*******************************************************************

    NAME:       UI_MENU_EXT :: W_BiasMenuIds

    SYNOPSIS:   Private worker method for BiasMenuIds.

    ENTRY:      hMenu                   - The menu to adjust.

                dwDelta                 - The delta to be applied to
                                          each ID.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Oct-1992     Created.

********************************************************************/
APIERR UI_MENU_EXT :: W_BiasMenuIds( HMENU  hMenu,
                                     DWORD  dwDelta )
{
    //
    //  menu represents our target menu.
    //
    //  nlsText will contain the display text of
    //  menus that are modified.
    //

    POPUP_MENU menu( hMenu );
    NLS_STR    nlsText;

    //
    //  Ensure everything constructed properly.
    //

    APIERR err = menu.QueryError();

    if( err == NERR_Success )
    {
        err = nlsText.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Get the number of items in the menu.
        //

        INT cItems = menu.QueryItemCount();

        for( INT pos = 0 ; pos < cItems ; pos++ )
        {
            //
            //  See if the current item is a popup.  Only popups
            //  will return a non-NULL value from QuerySubMenu().
            //

            HMENU hSubMenu = menu.QuerySubMenu( pos );

            if( hSubMenu != NULL )
            {
                err = W_BiasMenuIds( hSubMenu, dwDelta );

                if( err != NERR_Success )
                {
                    break;
                }

                continue;
            }

            //
            //  Get the mid for the current item.
            //

            UINT mid = menu.QueryItemID( pos );

            //
            //  Abnormal items (such as menubarbreaks and separators)
            //  return 0xFFFFFFFF or 0 as their mid.  Ignore these.
            //

            if( ( mid == (UINT)-1L ) || ( mid == 0 ) )
            {
                continue;
            }

            //
            //  OK, so we now know we have found a "normal" item.
            //  Let's see if we can get the item's text.
            //

            err = menu.QueryItemText( &nlsText,
                                      pos,
                                      MF_BYPOSITION );

            if( err == NERR_Success )
            {
                //
                //  Cool.  Now adjust the mid by adding the
                //  user-supplied delta.
                //

                err = menu.Modify( nlsText,
                                   pos,
                                   mid + (UINT)dwDelta,
                                   MF_BYPOSITION );
            }

            if( err != NERR_Success )
            {
                //
                //  Something failed along the way, so abort
                //  the loop.
                //

                break;
            }
        }
    }

    return err;

}   // UI_MENU_EXT :: W_BiasMenuIds



//
//  UI_EXT_MGR methods.
//

/*******************************************************************

    NAME:       UI_EXT_MGR :: UI_EXT_MGR

    SYNOPSIS:   UI_EXT_MGR class constructor.

    ENTRY:      pExtMgrIf               - Points to an object representing
                                          the interface between the
                                          extension manager & the application.

                dwInitialDelta          - The initial menu/control ID delta.

                dwDeltaDelta            - The "inter-delta offset".

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR :: UI_EXT_MGR( UI_EXT_MGR_IF * pExtMgrIf,
                          DWORD           dwInitialDelta,
                          DWORD           dwDeltaDelta )
  : BASE(),
    _pExtMgrIf( pExtMgrIf ),
    _dwDelta( dwInitialDelta ),
    _dwDeltaDelta( dwDeltaDelta ),
    _slExtensions( FALSE )
{
    UIASSERT( pExtMgrIf != NULL );
    UIASSERT( pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT_MGR failed to construct" );
        return;
    }

}   // UI_EXT_MGR :: UI_EXT_MGR


/*******************************************************************

    NAME:       UI_EXT_MGR :: ~UI_EXT_MGR

    SYNOPSIS:   UI_EXT_MGR class destructor.

    EXIT:       The object is destroyed.  All extensions are unloaded.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR :: ~UI_EXT_MGR( VOID )
{
    UnloadExtensions();
    _pExtMgrIf = NULL;

}   // UI_EXT_MGR :: ~UI_EXT_MGR


/*******************************************************************

    NAME:       UI_EXT_MGR :: FindExtensionByName

    SYNOPSIS:   Locate an extension given its DLL name.

    ENTRY:      pszDllName              - The name of the extension's DLL.

    RETURNS:    UI_EXT *                - The extension, NULL if not found.

    HISTORY:
        KeithMo     26-Oct-1992     Created.

********************************************************************/
UI_EXT * UI_EXT_MGR :: FindExtensionByName( const TCHAR * pszDllName )
{
    UIASSERT( pszDllName != NULL );
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the extension objects, looking for a match.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        const TCHAR * pszTmp = pExt->QueryDllName();

        if( ( pszTmp != NULL ) && ( ::stricmpf( pszTmp, pszDllName ) == 0 ) )
        {
            break;
        }
    }

    return pExt;

}   // UI_EXT_MGR :: FindExtensionByName


/*******************************************************************

    NAME:       UI_EXT_MGR :: FindExtensionByDelta

    SYNOPSIS:   Locate an extension given its menu/control ID delta.

    ENTRY:      dwDelta                 - The search delta.

    RETURNS:    UI_EXT *                - The extension, NULL if not found.

    HISTORY:
        KeithMo     26-Oct-1992     Created.

********************************************************************/
UI_EXT * UI_EXT_MGR :: FindExtensionByDelta( DWORD dwDelta )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the extension objects, looking for a match.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        DWORD dwTmp = pExt->QueryDelta();

        if( ( dwDelta >= dwTmp ) && ( dwDelta < ( dwTmp + QueryDeltaDelta() ) ) )
            break;
    }

    return pExt;

}   // UI_EXT_MGR :: FindExtensionByDelta


/*******************************************************************

    NAME:       UI_EXT_MGR :: W_LoadExtension

    SYNOPSIS:   Worker method to load a UI_EXT.  Typically just thunks
                through the interface object to let the application do
                the dirty work.

    ENTRY:      pszExtensionDll         - The name of the DLL containing
                                          the app extension.

                dwDelta                 - A menu/control ID delta for the
                                          extension's menus/controls.

    RETURNS:    UI_EXT *                - The newly loaded extension.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT * UI_EXT_MGR :: W_LoadExtension( const TCHAR * pszExtensionDll,
                                        DWORD         dwDelta )
{
    UIASSERT( pszExtensionDll != NULL );
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Let the app (via the interface object) do the dirty work.
    //

    UI_EXT * pExt = _pExtMgrIf->LoadExtension( pszExtensionDll,
                                               dwDelta );

#ifdef DEBUG
    if( pExt == NULL )
    {
        DBGEOL( "UI_EXT_MGR::W_LoadExtension - _pExtMgrIf returned NULL" );
    }
    else
    if( pExt->QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT_MGR::W_LoadExtension - pExt returned "
                << pExt->QueryError() );
    }
#endif  // DEBUG

    return pExt;

}   // UI_EXT_MGR :: W_LoadExtension


/*******************************************************************

    NAME:       UI_EXT_MGR :: LoadExtensions

    SYNOPSIS:   This method loads all extensions available to the
                application.

    RETURNS:    UINT                    - The number of extensions
                                          successfully loaded.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UINT UI_EXT_MGR :: LoadExtensions( VOID )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Get the list of available extension DLLs.
    //

    STRLIST * psl = _pExtMgrIf->GetExtensionList();

    if( psl == NULL )
    {
        DBGEOL( "UI_EXT_MGR::LoadExtensions - _pExtMgrIf returned NULL list" );
        return 0;
    }

    //
    //  Now scan the extension DLL list, calling W_LoadExtension
    //  on each.
    //

    ITER_STRLIST itersl( *psl );
    NLS_STR * pnls;
    UINT cExtensions = 0;

    while( ( pnls = itersl.Next() ) != NULL )
    {
        //
        //  Try to load the extension.
        //

        UI_EXT * pExt = W_LoadExtension( pnls->QueryPch(),
                                         _dwDelta );

        //
        //  Update the next delta.
        //

        _dwDelta += _dwDeltaDelta;

        if( ( pExt != NULL ) && ( pExt->QueryError() == NERR_Success ) )
        {
            if( _slExtensions.Append( pExt ) == NERR_Success )
            {
                cExtensions++;
            }
        }
    }

    //
    //  Delete the STRLIST before returning.
    //

    delete psl;
    psl = NULL;

    return cExtensions;

}   // UI_EXT_MGR :: LoadExtensions


/*******************************************************************

    NAME:       UI_EXT_MGR :: UnloadExtensions

    SYNOPSIS:   This method unloads all loaded extensions.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_EXT_MGR :: UnloadExtensions( VOID )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the & delete the extension objects.  This
    //  will force the actual extensions to get unloaded.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        delete pExt;
    }

}   // UI_EXT_MGR :: UnloadExtensions


/*******************************************************************

    NAME:       UI_EXT_MGR :: RefreshExtensions

    SYNOPSIS:   This method refreshes all loaded extensions.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_EXT_MGR :: RefreshExtensions( HWND hwndParent )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate & refresh the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        pExt->Refresh( hwndParent );
    }

}   // UI_EXT_MGR :: RefreshExtensions


/*******************************************************************

    NAME:       UI_EXT_MGR :: ActivateExtension

    SYNOPSIS:   This method activates the extension with the given
                menu/control ID.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_EXT_MGR :: ActivateExtension( HWND hwndParent, DWORD dwId )
{
    UIASSERT( _pExtMgrIf != NULL );
    UIASSERT( _pExtMgrIf->QueryError() == NERR_Success );

    //
    //  Enumerate the extension objects, looking for an ID match.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        DWORD dwDelta = pExt->QueryDelta();

        if( ( dwDelta <= dwId ) &&
            ( ( dwDelta + QueryDeltaDelta() ) > dwId ) )
        {
            _pExtMgrIf->ActivateExtension( hwndParent, pExt, dwId - dwDelta );
            break;
        }
    }

}   // UI_EXT_MGR :: ActivateExtension



//
//  UI_MENU_EXT_MGR methods.
//

/*******************************************************************

    NAME:       UI_MENU_EXT_MGR :: UI_MENU_EXT_MGR

    SYNOPSIS:   UI_MENU_EXT_MGR class constructor.

    ENTRY:      pExtMgrIf               - Points to an object representing
                                          the interface between the
                                          extension manager & the application.

                dwInitialDelta          - The initial menu/control ID delta.

                dwDeltaDelta            - The "inter-delta offset".

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT_MGR :: UI_MENU_EXT_MGR( UI_EXT_MGR_IF * pExtMgrIf,
                                    DWORD           dwInitialDelta,
                                    DWORD           dwDeltaDelta )
  : UI_EXT_MGR( pExtMgrIf, dwInitialDelta, dwDeltaDelta )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_MENU_EXT_MGR failed to construct" );
        return;
    }

}   // UI_MENU_EXT_MGR :: UI_MENU_EXT_MGR


/*******************************************************************

    NAME:       UI_MENU_EXT_MGR :: ~UI_MENU_EXT_MGR

    SYNOPSIS:   UI_MENU_EXT_MGR class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_MENU_EXT_MGR :: ~UI_MENU_EXT_MGR( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // UI_MENU_EXT_MGR :: ~UI_MENU_EXT_MGR


/*******************************************************************

    NAME:       UI_MENU_EXT_MGR :: MenuInitExtensions

    SYNOPSIS:   This method sends a menu init notification to all
                loaded extensions.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID UI_MENU_EXT_MGR :: MenuInitExtensions( VOID )
{
    //
    //  Enumerate & menu init the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_MENU_EXT * pExt;

    while( ( pExt = (UI_MENU_EXT *)iter.Next() ) != NULL )
    {
        pExt->MenuInit();
    }

}   // UI_MENU_EXT_MGR :: MenuInitExtensions



//
//  UI_EXT_MGR_IF methods.
//

/*******************************************************************

    NAME:       UI_EXT_MGR_IF :: UI_EXT_MGR_IF

    SYNOPSIS:   UI_EXT_MGR_IF class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR_IF :: UI_EXT_MGR_IF( VOID )
  : BASE()
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UI_EXT_MGR_IF failed to construct" );
        return;
    }

}   // UI_EXT_MGR_IF :: UI_EXT_MGR_IF


/*******************************************************************

    NAME:       UI_EXT_MGR_IF :: ~UI_EXT_MGR_IF

    SYNOPSIS:   UI_EXT_MGR_IF class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
UI_EXT_MGR_IF :: ~UI_EXT_MGR_IF( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // UI_EXT_MGR_IF :: ~UI_EXT_MGR_IF



DEFINE_SLIST_OF( UI_EXT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\usrcache.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    usrcache.cxx

    This file contains the class definitions for the abstract
    USER_LBI_CACHE class.  This class implements a cache of LBIs
    used when dealing with very large user databases.  This class's
    primary purpose is to be the "backing store" for a LAZY_LISTBOX.
    As such, its interface is very similar to the BLT_LISTBOX
    interface.


    FILE HISTORY:
        KeithMo     15-Dec-1992     Created.
*/

#include "pchapplb.hxx"   // Precompiled header

//
//  This is the maximum number of bytes we'll make for
//  any given API invocation.
//

#define MAX_BYTES_PER_REQUEST   0x0001FFFFL


//
// The following defines are used in the slow mode timing heuristics in
// ReadUsers.  A timer determines how long it takes
// to read in each batch of user accounts.  If this time is less
// that READ_MORE_MSEC, we double the number of bytes requested on the
// next call.  If it is more than READ_LESS_MSEC, we halve it.
//

#define USERS_INITIAL_COUNT    0x00200 /*  512 */
#define USERS_MIN_COUNT        0x00020 /*   32 */
#define USERS_MAX_COUNT        0x01000 /* 4K   */

#define BYTES_INITIAL_COUNT    0x03FFF /*  16K */
#define BYTES_MIN_COUNT        0x003FF /*   1K */
#define BYTES_MAX_COUNT        0x1FFFF /* 128K */

#define READ_MORE_MSEC         1000
#define READ_LESS_MSEC         5000

//
//  min/max macros.
//

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif


//
//  ULC_API_BUFFER methods.
//

/*******************************************************************

    NAME:       ULC_API_BUFFER :: ULC_API_BUFFER

    SYNOPSIS:   ULC_API_BUFFER class constructor.

    ENTRY:      pddu                    - The API buffer returned from
                                          SamQueryDisplayInformation.

                cItems                  - Number of items in the buffer.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
ULC_API_BUFFER :: ULC_API_BUFFER( DOMAIN_DISPLAY_USER * pddu,
                                  ULONG                 cItems )
  : _pddu( pddu ),
    _cItems( cItems )
{
    UIASSERT( cItems > 0 );
    UIASSERT( pddu != NULL );

    //
    //  This space intentionally left blank.
    //

}   // ULC_API_BUFFER :: ULC_API_BUFFER

/*******************************************************************

    NAME:       ULC_API_BUFFER :: ~ULC_API_BUFFER

    SYNOPSIS:   ULC_API_BUFFER class destructor.

    EXIT:       The object has been destroyed.  The SAM buffer
                associated with this object has been freed.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
ULC_API_BUFFER :: ~ULC_API_BUFFER( VOID )
{
    //
    //  Free the associated SAM buffer.
    //

    if( _pddu != NULL )
    {
        ::SamFreeMemory( (PVOID)_pddu );
    }

    _pddu   = NULL;
    _cItems = 0;

}   // ULC_API_BUFFER :: ~ULC_API_BUFFER

DEFINE_SLIST_OF( ULC_API_BUFFER );



//
//  USER_LBI_CACHE methods.
//

/*******************************************************************

    NAME:       USER_LBI_CACHE :: USER_LBI_CACHE

    SYNOPSIS:   USER_LBI_CACHE class constructor.

    ENTRY:      padminauth              - Points to an ADMIN_AUTHORITY
                                          that represents the target
                                          machine.  This should be NULL
                                          for downlevel machines.

                nInitialGrowthSpace     - Percentage of initial "slop"
                                          entries in the cache.  Used to
                                          plan for future cache growth.

                cUsersPerRequest        - The number of users to request
                                          per SAM API invocation.

                fIncludeRemoteUsers     - If TRUE, then remote users will
                                          be included in the cache.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
USER_LBI_CACHE :: USER_LBI_CACHE( INT cbExtraBytes )
  : BASE(),
    _pCache( NULL ),
    _slBuffers(),
    _cSlots( 0 ),
    _cEntries( 0 ),
    _cbExtraBytes( cbExtraBytes )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    // Round _cbExtraBytes up to the nearest multiple of sizeof(DWORD)
    //
    // JonN 10/16/00 IA64: should be sizeof(PVOID)
    //

    if ( (_cbExtraBytes % sizeof(PVOID)) != 0 )
    {
        _cbExtraBytes += sizeof(PVOID) - ( _cbExtraBytes % sizeof(PVOID) );

        TRACEEOL(   "USER_LBI_CACHE::USER_LBI_CACHE: rounded _cbExtraBytes to "
                 << _cbExtraBytes );
    }

}   // USER_LBI_CACHE :: USER_LBI_CACHE

/*******************************************************************

    NAME:       USER_LBI_CACHE :: ~USER_LBI_CACHE

    SYNOPSIS:   USER_LBI_CACHE class destructor.

    EXIT:       The object has been destroyed.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
USER_LBI_CACHE :: ~USER_LBI_CACHE( VOID )
{
    //
    //  Safety first!
    //

    LockCache();

    //
    //  Destroy any LBIs in the cache.
    //

    if( _cSlots > 0 )
    {
        //
        //  _cSlots should only be > 0 if there was *ever*
        //  anything in the cache.  Ergo, _pCache *must*
        //  be non-NULL.
        //

        UIASSERT( _pCache != NULL );

        //
        //  Scan the cache, deleting the LBIs.
        //

        while( _cSlots > 0 )
        {
            ULC_ENTRY * pTmp = QueryULCEntryPtr( _cSlots-1 );
            delete pTmp->plbi;
            pTmp->plbi = NULL;
            _cSlots--;
        }
    }

    //
    //  Delete the cache itself.
    //

    delete _pCache;
    _pCache   = NULL;
    _cEntries = 0;

    //
    //  _slBuffers' destructor will take care of
    //  freeing the associated SAM buffers.
    //

    UnlockCache();

}   // USER_LBI_CACHE :: ~USER_LBI_CACHE

/*******************************************************************

    NAME:       USER_LBI_CACHE :: AddItem

    SYNOPSIS:   Add a new LBI to the cache.  A binary search of the
                cache will be performed to determine the appropriate
                location for the new LBI.

    ENTRY:      plbi                    - The new LBI to add to the
                                          cache.

    EXIT:       If successful, then the new LBI has been added to
                the cache in sorted order.

    RETURNS:    INT                     - ULC_ERR if an error occurred
                                          while adding the item.
                                          Otherwise, returns the index
                                          for the new item.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
INT USER_LBI_CACHE :: AddItem( LBI * plbi )
{
    //
    //  Refuse to add badly constructed LBIs to the cache.
    //

    if( plbi == NULL )
    {
        return ULC_ERR;
    }

    if( plbi->QueryError() != NERR_Success )
    {
        delete plbi;
        return ULC_ERR;
    }

    //
    //  Lock the cache before proceeding.
    //

    LockCache();

    //
    //  If we need to grow the cache array, do it now as this
    //  is the only operation we'll do that may actually fail.
    //

    if( _cEntries == _cSlots )
    {
        if( !W_GrowCache( _cSlots + ULC_CACHE_GROWTH_DELTA ) )
        {
            //
            //  Bad news, we failed to grow the cache.
            //  Delete the item since we failed to add it
            //  to the cache.
            //

            delete plbi;
            UnlockCache();

            return ULC_ERR;
        }
    }

    //
    //  Now that we've got some breathing room, find the
    //  proper location for the new LBI.
    //

    INT iNew = BinarySearch( plbi );
    UIASSERT( iNew >= 0 );

    //
    //  Make a hole in the cache to stick the new LBI.
    //

    ULC_ENTRY * pTmp = QueryULCEntryPtr( iNew );

    if( iNew < _cEntries )
    {
        ::memmove( (void *)QueryULCEntryPtr( iNew + 1 ),
                   pTmp,
                   ( _cEntries - iNew ) * QueryULCEntrySize() );
    }

    _cEntries++;

    //
    //  Initialize the newly formed cache entry.
    //

    pTmp->plbi = plbi;
    pTmp->pddu = NULL;
    if ( _cbExtraBytes > 0 )
    {
        ::memset( (void *)&(pTmp->bExtraBytes),
                   0,
                   _cbExtraBytes );
    }

    //
    //  Unlock the cache before returning.
    //

    UnlockCache();

    return iNew;

}   // USER_LBI_CACHE :: AddItem

/*******************************************************************

    NAME:       USER_LBI_CACHE :: RemoveItem

    SYNOPSIS:   Removes an item from the cache, but does not delete
                the corresponding LBI.

    ENTRY:      i                       - Zero-based index of the
                                          item to remove.

    EXIT:       If successful, then the LBI has been removed from
                the cache.

    RETURNS:    LBI *                   - Points to the LBI removed
                                          from the cache.  Will be
                                          NULL if an error occurred.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
LBI * USER_LBI_CACHE :: RemoveItem( INT i )
{
    //
    //  Safety first!
    //

    LockCache();

    //
    //  Only access the cache if the index is within range.
    //

    if( ( i < 0 ) || ( i >= _cEntries ) )
    {
        //
        //  Requested item is out of range.
        //

        UnlockCache();

        return NULL;
    }

    //
    //  Retrieve the LBI.  This may cause the creation of
    //  a new LBI.
    //

    LBI * plbi = W_GetLBI( i );

    //
    //  Now remove the LBI from the cache, adjusting the
    //  cache entries as necessary.
    //

    _cEntries--;

    if( ( _cEntries > 0 ) && ( i < _cEntries ) )
    {
        ::memmove( (void *)QueryULCEntryPtr( i ),
                   (void *)QueryULCEntryPtr( i + 1 ),
                   ( _cEntries - i ) * QueryULCEntrySize() );
    }

    //
    //  Clear the unused entry.
    //

    QueryULCEntryPtr( _cEntries )->pddu = NULL;
    QueryULCEntryPtr( _cEntries )->plbi = NULL;

    //
    //  Unlock the cache before returning.
    //

    UnlockCache();

    return plbi;

}   // USER_LBI_CACHE :: RemoveItem

/*******************************************************************

    NAME:       USER_LBI_CACHE :: QueryItem

    SYNOPSIS:   Query the LBI at the specified index.

    ENTRY:      i                       - Zero-based index of the
                                          item to query.

    EXIT:       If successful, then the specified cache entry will
                contain a valid LBI.  This may be a newly created
                LBI retrieved by calling the CreateLBI virtual.

    RETURNS:    LBI *                   - Points to the LBI found at
                                          the specified location.  Will
                                          be NULL if an error occurred.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
LBI * USER_LBI_CACHE :: QueryItem( INT i )
{
    //
    //  Safety first!
    //

    LockCache();

    //
    //  Retrieve the LBI.  This may cause the creation of
    //  a new LBI.
    //

    LBI * plbi = W_GetLBI( i );

    UnlockCache();

    return plbi;

}   // USER_LBI_CACHE :: QueryItem

/*******************************************************************

    NAME:       USER_LBI_CACHE :: IsItemAvailable

    SYNOPSIS:   Determine if the necessary data is available for
                a specific item.

    ENTRY:      i                       - Zero-based index of the
                                          item to query.

    RETURNS:    BOOL                    - TRUE if the necessary data
                                          for the item is available,
                                          FALSE otherwise.  Note that
                                          TRUE does *not* necessarily
                                          mean that an associated LBI
                                          has been created.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
BOOL USER_LBI_CACHE :: IsItemAvailable( INT i )
{
    //
    //  Safety first!
    //

    LockCache();

    BOOL fResult = FALSE;

    //
    //  Only access the cache if the index is within range.
    //

    if( ( i >= 0 ) && ( i < _cEntries ) )
    {
        //
        //  Find the cache entry.
        //

        ULC_ENTRY * pTmp = QueryULCEntryPtr( i );

        if( ( pTmp->plbi != NULL ) || ( pTmp->pddu != NULL ) )
        {
            fResult = TRUE;
        }
    }

    UnlockCache();

    return fResult;

}   // USER_LBI_CACHE :: IsItemAvailable

/*******************************************************************

    NAME:       USER_LBI_CACHE :: Sort

    SYNOPSIS:   Sorts the cache entries.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
VOID USER_LBI_CACHE :: Sort( VOID )
{

TRACETIMESTART;

    //
    //  Safety first!
    //

    LockCache();

    //
    //  We only need to sort if there's something in the cache.
    //

    if( _cEntries > 0 )
    {
        UIASSERT( _pCache != NULL );

        //
        //  Retrieve the appropriate compare method.
        //

        PQSORT_COMPARE pfnCmp = QueryCompareMethod();
        UIASSERT( pfnCmp != NULL );

        //
        //  Before using qsort to sort the cache, check if it is already
        //  sorted.
        //

TRACETIMESTART2( presort );
        BOOL fSorted = TRUE;
        for (INT i = 1; i < _cEntries; i++)
        {
            if ( (pfnCmp)(QueryULCEntryPtr(i-1), QueryULCEntryPtr(i)) > 0 )
            {
                fSorted = FALSE;
#if defined(DEBUG) && defined(TRACE)
                TRACEOUT(   "    failed comparison " << i-1 << " : compare( \"" );
                {
                    INT cch = QueryULCEntryPtr(i-1)->pddu->LogonName.Length / sizeof(WCHAR);
                    const WCHAR * pch = QueryULCEntryPtr(i-1)->pddu->LogonName.Buffer;
                    INT iChar = 0;
                    while (iChar < cch) { cdebug << pch[iChar++]; }
                    TRACEOUT( "\", \"" );
                    cch = QueryULCEntryPtr(i)->pddu->LogonName.Length / sizeof(WCHAR);
                    pch = QueryULCEntryPtr(i)->pddu->LogonName.Buffer;
                    iChar = 0;
                    while (iChar < cch) { cdebug << pch[iChar++]; }
                }
                TRACEEOL( "\" ) > 0" );
#endif
                break;
            }
        }
TRACETIMEEND2( presort, "USER_LBI_CACHE::Sort: presort " << ( (fSorted) ? "confirmed" : "denied" ) << " in " );


        //
        //  Sort the cache if it needs to be sorted.
        //

        if ( !fSorted )
        {
TRACETIMESTART2( sort );
            ::qsort( (void *)_pCache,
                     (size_t)_cEntries,
                     QueryULCEntrySize(),
                     pfnCmp );
TRACETIMEEND2( sort, "USER_LBI_CACHE::Sort: sort took " );
        }
    }

    UnlockCache();

TRACETIMEEND( "USER_LBI_CACHE::Sort: total time " );

}   // USER_LBI_CACHE :: Sort

/*******************************************************************

    NAME:       USER_LBI_CACHE :: QueryCompareMethod

    SYNOPSIS:   Returns a pointer to a compare method suitable for
                use by the qsort() function.

    RETURNS:    PQSORT_COMPARE          - Points to a compare function
                                          usable by qsort().

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
PQSORT_COMPARE USER_LBI_CACHE :: QueryCompareMethod( VOID ) const
{
    //
    //  CompareLogonNames is the default compare method.
    //

    return (PQSORT_COMPARE)&USER_LBI_CACHE::CompareLogonNames;

}   // USER_LBI_CACHE :: QueryCompareMethod

/*******************************************************************

    NAME:       USER_LBI_CACHE :: LockCache

    SYNOPSIS:   Locks the cache.  This is basically just a hook
                so a subclass can provide multithread safety.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
VOID USER_LBI_CACHE :: LockCache( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // USER_LBI_CACHE :: LockCache

/*******************************************************************

    NAME:       USER_LBI_CACHE :: UnlockCache

    SYNOPSIS:   Unlocks the cache.  This is basically just a hook
                so a subclass can provide multithread safety.

    NOTES:      This is a virtual method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
VOID USER_LBI_CACHE :: UnlockCache( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // USER_LBI_CACHE :: UnlockCache

/*******************************************************************

    NAME:       USER_LBI_CACHE :: CmpUniStrs

    SYNOPSIS:   Does a case insensitive comparison of two
                UNICODE_STRINGs.

    ENTRY:      punicode0               - The "left" string.

                punicode1               - The "right" string.

    RETURNS:    int                     - 0, <0, >0.

    NOTES:      This is a static method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
int USER_LBI_CACHE :: CmpUniStrs( const UNICODE_STRING * punicode0,
                                  const UNICODE_STRING * punicode1 )
{
    UIASSERT( punicode0 != NULL );
    UIASSERT( punicode1 != NULL );

    //
    //  Get the buffer pointers from the UNICODE_STRINGs.
    //

    const WCHAR * pwchLeft  = punicode0->Buffer;
    const WCHAR * pwchRight = punicode1->Buffer;

    //
    //  If either buffer pointer is NULL then we don't
    //  need to do the actual comparison.
    //

    if( pwchLeft == NULL )
    {
        return ( pwchRight == NULL ) ? 0        // both strings NULL
                                     : -1;      // right string !NULL
    }

    if( pwchRight == NULL )
    {
        return 1;                               // left string !NULL
    }

    //
    //  Get the string lengths from the UNICODE_STRINGs.
    //

    UINT cchLeft  = punicode0->Length / sizeof(WCHAR);
    UINT cchRight = punicode1->Length / sizeof(WCHAR);

    //
    //  Compare the strings.
    //

    int cmpres = NETUI_strnicmp2( pwchLeft, cchLeft,
                                  pwchRight, cchRight );

    return cmpres;

}   // USER_LBI_CACHE :: CmpUniStrs

/*******************************************************************

    NAME:       USER_LBI_CACHE :: CompareLogonNames

    SYNOPSIS:   Compares the LogonName fields of two
                DOMAIN_DISPLAY_USER structures.

    ENTRY:      p0                      - Points to the "left" structure.

                p1                      - Points to the "right" structure.

                p0 & p1 actually point to ULC_ENTRY structures.

    RETURNS:    int                     -  0 if *p0 == *p1
                                          >0 if *p0  > *p1
                                          <0 if *p0  < *p1

    NOTES:      This is a static method.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
int __cdecl USER_LBI_CACHE :: CompareLogonNames( const void * p0,
                                                  const void * p1 )
{
    const ULC_ENTRY * pLeft  = (const ULC_ENTRY *)p0;
    const ULC_ENTRY * pRight = (const ULC_ENTRY *)p1;

    return USER_LBI_CACHE::CmpUniStrs( &pLeft->pddu->LogonName,
                                       &pRight->pddu->LogonName );

}   // USER_LBI_CACHE :: CompareLogonNames

/*******************************************************************

    NAME:       USER_LBI_CACHE :: ReadUsers

    SYNOPSIS:   Reads user data from SamQueryDisplayInformation,
                adds it to a list of API buffers, creates cache entries
                for the new items and appends the entries to the end
                of the cache.

    ENTRY:      padminauth              - Points to an ADMIN_AUTHORITY
                                          that represents the target
                                          machine.

                nInitialGrowthSpace     - Percentage of initial "slop"
                                          entries in the cache.  Used to
                                          plan for future cache growth.

                cUsersPerRequest        - The number of users to request
                                          per SAM API invocation.  0 for
                                          default.

                fIncludeRemoteUsers     - If TRUE, then remote users will
                                          be included in the cache.

    RETURNS:    APIERR                  - Any errors that occurred.

    NOTES:      The caller can specify the number of users requested
                per call, but ReadUsers set the number of bytes requested
                using an adaptive algorithm.  This should help improve
                responsiveness across a slow link.

    HISTORY:
        KeithMo     15-Dec-1992     Created.
        JonN        23-Mar-1993     Adaptive timing for slow connections

********************************************************************/
APIERR USER_LBI_CACHE :: ReadUsers( ADMIN_AUTHORITY * padminauth,
                                    UINT              nInitialGrowthSpace,
                                    UINT              cUsersPerRequest,
                                    BOOL              fIncludeRemoteUsers,
                                    BOOL *            pfQuitEnum )
{
    UIASSERT( padminauth != NULL );
    UIASSERT( padminauth->QueryError() == NERR_Success );
    UIASSERT( _slBuffers.QueryNumElem() == 0 );

    if ( pfQuitEnum != NULL && *pfQuitEnum )
        return NERR_Success;

    //
    //  Retrieve the domain handle.
    //

    SAM_HANDLE hSamDomain = padminauth->QueryAccountDomain()->QueryHandle();
    UIASSERT( hSamDomain != NULL );

    //
    //  The current user index.
    //

    ULONG iUser = 0;

    //
    //  We'll only add a given user to the cache if the
    //  boolean AND of the user's AccountControl field and
    //  this mask produces a zero result.
    //

    ULONG maskSelect = fIncludeRemoteUsers ? 0L
                                           : USER_TEMP_DUPLICATE_ACCOUNT;

    APIERR err = NERR_Success;

#if defined(DEBUG) && defined(TRACE)

    DWORD APItime   = 0L;
    DWORD totaltime = 0L;

    DWORD start = ::GetTickCount();
    TRACEEOL(   "USER_LBI_CACHE::ReadUsers: starting read" );

#endif

    ULONG cbBytesRequested = BYTES_INITIAL_COUNT;
    if (cUsersPerRequest == 0)
        cUsersPerRequest = USERS_INITIAL_COUNT;

    for( ; ; )
    {
        ULONG cbTotalAvailable;
        ULONG cbTotalReturned;
        ULONG cEntriesRead;
        DOMAIN_DISPLAY_USER * pddu = NULL;
        DOMAIN_DISPLAY_USER * pdduOrig = NULL;

        //
        //  Get the next chunk of API data.
        //

        DWORD APIstart = ::GetTickCount();

        NTSTATUS status = ::SamQueryDisplayInformation( hSamDomain,
                                                        DomainDisplayUser,
                                                        iUser,
                                                        cUsersPerRequest,
                                                        cbBytesRequested,
                                                        &cbTotalAvailable,
                                                        &cbTotalReturned,
                                                        &cEntriesRead,
                                                        (PVOID *)&pdduOrig );
        pddu = pdduOrig;

        DWORD APIfinish = ::GetTickCount();

        TRACEEOL(   "ReadUsers: " << cEntriesRead << " (" << cUsersPerRequest
                 << ") users and " << cbTotalReturned << " (" << cbBytesRequested
                 << ") bytes took "
                 << (APIfinish - APIstart) << " msec" );

        if ( (APIfinish - APIstart) < READ_MORE_MSEC )
        {
            cbBytesRequested *= 2;
            if ( cbBytesRequested > BYTES_MAX_COUNT )
                cbBytesRequested = BYTES_MAX_COUNT;

            cUsersPerRequest *= 2;
            if ( cUsersPerRequest > USERS_MAX_COUNT )
                cUsersPerRequest = USERS_MAX_COUNT;
        }
        else if ( (APIfinish - APIstart) > READ_LESS_MSEC )
        {
            cbBytesRequested /= 2;
            if ( cbBytesRequested < BYTES_MIN_COUNT )
                cbBytesRequested = BYTES_MIN_COUNT;

            cUsersPerRequest /= 2;
            if ( cUsersPerRequest < USERS_MIN_COUNT )
                cUsersPerRequest = USERS_MIN_COUNT;
        }

#if defined(DEBUG) && defined(TRACE)

        APItime += (APIfinish - APIstart);

#endif

        err = ERRMAP::MapNTStatus( status );

        if( ( err != NERR_Success ) && ( err != ERROR_MORE_DATA ) )
        {
            //
            //  Something tragic occurred.
            //

            break;
        }

        if( ( cEntriesRead == 0 ) || ( cbTotalReturned == 0 ) )
        {
            //
            //  No more data to return.
            //

            break;
        }

        //
        //  Create a new buffer node for our buffer list.
        //

        ULC_API_BUFFER * pbuffer = new ULC_API_BUFFER( pddu, cEntriesRead );

        if( pbuffer == NULL )
        {
            //
            //  Could not create the buffer.
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        //  Append the new buffer node to the list.
        //

        // JonN 8/7/00
        // 24922 cleanup: this was overwriting the ERROR_MORE_DATA value
        APIERR err2 = _slBuffers.Append( pbuffer );

        if( err2 != NERR_Success )
        {
            err = err2;
            break;
        }

        //
        //  Grow the cache.  Note that we simply use cEntriesRead
        //  as a delta against the current cache size.  In reality,
        //  we may not need this much data if fIncludeRemoteUsers
        //  is FALSE.  Since most users are *not* remote users,
        //  it's not worth the effort to calculate a more accurate
        //  figure.  A little slop in the array size isn't a
        //  horrific price to pay for a little added efficiency.
        //

        if( !W_GrowCache( _cEntries + (INT)cEntriesRead ) )
        {
            //
            //  Could not grow the cache.
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        //  Update the cache entries.
        //

        ULONG cTmpEntries = cEntriesRead;

        for ( ULC_ENTRY * pTmp = QueryULCEntryPtr( _cEntries ) ;
              cTmpEntries-- ;
              pddu++ )
        {
            if( ( pddu->AccountControl & maskSelect ) == 0 )
            {
                pTmp->pddu = pddu;
                pTmp->plbi = NULL;
                if ( _cbExtraBytes > 0 )
                {
                    ::memset( (void *)&(pTmp->bExtraBytes),
                              0,
                              _cbExtraBytes );
                }

                _cEntries++;
                pTmp = (ULC_ENTRY *) ( ((BYTE *)pTmp) + QueryULCEntrySize() );
            }
        }

        //
        //  Update for the next API chunk.
        //

        // 379697: Incorrect usage of SamQueryDisplayInformation() in User Browser and net\ui\common\src
        // JonN 8/5/99

        // only continue on ERROR_MORE_DATA
        if ( ERROR_MORE_DATA != err )
            break;
        // set starting index for next iteration to index of last returned entry
        // iUser += cEntriesRead;
        if ( 0 < cEntriesRead )
            iUser = pdduOrig[cEntriesRead-1].Index;

        if ( pfQuitEnum != NULL && *pfQuitEnum )
            break;
    }

#if defined(DEBUG) && defined(TRACE)

    DWORD finish = ::GetTickCount();
    TRACEEOL(   "USER_LBI_CACHE::ReadUsers: completed read" );

    totaltime = finish - start;

    {
        TCHAR buffer1[ 100 ];
        TCHAR buffer2[ 100 ];

        wsprintf( buffer1, SZ("%8lu"), APItime );
        wsprintf( buffer2, SZ("%8lu"), totaltime );
        TRACEEOL(   "\tAPI   time " << buffer1 << " ms" );
        TRACEEOL(   "\ttotal time " << buffer2 << " ms" );
    }


    if ( err != NERR_Success )
    {
        TRACEEOL( "USER_LBI_CACHE::ReadUsers: read failed with " << err );
    }

#endif

    if( ( err == NERR_Success ) && ( nInitialGrowthSpace > 0 ) )
    {
        //
        //  The client is requesting some slop in the
        //  cache array.
        //

        INT nNewSize = ( _cEntries * ( nInitialGrowthSpace + 100 ) ) / 100;

        if( !W_GrowCache( nNewSize ) )
        {
            //
            //  Could not grow the cache.
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return err;

}   // USER_LBI_CACHE :: ReadUsers

/*******************************************************************

    NAME:       USER_LBI_CACHE :: BinarySearch

    SYNOPSIS:   Performs a binary search on the cache to find
                the appropriate location for a new LBI.

    ENTRY:      plbiNew                 - The new LBI.

    RETURNS:    INT                     - The proper index for the
                                          new LBI.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
INT USER_LBI_CACHE :: BinarySearch( LBI * plbiNew )
{
    if( _cEntries == 0 )
    {
        //
        //  The cache is empty, so we'll put the new
        //  LBI at the beginning.
        //

        return 0;
    }

    UIASSERT( _pCache != NULL );

    INT iHigh  = _cEntries - 1;
    INT iLow   = 0;
    INT iNew   = 0;
    INT cmpres = 0;

    //
    //  This is just your basic binary search, nothing fancy.
    //

    while( iLow <= iHigh )
    {
        iNew = ( iHigh + iLow ) / 2;

        ULC_ENTRY * pTmp = QueryULCEntryPtr( iNew );

        //
        //  We need to decide where to compare plbi <-> plbi
        //  or plbi <-> pddu.
        //

        if( pTmp->plbi != NULL )
        {
            cmpres = Compare( plbiNew, pTmp->plbi );
        }
        else
        {
            UIASSERT( pTmp->pddu != NULL );
            cmpres = Compare( plbiNew, pTmp->pddu );
        }

        //
        //  Interpret the result, move the boundaries as necessary.
        //

        if( cmpres < 0 )
        {
            iHigh = iNew - 1;
        }
        else
        if( cmpres > 0 )
        {
            iLow = iNew + 1;
        }
        else
        {
            iLow = iNew;
            break;
        }

    }

    return max( 0, iLow );

}   // USER_LBI_CACHE :: BinarySearch


/*******************************************************************

    NAME:       USER_LBI_CACHE :: BinarySearch

    SYNOPSIS:   Performs a binary search on the cache to find
                the appropriate location for a new LBI.

    ENTRY:      pddu                    - The DOMAIN_DISPLAY_USER for a new LBI.

    RETURNS:    INT                     - The proper index for the
                                          new LBI.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        JonN        30-Dec-1992     Created.

********************************************************************/
INT USER_LBI_CACHE :: BinarySearch( DOMAIN_DISPLAY_USER * pddu )
{
    if( _cEntries == 0 )
    {
        //
        //  The cache is empty, so we'll put the new
        //  LBI at the beginning.
        //

        return 0;
    }

    UIASSERT( _pCache != NULL );

    INT iHigh  = _cEntries - 1;
    INT iLow   = 0;
    INT iNew   = 0;
    INT cmpres = 0;

    //
    //  This is just your basic binary search, nothing fancy.
    //

    while( iLow <= iHigh )
    {
        iNew = ( iHigh + iLow ) / 2;

        ULC_ENTRY * pTmp = QueryULCEntryPtr( iNew );

        //
        //  We need to decide where to compare pddu <-> plbi
        //  or pddu <-> pddu.
        //

        if( pTmp->plbi != NULL )
        {
            cmpres = -(Compare( pTmp->plbi, pddu ));
        }
        else
        {
            UIASSERT( pTmp->pddu != NULL );
            ULC_ENTRY ulcTemp;
            ulcTemp.plbi = NULL;
            ulcTemp.pddu = pddu;
            cmpres = (QueryCompareMethod())( (void *)(&ulcTemp), (void *)pTmp );
        }

        //
        //  Interpret the result, move the boundaries as necessary.
        //

        if( cmpres < 0 )
        {
            iHigh = iNew - 1;
        }
        else
        if( cmpres > 0 )
        {
            iLow = iNew + 1;
        }
        else
        {
            iLow = iNew;
            break;
        }

    }

    return max( 0, iLow );

}   // USER_LBI_CACHE :: BinarySearch


/*******************************************************************

    NAME:       USER_LBI_CACHE :: W_GetLBI

    SYNOPSIS:   Lazy LBI creation.  Ensures that a particular cache
                location contains a valid LBI.

    ENTRY:      i                       - Zero-based index of the
                                          LBI to retrieve.

    EXIT:       If successful, then the specified cache entry will
                contain a valid LBI.  This may be a newly created
                LBI retrieved by calling the CreateLBI virtual.

    RETURNS:    LBI *                   - Points to the LBI found at
                                          the specified location.  Will
                                          be NULL if an error occurred.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
LBI * USER_LBI_CACHE :: W_GetLBI( INT i )
{
    LBI * plbi = NULL;

    //
    //  Only access the cache if the index is within range.
    //

    if( ( i >= 0 ) && ( i < _cEntries ) )
    {
        //
        //  Find the cache entry.
        //

        ULC_ENTRY * pTmp = QueryULCEntryPtr( i );

        plbi = pTmp->plbi;

        if( plbi == NULL )
        {
            //
            //  Cache miss.  Invoke the virtual callback
            //  to get a new LBI for this entry.
            //

            DOMAIN_DISPLAY_USER * pddu = pTmp->pddu;

            UIASSERT( pddu != NULL );

            if( pddu != NULL )
            {
                plbi = CreateLBI( pTmp->pddu );
            }

            if( ( plbi != NULL ) && ( plbi->QueryError() != NERR_Success ) )
            {
                //
                //  We want to avoid putting badly constructed
                //  LBIs in the cache.
                //

                delete plbi;
                plbi = NULL;
            }

            //
            //  Save the new (potentially NULL) LBI in the cache.
            //

            pTmp->plbi = plbi;
        }
        else
        {
            //
            //  Only properly constructed LBIs should ever
            //  make it into the cache.
            //

            UIASSERT( plbi->QueryError() == NERR_Success );
        }
    }

    return plbi;

}   // USER_LBI_CACHE :: W_GetLBI

/*******************************************************************

    NAME:       USER_LBI_CACHE :: W_GrowCache

    SYNOPSIS:   Grow the cache array to contain at least the specified
                number of entries.

    ENTRY:      cTotalCacheEntries      - The minimum number of entries
                                          the cache should contain.

    EXIT:       If successful, the cache has been grown to contain at
                least the specified number of entries.  This typically
                requires a reallocation of the cache array block.  This
                method is also responsible for updating the _cSlots
                data member.

    RETURNS:    BOOL                    - TRUE if successful, FALSE
                                          otherwise.

    NOTES:      This method must be called with the cache locked.

    HISTORY:
        KeithMo     15-Dec-1992     Created.

********************************************************************/
BOOL USER_LBI_CACHE :: W_GrowCache( INT cTotalCacheEntries )
{
    BOOL fResult = TRUE;       // until proven otherwise...

    if( cTotalCacheEntries > _cSlots )
    {
        //
        //  Round cTotalCacheEntries UP to an integral number
        //  of ULC_CACHE_GROWTH_DELTA blocks.
        //

        cTotalCacheEntries += ULC_CACHE_GROWTH_DELTA - 1;
        cTotalCacheEntries &= ~( ULC_CACHE_GROWTH_DELTA - 1 );

        //
        //  Try to allocate a new cache array of the
        //  requested size.
        //

        VOID * pNewCache = (VOID *) new BYTE[
                        cTotalCacheEntries * QueryULCEntrySize() ];

        if( pNewCache == NULL )
        {
            fResult = FALSE;
        }
        else
        {
            //
            //  Successful allocation.  Zero-out the new portion
            //  of the array, then copy the data from the old
            //  array.
            //

            ::memset( (void *)( ((BYTE *)pNewCache) + (_cEntries * QueryULCEntrySize()) ),
                      0,
                      ( cTotalCacheEntries - _cEntries ) * QueryULCEntrySize() );

            if( _cEntries > 0 )
            {
                ::memcpy( (void *)pNewCache,
                          (void *)_pCache,
                          _cEntries * QueryULCEntrySize() );
            }

            delete _pCache;
            _pCache = pNewCache;
            _cSlots = cTotalCacheEntries;
        }
    }

    return fResult;

}   // USER_LBI_CACHE :: W_GrowCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\w32event.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32event.cxx
    Class definitions for the WIN32_EVENT class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_EVENT methods.
//

/*******************************************************************

    NAME:       WIN32_EVENT :: WIN32_EVENT

    SYNOPSIS:   WIN32_EVENT class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_EVENT :: WIN32_EVENT( const TCHAR * pszName,
                            BOOL          fManualReset,
                            BOOL          fInitialState )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    HANDLE hEvent;

    hEvent = ::CreateEvent( NULL,
                            fManualReset,
                            fInitialState,
                            (LPTSTR)pszName );

    if( hEvent == NULL )
    {
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetHandle( hEvent );

}   // WIN32_EVENT :: WIN32_EVENT


/*******************************************************************

    NAME:       WIN32_EVENT :: ~WIN32_EVENT

    SYNOPSIS:   WIN32_EVENT class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_EVENT :: ~WIN32_EVENT()
{
    //
    //  This space intentionally left blank.
    //

}   // WIN32_EVENT :: ~WIN32_EVENT


/*******************************************************************

    NAME:       WIN32_EVENT :: Set

    SYNOPSIS:   Set the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_EVENT :: Set( VOID )
{
    APIERR err = NO_ERROR;

    if( !::SetEvent( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_EVENT :: Set


/*******************************************************************

    NAME:       WIN32_EVENT :: Reset

    SYNOPSIS:   Reset the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_EVENT :: Reset( VOID )
{
    APIERR err = NO_ERROR;

    if( !::ResetEvent( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_EVENT :: Reset


/*******************************************************************

    NAME:       WIN32_EVENT :: Pulse

    SYNOPSIS:   Pulse the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_EVENT :: Pulse( VOID )
{
    APIERR err = NO_ERROR;

    if( !::PulseEvent( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_EVENT :: Pulse
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\usrbrows.h ===
#define CB_TRUSTED_DOMAINS          102
#define BUTTON_SHOW_USERS           103
#define LB_ACCOUNTS                 104
#define IDHELP                      108
#define COL_SUBJECT_NAME            202
#define COL_COMMENT                 203
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\usrbrows.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    UserBrows.cxx

    This file contains the implementation for the standard User Browser
    dialog.



    FILE HISTORY:
        Johnl   02-Mar-1992     Created
        jonn        14-Oct-1993 Use NetGetAnyDC
        jonn        14-Oct-1993 Minor focus fix (OnDlgDeactivation)

*/

#include "pchapplb.hxx"   // Precompiled header

#include "browmemb.hxx"
#include "findacct.hxx"

#ifndef min
    #define min(a,b)	 ((a)<(b)?(a):(b))
#endif

DEFINE_SLIST_OF(USER_BROWSER_LBI) ;

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::NT_USER_BROWSER_DIALOG

    SYNOPSIS:   Constructor for the user browser dialog

    ENTRY:      pszDlgName - Resource name of the dialog (supplied for possible
                    derivation).
                hwndOwner - Owner hwnd
                pszServer - Name of server (in "\\server" form) the resource
                    lives on.
                ulFlags - USRBROWS_* show and incl flags.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   02-Mar-1992      Created

********************************************************************/

NT_USER_BROWSER_DIALOG::NT_USER_BROWSER_DIALOG( const TCHAR * pszDlgName,
                                        HWND          hwndOwner,
                                        const TCHAR * pszServer,
                                        ULONG         ulHelpContext,
                                        ULONG         ulFlags,
                                        const TCHAR * pszHelpFileName,
                                        ULONG ulHelpContextGlobalMembership,
                                        ULONG ulHelpContextLocalMembership,
                                        ULONG ulHelpContextSearch,
					const ADMIN_AUTHORITY * pAdminAuthPrimary )
    : DIALOG_WINDOW           ( pszDlgName, hwndOwner ),
      _fIsSingleSelection     ( !!(ulFlags & USRBROWS_SINGLE_SELECT)  ),
      _fEnableMembersButton   ( TRUE ),
      _lbAccounts             ( this, LB_ACCOUNTS ),
      _cbDomains              ( this, CB_TRUSTED_DOMAINS ),
      _buttonShowUsers	      ( this, BUTTON_SHOW_USERS ),
      _buttonSearch	         ( this, USR_BUTTON_SEARCH ),
      _buttonMembers	         ( this, USR_BUTTON_MEMBERS ),
      _buttonOK 	            ( this, IDOK ),
      _buttonAdd	            ( this, USR_BUTTON_ADD ),
      _sleBrowseErrorText     ( this, USR_SLT_BROWSER_ERROR ),
      _mleAdd		            ( this,
                                USR_MLE_ADD,
                                pszServer,
                                this,
				                    !!(ulFlags & USRBROWS_SINGLE_SELECT),
				                    ulFlags ),
      _pbrowdomainCurrentFocus( NULL ),
      _pszServerResourceLivesOn( pszServer ),
      _ulFlags                ( ulFlags ),
      _fDomainsComboIsDropped ( FALSE ),
      _fUsersAreShown         ( FALSE ),
      _ulHelpContext          ( ulHelpContext ),
      _pszHelpFileName	      ( pszHelpFileName ),
      _ulHelpContextGlobalMembership( ulHelpContextGlobalMembership ),
      _ulHelpContextLocalMembership ( ulHelpContextLocalMembership ),
      _ulHelpContextSearch          ( ulHelpContextSearch ),
      _nlsDCofPrimaryDomain   (),
      _hwndLastFocus          ( NULL )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    if ( (err = _nlsDCofPrimaryDomain.QueryError()) != NERR_Success )
    {
        DBGEOL( "NT_USER_BROWSER_DIALOG::ctor(); NLS_STR ctor error " << err );
        ReportError( err );
        return;
    }

    if (  ( _pszServerResourceLivesOn != NULL )
       && ( _pszServerResourceLivesOn[0] == TCH('\\'))
       && ( _pszServerResourceLivesOn[1] == TCH('\\'))
       )
    {
        // Server is not null, and starts with two backslashes
        // ==> Check if it is the local machine name. If so, use NULL
        //     for the local machine name.
        LOCATION loc; // local computer
        NLS_STR nlsLocalMachineName;
        if (  (err = loc.QueryError())
           || (err = nlsLocalMachineName.QueryError())
           || (err = loc.QueryDisplayName( &nlsLocalMachineName ))
           )
        {
             ReportError( err );
             return;
        }

        if ( !::I_MNetComputerNameCompare( nlsLocalMachineName, pszServer ) )
            _pszServerResourceLivesOn = NULL;
    }

    //
    //	The listbox best be single select if we're going to be in single
    //	select mode
    //
    UIASSERT( !IsSingleSelection() ||
	      (IsSingleSelection() &&
		!( (_lbAccounts.QueryStyle() & LBS_EXTENDEDSEL) ||
		   (_lbAccounts.QueryStyle() & LBS_MULTIPLESEL)   )))

    AUTO_CURSOR cursHourGlass ;

    //
    //	Makes the combo auto drop etc.	Ignore the return code.
    //
    (void) _cbDomains.Command( CB_SETEXTENDEDUI, (WPARAM) TRUE ) ;

    //
    //	If users are never shown or only users are shown or
    //	users are always expanded, then don't show
    //	the "Show Users" button.
    //
    if ( !IsShowUsersButtonUsed() )
    {
        _buttonShowUsers.Show( FALSE ) ;
        _buttonShowUsers.Enable( FALSE ) ;
    }

    //
    //	If the client is asking for only global groups or local groups,
    //	disable access to the Members and Search button.
    //  Add show caption of add dialog.
    //
    BOOL fShowUsers   = !!( QueryFlags() & USRBROWS_SHOW_USERS	 );
    BOOL fShowGroups  = !!( QueryFlags() & USRBROWS_SHOW_GROUPS  );
    BOOL fShowAliases = !!( QueryFlags() & USRBROWS_SHOW_ALIASES );
    BOOL fShowWellKnownGroup = !!( QueryFlags() & USRBROWS_INCL_ALL );
    if (    ( fShowGroups  && !fShowUsers  )
         || ( fShowAliases && !fShowGroups )
       )
    {
	_buttonSearch.Enable( FALSE ) ;
	_buttonSearch.Show( FALSE ) ;
	_buttonMembers.Enable( FALSE ) ;
	_buttonMembers.Show( FALSE ) ;
    }

    MSGID idCaption = 0;
    if (_fIsSingleSelection)
    {
        if (fShowUsers)
        {
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_USER_OR_GROUP;
            else
                idCaption = IDS_USRBROWS_ADD_USER;
        }
        else
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_GROUP;
    }
    else
    {
        if (fShowUsers)
        {
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_USERS_AND_GROUPS;
            else
                idCaption = IDS_USRBROWS_ADD_USERS;
        }
        else
            if (fShowGroups | fShowAliases | fShowWellKnownGroup)
                idCaption = IDS_USRBROWS_ADD_GROUPS;
    }

    if (idCaption)
    {
        RESOURCE_STR nlsCaption(idCaption);
        err = nlsCaption.QueryError();
        if (!err)
        {
            SetText (nlsCaption);
        }
    }

    //
    //	Resize the error slt to be the same size as the accounts listbox
    //
    XYDIMENSION xyLBSize = _lbAccounts.QuerySize() ;
    _sleBrowseErrorText.SetSize( xyLBSize, FALSE ) ;

    //
    //	Fill in the trusted domain list
    //
    if ( (err = GetTrustedDomainList( _pszServerResourceLivesOn,
				      &_pbrowdomainCurrentFocus,
				      &_cbDomains,
				      pAdminAuthPrimary )))
    {
	TRACEEOL("NT_USER_BROWSER_DIALOG::ct - Error " << err << " returned from GetTrustedDomainList") ;
    }
    SetDialogFocus( _cbDomains );

    //
    //	Finally, initialize everything for the default domain (this kicks
    //	off the thread for this domain).
    //

    if ( !err )
    {
	BROWSER_DOMAIN_LBI * plbi = (BROWSER_DOMAIN_LBI*) _cbDomains.QueryItem() ;
	UIASSERT( plbi != NULL ) ;

	BROWSER_DOMAIN * pBrDomNewFocus = plbi->QueryBrowserDomain() ;
	if ( !err &&
	     (err = OnDomainChange( pBrDomNewFocus, pAdminAuthPrimary )) )
	{
	    TRACEEOL("NT_USER_BROWSER_DIALOG::ct - Error " << err << " returned from QueryBrowserDomain") ;
	}
    }

    //
    //	The MLE needs to know which domain is the target domain so we can
    //	appropriately replace "BUILTIN" for well known accounts
    //
    if ( !err )
    {
	for ( int cItems = _cbDomains.QueryCount(), i = 0 ; i < cItems ; i++ )
	{
	    BROWSER_DOMAIN_LBI * plbi = (BROWSER_DOMAIN_LBI*) _cbDomains.QueryItem( i ) ;
	    UIASSERT( plbi != NULL )
	    if ( plbi->IsTargetDomain() )
	    {
		err = _mleAdd.SetTargetDomain( plbi->QueryBrowserDomain()->
						      QueryLsaLookupName() ) ;
		break ;
	    }
	}
    }

    if ( err )
	ReportError( err ) ;
}


NT_USER_BROWSER_DIALOG::~NT_USER_BROWSER_DIALOG()
{
    _pbrowdomainCurrentFocus = NULL ;

    //
    //	This will force the threads to quit accessing any members of *this
    //	before the members of this dialog are destructed (each browser
    //	domain in the CB may have a thread spinning in the background)
    //
    _cbDomains.DeleteAllItems() ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::EnableBrowsing

    SYNOPSIS:	Enables accounts listbox and associated buttons appropriately

    ENTRY:	fEnable - TRUE to enable browsing, FALSE otherwise

    NOTES:	This doesn't affect the domain combo in any way.

    HISTORY:
	Johnl	04-Dec-1992	Created

********************************************************************/

void NT_USER_BROWSER_DIALOG::EnableBrowsing( BOOL fEnable )
{
    //
    //	Enable/show controls as appropriate
    //
    _sleBrowseErrorText.Show( !fEnable ) ;
    _lbAccounts.Enable( fEnable ) ;

    _buttonShowUsers.Enable( fEnable && IsShowUsersButtonUsed() ) ;

    if ( fEnable )
    {
        HWND hwndLastFocus = ::GetFocus();
        if (hwndLastFocus == NULL)
        {
            TRACEEOL( "NT_USER_BROWSER_DIALOG::EnableBrowsing: remembering last focus" );
            hwndLastFocus = _hwndLastFocus;
        }

	//
	//  If the user is sitting on the domain combo and they are not
	//  selecting a new domain, then switch the focus to the listbox.
	//  This is for the user who wants to browse the list of accounts
	//
	if (   (_cbDomains.QueryHwnd() == hwndLastFocus)
            && !_cbDomains.IsDropped() )
	{
            SetDialogFocus( _lbAccounts );
	}

	_lbAccounts.Invalidate( TRUE ) ;
	if ( _lbAccounts.QueryCount() > 0 )
	{
            _lbAccounts.RemoveSelection();
	    _lbAccounts.SetCaretIndex( 0 ) ;
	}
    }

    _lbAccounts.Show( fEnable ) ;

    //
    //	This will enable _buttonMembers, _buttonAdd as appropriate
    //
    UpdateButtonState() ;
}


/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::SetAndFillErrorText

    SYNOPSIS:	Covers up the listbox with an SLT (that looks like the listbox)
		and displays the error code indicating why they can't browse
		the current domain.

    ENTRY:	errDisplay - Error code to display as part of the message
		fIsErr - If FALSE, then the text isn't prefixed with
		    the standard error prolog text

    RETUR:	NERR_Success of successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	04-Dec-1992	Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::SetAndFillErrorText( MSGID errDisplay,
						    BOOL  fIsErr )
{
    APIERR err ;

    RESOURCE_STR nlsMessage( (MSGID) ( fIsErr ? IDS_CANT_BROWSE_DOMAIN :
						errDisplay ) ) ;

    if ( fIsErr )
    {
	RESOURCE_STR nlsError( (MSGID) errDisplay ) ;
	if ( err = nlsError.QueryError() )
	{
	    /* If we couldn't find the error message then just put the
	     * error message number up for display
	     */
	    DEC_STR decStr( (ULONG) errDisplay ) ;
	    if ( (err = decStr.QueryError()) ||
		 (err = nlsError.CopyFrom( decStr )) )
	    {
		return err ;
	    }
	}

	if ( (err = nlsMessage.InsertParams( nlsError )) )
	{
	    return err ;
	}
    }

    _sleBrowseErrorText.SetText( nlsMessage ) ;
    _sleBrowseErrorText.Show( TRUE ) ;
    _lbAccounts.Show( FALSE ) ;
    _lbAccounts.Enable( FALSE ) ;

	// NTRAID#NTBUG9-577061-2002/03/07-artm  Prefast: err may not have been initialized
	// If fIsErr is false, then err was never initialized and the return
	// value is garbage bits.
    return err ;
}


/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnCommand

    SYNOPSIS:   Typical OnCommand for this dialog, we catch pressing
                the ShowUsers button and changing the selection in the
                domain drop down list.

    EXIT:

    RETURNS:

    NOTES:	The Add button is enabled any time there is a selection in
		the Accounts listbox.  It is made the default when the Add
		listbox is empty

    HISTORY:
        Johnl   02-Mar-1992     Created
********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryCode() )
    {
    case LBN_SETFOCUS:
    case CBN_SETFOCUS:
    case EN_SETFOCUS:
        TRACEEOL( "NT_USER_BROWSER_DIALOG::OnCommand(): ?N_SETFOCUS" );
        UpdateButtonState() ;
        break;
    default:
        break;
    }

    switch ( event.QueryCid() )
    {
    case BUTTON_SHOW_USERS:
	err = OnShowUsers() ;
	UpdateButtonState() ;
        break ;

    case CB_TRUSTED_DOMAINS:
        {
            switch ( event.QueryCode() )
            {
            //
            //  Note that the Show Users button is disabled anytime the
            //  domain combo is dropped.  This prevents somebody using the
            //  show users mnemonic on a domain that hasn't been initialized
            //  yet.
            //
            case CBN_DROPDOWN:
                SetDomainComboDropFlag( TRUE ) ;
                if ( IsShowUsersButtonUsed() )
                    _buttonShowUsers.Enable( FALSE ) ;
                _buttonMembers.Enable( FALSE ) ;
                break ;

            case CBN_CLOSEUP:
                SetDomainComboDropFlag( FALSE ) ;

                //
                //  Only re-enable the Show Users button if users aren't shown
                //  and the button is actually used and the list box is active
                //
                if ( IsShowUsersButtonUsed() &&
                     !AreUsersShown()        &&
                     IsBrowsingEnabled()       )
                {
                    _buttonShowUsers.Enable( TRUE ) ;
                }

                //
                // reenable the membrs if it os OK to do so
                //
                _buttonMembers.Enable(_lbAccounts.IsSelectionExpandableGroup()
                                      && _fEnableMembersButton ) ;

                //
                //  Fall through
                //

            case CBN_KILLFOCUS:
            case CBN_SELCHANGE:
                {
                    if ( IsDomainComboDropped() )
                        break ;

		    BROWSER_DOMAIN_LBI * plbi =
                                (BROWSER_DOMAIN_LBI*) _cbDomains.QueryItem() ;
                    ASSERT( plbi != NULL );
                    if (plbi != NULL)
                    {
		        BROWSER_DOMAIN * pBrDomNewFocus =
                                    plbi->QueryBrowserDomain() ;

                        if ( pBrDomNewFocus != QueryCurrentDomainFocus() )
                        {
		    	    err = OnDomainChange( pBrDomNewFocus ) ;
		    	    UpdateButtonState() ;
                        }
                    }
                }
                break ;
            }
	}
	break ;

    case USR_BUTTON_ADD:
	err = OnAdd() ;
	UpdateButtonState() ;
	break ;

    case USR_BUTTON_MEMBERS:
	err = OnMembers() ;
	UpdateButtonState() ;
	break ;

    case USR_BUTTON_SEARCH:
	err = OnSearch() ;
	UpdateButtonState() ;
	break ;

    case LB_ACCOUNTS:
	switch ( event.QueryCode() )
	{
	case LBN_DBLCLK:
	    err = OnAdd() ;
            // fall through

        case LBN_SELCHANGE:
	    UpdateButtonState() ;
	    break ;

        default:
            break ;
	}
	break ;

    default:
	return DIALOG_WINDOW::OnCommand( event ) ;
    }

    if ( err )
    {
        if( event.QueryCid() == CB_TRUSTED_DOMAINS )
        {
            //
            //  Something fatal occurred when filling the listbox
            //  with the newly selected domain.  Since the combo
            //  box reflects the new selection, we'll nuke the
            //  contents of the listbox.
            //

	    EnableBrowsing( FALSE ) ;
	    //_lbAccounts.RemoveAllItems(); // Needed??
	    UpdateButtonState() ;
	    if ( !SetAndFillErrorText( (MSGID) err ) )
	    {
		//
		//  If we successfully notified the user through the
		//  error SLE, then don't popup an error, otherwise, popup
		//  the error.
		//
		err = NERR_Success ;
	    }
	}

	if ( err )
	   MsgPopup( this, (MSGID) err ) ;

    }

    return TRUE ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnUserMessage

    SYNOPSIS:	Standard on user processing.  Catches the WM_ACCOUNT_DATA
		response and fills the accounts listbox

    NOTES:

    HISTORY:
	Johnl	07-Dec-1992	Created

********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnUserMessage( const EVENT & event )
{
    APIERR err = NERR_Success ;

    switch ( event.QueryMessage() )
    {
    case WM_LB_FILLED:
	{
	    BOOL fEnableBrowsing = (BOOL) event.QueryWParam() ;

	    if ( fEnableBrowsing )
	    {
    	        USER_BROWSER_LBI_CACHE * pcache = (USER_BROWSER_LBI_CACHE*)
		  				  event.QueryLParam() ;
                _lbAccounts.SetCurrentCache( pcache ) ;

                //
                // Enable the members button (subject to other checks)
                // see UpdateButtonState()
                //
                _fEnableMembersButton = TRUE ;

                //
                // Enable browsing after the cache has been set
                //
                EnableBrowsing( TRUE ) ;
	    }
            else
            {
                EnableBrowsing( FALSE ) ;
                SetAndFillErrorText( (APIERR) event.QueryLParam() );
            }
	}
	break ;

    default:
	return DIALOG_WINDOW::OnUserMessage( event ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::GetTrustedDomainList

    SYNOPSIS:   This method enumerates the trusted domains of the passed
		server adding each domain to the domain combo box.

    ENTRY:      pszServer - Where the resource lives (in form "\\server")
                ppBrowserDomainDefaultFocus - A pointer to the domain
                    that has the default focus (which will be where the
                    resource lives)
                pcbDomains - Pointer to combo box to fill with the trusted
                    domains.

    EXIT:       The domain combo will be filled, the list of trusted
                domains will be filled and *ppBrowserDomainDefaultFocus
                will be set to the domain that has the default focus.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The domain/server that the resource lives on will have an "*"
                appended to its name (indicates Alias enumeration).

                The list of trusted domains will be generated by enumerating
                the trusted domains on the PDC of the domain that
                pszServer is contained in.

    HISTORY:
        Johnl   03-Mar-1992     Created
        Thomaspa 10-10-1993     added pAdminAuthPrimary

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::GetTrustedDomainList(
			     const TCHAR *	 pszServer,
			     BROWSER_DOMAIN  * * ppBrowserDomainDefaultFocus,
			     BROWSER_DOMAIN_CB * pcbDomains,
			     const ADMIN_AUTHORITY * pAdminAuthPrimary )
{
    TRACEEOL("NT_USER_BROWSER_DIALOG::GetTrustedDomainList Entered @ " << ::GetTickCount()/100) ;

    APIERR err = NERR_Success ;

    /* errEnumDomains is used to indicate the success of enumerating
     * domains.
     */
    APIERR errEnumDomains = NERR_Success ;
    BOOL fShowComputer ;
    LSA_POLICY * pLSAPolicy = NULL;
    API_SESSION * pAPISession = NULL;

    do { // Error breakout thing

        LOCATION locServerResourceIsOn( pszServer, FALSE ) ;

        if ( (err = locServerResourceIsOn.QueryError()))
        {
            break ;
        }

        LOCATION_NT_TYPE locnttype ;
        BOOL fIsNT ;

        /* The target domain will be pszServer if this is a winnt machine,
         * else the target domain will be the primary domain of pszServer.
         */
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif
        if ( (err = locServerResourceIsOn.CheckIfNT( &fIsNT,
                                                     &locnttype )) ||
             !fIsNT )
        {
            UIASSERT(err || fIsNT) ; // Sure as heck better be on NT
            DBGEOL("GetTrustedDomainList - Error " << (ULONG) err <<
                   " returned from CheckIfNT") ;
            break ;
        }
#if defined(DEBUG) && defined(TRACE)
        TRACEEOL("GetTrustedDomainList: CheckIfNt took (ms) " << (::GetTickCount() - start) );
#endif

        /* Add the computer the resource resides on to the list of trusted
         * domains unless the client requested that it not be shown.
         */
        fShowComputer = !(QueryFlags() & USRBROWS_DONT_SHOW_COMPUTER) &&
                              (locnttype == LOC_NT_TYPE_WINDOWSNT
                                || locnttype == LOC_NT_TYPE_SERVERNT) ;

        /* Open an LSA Policy on the local machine so we can get its account
         * domain SID and primary domain sid
         */
        LSA_POLICY LSAPolicyLocalMachine( pszServer ) ;
        LSA_ACCT_DOM_INFO_MEM LSAAcctDomInfo ;
        LSA_PRIMARY_DOM_INFO_MEM LSAPrimDomInfo ;

        if ( (err = LSAPolicyLocalMachine.QueryError()) ||
             (err = LSAAcctDomInfo.QueryError())        ||
             (err = LSAPrimDomInfo.QueryError())          )
        {
            break ;
        }

        BROWSER_DOMAIN * pbrowdomain ;
        if ( fShowComputer )
        {
#if defined(DEBUG) && defined(TRACE)
            start = ::GetTickCount();
#endif
            if (err = LSAPolicyLocalMachine.GetAccountDomain(&LSAAcctDomInfo))
            {
                DBGEOL("GetTrustedDomainList - Error " << (ULONG) err <<
                       " returned from GetAccountDomain") ;
                break ;
            }
#if defined(DEBUG) && defined(TRACE)
            TRACEEOL("GetTrustedDomainList: GetAccountDomain took (ms) " << (::GetTickCount() - start) );
#endif

            /* Since this is a WinNT machine, this browser domain will be
             * the "target" domain (but not the default domain).
             */
            pbrowdomain = new BROWSER_DOMAIN(pszServer,
                                             LSAAcctDomInfo.QueryPSID(),
                                             TRUE,
                                             TRUE ) ;

	    if ( err = _cbDomains.AddItem( pbrowdomain ) )
            {
                break ;
	    }

            /* Make the default selection the computer name in case
             * we can't enumerate the trusted domains down below.
             */
            *ppBrowserDomainDefaultFocus = pbrowdomain ;
        }

#if defined(DEBUG) && defined(TRACE)
        start = ::GetTickCount();
#endif
        if (errEnumDomains = LSAPolicyLocalMachine.GetPrimaryDomain(
                                                             &LSAPrimDomInfo ))
        {
            DBGEOL("GetTrustedDomainList - GetPrimaryDomain returned error " <<
		     (ULONG) errEnumDomains ) ;
            break ;
        }
#if defined(DEBUG) && defined(TRACE)
        TRACEEOL("GetTrustedDomainList: GetPrimaryDomain took (ms) " << (::GetTickCount() - start) );
#endif

        /* If the machine is a workgroup machine then it won't have a domain
         * or set of trusted domains to enumerate, so get out.
         */
        if ( LSAPrimDomInfo.QueryPSID() == NULL )
        {
            DBGEOL("GetTrustedDomainList - Target machine does not have an" <<
                   " LSA primary domain (i.e., is a workgroup machine)") ;
            //
            //  If the client requested we don't show the computer but we
            //  are focused on a workgroup machine (which only has the computer
            //  to show), then tell them they messed up
            //
            if ( !fShowComputer )
                err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        NLS_STR nlsPrimDomain( DNLEN ) ;
        if ( (errEnumDomains = nlsPrimDomain.QueryError()) ||
             (errEnumDomains = LSAPrimDomInfo.QueryName( &nlsPrimDomain )) )
        {
            DBGEOL(   "NT_USER_BROWSER_DIALOG::GetTrustedDomainList(): "
                   << "error loading DC of primary domain " << errEnumDomains );
            break ;
        }

#ifdef TRACE
	TRACEEOL("GetTrustedDomainList - Primary Domain Name is " << nlsPrimDomain ) ;
	TRACEEOL("GetTrustedDomainList - Primary domain SID:") ;
	OS_SID ossidPrimDomain( LSAPrimDomInfo.QueryPSID() ) ;
	ossidPrimDomain.DbgPrint() ;
#endif

        /* Add the domain this server is on.
         * This is only a target domain (3rd param) if the computer is not
         * shown.
         */
        pbrowdomain = new BROWSER_DOMAIN( nlsPrimDomain,
                                          LSAPrimDomInfo.QueryPSID(),
                                          !fShowComputer ) ;

        errEnumDomains = ERROR_NOT_ENOUGH_MEMORY ;
        if ( (pbrowdomain == NULL)             ||
             (err = pbrowdomain->QueryError()))
        {
            DBGEOL("GetTrustedDomains - can't construct PDC BROWSER_DOMAIN") ;
            delete pbrowdomain ;
            break ;
        }

        *ppBrowserDomainDefaultFocus = pbrowdomain ;
        if ( err = _cbDomains.AddItem( pbrowdomain) )
        {
            break ;
        }

        /* Now add each of the trusted domains listed from the PDC to
         * the trusted domain list.
         *
         * We establish an API session (null session w/ IPC$) so
         * we don't have account conflicts (i.e., Admin w/ diff passwords)
         */


        LSA_ENUMERATION_HANDLE LSAEnumHandle = 0 ;
        LSA_TRUST_INFO_MEM     LSATrustInfo ;



        if ( pAdminAuthPrimary == NULL )
        {
            DOMAIN_WITH_DC_CACHE PrimDom( nlsPrimDomain, TRUE ) ;
            if ( (errEnumDomains = PrimDom.GetInfo())
                || (errEnumDomains = _nlsDCofPrimaryDomain.CopyFrom(
                                        PrimDom.QueryAnyDC() )) )
            {
                //
                //  Give a more specific error message.  The workstation or
                //  browser not started should be the only reason why we
                //  get this error.
                //
                if ( errEnumDomains == NERR_ServiceNotInstalled )
                    errEnumDomains = IDS_WKSTA_OR_BROWSER_NOT_STARTED;
                break ;
            }
    	    TRACEEOL("GetTrustedDomainList - Using DC " << PrimDom.QueryAnyDC() ) ;
            pAPISession = new API_SESSION( PrimDom.QueryAnyDC(), TRUE ) ;
            pLSAPolicy = new LSA_POLICY( PrimDom.QueryAnyDC() ) ;
            errEnumDomains = ERROR_NOT_ENOUGH_MEMORY;
            if ( (pAPISession == NULL) ||
                 (pLSAPolicy == NULL) ||
                 (errEnumDomains = pAPISession->QueryError()) ||
                 (errEnumDomains = pLSAPolicy->QueryError()) )
             {
                 break;
             }
             errEnumDomains = NERR_Success;
        }
        else
        {
            pLSAPolicy = pAdminAuthPrimary->QueryLSAPolicy();

            if( errEnumDomains = _nlsDCofPrimaryDomain.CopyFrom(
                                        pAdminAuthPrimary->QueryServer()) )
            {
                break;
            }

        }


        NLS_STR                nlsDomName( DNLEN ) ;
        if ( (errEnumDomains = LSATrustInfo.QueryError())||
             (errEnumDomains = nlsDomName.QueryError())    )
        {
            DBGEOL( "GetTrustedDomains - Error " << (ULONG) errEnumDomains <<
                     " constructing LSA/API Session class" ) ;
            break ;
        }

        do {
            errEnumDomains = pLSAPolicy->EnumerateTrustedDomains( &LSATrustInfo,
                                                                &LSAEnumHandle,
                                                                1024L ) ;
	    TRACEEOL("GetTrustedDomainList - Returned " << errEnumDomains ) ;

            if ( errEnumDomains != NERR_Success &&
                 errEnumDomains != ERROR_MORE_DATA )
            {
                if ( errEnumDomains == ERROR_NO_MORE_ITEMS )
                {
                    errEnumDomains = NERR_Success ;
                }

                break ;
            }

            for ( ULONG i = 0 ; i < LSATrustInfo.QueryCount() ; i++ )
            {
                if ( (err = LSATrustInfo.QueryName( i, &nlsDomName )))
                {
                    break ;
                }

		TRACEEOL( "GetTrustedDomainList - Adding trusted domain " << nlsDomName ) ;
#if defined(DEBUG) && defined(TRACE)
                start = ::GetTickCount();
#endif
                pbrowdomain = new BROWSER_DOMAIN( nlsDomName,
                                                  LSATrustInfo.QueryPSID( i ),
                                                  FALSE ) ;
		if ( _cbDomains.AddItem( pbrowdomain ) )
                {
                    break ;
                }
#if defined(DEBUG) && defined(TRACE)
                TRACEEOL("GetTrustedDomainList: BROWSER_DOMAIN took (ms) " << (::GetTickCount() - start) );
#endif
            }
        } while ( errEnumDomains == ERROR_MORE_DATA ) ;

    } while (FALSE) ; // Error breakout loop

    if ( pAdminAuthPrimary == NULL )
    {
        delete pAPISession;
        delete pLSAPolicy;
    }

    //
    //  If err is set then a fatal error occurred
    //
    if ( err )
    {
        return err ;
    }

    //
    //	Select the default domain in the combo box
    //
    pcbDomains->SelectItem( *ppBrowserDomainDefaultFocus ) ;

    //
    //	If errEnumDomains is set, then an error occurred that the user needs
    //	to know about but we can still display this dialog.
    //
    if ( errEnumDomains )
    {
        TRACEEOL( "GetTrustedDomainList - Reporting non-fatal errror " << (ULONG) errEnumDomains) ;
        APIERR errTmp ;
        RESOURCE_STR nlsError( (MSGID) errEnumDomains ) ;
        if ( errTmp = nlsError.QueryError() )
        {
            /* If we couldn't find the error message then just put the
             * error message number up for display
             */
            DEC_STR decStr( (ULONG) errEnumDomains ) ;
            if ( (errTmp = decStr.QueryError()) ||
                 (errTmp = nlsError.CopyFrom( decStr )) )
            {
                return errTmp ;
            }
        }

        MsgPopup( this,
                  IDS_CANT_BROWSE_DOMAINS,
                  MPSEV_WARNING,
                  MP_OK,
                  nlsError ) ;
    }

    TRACEEOL("NT_USER_BROWSER_DIALOG::GetTrustedDomainList Leave   @ " << ::GetTickCount()/100) ;
    return err ;
}


/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnDomainChange

    SYNOPSIS:   This method is called when the user selects a new domain
                from the domain name combo.

    ENTRY:      pDomainNewSelection - Pointer to new BROWSER_DOMAIN that was
                    just selected.

    EXIT:       The listbox will be updated to reflect the new items in
                the selected domain.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:	This method maybe called when QueryCurrentDomainFocus returns
		NULL (when first initializing).

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnDomainChange( BROWSER_DOMAIN * pDomainNewSelection,
					const ADMIN_AUTHORITY * pAdminAuth )
{
    TRACEEOL("NT_USER_BROWSER_DIALOG::OnDomainChange Enter @ " << ::GetTickCount()/100) ;
    UIASSERT( pDomainNewSelection != NULL ) ;
    APIERR err = NERR_Success ;
    AUTO_CURSOR cursHourGlass ;

    //
    //	In case the user is just flipping through domains, don't update the
    //	listbox for this domain if we are on a new domain
    //
    BROWSER_DOMAIN * pDomainOldSelection = QueryCurrentDomainFocus() ;
    if ( pDomainOldSelection != NULL && pDomainOldSelection->IsInitialized() )
    {
	pDomainOldSelection->UnRequestAccountData() ;
	_mleAdd.CanonicalizeNames( QueryCurrentDomainFocus()->QueryLsaLookupName() ) ;
    }

    //
    //  Hide the listbox while we mess around with it
    //
    (void) SetAndFillErrorText( IDS_GETTING_DOMAIN_INFO, FALSE ) ;

    //
    // Turn off browsing until the listbox gets filled with data
    //
    _lbAccounts.SetCount( 0 ) ;
    EnableBrowsing( FALSE ) ;
    _fUsersAreShown = FALSE ;

    SetCurrentDomainFocus( pDomainNewSelection ) ;

    //
    // disable the members button while all this goes on
    //
    _buttonMembers.Enable( FALSE ) ;
    _fEnableMembersButton = FALSE ;

    //
    //	If this browser domain isn't initialized, then initialize it
    //

    if ( !pDomainNewSelection->IsInitialized() )
    {
	if ( err = pDomainNewSelection->GetDomainInfo( this, pAdminAuth ) )
        {
            return err ;
        }
    }

    //
    //	Let the thread know we are awaiting the data
    //
    err = pDomainNewSelection->RequestAccountData() ;

    TRACEEOL("NT_USER_BROWSER_DIALOG::OnDomainChange Leave    @ " << ::GetTickCount()/100) ;
    return err ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnShowUsers

    SYNOPSIS:   This method is called when the user presses the "Show Users"
                button.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:	Note that the users are added in this thread and are not
		added to the thread's list of LBIs

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnShowUsers( void )
{
    /* We claim focus in the listbox so that when we disable the
     * button we don't lose the default focus.
     */
    AUTO_CURSOR CursorHourGlass ;
    SetDialogFocus( _lbAccounts );
    _buttonShowUsers.Enable( FALSE ) ;

    APIERR err = NERR_Success ;

    if ( err = QueryCurrentDomainFocus()->RequestAndWaitForUsers() )
    {
	DBGEOL("NT_USER_BROWSER_DIALOG::OnShowUsers - Error " << err ) ;
    }

    _lbAccounts.SetCount( _lbAccounts.QueryCurrentCache()->QueryCount() ) ;
    _fUsersAreShown = (err == NERR_Success) ;
    return err ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnSearch

    SYNOPSIS:   This method is called when the user presses the "Search"
                button.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        JonN    01-Dec-1992     Created
        JohnL   17-Mar-1993     Conditional add to cache logic

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnSearch( void )
{
    TRACEEOL("OnSearch called") ;

    NT_FIND_ACCOUNT_DIALOG * pntfinddlg = new NT_FIND_ACCOUNT_DIALOG(
                                                QueryHwnd(),
                                                this,
                                                &_cbDomains,
                                                QueryServerResourceLivesOn(),
                                                QueryFlags() );

    BOOL fChoseAdd = FALSE;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pntfinddlg != NULL
        && (err = pntfinddlg->QueryError()) == NERR_Success
        && (err = pntfinddlg->Process( &fChoseAdd )) == NERR_Success
        && fChoseAdd
       )
    {
        USER_BROWSER_LB * plbFound = pntfinddlg->QuerySourceListbox();
        UIASSERT( plbFound != NULL && plbFound->QueryError() == NERR_Success )
        if (plbFound->QuerySelCount() > 0)
        {
            TRACEEOL("OnSearch() copying from Find Accounts");

            //
            //  We only add to the cache if everything is being shown.  This
            //  prevents users from adding accounts through the search dialog
            //  that the application didn't ask for.
            //
	    err = AddSelectedUserBrowserLBIs(
                   plbFound,
                   FALSE,     // no need to copy
                   (QueryFlags() & (USRBROWS_INCL_ALL | USRBROWS_SHOW_ALL)) ==
                                       (USRBROWS_INCL_ALL | USRBROWS_SHOW_ALL) ) ;

        }
    }

    delete pntfinddlg;

    return err;
}


/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::OnMembers

    SYNOPSIS:   This method is called when the user presses the "Members"
                button.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        JonN    05-Nov-1992     Created

********************************************************************/


APIERR NT_USER_BROWSER_DIALOG::OnMembers( void )
{
    TRACEEOL("OnMembers called") ;

    USER_BROWSER_LB * plbSelGroup = NULL;
    APIERR err = NERR_Success;

    if ( _lbAccounts.QuerySelCount() == 1 )
    {
        plbSelGroup = &_lbAccounts;
    }
    else
    {
        DBGEOL("OnMembers called with improper selection") ;
        UIASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    do // false loop
    {
        if ( plbSelGroup == NULL )
            break;

        USER_BROWSER_LBI * plbi = (USER_BROWSER_LBI *) plbSelGroup->QueryItem();
        if (plbi == NULL)
        {
            UIASSERT( FALSE );
            break;
        }

        BROWSER_DOMAIN * pbdom = QueryCurrentDomainFocus();
        ASSERT( pbdom != NULL && pbdom->QueryError() == NERR_Success );

        SAM_DOMAIN * psamdomAccount = pbdom->QueryAccountDomain();
        SAM_DOMAIN * psamdomBuiltin = pbdom->QueryBuiltinDomain();
        ASSERT( psamdomAccount != NULL && psamdomAccount->QueryError() == NERR_Success );
        ASSERT( psamdomBuiltin != NULL && psamdomBuiltin->QueryError() == NERR_Success );

        NT_GROUP_BROWSER_DIALOG * pntgrpbrowdlg = NULL;
        OS_SID ossidGroup( plbi->QueryPSID(), (BOOL)FALSE);
	NLS_STR nlsQualifiedDomainName;
        if (   (err = ossidGroup.QueryError()) != NERR_Success
            || (err = nlsQualifiedDomainName.QueryError()) != NERR_Success
	    || (err = pbdom->GetQualifiedDomainName( &nlsQualifiedDomainName ))
           )
        {
            break;
        }

        switch ( plbi->QueryType() )
        {
        case SidTypeGroup:
            pntgrpbrowdlg = new NT_GLOBALGROUP_BROWSER_DIALOG(
                                    QueryHwnd(),
                                    this,
                                    nlsQualifiedDomainName.QueryPch(),
                                    plbi->QueryAccountName(),
                                    &ossidGroup,
                                    pbdom->QueryAccountDomain(),
                                    pbdom->QueryLSAPolicy(),
                                    QueryServerResourceLivesOn() );
            break;

        case SidTypeAlias:
            {
            // we must determine if the alias is in the builtin domain
            OS_SID ossidDomainOfGroup( ossidGroup.QueryPSID(), (BOOL)TRUE );
            if (   (err = ossidDomainOfGroup.QueryError()) != NERR_Success
                || (err = ossidDomainOfGroup.TrimLastSubAuthority()) != NERR_Success
               )
            {
                break;
            }

            BOOL fIsBuiltin = ( ossidDomainOfGroup == *(psamdomBuiltin->QueryOSSID()) );

            pntgrpbrowdlg = new NT_LOCALGROUP_BROWSER_DIALOG(
                                    QueryHwnd(),
                                    this,
                                    nlsQualifiedDomainName.QueryPch(),
                                    plbi->QueryAccountName(),
                                    &ossidGroup,
                                    (fIsBuiltin) ? psamdomBuiltin
                                                 : psamdomAccount,
                                    psamdomAccount,
                                    pbdom->QueryLSAPolicy(),
                                    QueryServerResourceLivesOn() );
            }

            break;

        default:
            UIASSERT( FALSE );
            break;
        }

        if ( err == NERR_Success )
        {

            BOOL fChoseAdd = FALSE;

            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pntgrpbrowdlg != NULL
                && (err = pntgrpbrowdlg->QueryError()) == NERR_Success
                && (err = pntgrpbrowdlg->Process( &fChoseAdd )) == NERR_Success
                && fChoseAdd
               )
            {
                // If the user pressed ADD in the group browser, but didn't
                // select any items there, add the group itself
                USER_BROWSER_LB * plbGroupBrowser = pntgrpbrowdlg->QuerySourceListbox();
                if (plbGroupBrowser->QuerySelCount() > 0)
                {
		    err = AddSelectedUserBrowserLBIs(
                                    plbGroupBrowser,
                                    FALSE ) ; // no need to copy, we're about
                                              // to delete the dialog + LB
                }
                else
                {
		    err = AddSelectedUserBrowserLBIs(
				    plbSelGroup,
				    TRUE ) ; // do copy here

                }
            }
        }

        delete pntgrpbrowdlg;

    } while (FALSE); // false loop

    return err ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::UpdateButtonState

    SYNOPSIS:	This updates the the set of buttons based on the current
		selection and items in each of the listboxes

    NOTES:

    HISTORY:
	Johnl	28-Oct-1992	Created

********************************************************************/

void NT_USER_BROWSER_DIALOG::UpdateButtonState( void )
{
    _buttonMembers.Enable( _lbAccounts.IsSelectionExpandableGroup() &&
                           _fEnableMembersButton ) ;

    if ( _lbAccounts.HasFocus() && _lbAccounts.QuerySelCount() > 0 )
    {
	UIASSERT( _lbAccounts.IsEnabled() ) ;
	_buttonAdd.Enable( TRUE ) ;
	_buttonAdd.MakeDefault() ;
    }
    else
    {
	if ( _lbAccounts.QuerySelCount() > 0 )
	    _buttonAdd.Enable( TRUE ) ;
	else
	{
	    //
	    // If we are about to disable the Add button and it has the focus,
	    // then set the focus to the accounts listbox (which must be
	    // enabled otherwise we wouldn't be able to press the Add button).
	    //
	    if ( _buttonAdd.HasFocus() )
	    {
		UIASSERT( _lbAccounts.IsEnabled() ) ;
                SetDialogFocus( _lbAccounts );
	    }

	    _buttonAdd.Enable( FALSE ) ;
	}

	_buttonOK.MakeDefault() ;
    }
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnAdd

    SYNOPSIS:	Removes selected items from the accounts listbox and
		adds them to the "Add" listbox

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::OnAdd( void )
{
    AUTO_CURSOR niftycursor ;
    return AddSelectedUserBrowserLBIs( &_lbAccounts, TRUE ) ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnDlgDeactivation

    SYNOPSIS:	We hook the WM_ACTIVATE message

    HISTORY:
        JonN    06-Oct-1993     Created

********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnDlgDeactivation( const ACTIVATION_EVENT & ae )
{
    TRACEEOL( "NT_USER_BROWSER_DIALOG:: OnDlgDeactivation" );
    _hwndLastFocus = ::GetFocus() ;

    return DIALOG_WINDOW::OnDlgDeactivation( ae );
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::AddSelectedUserBrowserLBIs

    SYNOPSIS:	Takes the currently selected items in plbUserBrowser and
		relocates them to *this

    ENTRY:	plbUserBrowser - Listbox to take selected items from
		fCopy	       - TRUE to not delete from plbUserBrowser,
                                 FALSE to delete the LBIs from plbUserBrowser
                fAddToCache    - TRUE to add to cache (won't be checked for
                                    correctness OnOK)
                                 FALSE to force re-evaluation OnOK.

    EXIT:	plbUserBrowser will have the selected items removed

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

APIERR NT_USER_BROWSER_DIALOG::AddSelectedUserBrowserLBIs(
					     USER_BROWSER_LB * plbUserBrowser,
                                             BOOL fCopy,
                                             BOOL fAddToCache  )
{
    UIASSERT( plbUserBrowser != NULL ) ;
    APIERR err ;

    INT cSel = plbUserBrowser->QuerySelCount() ;
    NLS_STR nlsNames( cSel * 100 ) ;
    if ( (err = nlsNames.QueryError()) ||
	 ( !_mleAdd.IsSingleSelect() && (err = _mleAdd.QueryText( &nlsNames ))) )
    {
	return err ;
    }

    BUFFER buffSelection(  cSel * sizeof( INT )) ;

    do {  // error breakout

	if ( err = buffSelection.QueryError() )
	    break ;

	INT * pSel = (INT *) buffSelection.QueryPtr() ;
	if ( err = plbUserBrowser->QuerySelItems( pSel, cSel ) )
	{
	    break ;
	}

	for ( INT i = cSel-1 ; i >= 0 ; i-- )
	{
	    USER_BROWSER_LBI * plbi ;

	    if ( fCopy )
	    {
		plbi = (USER_BROWSER_LBI*) plbUserBrowser->QueryItem( pSel[i] ) ;
		UIASSERT( plbi != NULL ) ;

		//
		// Refuse to deal with any error LBIs
		//
		if ( plbi == plbUserBrowser->QueryErrorLBI() )
		    return NERR_Success ;

		USER_BROWSER_LBI * plbiNew = new USER_BROWSER_LBI(
					    plbi->QueryAccountName(),
					    plbi->QueryFullName(),
					    plbi->QueryDisplayName(),
					    plbi->QueryComment(),
					    plbi->QueryDomainName(),
					    plbi->QueryPSID(),
					    plbi->QueryUISysSid(),
					    plbi->QueryType(),
					    plbi->QueryUserAccountFlags() ) ;
		plbi = plbiNew ;
	    }
	    else
	    {
		plbi = (USER_BROWSER_LBI*) plbUserBrowser->RemoveItem( pSel[i] ) ;
		UIASSERT( plbi != NULL ) ;

		//
		// Refuse to deal with any error LBIs
		//
		if ( plbi == plbUserBrowser->QueryErrorLBI() )
		    return NERR_Success ;
	    }

	    //
	    //	We do the display name first because plbi may get deleted
	    //	after the AddItemIdemp if it is a duplicate
	    //
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    if ( plbi == NULL ||
		 (err = plbi->QueryError()) ||
                 (err = plbi->QualifyDisplayName()))
	    {
		delete plbi ;
		break ;
	    }

            if ( fAddToCache &&
                 (err = _slUsrBrowserLBIsCache.Add( plbi )) )
            {
		delete plbi ;
		break ;
	    }

	    //
	    //	Append to the current name list
	    //

	    if ( ((_mleAdd.QueryTextLength() != 0) || (nlsNames.strlen() != 0)) &&
		 !_mleAdd.IsSingleSelect() )
	    {
		//
		//  Only prefix the "; " if this isn't the first name
		//
		if ( (err = nlsNames.AppendChar( TCH(';') )) ||
		     (err = nlsNames.AppendChar( TCH(' ') ))   )
		{
		    break ;
		}
	    }

	    ALIAS_STR nlsDisplayName( plbi->QueryDisplayName() ) ;
	    if ( err = nlsNames.Append( nlsDisplayName ) )
	    {
		break ;
	    }

	    //
	    //	Only add one name if we are single select
	    //
	    if ( _mleAdd.IsSingleSelect() )
		break ;
	}

    } while (FALSE) ;

    if ( !err )
    {
	_mleAdd.SetText( nlsNames ) ;
	plbUserBrowser->RemoveSelection() ;
    }

    return err ;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::FindDomain

    SYNOPSIS:	Looks in the combobox for the item corresponding to this
                domain, then returns a BROWSER_DOMAIN *.

    RETURNS:	NULL if the domain cannot be found

    NOTES:

    HISTORY:
        JonN    06-Nov-1992     Created

********************************************************************/

BROWSER_DOMAIN * NT_USER_BROWSER_DIALOG::FindDomain( const OS_SID * possid )
{
    UIASSERT( possid != NULL && possid->QueryError() == NERR_Success ) ;

    INT cDomains = _cbDomains.QueryCount();
    for (INT i = 0; i < cDomains; i++)
    {
        BROWSER_DOMAIN_LBI * plbi =
                (BROWSER_DOMAIN_LBI *)_cbDomains.QueryItem( i );
        ASSERT( plbi != NULL );
        BROWSER_DOMAIN * pbdom = plbi->QueryBrowserDomain();
        ASSERT( pbdom != NULL );
        if ( (*possid) == *(pbdom->QueryDomainSid()) )
            return pbdom;
    }

    TRACEEOL("FindDomain(): domain not found");
    return NULL;
}

/*******************************************************************

    NAME:	NT_USER_BROWSER_DIALOG::OnOK

    SYNOPSIS:	Selects all of the items in the Add dialog if it is present.

    NOTES:

    HISTORY:
	Johnl	28-Oct-1992	Created

********************************************************************/

BOOL NT_USER_BROWSER_DIALOG::OnOK( void )
{
    APIERR err = NERR_Success ;
    APIERR errFailingName = NERR_Success ;
    AUTO_CURSOR niftycursor ;

    do { // error breakout

	NLS_STR nlsFailingName ;
	if ((err = nlsFailingName.QueryError()) ||
	    (err = _mleAdd.CreateLBIListFromNames(
				QueryServerResourceLivesOn(),
				QueryCurrentDomainFocus()->QueryLsaLookupName(),
				&_slUsrBrowserLBIsCache,
				&_slUsrBrowserLBIs,
				&errFailingName,
				&nlsFailingName )) )
	{
	    break ;
	}

	if ( errFailingName )
	{
            SetDialogFocus( _mleAdd );
	    ::MsgPopup( this,
			(MSGID) errFailingName,
			MPSEV_ERROR,
			MP_OK,
			nlsFailingName ) ;

#ifdef EM_SCROLLCARET
	    // The manifest isn't defined and the code in user is commented
	    // out (12/05/92).
	    _mleAdd.Command( EM_SCROLLCARET ) ;
#endif

	}

    } while (FALSE) ;

    if ( err )
	::MsgPopup( this, (MSGID) err ) ;
    else if ( !errFailingName )
	Dismiss( TRUE ) ;

    return TRUE ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical help context query for this dialog

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

ULONG NT_USER_BROWSER_DIALOG::QueryHelpContext( void )
{
    return _ulHelpContext ;
}

/*******************************************************************

    NAME:       NT_USER_BROWSER_DIALOG::QueryHelpFileName

    SYNOPSIS:   Returns the help file name to use for this instance of
                dialog

    NOTES:

    HISTORY:
        Johnl   03-Sep-1992     Created

********************************************************************/

const TCHAR * NT_USER_BROWSER_DIALOG::QueryHelpFile( ULONG ulHelpContext )
{
    UNREFERENCED( ulHelpContext ) ;
    return _pszHelpFileName ;
}


/*******************************************************************

    NAME:       BROWSER_DOMAIN::BROWSER_DOMAIN

    SYNOPSIS:   Standard constructor/destructor for the BROWSER_DOMAIN class.

    ENTRY:      pszDomainName - Name of this domain
                psidDomain - SID of this domain (maybe unecessary)
                fAliasesAreEnumerated - TRUE if aliases should be enumerated
                    on this domain

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

BROWSER_DOMAIN::BROWSER_DOMAIN( const TCHAR * pszDomainName,
                                      PSID    psidDomain,
                                      BOOL    fIsTargetDomain,
                                      BOOL    fIsWinNTMachine )
    : _nlsDomainName        ( pszDomainName ),
      _nlsDisplayName	    ( pszDomainName ),
      _nlsLsaDomainName     ( pszDomainName ),
      _ossidDomain          ( psidDomain, TRUE ),
      _fIsTargetDomain      ( fIsTargetDomain ),
      _fIsWinNT 	    ( fIsWinNTMachine ),
      _pFillDomainThread    ( NULL )

{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _nlsDomainName.QueryError() )	||
	 (err = _nlsLsaDomainName.QueryError()) ||
         (err = _ossidDomain.QueryError())      )
    {
        ReportError( err ) ;
        return ;
    }

    //
    //	If the domain name is NULL then get the machine name from Windows
    //
    if ( pszDomainName == NULL )
    {
	TCHAR achComputerName[ MAX_COMPUTERNAME_LENGTH+1 ] ;
	DWORD cchComputerName = sizeof( achComputerName ) / sizeof(TCHAR) ;

	if ( !::GetComputerName( achComputerName, &cchComputerName ))
	{
	    ReportError( ::GetLastError() ) ;
	    return ;
	}

	if ( (err = _nlsDisplayName.CopyFrom( (const TCHAR *) achComputerName)) ||
	     (err = _nlsLsaDomainName.CopyFrom( (const TCHAR *) achComputerName)) )
        {
            ReportError( err ) ;
            return ;
        }

	//
	//  Add "\\"'s if they are not already there
	//
        ISTR istrDisplayName( _nlsDisplayName ) ;
        if ( _nlsDisplayName.QueryChar( istrDisplayName ) != TCH('\\') )
        {
            ALIAS_STR nlsWhackWhack( SZ("\\\\") ) ;
            if ( ! _nlsDisplayName.InsertStr( nlsWhackWhack,
                                                  istrDisplayName ) )
            {
                ReportError( _nlsDisplayName.QueryError() ) ;
                return ;
            }
        }
    }
    else if ( pszDomainName[0] == TCH('\\') && pszDomainName[1] == TCH('\\'))
    {
	//
	//  If the domain name begins with '\\' (we're looking at a workgroup),
	//  then strip them so the LSA is happy
	//
	if ( err = _nlsLsaDomainName.CopyFrom( (const TCHAR *) pszDomainName+2) )
	{
	    ReportError( err ) ;
	    return ;
	}
    }


    /* Mark the target domain appropriately
     */
    if ( fIsTargetDomain &&
         (err = SetAsTargetDomain()) )
    {
        ReportError( err ) ;
        return ;
    }
}

BROWSER_DOMAIN::~BROWSER_DOMAIN()
{
    if ( _pFillDomainThread != NULL )
    {
	//
	//  Tell the thread we are going away.	
	//
	//  Don't delete _pFillDomainThread.  It will delete itself
	//

	(void) _pFillDomainThread->ExitThread() ;

	_pFillDomainThread = NULL ;
    }
}

/*******************************************************************

    NAME:       BROWSER_DOMAIN::SetAsTargetDomain

    SYNOPSIS:   Marks this domain as the target domain

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   07-May-1992     Moved to private method

********************************************************************/

APIERR BROWSER_DOMAIN::SetAsTargetDomain( void )
{
    _fIsTargetDomain = TRUE ;
    return _nlsDisplayName.AppendChar( ALIAS_MARKER_CHAR ) ;
}

/*******************************************************************

    NAME:       BROWSER_DOMAIN::GetDomainInfo

    SYNOPSIS:	Creates a domain thread for this domain

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The server used for this domain is the PDC of the domain

    HISTORY:
        Johnl   30-Mar-1992     Created

********************************************************************/

APIERR BROWSER_DOMAIN::GetDomainInfo( NT_USER_BROWSER_DIALOG * pdlg,
					const ADMIN_AUTHORITY * pAdminAuth )
{
    //
    // Create thread for this domain if we haven't already done so
    //
    APIERR err = NERR_Success ;

    if ( _pFillDomainThread == NULL )
    {
	_pFillDomainThread = new DOMAIN_FILL_THREAD( pdlg, this, pAdminAuth ) ;

	err = ERROR_NOT_ENOUGH_MEMORY ;
	if ( _pFillDomainThread == NULL ||
	     (err = _pFillDomainThread->QueryError()) ||
             (err = _pFillDomainThread->Resume()) )
	{
	    delete _pFillDomainThread ;
	    _pFillDomainThread = NULL ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN::GetQualifiedDomainName

    SYNOPSIS:	Returns the domain name in yet another form

    ENTRY:	pnlsDomainName - String to receive domain name

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	20-Oct-1992	Created

********************************************************************/

APIERR BROWSER_DOMAIN::GetQualifiedDomainName( NLS_STR * pnlsDomainName )
{
    //
    //	The display name has what we want except it may have the "\\" or
    //	"*" which we will need to strip
    //
    NLS_STR nlsDomain( QueryDisplayName()[0] == TCH('\\') ?
						QueryDisplayName() + 2 :
						QueryDisplayName()) ;

    if ( IsTargetDomain() )
    {
	ISTR istr( nlsDomain ) ;

	if ( nlsDomain.strrchr( &istr, ALIAS_MARKER_CHAR ) )
	    nlsDomain.DelSubStr( istr ) ;
    }

    return pnlsDomainName->CopyFrom( nlsDomain ) ;
}

/*******************************************************************

    NAME:       BROWSER_SUBJECT_ITER::BROWSER_SUBJECT_ITER

    SYNOPSIS:   Typical constructor/destructor

    ENTRY:      pNtUserBrowserDialog - Pointer to a user browser dialog
                that the user just pressed OK on.

    NOTES:

    HISTORY:
        Johnl   05-Mar-1992     Created

********************************************************************/

BROWSER_SUBJECT_ITER::BROWSER_SUBJECT_ITER(
                                NT_USER_BROWSER_DIALOG * pNtUserBrowserDialog )
    : _pUserBrowserDialog( pNtUserBrowserDialog ),
      _BrowserSubject	 (),
      _iterUserBrowserLBIs( *_pUserBrowserDialog->QuerySelectionList() )
{
    if ( QueryError() )
        return ;

    UIASSERT( pNtUserBrowserDialog != NULL ) ;
    UIASSERT( !pNtUserBrowserDialog->QueryError() ) ;
}

BROWSER_SUBJECT_ITER::~BROWSER_SUBJECT_ITER()
{
    _pUserBrowserDialog = NULL ;
}

/*******************************************************************

    NAME:       BROWSER_SUBJECT_ITER::Next

    SYNOPSIS:   Returns the next item in the selection of the listbox

    ENTRY:      ppBrowserSubject - Pointer to a pointer to receive a
                    BROWSER_SUBJECT object.  Do not free this memory.

    EXIT:

    RETURNS:    NERR_Success if successful error code otherwise.

                If NERR_Success is returned, then check *ppBrowserSubject
                for NULL.  If it is NULL, then the iteration is finished.

                If an error code is returned, then *ppBrowserSubject is not
                initialized.

    NOTES:

    HISTORY:
        Johnl   05-Mar-1992     Created

********************************************************************/

APIERR BROWSER_SUBJECT_ITER::Next( BROWSER_SUBJECT ** ppBrowserSubject )
{
    //
    //	If we have finished the iteration, get, out.
    //
    USER_BROWSER_LBI * plbi ;
    if ( (plbi = _iterUserBrowserLBIs.Next()) == NULL )
    {
        *ppBrowserSubject = NULL ;
        return NERR_Success ;
    }

    APIERR err = NERR_Success ;
    if ( !(err = _BrowserSubject.SetUserBrowserLBI( plbi )) )
    {
	*ppBrowserSubject = &_BrowserSubject ;
    }

    return err ;
}


/*******************************************************************

    NAME:       BROWSER_SUBJECT::BROWSER_SUBJECT

    SYNOPSIS:   Standard constructor/destructor

    ENTRY:

    NOTES:

    HISTORY:
        JohnL   05-Mar-1992     Created

********************************************************************/

BROWSER_SUBJECT::BROWSER_SUBJECT()
    : _ossidAccount	( NULL		 ),
      _ossidDomain	( NULL		 ),
      _pUserBrowserLBI	( NULL		 )
{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _ossidAccount.QueryError() )  ||
	 (err = _ossidDomain.QueryError()) )
    {
        DBGEOL( "BROWSER_SUBJECT::ct - error constructing private member" ) ;
        ReportError( err ) ;
        return ;
    }
}


BROWSER_SUBJECT::~BROWSER_SUBJECT()
{
    /* Nothing to do
     */
}

/*******************************************************************

    NAME:	BROWSER_SUBJECT::SetUserBrowserLBI

    SYNOPSIS:	Sets up this browser subject so it can be used in an iteration

    ENTRY:	pUserBrowserLBI - Pointer to select we are enumerating

    EXIT:	_ossidAccount will be set up with the account SID and
		_ossidDomain will be set up with the domain SID for this
		account

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	20-Oct-1992	Created

********************************************************************/

APIERR BROWSER_SUBJECT::SetUserBrowserLBI( USER_BROWSER_LBI * pUserBrowserLBI )
{
    UIASSERT( pUserBrowserLBI != NULL ) ;

    _pUserBrowserLBI = pUserBrowserLBI ;

    APIERR err ;
    UCHAR * pcSubAuthority ;
    if ( (err = _ossidAccount.SetPtr( pUserBrowserLBI->QueryPSID() )) ||
	 (err = _ossidDomain.Copy( _ossidAccount ))		      ||
	 (err = _ossidDomain.QuerySubAuthorityCount( &pcSubAuthority )) )
    {
	return err ;
    }

    /* Make the account SID into the domain SID.
     */
    *pcSubAuthority -= 1 ;

    return err ;
}

/*******************************************************************

    NAME:       BROWSER_SUBJECT::QueryQualifiedName

    SYNOPSIS:   Gives a suitable name for immediately displaying this
                subject, complete with domain prefix and user name, if
                desired.

    ENTRY:      pnlsQualifiedName - NLS_STR to receive the qualified name
                pnlsDomainName - Name of the "Focused" domain (i.e., where
                                 the app is focused)
                fShowFullName - TRUE if the full name should be included

    EXIT:       pnlsQualifiedName will contain the fully qualified name

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   10-Jun-1992     Created

********************************************************************/

APIERR BROWSER_SUBJECT::QueryQualifiedName(
                                 NLS_STR * pnlsQualifiedName,
                           const NLS_STR * pnlsDomainName,
                                 BOOL      fShowFullName ) const
{
    UIASSERT( pnlsQualifiedName != NULL ) ;
    UIASSERT( _pUserBrowserLBI != NULL ) ;

    APIERR err ;

    /* Well known SIDs don't get the domain prefix
     */
    if ( QueryType() != SidTypeWellKnownGroup)
    {
	ALIAS_STR nlsDomainAccountIsOn( QueryDomainName() ) ;
	ALIAS_STR nlsAccountName( QueryAccountName() ) ;
	ALIAS_STR nlsFullName	( QueryFullName() ) ;
        err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                                     pnlsQualifiedName,
						     nlsAccountName,
                                                     nlsDomainAccountIsOn,
						     fShowFullName ? &nlsFullName
                                                                   : NULL,
                                                     pnlsDomainName ) ;
    }
    else
    {
	err = pnlsQualifiedName->CopyFrom( QueryAccountName() ) ;
    }

    return err ;
}


/*************************************************************************

    NAME:	BROWSER_DOMAIN_CB

    SYNOPSIS:   This listbox lists users, groups, aliases and well known SIDs.

    INTERFACE:

    PARENT:	BLT_COMBOBOX

    USES:       DISPLAY_MAP

    CAVEATS:

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

**************************************************************************/

BROWSER_DOMAIN_CB::BROWSER_DOMAIN_CB( OWNER_WINDOW * powin,
				      CID cid )
    : BLT_COMBOBOX	( powin, cid ),
      _dmDomain 	( BMID_DOMAIN_CANNOT_EXPAND ),
      _dmComputer	( BMID_SERVER )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    if ( (err = _dmDomain.QueryError())    ||
	 (err = _dmComputer.QueryError())  ||
         (err = DISPLAY_TABLE::CalcColumnWidths( (UINT *) QueryColWidthArray(),
						 2,
                                                 powin,
                                                 QueryCid(),
                                                 TRUE )) )
    {
        ReportError( err ) ;
        return ;
    }
}

BROWSER_DOMAIN_CB::~BROWSER_DOMAIN_CB()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_CB::AddItem

    SYNOPSIS:	Adds the browser domain to the combo

    ENTRY:	pBrowDomain - heap allocated browser domain to add

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	This method will check for successful allocation and
		construction of the browser domain

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

APIERR BROWSER_DOMAIN_CB::AddItem( BROWSER_DOMAIN * pBrowDomain )
{
    if ( pBrowDomain == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    APIERR err ;
    if ( err = pBrowDomain->QueryError())
	return err ;

    if ( BLT_COMBOBOX::AddItem( new BROWSER_DOMAIN_LBI( pBrowDomain )) == -1 )
    {
	err = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return err ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_CB::SelectItem

    SYNOPSIS:	Selects the item in the combo box that points to pBrowDomain

    ENTRY:	pBrowDomain - Item to select

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

void BROWSER_DOMAIN_CB::SelectItem( BROWSER_DOMAIN * pBrowDomain )
{
    INT cItems = QueryCount() ;

    for ( INT i = 0 ; i < cItems ; i++ )
    {
	BROWSER_DOMAIN_LBI * plbi = (BROWSER_DOMAIN_LBI*) QueryItem( i ) ;
	if ( plbi->QueryBrowserDomain() == pBrowDomain )
	{
	    BLT_COMBOBOX::SelectItem( i, TRUE ) ;
	    return ;
	}
    }

    UIASSERT( FALSE ) ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_CB::QueryDisplayMap

    SYNOPSIS:	Returns the appropriate display map to use for this
		browser domain

    RETURNS:	Pointer to appropriate display map

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

DISPLAY_MAP * BROWSER_DOMAIN_CB::QueryDisplayMap(const BROWSER_DOMAIN_LBI * plbi )
{
    DISPLAY_MAP * pdmap = &_dmDomain ;
    if ( plbi->QueryBrowserDomain()->IsWinNTMachine() )
	pdmap = &_dmComputer ;

    return pdmap ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::~BROWSER_DOMAIN_LBI

    SYNOPSIS:	Deletes _pBrowDomain member

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

BROWSER_DOMAIN_LBI::~BROWSER_DOMAIN_LBI()
{
    delete _pBrowDomain ;
    _pBrowDomain = NULL ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::Paint

    SYNOPSIS:   Typical LBI Paint method

    NOTES:

    HISTORY:
	Johnl	27-Oct-1992	Created
        JonN    04-Dec-1992     W_Paint worker function

********************************************************************/

VOID BROWSER_DOMAIN_LBI::Paint(
                    LISTBOX * plb,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    W_Paint( (BROWSER_DOMAIN_CB *)plb, plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::W_Paint

    SYNOPSIS:   Paint worker function, called directly by piggyback LBI

    ENTRY:      pcbBrowser - User Browser combobox containing bitmaps
                plbActual  - Listbox which actually contains LBI to be drawn

    NOTES:

    HISTORY:
        JonN    04-Dec-1992     Created

********************************************************************/

VOID BROWSER_DOMAIN_LBI::W_Paint(
                    BROWSER_DOMAIN_CB * pcbBrowser,
                    LISTBOX * plbActual,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    STR_DTE strdteName( QueryDisplayName() ) ;
    DM_DTE  dmdteIcon( pcbBrowser->QueryDisplayMap( this ) ) ;

    DISPLAY_TABLE dt( 2, pcbBrowser->QueryColWidthArray()) ;
    dt[0] = & dmdteIcon ;
    dt[1] = & strdteName ;

    dt.Paint( plbActual, hdc, prect, pGUILTT ) ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::Compare

    SYNOPSIS:   Typical LBI compare for user browser listbox

    NOTES:      This method will sort all user sid types to the end of
                the list

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

INT BROWSER_DOMAIN_LBI::Compare( const LBI * plbi ) const
{
    BROWSER_DOMAIN_LBI * pubrowLBI = (BROWSER_DOMAIN_LBI*) plbi ;

    return ::stricmpf( QueryDisplayName(), pubrowLBI->QueryDisplayName() ) ;
}

/*******************************************************************

    NAME:	BROWSER_DOMAIN_LBI::QueryLeadingChar

    SYNOPSIS:   Typical QueryLeadingChar method

    HISTORY:
	Johnl	27-Oct-1992	Created

********************************************************************/

WCHAR BROWSER_DOMAIN_LBI::QueryLeadingChar( void ) const
{
    return QueryDisplayName()[0] ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\w32handl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32handl.cxx
    Class definitions for the WIN32_HANDLE class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_HANDLE methods.
//

/*******************************************************************

    NAME:       WIN32_HANDLE :: WIN32_HANDLE

    SYNOPSIS:   WIN32_HANDLE class constructor.

    ENTRY:      hGeneric                - The Win32 Handle.

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_HANDLE :: WIN32_HANDLE( HANDLE hGeneric )
   : _hGeneric( NULL )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    SetHandle( hGeneric );

}   // WIN32_HANDLE :: WIN32_HANDLE


/*******************************************************************

    NAME:       WIN32_HANDLE :: ~WIN32_HANDLE

    SYNOPSIS:   WIN32_HANDLE class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_HANDLE :: ~WIN32_HANDLE()
{
    if( QueryHandle() != NULL )
    {
        Close();
    }

}   // WIN32_HANDLE :: ~WIN32_HANDLE


/*******************************************************************

    NAME:       WIN32_HANDLE :: Close

    SYNOPSIS:   Close the handle associated with this object.

    EXIT:       If successful, then the handle has been closed.

    RETURNS:    APIERR                  - Error code if handle could
                                          not be closed.

    NOTES:      If the handle was successfully closed, then the handle
                value is set to NULL.

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_HANDLE :: Close( VOID )
{
    APIERR err = NO_ERROR;

    UIASSERT( QueryHandle() != NULL );

    if( !::CloseHandle( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    if( err == NO_ERROR )
    {
        SetHandle( NULL );
    }

    return err;

}   // WIN32_HANDLE :: Close
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\usrlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    usrlb.cxx

    Basic User Browser listbox



    FILE HISTORY:
        Johnl   08-Dec-1992     Created
        jonn        14-Oct-1993 Moved bitmaps to SUBJECT_BITMAP_BLOCK

*/

#include "pchapplb.hxx"   // Precompiled header
#include "browmemb.hxx"
#include "bmpblock.hxx"   // SUBJECT_BITMAP_BLOCK

#ifndef min
    #define min(a,b)  ((a)<=(b) ? (a) : (b))
#endif

static WCHAR IsCharPrintableOrSpace( WCHAR wch ) ;


//
// The following defines are used in the slow mode timing heuristics in
// AddAliases and AddGroups.  A timer determines how long it takes
// to read in each batch of alias/group accounts.  If this time is less
// that READ_MORE_MSEC, we double the number of bytes requested on the
// next call.  If it is more than READ_LESS_MSEC, we halve it.
//

#define USRBROWS_ALIASES_INITIAL_COUNT  2048
#define USRBROWS_ALIASES_MIN_COUNT       512
#define USRBROWS_ALIASES_MAX_COUNT      0xFFFF /* 64K */
#define USRBROWS_ALIASES_READ_MORE_MSEC 1000
#define USRBROWS_ALIASES_READ_LESS_MSEC 5000

#define USRBROWS_GROUPS_INITIAL_COUNT   USRBROWS_ALIASES_INITIAL_COUNT
#define USRBROWS_GROUPS_MIN_COUNT       USRBROWS_ALIASES_MIN_COUNT
#define USRBROWS_GROUPS_MAX_COUNT       USRBROWS_ALIASES_MAX_COUNT
#define USRBROWS_GROUPS_READ_MORE_MSEC  USRBROWS_ALIASES_READ_MORE_MSEC
#define USRBROWS_GROUPS_READ_LESS_MSEC  USRBROWS_ALIASES_READ_LESS_MSEC


class USRLB_NT_GROUP_ENUM : public NT_GROUP_ENUM
{
protected:

    virtual APIERR QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall );      // how many milliseconds last call took

public:

    USRLB_NT_GROUP_ENUM( const SAM_DOMAIN * psamdomain )
        : NT_GROUP_ENUM( psamdomain )
        {}

    ~USRLB_NT_GROUP_ENUM()
        {}

};  // class NT_GROUP_ENUM


APIERR USRLB_NT_GROUP_ENUM::QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    return QueryCountPreferences2( pcEntriesRequested,
                                   pcbBytesRequested,
                                   nNthCall,
                                   cLastEntriesRequested,
                                   cbLastBytesRequested,
                                   msTimeLastCall );
}



/*************************************************************************

    NAME:       USER_BROWSER_LB

    SYNOPSIS:   This listbox lists users, groups, aliases and well known SIDs.

    INTERFACE:

    PARENT:     BLT_LISTBOX_HAW

    USES:       DISPLAY_MAP

    CAVEATS:

    NOTES:

    HISTORY:
        Johnl   20-Oct-1992     Created

**************************************************************************/

USER_BROWSER_LB::USER_BROWSER_LB( OWNER_WINDOW * powin, CID cid )
    : LAZY_LISTBOX      ( powin, cid ),
      _pbmpblock        ( NULL ),
      _plbicacheCurrent ( NULL ),
      _plbiError        ( NULL ),
      _hawinfo          ( )
{
    APIERR err = NERR_Success ;

    if ((err = _hawinfo.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }

    RESOURCE_STR nls( ERROR_NOT_ENOUGH_MEMORY ) ;
    OS_SID ossid ;
    if ( (err = DISPLAY_TABLE::CalcColumnWidths( (UINT *) QueryColWidthArray(),
                                                 3,
                                                 powin,
                                                 QueryCid(),
                                                 TRUE ))  ||
         (err = nls.QueryError()) ||
         (err = ossid.QueryError()) ||
         (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins, &ossid )) )
    {
        ReportError( err ) ;
        return ;
    }

    err = ERROR_NOT_ENOUGH_MEMORY ;
    _pbmpblock = new SUBJECT_BITMAP_BLOCK();
    _plbiError = new USER_BROWSER_LBI( nls, SZ(""), nls, SZ(""), SZ(""),
                                       ossid.QueryPSID(), UI_SID_Admins,
                                       SidTypeAlias ) ;
    if ( (_plbiError == NULL) ||
         (_pbmpblock == NULL) ||
         (err = _pbmpblock->QueryError()) ||
         (err = _plbiError->QueryError()) )
    {
        ReportError( err ) ;
        delete _plbiError ;
        _plbiError = NULL ;
        return ;
    }


}

USER_BROWSER_LB::~USER_BROWSER_LB()
{
    delete _pbmpblock;
    delete _plbiError ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::QueryDisplayMap

    SYNOPSIS:   Retrieves the correct display map based on the LBI type

    ENTRY:      plbi - Pointer to LBI we are getting the display map for

    RETURNS:    Pointer to the appropriate display map

    NOTES:

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

DISPLAY_MAP * USER_BROWSER_LB::QueryDisplayMap(
                                             const USER_BROWSER_LBI * plbi )
{
    UIASSERT( plbi != NULL ) ;

    return _pbmpblock->QueryDisplayMap( plbi->QueryType(),
                                        plbi->QueryUISysSid(),
                                        !!(plbi->QueryUserAccountFlags()
                                            & USER_TEMP_DUPLICATE_ACCOUNT) );
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::IsSelectionExpandableGroup

    SYNOPSIS:   Checks to see if the Members button should be enabled

    RETURNS:    TRUE if this is a group that can have its members viewed

    HISTORY:
        Johnl   28-Oct-1992     Created

********************************************************************/

BOOL USER_BROWSER_LB::IsSelectionExpandableGroup(
                                      const USER_BROWSER_LBI * plbi,
                                      INT   cSelItems ) const
{
    return (plbi != NULL)           &&
           (cSelItems == 1)         &&
           (plbi->QueryType() == SidTypeAlias ||
            plbi->QueryType() == SidTypeGroup) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::QueryItem

    SYNOPSIS:   This method provides the typical QueryItem funcitonality for
                the listbox.

    ENTRY:      i - LBI index being requested

    RETURNS:    Pointer to LBI

    NOTES:      If an error occurs getting the LBI, then _plbiError will be
                returned, which simply as an account name indicating no
                memory is available.

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

USER_BROWSER_LBI * USER_BROWSER_LB::QueryItem( INT i ) const
{
    USER_BROWSER_LBI * plbi ;
    if (  QueryCurrentCache() == NULL ||
         (plbi = (USER_BROWSER_LBI*) QueryCurrentCache()->QueryItem( i )) == NULL )
    {
        return _plbiError ;
    }

    return plbi ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LB::OnNewItem

    SYNOPSIS:   The lazy listbox is requesting an LBI, return it

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

LBI * USER_BROWSER_LB::OnNewItem( UINT i )
{
    return (LBI *) QueryItem( i ) ;
}

INT USER_BROWSER_LB::CD_Char( WCHAR wch, USHORT nLastPos )
{
    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo ) ;
}


/**********************************************************************

    NAME:       IsCharPrintableOrSpace

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        JonN        30-Dec-1992 Templated from bltlb.cxx

**********************************************************************/

static WCHAR IsCharPrintableOrSpace( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) >= (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);
TRACEEOL( "IsCharPrintableOrSpace(" << (DWORD)wch << ") returns " << nType );

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK)));
#endif
}


/**********************************************************************

    NAME:       USER_BROWSER_LB::CD_Char_HAWforHawaii

    SYNOPSIS:   Custom-draw code to respond to a typed character
                for listboxes with HAW-for-Hawaii support

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position
                phawinfo - Pointer to info buffer used internally
                           to keep track of HAW-for-Hawaii state.
                           This must have constructed successfully,
                           but the caller need not keep closer track.

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

        CODEWORK:  Should be moved to LAZY_LISTBOX class, where this can be
                   implemented more efficiently

    HISTORY:
        JonN        30-Dec-1992 Templated from BLT_LISTBOX

**********************************************************************/

INT USER_BROWSER_LB::CD_Char_HAWforHawaii( WCHAR wch,
                                           USHORT nLastPos,
                                           HAW_FOR_HAWAII_INFO * phawinfo )
{
    UIASSERT( phawinfo != NULL && phawinfo->QueryError() == NERR_Success );

    if ( QueryCurrentCache() == NULL )
    {
        return -2;
    }
    if (wch == VK_BACK)
    {
        phawinfo->_time = 0L; // reset timer
        phawinfo->_nls = SZ("");
        UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );
        TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: backspace" );
        return 0; // go to first LBI
    }

    // Filter characters which won't appear in keys

    if ( ! IsCharPrintableOrSpace( wch ))
        return -2;  // take no other action

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    LONG lTime = ::GetMessageTime();

#define ThresholdTime 2000

    if ( (lTime - phawinfo->_time) > ThresholdTime )
    {
        TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: threshold timeout" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    APIERR err = phawinfo->_nls.AppendChar( wch );
    if (err != NERR_Success)
    {
        DBGEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: could not extend phawinfo->_nls" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );

    TRACEEOL(   "USER_BROWSER_LB::CD_Char_HAWforHawaii: phawinfo->_nls is \""
             << phawinfo->_nls.QueryPch()
             << "\"" );

    phawinfo->_time = lTime;

    // If this is a single-character search, start search with next entry
    if ( phawinfo->_nls.strlen() <= 1 )
    {
        nLastPos++;
    }

    UNICODE_STRING ustrFind0 ;
    ustrFind0.Length        = (USHORT)phawinfo->_nls.strlen() ;
    ustrFind0.MaximumLength = ustrFind0.Length + sizeof( TCHAR ) ;
    ustrFind0.Buffer        = (PWSTR) phawinfo->_nls.QueryPch() ;

    INT nReturn = -2; // take no other action

    for ( INT iLoop = nLastPos; iLoop < clbi; iLoop++ )
    {
        UNICODE_STRING ustrFind1 ;
        ULC_ENTRY_BASE * pulc = QueryCurrentCache()->QueryEntryPtr( iLoop );
        if ( pulc->pddu != NULL )
        {
            ustrFind1.Length        = pulc->pddu->LogonName.Length ;
            ustrFind1.MaximumLength = pulc->pddu->LogonName.MaximumLength ;
            ustrFind1.Buffer        = pulc->pddu->LogonName.Buffer ;

            if ( ustrFind1.Buffer == NULL )
                continue ;
        }
        else if ( pulc->plbi != NULL )
        {
            USER_BROWSER_LBI * plbi = (USER_BROWSER_LBI*) pulc->plbi ;
            plbi->AliasUnicodeStrToDisplayName( &ustrFind1 ) ;
        }
        else
        {
            UIASSERT( FALSE ) ;
            return 0 ;
        }

        if ( ustrFind1.Length >= ustrFind0.Length )
        {
            INT n = ::strnicmpf( ustrFind0.Buffer,
                                 ustrFind1.Buffer,
                                 ustrFind0.Length / sizeof(TCHAR) );
            if (n == 0)
            {
                //  Return index of item, on which the system listbox should
                //  perform the default action.
                //
                TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: match at " << iLoop );
                return ( iLoop );
            }
            else if (n < 0)
            {
                if (nReturn < 0)
                    nReturn = iLoop;
            }
        }
    }

    //  The character was not found as a leading prefix of any listbox item

    TRACEEOL( "USER_BROWSER_LB::CD_Char_HAWforHawaii: no match, returning " << nReturn );

    //  If all LBIs were less than this string, then jump to the end
    return (nReturn == -2) ? clbi-1 : nReturn;
}


/*******************************************************************

    NAME:       USER_BROWSER_LB::CD_VKey

    SYNOPSIS:   Handles the backspace key

    ENTRY:      nVKey -         Virtual key that was pressed
                nLastPos -      Previous listbox cursor position

    RETURNS:    Return value appropriate to WM_VKEYTOITEM message:
                -2      ==> listbox should take no further action
                -1      ==> listbox should take default action
                other   ==> index of an item to perform default action

    HISTORY:
        jonn        28-Feb-1996 Copied from LAZY_USER_LISTBOX

********************************************************************/

INT USER_BROWSER_LB::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    if (nVKey == VK_BACK)
    {
        TRACEEOL( "USER_BROWSER_LB:CD_VKey: hit BACKSPACE" );
        _hawinfo._time = 0L; // reset timer
        _hawinfo._nls = SZ("");
        UIASSERT( _hawinfo._nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }

    return LAZY_LISTBOX::CD_VKey( nVKey, nLastPos );
}




/*******************************************************************

    NAME:       USER_BROWSER_LB::OnDeleteItem

    SYNOPSIS:   All of our items are stored in the cache, so ignore deletion
                requests

    HISTORY:    Johnl   28-Dec-1992     Created

********************************************************************/

VOID USER_BROWSER_LB::OnDeleteItem( LBI * plbi )
{
    // Don't delete any LBIs since they are stored in the cache
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::USER_BROWSER_LBI_CACHE

    SYNOPSIS:   User browser LBI cache constructor

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

USER_BROWSER_LBI_CACHE::USER_BROWSER_LBI_CACHE()
    : USER_LBI_CACHE       (),
      _nlsDomainName       (),
      _ossidDomain         ( NULL ),
      _fCacheContainsUsers ( FALSE ),
      _fIncludeUsersInCount( FALSE ),
      _cUsers              ( 0 ),
      _cNonUsers           ( 0 )

{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = _nlsDomainName.QueryError()) ||
         (err = _ossidDomain.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }
}

USER_BROWSER_LBI_CACHE::~USER_BROWSER_LBI_CACHE()
{
    // Nothing to do
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::CreateLBI

    SYNOPSIS:   The cache wants an LBI created from a pddu

    NOTES:

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

LBI * USER_BROWSER_LBI_CACHE::CreateLBI( const DOMAIN_DISPLAY_USER * pddu )
{
    NLS_STR nlsAccountName ;
    NLS_STR nlsFullName ;
    NLS_STR nlsComment ;
    NLS_STR nlsDisplayName ;
    OS_SID  ossidUser( _ossidDomain, pddu->Rid ) ;

    if ( nlsAccountName.QueryError() ||
         nlsFullName.QueryError()    ||
         nlsComment.QueryError()     ||
         nlsDisplayName.QueryError() ||
         nlsAccountName.MapCopyFrom( pddu->LogonName.Buffer,
                                     pddu->LogonName.Length ) ||
         nlsFullName.MapCopyFrom   ( pddu->FullName.Buffer,
                                     pddu->FullName.Length ) ||
         nlsComment.MapCopyFrom    ( pddu->AdminComment.Buffer,
                                     pddu->AdminComment.Length )  ||
         ossidUser.QueryError() ||
         NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                     &nlsDisplayName,
                                     nlsAccountName,
                                     _nlsDomainName,
                                     &nlsFullName,
                                     &_nlsDomainName ) )
    {
        return NULL ;
    }

    return new USER_BROWSER_LBI(  nlsAccountName,
                                  nlsFullName,
                                  nlsDisplayName,
                                  nlsComment,
                                  _nlsDomainName,
                                  ossidUser,
                                  UI_SID_Invalid,
                                  SidTypeUser,
                                  pddu->AccountControl ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::Compare

    SYNOPSIS:   Compares a user browser lbi and a pddu

    NOTES:

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

INT USER_BROWSER_LBI_CACHE::Compare( const LBI                 * plbi,
                                     const DOMAIN_DISPLAY_USER * pddu ) const
{
    USER_BROWSER_LBI * pubrowLBI = (USER_BROWSER_LBI*) plbi ;

// CODEWORK We are not consistent about comparing the LogonName vs. the
// DisplayName

    if ( (pubrowLBI->QueryType() != SidTypeUser ))
    {
        return -1 ;
    }

    UNICODE_STRING unistrLBI;
    unistrLBI.Buffer = (PWSTR)((USER_BROWSER_LBI *)plbi)->QueryAccountName();
    unistrLBI.Length = ::strlenf(unistrLBI.Buffer)*sizeof(WCHAR);
    unistrLBI.MaximumLength = unistrLBI.Length + sizeof(WCHAR);

    return CmpUniStrs ( &unistrLBI, &(pddu->LogonName) );
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::Compare

    SYNOPSIS:   Compares two user browser lbis

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/


INT USER_BROWSER_LBI_CACHE::Compare( const LBI * plbi0,
                                     const LBI * plbi1 ) const
{
    USER_BROWSER_LBI * pubrowLBI0 = (USER_BROWSER_LBI*) plbi0 ;
    USER_BROWSER_LBI * pubrowLBI1 = (USER_BROWSER_LBI*) plbi1 ;

    if ( (pubrowLBI0->QueryType() != SidTypeUser) &&
         (pubrowLBI1->QueryType() == SidTypeUser ))
    {
        return -1 ;
    }

    if ( (pubrowLBI0->QueryType() == SidTypeUser) &&
         (pubrowLBI1->QueryType() != SidTypeUser ))
    {
        return 1 ;
    }

    return ::stricmpf( pubrowLBI0->QueryDisplayName(),
                       pubrowLBI1->QueryDisplayName()  ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddUsers

    SYNOPSIS:   Tells the cache to read the users from the passed admin
                authority

    ENTRY:      Same as USER_LBI_CACHE::ReadUsers

    NOTES:

    HISTORY:
        Johnl   28-Dec-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddUsers( ADMIN_AUTHORITY * pAdminAuthority,
                                         const TCHAR     * pszDomain,
                                         BOOL              fIsTargetDomain,
                                         BOOL            * pfQuitEnum )
{
    UNREFERENCED( pfQuitEnum ) ;
    ASSERT( pfQuitEnum != NULL );
    APIERR err ;

    //
    //  Somebody specifically requested users so include them in the cache count
    //
    _fIncludeUsersInCount = TRUE ;

    if ( _fCacheContainsUsers )
        return NERR_Success ;

    //
    //  CODEWORK - Add pfQuitEnum support to user cache (set by 2nd thread)
    //
    OS_SID ossidTmp( pAdminAuthority->QueryAccountDomain()->QueryPSID() ) ;
    if ( (err = _nlsDomainName.CopyFrom( pszDomain )) ||
         (err = ossidTmp.QueryError()) ||
         (err = _ossidDomain.Copy( ossidTmp )) ||
         (err = ReadUsers( pAdminAuthority, ULC_INITIAL_GROWTH_DEFAULT,
                                            ULC_REQUEST_COUNT_DEFAULT,
                                            fIsTargetDomain,
                                            pfQuitEnum )) )
    {
        // fall through
    }

    //
    //  Adjust the total user count
    //
    _cUsers = USER_LBI_CACHE::QueryCount() - _cNonUsers ;

    if ( !err )
    {
	_fCacheContainsUsers = TRUE ;
	Sort() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::Fill

    SYNOPSIS:   This method adds all of the users/groups/aliases/
                well known SIDs to this listbox.  The contents are emptied
                first.  What to add is specified by the ulFlags parameter which
                contains the combination of USRBROWS_INCL* and USRBROWS_SHOW*
                flags.

    ENTRY:      pAdminAuthority - Pointer to domain we are browsing
                ulFlags - set of USRBROWS_* incl and show flags.

    EXIT:       The cache will be filled with the requested items

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Must be MT safe!

    HISTORY:
        Johnl   02-Mar-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::Fill( ADMIN_AUTHORITY  * pAdminAuthority,
                                     const TCHAR *      pszQualifyingDomain,
                                     ULONG              ulFlags,
                                     BOOL               fIsWinNTDomain,
                                     BOOL               fIsTargetDomain,
                                     BOOL *             pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    APIERR err = NERR_Success ;
    AUTO_CURSOR CursorHourGlass ;

    if ( *pfQuitEnum )
        return err ;

    if ( !err &&
         fIsTargetDomain &&
         (ulFlags & USRBROWS_SHOW_ALIASES) )
    {
        err = AddAliases( pAdminAuthority, pszQualifyingDomain,
                          pfQuitEnum ) ;
    }

    if ( !err &&
         !fIsWinNTDomain &&
         (ulFlags & USRBROWS_SHOW_GROUPS) )
    {
        err = AddGroups( pAdminAuthority, pszQualifyingDomain,
                         pfQuitEnum ) ;
    }

    if ( !err && (ulFlags & USRBROWS_INCL_ALL) )
    {
        err = AddWellKnownSids( pAdminAuthority, ulFlags, pfQuitEnum ) ;

    }

    //
    //  Show (in this context, expand) the users if the client specifically
    //  requested them to be shown or all we are showing is users
    //  (regardless of the expanded user flag).
    //
    if ( !err && ((ulFlags & USRBROWS_EXPAND_USERS)  ||
                 ((ulFlags & USRBROWS_SHOW_ALL ) == USRBROWS_SHOW_USERS)))
    {
        err = AddUsers( pAdminAuthority, pszQualifyingDomain, fIsTargetDomain,
                        pfQuitEnum ) ;
    }

    return err ;
}


/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddAliases

    SYNOPSIS:   The method enumerates all of the aliases on the given
                domain and adds them to the listbox

    ENTRY:      pBrowserDomain - Pointer to the browser domain to enumerate
                    the aliases on

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   26-Mar-1992     Implemented

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddAliases( ADMIN_AUTHORITY * pAdminAuthority,
                                           const TCHAR * pszQualifyingDomain,
                                           BOOL *pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddAliases Entered @ " << ::GetTickCount()/100) ;

    APIERR err = NERR_Success ;

    if ( (err = AddAliases( pAdminAuthority->QueryAccountDomain(),
                            pszQualifyingDomain,
                            pfQuitEnum ))  ||
         (err = AddAliases( pAdminAuthority->QueryBuiltinDomain(),
                            pszQualifyingDomain,
                            pfQuitEnum )) )
    {
        /* Fall through
         */

    }

    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddAliases Leave    @ " << ::GetTickCount()/100) ;
    return err ;
}


/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddAliases

    SYNOPSIS:   The method enumerates all of the aliases on the given
                SAM domain and adds them to the listbox

    ENTRY:      pSAMDomain - Pointer to the SAM domain to get the aliases for


    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   26-Mar-1992     Implemented

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddAliases( SAM_DOMAIN * pSAMDomain,
                                           const TCHAR * pszQualifyingDomain,
                                           BOOL * pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    APIERR err = NERR_Success ;

    if ( *pfQuitEnum )
        return err ;

    do { // error breakout

        SAM_ENUMERATE_HANDLE    hSAMEnum = 0 ;
        SAM_RID_ENUMERATION_MEM SAMRidEnumMem ;
        NLS_STR                 nlsAccountName ;
        NLS_STR                 nlsComment ;

        if ( (err = SAMRidEnumMem.QueryError()) ||
             (err = nlsAccountName.QueryError())||
             (err = nlsComment.QueryError())      )
        {
            break ;
        }

        /* set the initial read count */
        ULONG ulBytesRequested = USRBROWS_ALIASES_INITIAL_COUNT;

        /* EnumerateAliases returned ERROR_MORE_DATA */
        BOOL fMoreData = FALSE;

        /* Loop through each alias and add it to the listbox
         */
        do {

            /* make API call and time how long it takes */
            DWORD start = ::GetTickCount();
            err = pSAMDomain->EnumerateAliases( &SAMRidEnumMem,
                                                &hSAMEnum,
                                                ulBytesRequested ) ;
            DWORD finish = ::GetTickCount();

            TRACEEOL( "AddAliases: first " << ulBytesRequested << " read in " << (finish-start) );

            /* adjust ulBytesRequested according to how long the last call took */
            if ( finish - start < USRBROWS_ALIASES_READ_MORE_MSEC )
            {
                ulBytesRequested *= 2;
                if ( ulBytesRequested > USRBROWS_ALIASES_MAX_COUNT )
                    ulBytesRequested = USRBROWS_ALIASES_MAX_COUNT;
            }
            else if ( finish - start > USRBROWS_ALIASES_READ_LESS_MSEC )
            {
                ulBytesRequested /= 2;
                if ( ulBytesRequested < USRBROWS_ALIASES_MIN_COUNT )
                    ulBytesRequested = USRBROWS_ALIASES_MIN_COUNT;

            }

            fMoreData = (err == ERROR_MORE_DATA);
            if ( err != NERR_Success )
            {
                if (err == ERROR_MORE_DATA)
                {
                    TRACEEOL( "AddAliases: will request more data" );
                    err = NERR_Success;
                }
                else
                {
                    DBGEOL( "AddAliases: Error " << (ULONG) err <<
                            "Enumerating aliases" ) ;
                    break ;
                }
            }

            for ( ULONG i = 0 ; i < SAMRidEnumMem.QueryCount() ; i++ )
            {
                if ( *pfQuitEnum )
                    break ;

                ULONG ulRid = SAMRidEnumMem.QueryRID( i ) ;
                if ( (err = SAMRidEnumMem.QueryName( i, &nlsAccountName )))
                {
                    break ;
                }

                /* We also need to get the comment for this alias
                 */
                SAM_ALIAS SAMAlias( *pSAMDomain,
                                    ulRid,
                                    ALIAS_READ_INFORMATION ) ;

                OS_SID ossidAlias( pSAMDomain->QueryPSID(), ulRid ) ;
                if ( (err = SAMAlias.QueryError() ) ||
                     (err = ossidAlias.QueryError())||
                     (err = SAMAlias.GetComment( &nlsComment ) ))
                {
                    DBGEOL( "AddAliases - Error " << (ULONG) err <<
                            "constructing sam alias or getting the comment" ) ;
                    break ;
                }

                if ( err = BuildAndAddLBI( nlsAccountName,
                                           NULL,
                                           nlsAccountName,
                                           nlsComment,
                                           pszQualifyingDomain,
                                           ossidAlias.QueryPSID(),
                                           UI_SID_Invalid,
                                           SidTypeAlias,
                                           0 ))
                {
                    break ;
                }
            }
        } while ( (err == NERR_Success) && fMoreData && !(*pfQuitEnum) ) ;

    } while (FALSE) ; // error breakout loop

    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddGroups

    SYNOPSIS:   Adds the groups from pAdminAuthority to the list

    ENTRY:      pAdminAuthority - The domain to add the users from

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   07-Apr-1992     Implemented

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::AddGroups( ADMIN_AUTHORITY * pAdminAuthority,
                                          const TCHAR * pszQualifyingDomain,
                                          BOOL * pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddGroups Entered @ " << ::GetTickCount()/100) ;
    APIERR err     = NERR_Success ;
    APIERR errEnum = NERR_Success ;
    if ( *pfQuitEnum )
        return err ;

    SAM_DOMAIN * pSAMDomain = pAdminAuthority->QueryAccountDomain() ;

    do { // error breakout

        /* Try to use SamQDI(DOMAIN_DISPLAY_GROUP).  This will work
         * only if the target is Daytona or better.
         */
        {
            USRLB_NT_GROUP_ENUM ntgenum( pSAMDomain );
            if (   (err = ntgenum.QueryError()) == NERR_Success
                && (err = ntgenum.GetInfo()) == NERR_Success
               )
            {
                // do not create iter until after GetInfo
                NT_GROUP_ENUM_ITER ntgeiter( ntgenum );
                NLS_STR nlsAccountName;
                NLS_STR nlsComment;
                if (   (err = ntgeiter.QueryError()) != NERR_Success
                    || (err = nlsAccountName.QueryError()) != NERR_Success
                    || (err = nlsComment.QueryError()) != NERR_Success
                   )
                {
                    DBGEOL( "AddGroups: error creating iterator " << err );
                    break;
                }

                const NT_GROUP_ENUM_OBJ * pntgeobj = NULL;
                while( ( pntgeobj = ntgeiter(&err, FALSE)) != NULL )
                {
                    ASSERT( err != ERROR_MORE_DATA );

                    if ( *pfQuitEnum )
                        break ;

                    OS_SID ossidGroup( pSAMDomain->QueryPSID(),
                                       (ULONG)pntgeobj->QueryRID() ) ;
                    if (   (err = ossidGroup.QueryError()) != NERR_Success
                        || (err = pntgeobj->QueryGroup( &nlsAccountName ))
                                        != NERR_Success
                        || (err = pntgeobj->QueryComment( &nlsComment ))
                                        != NERR_Success
                        || (err = BuildAndAddLBI( nlsAccountName,
                                                  NULL,
                                                  nlsAccountName,
                                                  nlsComment,
                                                  pszQualifyingDomain,
                                                  ossidGroup.QueryPSID(),
                                                  UI_SID_Invalid,
                                                  SidTypeGroup,
                                                  0 )) != NERR_Success )
                    {
                        DBGEOL( "AddGroups: error in BuildAndAddLBI " << err );
                        break;
                    }
                }

                if ( err != NERR_Success )
                {
                    DBGEOL( "AddGroups: error in SamQDI enum " << err );
                }

                break; // we don't want to mix SamQDI and EnumerateGroups results
            }

            if (err == ERROR_NOT_SUPPORTED || err == ERROR_INVALID_PARAMETER)
            {
                TRACEEOL( "AddGroups: SamQDI not supported" );
            }
            else
            {
                if (err != NERR_Success)
                {
                    DBGEOL( "AddGroups: Error " << err << "in SamQDI" ) ;
                }
                break;
            }
        }

        if ( *pfQuitEnum )
            break ;


        SAM_ENUMERATE_HANDLE    hSAMEnum = 0 ;
        SAM_RID_ENUMERATION_MEM SAMRidEnumMem ;
        NLS_STR                 nlsAccountName ;
        NLS_STR                 nlsComment ;

        if ( (err = SAMRidEnumMem.QueryError()) ||
             (err = nlsAccountName.QueryError())||
             (err = nlsComment.QueryError())      )
        {
            break ;
        }

        /* set the initial read count */
        ULONG ulBytesRequested = USRBROWS_GROUPS_INITIAL_COUNT;

        /* Loop through each Group and add it to the listbox
         */
        do {
            if ( *pfQuitEnum )
                break ;

            /* make API call and time how long it takes */
            DWORD start = ::GetTickCount();
            errEnum = pSAMDomain->EnumerateGroups( &SAMRidEnumMem,
                                                   &hSAMEnum,
                                                   ulBytesRequested ) ;
            DWORD finish = ::GetTickCount();

            TRACEEOL( "AddGroups: first " << ulBytesRequested << " read in " << (finish-start) );

            /* adjust ulBytesRequested according to how long the last call took */
            if ( finish - start < USRBROWS_GROUPS_READ_MORE_MSEC )
            {
                ulBytesRequested *= 2;
                if ( ulBytesRequested > USRBROWS_GROUPS_MAX_COUNT )
                    ulBytesRequested = USRBROWS_GROUPS_MAX_COUNT;
            }
            else if ( finish - start > USRBROWS_GROUPS_READ_LESS_MSEC )
            {
                ulBytesRequested /= 2;
                if ( ulBytesRequested < USRBROWS_GROUPS_MIN_COUNT )
                    ulBytesRequested = USRBROWS_GROUPS_MIN_COUNT;

            }

            if ( errEnum != NERR_Success &&
                 errEnum != ERROR_MORE_DATA )
            {
                err = errEnum ;
                DBGEOL( "AddGroups: Error " << (ULONG) err <<
                        "Enumerating Groups" ) ;
                break ;
            }

            for ( ULONG i = 0 ; i < SAMRidEnumMem.QueryCount() ; i++ )
            {
                if ( *pfQuitEnum )
                    break ;

                ULONG ulRid = SAMRidEnumMem.QueryRID( i ) ;
                if ( (err = SAMRidEnumMem.QueryName( i, &nlsAccountName )))
                {
                    break ;
                }

                //
                // We also need to get the comment for this Group
                //
                SAM_GROUP SAMGroup( *pSAMDomain,
                                    ulRid,
                                    GROUP_READ_INFORMATION ) ;

                OS_SID ossidGroup( pSAMDomain->QueryPSID(), ulRid ) ;
                if ( (err = SAMGroup.QueryError() ) ||
                     (err = ossidGroup.QueryError())||
                     (err = SAMGroup.GetComment( &nlsComment ) ))
                {
                    DBGEOL( "AddGroups - Error " << (ULONG) err <<
                            "constructing sam Group or getting the comment" ) ;
                    break ;
                }

                if ( err = BuildAndAddLBI( nlsAccountName,
                                           NULL,
                                           nlsAccountName,
                                           nlsComment,
                                           pszQualifyingDomain,
                                           ossidGroup.QueryPSID(),
                                           UI_SID_Invalid,
                                           SidTypeGroup,
                                           0 ))
                {
                    break ;
                }
            }
        } while ( errEnum == ERROR_MORE_DATA ) ;

    } while (FALSE) ; // error breakout loop

    TRACEEOL("\tUSER_BROWSER_LBI_CACHE::AddGroups Leave    @ " << ::GetTickCount()/100) ;
    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::AddWellKnownSids

    SYNOPSIS:   This method adds all of requested the well known SIDs supported
                by the user browser to the listbox

    ENTRY:      pAdminAuthority - Pointer to a admin authority that should be
                    used for the name translation.
                ulFlags - Bitfield passed to the user browser constructor

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The domain name will be the empty string for the added
                LBIs.

    HISTORY:
        Johnl   25-Mar-1992     Implemented

********************************************************************/

#define MAX_SIDS 6

APIERR USER_BROWSER_LBI_CACHE::AddWellKnownSids( ADMIN_AUTHORITY  * pAdminAuthority,
                                                 ULONG              ulFlags,
                                                 BOOL *             pfQuitEnum )
{
    ASSERT( pfQuitEnum != NULL );
    APIERR err = NERR_Success ;
    UI_SystemSid aSysSids[MAX_SIDS] ;
    MSGID        amsgidSysSids[MAX_SIDS] ;
    INT          cSids = -1 ;

    if ( ulFlags & USRBROWS_INCL_EVERYONE )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_World ;
        amsgidSysSids[cSids] = IDS_USRBROWS_EVERYONE_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_REMOTE_USERS )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_Network ;
        amsgidSysSids[cSids] = IDS_USRBROWS_REMOTE_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_INTERACTIVE )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_Interactive ;
        amsgidSysSids[cSids] = IDS_USRBROWS_INTERACTIVE_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_CREATOR )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_CreatorOwner ;
        amsgidSysSids[cSids] = IDS_USRBROWS_CREATOR_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_SYSTEM )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_System ;
        amsgidSysSids[cSids] = IDS_USRBROWS_SYSTEM_SID_COMMENT ;
    }

    if ( ulFlags & USRBROWS_INCL_RESTRICTED )
    {
        cSids++ ;
        aSysSids[cSids] = UI_SID_Restricted ;
        amsgidSysSids[cSids] = IDS_USRBROWS_RESTRICTED_SID_COMMENT ;
    }

    if ( cSids < 0 )
    {
        return err ;
    }

    /* Convert from array index to count
     */
    cSids++ ;
    UIASSERT( cSids <= MAX_SIDS ) ;

    do { // error breakout

        PSID   apsid[MAX_SIDS] ;

        /* I know this is kinda hokey.  I wanted to do OS_SID aossid[MAX_SIDS]
         * but it is not implemented in CFRONT (array with default arguments).
         * One alternative is to give OS_SID a no argument constructor.
         */
        OS_SID * aossidWellKnown[MAX_SIDS] ;
        OS_SID OS_SID0, OS_SID1, OS_SID2, OS_SID3, OS_SID4, OS_SID5 ;
        aossidWellKnown[0] = &OS_SID0 ;
        aossidWellKnown[1] = &OS_SID1 ;
        aossidWellKnown[2] = &OS_SID2 ;
        aossidWellKnown[3] = &OS_SID3 ;
        aossidWellKnown[4] = &OS_SID4 ;
        aossidWellKnown[5] = &OS_SID5 ;

        /* Build the array of PSIDs suitable for passing to LSATranslateSidsToNames
         */
        for ( INT i = 0 ; i < cSids  ; i++ )
        {
            if ((err = aossidWellKnown[i]->QueryError()) ||
                (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(aSysSids[i],
                                                        aossidWellKnown[i])))

            {
                break ;
            }

            apsid[i] = aossidWellKnown[i]->QueryPSID() ;
        }

        if ( err || *pfQuitEnum )
            break ;

        /* Do the name translation
         */
        LSA_TRANSLATED_NAME_MEM LSATransNameMem ;
        LSA_REF_DOMAIN_MEM      LSARefDomainMem ;
        NLS_STR                 nlsAccountName ;
        NLS_STR                 nlsComment ;

        if ( (err = LSATransNameMem.QueryError() ) ||
             (err = LSARefDomainMem.QueryError())  ||
             (err = pAdminAuthority->QueryLSAPolicy()->TranslateSidsToNames(
                                                    apsid,
                                                    cSids,
                                                    &LSATransNameMem,
                                                    &LSARefDomainMem )) ||
             (err = nlsComment.QueryError())                            ||
             (err = nlsAccountName.QueryError())                          )
        {
            DBGEOL("NT_ACL_TO_PERM_CONVERTER::SidsToNames - Error translating names or constructing LSA_POLICY") ;
            break ;
        }

        /* Add the new Well Known SID LBIs to the listbox
         */
        for ( i = 0 ; i < cSids ; i++ )
        {
            //
            // JonN 3/16/99 replaced bad assertion, this could happen if
            //   the target machine is downlevel
            //
            if ( LSATransNameMem.QueryUse(i) != SidTypeWellKnownGroup )
                continue;

            if ( (err = LSATransNameMem.QueryName( i, &nlsAccountName)) ||
                 (err = nlsComment.Load( amsgidSysSids[i] )) ||
                 (err = BuildAndAddLBI(  nlsAccountName,
                                         NULL,
                                         nlsAccountName,
                                         nlsComment,
                                         NULL,
                                         aossidWellKnown[i]->QueryPSID(),
                                         aSysSids[i],
                                         LSATransNameMem.QueryUse(i),
                                         0 )) )
            {
                break ;
            }
        }

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI_CACHE::BuildAndAddLBI

    SYNOPSIS:   Adds an item to the user browser listbox

    ENTRY:      pszAccountName - Account for the LSA (or NULL if Well Known)
                pszFullName    - Full name for users (can be NULL)
                pszDisplayName - Display name to show the user
                pszComment - Comment for this account
                UISysSid         - If this is a well known SID, then this
                                   member contains the UI_SID_* value we
                                   can use to get the SID, else it will
                                   contain UI_SID_Invalid which means we
                                   should use the display name for the account
                                   name.
                SidType    - The type of account we are adding
                nFlags     - User account flags

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Must be MT safe!

    HISTORY:
        Johnl   25-Mar-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI_CACHE::BuildAndAddLBI(
                                        const TCHAR     * pszAccountName,
                                        const TCHAR     * pszFullName,
                                        const TCHAR     * pszDisplayName,
                                        const TCHAR     * pszComment,
                                        const TCHAR     * pszDomain,
                                        const PSID        psidAccount,
                                        enum UI_SystemSid UISysSid,
                                        SID_NAME_USE      SidType,
                                        ULONG             nFlags )
{
    APIERR err ;

    //
    //  This method can only be used for adding non-users (users are added
    //  through the AddUsers method).
    //
    UIASSERT( SidType != SidTypeUser ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    USER_BROWSER_LBI * plbi = new USER_BROWSER_LBI( pszAccountName,
                                                    pszFullName,
                                                    pszDisplayName,
                                                    pszComment,
                                                    pszDomain,
                                                    psidAccount,
                                                    UISysSid,
                                                    SidType,
                                                    nFlags ) ;

    if (  plbi == NULL ||
         (err = plbi->QueryError()) )
    {
        delete plbi ;
        return err ;
    }

    if ( AddItem( plbi ) < 0 )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return err ;
}

PQSORT_COMPARE USER_BROWSER_LBI_CACHE::QueryCompareMethod( VOID ) const
{
    return (PQSORT_COMPARE) USER_BROWSER_LBI_CACHE::CompareCacheLBIs ;
}


//
//  PUSER_BROWSER_LBI compare funcion used in qsort
//
int __cdecl USER_BROWSER_LBI_CACHE::CompareCacheLBIs(
			   const ULC_ENTRY_BASE * pulc1,
			   const ULC_ENTRY_BASE * pulc2 )
{
    UIASSERT( pulc1 != NULL ) ;
    UIASSERT( pulc2 != NULL ) ;

    //
    //	If pulc1 is not a user and pulc2 is...
    //
    if ( pulc1->pddu == NULL &&
	 pulc2->pddu != NULL   )
    {
	return -1 ;
    }

    //
    //	If pulc1 is a user and pulc2 is not...
    //
    if ( pulc1->pddu != NULL &&
	 pulc2->pddu == NULL   )
    {
	return 1 ;
    }


    PUNICODE_STRING puni1, puni2 ;
    UNICODE_STRING uni1, uni2 ;

    if ( pulc1->pddu  != NULL )
    {
	puni1 = &pulc1->pddu->LogonName ;
    }
    else
    {
	//
	//  Dummy up the logon name from the LBI
	//
	RtlInitUnicodeString( &uni1,
	      ((USER_BROWSER_LBI*)pulc1->plbi)->QueryDisplayName()) ;
	puni1 = &uni1 ;
    }

    if ( pulc2->pddu  != NULL )
    {
	puni2 = &pulc2->pddu->LogonName ;
    }
    else
    {
	//
	//  Dummy up the logon name from the LBI
	//
	RtlInitUnicodeString( &uni2,
	      ((USER_BROWSER_LBI*)pulc2->plbi)->QueryDisplayName()) ;
	puni2 = &uni2 ;
    }


    return USER_BROWSER_LBI_CACHE::CmpUniStrs( puni1, puni2 ) ;
}


/*******************************************************************

    NAME:       USER_BROWSER_LBI::USER_BROWSER_LBI

    SYNOPSIS:   Typical LBI Constructor destructor

    ENTRY:      pszAccountName - Name suitable for passing to the LSA if
                                 this is not a well known sid (can be NULL)
                pszFullName    - Full name (can be NULL)
                pszSubjectName - Name of this Alias/Group/User
                pszComment - Comment for this Alias/Group/User
                UISysSid   - For well known SIDs we use this value to
                             get the SID, otherwise we use the _nlsAccountName
                             member.
                SidType - Is this an Alias/Group/User
                nFlags  - User Account flags ( Sid type must be user if
                          this field is non-zero)

    NOTES:

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

USER_BROWSER_LBI::USER_BROWSER_LBI( const TCHAR     * pszAccountName,
                                          const TCHAR     * pszFullName,
                                          const TCHAR     * pszSubjectName,
                                          const TCHAR     * pszComment,
                                          const TCHAR     * pszDomain,
                                          const PSID        psidAccount,
                                          enum UI_SystemSid UISysSid,
                                          SID_NAME_USE      SidType,
                                          ULONG             nFlags )

    : _nlsAccountName( pszAccountName ),
      _nlsFullName   ( pszFullName    ),
      _nlsDisplayName( pszSubjectName ),
      _nlsComment    ( pszComment     ),
      _nlsDomain     ( pszDomain      ),
      _ossid         ( psidAccount, TRUE ),
      _UISysSid      ( UISysSid ),
      _SidType       ( SidType ),
      _nFlags        ( nFlags )
{
    if ( QueryError() )
        return ;

    /* The flags field must be zero if this is not a user
     */
    UIASSERT( (SidType == SidTypeUser) ||
              (SidType != SidTypeUser  && nFlags == 0)) ;

    APIERR err ;
    if ( (err = _nlsFullName.QueryError()) ||
         (err = _nlsAccountName.QueryError()) ||
         (err = _nlsDisplayName.QueryError()) ||
         (err = _nlsComment.QueryError())     ||
         (err = _nlsDomain.QueryError())      ||
         (err = _ossid.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }
}

USER_BROWSER_LBI::~USER_BROWSER_LBI()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::QualifyDisplayName

    SYNOPSIS:   Forces explicit qualification of the display name

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   27-Oct-1992     Created

********************************************************************/

APIERR USER_BROWSER_LBI::QualifyDisplayName( void )
{
    return NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                                &_nlsDisplayName,
                                                _nlsAccountName,
                                                _nlsDomain,
                                                NULL,
                                                NULL,
                                                QueryType() ) ;
}



/*******************************************************************

    NAME:       USER_BROWSER_LBI::Paint

    SYNOPSIS:   Typical LBI Paint method

    NOTES:

    HISTORY:
        Johnl   03-Mar-1992     Created
        beng    21-Apr-1992     LBI::Paint interface change

********************************************************************/

VOID USER_BROWSER_LBI::Paint(
                    LISTBOX * plb,
                    HDC hdc,
                    const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    STR_DTE strdteName( _nlsDisplayName ) ;
    STR_DTE strdteComment( _nlsComment ) ;
    DM_DTE  dmdteIcon( ((USER_BROWSER_LB*)plb)->QueryDisplayMap( this ) ) ;

    DISPLAY_TABLE dt( 3, ((USER_BROWSER_LB*)plb)->QueryColWidthArray()) ;
    dt[0] = &dmdteIcon ;
    dt[1] = &strdteName ;
    dt[2] = &strdteComment ;

    dt.Paint( plb, hdc, prect, pGUILTT ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::Compare

    SYNOPSIS:   Typical LBI compare for user browser listbox

    NOTES:      This method will sort all user sid types to the end of
                the list

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

INT USER_BROWSER_LBI::Compare( const LBI * plbi ) const
{
    return CompareAux( plbi ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::CompareAux

    SYNOPSIS:   Allows calling by ComparepLBIs (which must be _CRTAPI) and
                the normal compare method

    NOTES:

    HISTORY:
        Johnl   08-Dec-1992     Created

********************************************************************/

INT USER_BROWSER_LBI::CompareAux( const LBI * plbi ) const
{
    USER_BROWSER_LBI * pubrowLBI = (USER_BROWSER_LBI*) plbi ;

    if ( (QueryType() != SidTypeUser) &&
         (pubrowLBI->QueryType() == SidTypeUser ))
    {
        return -1 ;
    }

    if ( (QueryType() == SidTypeUser) &&
         (pubrowLBI->QueryType() != SidTypeUser ))
    {
        return 1 ;
    }

    return _nlsDisplayName._stricmp( pubrowLBI->_nlsDisplayName ) ;
}

    //
    //  PUSER_BROWSER_LBI compare funcion used in qsort
    //
    int __cdecl ComparepLBIs( const PUSER_BROWSER_LBI * pplbi1,
                               const PUSER_BROWSER_LBI * pplbi2 )
    {
        return (*pplbi1)->CompareAux( *pplbi2 ) ;
    }

/*******************************************************************

    NAME:       USER_BROWSER_LBI::QueryLeadingChar

    SYNOPSIS:   Typical QueryLeadingChar method

    HISTORY:
        Johnl   03-Mar-1992     Created

********************************************************************/

WCHAR USER_BROWSER_LBI::QueryLeadingChar( void ) const
{
    ISTR istr( _nlsDisplayName ) ;
    return _nlsDisplayName.QueryChar( istr ) ;
}

/*******************************************************************

    NAME:       USER_BROWSER_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Compare to prefix for HAW-for-Hawaii

    HISTORY:
        JonN    11-Aug-1992     HAW-for-Hawaii

********************************************************************/

INT USER_BROWSER_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
//    TRACEEOL(  "User Browser: Compare_HAWforHawaii(): \""
//             << nls
//             << "\", \""
//             << _nlsDisplayName.QueryPch()
//             << "\", "
//             << nls.QueryTextLength() );
    ISTR istr( nls ) ;
    istr += nls.QueryTextLength();
    return nls._strnicmp( _nlsDisplayName, istr ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\bin\makefile.inc ===
COMBINE_SOURCELIBS=..\pch\$(O)\pchapplb.lib \
                   ..\applib\$(O)\applib.lib

COMBINE_TARGETLIB=$(O)\uiapplib.lib

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\w32sema4.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32sema4.cxx
    Class definitions for the WIN32_SEMAPHORE class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_SEMAPHORE methods.
//

/*******************************************************************

    NAME:       WIN32_SEMAPHORE :: WIN32_SEMAPHORE

    SYNOPSIS:   WIN32_SEMAPHORE class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SEMAPHORE :: WIN32_SEMAPHORE( const TCHAR * pszName,
                                    LONG          cInitial,
                                    LONG          cMaximum )
  : WIN32_SYNC_BASE( NULL )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    HANDLE hSemaphore;

    hSemaphore = ::CreateSemaphore( NULL,
                                    cInitial,
                                    cMaximum,
                                    (LPTSTR)pszName );

    if( hSemaphore == NULL )
    {
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetHandle( hSemaphore );

}   // WIN32_SEMAPHORE :: WIN32_SEMAPHORE


/*******************************************************************

    NAME:       WIN32_SEMAPHORE :: ~WIN32_SEMAPHORE

    SYNOPSIS:   WIN32_SEMAPHORE class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SEMAPHORE :: ~WIN32_SEMAPHORE( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // WIN32_SEMAPHORE :: ~WIN32_SEMAPHORE


/*******************************************************************

    NAME:       WIN32_SEMAPHORE :: Release

    SYNOPSIS:   Release the semaphore.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_SEMAPHORE :: Release( LONG   ReleaseCount,
                                   LONG * pPreviousCount )
{
    APIERR err = NO_ERROR;

    if( !::ReleaseSemaphore( QueryHandle(),
                             ReleaseCount,
                             pPreviousCount ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_SEMAPHORE :: Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\w32sync.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32sync.cxx
    Class definitions for the WIN32_SYNC_BASE class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_SYNC_BASE methods.
//

/*******************************************************************

    NAME:       WIN32_SYNC_BASE :: WIN32_SYNC_BASE

    SYNOPSIS:   WIN32_SYNC_BASE class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SYNC_BASE :: WIN32_SYNC_BASE( HANDLE hSyncObject )
   : WIN32_HANDLE( hSyncObject )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

}   // WIN32_SYNC_BASE :: WIN32_SYNC_BASE


/*******************************************************************

    NAME:       WIN32_SYNC_BASE :: ~WIN32_SYNC_BASE

    SYNOPSIS:   WIN32_SYNC_BASE class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_SYNC_BASE :: ~WIN32_SYNC_BASE()
{
    //
    //  Force the object handle closed.
    //

    Close();

}   // WIN32_SYNC_BASE :: ~WIN32_SYNC_BASE


/*******************************************************************

    NAME:       WIN32_SYNC_BASE :: Wait

    SYNOPSIS:   Wait for the object to enter the signaled state.

    ENTRY:      cMilliseconds           - The number of milliseconds to
                                          wait for the object to enter
                                          the signaled state.
                                          -1 == wait indefinitely.

    EXIT:       Either the object is in the signaled state or a timeout
                has occurred.

    RETURNS:    APIERR                  - The result of the wait.

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_SYNC_BASE :: Wait( UINT cMilliseconds )
{
    APIERR err;

    UIASSERT( QueryHandle() != NULL );

    err = (APIERR)::WaitForSingleObject( QueryHandle(),
                                         (DWORD)cMilliseconds );

    if( ( err != NO_ERROR ) &&
        ( err != WAIT_TIMEOUT ) &&
        ( err != WAIT_ABANDONED ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_SYNC_BASE :: Wait
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\w32mutex.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32mutex.cxx
    Class definitions for the WIN32_MUTEX class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_MUTEX methods.
//

/*******************************************************************

    NAME:       WIN32_MUTEX :: WIN32_MUTEX

    SYNOPSIS:   WIN32_MUTEX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_MUTEX :: WIN32_MUTEX( const TCHAR * pszName,
                            BOOL          fInitialOwner )
  : WIN32_SYNC_BASE( NULL )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    HANDLE hMutex;

    hMutex = ::CreateMutex( NULL,
                            fInitialOwner,
                            (LPTSTR)pszName );

    if( hMutex == NULL )
    {
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetHandle( hMutex );

}   // WIN32_MUTEX :: WIN32_MUTEX


/*******************************************************************

    NAME:       WIN32_MUTEX :: ~WIN32_MUTEX

    SYNOPSIS:   WIN32_MUTEX class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_MUTEX :: ~WIN32_MUTEX()
{
    //
    //  This space intentionally left blank.
    //

}   // WIN32_MUTEX :: ~WIN32_MUTEX


/*******************************************************************

    NAME:       WIN32_MUTEX :: Release

    SYNOPSIS:   Release the mutex.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_MUTEX :: Release( VOID )
{
    APIERR err = NO_ERROR;

    if( !::ReleaseMutex( QueryHandle() ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // WIN32_MUTEX :: Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\applib\w32thred.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    w32thred.cxx
    Class definitions for the WIN32_THREAD class.

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        KeithMo     21-Jan-1992 Created.

*/

#include "pchapplb.hxx"   // Precompiled header

//
//  WIN32_THREAD methods.
//

/*******************************************************************

    NAME:       WIN32_THREAD :: WIN32_THREAD

    SYNOPSIS:   WIN32_THREAD class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.
        JonN        30-Nov-1993 Added pszLoadLibrary

********************************************************************/
WIN32_THREAD :: WIN32_THREAD( BOOL fSuspended,
                              UINT cbStack,
                              const TCHAR * pszLoadLibrary )
  : WIN32_SYNC_BASE( NULL ),
    _idThread( 0 ),
    _nExitCode( 0 ),
    _nlsLoadLibrary( pszLoadLibrary ),
    _hLoadLibrary( NULL ),
    _state( Embryonic )
{
    if( QueryError() != NO_ERROR )
    {
        return;
    }

    APIERR err = _nlsLoadLibrary.QueryError();
    if( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    HANDLE hThread;

    hThread = ::CreateThread( NULL,
                              (DWORD)cbStack,
                              (LPTHREAD_START_ROUTINE)&WIN32_THREAD::StartThread,
                              (LPVOID)this,
                              fSuspended ? CREATE_SUSPENDED : 0,
                              (LPDWORD)&_idThread );

    if( hThread == NULL )
    {
        err = (APIERR)::GetLastError();
        ReportError( err );
        TRACEEOL( "WIN32_THREAD::ctor() error " << err );
        return;
    }

    SetHandle( hThread );

}   // WIN32_THREAD :: WIN32_THREAD


/*******************************************************************

    NAME:       WIN32_THREAD :: ~WIN32_THREAD

    SYNOPSIS:   WIN32_THREAD class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
WIN32_THREAD :: ~WIN32_THREAD()
{
    if( IsRunnable() )
    {
        Terminate( 0 );
    }

}   // WIN32_THREAD :: ~WIN32_THREAD


/*******************************************************************

    NAME:       WIN32_THREAD :: StartThread

    SYNOPSIS:   Gets the thread started.

    ENTRY:      lpParam                 - The parameter from CreateThread
                                          (is actually 'this').

    EXIT:       Does not exit until thread is terminated or exits.

    RETURNS:    DWORD                   - Thread exit code.

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
DWORD WIN32_THREAD :: StartThread( LPVOID lpParam )
{
    WIN32_THREAD * pThread = (WIN32_THREAD *)lpParam;
    APIERR err;

    if ( pThread->_nlsLoadLibrary.strlen() != 0 )
    {
        pThread->_hLoadLibrary = LoadLibrary(
                            pThread->_nlsLoadLibrary.QueryPch() );
        if ( pThread->_hLoadLibrary == NULL )
        {
            //
            // If a LoadLibrary error occurs, we kill the thread
            //

            err = ::GetLastError();
            DBGEOL( "WIN32_THREAD::StartThread(): LoadLibrary() error " << err );
            return (DWORD)err;
        }

        TRACEEOL(   "WIN32_THREAD::StartThread(): LoadLibrary() returns "
                 << (DWORD)pThread->_hLoadLibrary );
    }


    pThread->SetState( Starting );
    err = pThread->PreMain();

    TRACEEOL( "WIN32_THREAD::StartThread(): PreMain() returns " << err );

    if( err == NO_ERROR )
    {
        pThread->SetState( Running );
        err = pThread->Main();

        TRACEEOL( "WIN32_THREAD::StartThread(): Main() returns " << err );
    }

    pThread->SetState( Stopping );
    APIERR err2 = pThread->PostMain();
    TRACEEOL( "WIN32_THREAD::StartThread(): PostMain() returns " << err2 );
    err = err2 ? err2 : err;

    pThread->SetState( Dead );
    pThread->_nExitCode = (UINT)err;

    TRACEEOL( "WIN32_THREAD::StartThread(): returns " << err );

    if ( pThread->_hLoadLibrary != NULL )
    {
        TRACEEOL( "WIN32_THREAD::StartThread(): exiting by FreeLibraryAndExitThread()" );
        FreeLibraryAndExitThread( pThread->_hLoadLibrary, (DWORD)err );
        ASSERT( FALSE ); // should never reach this point
    }

    return (DWORD)err;

}   // WIN32_THREAD :: StartThread


/*******************************************************************

    NAME:       WIN32_THREAD :: PreMain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: PreMain( VOID )
{
    UIASSERT( QueryState() == Starting );

    return NO_ERROR;

}   // WIN32_THREAD :: PreMain


/*******************************************************************

    NAME:       WIN32_THREAD :: Main

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Main( VOID )
{
    UIASSERT( QueryState() == Running );

    return  NO_ERROR;

}   // WIN32_THREAD :: Main


/*******************************************************************

    NAME:       WIN32_THREAD :: PostMain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: PostMain( VOID )
{
    UIASSERT( QueryState() == Stopping );

    return  NO_ERROR;

}   // WIN32_THREAD :: PostMain


/*******************************************************************

    NAME:       WIN32_THREAD :: Exit

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
VOID WIN32_THREAD :: Exit( UINT nExitCode )
{
    UIASSERT( QueryState() == Running );
    UIASSERT( QueryID() == (UINT)::GetCurrentThreadId() );

    SetState( Stopping );
    PostMain();

    SetState( Dead );
    _nExitCode = nExitCode;

    if ( _hLoadLibrary != NULL )
    {
        TRACEEOL( "WIN32_THREAD::Exit(): exiting by FreeLibraryAndExitThread()" );
        FreeLibraryAndExitThread( _hLoadLibrary, (DWORD)nExitCode );
    }
    else
    {
        ::ExitThread( (DWORD)nExitCode );
    }

    DBGEOL( "WIN32_THRED::Exit: unexpected return from ::ExitThread()" );
    UIASSERT( FALSE );

}   // WIN32_THREAD :: Exit


/*******************************************************************

    NAME:       WIN32_THREAD :: SetPriority

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: SetPriority( INT nPriority )
{
    APIERR err = NO_ERROR;

    if( !::SetThreadPriority( QueryHandle(), nPriority ) )
    {
        err = (APIERR)::GetLastError();

        TRACEEOL(    "WIN32_THRED::SetPriority( " << nPriority
                  << "): ::SetThreadPriority() error " << err );
    }

    return err;

}   // WIN32_THREAD :: SetPriority


/*******************************************************************

    NAME:       WIN32_THREAD :: QueryPriority

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
INT WIN32_THREAD :: QueryPriority( VOID )
{
    return (INT)::GetThreadPriority( QueryHandle() );

}   // WIN32_THREAD :: QueryPriority


/*******************************************************************

    NAME:       WIN32_THREAD :: Suspend

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Suspend( VOID )
{
    APIERR err = NO_ERROR;

    if( ::SuspendThread( QueryHandle() ) == (DWORD)-1L )
    {
        err = (APIERR)::GetLastError();

        TRACEEOL( "WIN32_THRED::Suspend: ::SuspendThread() error " << err );
    }

    return err;

}   // WIN32_THREAD :: Suspend


/*******************************************************************

    NAME:       WIN32_THREAD :: Resume

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Resume( VOID )
{
    APIERR err = NO_ERROR;

    if( ::ResumeThread( QueryHandle() ) == (DWORD)-1L )
    {
        err = (APIERR)::GetLastError();

        TRACEEOL( "WIN32_THRED::Resume: ::ResumeThread() error " << err );
    }

    return err;

}   // WIN32_THREAD :: Resume


/*******************************************************************

    NAME:       WIN32_THREAD :: Sleep

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
VOID WIN32_THREAD :: Sleep( UINT cMilliseconds )
{
    ::Sleep( (DWORD)cMilliseconds );

}   // WIN32_THREAD :: Sleep


/*******************************************************************

    NAME:       WIN32_THREAD :: Terminate

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      don't use this on a thread which must free _hLoadLibrary

    HISTORY:
        KeithMo     21-Jan-1992 Created.

********************************************************************/
APIERR WIN32_THREAD :: Terminate( UINT nExitCode )
{
    ASSERT( _hLoadLibrary == NULL );

    APIERR err = NO_ERROR;

	// NTRAID#NTBUG9-577117-2002/03/08-artm  Prefast: TerminateThread() very risky.
	// According to MSDN, TerminateThread() does not allow the thread to 
	// properly clean up before terminating.  Use ExitThread() instead.
    if( !::TerminateThread( QueryHandle(), (DWORD)nExitCode ) )
    {
        err = (APIERR)::GetLastError();

        DBGEOL( "WIN32_THRED::Terminate: ::TerminateThread() error " << err );

    }

    if( err == NO_ERROR )
    {
        SetState( Terminated );
    }

    return err;

}   // WIN32_THREAD :: Terminate


/*******************************************************************

    NAME:       WIN32_THREAD :: DeleteAndExit

    SYNOPSIS:   Deletes "this" then exits the thread.  Allows a
                thread to kill itself when it wants to

    ENTRY:      nExitCode - Exit code for this thread

    NOTES:      The thread must be allocated on the heap.
                This call will never return.

    HISTORY:
        Johnl   07-Jan-1993     Created
        JonN    20-May-1992     Changed to DeleteAndExit

********************************************************************/
VOID WIN32_THREAD :: DeleteAndExit( UINT nExitCode )
{
    UIASSERT( QueryID() == (UINT)::GetCurrentThreadId() );

    HINSTANCE hInstance = _hLoadLibrary; // save for later

    //
    //  Lie abit, make the destructor think the thread has already been
    //  terminated
    //
    SetState( Dead ) ;
    delete this ;

    if ( hInstance != NULL )
    {
        TRACEEOL( "WIN32_THREAD::DeleteAndExit(): exiting by FreeLibraryAndExitThread()" );
        FreeLibraryAndExitThread( hInstance, (DWORD)nExitCode );
    }
    else
    {
        ::ExitThread( (DWORD)nExitCode );
    }


    DBGEOL( "WIN32_THRED::DeleteAndExit: unexpected return from ::ExitThread()" );
    UIASSERT( FALSE );

}   // WIN32_THREAD :: DeleteAndExit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\applib\pch\usrmle.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    usrmle.cxx

    Contains code for manipulating the user accounts MLE in the user browser

    FILE HISTORY:
        Johnl   08-Dec-1992     Created

*/

#include "pchapplb.hxx"  //  Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

enum UI_SystemSid syssid[] =  { UI_SID_World,
                                UI_SID_Interactive,
                                UI_SID_CreatorOwner,
                                UI_SID_Network,
                                UI_SID_System,
                                UI_SID_Restricted,

                                UI_SID_Admins,
                                UI_SID_Replicator,
                                UI_SID_PowerUsers,
                                UI_SID_Guests,
                                UI_SID_Users,
                                UI_SID_BackupOperators,
                                UI_SID_AccountOperators,
                                UI_SID_SystemOperators,
                                UI_SID_PrintOperators
                              } ;
#define NUM_WELLKNOWN_SIDS   (6)
#define NUM_SIDS             (sizeof(syssid)/sizeof(syssid[0]))

DECLARE_SLIST_OF(OS_SID) ;  // Defined in browmemb.cxx

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::ACCOUNT_NAMES_MLE

    SYNOPSIS:   MLE that allows the user to type account names.  Knows how
                to parse, recognizes well known and built in sids

    ENTRY:      fIsSingleSelect - Set to TRUE if only one name is allowed
                    (note that this processing is not dynamic)
                ulFlags - Selection flag passed to user browser dialog

    NOTES:

    HISTORY:
        Johnl   10-Dec-1992     Created
        Johnl   02-Jul-1993     Add names for well known/builtin SIDs
                                in the local machine language and the remote
                                machine language for comparison purposes

********************************************************************/

ACCOUNT_NAMES_MLE::ACCOUNT_NAMES_MLE( OWNER_WINDOW * powin,
                                      CID   cid,
                                      const TCHAR * pszServer,
                                      NT_USER_BROWSER_DIALOG * pUserBrowser,
                                      BOOL  fIsSingleSelect,
                                      ULONG ulFlags,
                                      enum  FontType fonttype )
    : MLE_FONT( powin, cid, fonttype ),
      _fIsSingleSelect( fIsSingleSelect ),
      _nlsTargetDomain(),
      _ulFlags        ( ulFlags ),
      _pUserBrowser   ( pUserBrowser )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    if ( err = _nlsTargetDomain.QueryError() )
    {
        ReportError( err ) ;
        return ;
    }

    OS_SID * apossidWellKnown[NUM_SIDS] ;
    for ( int i = 0 ; i < NUM_SIDS ; i++ )
    {
        apossidWellKnown[i] = NULL ;
    }

    { // Help C++ with Exit label
        //
        //  Fill in the array of well known PSIDs so we can do a lookup
        //
        PSID apsid[NUM_SIDS] ;
        for ( i = 0 ; i < NUM_SIDS ; i++ )
        {
            apossidWellKnown[i] = new OS_SID ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( apossidWellKnown[i] == NULL ||
                 (err = apossidWellKnown[i]->QueryError()) ||
                 (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( syssid[i],
                                                             apossidWellKnown[i] )))
            {
                goto Exit ;
            }

            apsid[i] = apossidWellKnown[i]->QueryPSID() ;
        }

        //
        //  Lookup the well known names.  Make qualification relative to the built
        //  in domain so the builtin sids don't get qualified
        //
        LSA_POLICY LSAPolicyTarget( pszServer ) ;
        OS_SID ossidBuiltinDomain ;

        if ( err ||
            (err = LSAPolicyTarget.QueryError())        ||
            (err = ossidBuiltinDomain.QueryError())     ||
            (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_BuiltIn,
                                                        &ossidBuiltinDomain )))
        {
            ReportError( err ) ;
            return ;
        }

        if ((err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                          LSAPolicyTarget,
                                          ossidBuiltinDomain.QueryPSID(),
                                          apsid,
                                          NUM_SIDS,
                                          FALSE,
                                          &_strlistBuiltin)) )
        {
            DBGEOL("ACCOUNT_NAMES_MLE::ct - Error " << (ULONG) err
                    << " returned from GetQualifiedAccountNames") ;
            ReportError( err ) ;
            return ;
        }

        //
        //  Move the well known accounts into _strlistWellKnown and strip the
        //  account name from the builtin accounts
        //

        NLS_STR   nlsAccount ;
        NLS_STR   nlsDomain ;

        NLS_STR * pnls ;
        ITER_STRLIST iter(_strlistBuiltin) ;

        for ( i = 0 ; i < NUM_SIDS ; i++ )
        {
            if ( i < NUM_WELLKNOWN_SIDS )
            {
                if ( err = _strlistWellKnown.Add( pnls = _strlistBuiltin.Remove( iter )) )
                {
                    delete pnls ;
                    goto Exit ;
                }
#ifdef VERBOSE
                TRACEEOL("ACCOUNT_NAMES_MLE::ct - Adding well known name " <<
                       *pnls);
#endif
            }
            else
            {
                //
                //  Builtin accounts, strip the domain
                //
                pnls = iter.Next() ;
                UIASSERT( pnls != NULL ) ;
                if ( (err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                                   *pnls,
                                                                   &nlsAccount )) ||
                     (err = pnls->CopyFrom( nlsAccount )) )
                {
                    goto Exit ;
                }
#ifdef VERBOSE
                TRACEEOL("ACCOUNT_NAMES_MLE::ct - Adding built in name " <<
                       *pnls);
#endif
            }
        }
    }
Exit:
    if ( err )
        ReportError( err ) ;

    //
    //  Delete the SIDs we looked up
    //
    for ( i = 0 ; i < NUM_SIDS ; i++ )
    {
        delete apossidWellKnown[i] ;
    }
}

ACCOUNT_NAMES_MLE::~ACCOUNT_NAMES_MLE()
{
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::ParseUserNameList

    SYNOPSIS:   Parses a user entered list of account names

    ENTRY:      pstrlstNames - STRLIST of parsed names suitable for doing
                    lookups on
                pszDomainName - Unqualified accounts are qualified with this
                                (and will be used for LsaLookupNames)
                pbuffStartPos - Buffer that will contain an array of name
                    start positions (in count of characters).

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Double quotes ('"') and semi-colons (';') are not valid
                in account names.

    HISTORY:
        Johnl   05-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::ParseUserNameList( STRLIST *       pstrlstNames,
                                             const TCHAR *   pszDomainName )
{
TRACETIMESTART;
    UIASSERT( pstrlstNames != NULL ) ;

    pstrlstNames->Clear() ;

TRACETIMESTART2( querytext );
    APIERR err = NERR_Success ;
    NLS_STR nlsNames ;
    if ( (err = nlsNames.QueryError()) ||
         (err = QueryText( &nlsNames )) )
    {
        return err ;
    }
TRACETIMEEND2( querytext, "ACCOUNT_NAMES_NLE::ParseUserNameList; QueryText " );

    ISTR istrBeginningOfString( nlsNames ) ;
    ISTR istrStart( nlsNames ) ;
    ISTR istrEnd  ( nlsNames ) ;
    ISTR istr     ( nlsNames ) ;
    NLS_STR * pnlsName = NULL ;
    BOOL fDone    = FALSE ;     // No more names to process
    BOOL fInName  = FALSE ;     // We're processing name (affects spaces)
    BOOL fInQuote = FALSE ;     // We're in a ""
    BOOL fNewName = FALSE ;     // When we've parsed a full name add it

    while ( !fDone && !err )
    {
        switch ( nlsNames.QueryChar( istr ) )
        {
        case TCH('\"'):
            if ( !fInQuote )
            {
                fInQuote = TRUE ;
                fInName  = TRUE ;
                ++istr ;
                istrStart = istr ;
            }
            else
            {
                //
                //  We've found the close quote so extract the string then
                //  start over again at the next semi-colon
                //
                istrEnd = istr ;
                fNewName = TRUE ;

                if ( nlsNames.strchr( &istr, TCH(';'), istr ) )
                    ++istr ;    // move past ';'
                else
                    fDone = TRUE ;
            }
            break ;

        case TCH(' '):
            {
                //
                //  Strip spaces
                //
                ISTR istrStartSpace = istr ;
                TCHAR tch ;
                while ( (tch = nlsNames.QueryChar( istr )) == TCH(' ') )
                    ++istr ;

                //
                //  Retain all spaces in quotes.
                //  else If we hit a ';' not in quotes
                //      or the end of the string, then we have a new string
                //  else if we aren't currently in a name, strip the space
                //
                if ( fInQuote )
                    continue ;
                else if ( tch == TCH(';') || tch == TCH('\0') )
                {
                    istrEnd = istrStartSpace ;
                    fNewName = TRUE ;
                    ++istr ;    // move past ';'
                    fDone = (tch == TCH('\0')) ;
                }
                else if ( !fInName )
                {
                    //
                    //  Strips leading spaces
                    //
                    istrStart = istr ;
                }
            }
            break ;

        case TCH('\0'):
            fDone = TRUE ;
            fNewName = TRUE ;
            istrEnd = istr ;
            break ;

        case TCH('\r'):       // Carriage return or line feed gets aliased
        case TCH('\n'):       // to the semi-colon
        case TCH(';'):
            if ( fInQuote )
                ++istr ;
            else
            {
                fNewName = TRUE ;
                istrEnd = istr ;
                ++istr ;
            }
            break ;


        default:
            if ( !fInName )
            {
                fInName = TRUE ;
                istrStart = istr ;
            }
            ++istr ;
            continue ;
        }

        //
        //  Add the extracted name if there is one to add
        //
        if ( fNewName )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( NULL == (pnlsName = nlsNames.QuerySubStr( istrStart, istrEnd )) ||
                 (err = pnlsName->QueryError()) ||
                 (pnlsName->strlen() == 0)      ||
                 (err = pstrlstNames->Append( pnlsName )) )
            {
                delete pnlsName ;
                pnlsName = NULL ;
            }
            else if ( !IsWellKnownAccount( *pnlsName ) )
            {
				// NTRAID#NTBUG9-574280-2002/03/08-artm  Prefast: Redeclaration of istr.
				// Hides declaration of istr at function level.

                //
                //  We have a valid string, qualify if necessary
                //
                ISTR istr( *pnlsName ) ;

                //
                //  If the name leads with a slash, strip it
                //
                if ( pnlsName->QueryChar( istr ) == '\\' )
                {
                    ISTR istrEndWhack( istr ) ;
                    ++istrEndWhack ;
                    pnlsName->DelSubStr( istr, istrEndWhack ) ;
                }

                NLS_STR nlsAccountName( *pnlsName ) ;
                ALIAS_STR nlsDomain( pszDomainName ) ;
                if ( (err = nlsAccountName.QueryError())  ||
                     (!pnlsName->strchr( &istr, TCH('\\')) &&
                     (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                                  pnlsName,
                                                  nlsAccountName,
                                                  nlsDomain))) )
                {
                    // fall through
                }
            }

            //
            //  We will only parse the first name if we are single select
            //
            if ( !err && pnlsName != NULL && IsSingleSelect() )
            {
                break ;
            }

            fInQuote  = FALSE ;
            fInName   = FALSE ;
            fNewName  = FALSE ;
            pnlsName  = NULL ;
            istrStart = istr ;
        }
    }

    //
    //  The last thing we do is remove duplicates from the strlist
    //
    RemoveDuplicateAccountNames( pstrlstNames ) ;

#ifdef VERBOSE
    TRACEEOL("Parsed the following names:") ;
    ITER_STRLIST iter( *pstrlstNames ) ;
    while ( pnlsName = iter.Next() )
    {
        TRACEEOL("\t\"" << pnlsName->QueryPch() << "\"") ;
    }
#endif

TRACETIMEEND( "ACCOUNT_NAMES_MLE::ParseUserNameList took " );
    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::IsWellKnownAccount

    SYNOPSIS:   Searches the well known account list for this name

    ENTRY:      nlsName - Name to search against

    RETURNS:    TRUE if this is a well known account name

    NOTES:

    HISTORY:
        Johnl   09-Dec-1992     Created

********************************************************************/

BOOL ACCOUNT_NAMES_MLE::IsWellKnownAccount( const NLS_STR & nlsName )
{
    ITER_STRLIST iter( _strlistWellKnown ) ;
    NLS_STR * pnls ;

#ifdef VERBOSE
    TRACEEOL("ACCOUNT_NAMES_MLE::IsWellKnownAccount - Checking " << nlsName );
#endif
    while ( pnls = iter.Next() )
    {
        if ( nlsName._stricmp( *pnls ) == 0 )
        {
#ifdef VERBOSE
            TRACEEOL("ACCOUNT_NAMES_MLE::IsWellKnownAccount - Matched against well known list");
#endif
            return TRUE ;
        }
    }

    //
    //  Next, look in the cache of items the user has already added.  If the
    //  name matches and this is a well known sid type, then this is a well
    //  known sid.  This gets around the problem of adding a well known
    //  account from a domain of a different language.
    //
    ITER_SL_OF(USER_BROWSER_LBI) iterCache( *_pUserBrowser->QuerySelectionCache()) ;
    USER_BROWSER_LBI * plbi;

    while ( plbi = iterCache.Next() )
    {
        if ( ::stricmpf( nlsName.QueryPch(), plbi->QueryDisplayName()) == 0 &&
             plbi->QueryType() == SidTypeWellKnownGroup)
        {
#ifdef VERBOSE
            TRACEEOL("ACCOUNT_NAMES_MLE::IsWellKnownAccount - Matched against Cached LBI list");
#endif
            return TRUE ;
        }
    }

    return FALSE ;
}


/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::RemoveDuplicateAccountNames

    SYNOPSIS:   Removes duplicate account names from the strlist

    ENTRY:      pstrlstNames - List of names generated by ParseUserNameList

    EXIT:       All duplicates will be removed

    NOTES:

    HISTORY:
        Johnl   08-Dec-1992     Created

********************************************************************/

void ACCOUNT_NAMES_MLE::RemoveDuplicateAccountNames( STRLIST * pstrlstNames )

{
    UIASSERT( pstrlstNames != NULL ) ;
    ITER_STRLIST iter1( *pstrlstNames ) ;
    ITER_STRLIST iter2( *pstrlstNames ) ;
    NLS_STR *pnls1, *pnls2 ;


    while ( (pnls1 = iter1.Next()) != NULL )
    {
        //
        //  Since we are scanning the same list, we will always find ourselves
        //  at least once.  It's more then once that we remove
        //
        BOOL fFoundOnce = FALSE ;

        //
        //  If we removed an item the last time through, the iterator
        //  has already moved on, so don't move it again
        //
        BOOL fDoNextString = TRUE ;

        while ( (pnls2 = (fDoNextString ? iter2.Next()
                                        : iter2.QueryProp())) != NULL )
        {
            fDoNextString = TRUE;
            if ( pnls1->_stricmp( *pnls2 ) == 0 )
            {
                if ( fFoundOnce )
                {
                    pnls2 = pstrlstNames->Remove( iter2 ) ;
                    ASSERT( pnls2 != NULL );
                    fDoNextString = FALSE;
                    delete pnls2 ;
                }
                else
                {
                    fFoundOnce = TRUE ;
                }
            }
        }
        iter2.Reset() ;
    }
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::BuildNameStrFromAccountList

    SYNOPSIS:   Builds a concatenated string of accounts from the account
                strlist

    ENTRY:      pnlsNames - String to receive the list
                pstrlstNames - List of account names

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   09-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::BuildNameListFromStrList(
                                        NLS_STR * pnlsNames,
                                        STRLIST * pstrlstNames )
{
TRACETIMESTART;
    APIERR err = NERR_Success ;

    ITER_STRLIST iter( *pstrlstNames ) ;
    NLS_STR * pnls ;
    *pnlsNames = SZ("") ;
    while ( pnls = iter.Next() )
    {
        if ( pnlsNames->strlen() != 0 )
        {
            if ( (err = pnlsNames->AppendChar( TCH(';') )) ||
                 (err = pnlsNames->AppendChar( TCH(' ') ))   )
            {
                break ;
            }
        }

        if ( err = pnlsNames->Append( *pnls ) )
        {
            break ;
        }
    }

TRACETIMEEND( "ACCOUNT_NAMES_MLE::BuildNameListFromStrList " );
    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CreateLBIListFromNames

    SYNOPSIS:   Converts the list of names in strlstNames to a list of
                USER_BROWSER_LBIs that the selection iterator can handle

    ENTRY:      pszServer - Where to do the LsaLookup
                pszDomain - Current domain to use for unqualified names
                pslUsrBrowLBIsCache - Cached user browser LBIs
                pslReturn - The list of LBIs the user wants
                perrNameListError - Error code if can't find name etc
                pnlsFailingName - First account name that failed

    RETURNS:    NERR_Success if successful, error code otherwise.
                perrNameListError will contain the error caused by a bad
                name entry.

    NOTES:      strlstNames gets trashed.

    HISTORY:
        Johnl   05-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CreateLBIListFromNames(
                                   const TCHAR * pszServer,
                                   const TCHAR * pszDomain,
                                   SLIST_OF(USER_BROWSER_LBI) *pslUsrBrowLBIsCache,
                                   SLIST_OF(USER_BROWSER_LBI) *pslReturn,
                                   APIERR  * perrNameListError,
                                   NLS_STR * pnlsFailingName )
{
TRACETIMESTART;
    APIERR err = NERR_Success ;
    *perrNameListError = NERR_Success ;

    STRLIST strlstNames ;

TRACETIMESTART2( canon );
    if ( (err = CanonicalizeNames( pszDomain, &strlstNames )) != NERR_Success )
    {
        return err ;
    }
TRACETIMEEND2( canon, "CreateLBIListFromNames canonicalize time " );

    if ( strlstNames.QueryNumElem() == 0 )
        return NERR_Success ;

    ITER_SL_OF( USER_BROWSER_LBI ) iterCache( *pslUsrBrowLBIsCache ) ;
    ITER_SL_OF( USER_BROWSER_LBI ) iterReturn( *pslReturn ) ;
    ITER_STRLIST iterstrlst( strlstNames ) ;
    USER_BROWSER_LBI * plbi = NULL ;
    NLS_STR * pnls ;

    do { // error breakout

        //
        //  Scan the list of cached LBIs and see if there are any items that
        //  we don't have to lookup
        //

TRACETIMESTART2( scan );
        BOOL fDoNextCache = TRUE ;
        while ( (plbi = fDoNextCache ? iterCache.Next() : plbi ) != NULL && !err )
        {
            fDoNextCache = TRUE ;

            while ( (pnls = iterstrlst.Next()) != NULL && !err )
            {
                if ( ::stricmpf( plbi->QueryDisplayName(), pnls->QueryPch() ) == 0 )
                {
                    pnls = strlstNames.Remove( iterstrlst ) ;
#ifdef VERBOSE
                    TRACEEOL("CreateLBIListFromNames - Cache hit on " << *pnls) ;
#endif
                    delete pnls ;
                    plbi = pslUsrBrowLBIsCache->Remove( iterCache ) ;
                    if ( err = pslReturn->Add( plbi ) )
                    {
                        break ;
                    }

                    //
                    //  The remove bumps the iter to the next item so don't
                    //  do the next this time
                    //
                    fDoNextCache  = FALSE ;
                    plbi = iterCache.QueryProp() ;

                    break ;
                }
            }

            iterstrlst.Reset() ;
        }
TRACETIMEEND2( scan, "CreateLBIListFromNames scan time " );
        if ( err )
            break ;

        //
        //  If all of the items were in the cache, then we don't need to do
        //  anything else.
        //

        UINT cNames = strlstNames.QueryNumElem() ;
        if ( cNames == 0 )
        {
            TRACEEOL( "CreateLBIListFromNames all items cached" );
            break ;
        }

        //
        //  strlstNames now contains all the names that we have to lookup,
        //  so look them up
        //

        BUFFER buffpch( sizeof(LPTSTR) * cNames ) ;
        LSA_TRANSLATED_SID_MEM lsatsm ;
        LSA_REF_DOMAIN_MEM lsardm ;
        LSA_POLICY lsapol( pszServer ) ;

        if ( (err = buffpch.QueryError()) ||
             (err = lsatsm.QueryError())  ||
             (err = lsardm.QueryError())  ||
             (err = lsapol.QueryError())    )
        {
            break ;
        }

        LPTSTR * alptstr = (LPTSTR *) buffpch.QueryPtr() ;

TRACETIMESTART2( strip );
        iterstrlst.Reset() ;
        for ( UINT i = 0 ; i < cNames ; i++ )
        {
            pnls = iterstrlst.Next() ;
            UIASSERT( pnls != NULL ) ;

            //
            //  Builtin accounts on the target domain need to have the
            //  machine name replaced with the "BUILTIN\" domain
            //  (LsaLookupNames requires this).  Well known accounts need
            //  to have the domain qualified stripped.
            //
            //  These accounts should always be found (thus we
            //  don't need to resubstitute on error).
            //

            BOOL fFound ;
            if ( (err = ReplaceDomainIfBuiltIn( pnls, &fFound )) ||
                 (!fFound &&
                 (err = StripDomainIfWellKnown( pnls )))  )
            {
                break ;
            }

            alptstr[i] = (LPTSTR) pnls->QueryPch() ;
        }
TRACETIMEEND2( strip, "CreateLBIListFromNames strip time " );
        if ( err )
            break ;

#ifdef VERBOSE
        TRACEEOL("Looking up:") ;
        for ( i = 0 ; i < cNames ; i++ )
        {
            TRACEEOL( alptstr[i] ) ;
        }
#endif

TRACETIMESTART2( lookup );
        err = lsapol.TranslateNamesToSids( (const TCHAR * const *) alptstr,
                                           cNames,
                                           &lsatsm,
                                           &lsardm ) ;
TRACETIMEEND2( lookup, "CreateLBIListFromNames lookup time " );

        //
        //  If none of the groups could be found, then NERR_GroupNotFound
        //  is returned.  If only some of the groups couldn't be found, then
        //  success is returned.  ValidateNames will catch any non-mapped
        //  names
        //

        if ( err == NERR_GroupNotFound )
        {
            err = NERR_Success ;
        }

        if ( err )
        {
            DBGEOL("CreateLBIListFromNames - Error " << err << " returned "
                   << " from TranslateNamesToSids") ;
            break ;
        }

        //
        //  Check for names that couldn't be found or names that aren't
        //  allowed
        //

TRACETIMESTART2( check );
        if ( (err = CheckLookedUpNames( alptstr,
                                        &lsatsm,
                                        &strlstNames,
                                        pnlsFailingName,
                                        pszDomain,
                                        perrNameListError )) ||
             *perrNameListError )
        {
            break ;
        }
TRACETIMEEND2( check, "CreateLBIListFromNames check time " );

        //
        //  Create LBIs and add them to the return list
        //

        NLS_STR nlsDomainName, nlsAccountName ;
        if ( (err = nlsDomainName.QueryError()) ||
             (err = nlsAccountName.QueryError())  )
        {
            break ;
        }

        SLIST_OF(OS_SID) slossid ;
        BUFFER buffapsid( cNames * sizeof( OS_SID * )) ;

        if ( err = buffapsid.QueryError() )
            break ;

TRACETIMESTART2( sidarray );
        PSID * apsid = (PSID *) buffapsid.QueryPtr() ;
        for ( i = 0 ; i < cNames ; i++ )
        {
            NLS_STR * pnlsAccountName = iterstrlst.Next() ;
            OS_SID * possid = new OS_SID( lsardm.QueryPSID( lsatsm.QueryDomainIndex( i  ) ),
                                          lsatsm.QueryRID( i )) ;
            err = ERROR_NOT_ENOUGH_MEMORY ;
            if ( possid == NULL ||
                 (err = possid->QueryError()) ||
                 (err = slossid.Add( possid )) )
            {
                delete possid ;
                break ;
            }

            apsid[i] = possid->QueryPSID() ;
        }
        if ( err )
            break ;
TRACETIMEEND2( sidarray, "CreateLBIListFromNames sidarray time " );

TRACETIMESTART2( createfromsids );
        if ( err = ::CreateLBIsFromSids( apsid,
                                         cNames,
                                         apsid[0],    // dummy
                                         &lsapol,
                                         pszServer,
                                         NULL,
                                         pslReturn ))
        {
            // Fall through (and out)
        }
TRACETIMEEND2( createfromsids, "CreateLBIListFromNames createfromsids time " );

    } while (FALSE) ;

    //
    //  If an error occurred, we have to move the items in from the return
    //  list back into the cache list
    //
    if ( err || *perrNameListError )
    {
TRACETIMESTART2( errfix );
        iterReturn.Reset() ;
        while (  plbi = pslReturn->Remove( iterReturn ) )
        {
            if ( err = pslUsrBrowLBIsCache->Add( plbi ) )
            {
                //
                //  Hmmm, well, nothing we can do but clear the return list
                //  and get out
                //

                pslReturn->Clear() ;
                break ;
            }
        }
TRACETIMEEND2( errfix, "CreateLBIListFromNames errfix time " );
    }

TRACETIMEEND( "CreateLBIListFromNames total time " );

    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CanonicalizeNames

    SYNOPSIS:   Forces the MLE to qualify unqualified names and remove
                duplicates

    ENTRY:      pszCurrentDomain - Domain to qualify unqualified names with

    EXIT:       The MLE will be reset with the new list of names

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The MLE will not be reset if an error occurs

    HISTORY:
        Johnl   10-Dec-1992     CReated

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CanonicalizeNames( const TCHAR * pszCurrentDomain,
                                             STRLIST * pstrlstNames )
{
TRACETIMESTART;
    UIASSERT( pszCurrentDomain != NULL ) ;

    STRLIST strlstTemp ;
    if (pstrlstNames == NULL)
        pstrlstNames = &strlstTemp;

    NLS_STR nlsNames ;
    APIERR err ;
    if ( (err = nlsNames.QueryError()) ||
         (err = ParseUserNameList( pstrlstNames, pszCurrentDomain )) ||
         (err = BuildNameListFromStrList( &nlsNames, pstrlstNames ))  )
    {
        // fall through
    }
    else
    {
        SetText( nlsNames ) ;
        Invalidate( TRUE ) ;        // Force update as soon as we canoned
    }

TRACETIMEEND( "ACCOUNT_NAMES_MLE::CanonicalizeNames total time " );
    return err ;
}


/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::ReplaceDomainIfBuiltIn

    SYNOPSIS:   Looks for any builtin accounts that are in the target domain
                (_nlsTargetDomain).  If it finds one, then it
                strips the domain.  Note we only do this for the target domain
                to impress upon the user that the built in sids are only valid
                in the target domain (accounts won't be found in other domains).

    ENTRY:      pnlsQualifiedAccount - String to check and modify if necessary
                pfFound - set to TRUE if this is a built in account

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::ReplaceDomainIfBuiltIn(
                                                NLS_STR * pnlsQualifiedAccount,
                                                BOOL    * pfFound )
{

    APIERR err = NERR_Success ;
    NLS_STR nlsAccount ;
    NLS_STR nlsDomain ;
    *pfFound = FALSE ;

    if (!(err = nlsAccount.QueryError()) &&
        !(err = nlsDomain.QueryError()) &&
        !(err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                          *pnlsQualifiedAccount,
                                                          &nlsAccount,
                                                          &nlsDomain )) )
    {
        if( !::I_MNetComputerNameCompare( _nlsTargetDomain, nlsDomain ) )
        {
            NLS_STR * pnls ;
            ITER_STRLIST iter( _strlistBuiltin ) ;
            while ( pnls = iter.Next() )
            {
                if (  nlsAccount._stricmp( *pnls ) == 0 )
                {
                    err = pnlsQualifiedAccount->CopyFrom( nlsAccount ) ;
                    *pfFound = TRUE ;
                    break ;
                }
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::StripDomainIfWellKnown

    SYNOPSIS:   Looks for any well known account names and strips the domain
                if necessary (Lsa requires well known accounts to not be
                qualified).

    ENTRY:      pnlsAccount - String to check and modify if necessary

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   11-Dec-1992     Created

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::StripDomainIfWellKnown( NLS_STR * pnlsAccount )
{
    APIERR err = NERR_Success ;

    NLS_STR nlsAccount ;
    if (!(err = nlsAccount.QueryError()) &&
        !(err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                          *pnlsAccount,
                                                          &nlsAccount )) )
    {
        NLS_STR * pnls ;
        ITER_STRLIST iter( _strlistWellKnown ) ;
        while ( pnls = iter.Next() )
        {
            if (  nlsAccount._stricmp( *pnls ) == 0 )
            {
                err = pnlsAccount->CopyFrom( nlsAccount ) ;
                break ;
            }
        }
    }

    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CheckLookedUpNames

    SYNOPSIS:   Checks the selected names with the "USRBROWS_SHOW_*" and
                "USRBROWS_INCL_*" flags.  Prevents the user from typing in
                a name that the client doesn't want.

    ENTRY:      alptstr - Array of looked up names
                plsatsm - Translated sid mem
                pstrlist - Strlist representing the contents of the MLE, used
                    to locate and hi-lite the offending name
                pnlsFailingName - This will be filled with the first name
                    that failed so we can show the user in the error message.
                pszDomain - Domain qualifier for parsing names with
                perrNameListError - Error code indicating what error should
                    be shown to the user

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   04-Jan-1992     Broke out, added exclusion functionality

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CheckLookedUpNames(
                                      LPTSTR      * alptstr,
                                      LSA_TRANSLATED_SID_MEM * plsatsm,
                                      STRLIST     * pstrlist,
                                      NLS_STR     * pnlsFailingName,
                                      const TCHAR * pszDomain,
                                      APIERR      * perrNameListError )
{
TRACETIMESTART;
    APIERR err = NERR_Success ;
    *perrNameListError = NERR_Success ;

    do { // error breakout

        //
        //  Check the accounts we looked up with the accounts the client
        //  requested.
        //

        BOOL fFoundBadAccount = FALSE ;
        ULONG iFailingName = 0 ;
        BOOL fFoundAllAccounts = !plsatsm->QueryFailingNameIndex( &iFailingName ) ;

        if ( fFoundAllAccounts )
        {
            for ( iFailingName = 0 ;
                  iFailingName < plsatsm->QueryCount() ;
                  iFailingName++ )
            {
                *perrNameListError = CheckNameType(
                        plsatsm->QueryUse( iFailingName ),
                        QueryFlags() );
                if ( *perrNameListError )
                {
                    fFoundBadAccount = TRUE ;
                    break ;
                }
            }
        }
        else
        {
            *perrNameListError = IDS_CANT_FIND_ACCOUNT ;
        }


        //
        //  Figure out which name failed (if any) and figure out where
        //  it occurred in the list so we can hi-lite it.
        //

        if ( !fFoundAllAccounts || fFoundBadAccount )
        {
            if ((err = pnlsFailingName->CopyFrom( alptstr[iFailingName] )) ||
                (err = ParseUserNameList( pstrlist, pszDomain )) )
            {
                break ;
            }

            ITER_STRLIST iterstrlst( *pstrlist ) ;
            NLS_STR * pnls ;
            INT IndexFailingNameStart = 0 ;
            INT IndexFailingNameEnd = 0 ;

#ifdef VERBOSE
            TRACEEOL("CreateLBILIstFromNames - Search for failing name " << *pnlsFailingName ) ;
#endif
            while ( pnls = iterstrlst.Next() )
            {
                if ( *pnlsFailingName == *pnls )
                {

                    IndexFailingNameEnd = IndexFailingNameStart +
                                          pnls->QueryNumChar() ;
                    break ;
                }

                //
                //  "+2" is for the " ;"
                //
                IndexFailingNameStart += pnls->QueryNumChar() + 2 ;
            }

            Command( EM_SETSEL,
                     (WPARAM) IndexFailingNameStart,
                     (LPARAM) IndexFailingNameEnd ) ;

        }
    } while ( FALSE ) ;

TRACETIMEEND( "ACCOUNT_NAMES_MLE::CheckLookedUpNames total " );
    return err ;
}

/*******************************************************************

    NAME:       ACCOUNT_NAMES_MLE::CheckNameType

    SYNOPSIS:   Checks whether the application will accept names of this type.

    ENTRY:      use - type of name
                ulFlags - flags as passed to User Browser

    RETURNS:    NERR_Success if successful, error message otherwise.

    NOTES:

    HISTORY:
        Johnl   04-Jan-1992     Broke out, added exclusion functionality
        JonN    16-May-1994     Split from CheckLookedUpNames

********************************************************************/

APIERR ACCOUNT_NAMES_MLE::CheckNameType( SID_NAME_USE use, ULONG ulFlags )
{
    APIERR err = NERR_Success;
    switch ( use )
    {
    case SidTypeUser:
        if ( !(ulFlags & USRBROWS_SHOW_USERS) )
            err = IDS_CANT_ADD_USERS ;
        break ;

    case SidTypeGroup:
        if ( !(ulFlags & USRBROWS_SHOW_GROUPS) )
            err = IDS_CANT_ADD_GROUPS ;
        break ;

    case SidTypeAlias:
        if ( !(ulFlags & USRBROWS_SHOW_ALIASES) )
            err = IDS_CANT_ADD_ALIASES ;
        break ;

    case SidTypeWellKnownGroup:
        if ( !(ulFlags & USRBROWS_INCL_ALL) )
            err = IDS_CANT_ADD_WELL_KNOWN_GROUPS ;
        break ;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltapp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltapp.cxx
    APPLICATION class implementation

    FILE HISTORY:
        rustanl     17-Jun-1991 Created, mostly from APPSTART
        rustanl     15-Jul-1991 Code review changes (no functional
                                differences).  CR attended by
                                BenG, ChuckC, Hui-LiCh, TerryK, RustanL.
        beng        17-Oct-1991 Moved WinMain into this module
        beng        29-Jun-1992 Removed WinMain to the .hxx file
*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       APPLICATION::APPLICATION

    SYNOPSIS:   APPLICATION constructor.

    ENTRY:      hInstance -         Application's instance handle
                nCmdShow -          Show-window type (open/icon)

    EXIT:       _fMsgPopupIsInit -  TRUE if the MsgPopup mechanism was
                                    installed, and FALSE otherwise.
                                    If this mechanism was successfully
                                    installed, MsgPopup can be used to
                                    display messages.  _fMsgPopupIsInit
                                    is used in APPLICATION::Run.

    NOTES:
        Need to think about command-line access someday.
        Needs to pass along nCmdShow to BLT and Do The Right Thing.

    HISTORY:
        rustanl     17-Jun-1991 Created
        rustanl     09-Jul-1991 Added MEM_MASTER::Init
        rustanl     09-Sep-1991 Intialize BLT_MASTER_TIMER
        beng        18-Oct-1991 Win32 conversion
        beng        24-Apr-1992 Change command-line support
        beng        03-Aug-1992 Dllization of resources

********************************************************************/

APPLICATION::APPLICATION( HINSTANCE hInstance, INT nCmdShow,
                          UINT idMinR, UINT idMaxR,
                          UINT idMinS, UINT idMaxS )
    : _hInstance( hInstance ),
      _fMsgPopupIsInit( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

    UNREFERENCED( nCmdShow );

#if !defined(WIN32) // only needed for Win16
    ::init_strlib();
#endif

#if !defined(WIN32) // ditto
    if ( ! MEM_MASTER::Init() )
    {
        // This should never happen because MEM_MASTER::Init only
        // allocates some 30 bytes out of the local heap (in the
        // automatic data segment).  If this fails, it is probably
        // due to a programmer error, viz. not specifying a
        // "HEAP" in the .def file.
        //
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
#endif

    APIERR err = BLT::Init( _hInstance, idMinR, idMaxR, idMinS, idMaxS );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _fMsgPopupIsInit = TRUE;        // MsgPopup is now available

    err = BLT_MASTER_TIMER::Init();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       APPLICATION::~APPLICATION

    SYNOPSIS:   APPLICATION destructor

    HISTORY:
        rustanl     17-Jun-1991 Created
        rustanl     09-Jul-1991 Added MEM_MASTER::Term
        rustanl     09-Sep-1991 Added BLT_MASTER_TIMER::Term
        beng        18-Oct-1991 Win32 conversion
        DavidHov    22-Nov-1991 Heap Residue checking for Win32
        beng        04-Aug-1992 Dllization

********************************************************************/

APPLICATION::~APPLICATION()
{
    BLT_MASTER_TIMER::Term();

    BLT::Term( _hInstance );

#if !defined(WIN32)
    if ( ! MEM_MASTER::Term() )
    {
        // There was some memory residue from allocations.  Warn
        // the programmer.
        //
        DBGEOL("APPLICATION termination: some memory residue exists");
    }
#else
    // The Win32 version checks its heap at DLL process detach time
#endif
}


/*******************************************************************

    NAME:       APPLICATION::Run

    SYNOPSIS:   Allows the application to run, by:
                    - verifying its construction
                    - running its message loop

    ENTRY:      An APPLICATION object after all of its constructors
                have been called.

    RETURNS:    The application's return code (from the pump).

    NOTES:
        This is a virtual member function.

        This method is analogous to DIALOG_WINDOW::Process.

    HISTORY:
        rustanl     17-Jun-1991 Created
        beng        09-Jul-1991 Added new FilterMessage scheme
        rustanl     29-Aug-1991 Virtualized Run
        beng        07-Oct-1991 Uses HAS_MESSAGE_PUMP::RunMessagePump

********************************************************************/

INT APPLICATION::Run()
{
    UIASSERT( QueryError() == NERR_Success );   // otherwise, this method
                                                // shouldn't have been
                                                // called

    return (INT)RunMessagePump();
}


/*******************************************************************

    NAME:       APPLICATION::DisplayCtError

    SYNOPSIS:   Displays a constructor error

    ENTRY:      err -       The error to be displayed

    NOTES:      Since construction failed, MsgPopup may not be
                available.  If so, no error is displayed.

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

VOID APPLICATION::DisplayCtError( APIERR err )
{
    ASSERTSZ( (err != NERR_Success), "APPLICATION construction failed" );

    if ( _fMsgPopupIsInit )
    {
        ::MsgPopup( (HWND)NULL, err );
    }
}


/*******************************************************************

    NAME:       APPLICATION::IsSystemInitialized

    SYNOPSIS:   Determines if the *system* is properly initialized.

    RETURNS:    BOOL - TRUE if system init OK, FALSE otherwise.

    NOTES:      This is a static method.

    HISTORY:
        keithmo     13-May-1993     Created

********************************************************************/

BOOL APPLICATION::IsSystemInitialized( VOID )
{
    return ( ::GetDesktopWindow() != NULL );

}   // APPLICATION::IsSystemInitialized
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltapwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltapwin.cxx
    Implementation of BLT application window classes


    FILE HISTORY:
        beng        13-May-1991     Created
        terryk      25-Jul-1991     Add WM_GETMINMAXINFO to the dispatcher
        rustanl     05-Sep-1991     Added Close

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       APP_WINDOW::APP_WINDOW

    SYNOPSIS:   Construct a new application window

    ENTRY:      xyPos       - origin of window on screen
                dxySize     - size of window
                nlsTitle    - caption of window
                pszIcon     - name of icon resource
                pszMenu     - name of menu resource

    NOTES:

    HISTORY:
        beng        08-Jul-1991 SetCaption changed to SetText
        beng        01-Nov-1991 Use MapLastError
        beng        03-Aug-1992 Use IDRESOURCE

********************************************************************/

APP_WINDOW::APP_WINDOW( XYPOINT xyPos, XYDIMENSION dxySize,
                        const NLS_STR &    nlsTitle,
                        const IDRESOURCE & idIcon,
                        const IDRESOURCE & idMenu )
    : CLIENT_WINDOW( WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, NULL ),
      _hmenu(0),
      _hicon(0)
{
    if (QueryError())
        return;

    SetPos(xyPos);
    SetSize(dxySize);
    SetText(nlsTitle);
    if (!SetMenu(idMenu) || !SetIcon(idIcon))
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_FUNCTION));
        return;
    }
}


APP_WINDOW::APP_WINDOW( const NLS_STR &    nlsTitle,
                        const IDRESOURCE & idIcon,
                        const IDRESOURCE & idMenu )
    : CLIENT_WINDOW( WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, NULL ),
      _hmenu(0),
      _hicon(0)
{
    if (QueryError())
        return;

    SetText(nlsTitle);

    if (!SetMenu(idMenu) || !SetIcon(idIcon))
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_FUNCTION));
        return;
    }
}


/*******************************************************************

    NAME:       APP_WINDOW::~APP_WINDOW

    SYNOPSIS:   Destructor for APP_WINDOW.
                Releases resources held by the window.

    NOTES:
        As Windows will clean up after the menu (it being attached
        to the window via SetMenu), this code must not DestroyMenu it.

    HISTORY:
        beng        08-Jul-1991     Created

********************************************************************/

APP_WINDOW::~APP_WINDOW()
{
    if (_hicon != 0)
    {
#if !defined(WIN32)
        // There is currently no way to set this to any system icon.
        // Hence FreeResource is always correct.
        //
        ::FreeResource(_hicon);
#endif
    }
}


/*******************************************************************

    NAME:       APP_WINDOW::SetMenu

    SYNOPSIS:   Establishes the menubar for an application window

    ENTRY:      pszMenuResource - names the menu resource

    EXIT:       Resource has been loaded;
                menubar has been drawn on the window

    RETURNS:    FALSE if resource is bad or other error

    NOTES:

    HISTORY:
        beng        08-Jul-1991 Header added
        beng        03-Aug-1992 Use IDRESOURCE; dllization

********************************************************************/

BOOL APP_WINDOW::SetMenu( const IDRESOURCE & idMenu )
{
    HMODULE hmod = BLT::CalcHmodRsrc(idMenu);

    HMENU hmenu = ::LoadMenu(hmod, idMenu.QueryPsz());
    if (hmenu == 0)
        return FALSE;

    BOOL fRet = ::SetMenu(QueryHwnd(), hmenu);
    if (!fRet)
    {
        fRet = ::DestroyMenu(hmenu);
        UIASSERT(fRet);
        return FALSE;
    }

    if (_hmenu != 0)
    {
        fRet = ::DestroyMenu(_hmenu);
        UIASSERT(fRet);
    }

    _hmenu = hmenu;
    ::DrawMenuBar(QueryHwnd());
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::QueryMenu

    SYNOPSIS:   Returns the handle to the current menubar

    NOTES:      If no menubar loaded, returns NULL

    HISTORY:
        beng        08-Jul-1991     Header added

********************************************************************/

HMENU APP_WINDOW::QueryMenu() const
{
    return _hmenu;
}


/*******************************************************************

    NAME:       APP_WINDOW::SetIcon

    SYNOPSIS:   Sets the icon for an application window

    ENTRY:      pszIconResource - string naming the resource

    EXIT:       Icon has been loaded for the window,
                but not necessarily drawn

    RETURNS:    TRUE if successful

    NOTES:

    HISTORY:
        beng        08-Jul-1991 Implemented
        beng        03-Aug-1992 Use IDRESOURCE; dllization

********************************************************************/

BOOL APP_WINDOW::SetIcon( const IDRESOURCE & idIcon )
{
    HMODULE hmod = BLT::CalcHmodRsrc(idIcon);
    HICON hicon = ::LoadIcon(hmod, idIcon.QueryPsz());
    if (hicon == NULL)
        return FALSE;

    // Maybe there's already an icon loaded?

    if (_hicon != NULL)
    {
#if !defined(WIN32)
        BOOL fRet = ::FreeResource(_hicon);
        UIASSERT(fRet);
#endif
        _hicon = NULL;
    }

    _hicon = hicon;
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::QueryIcon

    SYNOPSIS:   Returns the handle to the current app icon

    NOTES:      If no icon loaded, returns NULL

    HISTORY:
        beng        08-Jul-1991     Header added

********************************************************************/

HICON APP_WINDOW::QueryIcon() const
{
    return _hicon;
}


/*******************************************************************

    NAME:       APP_WINDOW::DispatchMessage

    SYNOPSIS:   Message dispatcher for application window

    ENTRY:      EVENT - an event in the window

    EXIT:

    RETURNS:    TRUE if message handled completely
                FALSE if system-standard behavior still needed

    NOTES:

    HISTORY:
        beng        08-Jul-1991 Added icon drawing, correct OnShutdown;
                                changed return type to LONG
        beng        30-Mar-1992 Corrected icon background drawing

********************************************************************/

LRESULT APP_WINDOW::DispatchMessage( const EVENT &event )
{
    switch (event.QueryMessage())
    {
    case WM_WININICHANGE:
    case WM_DEVMODECHANGE:
    case WM_TIMECHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_PALETTECHANGED:
    case WM_FONTCHANGE:
        return OnSystemChange((const SYSCHANGE_EVENT &)event);

    case WM_GETMINMAXINFO:
        return OnQMinMax(( QMINMAX_EVENT & ) event );

    case WM_INITMENU:
        return OnMenuInit((const MENU_EVENT &)event);

    case WM_MENUSELECT:
        return OnMenuSelect((const MENUITEM_EVENT &)event);

    case WM_QUERYOPEN:
        return !MayRestore();

    case WM_QUERYENDSESSION:
        return !MayShutdown();

    case WM_ENDSESSION:
        if (event.QueryWParam())
            OnShutdown();
        return TRUE;

    case WM_QUERYDRAGICON:
        return (LRESULT)QueryIcon();

    case WM_ERASEBKGND:
        // If noniconic, Win will erase the background to the brush
        // supplied at class ct time.
        //
        if (!IsMinimized())
            break;

        // When iconic, do not erase the background; the DrawIcon
        // code will do so at paint time.
        //
        return 1;

    case WM_PAINT:
        // Dispatch OnPaintReq when noniconic.
        //
        if (!IsMinimized())
            break;

        // Iconic appwindow needs an icon drawn, since none
        // is supplied by the winclass.
        //
        return DrawIcon();

    case WM_COMMAND:
        {
            const CONTROL_EVENT & ctrle = (const CONTROL_EVENT &)event;

            if (ctrle.QueryHwnd() == 0)
                return OnMenuCommand((MID)ctrle.QueryCid());
            else
                return OnCommand((const CONTROL_EVENT &)ctrle);
        }
    }

    // Message not handled (default)
    //
    return CLIENT_WINDOW::DispatchMessage(event);
}


/*******************************************************************

    NAME:       APP_WINDOW::OnMenuInit

    SYNOPSIS:   Called when a menu is first pulled down

    ENTRY:      Event from Windows

    RETURNS:    TRUE if client handles message

    HISTORY:
        beng        15-Oct-1991 Header added

********************************************************************/

BOOL APP_WINDOW::OnMenuInit( const MENU_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnMenuSelect

    SYNOPSIS:   Called when a menu item is selected

    ENTRY:      Event from Windows

    RETURNS:    TRUE if client handles message

    CAVEATS:
        Do not confuse with OnMenuCommand.

    HISTORY:
        beng        15-Oct-1991 Header added

********************************************************************/

BOOL APP_WINDOW::OnMenuSelect( const MENUITEM_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnMenuCommand

    SYNOPSIS:   Called upon a menu command from the user

    ENTRY:      mid - ID of menu item chosen

    RETURNS:    TRUE if menu command handled

    HISTORY:
        beng        08-Jul-1991     Header added

********************************************************************/

BOOL APP_WINDOW::OnMenuCommand( MID mid )
{
    UNREFERENCED(mid);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::MayRestore

    SYNOPSIS:   Called upon a request to de-iconize the app

    RETURNS:    FALSE to avoid expanding icon; TRUE otherwise

    NOTES:      Default implementation simply returns TRUE

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::MayRestore()
{
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::MayShutdown

    SYNOPSIS:   Called upon a request to terminate the app

    RETURNS:    FALSE to avoid shutdown; TRUE otherwise

    NOTES:      This default implementation simply returns TRUE,
                meaning that any request to shutdown succeeds.

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::MayShutdown()
{
    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnShutdown

    SYNOPSIS:   Called before a forced app shutdown

    CAVEATS:    This member should implement a complete
                synchronous cleanup of the application.  Windows
                can terminate at any time after this member returns.

    NOTES:      Should this default implementation force app seppuku
                with a "delete this" or some such?

    HISTORY:
        beng        08-Jul-1991     Return type changed to "void"

********************************************************************/

VOID APP_WINDOW::OnShutdown()
{
    return; // does nothing... yet
}


// CODEWORK: document following two members

BOOL APP_WINDOW::OnSystemChange( const SYSCHANGE_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


// Achtung!  INTENTIONAL non-const "event" reference!

BOOL APP_WINDOW::OnQMinMax( QMINMAX_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnCloseReq

    SYNOPSIS:   Called upon a request to close the application window

    RETURNS:    TRUE

    NOTES:      This default implementation terminates the application.

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::OnCloseReq()
{
    ::PostQuitMessage(0);

    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::OnPaintReq

    SYNOPSIS:   Paint-my-window stub

    ENTRY:      A WM_PAINT finally made its way through the queue

    EXIT:       "Invalid" region has been validated

    RETURNS:    TRUE, always

    NOTES:
        This default implementation does nothing of interest

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL APP_WINDOW::OnPaintReq()
{
    HWND hwnd = QueryHwnd();
    PAINTSTRUCT ps;

    ::BeginPaint(hwnd, &ps);
    ::EndPaint(hwnd, &ps);

    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW::DrawIcon

    SYNOPSIS:   Draw the current icon for the application

    ENTRY:      The window has received a paint request while iconic.

    EXIT:

    RETURNS:    TRUE if it could draw something for an app icon;
                FALSE if system defaults needed

    NOTES:      This is a private class member.

    HISTORY:
        beng        08-Jul-1991 Created
        beng        30-Mar-1992 Correct background paint

********************************************************************/

BOOL APP_WINDOW::DrawIcon()
{
    ASSERT( IsMinimized() );

    if (_hicon == 0)
        return FALSE;

    PAINT_DISPLAY_CONTEXT dc(this);

    ::DefWindowProc(QueryHwnd(), WM_ICONERASEBKGND,
                    (WPARAM)dc.QueryHdc(), (LPARAM)0L);
    dc.SetMapMode(MM_TEXT);
    dc.SetBkColor( ::GetSysColor(COLOR_BACKGROUND) );
    ::DrawIcon(dc.QueryHdc(), 0, 0, _hicon);

    return TRUE;
}


/*******************************************************************

    NAME:       APP_WINDOW :: GetPlacement

    SYNOPSIS:   Returns the "placement" for the window.  This includes
                the minimized position, the maximized position, and
                a number of other interesting goodies.

    ENTRY:      pwp                     - Points to a WINDOWPLACEMENT
                                          structure to receive the info.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     07-Aug-1992     Created.

********************************************************************/
APIERR APP_WINDOW :: GetPlacement( WINDOWPLACEMENT * pwp ) const
{
    APIERR err = ::GetWindowPlacement( QueryHwnd(), pwp )
                     ? NERR_Success
                     : (APIERR)::GetLastError();

    return err;

}   // APP_WINDOW :: GetPlacement


/*******************************************************************

    NAME:       APP_WINDOW :: SetPlacement

    SYNOPSIS:   Sets the "placement" for the window.  This includes
                the minimized position, the maximized position, and
                a number of other interesting goodies.

    ENTRY:      pwp                     - Points to a WINDOWPLACEMENT
                                          structure containing the info.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     07-Aug-1992     Created.

********************************************************************/
APIERR APP_WINDOW :: SetPlacement( const WINDOWPLACEMENT * pwp ) const
{
    APIERR err = ::SetWindowPlacement( QueryHwnd(), pwp )
                     ? NERR_Success
                     : (APIERR)::GetLastError();

    return err;

}   // APP_WINDOW :: SetPlacement


/*******************************************************************

    NAME:       APP_WINDOW :: DrawMenuBar

    SYNOPSIS:   Redraws the menu bar.  This method *must* be called
                to reflect any changes made to the window's menu.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     13-Oct-1992     Created.

********************************************************************/
APIERR APP_WINDOW :: DrawMenuBar( VOID ) const
{
    APIERR err = ::DrawMenuBar( QueryHwnd() )
                     ? NERR_Success
                     : (APIERR)::GetLastError();

    return err;

}   // APP_WINDOW :: DrawMenuBar


/*******************************************************************

    NAME:       APP_WINDOW::Close

    SYNOPSIS:   Closes the application window

    EXIT:       The window is closed

    HISTORY:
        rustanl     05-Sep-1991     Created

********************************************************************/

VOID APP_WINDOW::Close()
{
    Command( WM_CLOSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltbitmp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbitmp.cxx
    BLT bitmap and display map class definitions

    LM 3.0 Work Item: The DISPLAY_MAP object needs several additional
    parameters in the Paint method.  It needs the origin of the display
    map and the clipping rectangle.


    FILE HISTORY:
        rustanl     03-Dec-1990     Created
        beng        11-Feb-1991     Uses lmui.hxx
        Johnl       01-Mar-1991     Added Display Map object
        Johnl       13-Mar-1991     Cleaned up BIT_MAP object
        Johnl       18-Mar-1991     Made code review changes
        gregj       01-May-1991     Added DISPLAY_MAP::QueryID for GUILTT
        beng        14-May-1991     Exploded blt.hxx into components
        rustanl     19-Jul-1991     Added more error checks
        terryk      19-Jul-1991     Delete BIT_MAP( ULONG ) constructor and
                                    add BIT_MAP::SetBitmap() function
        KeithMo     07-Aug-1992     STRICTified.

*/
#include "pchblt.hxx"


// NOTE - winbase.h defines UnlockResource such that
// I can't call it like a C++ global fcn.

#if defined(WIN32) && defined(UnlockResource)
#undef UnlockResource
inline BOOL UnlockResource( HANDLE hResData )
{
    UNREFERENCED(hResData);
    return FALSE;
}
#endif


/*******************************************************************

    NAME:       BIT_MAP::BIT_MAP

    SYNOPSIS:   Bitmap object contructors

        Form 0:  Accepts BMID and tries to load it from the
        resource file; will assert out under DEBUG if load fails.

        Form 1:  Accepts name of bitmap resource and tries to
        load from resource file; will assert out under DEBUG if
        load fails.

        (Forms 0 and 1 are now unified under IDRESOURCE.)

        Form 3:  Accepts handle to a valid, loaded bitmap.  Note,
        the destructor will delete this object.

    HISTORY:
        Rustanl     03-Dec-1990 Created
        Johnl       13-Mar-1991 Commented, cleaned up
        terryk      21-Jun-1991 Add 2 more constructors for bitmap class
        rustanl     18-Jul-1991 Added BASE error checks
        beng        01-Nov-1991 Use MapLastError
        beng        03-Aug-1992 Use IDRESOURCE; dllization

********************************************************************/

BIT_MAP::BIT_MAP( const IDRESOURCE & id )
    : _h( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    HMODULE hmod = BLT::CalcHmodRsrc(id);

    HBITMAP hbmp = ::LoadBitmap(hmod, id.QueryPsz());
    if (hbmp == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    _h = hbmp;
}


BIT_MAP::BIT_MAP( HBITMAP hbitmap )
    : _h( hbitmap )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( hbitmap == NULL )
    {
        UIASSERT( FALSE );
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }
}


/*******************************************************************

    NAME:       BIT_MAP::~BIT_MAP

    SYNOPSIS:   BIT_MAP destructor, if we have a valid (i.e., non-null)
                bitmap handle, we call DeleteObject on it, otherwise
                ignore it.

    HISTORY:
        Rustanl 03-Dec-1990     Created
        Johnl   13-Mar-1991     Commented, cleaned up

********************************************************************/

BIT_MAP::~BIT_MAP()
{
    if ( _h != NULL )
        ::DeleteObject( (HGDIOBJ)_h );
}


/*******************************************************************

    NAME:     BIT_MAP::QueryHandle

    SYNOPSIS: Retrieves bitmap handle

    HISTORY:
        Rustanl 03-Dec-1990     Created
        Johnl   13-Mar-1991     Commented, cleaned up

********************************************************************/

HBITMAP BIT_MAP::QueryHandle() const
{
    UIASSERT( QueryError() == NERR_Success );
    return _h;
}


/*******************************************************************

    NAME:       BIT_MAP::SetBitmap

    SYNOPSIS:   set the internal bitmap variable to the given parameter

    ENTRY:      HBITMAP hbitmap - the new bitmap handle

    HISTORY:
                terryk  19-Jul-91   Created

********************************************************************/

VOID BIT_MAP::SetBitmap( HBITMAP hbitmap )
{
    _h = hbitmap;
}


/*******************************************************************

    NAME:       BIT_MAP::QueryHeight

    SYNOPSIS:   Gets the width and height in pixels of the bitmap.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Rustanl     03-Dec-1990 Created
        Johnl       13-Mar-1991 Added real code (for real people)
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT BIT_MAP::QueryHeight() const
{
    UIASSERT( QueryError() == NERR_Success );

    BITMAP bitmap;
    // Note funky third arg to GetObject
    if ( ! ::GetObject( QueryHandle(), sizeof( bitmap ), (TCHAR*) &bitmap ) )
    {
        UIASSERT(FALSE);
        return 0;
    }

    return bitmap.bmHeight;
}


/*******************************************************************

    NAME:       BIT_MAP::QueryWidth

    SYNOPSIS:   Gets the width and height in pixels of the bitmap.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Rustanl     03-Dec-1990 Created
        Johnl       13-Mar-1991 Added real code (for real people)
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT BIT_MAP::QueryWidth() const
{
    UIASSERT( QueryError() == NERR_Success );

    BITMAP bitmap;
    if ( ! ::GetObject( QueryHandle(), sizeof( bitmap ), (TCHAR*) &bitmap ) )
    {
        UIASSERT(FALSE);
        return 0;
    }

    return bitmap.bmWidth;
}


/*******************************************************************

    NONAME:     DISPLAY_MAP::CalcBitmapSize

    SYNOPSIS:   Calculates the size of the bitmap, in bytes

    ENTRY:      pbihdr - pointer to the bitmap header info
                (just fetched from the locked resource)

    RETURNS:    Count of bytes

    NOTES:
        CODEWORK - make this a member function (private)

    HISTORY:
        beng        22-Oct-1991 Created

********************************************************************/

static UINT CalcBitmapSize( const BITMAPINFOHEADER * pbihdr )
{
    UIASSERT( pbihdr->biSizeImage < 65534L ); // Catch any overflows

    // 0 denotes "normal size."  Will not be zero if compressed, etc.

    if (pbihdr->biSizeImage != 0L)
        return (UINT) (pbihdr->biSizeImage);

    UINT cbSize = pbihdr->biWidth * pbihdr->biBitCount;
    cbSize += 31;   // DIB scanlines must be DWORD aligned
    cbSize &= ~31;
    cbSize /= 8;    // convert bits to bytes
    cbSize *= pbihdr->biHeight;

    return cbSize;
}


/*******************************************************************

    NAME:       DISPLAY_MAP::DISPLAY_MAP

    SYNOPSIS:   Constructor for the display map object

    ENTRY:      bmid - Display map ID (actually a bitmap ID)

    EXIT:       Constructed, or else ReportError

    NOTES:

    HISTORY:
        Johnl       1-Mar-1991  Created
        rustanl     18-Jul-1991 Added more BASE error checking
        beng        04-Oct-1991 Win32 conversion
        beng        22-Oct-1991 Fix buffer-size, rsrc-handling bugs
        beng        07-Nov-1991 Error mapping
        beng        15-Jun-1992 Fix for bitmaps which aren't even DWORDs
        beng        03-Aug-1992 dllization

********************************************************************/

DISPLAY_MAP::DISPLAY_MAP( BMID bmid )
    : _bmid( bmid ),          // cache the ID for GUILTT
      _pbmMask( NULL ),
      _pbmBitmap( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    HMODULE hmod = BLT::CalcHmodRsrc(bmid);

    // Load the resource directly so we can access its bitmap information.

    HRSRC h = ::FindResource( hmod, MAKEINTRESOURCE( bmid ), RT_BITMAP );
    if (h == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    UINT cbBitmapSize = ::SizeofResource( hmod, h );

    HGLOBAL hRes = ::LoadResource( hmod, h );
    if (hRes == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    // Lock the bitmap data and make a copy of it for the mask and the bitmap.
    //
    LPBITMAPINFOHEADER lpBitmapData =
        (LPBITMAPINFOHEADER) ::LockResource( hRes );

    BUFFER buffBitmap( cbBitmapSize );
    BUFFER buffMask( cbBitmapSize );
    APIERR err;
    if ( (err = buffBitmap.QueryError()) != NERR_Success ||
         (err = buffMask.QueryError()  ) != NERR_Success )
    {
#if !defined(WIN32)
        ::UnlockResource( hRes );
        ::FreeResource( hRes );
#endif
        ReportError( err );
        return;
    }

    LPBITMAPINFOHEADER lpBitmapInfo =
        (LPBITMAPINFOHEADER) buffBitmap.QueryPtr();
    LPBITMAPINFOHEADER lpMaskInfo =
        (LPBITMAPINFOHEADER) buffMask.QueryPtr();
    //  Since both buffers above succeeded, these pointers should be
    //  non-NULL
    UIASSERT( lpBitmapInfo != NULL );
    UIASSERT( lpMaskInfo != NULL );

    ::memcpy( lpBitmapInfo, lpBitmapData, cbBitmapSize );
    ::memcpy( lpMaskInfo,   lpBitmapData, cbBitmapSize );
#if !defined(WIN32)
    ::UnlockResource( hRes );
    ::FreeResource( hRes );
#endif

    /* Get a pointer into the color table of the bitmaps, cache the number of
     * bits per pixel
     */
    DWORD *pdwRGBMask   = (DWORD *)( ((BYTE*)lpMaskInfo)   + lpMaskInfo->biSize   );
    DWORD *pdwRGBBitmap = (DWORD *)( ((BYTE*)lpBitmapInfo) + lpBitmapInfo->biSize );

    const INT nBitsPerPixel = lpMaskInfo->biBitCount;

    // Now we get pointers to the bits of the bitmap itself, get the transparent
    // color index and set the bits in the mask and the bitmap appropriately.
    //
    BYTE * pbMaskBits   = (BYTE *)(pdwRGBMask) +
                          ( 1 << ( nBitsPerPixel )) * sizeof( RGBQUAD );
    BYTE * pbBitmapBits = (BYTE *)(pdwRGBBitmap) +
                          ( 1 << ( nBitsPerPixel )) * sizeof( RGBQUAD );

    INT iTransColorIndex = GetTransColorIndex( pdwRGBMask,
                                               1 << nBitsPerPixel );
    const UINT cbBits = CalcBitmapSize(lpBitmapInfo);

    SetMaskBits( pbMaskBits, iTransColorIndex, nBitsPerPixel, cbBits);
    SetBitmapBits( pbBitmapBits, iTransColorIndex, nBitsPerPixel, cbBits);

    /* Create the bitmask bitmap based on the characteristics of the
     * display and store it in a newly created BIT_MAP object that
     * we keep around as a member.
     */
    SCREEN_DC dcScreen;
    if ( dcScreen.QueryHdc() == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }

    HBITMAP hMask   = ::CreateDIBitmap(dcScreen.QueryHdc(),
                                       lpMaskInfo,
                                       (DWORD)CBM_INIT,
                                       (BYTE*)pbMaskBits,
                                       (LPBITMAPINFO)lpMaskInfo,
                                       DIB_RGB_COLORS);
    if ( hMask == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }

    HBITMAP hBitmap = ::CreateDIBitmap(dcScreen.QueryHdc(),
                                       lpBitmapInfo,
                                       (DWORD)CBM_INIT,
                                       (BYTE*)pbBitmapBits,
                                       (LPBITMAPINFO)lpBitmapInfo,
                                       DIB_RGB_COLORS);
    if ( hBitmap == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        ::DeleteObject( (HGDIOBJ)hMask );
        return;
    }

    err = ERROR_NOT_ENOUGH_MEMORY;
    _pbmMask = new BIT_MAP( hMask );
    _pbmBitmap = new BIT_MAP( hBitmap );

    if (   _pbmMask == NULL
        || _pbmBitmap == NULL
        || ((err = _pbmMask->QueryError()) != NERR_Success)
        || ((err = _pbmBitmap->QueryError()) != NERR_Success) )
    {
        ReportError( err );

        // Do only whatever cleanup wouldn't be done by dtor

        if (_pbmMask == NULL)
            ::DeleteObject((HGDIOBJ)hMask);
        if (_pbmBitmap == NULL)
            ::DeleteObject((HGDIOBJ)hBitmap);

        return;
    }
}


/*******************************************************************

    NAME:     DISPLAY_MAP::~DISPLAY_MAP

    SYNOPSIS: Display map destructor - deletes allocated display maps

    HISTORY:
        Johnl   1-Mar-1991      Created

********************************************************************/

DISPLAY_MAP::~DISPLAY_MAP()
{
    delete _pbmMask;
    delete _pbmBitmap;
    _pbmBitmap = _pbmMask = NULL;
}


/*******************************************************************

    NAME:     DISPLAY_MAP::QueryMaskHandle

    SYNOPSIS: Retrieves the handles to the twiddled mask bitmap and
              twiddled bitmap bitmap

    ENTRY:

    EXIT:

    NOTES:    Will assert out if the DISPLAY_MAP object failed to be
              constructed.

    HISTORY:
        Johnl   1-Mar-1991      Created

********************************************************************/

HBITMAP DISPLAY_MAP::QueryMaskHandle() const
{
    UIASSERT( !QueryError() );
    return _pbmMask->QueryHandle();
}


/*******************************************************************

    NAME:       DISPLAY_MAP::QueryBitmapHandle

    SYNOPSIS:   Retrieves the handles to the twiddled mask bitmap and
                twiddled bitmap bitmap

    NOTES:
        Will assert out if the DISPLAY_MAP object failed to be constructed.

    HISTORY:
        Johnl   1-Mar-1991      Created

********************************************************************/

HBITMAP DISPLAY_MAP::QueryBitmapHandle() const
{
    UIASSERT( !QueryError() );
    return _pbmBitmap->QueryHandle();
}


/*******************************************************************

    NAME:       DISPLAY_MAP::QueryHeight

    SYNOPSIS:   Gets the width and height in pixels of the display map

    NOTES:      It is assumed the bitmap and mask are the same dimensions

    HISTORY:
        Johnl       01-Mar-1991 Created
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT DISPLAY_MAP::QueryHeight() const
{
    UIASSERT( !QueryError() );
    return _pbmBitmap->QueryHeight();
}


/*******************************************************************

    NAME:     DISPLAY_MAP::QueryWidth

    SYNOPSIS: Gets the width and height in pixels of the display map

    ENTRY:

    EXIT:

    NOTES:    It is assumed the bitmap and mask are the same dimensions

    HISTORY:
        Johnl       01-Mar-1991 Created
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT DISPLAY_MAP::QueryWidth() const
{
    UIASSERT( !QueryError() );
    return _pbmBitmap->QueryWidth();
}


/*******************************************************************

    NAME:     DISPLAY_MAP::SetMaskBits

    SYNOPSIS: Given a pointer to the bitmap bits, this method creates the
              actual mask by setting all transparent bits to black and all
              non-transparent bits to white.  The mask is meant to
              be used with bitblt functions.

    ENTRY:    pbBits points to the first byte of the bitmap data
              nTransColor is the index of the bit pattern to replace with black
              cbSize is the count of bytes in this bitmap
              nBitsPerPixel is the number of bits that make up each pixel

    EXIT:     The mask bitmap will have all transparent bits set to black and
              all non-transparent bits set to white.

    NOTES:
        We only accept 4 and 8 bit per pixel bitmaps

    HISTORY:
        Johnl       4-Mar-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        23-Oct-1991 Add monochrome sauve-qui-peut

********************************************************************/

VOID DISPLAY_MAP::SetMaskBits( BYTE * pbBits,
                               INT    nTransColorIndex,
                               INT    nBitsPerPixel,
                               UINT   cbSize )
{
    /* We only handle 4 bits per pixel or 8 bits per pixel */
    UIASSERT( nBitsPerPixel == 4 || nBitsPerPixel == 8 );

    // Fall-through (retail build): should we somehow get a mono
    // bitmap, make its map completely empty.
    //
    if (nBitsPerPixel == 1)
    {
        while (cbSize--)
            *pbBits++ = 0xff;
        return;
    }

    BYTE *pbEnd = pbBits + cbSize;
    while ( pbBits < pbEnd )
    {
        if ( nBitsPerPixel == 8 )
            *pbBits = (BYTE) (((INT)*pbBits == nTransColorIndex) ? 0x00 : 0xff);
        else
        {
            /* Zap the upper nibble and/or the lower nibble if the nibble
             * is the transparent color index.
             */
            *pbBits = (BYTE) ((((INT)(*pbBits >> 4) == nTransColorIndex) ? 0x0f : 0xff)
                              &
                             (((INT)(*pbBits & 0x0f) == nTransColorIndex) ? 0xf0 : 0xff));
        }
        pbBits++;
    }
}


/*******************************************************************

    NAME:     DISPLAY_MAP::SetBitmapBits

    SYNOPSIS: Given a pointer to the bitmap bits, this method modifies
              the main bitmap.  It changes the transparent color to
              white and ignores the non-transparent colors.

    ENTRY:    pbBits points to the first byte of the bitmap data
              nTransColor is the index of the bit pattern to replace with black
              cbSize is the count of bytes in this bitmap
              nBitsPerPixel is the number of bits that make up each pixel

    EXIT:     The bitmap will have all transparent colors changed to white,
              everything else stays the same.

    NOTES:    We only accept 4 and 8 bit per pixel bitmaps

    HISTORY:
        Johnl       4-Mar-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        23-Oct-1991 Add monochrome sauve-qui-peut

********************************************************************/

VOID DISPLAY_MAP::SetBitmapBits( BYTE * pbBits,
                                 INT    nTransColorIndex,
                                 INT    nBitsPerPixel,
                                 UINT   cbSize )
{
    /* We only handle 4 bits per pixel or 8 bits per pixel */
    UIASSERT( nBitsPerPixel == 4 || nBitsPerPixel == 8 );

    // Fall-through (retail build): should we somehow get a mono
    // bitmap, leave it be.
    //
    if (nBitsPerPixel == 1)
        return;

    BYTE *pbEnd = pbBits + cbSize;
    while ( pbBits < pbEnd )
    {
        if ( nBitsPerPixel == 8 )
            *pbBits = (BYTE)(((INT)*pbBits == nTransColorIndex) ? 0xff : *pbBits);
        else
        {
            /* Set the upper and/or lower nibble if that nibble is the
             * transparent color index.  If it is not, we preserve the
             * nibble.
             */

            *pbBits = (BYTE) ((((INT)(*pbBits >> 4) == nTransColorIndex) ? 0xf0 : *pbBits & 0xf0)
                              |
                             (((INT)(*pbBits & 0x0f) == nTransColorIndex) ? 0x0f : *pbBits & 0x0f));
        }
        pbBits++;
    }
}


/*******************************************************************

    NAME:       DISPLAY_MAP::GetTransColorIndex

    SYNOPSIS:   Finds the index into the color table of the transparent color
                (i.e., the RGB value that == DISPLAY_MAP_TRANS_COLOR).

    ENTRY:      pdwRGB - Pointer to the bitmaps RGB color table
                nNumDWords - number of RGB quads in the color table

    EXIT:

    RETURNS:    Index of the transparent color in the RGB table, or 0
                if not found.

        The user should assume this routine will
        succeed.  Even if it doesn't, the bitmaps only look weird
        which means we weren't passed a correct "Green" bitmap.
        We assert out under DEBUG if the transparent color isn't found.

    NOTES:
        The transparent color must occur at least once in the bitmap
        It is assumed the color will not occur multiple times in the
        color index table.

    HISTORY:
        Johnl   4-Mar-1991      Created

********************************************************************/

INT DISPLAY_MAP::GetTransColorIndex( DWORD *pdwRGB, INT nNumDWords ) const
{
    INT iTransColorIndex = 0;
    while ( iTransColorIndex < nNumDWords  )
    {
        if ( pdwRGB[iTransColorIndex] == DISPLAY_MAP_TRANS_COLOR )
            break;
        iTransColorIndex++;
    }

    /* Make sure we found the color
     */
    if ( iTransColorIndex >= nNumDWords )
    {
        ASSERTSZ(FALSE, "DISPLAY_MAP::GetTransColorIndex: transparent color not found in bitmap");
        iTransColorIndex = 0;
    }

    return iTransColorIndex;
}


/*******************************************************************

    NAME:       DISPLAY_MAP::Paint

    SYNOPSIS:   Using the previously created mask, Paint draws the
                bitmap with a transparent background.

    ENTRY:  hdc - handle to destination DC into which to paint
            x   - origin of destination, x coord
            y   - origin of destination, y coord

    EXIT:

    RETURNS:    Return of Windows BitBlt (fSuccess)

    NOTES:
        Bitmaps are drawn by first ORing in a mask bitmap,
        which preserves everything that's supposed to be
        transparent (black in the mask) and turns everything
        that's going to be redrawn to white (white areas in
        the mask).  Then AND in the main bitmap to draw the
        image.  See SetMaskBits of this class.

    HISTORY:
        Johnl       4-Mar-1991  Scavenged from original code (rustanl/gregj)
        beng        04-Oct-1991 Win32 conversion
        beng        15-Jun-1992 Performance tweaks

********************************************************************/

BOOL DISPLAY_MAP::Paint( HDC hdc, INT x, INT y ) const
{
    DEVICE_CONTEXT dc( hdc );
    MEMORY_DC memdc( dc );

    if ( memdc.QueryHdc() == NULL )
        return FALSE;

    // These are worth caching, since each involves a GetObject call

    const UINT dx = QueryWidth();
    const UINT dy = QueryHeight();

    // No point in saving previous object - we'll discard this DC soon

    memdc.SelectBitmap( QueryMaskHandle() );

    BOOL fSuccess = dc.BitBlt( x, y, dx, dy,
                               memdc,
                               0, 0,
                               SRCPAINT );
    if ( fSuccess )
    {
        memdc.SelectBitmap( QueryBitmapHandle() );

        fSuccess = dc.BitBlt( x, y, dx, dy,
                              memdc,
                              0, 0,
                              SRCAND );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltbkgnd.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbkgnd.cxx
    BLT background edit with non-default color

    FILE HISTORY:
        jonn        29-Sep-95   split from blttd.cxx
*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       BLT_BACKGROUND_EDIT::BLT_BACKGROUND_EDIT

    SYNOPSIS:   constructor

    HISTORY:
        jonn        05-Sep-95   Created

*********************************************************************/

BLT_BACKGROUND_EDIT::BLT_BACKGROUND_EDIT( OWNER_WINDOW *powin, CID cid )
    : EDIT_CONTROL( powin, cid )
{
    if ( QueryError() )
        return;

    //
    // Update the frame edit control to have a CLIENTEDGE and a frame
    //
    HWND hwnd = QueryHwnd();
    ASSERT( hwnd != NULL );
    LONG lExStyle = ::GetWindowLong(hwnd, GWL_EXSTYLE);
    if ( lExStyle == 0 )
    {
        DBGEOL("BLT_BACKGROUND_EDIT: GetWindowLong error " << ::GetLastError() );
    }
    if ( !::SetWindowLong( hwnd,
                           GWL_EXSTYLE,
                           lExStyle | WS_EX_CLIENTEDGE ) )
    {
        DBGEOL("BLT_BACKGROUND_EDIT: SetWindowLong error " << ::GetLastError() );
        ASSERT( FALSE );
    }
    if ( !::SetWindowPos( hwnd,
                NULL, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_DRAWFRAME | SWP_SHOWWINDOW ) )
    {
        DBGEOL("BLT_BACKGROUND_EDIT: SetWindowPos error " << ::GetLastError() );
        ASSERT( FALSE );
    }
}


/*********************************************************************

    NAME:       BLT_BACKGROUND_EDIT::~BLT_BACKGROUND_EDIT

    SYNOPSIS:   destructor

    HISTORY:
        jonn        05-Sep-95   Created

*********************************************************************/

BLT_BACKGROUND_EDIT::~BLT_BACKGROUND_EDIT()
{
}


/*******************************************************************

    NAME:       BLT_BACKGROUND_EDIT::OnCtlColor

    SYNOPSIS:   Intercepts WM_CTLCOLOR*.  This can be used to
                set the background color of controls to other
                than the default, for example to change the default
                background color for a static text control to
                the same background as for an edit control.

    ENTRY:

    EXIT:

    RETURNS:    brush handle if you handle it

    HISTORY:
        JonN            09/05/95          Created

********************************************************************/
HBRUSH BLT_BACKGROUND_EDIT::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    ASSERT( pmsgid != NULL && hwnd == QueryHwnd() );
    *pmsgid = WM_CTLCOLOREDIT;
    return NULL;
#if 0
//
// Template code to manually force foreground and background colors.
// Normally it is sufficient to set *pmsgid to WM_CTLCOLOREDIT.
//
    REQUIRE( CLR_INVALID !=
              ::SetBkColor(   hdc, ::GetSysColor(COLOR_WINDOW) ) );
    REQUIRE( CLR_INVALID !=
              ::SetTextColor( hdc, ::GetSysColor(COLOR_WINDOWTEXT) ) );
    return ::GetSysColorBrush( COLOR_3DFACE );
//     NOTES:      ::GetSysColorBrush() returns a handle to the current
//                 default brush of this color.  It does not have to be
//                 freed.  This brush will remain in sync with the Colors
//                 CPL default colors if they change, so there is no need
//                 to intercept WM_SYSCOLORCHANGE.  This is new to WINVER4.
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltctrl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltctrl.cxx
    BLT control hierarchy definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        Johnl       23-Apr-1991 Moved RADIO_GROUP to bltgroup.cxx
        gregj       01-May-1991 Added GUILTT support
        beng        14-May-1991 Exploded blt.hxx into components
        beng        17-Sep-1991 Broke apart bltbutn, bltedit
        o-SimoP     02-Jan-1992 Added HIDDEN_CONTROL
        beng        18-May-1992 Added SCROLLBAR
*/
#include "pchblt.hxx"

const TCHAR * SCROLLBAR::_pszClassName = SZ("SCROLLBAR");


const TCHAR * CONTROL_WINDOW :: QueryEditClassName ()
{
    return SZ("edit") ;
}

const TCHAR * CONTROL_WINDOW :: QueryStaticClassName ()
{
    return SZ("static") ;
}

const TCHAR * CONTROL_WINDOW :: QueryListboxClassName ()
{
    return SZ("listbox") ;
}

const TCHAR * CONTROL_WINDOW :: QueryComboboxClassName ()
{
    return SZ("combobox") ;
}

/*********************************************************************

    NAME:       CONTROL_WINDOW::CONTROL_WINDOW

    SYNOPSIS:   Constructor for control window

    ENTRY:      Two forms.  One form appears in dialogs, and assumes
                that the control is defined in a resourcefile, having
                already been Created by Windows:

            powin        - pointer to dialog object owning the control
            cid          - ID of control

                while the other appears in standalone windows, and
                creates the control window itself:

            powin        - pointer to hosting window
            cid          - ID of control
            xy           - size of control
            dxy          - dimensions of control
            flStyle      - Windows-defined style bits for control window
            pszClassName - name of WindowClass for control.

    EXIT:       Success: window has been created and registered
                    with the owner window.
                Failure: owner window has its error flag set so that
                    future controls may elide construction

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        25-Apr-1991 Base-class constructor munged
        beng        17-May-1991 Added app-window constructor form
        beng        31-Jul-1991 Error reporting changed
        beng        07-Nov-1991 Error mapping

*********************************************************************/

CONTROL_WINDOW::CONTROL_WINDOW( OWNER_WINDOW * powin, CID cid )
    : WINDOW(),
      FORWARDING_BASE(powin),
      _cid( cid )
{
    // Did previous control in the window fail?
    //
    if (QueryError())
        return;

    // Did this control's window fail?
    //
    if ( WINDOW::QueryError() )
    {
        ReportError( WINDOW::QueryError() );
        return;
    }

    HWND hwnd = ::GetDlgItem( powin->QueryHwnd(), cid );
    if ( hwnd == NULL )
    {
        // In a properly built program, no control window object
        // should reference the wrong control ID.  Since the dialog
        // constructed successfully, GetDlgItem should be able to find
        // the given CID.
        //
        ASSERTSZ( FALSE, "Invalid control ID given" );

        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
    SetHwnd( hwnd );

    // Register the control with the owner window
    //
    if ( ! powin->AddControl( this ))
    {
        DBGEOL( "BLT: Insufficient memory to add control to owner window" );

        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
}


CONTROL_WINDOW::CONTROL_WINDOW( OWNER_WINDOW * powin, CID cid,
                                XYPOINT xy, XYDIMENSION dxy,
                                ULONG flStyle, const TCHAR * pszClassName )
    : WINDOW(pszClassName, flStyle, powin, cid),
      FORWARDING_BASE(powin),
      _cid( cid )
{
    if ( QueryError() )
        return;

    if ( WINDOW::QueryError() )
    {
        ReportError( WINDOW::QueryError() );
        return;
    }

    // Sanity check: make sure that we're registered in the
    // parent window.  We need to be a child.

    UIASSERT(QueryHwnd() == ::GetDlgItem( powin->QueryHwnd(), cid ));

    // Position this control as requested.  (All windows are created
    // originally with the system default size and position.)

    SetPos(xy);
    SetSize(dxy);

    // Register the control with the owner window table.
    //
    if ( ! powin->AddControl( this ))
    {
        DBGEOL("BLT: Insufficient memory to add control to owner window");

        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
}


/**********************************************************************

    NAME:       CONTROL_WINDOW::OnUserAction

    SYNOPSIS:   Called when the user has manipulated the control
                in some way.

    ENTRY:      lParam      The parameters to the WM_CONTROL message that
                            the control sent its owner window.  The contents
                            of this value is specific to different types of
                            controls.

    RETURN:     0 if some action was taken.

    EXIT:

    NOTES:
                Even if an action is taken, the owner will still get a
                notification about the this event.

                NOTE:  Currently, this method is only called from the
                DIALOG_WINDOW, but it could potentially also be called
                from some other branch of the OWNER_WINDOW hierarchy.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR CONTROL_WINDOW::OnUserAction( const CONTROL_EVENT & e )
{
    UNREFERENCED(e);        // quiet compiler
    return NERR_Success;    // success in handling user action
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::OnCtlColor

    SYNOPSIS:   Dialogs pass WM_CTLCOLOR* here

    RETURNS:    brush handle if you handle it, may also change *pmsgid

    NOTES:      see blt\bltcc\bltsslt.cxx for an example of how to
                work with this

                If this method or its virtual redefinition is not being
                called, check whether a redefinition of
                DIALOG_WINDOW::OnCtlColor is failing to call through to
                that root method.

    HISTORY:
        jonn        31-Aug-1995 Created

********************************************************************/
HBRUSH CONTROL_WINDOW::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    UNREFERENCED( hdc );
    UNREFERENCED( hwnd );
    UNREFERENCED( pmsgid );
    return NULL;
}


/**********************************************************************

    NAME:       CONTROL_WINDOW::SetTabStop

    SYNOPSIS:   Set the tab stop on the control window

    ENTRY:      fTabStop    TRUE if we want to set the tab stop and FALSE
                            if we want to remove the tab stop.

    RETURN:

    EXIT:

    NOTES:

    HISTORY:
        Yi-HsinS     29-May-1992 Created

**********************************************************************/

VOID CONTROL_WINDOW::SetTabStop( BOOL fTabStop )
{
    if ( fTabStop )
    {
        SetStyle( QueryStyle() | WS_TABSTOP );
    }
    else
    {
        SetStyle( QueryStyle() & ~((ULONG) WS_TABSTOP) );
    }
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Draw

    SYNOPSIS:   Draws (an item in) a custom drawn control.

    ENTRY:      pdis    A pointer to a DRAWITEMSTRUCT (described in the
                        Windows SDK.

    RETURN:
                TRUE if the item was drawn
                FALSE otherwise

    NOTES:
        This method may be replaced by the client for any custom drawn
        control.

        This method is never called for controls that don't have the
        owner-drawn style bit.

    HISTORY:
        rustanl         20-Nov-1990 Created
        gregj           01-May-1991 Added GUILTT support
        beng            01-Jun-1992 Changed GUILTT support

*********************************************************************/

BOOL CONTROL_WINDOW::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    UNREFERENCED(pdis);
    return FALSE;   // no action taken
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Measure

    SYNOPSIS:   Called to measure a VARIABLE size item
                in a custom drawn control.

    ENTRY:      pdms    A pointer to a MEASUREITEMSTRUCT (described in the
                        Windows SDK.

    RETURN:     TRUE if a response was taken
                FALSE otherwise

    NOTES:
        This method may be replaced by the client for any custom draw
        control.

        This method is never called for controls that don't have the
        owner-draw and variable-size data style bits.

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

BOOL CONTROL_WINDOW::CD_Measure( MEASUREITEMSTRUCT * pmis )
{
    UNREFERENCED(pmis);   // quiet compiler
    return FALSE;         // no action taken
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Char

    SYNOPSIS:   Called to determine the effect of a keystroke
                in a custom-drawn listbox.

    ENTRY:
        wch         The Ansi value of the character typed.
        nLastPos    Index of the current caret position.

    RETURN:
        -2 ==> the control did all processing of the character.
        -1 ==> the default effect of the character is appropriate.
        0 or greater ==> the index of an item to act upon.

    NOTES:
        This method may be replaced by the client for any custom draw
        list control.

        This method is never called for controls other than custom
        drawn listboxes.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        15-Oct-1991 Win32 conversion

*********************************************************************/

INT CONTROL_WINDOW::CD_Char( WCHAR wch, USHORT nLastPos )
{
    UNREFERENCED(wch);      // quiet compiler
    UNREFERENCED(nLastPos);
    return -1;                // take default action
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_VKey

    SYNOPSIS:   Called when a listbox with the LBS_WANTKEYBOARDINPUT style
                receives a WM_KEYDOWN message.

    ENTRY:
        nVKey       The virtual-key code of the key which the user pressed.
        nLastPos    Index of the current caret position.

    RETURN:
        -2 ==> the control did all processing of the key press.
        -1 ==> the listbox should perform the default action
               in response to the keystroke.
        at least 0 ==> the index of an item to act upon.

    NOTES:
        This method may be replaced by the client for any custom draw
        list control with the LBS_WANTKEYBOARDINPUT style.

        This method is never called for controls other than custom
        drawn listboxes with the LBS_WANTKEYBOARDINPUT style.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        15-Oct-1991 Win32 conversion

*********************************************************************/

INT CONTROL_WINDOW::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    UNREFERENCED(nVKey);      // quiet compiler
    UNREFERENCED(nLastPos);
    return -1;                // take default action
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::CD_Guiltt

    SYNOPSIS:   Fetches data for GUILTT from a control

    ENTRY:
        ilb     - index into the listbox (or some other subsel)
        pnlsOut - string to hold the output data

    EXIT
        pnlsOut - no doubt has been scribbled into

    RETURN:     An error code - NERR_Success if successful.

    NOTES:
        The default implementation always returns "not supported,"
        since only owner-draw listboxes at present support GUILTT.

    HISTORY:
        beng            01-Jun-1992 Created

*********************************************************************/

APIERR CONTROL_WINDOW::CD_Guiltt( INT ilb, NLS_STR * pnlsOut )
{
    UNREFERENCED(ilb);
    UNREFERENCED(pnlsOut);
    return ERROR_NOT_SUPPORTED;
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::QueryCid

    SYNOPSIS:   Returns the control ID.

    RETURN:     the control ID of the control

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

CID CONTROL_WINDOW::QueryCid() const
{
    return _cid;
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::ClaimFocus

    SYNOPSIS:   Sets the input focus to the control window.

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

VOID CONTROL_WINDOW::ClaimFocus()
{
    SetFocus(QueryHwnd());
}


/*********************************************************************

    NAME:       CONTROL_WINDOW::QueryFont

    SYNOPSIS:   Retrieves the handle of the font with which the control is
                currently drawing its text.

    RETURNS:    Handle of said font, or NULL if system font.

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        21-Aug-1991     Return type HFONT

*********************************************************************/

HFONT CONTROL_WINDOW::QueryFont() const
{
    return (HFONT)Command( WM_GETFONT );
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::SetFont

    SYNOPSIS:   Sets the current font with which the control draws text

    ENTRY:      hfont   - handle to font (queried from elsewhere)
                          (optionally - a created logical font)

                fRedraw - TRUE to redraw font

    EXIT:       Font is set.

    HISTORY:
        beng        21-Aug-1991 Created
        beng        17-Oct-1991 Win32 conversion

********************************************************************/

VOID CONTROL_WINDOW::SetFont( HFONT hfont, BOOL fRedraw )
{
    Command(WM_SETFONT, (WPARAM)hfont, (LPARAM)fRedraw);
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::SetControlValueFocus

    SYNOPSIS:   Sets the focus to this control window
                (see CONTROL_VALUE for more details).

    EXIT:       The focus should be set to this control window.

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created

********************************************************************/

VOID CONTROL_WINDOW::SetControlValueFocus()
{
    ClaimFocus();
}


/*******************************************************************

    NAME:     CONTROL_WINDOW::NotifyGroups

    SYNOPSIS: Notifies all parent groups of this control that this control
              received the specified message.

    ENTRY:    lParam is the message received by the control

    EXIT:     All groups will have been notified (if appropriate).

    RETURNS:  An APIERR, or else GROUP_NO_CHANGE

    NOTES:

    HISTORY:
        Johnl       02-May-1991 Created
        beng        08-Oct-1991 Win32 conversion

********************************************************************/

APIERR CONTROL_WINDOW::NotifyGroups( const CONTROL_EVENT & e )
{
    APIERR apierr = NERR_Success;

    /* If the control belongs to a group, tell the
     * group a user tampered with one of its controls
     */
    CONTROL_GROUP * pg = QueryGroup() ;
    if ( pg != NULL )
    {
        /* A group can indicate that nothing has changed
         * (by returning GROUP_NO_CHANGE), this will
         * prevent the parent groups from being notified.
         */

        // C7 CODEWORK - remove redundant Glock-pacifier cast
        apierr = pg->OnUserAction( this, (const CONTROL_EVENT &)e );

        /* Now tell all of the parent groups of this group
         * that the group has been tampered with.
         */
        CONTROL_GROUP * pgNext ;
        while ( (apierr == NERR_Success) &&
                (pgNext = pg->QueryGroup()) != NULL )
        {
            apierr = pgNext->OnGroupAction( pg );
            pg = pgNext;
        }

        if ( apierr == NERR_Success || apierr == GROUP_NO_CHANGE )
            QueryGroup()->AfterGroupActions();
    }

    return apierr;
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::Validate

    SYNOPSIS:   Validates the contents of the control

    ENTRY:      Validity unknown

    EXIT:       Validity known

    RETURNS:    Error code (NERR_Success if input ok)

    NOTES:
        This is a virtual member function.  Controls which validate
        their contents (those which have contents to validate, that
        is) should redefine it.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

APIERR CONTROL_WINDOW::Validate()
{
    // Stub implementation always returns "success," so controls
    // which don't validate their input are ignored

    return NERR_Success;
}


/*******************************************************************

    NAME:       CONTROL_WINDOW::IndicateError

    SYNOPSIS:   Indicate invalid data within the control

    ENTRY:      Control has already checked the validity of its data,
                and found it wanting; dialog now is asking control
                to indicate the error

    EXIT:       Control has indicated the error

    NOTES:
        This is a virtual member function.

        This default implementation sets focus to the control
        and raises a popup.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

VOID CONTROL_WINDOW::IndicateError( APIERR err )
{
    MsgPopup(QueryHwnd(), (MSGID)err);
    ClaimFocus();
}


/*******************************************************************

    NAME:     ICON_CONTROL::ICON_CONTROL

    SYNOPSIS: Static icon control class

    ENTRY:    powin - Owner window of this control
            cidIcon - Control ID of the icon
            lpIconName - Name of the icon in the resource file
            or LOWORD( lpIconName ) is one of the predefined windows icons.
            or NULL means don't do anything.

    EXIT:

    NOTES:
        CODEWORK: Add constructor that takes a HICON parm, or
        perhaps some ICON object

    HISTORY:
        Johnl       8-Feb-1991      Created
        beng        17-May-1991     Added app-window constructor
        keithmo     24-Mar-1992     Uses IDRESOURCE
        beng        01-Apr-1992     Const args fixup

********************************************************************/

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon )
    : CONTROL_WINDOW( powin, cidIcon )
{
    if (QueryError())
        return;
}

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon,
    const IDRESOURCE & idresIcon )
    : CONTROL_WINDOW( powin, cidIcon )
{
    if (QueryError())
        return;

    APIERR err = SetIcon( idresIcon );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *  pszClassName )
    : CONTROL_WINDOW( powin, cidIcon, xy, dxy, flStyle, pszClassName )
{
    if (QueryError())
        return;
}

ICON_CONTROL::ICON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidIcon,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    const IDRESOURCE & idresIcon,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : CONTROL_WINDOW( powin, cidIcon, xy, dxy, flStyle, pszClassName )
{
    if (QueryError())
        return;

    APIERR err = SetIcon( idresIcon );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:     ICON_CONTROL::W_SetIcon

    SYNOPSIS: Change the icon this control contains

    ENTRY:    idresIcon - Either points to the name of the icon resource
                          OR contains the ordinal of the icon resource.

              fIsPredefined - If TRUE then idresIcon must be one of the
                              predefined Windows icons (IDI_*).  Otherwise,
                              idresIcon is an application icon.

    EXIT:

    NOTES:
        You can always change an icon using an undocumented (though
        publicly supported) trick.  You set the text of the control
        and rather then passing a pointer to a string of text, the
        pointer contains the handle to the icon.

        The psz-can-either-be-a-char*-or-a-MAKEINTRESOURCE(lpstr) hack
        of the Win API is pretty disgusting.  CODEWORK: overload this
        function to do it either one way or the other.

    HISTORY:
        Johnl       8-Feb-1991  (created)
        beng        17-May-1991 Changed arg to const TCHAR *
        KeithMo     22-Sep-1991 Changed to Win 3.1 message
        beng        07-Oct-1991 Win32 conversion
        KeithMo     24-Mar-1992 Changed to W_SetIcon, uses IDRESOURCE.
        beng        01-Apr-1992 const args fixup
        beng        03-Aug-1992 Dllization

********************************************************************/

APIERR ICON_CONTROL::W_SetIcon( const IDRESOURCE & idresIcon,
                                BOOL fIsPredefined )
{
    HICON hNewIcon = ::LoadIcon( fIsPredefined
                                  ? NULL
                                  : BLT::CalcHmodRsrc(idresIcon),
                                 idresIcon.QueryPsz() );
    if ( hNewIcon == NULL )
    {
        return BLT::MapLastError(ERROR_INVALID_PARAMETER);
    }

    return (APIERR)Command( STM_SETICON, (WPARAM)hNewIcon, 0L );
}


/*******************************************************************

    NAME:       HIDDEN_CONTROL::HIDDEN_CONTROL

    SYNOPSIS:   constructor

    EXIT:       control is invisible and inaccessible

    HISTORY:
        o-SimoP     02-Jan-1992 Created

********************************************************************/

HIDDEN_CONTROL::HIDDEN_CONTROL( OWNER_WINDOW * powin, CID cid )
        : CONTROL_WINDOW( powin, cid )
{
    if ( QueryError() != NERR_Success )
        return;
    Enable( FALSE );
    Show( FALSE );
}


/*******************************************************************

    NAME:       SCROLLBAR::SCROLLBAR

    SYNOPSIS:   Ctor

    NOTE:
        Another form of this ctor lies inline.  This form lies
        outline because it references a static member.

    HISTORY:
        beng        29-Jun-1992 Outlined (dllization delta)

********************************************************************/

SCROLLBAR::SCROLLBAR( OWNER_WINDOW * pwnd, CID cid,
                      XYPOINT xy, XYDIMENSION dxy, ULONG flStyle )
    : CONTROL_WINDOW( pwnd, cid, xy, dxy, flStyle, _pszClassName )
{
    // Nothing further to do
}


/*******************************************************************

    NAME:       SCROLLBAR::SetPos

    SYNOPSIS:   Set the position of a scrollbar

    ENTRY:      nPosition - desired position

    NOTE:
        This function does NOT redraw the control.  Use RepaintNow
        to force a redraw.

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

VOID SCROLLBAR::SetPos( UINT nPosition )
{
    ::SetScrollPos(QueryHwnd(), SB_CTL, nPosition, FALSE);
}


/*******************************************************************

    NAME:       SCROLLBAR::SetRange

    SYNOPSIS:   Sets the range within which a sbar reports position

    ENTRY:      nMin - minimum position
                nMax - maximum (inclusive)

    NOTE:
        This function does NOT redraw the control.  Use RepaintNow
        to force a redraw.

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

VOID SCROLLBAR::SetRange( UINT nMin, UINT nMax )
{
    BOOL fOk = ::SetScrollRange(QueryHwnd(), SB_CTL, nMin, nMax, FALSE);

#if defined(DEBUG)
    if (!fOk)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGEOL("BLT: SetScrollRange failed, err = "
                << BLT::MapLastError(ERROR_GEN_FAILURE));
    }
#endif
}


/*******************************************************************

    NAME:       SCROLLBAR::QueryPos

    SYNOPSIS:   Returns the current position within a scrollbar

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

UINT SCROLLBAR::QueryPos() const
{
    return ::GetScrollPos(QueryHwnd(), SB_CTL);
}


/*******************************************************************

    NAME:       SCROLLBAR::QueryMin

    SYNOPSIS:   Returns the low end of a scrollbar's range

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

UINT SCROLLBAR::QueryMin() const
{
    INT nMin = 0, nMax;

    BOOL fOk = ::GetScrollRange(QueryHwnd(), SB_CTL, &nMin, &nMax);
#if defined(DEBUG)
    if (!fOk)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGEOL("BLT: GetScrollRange failed, err = "
                << BLT::MapLastError(ERROR_GEN_FAILURE));
    }
#endif

    return (UINT)nMin;
}


/*******************************************************************

    NAME:       SCROLLBAR::QueryMax

    SYNOPSIS:   Returns the high end of a scrollbar's range

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

UINT SCROLLBAR::QueryMax() const
{
    INT nMin, nMax = 0;

    BOOL fOk = ::GetScrollRange(QueryHwnd(), SB_CTL, &nMin, &nMax);
#if defined(DEBUG)
    if (!fOk)
    {
        DBGEOL("BLT: GetScrollRange failed, err = "
                << BLT::MapLastError(ERROR_GEN_FAILURE));
    }
#endif

    return (UINT)nMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltdlg.cxx
    BLT dialog class definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        rustanl     04-Mar-1991 Changed Process format
        beng        14-May-1991 Exploded blt.hxx into components;
                                merged with bltsdp
        gregj       17-May-1991 Return correct error codes to GUILTT
        terryk      28-Jul-1991 Added FilterMessage function to DIALOG_WINDOW
        beng        28-Jul-1992 Add reference to hmodBlt
        KeithMo     07-Aug-1992 Massive revamping of helpfile management.
        jonn        07-Oct-1993 Added OnDlgActivation/OnDlgDeactivation
        DavePr      03-Jun-2002 Fixing DLGPROC for Win64
*/

#include "pchblt.hxx"

extern "C"
{
    /* C7 CODEWORK - nuke this stub */
    INT_PTR CALLBACK BltDlgProc( HWND hdlg, UINT wMsg, WPARAM wParam, LPARAM lParam )
    {
        return DIALOG_WINDOW::DlgProc(hdlg, (USHORT)wMsg, wParam, lParam);
    }

    /* CODEWORK - remove this as soon as all clients convert */
    BOOL  APIENTRY ShellDlgProc(HWND hdlg, USHORT usMsg, WPARAM wParam, DWORD lParam )
    {
        UNREFERENCED(hdlg);
        UNREFERENCED(usMsg);
        UNREFERENCED(wParam);
        UNREFERENCED(lParam);
        ASSERT(FALSE);
        return FALSE;
    }
}


/**********************************************************************

    NAME:       HWND_DLGPTR_CACHE

    SYNOPSIS:   Cache for xlation of hwnd to a pdlg

    INTERFACE:  Find()   - find a dialog_window by the handle
                Add()    - add the dialog window to the current window handle
                Remove() - remove the window handle

    NOTES:
        This is a very simple cache, consisting of one entry only.
        The size and implementation of this cache can be changed to accomodate
        more entries.  More entries may or may not provide better overall
        performance.  The DIALOG_WINDOW class uses this class regardless of
        how many entries the cache has.  Hence, any changes in this cache need
        not cause any changes in the DIALOG_WINDOW implementation.

        CODEWORK: tune this!

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

class HWND_DLGPTR_CACHE
{
private:
    static HWND hwndPrev;
    static DIALOG_WINDOW * pdlgPrev;

public:
    static DIALOG_WINDOW * Find( HWND hwnd );

    static VOID Add( HWND hwnd, DIALOG_WINDOW * pdlg );
    static VOID Remove( HWND hwnd );
};


HWND HWND_DLGPTR_CACHE::hwndPrev = NULL;

DIALOG_WINDOW * HWND_DLGPTR_CACHE::pdlgPrev = NULL;


/**********************************************************************

    NAME:       HWND_DLGPTR_CACHE::Find

    SYNOPSIS:   return the dialog_window handle

    ENTRY:      HWND hwnd - the hwnd of the return DIALOG_WINDOW

    RETURN:     return DIALOG_WINDOW * of the given HWND

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

DIALOG_WINDOW * HWND_DLGPTR_CACHE::Find( HWND hwnd )
{
    if ( hwndPrev == hwnd )
        return pdlgPrev;

    return NULL;
}


/**********************************************************************

    NAME:       HWND_DLGPTR_CACHE::Add

    SYNOPSIS:   Add the dialog window handle to the cache

    ENTRY:      HWND hwnd - the HWND of the given DIALOG_WINDOW
                DIALOG_WINDOW * the dialog window for the given HWND

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID HWND_DLGPTR_CACHE::Add( HWND hwnd, DIALOG_WINDOW * pdlg )
{
    ASSERT( pdlg != NULL );    // should never add a NULL pointer

    hwndPrev = hwnd;
    pdlgPrev = pdlg;
}


/*********************************************************************

    NAME:       HWND_DLGPTR_CACHE::Remove

    SYNOPSIS:   Remove the dialog window handle from the cache

    ENTRY:      HWND hwnd - hwnd of the DIALOG_WINDOW to be removed

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

VOID HWND_DLGPTR_CACHE::Remove( HWND hwnd )
{
    // Note, there is no guarantee that this item will actually be in the
    // cache; hence, we do not assert that it is.

    if ( hwndPrev == hwnd )
    {
        hwndPrev = NULL;
        pdlgPrev = NULL;
    }
}


/*******************************************************************

    NAME:       DLGLOAD::DLGLOAD

    SYNOPSIS:   Constructor - load a dialog from rsrc or template

    ENTRY:
        idrsrcDialog    - name of the application resource
        bufTemplate     - BUFFER object containing assembled template
        hwndOwner       - handle of owner window
        dlgProc         - DLGPROC for dialog-proc

    EXIT:
        Loads the dialog.

    NOTES:
        This class is private to DIALOG_WINDOW.

    HISTORY:
        beng        30-Sep-1991 Created
        beng        01-Nov-1991 Uses IDRESOURCE; replace BUFFER with pb, cb
        beng        03-Aug-1992 Dllization
        KeithMo     07-Feb-1993 Allow override of default charset.
        DavePr      03-Jun-2002 Fixing DLGPROC for Win64

********************************************************************/

DLGLOAD::DLGLOAD( const IDRESOURCE & idrsrcDialog,
                  HWND hwndOwner,
                  DLGPROC dlgProc,
                  BOOL fAnsiDialog )
{
    HMODULE hmod = BLT::CalcHmodRsrc(idrsrcDialog);

    //
    // Create the dialog from the template in the resource file
    //

#if defined(WIN32)
    HWND hwnd = NULL;

    if( fAnsiDialog )
    {
        hwnd = ::CreateDialogA( hmod,
                                (CHAR*)idrsrcDialog.QueryPsz(),
                                hwndOwner,
                                dlgProc);
    }
    else
    {
        hwnd = ::CreateDialogW( hmod,
                                (WCHAR*)idrsrcDialog.QueryPsz(),
                                hwndOwner,
                                dlgProc);
    }

#else   // !WIN32
    UIASSERT( fAnsiDialog );
    HWND hwnd = ::CreateDialog( hmod,
                                (TCHAR*)idrsrcDialog.QueryPsz(),
                                hwndOwner,
                                dlgProc);
#endif  // WIN32

    if (hwnd == NULL)
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));

    _hwnd = hwnd;
}


DLGLOAD::DLGLOAD( const BYTE * pbTemplate,
                  UINT cbTemplate,
                  HWND hwndOwner,
                  DLGPROC dlgProc,
                  BOOL fAnsiDialog )
{
    UNREFERENCED(cbTemplate);

    //
    // Create the dialog from the given template
    //

#if defined(WIN32)
    HWND hwnd = NULL;

    if( fAnsiDialog )
    {
        hwnd = ::CreateDialogIndirectA( hmodBlt,
                                        (LPDLGTEMPLATEA)(CHAR*)pbTemplate,
                                        hwndOwner,
                                        dlgProc);
    }
    else
    {
        hwnd = ::CreateDialogIndirectW( hmodBlt,
                                        (LPDLGTEMPLATEW)(WCHAR*)pbTemplate,
                                        hwndOwner,
                                        dlgProc);
    }

#else   // !WIN32
    UIASSERT( fAnsiDialog );
    HWND hwnd = ::CreateDialogIndirect( hmodBlt,
                                        (LPDLGTEMPLATE)(TCHAR*)pbTemplate,
                                        hwndOwner,
                                        dlgProc);
#endif  // WIN32



    if (hwnd == NULL)
        ReportError(BLT::MapLastError(ERROR_GEN_FAILURE));

    _hwnd = hwnd;
}


/*******************************************************************

    NAME:       DLGLOAD::~DLGLOAD

    SYNOPSIS:   Destructor - releases a loaded dialog

    ENTRY:      Dialog exists

    EXIT:       Dialog window destroyed

    HISTORY:
        beng        30-Sep-1991 Created

********************************************************************/

DLGLOAD::~DLGLOAD()
{
    if (_hwnd != 0)
       ::DestroyWindow( _hwnd );
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::DIALOG_WINDOW

    SYNOPSIS:   constructor for the dialog_window

    ENTRY:      TCHAR* - resource name
                HWND - the HWND of the owner window

    NOTES:
        Help has not yet been activated on this dialog.

        CODEWORK - should statically init the procinst member

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        14-May-1991 Uses BltDlgProc
        beng        30-Sep-1991 Win32 conversion
        beng        01-Nov-1991 Uses IDRESOURCE; replace BUFFER with pb, cb
        KeithMo     07-Feb-1993 Allow override of default charset.

*********************************************************************/

DIALOG_WINDOW::DIALOG_WINDOW( const IDRESOURCE & idrsrcDialog,
                              const PWND2HWND & wndOwner,
                              BOOL fAnsiDialog )
    : OWNER_WINDOW(),
      //_procinstDlg( (MFARPROC)BltDlgProc ),
      _dlg( idrsrcDialog, wndOwner.QueryHwnd(), BltDlgProc, fAnsiDialog ),
      _assocThis( _dlg.QueryHwnd(), this ),
      _prstate( DLG_PROCESS_STATE_INITIALIZING )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    //if (   ((err = _procinstDlg.QueryError()) != NERR_Success)
    //    || ((err = _dlg.QueryError()) != NERR_Success)
    //    || ((err = _assocThis.QueryError()) != NERR_Success) )
    //
    if (   ((err = _dlg.QueryError()) != NERR_Success)
        || ((err = _assocThis.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }

    // Finally, register the hwnd for this object.
    //
    SetHwnd( _dlg.QueryHwnd() );
}


DIALOG_WINDOW::DIALOG_WINDOW( const BYTE * pbTemplate,
                              UINT cbTemplate,
                              HWND hwndOwner,
                              BOOL fAnsiDialog )
    : OWNER_WINDOW(),
      //_procinstDlg( (MFARPROC)BltDlgProc ),
      _dlg( pbTemplate, cbTemplate, hwndOwner, BltDlgProc, fAnsiDialog ),
      _assocThis( _dlg.QueryHwnd(), this ),
      _prstate( DLG_PROCESS_STATE_INITIALIZING )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    //if (   ((err = _procinstDlg.QueryError()) != NERR_Success)
    //    || ((err = _dlg.QueryError()) != NERR_Success)
    //    || ((err = _assocThis.QueryError()) != NERR_Success) )
    if (   ((err = _dlg.QueryError()) != NERR_Success)
        || ((err = _assocThis.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }

    // Finally, register the hwnd for this object.
    //
    SetHwnd( _dlg.QueryHwnd() );
}



/*********************************************************************

    NAME:       DIALOG_WINDOW::~DIALOG_WINDOW

    SYNOPSIS:   destructor for the dialog window class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        22-Aug-1991 Use RESOURCE_STR class
        beng        30-Sep-1991 Win32 conversion

*********************************************************************/

DIALOG_WINDOW::~DIALOG_WINDOW()
{
    ASSERT( _prstate != DLG_PROCESS_STATE_ACTIVE );

    // Remove the properties of the dialog window, and then destroy it,
    // unless the dialog window creation failed.
    //
    HWND hwnd = QueryHwnd();
    if ( hwnd != NULL )
    {
        // Remove ( hwnd, pdlg ) entry from cache, incase it exists there.
        // This way, we guarantee that the cache will not return the wrong
        // pointer in the future, should Windows use the same hwnd for a
        // later window.
        //
        HWND_DLGPTR_CACHE::Remove( hwnd );
    }
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::QueryRobustHwnd

    SYNOPSIS:   The handle for the future version of BLT dialog_window

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

HWND DIALOG_WINDOW::QueryRobustHwnd() const
{
    if ( _prstate == DLG_PROCESS_STATE_ACTIVE )
        return QueryHwnd();

    return QueryOwnerHwnd();
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::HwndToPwnd

    SYNOPSIS:   This method maps a hwnd to a DIALOG_WINDOW.

    ENTRY:      hwnd - the hwnd to be mapped

    RETURNS:    The corresponding DIALOG_WINDOW,
                or NULL on failure.

    NOTES:      This method will return NULL (even for valid dialog hwnd's)
                before CreateDialog has returned.  CODEWORK.  This can be
                changed, if deemed necessary.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Renamed; uses ASSOCHWNDPDLG

*********************************************************************/

DIALOG_WINDOW * DIALOG_WINDOW::HwndToPwnd( HWND hwnd )
{
    // First, attempt to find the (hwnd, pdlg) pair in the cache
    //
    DIALOG_WINDOW * pdlg = HWND_DLGPTR_CACHE::Find( hwnd );

    if ( pdlg != NULL )
        return pdlg;

    pdlg = (DIALOG_WINDOW *)ASSOCHWNDPDLG::HwndToPdlg(hwnd);

    // Add to cache, unless pointer is NULL
    //
    if ( pdlg != NULL )
    {
        HWND_DLGPTR_CACHE::Add( hwnd, pdlg );
    }

    return pdlg;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::Dismiss

    SYNOPSIS:   The method demisses the dialog

    ENTRY:
                UINT nRetVal - An (optional) application defined return
                value for the dialog.  This value may be any unsigned 16-bit
                value.  Typically, the value is FALSE (zero) if the
                the dialog did not achieve its purpose, and TRUE
                (non-zero) if it did.

    EXIT:       Dialog is dismissed

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Win32 conversion

*********************************************************************/

VOID DIALOG_WINDOW::Dismiss( UINT nRetVal )
{
    ASSERT( _prstate == DLG_PROCESS_STATE_ACTIVE );

    // Indicate that the dialog has now been dismissed.
    // This will cause Process to exit its loop.
    //
    _prstate = DLG_PROCESS_STATE_DISMISSED;

    // Record the return value, so that Process can return it.
    //
    _nRetVal = nRetVal;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::DismissMsg

    SYNOPSIS:   This method provides a convenient way to call MsgPopup
                and Dismiss.

    ENTRY:
                USHORT usErr - The error value that is to be passed to
                               MsgPopup
                UINT nRetVal - The value to be passed to Dismiss

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Win32 conversion

*********************************************************************/

VOID DIALOG_WINDOW::DismissMsg( MSGID msgid, UINT nRetVal )
{
    MsgPopup( this, msgid );
    Dismiss( nRetVal );
}


/**********************************************************************

    NAME:       DIALOG_WINDOW::Process

    SYNOPSIS:   This method processes a dialog.
                It disables the owner window, and then sets up a
                message loop to process the dialog.  The method does
                not return until the dialog has been dismissed.

                A dialog object represents one instance of a dialog with
                the user.  Hence, calling this method more than once, or
                calling it after the dialog has already been dismissed
                (note, the dialog may be dismissed in the constructor) will
                result in an error (see below for error code).

    ENTRY:
        pnRetVal   Pointer to storage receiving the programmer defined
                dialog return code passed to Dismiss. pnRetVal
                is only valid if the method returns success.
                (Commonly, pnRetVal may actually point to a BOOL.)

                If a client is not interested in this return code,
                pnRetVal can be passed in as NULL.  The pnRetVal
                parameter defaults to NULL.

    RETURNS:
        The return value from Process is an error value indicating
        the success of constructing the dialog.  NERR_Success indicates
        success.

    NOTES:
        This method should be called while processing the same message
        as when the dialog constructor was called (or more precisely,
        before there's any chance of losing control to Windows).  Otherwise,
        there is a slight chance that some message, triggered by the user,
        would slip into the queue of the owner window.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Win32 conversion
        beng        21-Feb-1992 Use WINDOW::RepaintNow()

**********************************************************************/

APIERR DIALOG_WINDOW::Process( UINT * pnRetVal )
{
    // First, check whether or not the dialog was successfully constructed
    //
    if ( QueryError() != NERR_Success )
        return QueryError();

    // Make sure Process has not been called already
    //
    ASSERT( _prstate == DLG_PROCESS_STATE_INITIALIZING );
    if ( _prstate != DLG_PROCESS_STATE_INITIALIZING )
        return ERROR_GEN_FAILURE;

    // Get the hwnd into a local variable.  It should not be NULL, because
    // then a dialog creation error has occurred, in which case the
    // constructor should have reported an error.
    //
    HWND hwnd = QueryHwnd();
    ASSERT( hwnd != NULL );

    // Disable the parent window, unless the dialog has no owner
    //
    HWND hwndOwner = QueryOwnerHwnd();
    if ( hwndOwner != NULL )
    {
        ::EnableWindow( hwndOwner, FALSE );
    }

    // Force a paint of the dialog.  CODEWORK: This could be changed so
    // that the paint only occurs when the message queue is empty.
    // Show the window only if not "hidden"

    if ( ! QueryAttribute( OWIN_ATTR_HIDDEN ) )
    {
        Show(TRUE);
        RepaintNow();
    }

    // Run private message pump as long as the dialog is still active
    // (i.e., until it is dismissed).  Note that Dismiss will change the
    // value of _prstate.  Q.v. DIALOG_WINDOW::IsPumpFinished.
    //
    // Only enters this pump if the MayRun callout accedes to the request.
    // Should callout refuse to run the dialog, reset _prstate ourselves.
    // Messy hack, yes.  I think the days of _prstate are numbered.
    //
    // Sets _prstate before calling MayRun, so a QueryRobustWindow will
    // find that of the dialog, so that popups will handle focus correctly.
    //
    _prstate = DLG_PROCESS_STATE_ACTIVE;
    if (MayRun())
    {
        RunMessagePump();
    }
    _prstate = DLG_PROCESS_STATE_DISMISSED;

    // Now, re-enable the owner, if any
    //
    if ( hwndOwner != NULL )
    {
        ::EnableWindow( hwndOwner, TRUE );
    }

    // Hide the dialog window.  It will later be destroyed in the
    // destructor.
    //
    Show(FALSE);

    // Finally, set the dialog return value, and return
    //
    if ( pnRetVal != NULL )
        *pnRetVal = _nRetVal; // programmer defined dialog return code

    return NERR_Success;        // dialog was successfully displayed
}

APIERR DIALOG_WINDOW::Process( BOOL * pfRetVal )
{
    // This version accepts a BOOL argument

    UINT nReturned = 0; // JonN 01/27/00: PREFIX 444895

    APIERR err = Process(&nReturned);

    if (pfRetVal != NULL)
        *pfRetVal = !!nReturned;

    return err;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::FilterMessage

    SYNOPSIS:   Client-installable hook into the messageloop.

        DIALOG_WINDOW uses its FilterMessage implementation to
        catch F1 and launch help thereupon, and to handle dialog
        accelerators.

    ENTRY:      pmsg    - pointer to message fresh off the queue

    EXIT:       pmsg    - could possibly be changed

    RETURNS:
        FALSE to proceed with translating and dispatching
        the message.

        TRUE indicates that the message has already been
        handled by the filter.  In this case, the message
        loop will continue on to the next message in the
        queue.

    NOTES:
        This is a virtual member function.

    HISTORY:
        terryk      28-Jul-91   Created (as empty stub)
        beng        07-Oct-1991 Move non-generic behavior into filter

********************************************************************/

BOOL DIALOG_WINDOW::FilterMessage( MSG* pmsg )
{
    /*  The following wonderful R.M.L. comment I keep for eternity:

        The order in which the message and wParam components of
        the msg structure are checked for the F1 key has been optimized.
        Since it appears that wParam == VK_F1 appears less often than
        message == WM_KEYDOWN.  Hence, the former is checked first.
        For the F1 key, only the VK_F1 virtual key code is checked.
        There is a VK_HELP virtual key code, too.  VK_HELP is not
        the same key as the the F1 key.  In fact, VK_HELP is not a
        required key.    For this reason, and for the reason of not
        having to document some other Help key, the VK_HELP code
        is not tested for.
     */

    // Trap the F1 key

    if ( pmsg->wParam == VK_F1 && pmsg->message == WM_KEYDOWN )
    {
        OnHelp();
        return TRUE;
    }

    // Take care of dialog accelerators

    if ( ::IsDialogMessage( QueryHwnd(), pmsg ))
        return TRUE;

    // Let everything else through

    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::IsPumpFinished

    SYNOPSIS:   Client-installable pump termination condition

        DIALOG_WINDOW uses this predicate to drive the dialog box
        until Dismiss sets the _prstate flag to indicate completion.

    ENTRY:      Message pump has dispatched a message

    RETURNS:    TRUE to end the pump; FALSE to continue

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        07-Oct-1991 Created

********************************************************************/

BOOL DIALOG_WINDOW::IsPumpFinished()
{
    return ( _prstate != DLG_PROCESS_STATE_ACTIVE );
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::MayRun

    SYNOPSIS:   Client-installable dialog abort callout

        DIALOG_WINDOW uses this predicate to allow the client to abort
        a dialog after it's painted, but before it's run.

    ENTRY:      Dialog is painted, but not processed

    RETURNS:    TRUE to continue the dialog; FALSE to abort

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        30-Mar-1992 Created

********************************************************************/

BOOL DIALOG_WINDOW::MayRun()
{
    return TRUE; // default implementation
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::QueryHelpContext

    SYNOPSIS:   Called when the user performed an action which triggers Help
                to appear.  In particular, this may happen if the user
                pressed F1 or pushed the Help button.

    RETURNS:    Help context of dialog, or 0L if no help provided.

    NOTES:
        This method is replaceable to all subclasses.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

ULONG DIALOG_WINDOW::QueryHelpContext()
{
    return 0L;    // no help available
}


/*********************************************************************

    NAME:       DIALOG_WINDOW :: QueryHelpFile

    SYNOPSIS:   This method is responsible for returning the help
                file associated with the given help context.

    ENTRY:      nHelpContext            - A help context.  Must be mapped
                                          to an appropriate help file.

    RETURNS:    const TCHAR *           - The name of the help file, or
                                          NULL if none exists.

    NOTES:      This method is replaceable to all subclasses.

    HISTORY:
        KeithMo   07-Aug-1992   Created.

*********************************************************************/
const TCHAR * DIALOG_WINDOW :: QueryHelpFile( ULONG nHelpContext )
{
    return BLT::CalcHelpFileHC( nHelpContext );

}   // DIALOG_WINDOW :: QueryHelpFile


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnOK

    SYNOPSIS:   Called when the dialog's OK button is clicked
        and all data thereis passes muster (as per dialog validation
        rules).

    RETURNS:    TRUE if action was taken,
                FALSE otherwise.

    CAVEATS:
        Assumes that the OK button has control ID IDOK.

    NOTES:
        This method may be replaced by derived classes.
        This default implementation dismisses the dialog, returning TRUE.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

BOOL DIALOG_WINDOW::OnOK()
{
    Dismiss(TRUE);
    return TRUE;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnCancel

    SYNOPSIS:   Called when the dialog's Cancel button is clicked.
                Assumes that the Cancel button has control ID IDCANCEL.

    RETURNS:
        TRUE if action was taken,
        FALSE otherwise.

    NOTES:
        This method may be replaced by derived classes.
        This default implementation dismisses the dialog, returning FALSE.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

BOOL DIALOG_WINDOW::OnCancel()
{
    Dismiss(FALSE);
    return TRUE;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnCommand

    SYNOPSIS:   This method gets called when a dialog control sends
                some notification to its parent (i.e., this dialog).

    ENTRY:
        cid         The ID of the control which sent the notification
        lParam      Same parameter sent by the notifying control

    RETURNS:
        The method should return TRUE if it processed the message, and
        FALSE otherwise.

    NOTES:
        This method is replaceable to all subclasses.

        It is common practise to, as a last resort, call the OnCommand
        method for the parent class.

        This method is not called for notifications from speciial controls.
        Special controls are the OK, Cancel, and Help buttons.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        30-Sep-1991 Replaced

*********************************************************************/

BOOL DIALOG_WINDOW::OnCommand( const CONTROL_EVENT & event )
{
    UNREFERENCED(event);

    return FALSE;
}


/*********************************************************************

    NAME:       DIALOG_WINDOW::OnControlError

    SYNOPSIS:   This method is called whenever a control reports an error.
                If it is called, the corresponding OnCommand will not
                be called.

    ENTRY:
        cid     The control ID of the control reporting the error
        usErr   The error code of the error that occurred

    NOTES:
        This method is replaceable by derived classes.  As a default
        action, it displays the message to the user.

    HISTORY:
        rustanl   20-Nov-1990      Created

*********************************************************************/

VOID DIALOG_WINDOW::OnControlError( CID cid, APIERR err )
{
    UNREFERENCED(cid);

    MsgPopup( this, (MSGID)err );    // display the error to the user
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnValidationError

    SYNOPSIS:   Called whenever a control reports invalid input
                (at dialog validation time).

    ENTRY:      cid - control ID of failing control
                err - code of error, as reported by control

    NOTES:
        This virtual member function should be replaced by dialogs
        wishing to take further action when validation fails.  Most
        dialogs need not bother.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

VOID DIALOG_WINDOW::OnValidationError( CID cid, APIERR err )
{
    UNREFERENCED(cid);
    UNREFERENCED(err);
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnTimer

    SYNOPSIS:   Timer response callback

    ENTRY:      event - Timer event

    RETURNS:    TRUE if you handle it

    HISTORY:
        beng        07-Oct-1991 Header added

********************************************************************/

BOOL DIALOG_WINDOW::OnTimer( const TIMER_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnScrollBar

    SYNOPSIS:   Scrollbar response callback

    ENTRY:      event - Timer event

    RETURNS:    TRUE if you handle it

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnScrollBar( const SCROLL_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnScrollBarThumb

    SYNOPSIS:   Scrollbar thumb-motion response callback

    ENTRY:      event - Timer event

    RETURNS:    TRUE if you handle it

    HISTORY:
        beng        18-May-1992 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnScrollBarThumb( const SCROLL_THUMB_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnDlgActivation

    SYNOPSIS:   Activation callback

    ENTRY:      event - Activation event

    RETURNS:    TRUE if you handle it

    HISTORY:
        jonn        07-Oct-1993 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnDlgActivation( const ACTIVATION_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnDlgDeactivation

    SYNOPSIS:   Deactivation callback

    ENTRY:      event - Activation event

    RETURNS:    TRUE if you handle it

    HISTORY:
        jonn        07-Oct-1993 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnDlgDeactivation( const ACTIVATION_EVENT & event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnCtlColor

    SYNOPSIS:   Intercepts WM_CTLCOLOR*

    RETURNS:    brush handle if you handle it

    NOTES:      If you redefine this method, you should either return
                non-NULL or else (possibly change *pmsgid and) call
                through to the root implementation.

    HISTORY:
        jonn        03-Aug-1995 Created

********************************************************************/
HBRUSH DIALOG_WINDOW::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    ASSERT( pmsgid != NULL );
    CID cid = ::GetWindowLong( hwnd, GWL_ID );
    CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
    if (pctrl != NULL)
    {
        return pctrl->OnCtlColor( hdc, hwnd, pmsgid );
    }
    return NULL;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnSysColorChange

    SYNOPSIS:   Intercepts WM_SYSCOLORCHANGE

    NOTES:      see shellui\share\sharecrt.cxx for an example of how to
                work with this

    HISTORY:
        jonn        08-Aug-1995 Created

********************************************************************/
VOID DIALOG_WINDOW::OnSysColorChange()
{
    return;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::DlgProc

    SYNOPSIS:   The one and only BLT dialog procedure.

    ENTRY:      Called by BltDlgProc (the exported thunk).

    RETURNS:    TRUE to override system default behavior
                FALSE otherwise

    NOTES:
        This is a static member function.

    HISTORY:
        rustanl     ???         Created (as ShellDlgProc)
        beng        14-May-1991 Replaced ShellDlgProc
        beng        21-May-1991 Relocated much to OWNER_WINDOW,
                                for sharing with CLIENT_WINDOW
        beng        22-Aug-1991 Use RESOURCE_STR
        beng        22-Sep-1991 Correct usage of GetVersion
        beng        08-Oct-1991 Win32 conversion
        beng        31-Oct-1991 Added dialog validation
        beng        18-May-1992 Handles WM_[VH]SCROLL
        congpay     25-Oct-1992 Add OnUserMessage

********************************************************************/

INT_PTR CALLBACK DIALOG_WINDOW::DlgProc(
    HWND   hDlg,
    UINT   nMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    // First, handle messages which are not concerned about whether or
    // not hDlg can be converted into pdlg.

    switch (nMsg)
    {
    case WM_COMPAREITEM:
    case WM_DELETEITEM:
        return OWNER_WINDOW::OnLBIMessages(nMsg, wParam, lParam);
    }


    // Now, convert the hDlg to a pdlg.  If no pdlg available, then
    // we don't have our hwnd-to-pwnd hooks set up just yet.

    DIALOG_WINDOW * pdlg = DIALOG_WINDOW::HwndToPwnd( hDlg );

    if ( pdlg == NULL )
    {
        switch ( nMsg )
        {
        case WM_INITDIALOG:
            return TRUE;    // this asks of Windows to set the initial focus

        case WM_MEASUREITEM:
            // This WM_MEASUREITEM message is sent before the
            // WM_INITDIALOG message (except for variable size owner-draw
            // list controls.  Hence, the window properties are not yet set
            // up, and so the owner dialog cannot be called at this time.
            //
            // This function guesses the measure for fixed-size items
            // given the information available.
            //
            return OWNER_WINDOW::CalcFixedCDMeasure( hDlg, (MEASUREITEMSTRUCT *)lParam );

        default:
            break;
        }

        return FALSE;
    }


    switch ( nMsg )
    {
    case WM_COMMAND:
        {
            CONTROL_EVENT e( nMsg, wParam, lParam );
            CID cid = e.QueryCid();

            // Take care of the special cases immediately
            //
            switch ( cid )
            {
            case IDHELPBLT:
                // User clicked Help button
                return pdlg->OnHelp();

            case IDOK:
                // User clicked OK button.  Check dialog validity,
                // and allow the user to proceed only if all data
                // passes muster.
                //
                if (pdlg->IsValid())
                    return pdlg->OnOK();
                break;

            case IDCANCEL:
                // User clicked Cancel button
                return pdlg->OnCancel();
            }

            /*  First, call the control itself to do any processing
             *  on a control level.
             *  If the message is a client generated message (for
             *  example, SetText on an SLE), then we ignore the
             *  message and don't tell anyone about it.
             */

            CONTROL_WINDOW * pctrl = pdlg->CidToCtrlPtr( cid );

            if ( pctrl != NULL && !pctrl->IsClientGeneratedMessage() )
            {
                APIERR err = pctrl->OnUserAction(e);

                if ( err == NERR_Success )
                {
                    err = pctrl->NotifyGroups(e);
                }

                if ( err != NERR_Success && err != GROUP_NO_CHANGE )
                {
                    pdlg->OnControlError( cid, err );
                    return TRUE;
                }
            }

            //  Call the dialog to do dialog level processing.
            //
            return pdlg->OnCommand(e);
        }

    case WM_BLTHELP:
        pdlg->LaunchHelp();
        return TRUE;

    case WM_GUILTT:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        // Responses to owner-draw-control messages are defined
        // in the owner-window class.
        //
        return pdlg->OnCDMessages(nMsg, wParam, lParam);

    case WM_TIMER:
        {
            TIMER_EVENT e( nMsg, wParam, lParam );
            return pdlg->OnTimer(e);
        }

    case WM_VSCROLL:
    case WM_HSCROLL:
        {
            SCROLL_EVENT se( nMsg, wParam, lParam );

            if (   se.QueryCommand() == SCROLL_EVENT::scmdThumbPos
                || se.QueryCommand() == SCROLL_EVENT::scmdThumbTrack )
                return pdlg->OnScrollBarThumb((const SCROLL_THUMB_EVENT &)se);
            else
                return pdlg->OnScrollBar((const SCROLL_EVENT &)se);
        }

    case WM_ACTIVATE:
        {
            ACTIVATION_EVENT ae( nMsg, wParam, lParam );

            if (ae.IsActivating())
                return pdlg->OnDlgActivation(ae);
            else
                return pdlg->OnDlgDeactivation(ae);
        }

    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
        {
            UINT tmpMsgid = nMsg;
            BOOL retval = (NULL != (pdlg->OnCtlColor(
                                    (HDC)wParam, (HWND)lParam, &tmpMsgid )));
            if ( !retval && tmpMsgid != nMsg )
                return (BOOL)::DefWindowProc(
                                pdlg->QueryHwnd(), tmpMsgid, wParam, lParam );
            else
                return retval;
        }

    }

    // add OnUserMessage.
    if (nMsg >= WM_USER+100)
    {
        EVENT event(nMsg, wParam, lParam);
        return pdlg->OnUserMessage((const EVENT &)event);
    }

    // Have default dialog-proc called for us
    //
    return FALSE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::OnHelp

    SYNOPSIS:   Respond to a request for help

    EXIT:       "Help" message sitting in application queue

    NOTES:
        Unlike most of the "On" members, this is not a virtual
        function, so don't even think about redefining it.

    HISTORY:
        beng        30-Sep-1991 Created

********************************************************************/

BOOL DIALOG_WINDOW::OnHelp()
{
    ::PostMessage( QueryHwnd(), WM_BLTHELP, 0, 0L );
    return TRUE;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::LaunchHelp

    SYNOPSIS:   Actually launches the WinHelp applilcation

    NOTES:
        This is a private member function.

    HISTORY:
        beng        07-Oct-1991 Header added
        beng        05-Mar-1992 Removed wsprintf
        beng        22-Jun-1992 Disable help for Prerelease
        KeithMo     16-Aug-1992 Integrated new helpfile management.

********************************************************************/

VOID DIALOG_WINDOW::LaunchHelp()
{
    ULONG ulHelp = QueryHelpContext();
    const TCHAR * pszHelpFile = QueryHelpFile( ulHelp );

#if defined(DEBUG)
    HEX_STR nlsHelpContext(ulHelp);

    if( pszHelpFile != NULL )
    {
        DBGEOL( SZ("Help called on file ") << pszHelpFile << \
                SZ(", context ") << nlsHelpContext );
    }
    else
    {
        DBGEOL( SZ("Help called on unknown context ") << nlsHelpContext );
    }
#endif

    if( pszHelpFile != NULL )
    {
        if( !::WinHelp( QueryHwnd(),
                        (TCHAR *)pszHelpFile,
                        HELP_CONTEXT,
                        (DWORD)ulHelp ) )
        {
            ::MsgPopup( QueryHwnd(),
                        IDS_BLT_WinHelpError,
                        MPSEV_ERROR,
                        MP_OK );
        }
    }
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::Validate

    SYNOPSIS:   Checks every control for valid input

    ENTRY:      Controls contain input of unknown validity

    EXIT:       If success, every control contains valid input.
                If failed, control has indicated error, and dialog
                has been notified.

    RETURNS:    Code returned by failing control (0 if none)

    NOTES:
        If the dialog contains no self-validating controls, then
        this will always return success.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

APIERR DIALOG_WINDOW::Validate()
{
    ITER_CTRL iter(this);
    CONTROL_WINDOW * pctrl;
    while ((pctrl = iter.Next()) != NULL)
    {
        APIERR err = pctrl->Validate();
        if (err != NERR_Success)
        {
            // Control contained invalid data.

            pctrl->IndicateError(err);
            OnValidationError(pctrl->QueryCid(), err);
            return err;
        }
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       DIALOG_WINDOW::IsValid

    SYNOPSIS:   Returns whether controls contain valid data

    RETURNS:    fValid - TRUE if all's well.

    HISTORY:
        beng        31-Oct-1991 Created

********************************************************************/

BOOL DIALOG_WINDOW::IsValid()
{
    return (Validate() == NERR_Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltclwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltclwin.cxx
    Implementation of BLT client window classes

    FILE HISTORY:
        beng        09-May-1991     Created
        beng        13-Feb-1992     Relocated Repaint and RepaintNow to WINDOW
        KeithMo     07-Aug-1992     STRICTified.

*/
#include "pchblt.hxx"

extern "C"
{
    /* C7 CODEWORK - nuke this stub */
    LRESULT _EXPORT APIENTRY BltWndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
    {
        return CLIENT_WINDOW::WndProc(hwnd, nMsg, wParam, lParam);
    }
}


/* This is the name of the standard BLT windowclass */
const TCHAR * CLIENT_WINDOW::_pszClassName = SZ("BltClWin");


/*******************************************************************

    NAME:       CLIENT_WINDOW::Init

    SYNOPSIS:   Registers the single winclass used by client windows

    ENTRY:      BLT is uninitialized

    EXIT:       Winclass registered

    RETURNS:    Error code - 0 if successful

    NOTES:

    HISTORY:
        beng        18-Sep-1991 Changed return type
        beng        19-Oct-1991 Fixed background brush-load
        beng        26-Dec-1991 Works correctly when a client DLL has
                                already registered the class.
        beng        03-Aug-1992 True dllization delta

********************************************************************/

APIERR CLIENT_WINDOW::Init()
{
    WNDCLASS wc;
    BOOL     fSuccess;

    // See if anybody has already registered such a class.
    //

#if defined(DEBUG)
    fSuccess = ::GetClassInfo( hmodBlt, _pszClassName, &wc);
    if (fSuccess)
    {
        DBGEOL("BLT: wndclass already registered?");
        return ERROR_CLASS_ALREADY_EXISTS;
    }
#endif

    // Not already registered; assemble and attempt to register.
    //

    wc.style = CS_DBLCLKS;              // Yes! Give us double-clicks
    wc.lpfnWndProc = BltWndProc;
    wc.cbClsExtra = 0;                  // No per-class extra data.
    wc.cbWndExtra = 0;                  // No per-window extra data.
    wc.hInstance = hmodBlt;         // Hmod of common DLL
    wc.hIcon = NULL;                    // No icon
    wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName = NULL;             // No menu
    wc.lpszClassName = _pszClassName;

    TRACEEOL( "CLIENT_WINDOW::Init(); registering class" );
    fSuccess = ::RegisterClass(&wc);
    DWORD RegErr = ::GetLastError();
    TRACEEOL( "CLIENT_WINDOW::Init(); registered class" );

    if (!fSuccess)
    {
        DBGEOL("Couldn't register BLT window class " << RegErr);
        return BLT::MapLastError(ERROR_CLASS_ALREADY_EXISTS);
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::Term

    SYNOPSIS:   Releases the single winclass used by client windows

    ENTRY:      BLT is terminating

    EXIT:       Theoretically, winclass would be unregistered....

    HISTORY:
        beng        18-Sep-1991 Added comment header
        JohnL       08-Jan-1992 Changed assert to DBGEOL; Not necessarily
                                an error if unregister fails so downgrade
                                severity for public consumption
        beng        03-Aug-1992 Fix for BLT-in-a-DLL

********************************************************************/

VOID CLIENT_WINDOW::Term()
{
    // I don't really need to unregister; USER would do it for me.

    TRACEEOL( "CLIENT_WINDOW::Term(); deregistering class" );
    BOOL fRet = ::UnregisterClass(_pszClassName, hmodBlt);
    TRACEEOL( "CLIENT_WINDOW::Term(); deregistered class" );
    if ( !fRet )
    {
        DWORD RegErr = ::GetLastError();
        DBGEOL("BLT: UnregisterClass on window class failed " << RegErr);
    }
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::CLIENT_WINDOW

    SYNOPSIS:   Constructor for client-window

    ENTRY:
        flStyle     - dword of style bits for Windows
        pwndOwner   - pointer to owner-window
        pszClassName- name of winclass for window creation.

        With no arguments, attempts to inherit the window.

    EXIT:
        Window is created.

    NOTES:

    HISTORY:
        beng        30-Sep-1991 Uses ASSOCHWNDPWND

********************************************************************/

CLIENT_WINDOW::CLIENT_WINDOW(
    ULONG          flStyle,
    const WINDOW * pwndOwner,
    const TCHAR * pszClassName )
    : OWNER_WINDOW( pszClassName, flStyle, pwndOwner ),
      _assocThis( QueryHwnd(), this )
{
    if (QueryError())
        return;

    if ( !_assocThis )
    {
        ReportError( _assocThis.QueryError() );
        return;
    }
}

CLIENT_WINDOW::CLIENT_WINDOW()
    : OWNER_WINDOW(),
      _assocThis( QueryHwnd(), this )
{
    // This form of the constructor assumes that some other
    // agent has already created the window for us.

    if (QueryError())
        return;

    if ( !_assocThis )
    {
        ReportError( _assocThis.QueryError() );
        return;
    }
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::DispatchMessage

    SYNOPSIS:   Message dispatcher for client window

    ENTRY:      EVENT - an event in the window

    EXIT:       Window has either taken a response to the event
                or else punted to Windows for default behavior

    RETURNS:    TRUE if message handled completely
                FALSE if system-standard behavior still needed

    NOTES:

    HISTORY:
        beng        08-Jul-1991     Return type changed to LONG

********************************************************************/

LRESULT CLIENT_WINDOW::DispatchMessage( const EVENT &event )
{
    switch (event.QueryMessage())
    {
    case WM_PAINT:
        return OnPaintReq();

    case WM_ACTIVATE:
        {
            const ACTIVATION_EVENT & ae = (const ACTIVATION_EVENT &)event;

            if (ae.IsActivating())
                return OnActivation((const ACTIVATION_EVENT &)ae);
            else
                return OnDeactivation((const ACTIVATION_EVENT &)ae);
        }

    case WM_SIZE:
        return OnResize((const SIZE_EVENT &)event);

    case WM_MOVE:
        return OnMove((const MOVE_EVENT &)event);

    case WM_CLOSE:
        return OnCloseReq();

    case WM_DESTROY:
        // Usually not called...
        //
        return OnDestroy();

    case WM_KEYUP:
        return OnKeyUp((const VKEY_EVENT &)event);

    case WM_KEYDOWN:
        return OnKeyDown((const VKEY_EVENT &)event);

    case WM_CHAR:
        return OnChar((const CHAR_EVENT &)event);

    case WM_MOUSEMOVE:
        return OnMouseMove((const MOUSE_EVENT &)event);

    case WM_LBUTTONDOWN:
        return OnLMouseButtonDown((const MOUSE_EVENT &)event);

    case WM_LBUTTONUP:
        return OnLMouseButtonUp((const MOUSE_EVENT &)event);

    case WM_LBUTTONDBLCLK:
        return OnLMouseButtonDblClick((const MOUSE_EVENT &)event);

    case WM_SETFOCUS:
        return OnFocus((const FOCUS_EVENT &)event);

    case WM_KILLFOCUS:
        return OnDefocus((const FOCUS_EVENT &)event);

    case WM_TIMER:
        return OnTimer((const TIMER_EVENT &)event);

    case WM_COMMAND:
        return OnCommand((const CONTROL_EVENT &)event);
    }

    // Now for user-defined messages
    //
    if (event.QueryMessage() >= WM_USER+100)
    {
        // C7 CODEWORK - remove redundant cast
        return OnUserMessage((const EVENT &)event);
    }

    // Message not handled (default)
    //
    return FALSE;
}


BOOL CLIENT_WINDOW::OnPaintReq()
{
    return FALSE;
}


BOOL CLIENT_WINDOW::OnActivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDeactivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnResize( const SIZE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnMove( const MOVE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::OnCloseReq

    SYNOPSIS:   Called upon a request to close the window

    RETURNS:    FALSE

    NOTES:      This default implementation does nothing.

    HISTORY:
        beng        09-May-1991     Created
        beng        14-May-1991     Renamed (from "MayClose")

********************************************************************/

BOOL CLIENT_WINDOW::OnCloseReq()
{
    return FALSE;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::OnDestroy

    SYNOPSIS:   Called upon an *external* DestroyWindow.
                (Internal DestroyWindow calls created by the
                destructor will never cross this callback.)

    NOTES:
        This is not a dependable callback; please do not use it.

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

BOOL CLIENT_WINDOW::OnDestroy()
{
    return FALSE;
}


BOOL CLIENT_WINDOW::OnKeyDown( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnKeyUp( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnChar( const CHAR_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnMouseMove( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnLMouseButtonDown( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnLMouseButtonUp( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnLMouseButtonDblClick( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnFocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDefocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnTimer( const TIMER_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnCommand( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDblClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnChange( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnSelect( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnEnter( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnDropDown( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


#if 0 // unimplemented
BOOL CLIENT_WINDOW::OnScrollBar( const SCROLL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL CLIENT_WINDOW::OnScrollBarThumb( const SCROLL_THUMB_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}
#endif


BOOL CLIENT_WINDOW::OnOther( const EVENT &event )
{
    return (BOOL)DefWindowProc( QueryHwnd(), event.QueryMessage(),
                                event.QueryWParam(), event.QueryLParam());
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::WndProc

    SYNOPSIS:   Window-proc for BLT client windows

    ENTRY:      As per wndproc

    EXIT:       As per wndproc

    RETURNS:    The usual code returned by a wndproc

    NOTES:
        This is the wndproc proper for BLT client windows.  In
        the "extern C" clause above I declare a tiny exported stub
        which calls this.

    HISTORY:
        beng        10-May-1991 Implemented
        beng        20-May-1991 Add custom-draw control support
        beng        08-Jul-1991 DispatchMessage changed return type
        beng        15-Oct-1991 Win32 conversion

********************************************************************/

LRESULT CLIENT_WINDOW::WndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    // First, handle messages which are not concerned about whether or
    // not hwnd can be converted into pwnd.

    switch (nMsg)
    {
    case WM_COMPAREITEM:
    case WM_DELETEITEM:
        return OWNER_WINDOW::OnLBIMessages(nMsg, wParam, lParam);
    }

    CLIENT_WINDOW * pwnd = CLIENT_WINDOW::HwndToPwnd( hwnd );
    if (pwnd == NULL)
    {
        // If HwndToPwnd returns NULL, then either CreateWindow call
        // has not yet returned, or else this class's destructor has
        // already been called - important, since this proc will continue
        // to receive messages such as WM_DESTROY.  Since Blt Windows perform
        // their WM_CREATE style code in their constructor, it's okay to
        // let most of the traditional early messages pass us by.
        //
        // The exception is WM_GETMINMAXINFO, I suppose...
        //
        return ::DefWindowProc(hwnd, nMsg, wParam, lParam);
    }

    switch (nMsg)
    {
    case WM_GUILTT:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        // Responses to owner-draw-control messages are defined
        // in the owner-window class.
        //
        // It makes no sense to redefine one of these without
        // redefining the others.  Proper redefinition of control
        // behavior is done in the CONTROL_WINDOW::CD_* functions.
        //
        return pwnd->OnCDMessages(nMsg, wParam, lParam);
    }

    // Assemble an EVENT object, and dispatch appropriately.

    EVENT event( nMsg, wParam, lParam );
    LRESULT lRes = pwnd->DispatchMessage(event);
    if (lRes == 0)
        lRes = ::DefWindowProc(hwnd, nMsg, wParam, lParam);

    if (nMsg == WM_NCDESTROY)
    {
        // This is the last message that any window receives before its
        // hwnd becomes invalid.  This case will only be run if a BLT
        // client-window is destroyed by DestroyWindow instead of by
        // its destructor: a pathological case, since BLT custom controls
        // die by destructor even in a BLT dialog.
        //
        // Normally, a client window will receive DESTROY only after
        // its destructor has already disassociated the hwnd and pwnd.
        //
        pwnd->ResetCreator();
        // pwnd->DisassocHwndPwnd();
    }

    return lRes;
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::CaptureMouse

    SYNOPSIS:   Capture mouse input

    ENTRY:      Window may or may not have the mouse

    EXIT:       Window has the mouse

    NOTES:
        Should this function return the previous owner?  The API
        does provide that.

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID CLIENT_WINDOW::CaptureMouse()
{
    ::SetCapture(QueryHwnd());
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::ReleaseMouse

    SYNOPSIS:   Release mouse input after a CaptureMouse

    ENTRY:      Window has the mouse

    EXIT:       Window no longer has the mouse

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID CLIENT_WINDOW::ReleaseMouse()
{
    ::ReleaseCapture();
}


/*******************************************************************

    NAME:       CLIENT_WINDOW::QueryRobustHwnd

    SYNOPSIS:   Returns a Hwnd for MsgPopup's parent

    RETURNS:    Dependable HWND

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

HWND CLIENT_WINDOW::QueryRobustHwnd() const
{
    return QueryHwnd();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltdisph.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltdisph.cxx
    Implementation of BLT window-message dispatcher

    FILE HISTORY:
        beng        09-May-1991 Created
        terryk      20-Jun-1991 Move the source code from bltclwin.cxx
        terryk      10-Jul-1991 Change the constructor parameter to
                                WINDOW *.
        terryk      25-Jul-1991 Add OnDragBegin and OnDragEnd.
        beng        27-Sep-1991 Merge with CLIENT_WINDOW
        beng        19-May-1992 OnNCHitTest superseded by CUSTOM_CONTROL::
                                OnQHitTest
        beng        28-May-1992 The amazing bltcc/bltdisph shuffle
*/


#include "pchblt.hxx"


// A do-the-default return for the WM_NCHITTEST message,
// which gives 0 an interesting meaning.  Here's hoping this isn't
// reassigned in the near future to any other interesting value.

#define HT_DO_DEFAULT       ((ULONG)((HTERROR)-1))



/**********************************************************************

    NAME:       DISPATCHER::DISPATCHER

    SYNOPSIS:   constructor

    ENTRY:      CONTROL_WINDOW *pwnd - the associated control window pointer

    HISTORY:
        beng        10-May-1991 Created
        terryk      10-Jul-1991 Change the given parameter to
                                CONTROL_WINDOW pointer
        beng        30-Sep-1991 Win32 conversion
        beng        28-May-1992 bltcc reshuffle

***********************************************************************/

DISPATCHER::DISPATCHER( WINDOW *pwnd )
    : _pwnd( pwnd ),
      _assocThis( pwnd->QueryHwnd(), this )
{
    // This form of the constructor assumes that some other
    // agent has already created the window for us.

    if ( !_assocThis )
        return;

    // CODEWORK - inherit from BASE?
}


DISPATCHER::~DISPATCHER()
{
    // Nobody lives here
}


/*********************************************************************

    NAME:       DISPATCHER::Dispatch

    SYNOPSIS:   Main routine to dispatch the event appropriately

    ENTRY:      EVENT event - general event

    HISTORY:
        terryk      10-May-1991 Created
        terryk      25-Jul-1991 Add fDragMode checking
        beng        05-Dec-1991 Added scroll-bar messages
        beng        18-May-1992 Scroll-bar callbacks disabled
        beng        19-May-1992 WM_NCHITTEST reloc'd to CUSTOM_CONTROL
        beng        28-May-1992 Scramble bltcc, bltdisph

*********************************************************************/

BOOL DISPATCHER::Dispatch( const EVENT &event, ULONG * pnRes )
{
    BOOL fHandled = FALSE;

    // I've tried to order these messages to get the common cases
    // checked first.

    switch (event.QueryMessage())
    {

    case WM_NCHITTEST:
        // Special case, yuck.  0 is an interesting return here,
        // esp. when subclassing a STATIC.

        {
            ULONG nRes = OnQHitTest( XYPOINT(event.QueryLParam()) );
            if (nRes == HT_DO_DEFAULT) // HACK!
                return FALSE;
            else
            {
                *pnRes = nRes;
                return TRUE;
            }
        }

    //
    // Following simple cases share common pnRes-setting code
    // (at end of fcn, jumped to by BREAK statement)
    //

    case WM_MOUSEMOVE:
        fHandled = OnMouseMove((const MOUSE_EVENT &)event);
        break;

    case WM_SETCURSOR:
        fHandled = OnQMouseCursor((const QMOUSEACT_EVENT &)event);
        break;

    case WM_PAINT:
        fHandled = OnPaintReq();
        break;

    case WM_ACTIVATE:
        {
            const ACTIVATION_EVENT & ae = (const ACTIVATION_EVENT &)event;

            if (ae.IsActivating())
                fHandled = OnActivation((const ACTIVATION_EVENT &)ae);
            else
                fHandled = OnDeactivation((const ACTIVATION_EVENT &)ae);
        }
        break;

    case WM_SIZE:
        fHandled = OnResize((const SIZE_EVENT &)event);
        break;

    case WM_MOVE:
        fHandled = OnMove((const MOVE_EVENT &)event);
        break;

    case WM_CLOSE:
        fHandled = OnCloseReq();
        break;

    case WM_DESTROY: // REVIEW - when would this be called?
        fHandled = OnDestroy();
        break;

    case WM_KEYUP:
        fHandled = OnKeyUp((const VKEY_EVENT &)event);
        break;

    case WM_KEYDOWN:
        fHandled = OnKeyDown((const VKEY_EVENT &)event);
        break;

    case WM_CHAR:
        fHandled = OnChar((const CHAR_EVENT &)event);
        break;

    case WM_LBUTTONDOWN:
        fHandled = OnLMouseButtonDown((const MOUSE_EVENT &)event);
        break;

    case WM_LBUTTONUP:
        fHandled = OnLMouseButtonUp((const MOUSE_EVENT &)event);
        break;

    case WM_LBUTTONDBLCLK:
        fHandled = OnLMouseButtonDblClick((const MOUSE_EVENT &)event);
        break;

    case WM_SETFOCUS:
        fHandled = OnFocus((const FOCUS_EVENT &)event);
        break;

    case WM_KILLFOCUS:
        fHandled = OnDefocus((const FOCUS_EVENT &)event);
        break;

    case WM_TIMER:
        fHandled = OnTimer((const TIMER_EVENT &)event);
        break;

#if 0 // disabled - no clients
    case WM_VSCROLL:
    case WM_HSCROLL:
        {
            const SCROLL_EVENT & se = (const SCROLL_EVENT &)event;

            if (   se.QueryCommand() == SCROLL_EVENT::scmdThumbPos
                || se.QueryCommand() == SCROLL_EVENT::scmdThumbTrack )
                fHandled = OnScrollBarThumb((const SCROLL_THUMB_EVENT &)se);
            else
                fHandled = OnScrollBar((const SCROLL_EVENT &)se);
        }
        break;
#endif

    case WM_COMMAND:
        fHandled = OnCommand((const CONTROL_EVENT &)event);
        break;

    //
    // So much for the simple cases.  Following cases all set and return
    // status themselves.
    //

    case WM_GETDLGCODE:
        {
            ULONG nRes = OnQDlgCode();
            if (nRes == 0L)
                return FALSE;
            else
            {
                *pnRes = nRes;
                return TRUE;
            }
        }

    case WM_MOUSEACTIVATE:
        {
            ULONG nRes = OnQMouseActivate((const QMOUSEACT_EVENT &)event);
            if (nRes == 0L)
                return FALSE;
            else
            {
                *pnRes = nRes;
                return TRUE;
            }
        }

    default:
        if (event.QueryMessage() >= WM_USER+100)
        {
            // C7 CODEWORK - remove redundant cast
            fHandled = OnUserMessage((const EVENT &)event);
            break;
        }

        // Message not handled at all by dispatcher
        return FALSE;
    }


    // The most common response to a successful dispatch

    if (fHandled)
        *pnRes = TRUE;

    return fHandled;
}


/*******************************************************************

    NAME:       DISPATCHER::OnUserMessage

    SYNOPSIS:   Handles all user-defined messages

    ENTRY:      event - an untyped EVENT

    RETURNS:    TRUE if event handled, FALSE otherwise

    NOTES:
        Clients handling user-defined messages should supply
        OnOther instead of redefining DispatchMessage.

    HISTORY:
        beng        14-May-1991     Created

********************************************************************/

BOOL DISPATCHER::OnUserMessage( const EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnPaintReq()
{
    return FALSE;
}


BOOL DISPATCHER::OnActivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDeactivation( const ACTIVATION_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnResize( const SIZE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnMove( const MOVE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       DISPATCHER::OnCloseReq

    SYNOPSIS:   Called upon a request to close the window

    RETURNS:    FALSE

    NOTES:      This default implementation does nothing.

    HISTORY:
        beng        09-May-1991     Created
        beng        14-May-1991     Renamed (from "MayClose")

********************************************************************/

BOOL DISPATCHER::OnCloseReq()
{
    return FALSE;
}


/*******************************************************************

    NAME:       DISPATCHER::OnDestroy

    SYNOPSIS:   Called upon an *external* DestroyWindow.
                (Internal DestroyWindow calls created by the
                destructor will never cross this callback.)

    NOTES:
        This is not a dependable callback; please do not use it.

    HISTORY:
        beng        10-May-1991 Implemented
        terryk      25-Jul-1991 Add OnDragBegin, OnDragEnd, OnDragMove

********************************************************************/

BOOL DISPATCHER::OnDestroy()
{
    return FALSE;
}


BOOL DISPATCHER::OnKeyDown( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnKeyUp( const VKEY_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnChar( const CHAR_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnMouseMove( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnLMouseButtonDown( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnLMouseButtonUp( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnLMouseButtonDblClick( const MOUSE_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnFocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDefocus( const FOCUS_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnTimer( const TIMER_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnCommand( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


#if 0 // Never really implemented
BOOL DISPATCHER::OnClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDblClick( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnChange( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnSelect( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnEnter( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnDropDown( const CONTROL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}
#endif


#if 0 // disabled - no clients
BOOL DISPATCHER::OnScrollBar( const SCROLL_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


BOOL DISPATCHER::OnScrollBarThumb( const SCROLL_THUMB_EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}
#endif


/*********************************************************************

    NAME:       DISPATCHER::OnQDlgCode

    SYNOPSIS:   Return the dialog messages-needed code for custom ctrls

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        15-May-1992 Created

*********************************************************************/

ULONG DISPATCHER::OnQDlgCode()
{
    // Default implementation - do whatever default proc says
    return 0;
}


/*********************************************************************

    NAME:       DISPATCHER::OnQHitTest

    SYNOPSIS:   Return the hit-test code

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        18-May-1992 Created

*********************************************************************/

ULONG DISPATCHER::OnQHitTest( const XYPOINT & xy )
{
    UNREFERENCED(xy);

    // Default implementation - do whatever default proc says.

    // Here the custom control dispatcher design fails me, since
    // 0 has a meaning of its own.

    return HT_DO_DEFAULT;
}


/*********************************************************************

    NAME:       DISPATCHER::OnQMouseActivate

    SYNOPSIS:   Return whether a mouseclick will activate a control

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        18-May-1992 Created

*********************************************************************/

ULONG DISPATCHER::OnQMouseActivate( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    // Default implementation - do whatever default proc says
    return 0;
}


/*********************************************************************

    NAME:       DISPATCHER::OnQMouseCursor

    SYNOPSIS:   Give the window a chance to change the cursor

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        21-May-1992 Created

*********************************************************************/

BOOL DISPATCHER::OnQMouseCursor( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    // Default implementation - do whatever default proc says
    return FALSE;
}


/*******************************************************************

    NAME:       DISPATCHER::CaptureMouse

    SYNOPSIS:   Capture mouse input

    ENTRY:      Window may or may not have the mouse

    EXIT:       Window has the mouse

    NOTES:
        Should this function return the previous owner?  The API
        does provide that.

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID DISPATCHER::CaptureMouse()
{
    ::SetCapture(QueryHwnd());
}


/*******************************************************************

    NAME:       DISPATCHER::ReleaseMouse

    SYNOPSIS:   Release mouse input after a CaptureMouse

    ENTRY:      Window has the mouse

    EXIT:       Window no longer has the mouse

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

VOID DISPATCHER::ReleaseMouse()
{
    ::ReleaseCapture();
}


/*******************************************************************

    NAME:       DISPATCHER::QueryRobustHwnd

    SYNOPSIS:   Returns a Hwnd for MsgPopup's parent

    RETURNS:    Dependable HWND

    NOTES:

    HISTORY:
        beng        10-May-1991     Implemented

********************************************************************/

HWND DISPATCHER::QueryRobustHwnd() const
{
    return QueryHwnd();
}


/*********************************************************************

    NAME:       DISPATCHER::QueryHwnd

    SYNOPSIS:   return the associated CONTROL_WINDOW window handler

    RETURN:     HWND - the associated window handler

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

HWND DISPATCHER::QueryHwnd() const
{
    return _pwnd->QueryHwnd();
}


/*********************************************************************

    NAME:       DISPATCHER::DoChar

    SYNOPSIS:   Call the OnChar method

    ENTRY:      CHAR_EVENT event - character event

    RETURN:     BOOL - return whether the subroutine has handled the
                       message or not.

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL DISPATCHER::DoChar( const CHAR_EVENT & event )
{
    return OnChar( event );
}


/*********************************************************************

    NAME:       DISPATCHER::DoUserMessage

    SYNOPSIS:   Call the OnUserMessage method

    ENTRY:      EVENT event - general event

    RETURN:     BOOL - return whether the subroutine has handled the
                       message or not

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL DISPATCHER::DoUserMessage( const EVENT & event )
{
    return OnUserMessage( event );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltbutn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbutn.cxx
    BLT button control class implementations

    FILE HISTORY:
        beng        17-Sep-1991 Separated from bltctrl.cxx

*/

#include "pchblt.hxx"

/*
 * Winclass name for all Windows button controls.
 */
static const TCHAR *const _szClassName = SZ("button");


/**********************************************************************

    NAME:       BUTTON_CONTROL::BUTTON_CONTROL

    SYNOPSIS:   constructor class for the button control class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        17-Sep-1991 Moved classname def'n into implementation

*********************************************************************/

BUTTON_CONTROL::BUTTON_CONTROL( OWNER_WINDOW * powin, CID cid )
    : CONTROL_WINDOW( powin, cid )
{
    //  nothing to do
}

BUTTON_CONTROL::BUTTON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle )
    : CONTROL_WINDOW( powin, cid, xy, dxy, flStyle, _szClassName )
{
    //  nothing to do
}


/*******************************************************************

    NAME:       BUTTON_CONTROL::QueryEventEffects

    SYNOPSIS:   Virtual replacement for CONTROL_VALUE class

    ENTRY:

    EXIT:

    NOTES:      We currently consider all messages a value change message.

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        31-Jul-1991 Renamed, from QMessageInfo
        beng        04-Oct-1991 Win32 conversion
        KeithMo     27-Oct-1992 Relocated here from STATE_BUTTON_CONTROL.

********************************************************************/

UINT BUTTON_CONTROL::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch ( e.QueryCode() )
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        return CVMI_VALUE_CHANGE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/**********************************************************************

    NAME:       PUSH_BUTTON::PUSH_BUTTON

    SYNOPSIS:   constructor for the push button class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        17-Sep-1991 Removed redundant classname arg

*********************************************************************/

PUSH_BUTTON::PUSH_BUTTON( OWNER_WINDOW * powin, CID cid )
    : BUTTON_CONTROL( powin, cid )
{
    //  nothing to do
}


PUSH_BUTTON::PUSH_BUTTON(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle )
    : BUTTON_CONTROL( powin, cid, xy, dxy, flStyle )
{
    //  nothing to do
}


/**********************************************************************

   NAME:       PUSH_BUTTON::MakeDefault

   SYNOPSIS:   send a DM_DEFAULT message to the window

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

VOID PUSH_BUTTON::MakeDefault()
{
    UIASSERT( QueryOwnerHwnd() != NULL );
    //
    //	Before we can set the new default button style, we have to
    //	remove the default button style from the old default button
    //

    LRESULT lr = ::SendMessage( QueryOwnerHwnd(), DM_GETDEFID, 0, 0 ) ;
    if ( HIWORD( lr ) == DC_HASDEFID )
    {
        INT idCurrentDefault = LOWORD( lr );
        // check if this button is already default
        if ( idCurrentDefault == (INT)QueryCid() )
        {
            return;
        }

	HWND hwndOldDefButton = ::GetDlgItem( QueryOwnerHwnd(),
					      idCurrentDefault ) ;
	UIASSERT( hwndOldDefButton != NULL ) ;

#ifdef DEBUG
	LONG lStyle = ::GetWindowLong( hwndOldDefButton, GWL_STYLE ) ;

	//
	//  The button window styles are not bitmasks and the high word of
	//  the long comes back with other style info.	Since all of the button
	//  styles we are interested in are less then 15, we will just lop off
	//  the upper 28 bits.
	//
	UIASSERT( BS_PUSHBUTTON <= 0xf && BS_DEFPUSHBUTTON <= 0xf ) ;
	UIASSERT( ((lStyle & 0xf) == BS_PUSHBUTTON) ||
		  ((lStyle & 0xf) == BS_DEFPUSHBUTTON) ) ;
#endif //DEBUG

	::SendMessage( hwndOldDefButton,
		       BM_SETSTYLE,
		       MAKEWPARAM( BS_PUSHBUTTON, 0 ),
		       MAKELPARAM( TRUE, 0 )) ;
    }

    ::SendMessage( QueryOwnerHwnd(), DM_SETDEFID, QueryCid(), 0L );
    Command( BM_SETSTYLE,
	     MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
	     MAKELPARAM( TRUE, 0 )) ;
}


/*********************************************************************

    NAME:       STATE_BUTTON_CONTROL::STATE_BUTTON_CONTROL

    SYNOPSIS:   Constructor for the state button control baseclass

    ENTRY:

    EXIT:

    NOTES:
        The state button control coordinates the different sorts of
        state buttons: radio, check, tristate.  It corresponds to no
        particular control, and cannot be instantiated by itself.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        17-Sep-1991 Removed redundant classname arg
        beng        18-Sep-1991 Made "state" n-way

*********************************************************************/

STATE_BUTTON_CONTROL::STATE_BUTTON_CONTROL( OWNER_WINDOW * powin, CID cid )
    : BUTTON_CONTROL( powin, cid ),
      _nSaveCheck( 0 )
{
    // nothing to do
}

STATE_BUTTON_CONTROL::STATE_BUTTON_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle )
    : BUTTON_CONTROL( powin, cid, xy, dxy, flStyle ),
      _nSaveCheck( 0 )
{
    // nothing to do
}


/**********************************************************************

    NAME:       STATE_BUTTON_CONTROL::SetState

    SYNOPSIS:   Checks or unchecks a state button control.

    ENTRY:      nValue  Indicates whether the button should be checked or
                        unchecked.  TRUE indicates to check, whereas FALSE
                        indicates uncheck.  ("2" puts a tristate into
                        the indeterminate state.)

    HISTORY:
        rustanl     20-Nov-1990 Created, as SetCheck
        beng        18-Sep-1991 Made state n-way for tristates

*********************************************************************/

VOID STATE_BUTTON_CONTROL::SetState( UINT nValue )
{
    Command( BM_SETCHECK, nValue );
}


/*********************************************************************

    NAME:       STATE_BUTTON_CONTROL::QueryState

    SYNOPSIS:   Returns state of a state button.

    RETURN:     TRUE if the button is checked; FALSE otherwise.
                ("2" if tristate is indeterminate.)

    HISTORY:
        rustanl     20-Nov-1990 Created, as QueryCheck
        beng        18-Sep-1991 Made state n-way for tristates

*********************************************************************/

UINT STATE_BUTTON_CONTROL::QueryState() const
{
    return ( (UINT)Command( BM_GETCHECK ) );
}


/*******************************************************************

    NAME:     STATE_BUTTON_CONTROL::SaveValue

    SYNOPSIS: Saves the state of this button and unselects it

    EXIT:     Unselected button

    NOTES:
        Is 0 a suitable at-rest value for a tristate?

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        18-Sep-1991 Made state n-way for tristates

********************************************************************/

VOID STATE_BUTTON_CONTROL::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    _nSaveCheck = QueryState();
    SetState( 0 );
}


/*******************************************************************

    NAME:       STATE_BUTTON_CONTROL::RestoreValue

    SYNOPSIS:   Restores STATE_BUTTON_CONTROL after SaveValue

    NOTES:      See CONTROL_VALUE for more details.

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        18-Sep-1991 Made state n-way for tristates

********************************************************************/

VOID STATE_BUTTON_CONTROL::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    SetState( _nSaveCheck );
}


/**********************************************************************

    NAME:       CHECKBOX::Toggle

    SYNOPSIS:   The method toggles the checked state of the checkbox.

    ENTRY:

    RETURN:     The new value of the checkbox

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created

*********************************************************************/

BOOL CHECKBOX::Toggle()
{
    BOOL fNewState = ! QueryCheck();
    SetCheck( fNewState );

    return fNewState;
}


/*******************************************************************

    NAME:       TRISTATE::EnableThirdState

    SYNOPSIS:   Enable or disable a tristate's ability to go grey

    ENTRY:      fEnable - FALSE to disable, TRUE to enable

    EXIT:

    NOTES:
        This method attempts to retain the AUTO status of the checkbox.

    HISTORY:
        beng        19-Sep-1991 Created
        beng        13-Feb-1992 Use QueryStyle, new SetStyle

********************************************************************/

VOID TRISTATE::EnableThirdState( BOOL fEnable )
{
    ULONG lfValue = QueryStyle();

    BOOL fAuto = !!(lfValue & (BS_AUTO3STATE|BS_AUTOCHECKBOX));

    lfValue &= ~(0xF);

    if (fEnable)
    {
        lfValue |= (fAuto ? BS_AUTO3STATE : BS_3STATE);
    }
    else
    {
        lfValue |= (fAuto ? BS_AUTOCHECKBOX : BS_CHECKBOX);
    }

    SetStyle(lfValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltdlgxp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltdlgxp.cxx

    Expandable dialog class implementation.

    This class represents a standard BLT DIALOG_WINDOW which can
    be expanded once to reveal new controls.  All other operations
    are common between EXPANDABLE_DIALOG and DIALOG_WINDOW.

    To construct, provide the control ID of two controls: a "boundary"
    static text control (SLT) and an "expand" button.

    See BLTDLGXP.HXX for more details.

    FILE HISTORY:
        DavidHov      11/1/91      Created

*/
#include "pchblt.hxx"

/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::EXPANDABLE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      CID cidBoundary        the control ID of the "boundary"
                                        control
                CID cidExpandButn      the control ID of the "expand"
                                        button
                INT cPxBoundary        size in dlg units to use a minimum
                                        distance from border required
                                        to force use of new border

    EXIT:       normal for subclasses of BASE

    RETURNS:    nothing

    NOTES:

    HISTORY:
                DavidHov    11/1/91    Created

********************************************************************/

EXPANDABLE_DIALOG::EXPANDABLE_DIALOG
   ( const TCHAR * pszResourceName, HWND hwndOwner,
     CID cidBoundary, CID cidExpandButn, INT cPxBoundary )
    : DIALOG_WINDOW ( pszResourceName, hwndOwner ),
    _sltBoundary( this, cidBoundary ),
    _butnExpand( this, cidExpandButn ),
    _xyOriginal( 0, 0 ),
    _cPxBoundary( cPxBoundary ),
    _fExpanded( FALSE )
{
    // nothing else
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::EXPANDABLE_DIALOG

    SYNOPSIS:   destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      does nothing.

    HISTORY:

********************************************************************/
EXPANDABLE_DIALOG::~ EXPANDABLE_DIALOG ()
{
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::ShowArea()

    SYNOPSIS:   Grows or shrinks the dialog based upon the BOOL
                parameter and the location of the boundary control.

    ENTRY:      BOOL fFull              if TRUE, expand the dialog;
                                        otherwise, show default size.

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      Calls virtual OnExpand() member when it is about to
                exposed the previously hidden controls.

    HISTORY:

********************************************************************/

VOID EXPANDABLE_DIALOG::ShowArea ( BOOL fFull )
{
    //  If this is the first call, save the size of the dialog

    if ( _xyOriginal.QueryHeight() <= 0 )
    {
        _xyOriginal = QuerySize() ;

        //  Hide and disable the boundary control
        _sltBoundary.Show( FALSE ) ;
        _sltBoundary.Enable( FALSE ) ;
    }

    //  Iterate over child controls; dis/enable child controls in
    //  the expanded region to preserve tab ordering, etc.

    ITER_CTRL itCtrl( this ) ;
    CONTROL_WINDOW * pcw ;
    XYPOINT xyBoundary( _sltBoundary.QueryPos() ) ;

    for ( ; pcw = itCtrl() ; )
    {
        if ( pcw != & _sltBoundary )
        {
            XYPOINT xyControl( pcw->QueryPos() ) ;
            if (   xyControl.QueryX() >= xyBoundary.QueryX()
                || xyControl.QueryY() >= xyBoundary.QueryY() )
            {
                pcw->Enable( fFull ) ;
            }
        }
    }

    if ( ! fFull )  // Initial display; show only the default area
    {
		// NTRAID#NTBUG9-574280-2002/03/08-artm  Prefast: redeclaration of xyBoundary
		// This class is not used anywhere and can be removed.
        XYPOINT xyBoundary = _sltBoundary.QueryPos() ;
        XYDIMENSION dimBoundary = _sltBoundary.QuerySize();
        XYRECT rWindow ;

        //  Compute location of the lower right-hand edge of the boundary
        //  control relative to the full (i.e., not client) window.

        xyBoundary.SetX( xyBoundary.QueryX() + dimBoundary.QueryWidth() ) ;
        xyBoundary.SetY( xyBoundary.QueryY() + dimBoundary.QueryHeight() ) ;
        xyBoundary.ClientToScreen( QueryHwnd() ) ;
        QueryWindowRect( & rWindow ) ;
        xyBoundary.SetX( xyBoundary.QueryX() - rWindow.QueryLeft() ) ;
        xyBoundary.SetY( xyBoundary.QueryY() - rWindow.QueryTop() ) ;

        //  Check if the boundary control is "close" to the edge of the
        //  dialog in either dimension.  If so, use the original value.

        if ( (INT)(_xyOriginal.QueryHeight() - xyBoundary.QueryY()) <= _cPxBoundary )
            xyBoundary.SetY( _xyOriginal.QueryHeight() ) ;

        if ( (INT)(_xyOriginal.QueryWidth() - xyBoundary.QueryX()) <= _cPxBoundary )
            xyBoundary.SetX( _xyOriginal.QueryWidth() ) ;

        //  Change the dialog size.
        SetSize( xyBoundary.QueryX(), xyBoundary.QueryY(), TRUE ) ;
    }
    else            //  Full display; expand the dialog to original size
    {
        _fExpanded = TRUE ;

        //  Allow the owner to alter controls uncovered by the change
        OnExpand();

        //  Disable the one-way expand button
        _butnExpand.Enable( FALSE ) ;

        //  Set size to original full extent
        SetSize( _xyOriginal.QueryWidth(), _xyOriginal.QueryHeight(), TRUE ) ;
    }
}

    //  Reduce the size of the dialog based upon the boundary control
    //  and call the inherited 'Process' member.

/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      UINT * pnRetVal         return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR EXPANDABLE_DIALOG::Process ( UINT * pnRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pnRetVal ) ;
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      BOOL * pfRetVal         BOOL return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR EXPANDABLE_DIALOG::Process ( BOOL * pfRetVal )
{
    ShowArea( FALSE );
    return DIALOG_WINDOW::Process( pfRetVal ) ;
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::OnExpand

    SYNOPSIS:   Virtual callout from ShowArea() when dialog is
                about to be expanded.  Overriding routines should
                be sure to set focus on an appropriate control.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      none

    HISTORY:

********************************************************************/

VOID EXPANDABLE_DIALOG::OnExpand ()
{
    SetFocus( IDOK ) ;
}


/*******************************************************************

    NAME:       EXPANDABLE_DIALOG::OnCommand

    SYNOPSIS:   Override for DIALOG_WINDOW::OnCommand() that watches
                for activation of the "expand" button.

    ENTRY:      const CONTROL_EVENT & event

    EXIT:       TRUE if expand button was clicked.

    RETURNS:    BOOL return value from DIALOG_WINDOW::OnCommand()

    NOTES:      none

    HISTORY:

********************************************************************/

BOOL EXPANDABLE_DIALOG::OnCommand ( const CONTROL_EVENT & event )
{
    BOOL fResult ;

    if ( event.QueryCid() == _butnExpand.QueryCid() )
    {
        if ( ! _fExpanded )
            ShowArea( TRUE ) ;

        fResult = TRUE ;
    }
    else
    {
        fResult =  DIALOG_WINDOW::OnCommand( event ) ;
    }
    return fResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltfont.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltfont.cxx
    This file contains the implementation for the BLT FONT class.


    FILE HISTORY:
        Johnl       03-Apr-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      26-Nov-1991     Added FIX_PITCH font
        terryk      02-Dec-1991     Changed FIX_PITCH font from FF_SWISS
                                    to FF_MODERN
        terryk      20-Feb-1992     Added Courier as the default fixed
                                    font

*/

#include "pchblt.hxx"
#include "bltrc.h" // IDS_FIXED_TYPEFACE_NAME

// Local manifests

#define DEFAULT_TYPEFACE_SIZE       8
#define DEFAULT_PITCHFAMILY         VARIABLE_PITCH | FF_SWISS
#define DEFAULT_WEIGHT              FW_NORMAL

#define DEFAULT_TYPEFACE_NAME       SZ("MS Shell Dlg")
#define DEFAULT_FIXED_TYPEFACE_NAME SZ("Courier")
#define DEFAULT_FIXED_PITCHFAMILY   FIXED_PITCH | FF_MODERN

/*******************************************************************

    NAME:     FONT::FONT

    SYNOPSIS: FONT class constructor.  The constructor does all the
              hard work of building the LOGFONT structure then calls
              SetFont( LOGFONT ).

    ENTRY:    A valid FontType enumeration

    EXIT:     The handle is initialized to the created font or a ReportError
              is called.

    NOTES:

    HISTORY:
        Johnl       03-Apr-1991 Created
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

FONT::FONT( enum FontType Font )
{
    _hFont = NULL;

    LOGFONT logfont;

    /* We take the negative of the point size because we want the point
     * value to indicate the total ascent as opposed to a total height.
     */
#ifdef FE_SB // FONT::FONT() not need ifdef block. just for mark.
    if ( NETUI_IsDBCS() )
    {
        // We use 9pt as system default. 8pt is a little small and dirty...
        logfont.lfHeight       = -BLTPoints2LogUnits(DEFAULT_TYPEFACE_SIZE+1);
    } else
#endif
    logfont.lfHeight           = -BLTPoints2LogUnits(DEFAULT_TYPEFACE_SIZE);
    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    {
        DWORD cp = ::GetACP();
        CHARSETINFO csi;
#ifdef FE_SB // Bug fix....
        if (::TranslateCharsetInfo((DWORD *)UIntToPtr(cp), &csi, TCI_SRCCODEPAGE))
#else
        if (::TranslateCharsetInfo(&cp, &csi, TCI_SRCCODEPAGE))
#endif // FE_SB
            logfont.lfCharSet = (UCHAR)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }
    logfont.lfOutPrecision     = (UCHAR)OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = (UCHAR)(( Font == FONT_DEFAULT_FIXED_PITCH )
       ? DEFAULT_FIXED_PITCHFAMILY : DEFAULT_PITCHFAMILY);

    if ( NETUI_IsDBCS() )
    {
        if ( Font == FONT_DEFAULT_FIXED_PITCH )
        {
            // Use localized facename instead of hardcoded one.
            NLS_STR *nlsFixedTypefaceName = new NLS_STR;
            nlsFixedTypefaceName->Load((MSGID)IDS_FIXED_TYPEFACE_NAME);
            ::strcpyf( (TCHAR *)logfont.lfFaceName, nlsFixedTypefaceName->QueryPch() );
            delete nlsFixedTypefaceName;
        }
        else
        {
            ::strcpyf( (TCHAR *)logfont.lfFaceName, DEFAULT_TYPEFACE_NAME );
        }
    }
    else
    {
        ::strcpyf( (TCHAR *)logfont.lfFaceName,( Font == FONT_DEFAULT_FIXED_PITCH )?
            DEFAULT_FIXED_TYPEFACE_NAME:DEFAULT_TYPEFACE_NAME );
    }

    logfont.lfUnderline        = 0;
    logfont.lfStrikeOut        = 0;
    logfont.lfItalic           = ( Font == FONT_DEFAULT_ITALIC ||
                                   Font == FONT_DEFAULT_BOLD_ITALIC
                                   ? 1 : 0
                                 );
    logfont.lfWeight           = ( Font == FONT_DEFAULT_BOLD   ||
                                   Font == FONT_DEFAULT_BOLD_ITALIC
                                   ? FW_BOLD : DEFAULT_WEIGHT
                                 );

    APIERR err = SetFont(logfont);
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:     FONT::FONT

    SYNOPSIS: FONT class constructor.  This constructor takes a LOGFONT
              and passes it through to the SetFont method.


    ENTRY:    A valid, initialized LOGFONT structure.

    EXIT:     The handle is initialized to the created font or a ReportError
              is called.

    NOTES:

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        05-Oct-1991 Win32 conversion

********************************************************************/

FONT::FONT( const LOGFONT & logfont )
{
    _hFont = NULL;

    APIERR err = SetFont(logfont);
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:     FONT::FONT

    SYNOPSIS: FONT class constructor.  This constructor takes some of the
              common attributes a person might want to apply to a font
              and builds a LOGFONT structure.  It then calls SetFont
              with the initialized LOGFONT structure.


    ENTRY:    pchFaceName is a pointer to a type face name ("Helv" etc.)
              lfPitchAndFamily is the same as in the LOGFONT structure
              nPointSize is the size of the font in points
              fontatt is one or a combination of the FontAttributes enum.

    EXIT:     The handle is initialized to the created font or ReportError
              is called.

    NOTES:

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

FONT::FONT( const TCHAR * pchFaceName, BYTE lfPitchAndFamily,
            INT nPointSize, enum FontAttributes fontatt )
{
    WORD wFontAtt = (WORD) fontatt;

    /* The font attributes must be the default attributes or some
     * combination of the other attributes.
     */
    UIASSERT( wFontAtt == FONT_ATT_DEFAULT   ||
               (
                 wFontAtt & FONT_ATT_ITALIC    ||
                 wFontAtt & FONT_ATT_BOLD      ||
                 wFontAtt & FONT_ATT_UNDERLINE ||
                 wFontAtt & FONT_ATT_STRIKEOUT
               )
            );

    _hFont = NULL;

    LOGFONT logfont;

    logfont.lfHeight           = -BLTPoints2LogUnits( nPointSize );
    logfont.lfWidth            = 0;
    logfont.lfEscapement       = 0;
    logfont.lfOrientation      = 0;
    {
        DWORD cp = GetACP();
        CHARSETINFO csi;
#ifdef FE_SB // FONT::FONT() Bug fix...
        if (::TranslateCharsetInfo((DWORD *)UIntToPtr(cp), &csi, TCI_SRCCODEPAGE))
#else
        if (::TranslateCharsetInfo(&cp, &csi, TCI_SRCCODEPAGE))
#endif // FE_SB
            logfont.lfCharSet = (UCHAR)csi.ciCharset;
        else
            logfont.lfCharSet = ANSI_CHARSET;
    }
    logfont.lfOutPrecision     = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision    = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality          = DEFAULT_QUALITY;
    logfont.lfPitchAndFamily   = lfPitchAndFamily;
    ::strcpyf( (TCHAR *)logfont.lfFaceName, pchFaceName );

    logfont.lfUnderline        = wFontAtt & FONT_ATT_UNDERLINE;
    logfont.lfStrikeOut        = wFontAtt & FONT_ATT_STRIKEOUT;
    logfont.lfItalic           = wFontAtt & FONT_ATT_ITALIC;
    logfont.lfWeight           = (wFontAtt & FONT_ATT_BOLD ? FW_BOLD : FW_NORMAL );

    APIERR err = SetFont(logfont);
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:     FONT::~FONT

    SYNOPSIS: FONT class destructor, destroys the font if it was successfully
              created

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   03-Apr-1991     Created

********************************************************************/

FONT::~FONT()
{
    if ( _hFont != NULL )
        ::DeleteObject( (HGDIOBJ)_hFont );
}


/*******************************************************************

    NAME:     FONT::SetFont

    SYNOPSIS: Creates a font based on the passed LOGFONT structure.

    ENTRY:    logfont is an initialized LOGFONT structure.

    EXIT:     _hFont is initialized to the newly created font and TRUE
              is returned, else an error occurred and FALSE is returned.
              If FALSE is returned, the previous Font will still be
              active.

    RETURNS:  NERR_Success if successful

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        05-Oct-1991 Returns APIERR
        beng        06-Nov-1991 Uses MapLastError

********************************************************************/

APIERR FONT::SetFont( const LOGFONT & logfont )
{
    HFONT hFontNew = ::CreateFontIndirect( (LOGFONT *)&logfont );
    if ( hFontNew == NULL )
    {
        return BLT::MapLastError(ERROR_GEN_FAILURE);
    }

    if ( _hFont != NULL )
        ::DeleteObject( (HGDIOBJ)_hFont );

    _hFont = hFontNew;

    return NERR_Success;
}


/*******************************************************************

    NAME:       FONT::SetFont

    SYNOPSIS:   Sets the font handle to the passed HFONT

    ENTRY:      HFONT should be a valid font handle or NULL.

    EXIT:

    RETURNS:    NERR_Success, always

    NOTES:

    HISTORY:
        Johnl       05-Apr-1991 Created
        beng        05-Oct-1991 Returns APIERR for consistency

********************************************************************/

APIERR FONT::SetFont( HFONT hNewFont )
{
    _hFont = hNewFont;
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltedit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltedit.cxx
    BLT text control class implementations

    FILE HISTORY:
        beng        17-Sep-1991 Separated from bltctrl.cxx
        thomaspa    13-Feb-1992 Moved validate from SLE to ICANON_SLE
        KeithMo     27-Aug-1992 Added CONTROL_VALUE methods to SLT.

*/
#include "pchblt.hxx"


/**********************************************************************

    NAME:       TEXT_CONTROL::TEXT_CONTROL

    SYNOPSIS:   constructor for the text control class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

TEXT_CONTROL::TEXT_CONTROL( OWNER_WINDOW * powin, CID cid )
    : CONTROL_WINDOW ( powin, cid )
{
    // nothing to do
}

TEXT_CONTROL::TEXT_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : CONTROL_WINDOW( powin, cid, xy, dxy, flStyle, pszClassName )
{
    // ...
}


/**********************************************************************

    NAME:       STATIC_TEXT_CONTROL::STATIC_TEXT_CONTROL

    SYNOPSIS:   constructor for the static ext control class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

***********************************************************************/

STATIC_TEXT_CONTROL::STATIC_TEXT_CONTROL( OWNER_WINDOW * powin, CID cid )
    : TEXT_CONTROL( powin, cid )
{
    // nothing to do
}

STATIC_TEXT_CONTROL::STATIC_TEXT_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName )
{
    // ...
}


/**********************************************************************

    NAME:       SLT::SLT

    SYNOPSIS:   constructor for the SLE (single line text) class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

SLT::SLT( OWNER_WINDOW * powin, CID cid )
    : STATIC_TEXT_CONTROL( powin, cid ),
      _fSavedEnableState( TRUE )
{
    // nothing to do
}

SLT::SLT(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : STATIC_TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName ),
      _fSavedEnableState( TRUE )
{
    // ...
}


/*******************************************************************

    NAME:       SLT::SaveValue

    SYNOPSIS:   Saves the "enable" state of this control and optionally
                disables the control.  See CONTROL_VALUE for details.

    EXIT:       _nlsSaveValue now contains the EDIT_CONTROL text
                and the EDIT_CONTROL should be empty.

    HISTORY:
        KeithMo     27-Aug-1992     Created from EDIT_CONTROL::SaveValue.

********************************************************************/

VOID SLT::SaveValue( BOOL fInvisible )
{
    _fSavedEnableState = IsEnabled();

    if( fInvisible )
    {
        Enable( FALSE );
    }
}


/*******************************************************************

    NAME:     SLT::RestoreValue

    SYNOPSIS: Restores the "enable" state after being saved with SaveValue.

    HISTORY:
        KeithMo     27-Aug-1992     Created from EDIT_CONTROL::RestoreValue.

********************************************************************/

VOID SLT::RestoreValue( BOOL fInvisible )
{
    if( fInvisible )
    {
        Enable( _fSavedEnableState );
    }

#if 1
    //
    //  CODEWORK:
    //
    //  This should be accomplished by overriding the SetTabStop()
    //  virtual!
    //

    SetTabStop( FALSE );
#endif
}


/**********************************************************************

    NAME:       MLT::MLT

    SYNOPSIS:   constructor for the MLT (multi-line text) class

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

MLT::MLT( OWNER_WINDOW * powin, CID cid )
    : STATIC_TEXT_CONTROL( powin, cid )
{
    // nothing to do
}

MLT::MLT(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : STATIC_TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName )
{
    // ...
}


/**********************************************************************

    NAME:       EDIT_CONTROL::EDIT_CONTROL

    SYNOPSIS:   constructor for the edit control class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        31-Jul-1991 Error reporting changed
        beng        04-Oct-1991 Win32 conversion
        KeithMo     11-Sep-1992 Forcibly remove ES_OEMCONVERT under UNICODE.
        KeithMo     07-Feb-1993 Don't remove ES_OEMCONVERT.

**********************************************************************/

EDIT_CONTROL::EDIT_CONTROL( OWNER_WINDOW * powin, CID cid, UINT cchMax )
    : TEXT_CONTROL( powin, cid ),
      _nlsSaveValue( (TCHAR *) NULL )   // Initialize to empty string

{
    if (QueryError())
        return;

    if (_nlsSaveValue.QueryError())
    {
        ReportError(_nlsSaveValue.QueryError());
        return;
    }

    if ( cchMax > 0 )
        SetMaxLength( cchMax );
}


EDIT_CONTROL::EDIT_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : TEXT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName ),
      _nlsSaveValue( (TCHAR *) NULL )   // Initialize to empty string
{
    if (QueryError())
        return;

    if (_nlsSaveValue.QueryError())
    {
        ReportError(_nlsSaveValue.QueryError());
        return;
    }

    if ( cchMax > 0 )
        SetMaxLength( cchMax );
}


/**********************************************************************

    NAME:       EDIT_CONTROL::SetMaxLength

    SYNOPSIS:   Set the max length for the edit control

    NOTES:
        The EM_LIMITTEXT message talks bytes, whereas we want
        to talk TCHAR.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        19-Jun-1991 Honor Unicode characters
        beng        24-Jun-1992 Win takes TCHARs, not BYTES

**********************************************************************/

VOID EDIT_CONTROL::SetMaxLength( UINT cchMax )
{
    Command( EM_LIMITTEXT, cchMax );
}


/*********************************************************************

    NAME:       EDIT_CONTROL::SelectString

    SYNOPSIS:   This method selects the entire string contained in the edit
                control.

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        19-Jun-1991     Added code for Win32

*********************************************************************/

VOID EDIT_CONTROL::SelectString()
{
#if defined(WIN32)
    Command( EM_SETSEL, 0, (LPARAM)(-1) );
#else
    Command( EM_SETSEL, 0, MAKELONG( 0, 0x7fff ));
#endif
}


/*******************************************************************

    NAME:       EDIT_CONTROL::SaveValue

    SYNOPSIS:   Stores the contents of this EDIT_CONTROL and empties the
                EDIT_CONTROL (see CONTROL_VALUE for more details).

    EXIT:       _nlsSaveValue now contains the EDIT_CONTROL text
                and the EDIT_CONTROL should be empty.

    HISTORY:
        Johnl       25-Apr-1991     Created

********************************************************************/

VOID EDIT_CONTROL::SaveValue( BOOL fInvisible )
{
    QueryText( &_nlsSaveValue );
    if ( _nlsSaveValue.QueryError() )
    {
        _nlsSaveValue = NULL;
    }
    else
    {
        if ( fInvisible )
            ClearText();
    }
}


/*******************************************************************

    NAME:     EDIT_CONTROL::RestoreValue

    SYNOPSIS: Restores the text after being saved with SaveValue

    ENTRY:

    EXIT:     The text is restored and selected.

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl       25-Apr-1991     Created

********************************************************************/

VOID EDIT_CONTROL::RestoreValue( BOOL fInvisible )
{
    if ( _nlsSaveValue.QueryError() == NERR_Success )
    {
        if ( fInvisible )
            SetText( _nlsSaveValue );
        SelectString();
    }

    _nlsSaveValue = NULL;
}


/*******************************************************************

    NAME:       EDIT_CONTROL::QueryEventEffects

    SYNOPSIS:   Virtual replacement for CONTROL_VALUE class

    NOTES:      We currently only consider EN_CHANGE a value change message.

    HISTORY:
        Johnl       25-Apr-1991 Created
        beng        31-Jul-1991 Renamed from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT EDIT_CONTROL::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch ( e.QueryCode() )
    {
    case EN_CHANGE:
        return CVMI_VALUE_CHANGE;

    case EN_SETFOCUS:
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/*******************************************************************

    NAME:     EDIT_CONTROL::SetControlValueFocus

    SYNOPSIS: Sets the focus to this edit control
              (see CONTROL_VALUE for more details).

    EXIT:     The focus should be set to this edit control and the text
              should be selected.

    NOTES:

    HISTORY:
        Johnl       03-May-1991     Created

********************************************************************/

VOID EDIT_CONTROL::SetControlValueFocus()
{
    CONTROL_WINDOW::SetControlValueFocus();
    SelectString();
}


/*********************************************************************

    NAME:       SLE::SLE

    SYNOPSIS:   constructor for the single line edit class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        04-Oct-1991 Win32 conversion
        thomaspa    21-Jan-1992 Added validation

*********************************************************************/

SLE::SLE( OWNER_WINDOW * powin, CID cid, UINT cchMax )
    : EDIT_CONTROL( powin, cid, cchMax )

{
    // Nothing to do
}

SLE::SLE(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName, cchMax )
{
    // Nothing to do
}


/*******************************************************************

    NAME:       SLE::IndicateError

    SYNOPSIS:   Indicate that the contents are invalid

    ENTRY:      Contents were found invalid

    EXIT:       Error indicated

    NOTES:
        A SLE indicates an error by selecting the erronous data
        (assumed here to be all of the string).

    HISTORY:
        beng        01-Nov-1991 Created

********************************************************************/

VOID SLE::IndicateError( APIERR err )
{
    EDIT_CONTROL::IndicateError(err);
    SelectString();
}



/*********************************************************************

    NAME:       MLE::MLE

    SYNOPSIS:   constructor for multi-line edit class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

MLE::MLE( OWNER_WINDOW * powin, CID cid, UINT cchMax )
    : EDIT_CONTROL( powin, cid, cchMax )
{
    // nothing to do
}

MLE::MLE(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName, cchMax )
{
    // nothing to do
}


/**********************************************************************

    NAME:       PASSWORD_CONTROL::PASSWORD_CONTROL

    SYNOPSIS:   constructor for password control class

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

PASSWORD_CONTROL::PASSWORD_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, cchMax )
{
    // nothing to do
}

PASSWORD_CONTROL::PASSWORD_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName,
    UINT           cchMax )
    : EDIT_CONTROL( powin, cid, xy, dxy, flStyle, pszClassName, cchMax )
{
    // nothing to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltfunc.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltfunc.cxx
    Contain all the stand alone functions for the blt package.

    BLTDoubleChar( NLS_STR *pnls, TCHAR ch ) - double the given character
                                                in the given nls string

    FILE HISTORY:
	terryk	    3-Apr-1991	    Added BLTDoubleChar()
	terryk	    16-Apr-1991     second code review changed.
				    Attend: johnl jonn rustanl gregj
	beng	    14-May-1991     Exploded blt.hxx into components

*/

#include "pchblt.hxx"

/*********************************************************************

    NAME:	BLTDoubleChar

    SYNOPSIS:	double a special character within the given string

    ENTRY:	NLS_STR *pnlsStr - pointer to the given string
		TCHAR chSpecChar - an escape character

    EXIT:	The procedure will change the *pnlsStr if everything is okay.
		Otherwise, *pnlsStr is unchanged.

    RETURN:	USHORT - return either NERR_Success or API_ERROR

    NOTES:

    HISTORY:
	terryk	    8-Apr-1991	creation
	terryk	    16-Apr-1991 second code review changed
	beng	    04-Oct-1991 Win32 conversion
	beng	    21-Nov-1991 Replace owner-alloc string

**********************************************************************/

APIERR BLTDoubleChar( NLS_STR * pnlsStr, TCHAR chSpecChar )
{
    UIASSERT( pnlsStr != NULL );

    if ( pnlsStr->QueryError() != NERR_Success )
    {
	return pnlsStr->QueryError();
    }

    TCHAR achSpecChar[ 2 ];   // special character + NULL

    achSpecChar[0] = chSpecChar;
    achSpecChar[1] = TCH('\0');

    const ALIAS_STR nlsSpecChar( achSpecChar );

    // We need to keep a copy of the original string in case of error

    NLS_STR nlsOriginalString = *pnlsStr;
    if (!nlsOriginalString)
    {
	return nlsOriginalString.QueryError();
    }

    ISTR istrStartPos( *pnlsStr );
    ISTR istrPosition( *pnlsStr );

    // keep double the special character until we cannot find any more

    while ( pnlsStr->strchr( &istrPosition, chSpecChar, istrStartPos ))
    {
	pnlsStr->InsertStr( nlsSpecChar, istrPosition );
	if (pnlsStr->QueryError() != NERR_Success)
        {
            // Restore the original string

	    *pnlsStr = nlsOriginalString;
	    return pnlsStr->QueryError();
        }

        // skip the double characters
        istrStartPos = istrPosition;
        istrStartPos += 2;
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltgroup.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltgroup.cxx
    This file contains the code to handle the CONTROL_GROUP stuff of BLT.
    The default virtual definitions for CONTROL_VALUE are also here.

    FILE HISTORY:
        Johnl       23-Apr-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      10-Jul-1991     Added CVSaveValue and CVRestoreValue
                                    for CONTROL_GROUP to access the CONTROL_VALUE's
                                    protected member.
        Johnl       17-Sep-1991     Allowed SetSelection on operating magic group

*/

#include "pchblt.hxx"   // Precompiled header

DEFINE_ARRAY_LIST_OF( CONTROLVAL_CID_PAIR )

/*******************************************************************

    NAME:       CONTROL_VALUE::SaveValue

    SYNOPSIS:   See class CONTROL_VALUE

    NOTES:
        This default implementation does nothing.

    HISTORY:
        Johnl   23-Apr-1991     Created

********************************************************************/

VOID CONTROL_VALUE::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    return;
}


/*******************************************************************

    NAME:       CONTROL_VALUE::RestoreValue

    SYNOPSIS:   See class CONTROL_VALUE

    NOTES:
        This default implementation does nothing.

    HISTORY:
        Johnl   23-Apr-1991     Created

********************************************************************/

VOID CONTROL_VALUE::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    return;
}

/*******************************************************************

    NAME:       CONTROL_VALUE::SetTabStop

    SYNOPSIS:   See class CONTROL_VALUE

    NOTES:
        This default implementation does nothing.

    HISTORY:
        Yi-HsinS  29-May-1992   Created

********************************************************************/

VOID CONTROL_VALUE::SetTabStop( BOOL fTabStop )
{
    UNREFERENCED( fTabStop );
    return;
}

/*******************************************************************

    NAME:     CONTROL_VALUE::QueryEventEffects

    SYNOPSIS: This is the default definition for IsValueChangeMessage
              (returns FALSE).  See class CONTROL_VALUE for more
              information.
    ENTRY:

    EXIT:

    HISTORY:
        Johnl       23-Apr-1991 Created
        beng        31-Jul-1991 Renamed, from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT CONTROL_VALUE::QueryEventEffects( const CONTROL_EVENT & e )
{
    UNREFERENCED( e );
    return CVMI_NO_VALUE_CHANGE;
}


/*******************************************************************

    NAME:     CONTROL_VALUE::SetControlValueFocus

    SYNOPSIS: Tells a control value to set the focus to itself

    EXIT:     The control value should now have the focus

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created

********************************************************************/

VOID CONTROL_VALUE::SetControlValueFocus()
{
    return;
}


/*******************************************************************

    NAME:     CONTROL_GROUP::OnUserAction

    SYNOPSIS: Default virtual methods for the CONTROL_GROUP class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

APIERR CONTROL_GROUP::OnUserAction( CONTROL_WINDOW * pcontwin,
                                    const CONTROL_EVENT & e )
{
    UNREFERENCED( pcontwin );
    UNREFERENCED( e );
    return NERR_Success;
}


/*******************************************************************

    NAME:     CONTROL_GROUP::OnGroupAction

    SYNOPSIS: Default virtual methods for the CONTROL_GROUP class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

APIERR CONTROL_GROUP::OnGroupAction( CONTROL_GROUP * pChildGroup )
{
    UNREFERENCED( pChildGroup );
    return NERR_Success;
}


/*******************************************************************

    NAME:     CONTROL_GROUP::AfterGroupActions

    SYNOPSIS: Default virtual methods for the CONTROL_GROUP class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID CONTROL_GROUP::AfterGroupActions()
{
    return;
}


/**********************************************************\

    NAME:       CONTROL_GROUP::CVSaveValue

    SYNOPSIS:   Call the SaveValue function of the control value object

    ENTRY:      CONTROL_VALUE *pcv - pointer to the control value object

    NOTES:      CONTROL_GROUP is a friend of CONTROL_VALUE group

    HISTORY:
                terryk  11-Jul-1991 Created

\**********************************************************/

VOID CONTROL_GROUP::CVSaveValue( CONTROL_VALUE * pcv, BOOL fInvisible )
{
    pcv->SetTabStop( FALSE );
    pcv->SaveValue( fInvisible );
}


/**********************************************************\

    NAME:       CONTROL_GROUP::CVRestoreValue

    SYNOPSIS:   Call the RestoreValue function of the control value object

    ENTRY:      CONTROL_VALUE *pcv - pointer to the control value object

    NOTES:      CONTROL_GROUP is a friend of CONTROL_VALUE group

    HISTORY:
                terryk  11-Jul-1991 Created

\**********************************************************/

VOID CONTROL_GROUP::CVRestoreValue( CONTROL_VALUE * pcv, BOOL fInvisible )
{
    pcv->SetTabStop( TRUE );
    pcv->RestoreValue( fInvisible );
}


/**********************************************************\

   NAME:       RADIO_GROUP::RADIO_GROUP

   SYNOPSIS:   constructor for the radio group

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990 Created
    beng        07-Nov-1991 Fix error reporting

\**********************************************************/

RADIO_GROUP::RADIO_GROUP( OWNER_WINDOW * powin,
                          CID cidBase,
                          INT crbSize,
                          CID cidInitialSelection,
                          CONTROL_GROUP * pgroupOwner )
    : CONTROL_GROUP( pgroupOwner ),
      _cidBase( cidBase ),
      _crbSize( 0 ),
      _cidCurrentSelection( cidInitialSelection ),
      _cidSavedSelection( cidInitialSelection ),
      _prb( NULL )
{
    if ( QueryError() )
        return;

    _prb = (RADIO_BUTTON *) new BYTE[crbSize*sizeof(RADIO_BUTTON)];
    if ( _prb == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    RADIO_BUTTON * prbTemp = _prb;
    for ( INT i = 0; i < crbSize; i++ )
    {
        new (prbTemp) RADIO_BUTTON( powin, cidBase + i );

        if ( prbTemp->QueryError() != NERR_Success )
        {
            ReportError(prbTemp->QueryError());
            return;
        }

        _prb[i].SetGroup( this );
        prbTemp++;
        _crbSize++;         // Only destruct the number of radio buttons
                            // constructed.
    }

    //  Set the initial selection
    SetSelection( cidInitialSelection );
}


/**********************************************************\

   NAME:       RADIO_GROUP::~RADIO_GROUP

   SYNOPSIS:   destructor for the radio group

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

RADIO_GROUP::~RADIO_GROUP()
{
    //
    //  UPDATED for C++ 2.0: this code used to read:
    //    delete [_crbSize] _prb;
    //  which is INVALID for a user-constructed vector.
    //

    for ( INT i = 0 ; i < _crbSize ; i++ )
    {
        _prb[i].RADIO_BUTTON::~RADIO_BUTTON() ;
    }
    delete (void *) _prb ;
    _prb = NULL;
}


/**********************************************************\

   NAME:       RADIO_GROUP::QueryCount

   SYNOPSIS:   return the total number of control in the radio group

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

INT RADIO_GROUP::QueryCount()
{
    return _crbSize;
}


/**********************************************************************

    NAME:       RADIO_GROUP::OnUserAction

    SYNOPSIS:   Calls SetSelection if a radio button was selected.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        Johnl       25-Apr-1991 Updated to use new GROUP
        beng        08-Oct-1991 Win32 conversion

**********************************************************************/

APIERR RADIO_GROUP::OnUserAction( CONTROL_WINDOW * pcwinControl,
                                  const CONTROL_EVENT & e )
{
    UNREFERENCED( e );

    /* We know lParam will be either BN_CLICKED or BN_DBLCLICKED
     */
    CID cidJustSelectedRB = pcwinControl->QueryCid();
    if ( QuerySelection() != cidJustSelectedRB )
    {
        /* The normal SetSelection also notifies all parent groups, which
         * we don't want.
         */
        SetSelectionDontNotifyGroups( cidJustSelectedRB );
        return NERR_Success;
    }

    return GROUP_NO_CHANGE;
}


/**********************************************************\

   NAME:       RADIO_GROUP::IsMember

   SYNOPSIS:   check whether the given radio button CID
               belongs to the group or not.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

BOOL RADIO_GROUP::IsMember( CID cid )
{
    return ( _cidBase <= cid && cid < _cidBase + _crbSize );
}


/**********************************************************************

    NAME:       RADIO_GROUP::SetSelection

    SYNOPSIS:   set the select in the radio button group

    ENTRY:
        cid     - control ID

    EXIT:

    NOTES:
        This SetSelection is meant to be called by
        RADIO_GROUP/MAGIC_GROUP users.  It manually notifies groups (by
        calling NotifyGroups).  We need to do this manually because
        normally the group notification is performed in DIALOG_WINDOW::
        DialogProc, but  won't get called through DialogProc if the client
        simply calls SetSelection (i.e., group notification only works for
        direct control manipulation (mouse click etc.)).

    HISTORY:
        rustanl     20-Nov-1990 Created
        Johnl       25-Apr-1991 Updated to use new CONTROL_GROUP
        beng        04-Oct-1991 Experiment with Self
        beng        08-Oct-1991 Win32 conversion

**********************************************************************/

VOID RADIO_GROUP::SetSelection( CID cid )
{
    UIASSERT( !QueryError() );
    UIASSERT( cid == RG_NO_SEL || IsMember( cid ) );

    RADIO_GROUP & Self = *this;

    CONTROL_EVENT eventFake(cid, BN_CLICKED);

    /* Clear the old check (if it was checked) and set the new check
     * (if a selection is specified), then save the newly selected
     * button (or absence there of).
     */
    if ( QuerySelection() != RG_NO_SEL )
    {
        Self[QuerySelection()]->NotifyGroups(eventFake);
        Self[QuerySelection()]->SetCheck(FALSE);
    }

    if ( cid != RG_NO_SEL )
    {
        Self[cid]->NotifyGroups(eventFake);
        Self[cid]->SetCheck(TRUE);
    }

    _cidCurrentSelection = cid;
}


/**********************************************************************

    NAME:       RADIO_GROUP::SetSelectionDontNotifyGroups

    SYNOPSIS:   Exactly the same as SetSelection, except doesn't notify
                groups.

    ENTRY:
        cid     - control ID

    EXIT:

    NOTES:
        This SetSelection is meant to be called by
        RADIO_GROUP/MAGIC_GROUP users.  It manually notifies groups (by
        calling NotifyGroups).  We need to do this manually because
        normally the group notification is performed in DIALOG_WINDOW::
        DialogProc, but  won't get called through DialogProc if the client
        simply calls SetSelection (i.e., group notification only works for
        direct control manipulation (mouse click etc.)).

    HISTORY:
        beng        08-Oct-1991 Header added

**********************************************************************/

VOID RADIO_GROUP::SetSelectionDontNotifyGroups( CID cid )
{
    UIASSERT( !QueryError() );
    UIASSERT( cid == RG_NO_SEL || IsMember( cid ) );

    RADIO_GROUP & Self = *this;

    /* Clear the old check (if it was checked) and set the new check
     * (if a selection is specified), then save the newly selected
     * button (or absence there of).
     */
    if ( QuerySelection() != RG_NO_SEL )
        Self[QuerySelection()]->SetCheck( FALSE );

    if ( cid != RG_NO_SEL )
        Self[cid]->SetCheck( TRUE );

    _cidCurrentSelection = cid;
}


/**********************************************************\

   NAME:       RADIO_GROUP::QuerySelection

   SYNOPSIS:   query selection

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
    rustanl     20-Nov-1990     Created

\**********************************************************/

CID RADIO_GROUP::QuerySelection() const
{
    UIASSERT( !QueryError() );
    return _cidCurrentSelection;
}


/**********************************************************\

    NAME:       RADIO_GROUP::operator[]

    SYNOPSIS:   returns a pointer to the radio button that has the
                the specified CID (control ID).

    ENTRY:

    EXIT:

    NOTES:
        CODEWORK - This should return a reference, not a pointer.

    HISTORY:
        rustanl     20-Nov-1990     Created

\**********************************************************/

RADIO_BUTTON * RADIO_GROUP::operator[]( CID cid )
{
    UIASSERT( !QueryError() );
    UIASSERT( IsMember( cid ) );

    //  Verify that object is not in an error state, and that the given
    //  cid is within the right range.
    if ( !IsMember( cid ) )
        return _prb;

    //  Return a pointer to the specified radio button
    return &(_prb[ cid - _cidBase ]);
}


/*******************************************************************

    NAME:       RADIO_GROUP::Enable

    SYNOPSIS:   Disables all of the radio buttons in this radio group
                (disables in the Windows sense, not the control value
                sense).

    ENTRY:      fEnable - TRUE to enable, FALSE to disable

    NOTES:

    HISTORY:
        Johnl   05-May-1992     Created

********************************************************************/

void RADIO_GROUP::Enable( BOOL fEnable )
{
    for ( int i = 0 ; i < QueryCount() ; i++ )
    {
        _prb[i].Enable( fEnable ) ;
    }
}

/*******************************************************************

    NAME:     RADIO_GROUP::SaveValue

    SYNOPSIS: Clears the current selection in this radio group


    EXIT:     The radio group no longer contains a current selection

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID RADIO_GROUP::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    _cidSavedSelection = QuerySelection();
    SetSelectionDontNotifyGroups( RG_NO_SEL );
}


/*******************************************************************

    NAME:     RADIO_GROUP::RestoreValue

    SYNOPSIS: Restores RADIO_GROUP after SaveValue

    ENTRY:

    EXIT:

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl   25-Apr-1991     Created
********************************************************************/

VOID RADIO_GROUP::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    SetSelectionDontNotifyGroups( _cidSavedSelection );

    /* Cause an assertion if two RestoreValues are performed without
     * an intervening SaveValue.
     */
    _cidSavedSelection = 0;
}


/*******************************************************************

    NAME:     RADIO_GROUP::SetControlValueFocus

    SYNOPSIS: Redefines CONTROL_VALUE virtual.  Sets the focus to the
              currently selected radio button.


    EXIT:     The current radio button has the windows focus

    NOTES:

    HISTORY:
        Johnl       02-May-1991 Created
        Johnl       16-Sep-1991 Removed RG_NO_SEL assertion
        beng        04-Oct-1991 Experiment with Self

********************************************************************/

VOID RADIO_GROUP::SetControlValueFocus()
{
    /* If the current selection is no selection, then simply return (setting
     * focus to a button will automatically select it, so we just don't do
     * anything).
     */
    if ( QuerySelection() == RG_NO_SEL )
        return;

    RADIO_GROUP & Self = *this;

    Self[QuerySelection()]->SetControlValueFocus();
}


/*******************************************************************

    NAME:      MAGIC_GROUP::MAGIC_GROUP

    SYNOPSIS:  Magic group constructor, same parameters as RADIO_GROUP
               constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   24-Apr-1991     Created
        Johnl   25-Jun-1991     Removed unnecessary check from
                                _actrlcidAssocations

********************************************************************/

MAGIC_GROUP::MAGIC_GROUP( OWNER_WINDOW * powin,
                          CID cidBase,
                          INT crbSize,
                          CID cidInitialSelection,
                          CONTROL_GROUP * pgroupOwner     )
    : CONTROL_GROUP( pgroupOwner ),
      _rg( powin, cidBase, crbSize, cidInitialSelection, this ),
      _cidCurrentRBSelection( cidInitialSelection ),
      _actrlcidAssociations( 1 )    // Default to having 1 control
{
    /* We don't need to check _actrlcidAssociations (an ARRAY_LIST) since
     * we are guaranteed it will construct.  It may not construct the size
     * we request, in which case, AddAssociation will most likely fail.
     */

    if ( _rg.QueryError() != NERR_Success )
    {
        ReportError( _rg.QueryError() );
        return;
    }
}


/*******************************************************************

    NAME:     MAGIC_GROUP::AddAssociation

    SYNOPSIS: Associates a Radio button in this magic group with a
              control.

    ENTRY:    cidRadio - The Control ID of the radio button to associate
                         this control with.
              pcontval - Pointer to the control value to be associated with
                         the passed radio button.

    EXIT:

    NOTES:    If the control value's associated radio button is not active,
              then SaveValue will be called on that control value.

    HISTORY:
        Johnl   24-Apr-1991     Created

********************************************************************/

APIERR MAGIC_GROUP::AddAssociation( CID cidRadio, CONTROL_VALUE * pcontval )
{
    UIASSERT( _rg.IsMember(cidRadio) );
    UIASSERT( pcontval != NULL );

    CONTROLVAL_CID_PAIR  contvalcidpair( cidRadio, pcontval );

    if ( !_actrlcidAssociations.Add( contvalcidpair ) )
        return ERROR_NOT_ENOUGH_MEMORY;

    pcontval->SetGroup( this );

    /* If the radio button we are adding the association to is not checked,
     * do a SaveValue on it.
     */
    if ( !_rg[ cidRadio ]->QueryCheck() )
        CVSaveValue( pcontval );

    return NERR_Success;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::ActivateAssocControls

    SYNOPSIS: Calls RestoreValue and SaveValue on the controls that
              are being activated and inactivated, respectively.

    ENTRY:    cidNewRBSelection - The radio button that is newly selected
                                  (can be RG_NO_SEL).
              cidOldRBSelection - The radio button that is losing the selection
                                  (can be RG_NO_SEL).
              pctrlval          - The control that the user is currently on
                                  (won't be touched, can be NULL).

    EXIT:     The controls associated with cidNewRBSelection are activated
              and the controls associated with cidOldRBSelection are
              deactivated.

    NOTES:    pcontvalHasFocus should only point to a control belonging to
              the group that is going to be activated.

              If cidNewRBSelection and cidOldRBSelection are the same, then
              cidNewRBSelection will be activated and cidOldRBSelection will
              be ignored.

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID MAGIC_GROUP::ActivateAssocControls( CID  cidNewRBSelection,
                                         CID  cidOldRBSelection,
                                         CONTROL_VALUE * pctrlval )
{
    /* If we try to both activate and deactivate the same radio button,
     * then we will assume we just want to activate it
     */
    if ( cidNewRBSelection == cidOldRBSelection )
        cidOldRBSelection = RG_NO_SEL;

    for (UINT i = 0; i < _actrlcidAssociations.QueryCount(); i++ )
    {
        CONTROLVAL_CID_PAIR * pctrlcid = &_actrlcidAssociations[i];

        if ( pctrlcid->QueryRBCID() == cidNewRBSelection )
        {
             /* We don't want to Restore the control the user just
              * selected.
              */
             if ( pctrlcid->QueryContVal() != pctrlval      )
                 CVRestoreValue( pctrlcid->QueryContVal());
        }
        else if ( pctrlcid->QueryRBCID() == cidOldRBSelection )
        {
            CVSaveValue( pctrlcid->QueryContVal() );
        }
    }
}


/*******************************************************************

    NAME:     MAGIC_GROUP::OnUserAction

    SYNOPSIS: Virtual method that is called when a control belonging to this
              group received a message.  If the message indicates the
              control may have changed, this method will restore and save
              the appropriate associated controls.

    ENTRY:

    EXIT:

    NOTES:    This method only gets called when a control value belonging
              to this group receives a message (not when the radio buttons
              are messed with).

    HISTORY:
        Johnl       24-Apr-1991 Created
        beng        31-Jul-1991 Renamed QMessageInfo to QEventEffects
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

APIERR MAGIC_GROUP::OnUserAction( CONTROL_WINDOW *      pcwinControl,
                                  const CONTROL_EVENT & e )
{
    // C7 CODEWORK - remove Glock-pacifier cast
    UINT nChangeFlags = pcwinControl->QueryEventEffects( (const CONTROL_EVENT &)e );
    UIASSERT( (nChangeFlags == CVMI_NO_VALUE_CHANGE) ||
              (nChangeFlags == CVMI_VALUE_CHANGE )   ||
              (nChangeFlags == (CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE )) );

    /* Do this first since this is the cheapest thing to do.
     */
    if ( nChangeFlags == CVMI_NO_VALUE_CHANGE )
        return GROUP_NO_CHANGE;

    /* Now we need to check what radio button may have been activated by the
     * change message on pcwinControl.  If the radio button associated with
     * this control is the same as the current selection and the button is
     * already active, then nothing has changed.
     */
    CID cidNew = FindAssocRadioButton( pcwinControl );
    if ( cidNew == _cidCurrentRBSelection   &&
         _rg[_cidCurrentRBSelection]->QueryCheck() )
    {
        return GROUP_NO_CHANGE;
    }

    /* Change the checked radio button to the new selection and inactivate
     * the controls associated with the old selection  and activate the
     * controls associated with the new selection except for the control
     * which now has the focus (i.e., the one that the user selected to
     * cause all of this), unless the client requests that the control be
     * restored (by specifying the CVMI_RESTORE_ON_INACTIVE).
     */
    _rg.SetSelectionDontNotifyGroups( cidNew );
    if ( nChangeFlags & CVMI_RESTORE_ON_INACTIVE )
        pcwinControl = NULL;

    ActivateAssocControls( cidNew, _cidCurrentRBSelection, pcwinControl );

    _cidCurrentRBSelection = cidNew;
    return NERR_Success;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::OnGroupAction

    SYNOPSIS: Virtual method that is called when a child group has changed
              (i.e., our private RADIO_GROUP has changed or a child group
              acting as a control has changed).

    ENTRY:    pgroupChild is a pointer to the group that has changed
                          (will either be the address of our private
                          radio group or a child group).

    EXIT:

    NOTES:    We assume this only gets called when there is an actual
              change (i.e., a *new* radio button is selected/ a new
              group is activated etc.).

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

APIERR MAGIC_GROUP::OnGroupAction( CONTROL_GROUP * pgroupChild )
{
    CID cidNew;

    /* If the group that changed is not our private member RADIO_GROUP, then
     *   some other child group has changed, so we need to select our
     *   radio button (in our RADIO_GROUP) that is associated with the
     *   newly activated group.
     * else
     *   It was our private radio group that was changed, since it selects
     *   itself (see OnUserAction) we just note which button now has the
     *   current selection.
     */
    if ( pgroupChild != &_rg )
    {
        cidNew = FindAssocRadioButton( pgroupChild );

        /* If the radio button associated with the changed control is the
         * current selection and there is a current selection
         * and it is checked, then simply ignore and return,
         */
        if ( cidNew == _rg.QuerySelection()  &&
            _cidCurrentRBSelection != RG_NO_SEL &&
            _rg[_cidCurrentRBSelection]->QueryCheck() )
        {
            return GROUP_NO_CHANGE;
        }

        _rg.SetSelectionDontNotifyGroups( cidNew );
    }
    else
    {
        cidNew = _rg.QuerySelection();
    }

    ActivateAssocControls( cidNew, _cidCurrentRBSelection, pgroupChild );

    _cidCurrentRBSelection = cidNew;

    return NERR_Success;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::FindAssocRadioButton

    SYNOPSIS: Returns the CID associated with the pcontvalue

    ENTRY:    pcontvalue is the control value pointer the radio button
              CID is associated with.

    EXIT:     Returns the associated radio button CID or 0 if none
              is found.

    NOTES:    Asserts out under DEBUG if no association exists.

    HISTORY:
        Johnl   25-Apr-1991         Created

********************************************************************/

CID MAGIC_GROUP::FindAssocRadioButton( CONTROL_VALUE * pcontvalue )
{
    UIASSERT( pcontvalue != NULL );

    UINT i = 0;
    for ( ; i < _actrlcidAssociations.QueryCount() ; i++ )
    {
        if ( _actrlcidAssociations[i].QueryContVal() == pcontvalue )
            return _actrlcidAssociations[i].QueryRBCID();
    }

    DBGEOL(SZ("MAGIC_GROUP::FindAssocRadioButton - CONTROL_VALUE* not associated with RB!") );
    return 0;
}

/*******************************************************************

    NAME:       MAGIC_GROUP::Enable

    SYNOPSIS:   Disables all of the radio buttons and their associated
                controls.

    ENTRY:      fEnable - TRUE to enable, FALSE to disable

    NOTES:      WARNING - Currently disables only the radio buttons and not
                the associated controls.  To fix, CONTROL_VALUE needs an
                Enable method which will do the right thing.  This behavior
                is not currently needed by anyone but should be added if
                it is.

                CODEWORK - If we ever need to disable just a radio button
                and its associated controls, then add the radio buttons CID
                to this method.

    HISTORY:
        Johnl   05-May-1992     Created

********************************************************************/

void MAGIC_GROUP::Enable( BOOL fEnable )
{
#if 0
    // Add when Enable gets added to control value

    /* Disable each of the control values associated with this magic group.
     */
    for (INT i = 0; i < _actrlcidAssociations.QueryCount(); i++ )
    {
        _actrlcidAssociations[i].Enable( fEnable ) ;
    }
#endif
    /* Also disable the radio group that is contained in this magic group
     */
    _rg.Enable( fEnable ) ;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::SaveValue

    SYNOPSIS: Clears the current selection of this magic group and Saves
              the values of all the associated controls

    EXIT:     The magic group no longer contains a current selection

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID MAGIC_GROUP::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    /* Find the active radio button and inactivate the associated controls,
     * then save value on internal radio group.
     */
    if ( _rg.QuerySelection() != RG_NO_SEL )
        ActivateAssocControls( RG_NO_SEL, _rg.QuerySelection(), NULL );

    _rg.SaveValue();
    _cidCurrentRBSelection = RG_NO_SEL;
}


/*******************************************************************

    NAME:     MAGIC_GROUP::RestoreValue

    SYNOPSIS: Restores MAGIC_GROUP after SaveValue

    ENTRY:

    EXIT:

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID MAGIC_GROUP::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );
    _rg.RestoreValue();

    if ( _rg.QuerySelection() != RG_NO_SEL )
        ActivateAssocControls( _rg.QuerySelection(), RG_NO_SEL, NULL );

    _cidCurrentRBSelection = _rg.QuerySelection();
}


/*******************************************************************

    NAME:     MAGIC_GROUP::SetControlValueFocus

    SYNOPSIS: Redefines CONTROL_VALUE virtual.  Sets the focus to the
              currently selected radio button (which can be RG_NO_SEL).

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created
        Johnl   17-Sep-1991     Removed RG_NO_SEL assertion

********************************************************************/

VOID MAGIC_GROUP::SetControlValueFocus()
{
    _rg.SetControlValueFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltgb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltgb.cxx
    BLT graphical pushbutton definitions

    This file implements the special "graphical pushbuttons" of BLT.

    CODEWORK: There's a lot of fat in here.  Looks like the disable flavor was
    coded by cut-and-paste.  Redundant ctors should be folded together
    (using the 2-in-1 subobject hack, perhaps).  Disable flavor should
    move to a separate .obj file so it isn't dragged into most apps.

    FILE HISTORY:
        gregj       05-Apr-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      18-Jul-1991     Update header file and add a SetStatus()
                                    function to GRAPHICAL_BUTTON which takes
                                    a HBITMAP as its parameter.
                                    Also, change the constructor and add
                                    error checking in the constructor
        KeithMo     07-Aug-1992     STRICTified.
*/
#include "pchblt.hxx"   // Precompiled header

/*
    Distance, in pels, between text and focus box, all around.
    This is only used by the custom-draw code.
*/

#define FOCUS_DISTANCE  1


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::GRAPHICAL_BUTTON

    SYNOPSIS:   Constructor for a graphical pushbutton control.

    ENTRY:      powin     - owner of this control
                cid       - this control's ID
                hbmMain   - bitmap to display on the button face
                hbmStatus - bitmap to display as a status light
                            (defaults to NULL, meaning no status light)
        OR
        TCHAR * pszMainName - name of the main bitmap
        TCHAR * pszStatusName - name of the status bitmap


    EXIT:

    NOTES:      For best results, the status light bitmap should be
                a 10x10 color bitmap.

    HISTORY:
        gregj       05-Apr-1991 Created
        beng        15-May-1991 Names its parent constructor
        terryk      20-Jun-1991 change HBITMAP to BIT_MAP
        terryk      18-Jul-1991 Takes string name directly instead of
                                passing the string id to constructor
        beng        17-Sep-1991 Removed redundant classname arg
        beng        04-Aug-1992 Pruned unused HBITMAP versions
        KeithMo     13-Dec-1992 Moved guts to CtAux().

********************************************************************/
GRAPHICAL_BUTTON::GRAPHICAL_BUTTON( OWNER_WINDOW * powin,
                                    CID            cid,
                                    const TCHAR  * pszMainName,
                                    const TCHAR  * pszMainDisabledName,
                                    const TCHAR  * pszStatusName )
  : PUSH_BUTTON( powin, cid ),
    _pdmStatus( NULL ),
    _pdmMain( NULL ),
    _pdmMainDisabled( NULL )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Let CtAux() handle the grunt work.
    //

    CtAux( pszMainName, pszMainDisabledName, pszStatusName );
}

GRAPHICAL_BUTTON::GRAPHICAL_BUTTON( OWNER_WINDOW * powin,
                                    CID            cid,
                                    const TCHAR  * pszMainName,
                                    const TCHAR  * pszMainDisabledName,
                                    XYPOINT        xy,
                                    XYDIMENSION    dxy,
                                    ULONG          flStyle,
                                    const TCHAR  * pszStatusName )
  : PUSH_BUTTON( powin, cid, xy, dxy, flStyle ),
    _pdmStatus( NULL ),
    _pdmMain ( NULL ),
    _pdmMainDisabled( NULL )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Let CtAux() handle the grunt work.
    //

    CtAux( pszMainName, pszMainDisabledName, pszStatusName );
}

VOID GRAPHICAL_BUTTON::CtAux( const TCHAR * pszMainName,
                              const TCHAR * pszMainDisabledName,
                              const TCHAR * pszStatusName )
{
#if defined(DEBUG)
    {
        IDRESOURCE idresMain( pszMainName );
        IDRESOURCE idresMainDisabled( pszMainDisabledName );
        IDRESOURCE idresStatus( pszStatusName );

        UIASSERT( !idresMain.IsStringId() );
        UIASSERT( !idresMainDisabled.IsStringId() );
        UIASSERT( !idresStatus.IsStringId() );
    }
#endif

    APIERR err = NERR_Success;

    //
    //  Load the main button bitmap.
    //

    if( pszMainName != NULL )
    {
        _pdmMain = new DISPLAY_MAP( (BMID)(ULONG_PTR)pszMainName );

        err = ( _pdmMain == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : _pdmMain->QueryError();
    }

    //
    //  Load the main disabled bitmap.
    //

    if( ( err == NERR_Success ) && ( pszMainDisabledName != NULL ) )
    {
        _pdmMainDisabled = new DISPLAY_MAP( (BMID)(ULONG_PTR)pszMainDisabledName );

        err = ( _pdmMainDisabled == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                           : _pdmMainDisabled->QueryError();
    }

    //
    //  Load the status bitmap.
    //

    if( ( err == NERR_Success ) && ( pszStatusName != NULL ) )
    {
        _pdmStatus = new DISPLAY_MAP ( (BMID)(ULONG_PTR)pszStatusName );

        err = ( _pdmStatus == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _pdmStatus->QueryError();
    }

    //
    //  Set the error state if something tragic happened.
    //

    if( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::~GRAPHICAL_BUTTON

    SYNOPSIS:   Destructor for graphical pushbutton control

    EXIT:       Bitmaps are destroyed

    HISTORY:
                gregj   05-Apr-1991     Created

********************************************************************/

GRAPHICAL_BUTTON::~GRAPHICAL_BUTTON()
{
    delete _pdmMain;
    _pdmMain = NULL;

    delete _pdmMainDisabled;
    _pdmMainDisabled = NULL;

    delete _pdmStatus;
    _pdmStatus = NULL;
}


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::SetStatus

    SYNOPSIS:   Sets the status light bitmap for a graphical pushbutton

    ENTRY:      hbmNew - handle to a bitmap to draw as a status light
                         NULL for no status light

    EXIT:

    NOTES:
        This bitmap, unlike the main bitmap for the button,
        is not owned by the button itself and will not be
        destroyed when the control is destroyed.

    HISTORY:
        gregj       05-Apr-1991 Created
        terryk      18-Jul-1991 Add one more SetStatus which takes
                                a handle as a parameter

********************************************************************/

VOID GRAPHICAL_BUTTON::SetStatus( BMID bmidNewStatus )
{
    DISPLAY_MAP * pdmStatus = NULL;
    if ( bmidNewStatus != 0 )
    {
        pdmStatus = new DISPLAY_MAP ( bmidNewStatus );
        if ( pdmStatus->QueryError() != NERR_Success )
        {
            DBGEOL(SZ("BLTGB: cannot load bitmap."));
            return;
        }
    }

    _pdmStatus = pdmStatus;
    Invalidate();      // redraw button with new status
}

VOID GRAPHICAL_BUTTON::SetStatus( HBITMAP hbitmap )
{
#if 1
    UIASSERT( FALSE );  // can't do this for DISPLAY_MAPs!
#else
    if ( _pdmStatus == NULL )
    {
        BIT_MAP * pdmStatus = new BIT_MAP( hbitmap );
        if ( pdmStatus == NULL )
        {
            return;
        }
        else if ( pdmStatus->QueryError() != NERR_Success )
        {
            DBGEOL(SZ("BLTGB: cannot assign bitmap."));
            return;
        }
        _pdmStatus = pdmStatus;
        Invalidate();
        return;
    }
    _pdmStatus->SetBitmap ( hbitmap );
    Invalidate();
#endif
}


/*******************************************************************

    NAME:       GRAPHICAL_BUTTON::CD_Draw

    SYNOPSIS:   Custom draw routine for graphical pushbuttons

    ENTRY:      pdis - pointer to a DRAWITEMSTRUCT (see Windows ref.)

    EXIT:       Returns TRUE if the button was drawn successfully

    NOTES:      This method is protected, and only ShellDlgProc calls it.

    HISTORY:
        gregj       05-Apr-1991 Created
        gregj       01-May-1991 Added GUILTT support
        beng        15-May-1991 Uses XYDIMENSION object
        beng        04-Oct-1991 Win32 conversion
        KeithMo     21-Feb-1992 Use COLOR_BTNHIGHLIGHT instead of white.
        beng        30-Mar-1992 Unicode bugfix
        beng        05-May-1992 API changes
        beng        01-Jun-1992 GUILTT support changes
        beng        04-Aug-1992 Use some more DC members

********************************************************************/

BOOL GRAPHICAL_BUTTON::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    RECT rcFace, rcImage;

    ::OffsetRect(&pdis->rcItem, -pdis->rcItem.left, -pdis->rcItem.top);
    pdis->rcItem.right--;
    pdis->rcItem.bottom--;

    /*  Cache the dimensions of the button, not counting the border.  */
    INT xLeft = pdis->rcItem.left+1;
    INT yTop = pdis->rcItem.top+1;
    INT xRight = pdis->rcItem.right-1;
    INT yBottom = pdis->rcItem.bottom-1;

    /*  Calculate the rectangle enclosing the button face and the rectangle
        enclosing the image.  */

    if (pdis->itemState & ODS_SELECTED)
    {
        rcFace.left = xLeft + 1;
        rcFace.top = yTop + 1;
        rcFace.right = xRight;
        rcFace.bottom = yBottom;
        rcImage.left = xLeft + 3;
        rcImage.top = yTop + 3;
        rcImage.right = xRight - 1;
        rcImage.bottom = yBottom - 1;
    }
    else
    {
        rcFace.left = xLeft + 2;
        rcFace.top = yTop + 2;
        rcFace.right = xRight - 2;
        rcFace.bottom = yBottom - 2;
        rcImage = rcFace;
    }


    DEVICE_CONTEXT dc(pdis->hDC);

    NLS_STR nlsButtonText;
    APIERR err = QueryText(&nlsButtonText);
    if (err != NERR_Success)
        nlsButtonText = (const TCHAR *)NULL;

    XYDIMENSION dxyExtent = dc.QueryTextExtent(nlsButtonText);

    RECT rcText;
    INT dxText = dxyExtent.QueryWidth();

    rcText.bottom = rcImage.bottom - 1;
    rcText.top = rcText.bottom - dxyExtent.QueryHeight() - (2 * FOCUS_DISTANCE);
    if (dxText > rcFace.right - rcFace.left - (2*FOCUS_DISTANCE))
        dxText = rcFace.right - rcFace.left - (2*FOCUS_DISTANCE) - 1;
    rcText.left = rcImage.left - FOCUS_DISTANCE +
                (rcImage.right - rcImage.left - dxText) / 2;
    rcText.right = rcText.left + (2 * FOCUS_DISTANCE) + dxText + 1;

    if (pdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT))
    {
        /* Draw the border first, in black, avoiding corner pels */
        HPEN hpenOld = dc.SelectPen( (HPEN)::GetStockObject(BLACK_PEN) );

        dc.MoveTo(xLeft, yTop - 1);      /* top line */
        dc.LineTo(xRight + 1, yTop - 1);
        dc.MoveTo(xLeft, yBottom + 1);   /* bottom line */
        dc.LineTo(xRight + 1, yBottom + 1);
        dc.MoveTo(xLeft - 1, yTop);      /* left line */
        dc.LineTo(xLeft - 1, yBottom + 1);
        dc.MoveTo(xRight + 1, yTop);     /* right line */
        dc.LineTo(xRight + 1, yBottom + 1);

        /*  Draw the dark gray shadow, above/left or below/right as
            appropriate.  */

        HPEN hpenDark = ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW));
        HPEN hpenWhite = ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT));

        dc.SelectPen(hpenDark);

        if (pdis->itemState & ODS_SELECTED)
        {
            /*  "Depressed" button;  just dark shadow above/left.  */
            dc.MoveTo(xLeft, yBottom);   /* lower left corner */
            dc.LineTo(xLeft, yTop);      /* draw left shadow */
            dc.LineTo(xRight, yTop);     /* draw top shadow */
        }
        else
        {
            /*  "Released" button;  light above/left, dark below/right.  */
            dc.MoveTo(xRight, yTop);     /* upper right */
            dc.LineTo(xRight, yBottom);  /* right shadow, outer column */
            dc.LineTo(xLeft, yBottom);   /* bottom shadow, outer row */
            dc.MoveTo(xRight-1, yTop+1); /* u.r., down/in one pel */
            dc.LineTo(xRight-1, yBottom-1); /* right shadow, inner col. */
            dc.LineTo(xLeft+1, yBottom-1);  /* bottom shadow, inner row */

            dc.SelectPen(hpenWhite);

            dc.MoveTo(xLeft, yBottom-1); /* lower left, up one pel */
            dc.LineTo(xLeft, yTop);      /* light slope, outer column */
            dc.LineTo(xRight-1, yTop);   /* outer row */
            dc.MoveTo(xLeft+1, yBottom-2); /* l.l., up/in one pel */
            dc.LineTo(xLeft+1, yTop+1);  /* inner column */
            dc.LineTo(xRight-2, yTop+1); /* inner row */
        }
        dc.SelectPen(hpenOld);
        if (hpenDark) // JonN 01/27/00 PREFIX bug 444897
            ::DeleteObject( (HGDIOBJ)hpenDark );
        if (hpenWhite) // JonN 01/27/00 PREFIX bug 444897
            ::DeleteObject( (HGDIOBJ)hpenWhite );

        /*  Paint the image area with button-face color.  */

        HBRUSH hbrFace = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));

        rcFace.right++;         /* adjust for FillRect not doing bottom & right */
        rcFace.bottom++;
        ::FillRect(dc.QueryHdc(), &rcFace, hbrFace);
        ::DeleteObject( (HGDIOBJ)hbrFace );
        rcFace.right--;
        rcFace.bottom--;

        /*  Draw the text.  */

        INT oldbm = dc.SetBkMode( TRANSPARENT );

        if( pdis->itemState & ODS_DISABLED )
        {
            //
            //  Draw the grey text in the "normal" position.
            //

            dc.SetTextColor(::GetSysColor(COLOR_BTNSHADOW));
            dc.DrawText(nlsButtonText, &rcText,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);

            //
            //  Now draw the white text offset towards the lower
            //  right corner.
            //

            RECT rcTmp = rcText;

            rcTmp.left++;
            rcTmp.right++;
            rcTmp.top++;
            rcTmp.bottom++;

            dc.SetTextColor(::GetSysColor(COLOR_BTNHIGHLIGHT));
            dc.DrawText(nlsButtonText, &rcTmp,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }
        else
        {
            dc.SetTextColor(::GetSysColor(COLOR_BTNTEXT));
            dc.DrawText(nlsButtonText, &rcText,
                        DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }

        dc.SetBkMode( oldbm );

        /*  Draw the bitmap.  */

        DISPLAY_MAP * pdm = NULL;

        if( pdis->itemState & ODS_DISABLED )
            pdm = _pdmMainDisabled;

        if( pdm == NULL )
            pdm = _pdmMain;

        if( pdm != NULL )
        {
            pdm->Paint( dc.QueryHdc(),
                        rcImage.left +
                            ( rcImage.right - rcImage.left -
                                pdm->QueryWidth() ) / 2,
                        rcImage.top + 3 );
        }

        /*  Draw the status indicator, if desired.  */

        if( _pdmStatus != NULL )
        {
            _pdmStatus->Paint( dc.QueryHdc(),
                               rcImage.left + 2,
                               rcImage.top + 2 );
        }

        if (pdis->itemState & ODS_FOCUS)
            dc.DrawFocusRect(&rcText);
    }
    else if (pdis->itemAction & ODA_FOCUS)
    {
        dc.DrawFocusRect(&rcText);
    }

    return TRUE;
}


/**********************************************************************

    NAME:       GRAPHICAL_BUTTON_WITH_DISABLE::GRAPHICAL_BUTTON_WITH_DISABLE

    SYNOPSIS:   constructor

    ENTRY:      See GRAPHICAL_BUTTON for detail

    NOTES:      This constructor is similar to the GRAPHICAL_BUTTON
                constructor. However, it has one more bitmap to specify
                which is the DISABLE bitmap.

    HISTORY:
        terryk      22-May-91   Created
        terryk      20-Jun-91   Change HBITMAP to bitmap
        terryk      19-Jul-91   Change the parent class to push button
        terryk      19-Jul-91   Take the bitmap name in the resource file
                                directly instead of getting a string id
        beng        17-Sep-1991 Removed redundant classname arg
        beng        04-Aug-1992 Pruned HBITMAP versions; load resources
                                by ordinal; simplify ctors

**********************************************************************/

GRAPHICAL_BUTTON_WITH_DISABLE::GRAPHICAL_BUTTON_WITH_DISABLE(
    OWNER_WINDOW *powin,
    CID           cid,
    BMID          nIdMain,
    BMID          nIdInvert,
    BMID          nIdDisable )
    : PUSH_BUTTON(powin, cid),
      _bmMain( nIdMain ),
      _bmMainInvert( nIdInvert ),
      _bmDisable( nIdDisable ),
      _fSelected( FALSE )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return;

    if (   ((err = _bmMain.QueryError()) != NERR_Success)
        || ((err = _bmMainInvert.QueryError()) != NERR_Success)
        || ((err = _bmDisable.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}

GRAPHICAL_BUTTON_WITH_DISABLE::GRAPHICAL_BUTTON_WITH_DISABLE(
    OWNER_WINDOW *powin,
    CID           cid,
    BMID          nIdMain,
    BMID          nIdInvert,
    BMID          nIdDisable,
    XYPOINT       xy,
    XYDIMENSION   dxy,
    ULONG         flStyle )
    : PUSH_BUTTON(powin, cid, xy, dxy, flStyle),
      _bmMain( nIdMain ),
      _bmMainInvert( nIdInvert ),
      _bmDisable( nIdDisable ),
      _fSelected( FALSE )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return;

    if (   ((err = _bmMain.QueryError()) != NERR_Success)
        || ((err = _bmMainInvert.QueryError()) != NERR_Success)
        || ((err = _bmDisable.QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }
}


/**********************************************************************

    NAME:       GRAPHICAL_BUTTON_WITH_DISABLE::~GRAPHICAL_BUTTON_WITH_DISABLE

    SYNOPSIS:   destructor

    HISTORY:
        terryk      18-Jun-91   Created
        beng        04-Aug-1992 Clean up ctor/dtor

***********************************************************************/

GRAPHICAL_BUTTON_WITH_DISABLE::~GRAPHICAL_BUTTON_WITH_DISABLE()
{
    // all automatic
}


/**********************************************************************

    NAME:       GRAPHICAL_BUTTON_WITH_DISABLE::CD_Draw

    SYNOPSIS:   Redraw the graphical button

    ENTRY:      DRAWITEMSTRUCT *pdis - draw item information

    NOTES:      This CD_Draw routine is similar to the GRAPHICAL_BUTTON
                CD_Draw routine. The differents are:
                1. Instead of using Bitblt, it will use StretchBlt to
                   expand the bitmap to cover the whole button.
                2. You can specified a disable bitmap for disable purpose.

    HISTORY:
        terryk      22-May-91   Created
        terryk      19-Jul-91   It will change the window style in the
                                HWND. If the style contains GB_3D,
                                it will draw it in 3d, otherwise, it
                                will just display the button with a
                                different bitmap
        beng        04-Oct-1991 Win32 conversion
        KeithMo     21-Feb-1992 Use COLOR_BTNHIGHLIGHT instead of white.
        beng        30-Mar-1992 Unicode bugfix
        beng        01-Jun-1992 GUILTT support changes
        beng        04-Aug-1992 Use some more DC members
        terryk      10-Feb-1993 Remove the text part of the button.

**********************************************************************/

BOOL GRAPHICAL_BUTTON_WITH_DISABLE::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    BOOL f3D = ((QueryStyle() & GB_3D) != 0);

    RECT rcFace, rcImage;

    ::OffsetRect(&pdis->rcItem, -pdis->rcItem.left, -pdis->rcItem.top);
    pdis->rcItem.right--;
    pdis->rcItem.bottom--;

    /*  Cache the dimensions of the button, not counting the border.  */
    INT xLeft = pdis->rcItem.left+1;
    INT yTop = pdis->rcItem.top+1;
    INT xRight = pdis->rcItem.right-1;
    INT yBottom = pdis->rcItem.bottom-1;

    /*  Calculate the rectangle enclosing the button face and the rectangle
        enclosing the image.  */

    if ((pdis->itemState & ( ODS_SELECTED | ODS_FOCUS)) || _fSelected )
    {
        rcFace.left = xLeft + 1;
        rcFace.top = yTop + 1;
        rcFace.right = xRight;
        rcFace.bottom = yBottom;
        rcImage.left = xLeft + 3;
        rcImage.top = yTop + 3;
        rcImage.right = xRight - 1;
        rcImage.bottom = yBottom - 1;
    }
    else
    {
        rcFace.left = xLeft + 2;
        rcFace.top = yTop + 2;
        rcFace.right = xRight - 2;
        rcFace.bottom = yBottom - 2;
        rcImage = rcFace;
    }


    DEVICE_CONTEXT dc(pdis->hDC);

    if ((pdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT | ODA_FOCUS)) || _fSelected)
    {
        /*  Draw the bitmap.  */

        MEMORY_DC mdc( dc );
        BITMAP bitmap;
        HBITMAP hbitmap = NULL; // JonN 01/27/00 PREFIX bug 444898

        if (!( pdis->itemState & ODS_DISABLED ))
        {
            if (( pdis->itemState & ODS_SELECTED ) || _fSelected )
            {
                // display invert bitmap
                hbitmap = QueryMainInvert();
            }
            else
            {
                // display normal bitmap
                hbitmap = QueryMain();
            }
        }
        else
        {
            // display disable bitmap
            hbitmap = QueryDisable();
        }

        // display bitmap
        if (NULL != hbitmap)
        {
            ::GetObject(hbitmap, sizeof(bitmap), (TCHAR*)&bitmap);
            mdc.SelectBitmap( hbitmap );
        }

        if ( f3D )
        {
            // fit the bitmap into the button position
            ::StretchBlt( dc.QueryHdc(), rcImage.left,
                          rcImage.top, rcImage.right - rcImage.left,
                          rcImage.bottom - rcImage.top,
                          mdc.QueryHdc(), 0, 0, bitmap.bmWidth,
                          bitmap.bmHeight, SRCCOPY);
        }
        else
        {
            // fit the bitmap into the button position
            ::StretchBlt( dc.QueryHdc(), xLeft, yTop, xRight - xLeft + 1,
                          yBottom - yTop + 1, mdc.QueryHdc(), 0, 0,
                          bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);
        }

        /* Draw the border first, in black, avoiding corner pels */
        HPEN hpenOld = dc.SelectPen( (HPEN)::GetStockObject(BLACK_PEN) );

        dc.MoveTo(xLeft - 1,  yTop - 1);      /* top line */
        dc.LineTo(xRight + 2, yTop - 1);
        dc.MoveTo(xLeft - 1,  yBottom + 1);   /* bottom line */
        dc.LineTo(xRight + 2, yBottom + 1);
        dc.MoveTo(xLeft - 1,  yTop - 1);      /* left line */
        dc.LineTo(xLeft - 1,  yBottom + 1);
        dc.MoveTo(xRight + 1, yTop - 1);      /* right line */
        dc.LineTo(xRight + 1, yBottom + 1);

        if (( pdis->itemState &  ( ODS_SELECTED | ODS_FOCUS)) || _fSelected )
        {
            // draw the focus border

            dc.MoveTo(xLeft ,  yTop );      /* top line */
            dc.LineTo(xRight + 1, yTop);
            dc.MoveTo(xLeft ,  yBottom );   /* bottom line */
            dc.LineTo(xRight + 1, yBottom );
            dc.MoveTo(xLeft ,  yTop );      /* left line */
            dc.LineTo(xLeft ,  yBottom );
            dc.MoveTo(xRight , yTop );      /* right line */
            dc.LineTo(xRight , yBottom );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltinit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltinit.cxx
    BLT Initialization & static module

    This file contains any BLT specific initialization routines and
    any static/global objects required by BLT.


    FILE HISTORY:
        Johnl       12-Mar-1991 Created
        beng        14-May-1991 Exploded blt.hxx into components
        beng        21-May-1991 Made vhInst static; added dbgstr
        terryk      19-Jul-1991 Call the timer class init and term function
        terryk      07-Aug-1991 Comment out BLT_TIMER class's Init
                                and Term functions.
        beng        17-Oct-1991 Removed SLT_PLUS from init
        beng        25-Oct-1991 Removed static ctors
        beng        30-Oct-1991 Withdrew realmode support
        beng        16-Mar-1992 Changed cdebug init/term
        Yi-HsinS    14-Aug-1992 Load Netmsg.dll on Init time
        KeithMo     07-Aug-1992 Added RegisterHelpFile and related support.
*/

#include "pchblt.hxx"   // Precompiled header

// BLT keeps this information per registrand (registree?)

struct CLIENTDATA
{
    HMODULE _hmod;              // hmod of client (hinst for app)
    UINT    _idMinResource;     // range of resource IDs expected, inclusive
    UINT    _idMaxResource;
    UINT    _idMinString;       // range of string IDs expected, inclusive
    UINT    _idMaxString;
};

/* This manifest defines the number of items in the client data slist that
 * are added by BLT itself.  If you call AddClient in this module, then
 * you probably need to increment this flag.
 */
#define INTERNAL_CLIENTS        1


DECLARE_SLIST_OF(CLIENTDATA);
DEFINE_SLIST_OF(CLIENTDATA);


//
//  This class associates a help file with a specified
//  range of help contexts.
//

class ASSOCHCFILE : public BASE
{
private:
    HMODULE      _hMod;
    RESOURCE_STR _nlsHelpFile;
    ULONG        _nMinHC;
    ULONG        _nMaxHC;

public:
    ASSOCHCFILE( HMODULE hMod,
                 MSGID  idsHelpFile,
                 ULONG  nMinHC,
                 ULONG  nMaxHC );
    ~ASSOCHCFILE();

    HMODULE QueryModule( VOID ) const
        { return _hMod; }

    const TCHAR * QueryHelpFile( VOID ) const
        { return _nlsHelpFile.QueryPch(); }

    BOOL IsAssociatedHC( ULONG hc ) const
        { return ( hc >= _nMinHC ) && ( hc <= _nMaxHC ); }
};


DECLARE_SLIST_OF(ASSOCHCFILE);
DEFINE_SLIST_OF(ASSOCHCFILE);


// How far to unwind in a destruction/cleanup?
//
enum BLT_CTOR_STATE
{
    BLT_CTOR_OMEGA,         // Unwind the whole ding dang thing
    BLT_CTOR_CLWIN,         // CLIENT_WINDOW only
    BLT_CTOR_NOTHING        // nothing to unwind
};


// Guts

class BLTIMP
{
friend class BLT;

private:
    static BOOL         _fInit; // has module been init'd?
    static UINT         _cInit; // actually the number of registered clients
                                // (within this process, of course)

    static HANDLE _hBLTSema4 ;       // Protects BLT global data init/term
    static HANDLE _hResourceSema4 ;  // Protects following two slists
    static SLIST_OF(CLIENTDATA) * _pslClient;
    static SLIST_OF(ASSOCHCFILE) * _pslHelpFiles;

    // Helper function to unwind incomplete Inits
    //
    static VOID   Unwind( BLT_CTOR_STATE );

public:
    static UINT _cMaxResidueBlocksToDump;
    static BOOL _fBreakOnHeapResidue;

    static APIERR Init();
    static VOID   Term();

    static APIERR AddClient( HMODULE hmod, UINT, UINT, UINT, UINT );
    static VOID   RemoveClient( HMODULE hmod );

    static APIERR AddHelpAssoc( HMODULE hMod,
                                MSGID  idsHelpFile,
                                ULONG  nMinHC,
                                ULONG  nMaxHC );
    static VOID   RemoveHelpAssoc( HMODULE hMod,
				   ULONG  hc );

    static APIERR EnterResourceCritSect( void ) ;
    static void   LeaveResourceCritSect( void ) ;
    static APIERR EnterBLTCritSect( void ) ;
    static void   LeaveBLTCritSect( void ) ;
};

UINT         BLTIMP::_cInit = 0;
BOOL         BLTIMP::_fInit = FALSE;

UINT         BLTIMP::_cMaxResidueBlocksToDump = 5;      // defaults
BOOL         BLTIMP::_fBreakOnHeapResidue     = FALSE;


HANDLE BLTIMP::_hResourceSema4 = NULL ;
HANDLE BLTIMP::_hBLTSema4 = NULL ;
SLIST_OF(CLIENTDATA) * BLTIMP::_pslClient = NULL;
SLIST_OF(ASSOCHCFILE) * BLTIMP::_pslHelpFiles = NULL;



/*******************************************************************

    NAME:       BLTIMP::Init

    SYNOPSIS:   Does all necessary initialization of BLT;
                should be called during application/DLL startup to
                register that app with BLT

    ENTRY:      hInst - Instance handled passed to WinMain or LibMain

    EXIT:       _hInst has been set to the given handle;
                all manner of window classes have been registered

    RETURNS:    NERR_Success if initialization was successful
                ERROR_OUT_OF_MEMORY or
                ERROR_GEN_FAILURE  if resource loading error
                ERROR_NOT_SUPPORTED if called in real-mode x86 Windows

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move InitMsgPopup to the LIBMAIN of BLT.

        Since it is not a ctor, this function unwinds all its inits
        should any of them fail.  See Unwind.

    HISTORY:
        beng        31-Jul-1992 Created (dllization)
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe. major cleanup.

********************************************************************/

APIERR BLTIMP::Init()
{
    BLT_CTOR_STATE bltunwind = BLT_CTOR_NOTHING ;
    APIERR err = NERR_Success ;
    TRACEEOL("BLT: Initializing");

    //
    // preload this outside crit sect to avoid deadlock that
    // can result is someone other DLL is trying to do its BLT
    // init the same time while in its DLLENTRY. our LoadLibrary of
    // NETMSG wont succeed while the loader is doing the other
    // DLLENTRY, and that wont suceed since we have the BLT sema4.
    //
    // worst case scenario if we fall into the window (as a result
    // of doing this outside the crit sect) is that we have an extra
    // netmsg.dll loaded.
    //
    HMODULE hmod = ::LoadLibrary( NETMSG_DLL_STRING );

    if ( (err = EnterBLTCritSect()) != NERR_Success )
        return err;

    if (_fInit)
    {
        LeaveBLTCritSect() ;
        return NERR_Success;
    }


    TRACEEOL("BLT: CLIENT WINDOW Init");
    err = CLIENT_WINDOW::Init();
    if (err != NERR_Success)
    {
        DBGEOL("BLT: CLIENT_WINDOW init failed, error " << err);
        goto exitpoint ;
    }
    bltunwind = BLT_CTOR_CLWIN ;  // from here on unwind CLIENT_WINDOW as well

    TRACEEOL("BLT: POPUP Init");
    err = POPUP::Init();
    if (err != NERR_Success)
    {
        DBGEOL("BLT: MSGPOPUP init failed, error " << err);
        goto exitpoint ;
    }
    bltunwind = BLT_CTOR_OMEGA ;  // from here on unwind all

    //
    // next section is protected by critical section for resources
    //
    TRACEEOL("BLT: Resource/HMOD init data structures");
    if (err = EnterResourceCritSect())
        goto exitpoint ;
    _pslClient = new SLIST_OF(CLIENTDATA);
    if (_pslClient == NULL)
    {
        DBGEOL("BLT: failed to ct slist of clientdata, alloc failed");
        LeaveResourceCritSect() ;
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exitpoint ;
    }

    _pslHelpFiles = new SLIST_OF(ASSOCHCFILE);
    if (_pslHelpFiles == NULL)
    {
        DBGEOL("BLT: failed to ct slist of assochcfile, alloc failed");
        LeaveResourceCritSect() ;
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exitpoint ;
    }
    LeaveResourceCritSect() ;

    //
    // register NETMSG.DLL
    //
    if ( hmod != 0 )
    {
        err = BLTIMP::AddClient(hmod, 0, 0,
                                MIN_LANMAN_MESSAGE_ID, MAX_LANMAN_MESSAGE_ID);
    }

    if ( err != NERR_Success )
    {
        if ( hmod != 0 )
            ::FreeLibrary( hmod );
        goto exitpoint ;
    }

    _fInit = TRUE;

exitpoint:

    if (err != NERR_Success)
        Unwind(bltunwind);
    LeaveBLTCritSect() ;
    return err ;
}


/*******************************************************************

    NAME:       BLTIMP::Term

    SYNOPSIS:   Frees any memory and uninitializes any BLT objects.

    ENTRY:      An app has been registered with BLT

    EXIT:       BLT no longer available to app (which may now terminate).

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move UnInitMsgPopup to the WEP of BLT.

        Calling Deregister when the app isn't registered has no effect.
        This simplifies error handling for lanman.drv, which wants to call
        Deregister from its WEP.

    HISTORY:
        Johnl       12-Mar-1991 Created
        DavidHov    14-Mar-1991 Corrected for real mode.
        beng        21-May-1991 Added client-window cleanup;
                                re-corrected for real mode
        terryk      19-Jul-1991 Call the Timer terminator
        beng        29-Jul-1991 Made from ::BLTDeregister
        beng        30-Oct-1991 Rename to Term (from Unregister)
        beng        31-Jul-1992 Factored from BLT::Term; dllization
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/

VOID BLTIMP::Term()
{
    TRACEEOL("BLT: Terminating");
    APIERR err = EnterBLTCritSect() ;

    if (err != NERR_Success)
        return ;

    if (!_fInit)    // more disconnects than connects? bogus.
    {
        DBGEOL("BLT: warning: more disconnects than connects");
        LeaveBLTCritSect();
        return;
    }

    if (_cInit > INTERNAL_CLIENTS ) // not everybody has disconnected
    {
        LeaveBLTCritSect();
        return;
    }

    Unwind(BLT_CTOR_OMEGA);
    _fInit = FALSE;

    LeaveBLTCritSect();
}


/*******************************************************************

    NAME:       BLTIMP::Unwind

    SYNOPSIS:   Common code for dtor and unwinding a partial Init

    ENTRY:      BLT_CTOR_STATE - enum denoting stage of constructopn

    EXIT:       Construction is unwound

    NOTES:
        This is a static member function.

    HISTORY:
        beng        30-Jul-1991 Created - common factoring
        beng        18-Sep-1991 Added Alpha (and renamed Omega)
        beng        17-Oct-1991 Removed SLT_PLUS cleanup
        beng        25-Oct-1991 Removed static dtors
        beng        30-Oct-1991 Removed realmode support; renamed
        beng        16-Mar-1992 Change cdebug init/term

********************************************************************/

VOID BLTIMP::Unwind( BLT_CTOR_STATE state )
{

    TRACEEOL("BLT: Unwinding");

    // Be careful when modifying this - the states correspond
    // to states of partial "construction" (package initialization).
    //
    switch (state)
    {
    case BLT_CTOR_NOTHING:

        // nothing to unwind
        break ;

    default:
    case BLT_CTOR_OMEGA:
      {

        // Remove netmsg.dll
        ASSERT(_pslClient->QueryNumElem() == 1); // sanity
        ITER_SL_OF(CLIENTDATA) iter(*_pslClient);
        CLIENTDATA * pcld = iter.Next();
        ASSERT(pcld != NULL);       // invalid iterator?
        if (pcld != NULL) // JonN 1/27/00: PREFIX 444896
        {
                ::FreeLibrary(pcld->_hmod);
                BLTIMP::RemoveClient( pcld->_hmod );
        }

        delete _pslClient;
        _pslClient = NULL;

        delete _pslHelpFiles;
        _pslHelpFiles = NULL;

        POPUP::Term();
        /* fall through... */
      }

    case BLT_CTOR_CLWIN:
        CLIENT_WINDOW::Term();
        break ;
    }
}

/*******************************************************************

    NAME:       BLT::InitDLL

    SYNOPSIS:   Called once during process attach of BLT initialization

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Straight cut from Init method.  This was created so non-
                window clients (such as ntlanman.dll) don't have to call
                BLT::Init to get debugging services.

                The debug info memory is deleted after the last client unhooks
                from BLT.  Note that means we will have two allocations that
                won't be deallocated if nobody ever registers.  These won't
                show up in the heap residue because the heap residue is
                only called after the last unhook.  Since this will only
                occur under DEBUG builds, this is acceptable.

    HISTORY:
        Johnl   25-Nov-1992     Created
        ChuckC  17-May-1993     Added a couple of semaphores

********************************************************************/

APIERR BLT::InitDLL( void )
{
    //
    // Create the semaphore for BLT global init/term data
    //
    if (!(BLTIMP::_hBLTSema4))
    {
        if ( (BLTIMP::_hBLTSema4 = ::CreateSemaphore( NULL, 1, 1, NULL ))
               == NULL )
        {
            return ::GetLastError();
        }
    }

    //
    // Create the semaphore for BLT resource list protection
    //
    if (!(BLTIMP::_hResourceSema4))
    {
        if ( (BLTIMP::_hResourceSema4 = ::CreateSemaphore( NULL, 1, 1, NULL ))
               == NULL )
        {
            return ::GetLastError();
        }
    }

#if defined(DEBUG)
    // This calls the constructor for the dbgstream object.
    // Place no cdebug clauses before this statement is exec'd!
    //
    {
        const TCHAR * pszSection = SZ("blt");
        const TCHAR * pszIniFile = SZ("netui.ini");

        //
        //  Heap residue control.
        //
        //  [BLT]
        //      cMaxResidueBlocksToDump=10 <- max heap residue blocks to dump
        //      fBreakOnHeapResidue=1      <- break into debugger if residue
        //

        BLTIMP::_cMaxResidueBlocksToDump = ::GetPrivateProfileInt(
                                            pszSection,
                                            SZ("cMaxResidueBlocksToDump"),
                                            (int)BLTIMP::_cMaxResidueBlocksToDump,
                                            pszIniFile );

        BLTIMP::_fBreakOnHeapResidue = ( ::GetPrivateProfileInt(
                                            pszSection,
                                            SZ("fBreakOnHeapResidue"),
                                            (int)BLTIMP::_fBreakOnHeapResidue,
                                            pszIniFile ) > 0 );
    }
#endif   // DEBUG

    TRACEEOL("NETUI2.DLL: Initializing");

    return NERR_Success ;
}


/*******************************************************************

    NAME:       BLT::TermDLL

    SYNOPSIS:   Called once during process detach of BLT

    RETURNS:    nothing

    NOTES:      release all resources, performs heap residue checks

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
VOID BLT::TermDLL( void )
{
    TRACEEOL("NETUI2.DLL: Unloading");

    //
    // close out the semaphores
    //
    ::CloseHandle( BLTIMP::_hResourceSema4 ) ;
    BLTIMP::_hResourceSema4 = NULL ;
    ::CloseHandle( BLTIMP::_hBLTSema4 ) ;
    BLTIMP::_hBLTSema4 = NULL ;

    //
    // heap residue check
    //
    HeapResidueIter( BLTIMP::_cMaxResidueBlocksToDump,
                     BLTIMP::_fBreakOnHeapResidue );

    CLIENT_WINDOW::Term();
}

/*******************************************************************

    NAME:       BLTIMP::AddClient

    SYNOPSIS:   Called to register a client's HMODULE & resource range
                with BLT so we know where to get a resource later.

    RETURNS:    APIERR as appropriate.

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
APIERR BLTIMP::AddClient( HMODULE hmod, UINT idMinR, UINT idMaxR,
                                       UINT idMinS, UINT idMaxS )
{
    APIERR err ;
    ASSERT(_pslClient != NULL);

#if defined(DEBUG)
    if (err = EnterResourceCritSect())
        return err ;
    ITER_SL_OF(CLIENTDATA) iter(*_pslClient);
    CLIENTDATA * pcld = NULL;

    while ((pcld = iter.Next()) != NULL)
    {
        if (pcld->_hmod == hmod)
        {
            DBGEOL("BLT: module " << (UINT)(UINT_PTR)hmod << " already registered");
            ASSERT(FALSE);
        }
    }
    LeaveResourceCritSect() ;
#endif

    // CODEWORK: consider keeping a static pool of these
    // to minimize freestore clutter

    CLIENTDATA *pcl = new CLIENTDATA;
    if (pcl == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    pcl->_hmod = hmod;
    pcl->_idMinResource = idMinR;
    pcl->_idMaxResource = idMaxR;
    pcl->_idMinString = idMinS;
    pcl->_idMaxString = idMaxS;

    if (err = EnterResourceCritSect())
    {
        delete pcl; // JonN 01/23/00: PREFIX bug 444890
        return err ;
    }

    err = _pslClient->Add(pcl);

    if (err == NERR_Success)
        ++_cInit;

    LeaveResourceCritSect() ;
    return err;
}


/*******************************************************************

    NAME:       BLTIMP::RemoveClient

    SYNOPSIS:   Called to remove a client's HMODULE & resource range
                registration with BLT.

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
VOID BLTIMP::RemoveClient( HMODULE hmod )
{
    ASSERT(_pslClient != NULL);
    ASSERT(_cInit > 0);

    if (EnterResourceCritSect() != NERR_Success)
        return ;

    ITER_SL_OF(CLIENTDATA) iter(*_pslClient);
    CLIENTDATA * pcld = NULL;

    while ((pcld = iter.Next()) != NULL)
    {
        if (pcld->_hmod == hmod)
        {
#if defined(DEBUG)
            CLIENTDATA * pcldx = pcld;  // sanity check the removal
#endif
            pcld = _pslClient->Remove(iter);
            ASSERT(pcld != NULL);       // invalid iterator?
            ASSERT(pcldx == pcld);      // sanity
            delete pcld;
            --_cInit;
            LeaveResourceCritSect() ;
            return;
        }
    }

    DBGEOL("BLT: deregistering bogus hmod");
    ASSERT(FALSE);
    LeaveResourceCritSect() ;
}


/*******************************************************************

    NAME:       BLTIMP::AddHelpAssoc

    SYNOPSIS:   Called to register a helpfile and its range with BLT

    RETURNS:    APIERR as apropriate

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
APIERR BLTIMP::AddHelpAssoc( HMODULE hMod,
                             MSGID  idsHelpFile,
                             ULONG  nMinHC,
                             ULONG  nMaxHC )
{
    APIERR err ;
    ASSERT( _pslHelpFiles != NULL );

#if defined(DEBUG)
    if (err = EnterResourceCritSect())
        return err ;

    ITER_SL_OF(ASSOCHCFILE) iter( *_pslHelpFiles );
    ASSOCHCFILE * phfd = NULL;

    while( ( phfd = iter.Next() ) != NULL )
    {
        if( ( phfd->QueryModule() == hMod ) &&
            phfd->IsAssociatedHC( nMinHC ) &&
            phfd->IsAssociatedHC( nMaxHC ) )
        {
            //
            //  CODEWORK:  This could be made more robust
            //  by checking for overlapping context ranges.
            //

            DBGEOL( "BLT: module " << (UINT)(UINT_PTR)hMod << " already registered" );
            ASSERT( FALSE );
        }
    }
    LeaveResourceCritSect() ;
#endif

    // CODEWORK: consider keeping a static pool of these
    // to minimize freestore clutter

    ASSOCHCFILE *phf = new ASSOCHCFILE( hMod, idsHelpFile, nMinHC, nMaxHC );

    if (err = EnterResourceCritSect())
        return err ;

    err =  ( phf == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                           : _pslHelpFiles->Add( phf );
    LeaveResourceCritSect() ;
    return err ;
}


/*******************************************************************

    NAME:       BLTIMP::RemoveHelpAssoc

    SYNOPSIS:   Called to remove a help registration with BLT.

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Documented (earlier history unknown)

********************************************************************/
VOID BLTIMP::RemoveHelpAssoc( HMODULE hMod,
                              ULONG  hc )
{
    ASSERT( _pslHelpFiles != NULL );

    if (EnterResourceCritSect() != NERR_Success)
        return ;

    ITER_SL_OF(ASSOCHCFILE) iter( *_pslHelpFiles );
    ASSOCHCFILE * phfd = NULL;

    while( ( phfd = iter.Next()) != NULL )
    {
        if( ( phfd->QueryModule() == hMod ) &&
            ( ( hc == 0L ) || phfd->IsAssociatedHC( hc ) ) )
        {
#if defined(DEBUG)
            ASSOCHCFILE * phfdx = phfd;  // sanity check the removal
#endif
            phfd = _pslHelpFiles->Remove( iter );
            ASSERT( phfd != NULL );       // invalid iterator?
            ASSERT( phfdx == phfd );      // sanity
            delete phfd;
            LeaveResourceCritSect() ;
            return;
        }
    }
    LeaveResourceCritSect() ;
}



/*******************************************************************

    NAME:       BLT::MapLastError

    SYNOPSIS:   Returns our best guess as to the last error.

        BLT calls this function when a Win API call failed, and it
        isn't sure of the reason why.  Under Win16, its best guess
        is our only answer.  Under Win32, we can find the last error
        reported per-thread, and so use that instead of the guess.

    ENTRY:      errBestGuess - Guessed last error.

    RETURNS:    A better guess.

    NOTES:
        This function is for BLT internal use only.  (CODEWORK: create
        a separate static hierarchy for these, unexported; or else, make
        every BLT internal class inherit from "BLT" at the root.)

        CODEWORK: possibly, overload this with other error classes.
        This function would then map internal errors, etc. into the
        single APIERR scheme.

    HISTORY:
        beng        01-Nov-1991 Created

********************************************************************/

APIERR BLT::MapLastError( APIERR errBestGuess )
{
#if defined(WIN32)
    APIERR errSystemGuess = ::GetLastError();

    if (errSystemGuess == NERR_Success && errBestGuess != NERR_Success)
    {
        // GetLastError claims that no error took place.  Maybe
        // the thread has since overwritten the error, or maybe the
        // user developers forgot to set the error... anyway, we'll
        // return the client's best guess instead.

        return errBestGuess;
    }

    return errSystemGuess;
#else
    return errBestGuess;
#endif
}


/*******************************************************************

    NAME:       BLT::Init

    SYNOPSIS:   Does all necessary initialization of BLT;
                should be called during application/DLL startup to
                register that app with BLT

    ENTRY:      hInst - Instance handled passed to WinMain or LibMain
                idMinR, idMaxR - a range of resource IDs, INCLUSIVE
                idMinS, idMaxS - ditto for string resources

    EXIT:       _hInst has been set to the given handle;
                all manner of window classes have been registered

    RETURNS:    NERR_Success if initialization was successful
                ERROR_OUT_OF_MEMORY or
                ERROR_GEN_FAILURE  if resource loading error
                ERROR_NOT_SUPPORTED if called in real-mode x86 Windows

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move InitMsgPopup to the LIBMAIN of BLT.

        Since it is not a ctor, this function unwinds all its inits
        should any of them fail.  See Unwind.

    HISTORY:
        Johnl       12-Mar-1991 Created
        DavidHov    14-Mar-1991 Corrected for real mode
        beng        21-May-1991 Added client-window init
        terryk      19-Jul-1991 Called the timer initializer
        beng        29-Jul-1991 Made from ::BltRegister; returns APIERR
        beng        18-Sep-1991 Changes to SLT_PLUS, CLIENT_WINDOW init
        beng        17-Oct-1991 Remove SLT_PLUS init
        beng        25-Oct-1991 Removed static ctors
        beng        30-Oct-1991 BLT no longer supports realmode;
                                rename function to Init (from Register)
        beng        16-Mar-1992 Change cdebug init
        beng        10-May-1992 Checks netui.ini for cdebug dest
        beng        31-Jul-1992 Factored out BLTIMP::Init etc.
        Johnl       25-Nov-1992 Made registering a NULL hmod a noop

********************************************************************/

APIERR BLT::Init( HMODULE hmod, UINT idMinR, UINT idMaxR,
                               UINT idMinS, UINT idMaxS )
{
#if !defined(WIN32)
    // Return immediately if called under realmode Windows.
    //
    if ( !(::GetWinFlags() & WF_PMODE) )
        return ERROR_NOT_SUPPORTED;
#endif

    APIERR err = BLTIMP::Init(); // no-op except for first time
    if (err == NERR_Success && hmod != NULL )
        err = BLTIMP::AddClient(hmod, idMinR, idMaxR, idMinS, idMaxS);
    return err;
}


/*******************************************************************

    NAME:       BLT::Term

    SYNOPSIS:   Frees any memory and uninitializes any BLT objects.

    ENTRY:      An app has been registered with BLT

    EXIT:       BLT no longer available to app (which may now terminate).

    NOTES:
        This is a static member function.

        Once we are in the LM 3.0 timeframe (and BLT is a DLL),
        we will want to move UnInitMsgPopup to the WEP of BLT.

        Calling Deregister when the app isn't registered has no effect.
        This simplifies error handling for lanman.drv, which wants to call
        Deregister from its WEP.

    HISTORY:
        Johnl       12-Mar-1991 Created
        DavidHov    14-Mar-1991 Corrected for real mode.
        beng        21-May-1991 Added client-window cleanup;
                                re-corrected for real mode
        terryk      19-Jul-1991 Call the Timer terminator
        beng        29-Jul-1991 Made from ::BLTDeregister
        beng        30-Oct-1991 Rename to Term (from Unregister)
        beng        31-Jul-1992 Factor out BLTIMP; dllization

********************************************************************/

VOID BLT::Term( HMODULE hmod )
{
    BLTIMP::RemoveClient(hmod);
    BLTIMP::RemoveHelpAssoc( hmod, 0L );
    BLTIMP::Term(); // will no-op as necessary
}


/*******************************************************************

    NAME:       BLT :: RegisterHelpFile

    SYNOPSIS:   Associates the specified help file with the specified
                range of help contexts.

    ENTRY:      hMod                    - Handle for current module.

                idsHelpFile             - String resource ID containing
                                          the name of the help file.

                nMinHC                  - Base help context.

                nMaxHC                  - Ceiling help context.

    RETURNS:    APIERR                  - Any errors encountered (usually
                                          either out of memory or resource
                                          not found).

    NOTES:      This is a static member function.

    HISTORY:
        KeithMo     07-Aug-1992 Created.

********************************************************************/
APIERR BLT :: RegisterHelpFile( HMODULE hMod,
                                MSGID  idsHelpFile,
                                ULONG  nMinHC,
                                ULONG  nMaxHC )
{
    return BLTIMP::AddHelpAssoc( hMod, idsHelpFile, nMinHC, nMaxHC );

}   // BLT :: RegisterHelpFile


/*******************************************************************

    NAME:       BLT :: DeregisterHelpFile

    SYNOPSIS:   Disssociates the help file associated with the given
                help context.

    ENTRY:      hMod                    - Handle for current module.

                hc                      - A help context whose value lies
                                          in the range of a previously
                                          registered help file.
    NOTES:      This is a static member function.

    HISTORY:
        KeithMo     16-Aug-1992 Created.

********************************************************************/
VOID BLT :: DeregisterHelpFile( HMODULE hMod,
                                ULONG  hc )
{
    BLTIMP::RemoveHelpAssoc( hMod, hc );

}   // BLT :: DeregisterHelpFile


/*******************************************************************

    NAME:       BLT::CalcHmodString

    SYNOPSIS:   Returns the instance handle of this application/DLL
                given a string resource #

    ENTRY:      BLT has been initialized:

                id      - numeric ID of the resource

    RETURNS:    HANDLE of the applications instance (actually module)

    NOTES:
        This is a static member function.

    HISTORY:
        beng        31-Jul-1992 Created, replacing QueryInstance
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/

HMODULE BLT::CalcHmodString( MSGID id )
{
    if (BLTIMP::_pslClient == NULL  ||
	BLTIMP::EnterResourceCritSect() )
    {
	return hmodBlt;
    }

    ITER_SL_OF(CLIENTDATA) iter(*BLTIMP::_pslClient);
    CLIENTDATA * pcld = NULL;

    // CODEWORK: accelerate this mess.
    //
    // 1. The SLIST is certainly overkill, considering how many
    // entries we'll have (never any more than 10).
    // 2. Should cache recent hits.  I'd use move-to-front except
    // that SLIST doesn't support it: I'd have to Remove, Add.  Gross.
    // Need to add this Move capability to SLIST.
    // 3. The common library always lies at the end of the search,
    // from where it can never be moved due to its if-all-the-others-
    // fail status.  Instead, the first Calc should scan the list and
    // build a true, cachable entry - or entries - for hmodBlt.
    // Any subequent Add/RemoveModule would invalidate this entry,
    // whereupon the next calc would recalc, etc.  (Important to
    // keep that, since folks might LoadLibrary acledit.dll, etc.)

    while ((pcld = iter.Next()) != NULL)
    {
        if (id >= (MSGID)pcld->_idMinString && id <= (MSGID)pcld->_idMaxString)
	{
	    BLTIMP::LeaveResourceCritSect() ;
            return pcld->_hmod;
        }
    }

    // If no hits, use the common lib as the default

    BLTIMP::LeaveResourceCritSect() ;
    return hmodBlt;
}



/*******************************************************************

    NAME:       BLT::CalcHmodResource

    SYNOPSIS:   Returns the instance handle of this application/DLL
                given a the numeric resource ID of some non-string.

    ENTRY:      BLT has been initialized:

                id      - numeric ID of the resource

    RETURNS:    HANDLE of the applications instance (actually module)

    NOTES:
        This is a static member function.

        I made this version a separate fcn both for its "different" first
        arg and because I figured it'd use a different cache.

    HISTORY:
        beng        31-Jul-1992 Created, replacing QueryInstance
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/

HMODULE BLT::CalcHmodRsrc( const IDRESOURCE & id )
{
    if (BLTIMP::_pslClient == NULL  ||
	BLTIMP::EnterResourceCritSect() )
    {
	return hmodBlt;
    }

    ASSERT(!id.IsStringId()); // only load-by-ordinal supported here

    ITER_SL_OF(CLIENTDATA) iter(*BLTIMP::_pslClient);
    CLIENTDATA * pcld = NULL;

    const UINT nId = PtrToUlong(id.QueryPsz());

    while ((pcld = iter.Next()) != NULL)
    {
        if (nId >= pcld->_idMinResource && nId <= pcld->_idMaxResource)
	{
	    BLTIMP::LeaveResourceCritSect() ;
            return pcld->_hmod;
        }
    }

    BLTIMP::LeaveResourceCritSect() ;
    return hmodBlt;
}



/*******************************************************************

    NAME:       BLT :: CalcHelpFileHC

    SYNOPSIS:   Returns the name of the help file associated with the
                given help context.  The help file must have been
                previously registered with BLT::RegisterHelpFile().

    ENTRY:      nHelpContext            - The help context to look up.

    RETURNS:    const TCHAR *           - The name of the associated help
                                          file if found.  If not found,
                                          returns NULL.

    NOTES:
        This is a static member function.

    HISTORY:
        KeithMo     07-Aug-1992 Created.
        chuckc      17-May-1993 Added critical section checks to
                                be multi-thread safe

********************************************************************/
const TCHAR * BLT :: CalcHelpFileHC( ULONG nHelpContext )
{
    const TCHAR * pszHelpFile = NULL;

    if ( BLTIMP::EnterResourceCritSect() != NERR_Success)
        return NULL ;

    if( BLTIMP::_pslHelpFiles != NULL )
    {
        ITER_SL_OF(ASSOCHCFILE) iter( *BLTIMP::_pslHelpFiles );
        ASSOCHCFILE * phfd = NULL;

        while( ( phfd = iter.Next() ) != NULL )
        {
            if( phfd->IsAssociatedHC( nHelpContext ) )
            {
                pszHelpFile = phfd->QueryHelpFile();
                break;
            }
        }
    }

    BLTIMP::LeaveResourceCritSect() ;
    return pszHelpFile;

}   // BLT :: CalcHelpFileHC



//
//  ASSOCHCFILE stuff.
//

ASSOCHCFILE::ASSOCHCFILE( HMODULE hMod,
                          MSGID  idsHelpFile,
                          ULONG  nMinHC,
                          ULONG  nMaxHC )
  : _hMod( hMod ),
    _nlsHelpFile( idsHelpFile ),
    _nMinHC( nMinHC ),
    _nMaxHC( nMaxHC )
{
    if( !_nlsHelpFile )
    {
        ReportError( _nlsHelpFile.QueryError() );
        return;
    }
}

ASSOCHCFILE::~ASSOCHCFILE()
{
    ;   // empty
}

/*******************************************************************

    NAME:       BLTIMP::EnterResourceCritSect

    SYNOPSIS:   enforces MUTEX for resource related data

    RETURNS:    APIERR as appropriate

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Created

********************************************************************/
APIERR BLTIMP::EnterResourceCritSect( void )
{
    APIERR err = NERR_Success ;
    switch ( WaitForSingleObject( BLTIMP::_hResourceSema4, 30000 ) )
    {
    case WAIT_OBJECT_0:
	break ;

    case WAIT_TIMEOUT:
        // should not happen since all we do is manipulate pointers
        // and maybe an alloc or two.
        UIASSERT(FALSE) ;
        err = ERROR_BUSY ;
        break ;

    default:
	err = ::GetLastError() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       BLTIMP::LeaveResourceCritSect

    SYNOPSIS:   Leave the resource data critical section

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     created

********************************************************************/
void BLTIMP::LeaveResourceCritSect( void )
{
    REQUIRE( ReleaseSemaphore( BLTIMP::_hResourceSema4, 1, NULL ) ) ;
}

/*******************************************************************

    NAME:       BLTIMP::EnterBLTCritSect

    SYNOPSIS:   enforces MUTEX for resource BLT init related data

    RETURNS:    APIERR as appropriate

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     Created

********************************************************************/
APIERR BLTIMP::EnterBLTCritSect( void )
{
    APIERR err = NERR_Success ;
    switch ( WaitForSingleObject( BLTIMP::_hBLTSema4, INFINITE ) )
    {
    case WAIT_OBJECT_0:
	break ;

    default:
	err = ::GetLastError() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       BLTIMP::LeaveBLTCritSect

    SYNOPSIS:   Leave the BLT init data critical section

    RETURNS:    nothing

    NOTES:

    HISTORY:
       ChuckC   17-May-1993     created

********************************************************************/
void BLTIMP::LeaveBLTCritSect( void )
{
    REQUIRE( ReleaseSemaphore( BLTIMP::_hBLTSema4, 1, NULL ) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltlb.cxx
    BLT listbox control classes: implementation

    FILE HISTORY:
        RustanL     13-Feb-1991 Created
        RustanL     19-Feb-1991 Added meat for drawing
        rustanl     22-Mar-1991 Rolled in code review changes
                                from CR on 20-Mar-1991, attended by
                                JimH, GregJ, Hui-LiCh, RustanL.
        gregj       08-Apr-1991 Reintegrated caching listbox
        gregj       01-May-1991 Added GUILTT support
        beng        14-May-1991 Exploded blt.hxx into components
        beng        07-Nov-1991 Excised 2-pane listbox support
        beng        20-Apr-1992 Added lazy listbox support
        jonn        25-Apr-1992 Disabled LAZY_LISTBOX build fix
        beng        10-May-1992 Re-enabled (now that we have 1.264)
        Johnl       22-Jul-1992 Lifted Gregj's changes for owner draw combos
        Yi-HsinS    10-Dev-1992 Added support for LBS_OWNERDRAWVARIABLE
*/

#include "pchblt.hxx"   // Precompiled header

/*  The following macro is used to conveniently specify a LB_ or CB_
 *  manifest, depending on the value of _fCombo.  Note, although
 *  most (not all!) LB_ and CB_ manifests have the same name (apart from
 *  the prefix) and SendMessage semantics, they do not have the same values
 *  at all.  An experienced PM programmer may at this point be stunned.
 */
#define LC_MSG( suffix )    ( IsCombo() ? ( CB_##suffix ) : ( LB_##suffix ))

/*
 * Winclass name for all Windows listbox controls.
 */
static const TCHAR *const szClassName = SZ("listbox");

extern "C"
{
    #include <windowsx.h>   // For BLT_COMBOBOX
}

/**********************************************************************

    NAME:       HAW_FOR_HAWAII_INFO::HAW_FOR_HAWAII_INFO
                HAW_FOR_HAWAII_INFO::~HAW_FOR_HAWAII_INFO

    SYNOPSIS:

    ENTRY:

    EXIT:

    HISTORY:
        jonn        05-Aug-1992 Created

**********************************************************************/

HAW_FOR_HAWAII_INFO::HAW_FOR_HAWAII_INFO()
    :   BASE(),
        _nls(),
        _time( 0L )
{
    if ( _nls.QueryError() != NERR_Success )
        ReportError( _nls.QueryError() );
}

HAW_FOR_HAWAII_INFO::~HAW_FOR_HAWAII_INFO()
{
    // nothing to do here
}


/**********************************************************************

    NAME:       LISTBOX::LISTBOX

    SYNOPSIS:   Constructor for owner-draw listbox class

    ENTRY:

    EXIT:

    NOTES:      If the font doesn't construct, we will just continue
                and use the default font.

    HISTORY:
        beng        19-Apr-1992 Created

**********************************************************************/

LISTBOX::LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fReadOnly,
    enum FontType  fonttype,
    BOOL fIsCombo         )
    :   LIST_CONTROL( powin, cid, fIsCombo ),
        _fReadOnly( fReadOnly ),
        _fontListBox( fonttype ),
        _dxScroll( 0 )
{
    if ( QueryError() )
        return;

    //
    //  Enforce the assumption that all BLT_LISTBOXes are
    //  owner-draw (fixed).
    //

    UIASSERT(  ( QueryStyle() & LBS_OWNERDRAWFIXED )
            || ( QueryStyle() & LBS_OWNERDRAWVARIABLE ) );

    if ( !_fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM)_fontListBox.QueryHandle(), (LPARAM)FALSE );
}

LISTBOX::LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    BOOL           fReadOnly,
    enum FontType  fonttype,
    BOOL fIsCombo   )
    :   LIST_CONTROL( powin, cid, FALSE, xy, dxy, flStyle, szClassName ),
        _fReadOnly( fReadOnly ),
        _fontListBox( fonttype ),
        _dxScroll( 0 )
{
    UNREFERENCED( fIsCombo ) ;

    if ( QueryError() )
        return;

    //
    //  Enforce the assumption that all BLT_LISTBOXes are
    //  owner-draw (fixed).
    //

    UIASSERT(  ( flStyle & LBS_OWNERDRAWFIXED )
            || ( flStyle & LBS_OWNERDRAWVARIABLE ) );

    // Yes, this deliberately continues if FONT fails.  See note above.
    //
    if ( !_fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM)_fontListBox.QueryHandle(), (LPARAM)FALSE );
}


/**********************************************************************

    NAME:       LISTBOX::CD_Draw

    SYNOPSIS:   Implement painting a listbox, on request

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        RustanL     13-Feb-1991 Created
        gregj       01-May-1991 Added GUILTT support
        beng        07-Nov-1991 Tuned a bit
        beng        30-Mar-1992 Use COLORREF, DEVICE_CONTEXT types
        beng        20-Apr-1992 Generalized to BLT_LISTBOX and LAZY both
        beng        01-Jun-1992 GUILTT changes
        jonn        27-Mar-1996 Reset background and text colors

**********************************************************************/

BOOL LISTBOX::CD_Draw( DRAWITEMSTRUCT * pdis )
{
    UIASSERT( (pdis->CtlType == ODT_LISTBOX) ||
              (pdis->CtlType == ODT_COMBOBOX) );

    DEVICE_CONTEXT dc(pdis->hDC);

    //  Draw the focus, if required

//-ckm    if ( (pdis->itemAction & ODA_FOCUS) && !IsReadOnly() )
    if (pdis->itemAction & ODA_FOCUS)
    {
        dc.DrawFocusRect( &(pdis->rcItem) );
    }

    if ( pdis->itemAction & ( ODA_DRAWENTIRE | ODA_SELECT ) )
    {
        // itemID is -1 if asked to paint a focus rect at the first item
        // when the listbox is empty.  Then, itemAction should not
        // indicate painting the item itself.

        LBI * plbi = RequestLBI( pdis ); // virtually calc LBI from pdis
        if ( plbi != NULL )
        {
            // Set the color depending on if the item is selected
            // and it is read-only.

            COLORREF clrBackGround, clrText;
            HBRUSH hbr;

            if ( (pdis->itemState & ODS_SELECTED) && !IsReadOnly() )
            {
                clrBackGround = ::GetSysColor( COLOR_HIGHLIGHT );
                clrText       = ::GetSysColor( COLOR_HIGHLIGHTTEXT );
            }
            else
            {
                clrBackGround = ::GetSysColor( COLOR_WINDOW );
                clrText       = ::GetSysColor( COLOR_WINDOWTEXT );
            }

            hbr = ::CreateSolidBrush( clrBackGround );
            if ( hbr != NULL )
            {
                ::FillRect( dc.QueryHdc(), &(pdis->rcItem), hbr );
                ::DeleteObject( (HGDIOBJ)hbr );
            }

            /*
             *  We must reset the background and text colors, otherwise
             *  they will still be at their new values when GDI tries to
             *  erase an existing focus rectangle.  JonN 3/27/96
             */
            COLORREF clrPrevBackGround = dc.GetBkColor();
            COLORREF clrPrevText = dc.GetTextColor();

            dc.SetBkColor( clrBackGround );
            dc.SetTextColor( clrText );

            if ( (INT)(pdis->itemID) >= 0 )
            {
                plbi->Paint( this, dc.QueryHdc(), &(pdis->rcItem), NULL );
            }

            dc.SetBkColor( clrPrevBackGround );
            dc.SetTextColor( clrPrevText );

            ReleaseLBI(plbi); // dispose of as proper
        }
    }

    return TRUE;
}


/**********************************************************************

   NAME:        LISTBOX::CD_VKey

   SYNOPSIS:    Virtual key handler for listboxes

   ENTRY:       wVKey - virtual key code
                wLastPos - current caret position

   EXIT:        Return value appropriate to WM_VKEYTOITEM message:
                -2      ==> listbox should take no further action
                -1      ==> listbox should take default action
                other   ==> index of an item to perform default action on

   NOTES:
        The listbox must have LBS_WANTKEYBOARDINPUT style
        in order for this function to work (or even be called).

   HISTORY:
        gregj       4/18/91     Created
        beng        15-Oct-1991 Win32 conversion

**********************************************************************/

INT LISTBOX::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    UNREFERENCED( nLastPos );

    INT nRet;

    switch (nVKey)
    {
    case VK_LEFT:
        ::SendMessage(QueryOwnerHwnd(), WM_HSCROLL,
#if defined(WIN32)
                      MAKELONG(SB_LINEUP,0), (LPARAM)QueryHwnd()
#else
                      SB_LINEUP, MAKELONG(0,QueryHwnd())
#endif
                     );
        nRet = -2;      // no further action
        break;

    case VK_RIGHT:
        ::SendMessage(QueryOwnerHwnd(), WM_HSCROLL,
#if defined(WIN32)
                      MAKELONG(SB_LINEDOWN,0), (LPARAM)QueryHwnd()
#else
                      SB_LINEDOWN, MAKELONG(0,QueryHwnd())
#endif
                     );
        nRet = -2;      // no further action
        break;

    default:
        nRet = -1;      // take default action
        break;
    }

    return nRet;
}


/**********************************************************************

    NAME:       LISTBOX::InvalidateItem

    SYNOPSIS:   This method invalidates an item in the listbox.

    ENTRY:
        i       The index of the item
        fErase  Specifies whether the background of the item's region
                is to be erased.  fErase defaults to TRUE (do erase).

    EXIT:       Item has been invalidated

    HISTORY:
        RustanL     13-Feb-1991     Created
        beng        20-Apr-1992     Move into LISTBOX

**********************************************************************/

VOID LISTBOX::InvalidateItem( INT i, BOOL fErase )
{
    // This finds the item in question and invalidates it only.
    // (Cf. SetScrollPos.)

    RECT rect;

    if ( Command( LB_GETITEMRECT, i, (LPARAM)&rect ) == LB_ERR )
    {
        DBGEOL( "LISTBOX::InvalidateItem: possibly given an invalid index" );
        return;
    }

    ::InvalidateRect( QueryHwnd(), &rect, fErase );
}


/*******************************************************************

    NAME:       LISTBOX::SetScrollPos

    SYNOPSIS:   Sets the horizontal scroll increment of a listbox

    ENTRY:      dxNewPos - new increment, in pels;  defaults to 0

    EXIT:       Listbox is updated

    NOTES:      The scroll increment is typically produced by a
                separate scroll bar control.

    HISTORY:
        gregj       14-Apr-1991 Created
        beng        07-Nov-1991 Removed 2-pane support
        beng        20-Apr-1992 Move into LISTBOX

********************************************************************/

VOID LISTBOX::SetScrollPos( UINT dxNewPos )
{
    _dxScroll = dxNewPos;

    // Invalidate the entire shebang, so that we redraw it all

    Invalidate( FALSE );
}


/*******************************************************************

    NAME:       LISTBOX::QueryHorizontalExtent

    SYNOPSIS:   Returns the horizontal extent of the listbox.  This is
                the "virtual horizontal size" of a horizontally-scrollable
                listbox.

    RETURNS:    UINT                    - The horizontal extent (in pixels).

    HISTORY:
        KeithMo     09-Feb-1993 Created.

********************************************************************/

UINT LISTBOX::QueryHorizontalExtent( VOID ) const
{
    UINT dxExtent = (UINT)Command( LB_GETHORIZONTALEXTENT, 0, 0 );

    if( dxExtent == 0 )
    {
        //
        //  Win32 listboxen return a horizontal extent of 0 until
        //  it has been set with a previous WM_SETHORIZONTALEXTENT
        //  message.  If it would make life easier for the apps,
        //  we could map 0 to the actual width of the listbox window,
        //  like so:
        //
        //  dxExtent = QuerySize().QueryWidth();
        //
    }

    return dxExtent;
}


/*******************************************************************

    NAME:       LISTBOX::SetHorizontalExtent

    SYNOPSIS:   Sets the horizontal extent of the listbox.  This is the
                "virtual horizontal size" of a horizontally-scrollable
                listbox.

    ENTRY:      dxNewExtent             - The new horizontal extent
                                          (in pixels).
    HISTORY:
        KeithMo     09-Feb-1993 Created.

********************************************************************/

VOID LISTBOX::SetHorizontalExtent( UINT dxNewExtent )
{
    Command( LB_SETHORIZONTALEXTENT, (WPARAM)dxNewExtent, 0 );
}


/**********************************************************************

    NAME:       BLT_LISTBOX::BLT_LISTBOX

    SYNOPSIS:   Constructor for BLT listbox class

    ENTRY:

    EXIT:

    HISTORY:
        RustanL     13-Feb-1991 Created
        Johnl       05-Apr-1991 Added FontType parameter, made
                                default non-bold
        gregj       08-Apr-1991 Initialize two-column listbox members
        beng        17-May-1991 Added app-window constructor
        beng        17-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Removed 2-pane support
        KeithMo     17-Jan-1992 Added asserts to ensure that the listbox
                                was created with LBS_OWNERDRAW.
        beng        19-Apr-1992 Factored out LISTBOX

**********************************************************************/

BLT_LISTBOX::BLT_LISTBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          BOOL           fReadOnly,
                          enum FontType  fonttype,
                          BOOL           fIsCombo )
    : LISTBOX( powin, cid, fReadOnly, fonttype, fIsCombo ),
      _nSingleLineHeight( 0 )
{
    if ( QueryError() )
        return;

    APIERR err = CalcSingleLineHeight();
    if (err != NERR_Success)
    {
        ReportError( err );
        return;
    }
}

BLT_LISTBOX::BLT_LISTBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          XYPOINT        xy,
                          XYDIMENSION    dxy,
                          ULONG          flStyle,
                          BOOL           fReadOnly,
                          enum FontType  fonttype,
                          BOOL           fIsCombo )
    : LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype, fIsCombo ),
      _nSingleLineHeight( 0 )
{
    if ( QueryError() )
        return;

    APIERR err = CalcSingleLineHeight();
    if (err != NERR_Success)
    {
        ReportError( err );
        return;
    }
}

/**********************************************************************

   NAME:        BLT_LISTBOX::CalcSingleLineHeight

   SYNOPSIS:    (Re-)Calculate the height of a single item.  Call once
                when the listbox is constructed, and call again if
                the font is changed.

   RETURNS:     APIERR

   HISTORY:
       JonN             24-Sep-1993     Created

**********************************************************************/

APIERR BLT_LISTBOX::CalcSingleLineHeight( VOID )
{
    return (WINDOW::CalcFixedHeight( QueryHwnd(), &_nSingleLineHeight ))
                ? NERR_Success
                : ERROR_GEN_FAILURE;
}

/**********************************************************************

   NAME:        BLT_LISTBOX::CD_Measure

   SYNOPSIS:

   ENTRY:

   RETURNS:     TRUE if the message is processed, FALSE otherwise

   NOTES:

   HISTORY:
       Yi-HsinS         10-Dec-92       Created

**********************************************************************/

BOOL BLT_LISTBOX::CD_Measure( MEASUREITEMSTRUCT *pmis )
{
    UIASSERT( QueryStyle() & LBS_OWNERDRAWVARIABLE );

    LBI *plbi = QueryItem( pmis->itemID );
    UIASSERT( plbi != NULL );

    pmis->itemHeight = plbi->CalcHeight( _nSingleLineHeight );
    return TRUE;
}

/**********************************************************************

   NAME:        BLT_LISTBOX::AddItem

   SYNOPSIS:    Adds an LBI to a BLT_LISTBOX

   ENTRY:       plbi - pointer to newly created LBI

   RETURNS:     Index, or -1 if error

   NOTES:

   HISTORY:
        RustanL     13-Feb-1991 Created
        beng        20-Apr-1992 Header added

**********************************************************************/

INT BLT_LISTBOX::AddItem( LBI * plbi )
{
    if ( plbi == NULL )
        return -1;          //  Refuse to add NULL item.  This way, we can
                            //  guarantee that all items in the listbox
                            //  will be non-NULL.

    if ( plbi->QueryError() != NERR_Success )
    {
        //  Refuse to add an item that was not constructed correctly.
        //  This way, we can guarantee that all items in the listbox
        //  will be correctly constructed.
        //  Before returning, delete the item.
        //
        delete plbi;
        return -1;
    }

    INT i = AddItemData( (VOID *)plbi );
    if ( i < 0 )
    {
        //  Delete the item, since it could not be added.
        delete plbi;
    }

    return i;
}


/**********************************************************************

    NAME:       BLT_LISTBOX::AddItemIdemp

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:
        This method may delete plbi even if return is non-negative.

    HISTORY:
        RustanL         13-Feb-1991 Created

**********************************************************************/

INT BLT_LISTBOX::AddItemIdemp( LBI * plbi )
{
    if ( plbi == NULL )
        return -1;          //  Refuse to add NULL item.  This way, we can
                            //  guarantee that all items in the listbox
                            //  will be non-NULL.

    if ( plbi->QueryError() != NERR_Success )
    {
        // Refuse to add an item that was not constructed correctly.
        // This way, we can guarantee that all items in the listbox
        // will be correctly constructed.
        // Before returning, delete the item.

        delete plbi;
        return -1;
    }

    INT i = FindItem( *plbi );
    if ( i < 0 )
        return AddItem( plbi );

    // The item already exists in the list.  Therefore, delete the
    // given item, and return the index of the item in the listbox.

    delete plbi;
    return i;
}


/**********************************************************************

   NAME:        BLT_LISTBOX::InsertItem

   SYNOPSIS:    Inserts an LBI in a BLT_LISTBOX at a specific index.

   ENTRY:       i    - index for new item.

                plbi - pointer to newly created LBI

   RETURNS:     Index, or -1 if error

   NOTES:

   HISTORY:
        KeithMo     17-Dec-1992     Created.

**********************************************************************/

INT BLT_LISTBOX::InsertItem( INT i, LBI * plbi )
{
    //
    //  Refuse to insert badly constructed LBIs.
    //

    if( plbi == NULL )
    {
        return LB_ERR;
    }

    if( plbi->QueryError() != NERR_Success )
    {
        return LB_ERR;
    }

    //
    //  Insert the item into the listbox.
    //

    i = InsertItemData( i, (VOID *)plbi );

    if( i < 0 )
    {
        //
        //  Delete the LBI since we failed to insert it
        //  into the listbox.
        //

        delete plbi;
    }

    return i;
}


/**********************************************************************

   NAME:       BLT_LISTBOX::FindItem

   SYNOPSIS:   Finds an item in the listbox

   ENTRY:      lbi -        Reference to listbox item be used
                            as search criteria.  If this object
                            has an error, the search automatically
                            returns failure (negative number).

   RETURN:      The index of the item (a non-negative number), if
                found, or a negative number on failure.

   NOTES:       CODEWORK.  It is not clear if Windows makes use of the
                LBS_SORT style for owner-drawn listboxes.  Hence, the
                comparison below may not be needed.  If this is so, it is
                not clear whether or not this is documented Windows behavior
                or an error; in other words, this may change (be fixed?)
                in the future.

   HISTORY:
      RustanL   13-Feb-1991     Created
      DavidHov  10-Dec-1992     Changed to avoid Compare() when possible

**********************************************************************/

INT BLT_LISTBOX::FindItem( const LBI & lbi ) const
{
    if ( lbi.QueryError() != NERR_Success )
    {
        DBGEOL( "BLT_LISTBOX::FindItem called with invalid item" );
        return -1;
    }

    INT iLim = QueryCount();

    if ( QueryStyle() & LBS_SORT )
    {

        INT iMin = 0;

        //  Do binary search
        //  part of invariant:  0 <= iMin <= iLim <= QuerySize()
        //  bound function:     iLim - iMin

        while ( iMin < iLim )
        {
            INT i = ( iMin + iLim ) / 2;    // now, iMin <= i < iLim

            LBI * pLbiNext = QueryItem( i ) ;      // Get next item ptr

            INT nCmpResult = & lbi == pLbiNext     // Is it identical?
                           ? 0                     // Yes; else Compare().
                           : lbi.Compare( pLbiNext );

            if ( nCmpResult == 0 )
                return i;

            if ( nCmpResult < 0 )
                iLim = i;       // lbi < lb[ i ]    (this will definitely
                                //                  decrease iLim)
            else
                iMin = i + 1;   // lbi > lb[ i ]    (this will definitely
                                //                  increase iMin)
        }
    }
    else
    {
        //  Unsorted listbox.  Look for the item based on LBI pointer;
        //  failing that, use Compare() method.

        INT i ;
        for ( i = 0; i < iLim; i++ )
        {
            if ( & lbi == QueryItem( i ) )
                return i;
        }
        for ( i = 0; i < iLim; i++ )
        {
            if ( lbi.Compare( QueryItem( i )) == 0 )
                return i;
        }
    }

    return -1;      // search space exhausted; not found
}


/*******************************************************************

    NAME:       BLT_LISTBOX::ReplaceItem

    SYNOPSIS:   Replaces an LBI in the listbox with another one

    ENTRY:      i -         Valid index of item to be replaced

                plbiNew -   Pointer to new LBI.  If this is NULL,
                            it is assumed that the caller did
                            a:
                                err = lb.ReplaceItem( i, new MY_LBI(...));
                            and that the 'new' failed.  Hence,
                            this method will return ERROR_NOT_ENOUGH_MEMORY.

                pplbiOld -  Pointer to location that receives the
                            previous LBI * at position i in the
                            listbox.  A caller can pass pplbiOld as NULL
                            (its default value) to indicate a non-
                            interest in the previous value.  This
                            method will then delete the old item.

    EXIT:       On failure:  The listbox remains unchanged, plbiNew has
                been deleted, and *pplbiOld should not be used.

                On success:  Listbox item i will be *plbiNew.  If
                pplbiOld was NULL on entry, the previous listbox
                item i was deleted; if pplbiOld was non-NULL,
                *pplbiOld contains a pointer to the previous
                listbox item.

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

APIERR BLT_LISTBOX::ReplaceItem( INT i, LBI * plbiNew, LBI * * pplbiOld )
{
    if ( ! ( 0 <= i && i < QueryCount()))
    {
        DBGEOL( "BLT_LISTBOX::ReplaceItem: given invalid index" );
        return ERROR_INVALID_PARAMETER;
    }

    // Mimic the semantics of the param to AddItem for the plbiNew parameter
    if ( plbiNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY; // assume caller did a 'new'
                                        // and ran out (like AddItem)

    APIERR err = plbiNew->QueryError();
    if ( err != NERR_Success )
    {
        delete plbiNew;
        return err;
    }

    LBI * plbiOld = QueryItem( i );
    UIASSERT( plbiOld != NULL );
    if ( pplbiOld == NULL )
    {
        //  caller is not interested in previous item
        delete plbiOld;
    }
    else
    {
        //  caller wants to torture the old item
        *pplbiOld = plbiOld;
    }

    SetItem( i, plbiNew );

    return NERR_Success;
}

/*******************************************************************

    NAME:       BLT_LISTBOX::RemoveItem

    SYNOPSIS:   Removes an LBI from a listbox w/o deleting the LBI

    ENTRY:      i -         Valid index of item to be removed

    EXIT:       The item will have been removed from the listbox

    RETURNS:    A pointer to the removed LBI

    HISTORY:
        johnl     27-Oct-1992     Created

********************************************************************/

LBI * BLT_LISTBOX::RemoveItem( INT i )
{
    if ( ! ( 0 <= i && i < QueryCount()))
    {
        DBGEOL( "BLT_LISTBOX::RemoveItem: given invalid index" );
        UIASSERT( FALSE ) ;
        return NULL ;
    }

    LBI * plbiOld = QueryItem( i );
    UIASSERT( plbiOld != NULL );

    SetItem( i, NULL );
    DeleteItem( i ) ;

    return plbiOld ;
}

/*******************************************************************

    NAME:       BLT_LISTBOX::RemoveAllItems

    SYNOPSIS:   Removes all items from the listbox without deleting the LBIs

    NOTES:

    HISTORY:
        Johnl   07-Dec-1992     Created

********************************************************************/

void BLT_LISTBOX::RemoveAllItems( void )
{
    INT cItems = QueryCount() ;

    for ( ; cItems > 0 ; cItems-- )
    {
        RemoveItem( cItems-1 ) ;
    }
}

/**********************************************************************

    NAME:       BLT_LISTBOX::QueryItem

    SYNOPSIS:   Returns pointer to i'th item in listbox

    ENTRY:      Index of item sought.
                If no index supplied, returns first selected item.

    RETURNS:    LBI*, or NULL if no item selected.

    NOTES:

    HISTORY:
        RustanL     13-Feb-1991     Created
        beng        21-Aug-1991     Removed LC_CURRENT_ITEM magic value

**********************************************************************/

LBI * BLT_LISTBOX::QueryItem( INT i ) const
{
    if (i < 0)
        return NULL;

    ULONG_PTR ul = Command( LC_MSG( GETITEMDATA ), (UINT)i );
    if ( ul == (ULONG)LB_ERR )
        return NULL;

    //  CODEWORK.  Could potentially do some debug version checking to
    //  verify that ul is a pointer to a real LBI.  E.g., call virtual
    //  method QueryLeadingChar.  This gives some kind of test.

    return (LBI *)ul;
}


/*********************************************************************

    NAME:       BLT_LISTBOX::CD_Guiltt

    SYNOPSIS:   Fetches data for GUILTT from a control

    ENTRY:
        ilb     - index into the listbox (or some other subsel)
        pnlsOut - string to hold the output data

    EXIT
        pnlsOut - no doubt has been scribbled into

    RETURN:     An error code - NERR_Success if successful.

    HISTORY:
        beng            01-Jun-1992 Created
        beng            11-Jun-1992 Fix bug

*********************************************************************/

APIERR BLT_LISTBOX::CD_Guiltt( INT ilb, NLS_STR * pnlsOut )
{
    LBI * plbi = QueryItem(ilb);
    if (plbi == NULL)
        return BLT::MapLastError(ERROR_INVALID_PARAMETER);

    // Bundle all the information the Paint routine needs.
    // (This "Paint" interface, while awkward, was inherited from old BLT
    // code; it has many clients, and so would be a pain to change
    // this late in the game.)

    GUILTT_INFO ginfo;
    ginfo.pnlsOut = pnlsOut;
    ginfo.errOut = NERR_Success;

    plbi->Paint( this, 0, 0, &ginfo );
    return ginfo.errOut;
}

/**********************************************************************

    NAME:       BLT_COMBOBOX::BLT_COMBOBOX

    SYNOPSIS:   Constructor for BLT combobox class

    ENTRY:      Same as for BLT_LISTBOX

    EXIT:

    HISTORY:
        Johnl       21-Oct-1992     Created

**********************************************************************/

WNDPROC BLT_COMBOBOX::_OldCBProc = NULL ;
UINT    BLT_COMBOBOX::_cReferences = 0 ;

BLT_COMBOBOX::BLT_COMBOBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          BOOL           fReadOnly,
                          enum FontType  fonttype )
    : BLT_LISTBOX( powin, cid, fReadOnly, fonttype, TRUE )
{
    if ( QueryError() )
        return;

    if ( BLT_COMBOBOX::_OldCBProc == NULL )
        BLT_COMBOBOX::_OldCBProc = SubclassWindow( QueryHwnd(),
                                               BLT_COMBOBOX::CBSubclassProc ) ;
    BLT_COMBOBOX::_cReferences++ ;
}

BLT_COMBOBOX::BLT_COMBOBOX( OWNER_WINDOW * powin,
                          CID            cid,
                          XYPOINT        xy,
                          XYDIMENSION    dxy,
                          ULONG          flStyle,
                          BOOL           fReadOnly,
                          enum FontType  fonttype )
    : BLT_LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype, TRUE )
{
    if ( QueryError() )
        return;

    if ( BLT_COMBOBOX::_OldCBProc == NULL )
        BLT_COMBOBOX::_OldCBProc = SubclassWindow( QueryHwnd(),
                                               BLT_COMBOBOX::CBSubclassProc ) ;
    BLT_COMBOBOX::_cReferences++ ;
}

BLT_COMBOBOX::~BLT_COMBOBOX()
{
    BLT_COMBOBOX::_cReferences-- ;

    if ( BLT_COMBOBOX::_OldCBProc != NULL &&
         BLT_COMBOBOX::_cReferences == 0 )
    {
        (void) SubclassWindow( QueryHwnd(), BLT_COMBOBOX::_OldCBProc ) ;
        BLT_COMBOBOX::_OldCBProc = NULL ;
    }
}

/*******************************************************************

    NAME:       BLT_COMBOBOX::IsDropped

    SYNOPSIS:   Determines if the listbox portion of this combobox is "dropped"

    RETURNS:    TRUE if dropped, FALSE otherwise

    NOTES:      This method can be copied w/o changes to the normal combox
                class.

    HISTORY:
        Johnl   13-Dec-1992     Created

********************************************************************/

BOOL BLT_COMBOBOX::IsDropped( void ) const
{
    return (BOOL)Command( CB_GETDROPPEDSTATE ) ;
}

/*******************************************************************

    NAME:       BLT_COMBOBOX::DevCBSubclassProc

    SYNOPSIS:   Subclass procedure for device combo boxes

    ENTRY:      as a window proc

    EXIT:       as a window proc

    NOTES:
        MAJOR HACK: Windows does not have a combo box analog to
        LBS_WANTKEYBOARDINPUT, so an owner-drawn drop-down list
        does not have letter jumps.  So we subclass the window
        and simulate what Windows does for listboxes.  The only
        subclass procedure in BLT.

    HISTORY:
        gregj   24-Feb-1992     Created
        Johnl                   Converted to Win32

********************************************************************/

LRESULT WINAPI BLT_COMBOBOX::CBSubclassProc( HWND hwnd,
                                             UINT msg,
                                             WPARAM wParam,
                                             LPARAM lParam )
{
    switch (msg) {
    case WM_CHAR:
        {
            if (lParam & (1L << 31))
                break;

            INT iItem = ComboBox_GetCurSel( hwnd ) ;
            iItem = (INT) ::SendMessage( ::GetParent(hwnd),
                                         WM_CHARTOITEM,
                                         (WPARAM) MAKELONG( wParam, iItem ),
                                         (LPARAM) hwnd );

            if (iItem < 0)
                break;

            ComboBox_SetCurSel( hwnd, iItem ) ;
            break;
        }

    case WM_KEYDOWN:
        {
            INT iItem = ComboBox_GetCurSel( hwnd ) ;

            iItem = (INT) ::SendMessage( ::GetParent(hwnd),
                                         WM_VKEYTOITEM,
                                         (WPARAM) MAKELONG( wParam, iItem ),
                                         (LPARAM) hwnd );

            if (iItem < 0)
                break;

            ComboBox_SetCurSel( hwnd, iItem ) ;
            break;
        }
    }

    return CallWindowProc( BLT_COMBOBOX::_OldCBProc, hwnd, msg, wParam, lParam );
}


/**********************************************************************

    NAME:       CalcCharUpper

    SYNOPSIS:   Uppercase a character

    NOTES:
        Think of this as a Unicode/DBCS-safe "toupper"

    HISTORY:
        beng        08-Jun-1992 Created

**********************************************************************/

static inline WCHAR CalcCharUpper( WCHAR wchGiven )
{
    ULONG ul = MAKELONG(wchGiven, 0);
#if !defined(UNICODE)
    return (WCHAR) LOWORD(::AnsiUpper((TCHAR*)ul));
#else
    return (WCHAR) LOWORD(::CharUpper((TCHAR*)UIntToPtr(ul)));
#endif
}


/**********************************************************************

    NAME:       IsCharPrintable

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        beng        08-Jun-1992 Created

**********************************************************************/

static WCHAR IsCharPrintable( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) > (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK|C1_SPACE)));
#endif
}


/**********************************************************************

    NAME:       IsCharPrintableOrSpace

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        JonN        17-Aug-1992 Created

**********************************************************************/

static WCHAR IsCharPrintableOrSpace( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) >= (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK)));
#endif
}


/**********************************************************************

    NAME:       BLT_LISTBOX::CD_Char

    SYNOPSIS:   Custom-draw code to respond to a typed character

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    HISTORY:
        RustanL     13-Feb-1991 Created
        beng        20-May-1991 LBI::QueryLeadingChar now returns WCHAR
        beng        15-Oct-1991 Win32 conversion
        beng        08-Jun-1992 Locate lowercase entries correctly

**********************************************************************/

INT BLT_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    // Filter characters which won't appear in keys

    if ( ! IsCharPrintable( wch ))
        return -2;  // take no other action

    // Cache the typed character's uppercase version, for repeated
    // case-insensitive comparisons.

    WCHAR wchUpper = CalcCharUpper(wch);

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    INT iLim = nLastPos + clbi + 1;     // iLim is the first index mode clbi
                                        // that we will not look at

    for ( INT iLoop = nLastPos + 1; iLoop < iLim; iLoop++ )
    {
        LBI * plbi = QueryItem( iLoop % clbi );
        WCHAR wchLeading = plbi->QueryLeadingChar();

        if (   (wch == wchLeading)
            || (wchUpper == CalcCharUpper(wchLeading)) )
        {
            //  Return index of item, on which the system listbox should
            //  perform the default action.
            //
            return ( iLoop % clbi );
        }
    }

    //  The character was not found as a first character of any listbox item

    return -2;  // take no other action
}


/**********************************************************************

    NAME:       BLT_LISTBOX::CD_Char_HAWforHawaii

    SYNOPSIS:   Custom-draw code to respond to a typed character
                for listboxes with HAW-for-Hawaii support

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position
                phawinfo - Pointer to info buffer used internally
                           to keep track of HAW-for-Hawaii state.
                           This must have constructed successfully,
                           but the caller need not keep closer track.

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    HISTORY:
        JonN        05-Aug-1992 Created
        JonN        13-Nov-1992 Reset search on timeout; still can't
                                recognize SPACEBAR
        JonN        22-Mar-1993 Move focus to first after string if miss

**********************************************************************/

INT BLT_LISTBOX::CD_Char_HAWforHawaii( WCHAR wch,
                                       USHORT nLastPos,
                                       HAW_FOR_HAWAII_INFO * phawinfo )
{
    UIASSERT( phawinfo != NULL && phawinfo->QueryError() == NERR_Success );

    if (wch == VK_BACK)
    {
        TRACEEOL( "NETUI:HAWforHawaii: hit BACKSPACE" );
        phawinfo->_time = 0L; // reset timer
        phawinfo->_nls = SZ("");
        UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }

    // Filter characters which won't appear in keys

    if ( ! IsCharPrintableOrSpace( wch ))
        return -2;  // take no other action

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    LONG lTime = ::GetMessageTime();

#define ThresholdTime 2000

    // CODEWORK ignoring time wraparound effects for now
    if ( (lTime - phawinfo->_time) > ThresholdTime )
    {
        TRACEEOL( "NETUI:HAWforHawaii: threshold timeout" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    APIERR err = phawinfo->_nls.AppendChar( wch );
    if (err != NERR_Success)
    {
        DBGEOL( "NETUI:HAWforHawaii: could not extend phawinfo->_nls" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );

    TRACEEOL(   "NETUI:HAWforHawaii: phawinfo->_nls is \""
             << phawinfo->_nls.QueryPch()
             << "\"" );

    phawinfo->_time = lTime;

    INT nReturn = -2; // take no other action

    for ( INT iLoop = nLastPos; iLoop < clbi; iLoop++ )
    {
        LBI * plbi = QueryItem( iLoop );

        INT nCompare = plbi->Compare_HAWforHawaii( phawinfo->_nls );

        if ( nCompare == 0 )
        {
            TRACEEOL( "NETUI:HAWforHawaii: found match" );

            //  Return index of item, on which the system listbox should
            //  perform the default action.
            //
            TRACEEOL( "NETUI:HAWforHawaii: match at " << iLoop );
            return ( iLoop );
        }
        else if ( nCompare < 0 )
        {
            if ( nReturn < 0 )
                nReturn = iLoop;
        }
    }

    //  The character was not found as a leading prefix of any listbox item

    if (nReturn == -2)
    {
        nReturn = clbi-1;
        TRACEEOL(
            "NETUI:HAWforHawaii: no exact or subsequent match, returning last item "
            << nReturn );
    }
    else
    {
        TRACEEOL(
            "NETUI:HAWforHawaii: no exact match, returning subsequent match "
            << nReturn );
    }

    return nReturn;
}


/**********************************************************************

    NAME:       BLT_LISTBOX::RequestLBI

    SYNOPSIS:   Determine LBI from draw-item information

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

LBI * BLT_LISTBOX::RequestLBI( const DRAWITEMSTRUCT * pdis )
{
    return (LBI *)pdis->itemData;
}


/**********************************************************************

    NAME:       BLT_LISTBOX::ReleaseLBI

    SYNOPSIS:   Dispose of LBI* from RequestLBI

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

VOID BLT_LISTBOX::ReleaseLBI( LBI * plbi )
{
    UNREFERENCED(plbi);
}


/**********************************************************************

    NAME:       BLT_LISTBOX_HAW::BLT_LISTBOX_HAW

    SYNOPSIS:   Constructor for BLT listbox class with HAW-for-Hawaii

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

**********************************************************************/

BLT_LISTBOX_HAW::BLT_LISTBOX_HAW( OWNER_WINDOW * powin,
                                  CID            cid,
                                  BOOL           fReadOnly,
                                  enum FontType  fonttype,
                                  BOOL           fIsCombo )
    : BLT_LISTBOX( powin, cid, fReadOnly, fonttype, fIsCombo ),
    _hawinfo()
{
    if ( QueryError() )
        return;

    APIERR err = _hawinfo.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

BLT_LISTBOX_HAW::BLT_LISTBOX_HAW( OWNER_WINDOW * powin,
                                  CID            cid,
                                  XYPOINT        xy,
                                  XYDIMENSION    dxy,
                                  ULONG          flStyle,
                                  BOOL           fReadOnly,
                                  enum FontType  fonttype,
                                  BOOL           fIsCombo )
    : BLT_LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype, fIsCombo ),
    _hawinfo()
{
    if ( QueryError() )
        return;

    APIERR err = _hawinfo.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/**********************************************************************

    NAME:       BLT_LISTBOX_HAW::CD_Char

    SYNOPSIS:   Custom-draw code to respond to a typed character

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

**********************************************************************/

INT BLT_LISTBOX_HAW::CD_Char( WCHAR wch, USHORT nLastPos )
{
    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo );
}






#if defined(WIN32)
/**********************************************************************

    NAME:       LAZY_LISTBOX::LAZY_LISTBOX

    SYNOPSIS:   Constructor for BLT no-data listbox class

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

LAZY_LISTBOX::LAZY_LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fReadOnly,
    enum FontType  fonttype )
    : LISTBOX( powin, cid, fReadOnly, fonttype )
{
    if ( QueryError() )
        return;

    ASSERT( QueryStyle() & LBS_NODATA );
}

LAZY_LISTBOX::LAZY_LISTBOX(
    OWNER_WINDOW * powin,
    CID            cid,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    BOOL           fReadOnly,
    enum FontType  fonttype )
    : LISTBOX( powin, cid, xy, dxy, flStyle, fReadOnly, fonttype )
{
    if ( QueryError() )
        return;

    ASSERT( flStyle & LBS_NODATA );
}


/**********************************************************************

    NAME:       LAZY_LISTBOX::RequestLBI

    SYNOPSIS:   Determine LBI from draw-item information

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

LBI * LAZY_LISTBOX::RequestLBI( const DRAWITEMSTRUCT * pdis )
{
    return OnNewItem( pdis->itemID );
}


/**********************************************************************

    NAME:       LAZY_LISTBOX::ReleaseLBI

    SYNOPSIS:   Dispose of LBI* from RequestLBI

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

VOID LAZY_LISTBOX::ReleaseLBI( LBI * plbi )
{
    OnDeleteItem( plbi );
}

/**********************************************************************

    NAME:       LAZY_LISTBOX::OnDeleteItem

    SYNOPSIS:   Dispose of LBI* from RequestLBI

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS     20-Apr-1992 Created

**********************************************************************/

VOID LAZY_LISTBOX::OnDeleteItem( LBI * plbi )
{
    delete plbi;
}

/**********************************************************************

    NAME:       LAZY_LISTBOX::SetCount

    SYNOPSIS:   Set (or reset) the number of lines in a lazy listbox

    ENTRY:
        clbi    - New number of lines in the listbox

    HISTORY:
        beng        20-Apr-1992 Created

**********************************************************************/

VOID LAZY_LISTBOX::SetCount( UINT clbi )
{
    Command( LB_SETCOUNT, (WPARAM)clbi );
}


/*********************************************************************

    NAME:       LAZY_LISTBOX::CD_Guiltt

    SYNOPSIS:   Fetches data for GUILTT from a control

    ENTRY:
        ilb     - index into the listbox (or some other subsel)
        pnlsOut - string to hold the output data

    EXIT
        pnlsOut - no doubt has been scribbled into

    RETURN:     An error code - NERR_Success if successful.

    HISTORY:
        beng            01-Jun-1992 Created
        beng            11-Jun-1992 Fix bug
        KeithMo         21-Sep-1992 Fixed bug.

*********************************************************************/

APIERR LAZY_LISTBOX::CD_Guiltt( INT ilb, NLS_STR * pnlsOut )
{
    LBI * plbi = OnNewItem(ilb);
    if (plbi == NULL)
        return BLT::MapLastError(ERROR_INVALID_PARAMETER);

    // Bundle all the information the Paint routine needs.
    // (This "Paint" interface, while awkward, was inherited from old BLT
    // code; it has many clients, and so would be a pain to change
    // this late in the game.)

    GUILTT_INFO ginfo;
    ginfo.pnlsOut = pnlsOut;
    ginfo.errOut = NERR_Success;

    plbi->Paint( this, 0, 0, &ginfo );

//    delete plbi;
    OnDeleteItem( plbi );
    return ginfo.errOut;
}


#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlbi.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltlbi.cxx
    BLT owner-draw listboxes: implementation of owner-draw methods

    FILE HISTORY:
        RustanL     21-Feb-1991 Moved classes from bltlb.cxx
        rustanl     22-Mar-1991 Rolled in code review changes
                                from CR on 20-Mar-1991, attended by
                                JimH, GregJ, Hui-LiCh, RustanL.
        gregj       08-Apr-1991 Reintegrating caching listbox
        beng        14-May-1991 Exploded blt.hxx into components
        gregj       17-May-1991 Return correct error code to GUILTT
        beng        20-May-1991 Added OnDeleteItem, OnCompareItem
        beng        07-Nov-1991 Excised 2-pane listbox support
        beng        21-Apr-1992 BLT_LISTBOX -> LISTBOX
        Yi-HsinS    10-Dev-1992 Added support for variable size LBI in listbox
*/

#include "pchblt.hxx"   // Precompiled header

#if defined(TRACE)
// Trace methods

DBGSTREAM & operator << (DBGSTREAM &out, const RECT &rect)
{
    out << TCH('(') << rect.top  << SZ(", ") << rect.bottom << SZ(", ")
               << rect.left << SZ(", ") << rect.right  << TCH(')') ;

    return out;
}

#endif

void MLTextPaint( HDC hdc, const TCHAR * pch, const RECT * prect );

/*******************************************************************

    NAME:       DTE::QueryLeftMargin

    SYNOPSIS:   Returns the amount of space that a DTE desires
                to be left blank to its left.

    RETURNS:    The said left margin

    NOTES:
        This is a virtual member function.

        The return value of this method is used as follows:

        A display table calculates an original rectangle
        based on the column width of the current column

        The display table calls this method to find the
        left margin

        The left margin is added to the left margin of the
        original rectangle.  This creates the clipping
        rectangle.  (Well, almost.  Remember that DTE's
        are responsible for not drawing outside the
        rectangle passed to their Paint methods.)

        The clipping rectangle is passed to the DTE's
        Paint method.

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

UINT DTE::QueryLeftMargin() const
{
    return DISP_TBL_COLUMN_DELIM_SIZE;
}


/**********************************************************************

    NAME:       DM_DTE::DM_DTE

    SYNOPSIS:   Construct display-map DTE

    HISTORY:
        rustanl     21-Feb-1991     Creation

**********************************************************************/

DM_DTE::DM_DTE( DISPLAY_MAP * pdm )
    : _pdm( pdm )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pdm != NULL );
    UIASSERT( pdm->QueryError() == NERR_Success );
}

DM_DTE::DM_DTE()
    : _pdm( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    // Note: this form of the ctor is protected.  When used, the ctor
    // of the derived class must call SetPdm to properly complete this
    // object.
}


/**********************************************************************

    NAME:       DM_DTE::SetPdm

    SYNOPSIS:   Set display map for semi-constructed DTE

    ENTRY:      pdm - pointer to display map

    HISTORY:
        rustanl     21-Feb-1991     Creation

**********************************************************************/

VOID DM_DTE::SetPdm( DISPLAY_MAP * pdm )
{
    //  This is a protected method intended to be used with the protected
    //  constructor.  See it for more info.

    UIASSERT( pdm != NULL );
    UIASSERT( pdm->QueryError() == NERR_Success );
    _pdm = pdm;
}


/**********************************************************************

    NAME:       DM_DTE::Paint

    SYNOPSIS:   Render a display-map DTE in the listbox

    ENTRY:      hdc     - display context for screen
                prect   - pointer to rectangle of current line

    NOTES:
        This is a virtual member function.

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        10-Jul-1991 Centers its bitmap in the line
        beng        04-Oct-1991 Const parms
        beng        07-Nov-1991 Unsigned widths
        beng        15-Jun-1992 Call through to DISPLAY_MAP::Paint

**********************************************************************/

VOID DM_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    if ( _pdm == NULL )
        return;

    // Center bitmap in line.  Otherwise it appears to cling
    // to the top of the listbox row.
    //
    // CODEWORK: Calculate this and cache it in a persistent place.
    //
    const UINT cyHeight = prect->bottom - prect->top + 1;
    UINT dyCentering = 0;
    if ( NETUI_IsDBCS() )
    {
        // When System12Pt, BitmapHeight is larger than Listbox Height.
        const UINT lHeight = _pdm->QueryHeight();
        if( cyHeight > lHeight )
        {
            dyCentering = (cyHeight - lHeight) / 2;
        }
    }
    else
    {
        dyCentering = (cyHeight - _pdm->QueryHeight()) / 2;
    }

    _pdm->Paint(hdc, prect->left, prect->top+dyCentering);
}


/**********************************************************************

    NAME:       DM_DTE::AppendDataTo

    SYNOPSIS:   Returns information for GUILTT

    ENTRY:      pnlsOut - destination string

    EXIT:       Recipient string has appended to it a string rep of DM ID#

    RETURNS:    Error code

    NOTES:
        This is a virtual member function.

    HISTORY:
        gregj       01-May-1991 Created
        beng        23-Oct-1991 Win32 conversion
        beng        05-Mar-1992 Unicode fix
        beng        01-Jun-1992 GUILTT changes

**********************************************************************/

APIERR DM_DTE::AppendDataTo( NLS_STR * pnlsOut ) const
{
    DEC_STR nlsFormat((UINT)(_pdm->QueryID()));
    if (!nlsFormat)
        return nlsFormat.QueryError();

    return pnlsOut->Append(nlsFormat);
}


/*******************************************************************

    NAME:       DM_DTE::QueryDisplayWidth

    SYNOPSIS:   Returns the width (including left margin) that the DTE
                will require in order to be displayed in full

    RETURNS:    Said width

    HISTORY:
        rustanl     03-Sep-1991 Created
        beng        07-Nov-1991 Unsigned widths

********************************************************************/

UINT DM_DTE::QueryDisplayWidth() const
{
    UIASSERT( _pdm != NULL );

    return QueryLeftMargin() + _pdm->QueryWidth();
}


/**********************************************************************

    NAME:       DMID_DTE::DMID_DTE

    SYNOPSIS:   Construct DTE from a DMID (as opposed to a pre-existing DM)

    ENTRY:      dmid - ID of display map

    EXIT:

    NOTES:
        This DTE is unusual in that it may fail construction.  It
        forces all DTEs to inherit from BASE.

    HISTORY:
        rustanl     21-Feb-1991     Creation
        beng        10-Jul-1991     Add error checking for DISPLAY_MAP

**********************************************************************/

DMID_DTE::DMID_DTE( DMID dmid )
    : _dm( dmid )
{
    if (!_dm)
    {
        ReportError(_dm.QueryError());
        return;
    }

    SetPdm( &_dm );
}


/**********************************************************************

    NAME:       STR_DTE::AppendDataTo

    SYNOPSIS:   Returns information for GUILTT

    ENTRY:      pnlsOut - a destination string

    EXIT:       DTE's string is appended to the recipient string

    RETURNS:    Error code

    NOTES:
        This is a virtual member function.

    HISTORY:
        gregj       01-May-1991 Created
        beng        04-Oct-1991 Win32 conversion; Unicode fix
        beng        05-Mar-1992 Slight correction
        beng        01-Jun-1992 GUILTT changes

**********************************************************************/

APIERR STR_DTE::AppendDataTo( NLS_STR *pnlsOut ) const
{
    return pnlsOut->Append(_pch);
}


/**********************************************************************

    NAME:       STR_DTE::Paint

    SYNOPSIS:   Paint a text-only listbox element

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        20-May-1991 _pch element made const
        beng        10-Jul-1991 Centers text within line; remove
                                bogus xOrigin parm
        beng        04-Oct-1991 Const parms
        beng        07-Nov-1991 Unsigned width
        beng        05-May-1992 API changes
        beng        18-May-1992 Work around 1.265 bug
        Yi-HsinS    10-Dec-1992 Delete work around 1.265 bug

**********************************************************************/

VOID STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    if ( _pch == NULL )
        return;

    DEVICE_CONTEXT dc( hdc );

    // Center string in line.  Otherwise it appears to cling
    // to the top of the listbox row.
    //
    // CODEWORK: Cache dyCentering - too expensive to calc each time.
    //
    UINT cyHeight = prect->bottom - prect->top + 1;

    // Centering delta must be signed, since it can adjust the top of
    // the draw rectangle either way.
    //
    INT dyCentering = ((INT)cyHeight - dc.QueryFontHeight()) / 2;

    BOOL fSuccess = dc.TextOut( _pch, ::strlenf(_pch),
                                prect->left, prect->top + dyCentering,
                                prect );

#if defined(DEBUG)
    if (!fSuccess)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGOUT("BLT: TextOut in LB failed, err = " << err);
    }
#endif
}

/**********************************************************************

    NAME:       MULTILINE_STR_DTE::Paint

    SYNOPSIS:   Paint a multiline text-only listbox element

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    10-Dec-1992 Created

**********************************************************************/

VOID MULTILINE_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    MLTextPaint( hdc, QueryPch(), prect);
}

/**********************************************************************

    NAME:       COUNTED_STR_DTE::Paint

    SYNOPSIS:   Paint a text-only listbox element

    NOTES:
        This is a virtual member function.

    HISTORY:
        KeithMo         15-Dec-1992     Created

**********************************************************************/

VOID COUNTED_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    if ( QueryPch() == NULL )
        return;

    DEVICE_CONTEXT dc( hdc );

    // Center string in line.  Otherwise it appears to cling
    // to the top of the listbox row.
    //
    // CODEWORK: Cache dyCentering - too expensive to calc each time.
    //
    UINT cyHeight = prect->bottom - prect->top + 1;

    // Centering delta must be signed, since it can adjust the top of
    // the draw rectangle either way.
    //
    INT dyCentering = ((INT)cyHeight - dc.QueryFontHeight()) / 2;

    BOOL fSuccess = dc.TextOut( QueryPch(), QueryCount(),
                                prect->left, prect->top + dyCentering,
                                prect );

#if defined(DEBUG)
    if (!fSuccess)
    {
        APIERR err = BLT::MapLastError(ERROR_GEN_FAILURE);
        DBGOUT("BLT: TextOut in LB failed, err = " << err);
    }
#endif
}

/**********************************************************************

    NAME:       OWNER_DRAW_STR_DTE::Paint

    SYNOPSIS:   Paint a text-only listbox element

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    23-Dec-1992 Created

**********************************************************************/

VOID OWNER_DRAW_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    MLTextPaint(hdc, QueryPch(), prect);
}

/**********************************************************************

    NAME:       OWNER_DRAW_DMID_DTE::Paint

    SYNOPSIS:   Paint a display map centered according to _nDy

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    23-Dec-1992 Created

**********************************************************************/

VOID OWNER_DRAW_DMID_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    DISPLAY_MAP *pdm = QueryDisplayMap();

    pdm->Paint(hdc, prect->left, prect->top+_nDy );
}

/**********************************************************************

    NAME:       OWNER_DRAW_MULTILINE_STR_DTE::Paint

    SYNOPSIS:   Paint a multiline text-only listbox element according to _nDy

    ENTRY:

    EXIT:

    NOTES:
        This is a virtual member function.

    HISTORY:
        Yi-HsinS    23-Dec-1992 Created

**********************************************************************/

VOID OWNER_DRAW_MULTILINE_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
    MLTextPaint(hdc, QueryPch(), prect);
}

/**********************************************************************

    NAME:       ::MLTextPaint

    SYNOPSIS:   Multi-Line text paint function.  Centers the text on the given
                line.

    NOTES:

    HISTORY:
        Johnl     10-Jun-1994    Created

**********************************************************************/

void MLTextPaint( HDC hdc, const TCHAR * pch, const RECT * prect )
{
    if ( pch == NULL )
        return;

    ALIAS_STR nls( pch );
    DEVICE_CONTEXT dc(hdc);

    // Calculate the height of the rect
    INT cyHeight = prect->bottom - prect->top + 1;

    RECT rect = *prect;

    // Calculate the height of the given string
    INT nHeight = dc.DrawText( nls, &rect,
                  DT_CALCRECT | DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX );

    // Center string in line only if the rect is big enough.
    // Otherwise it appears to cling to the top of the listbox row.

    if ( cyHeight > nHeight )
        ((RECT *) prect)->top += ( cyHeight - nHeight ) / 2;

    dc.DrawText( nls, (RECT *) prect,
                 DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX );
}

/**********************************************************************

    NAME:       DISPLAY_TABLE::DISPLAY_TABLE

    SYNOPSIS:   Construct table of columns

    ENTRY:      cdxColumns    - number of columns
                pdxColWidth - array of widths

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        07-Nov-1991 Unsigned width

**********************************************************************/

DISPLAY_TABLE::DISPLAY_TABLE( UINT cdxColumns, const UINT * pdxColWidth )
    : _cdx(cdxColumns),
      _pdxColWidth(pdxColWidth)
{
    ASSERT( cdxColumns <= MAX_DISPLAY_TABLE_ENTRIES );

    for ( UINT i = 0; i < _cdx; i++ )
        _apdte[ i ] = NULL;
}


/*******************************************************************

    NAME:       DISPLAY_TABLE::CalcColumnWidths

    SYNOPSIS:   This method builds the column width table
                used by the LBI::Paint() method.

    ENTRY:
        adx             - An array of integers where the
                          column width table will be stored.
        cdx             - the number of columns in the listbox.
        pwndOwner       - pointer to the window owning the listbox.
        cidListbox      - The CID of the BLT_LISTBOX.
        fHaveIcon       - set if the listbox contains an icon
                          in its first column.

    EXIT:
        The column width table is calculated and stored in adx[].

    RETURNS:
        Error code.  NERR_Success if all's well.

    NOTES:
        This is a static member function.

        This code makes certain assumptions about the CID
        ordering for the target listbox.  The cidListbox parameter
        specifies the CID of the listbox.  Each listbox column
        must have a static text header.  These static text
        control windows must have sequential CIDs starting with
        cidListbox+1.

    HISTORY:
        KeithMo     ??-???-???? Created for the Server Manager.
        KeithMo     28-Aug-1991 Globbed into the SERVER_UTILITY class.
        ChuckC      09-Oct-1991 Stole and moved to APPLIB.
        beng        08-Nov-1991 Adapted from OPEN_LBOX_BASE::
                                BuildColumnWidthTable, and integrated
                                into BLT

********************************************************************/

APIERR DISPLAY_TABLE::CalcColumnWidths( UINT *        adx,
                                        UINT          cdx,
                                        OWNER_WINDOW *pwndOwner,
                                        CID           cidListbox,
                                        BOOL          fHaveIcon)
{
    ASSERT( adx != NULL );
    ASSERT( pwndOwner != NULL);

    //  If have icon, record the starting x position of the listbox.
    //  and use this as reference. If no icon we use the first column
    //  as reference.

    CID cidOrigin = fHaveIcon ? cidListbox : cidListbox + 1;
    HWND hwndOwner = pwndOwner->QueryHwnd();
    HWND hwndItem = ::GetDlgItem( hwndOwner, cidOrigin );
    BOOL bMirrordOwner = (GetWindowLongPtr(hwndOwner, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) != 0;
    if (hwndItem == NULL)
    {
        DBGEOL("Can't find control " << cidOrigin);
        return BLT::MapLastError(ERROR_GEN_FAILURE);
    }

    //  This will be used during several invocations of
    //  GetWindowRect().  Remember that GetWindowRect()
    //  returns *screen* coordinates!

    RECT rect;
    ::GetWindowRect( hwndItem, &rect );

    // If the owner is mirrored use Window coordinates!
    if (bMirrordOwner)
    {
        MapWindowPoints(NULL, hwndOwner, (LPPOINT)&rect, 2);
    }

    INT xPrevious = rect.left;
    CID cidNext = cidOrigin + 1;

    //  Now, scan through the cid array.  For each cid, determine
    //  the distance between the current position and the cid window.

    for ( UINT i = 0; i < cdx - 1; i++ )
    {
        //  Retrieve the starting x position of the current control
        //  window.

        hwndItem = ::GetDlgItem( hwndOwner, cidNext++ );
        UIASSERT( hwndItem != NULL );
        ::GetWindowRect( hwndItem, &rect );
        if (bMirrordOwner)
        {
            MapWindowPoints(NULL, hwndOwner, (LPPOINT)&rect, 2);
        }
        INT xCurrent = rect.left;

        //  The delta between the current position and the previous
        //  position is the current column width.

        adx[i] = xCurrent - xPrevious;

        //  The current position will become our next previous position.

        xPrevious = xCurrent;
    }

    //  The last column always has a value of COL_WIDTH_AWAP
    //  (As Wide As Possible).

    adx[i] = COL_WIDTH_AWAP;

    return NERR_Success;
}


/**********************************************************************

    NAME:       DISPLAY_TABLE::Paint

    SYNOPSIS:   Paints the COLUMN_DISPLAY_TABLE

    ENTRY:      plb -       Pointer to listbox in which listbox item
                            is to be painted.  If not in a listbox
                            (say, a column header), pass NULL.

                hdc -       Device context handle to be used
                prect -     Pointer to rectangle to be used for paint
                            (is usually the entire client rectangle)
                pGUILTT -   Pointer to GUILTT information (listbox
                            painting only)

    EXIT:

    NOTES:
        The first version of Paint calls the other after
        handling GUILTT support.

    HISTORY:
        rustanl     21-Feb-1991 Creation
        gregj       08-Apr-1991 Added two-column listbox support
        gregj       01-May-1991 Added GUILTT support
        rustanl     22-Jul-1991 Added generic paint support (for painting
                                areas other than listbox items)
        beng        04-Oct-1991 Const parms
        beng        07-Nov-1991 Removed 2-pane support
        beng        14-Feb-1992 Unicode fix
        beng        21-Apr-1992 BLT_LISTBOX -> LISTBOX
        beng        01-Jun-1992 GUILTT changes

**********************************************************************/

VOID DISPLAY_TABLE::Paint( LISTBOX *     plb,
                           HDC           hdc,
                           const RECT *  prect,
                           GUILTT_INFO * pginfo ) const
{
    // If this is a fake paint call from a WM_GUILTT message,
    // walk the display table storing information in the buffer.
    // This is done before the UIASSERTs below because "hdc", in
    // particular, will be NULL in this case.

    if (pginfo != NULL)
    {
        NLS_STR * pnlsOut = pginfo->pnlsOut;
        APIERR err = pnlsOut->QueryError();

        if (err != NERR_Success)
        {
            pginfo->errOut = err;
            return;
        }

        ASSERT(pnlsOut->strlen() == 0); // Should be a fresh string
        ASSERT(pginfo->errOut == NERR_Success);

        // Process each entry, breaking out on a failure.
        //
        for ( UINT i = 0; i < _cdx; i++ )
        {
            DTE * pdte = _apdte[ i ];
            if ( pdte == NULL )
                continue;

            err = pdte->AppendDataTo(pnlsOut);
            if (err != NERR_Success)
            {
                pginfo->errOut = err;
                break;
            }

            if (i < _cdx - 1) // Fields are tab-separated
            {
                err = pnlsOut->AppendChar(TCH('\t'));
                if (err != NERR_Success)
                {
                    pginfo->errOut = err;
                    break;
                }
            }
        }

        return;
    }

    // Call through to other version to do the painting work

    Paint(plb, hdc, prect);
}


VOID DISPLAY_TABLE::Paint( LISTBOX *     plb,
                           HDC           hdc,
                           const RECT *  prect ) const
{
    UIASSERT( hdc != NULL );
    UIASSERT( prect != NULL );

    // Paint each column.
    // Note that coordinates are signed, while displacements are unsigned.

    UINT dxScrollHorizontal = (plb == NULL) ? 0 : plb->QueryScrollPos();

    INT xLim = prect->right+dxScrollHorizontal;
    INT xLeft = prect->left+dxScrollHorizontal;

    for ( UINT i = 0; i < _cdx; i++ )
    {
        // The x coordinate of the next column is the current column's
        // x coordinate plus the width of the current column.  The width of
        // the current column is specified by a value in the _pdxColWidth
        // array.  The last column always stretches to the end of the pane,
        // regardless of its given column width.  The calculation of
        // xNextLeft is modified accordingly for these columns.

        INT xNextLeft;

        if ( i == _cdx - 1 )
            xNextLeft = xLim;
        else
            xNextLeft = xLeft + _pdxColWidth[ i ];

        // Retrieve a pointer to the display table entry of the current
        // column.

        DTE * pdte = _apdte[i];

        // Note: the left margin is taken from *within* the column.
        // This way, a client can easily use 0-width columns.

        if ( pdte != NULL )
            xLeft += pdte->QueryLeftMargin();

        // If this column falls outside the right edge of the given rect,
        // all remaining columns will, too.  Therefore, simply break out
        // of the loop.

        if ( xLeft >= xLim )
            break;

        // If the column has any contents, and it is visible somewhere
        // within the window, paint it.

        if ( pdte != NULL && xLeft < xNextLeft )
        {
            RECT rect;
            rect.left = xLeft;
            rect.top = prect->top;
            rect.right = xNextLeft;
            rect.bottom = prect->bottom;

            if ( ::RectVisible ( hdc, &rect ) )
                pdte->Paint( hdc, &rect );
        }

        xLeft = xNextLeft;
    }
}


/**********************************************************************

    NAME:       DISPLAY_TABLE::operator[]

    SYNOPSIS:   Return an element in the display table

    ENTRY:      i - index within the table

    RETURNS:    Pointer to a DTE (display table element)

    HISTORY:
        rustanl     21-Feb-1991 Creation
        beng        07-Nov-1991 Unsigned arg

**********************************************************************/

DTE * & DISPLAY_TABLE::operator[]( UINT i )
{
    UIASSERT( i < _cdx );

    return _apdte[ i ];
}


/**********************************************************************

    NAME:       LBI::LBI

    SYNOPSIS:   Constructor for listbox-item base

    NOTES:
        This base implementation does nothing

    HISTORY:
        rustanl     21-Feb-1991 Creation

**********************************************************************/

LBI::LBI()
{
    //  do nothing
}


/**********************************************************************

    NAME:       LBI::~LBI

    SYNOPSIS:   Destructor for listbox-item base

    NOTES:
       The LBI destructor is virtual.

    HISTORY:
       rustanl     21-Feb-1991 Creation

**********************************************************************/

LBI::~LBI()
{
    //  do nothing
}

/**********************************************************************

    NAME:       LBI::CalcHeight

    SYNOPSIS:   Called to find out the height of the LBI.

    ENTRY:      nSingleLineHeight - Contains the height of a single-line item

    RETURN:

    NOTES:
        This is a virtual method.
        This is the default implementation of CalcHeight.
        All LBIs contained in owner draw variable listbox/combo needs
        to redefine this method if they have items more than one line.

    HISTORY:
        Yi-HsinS     10-Dec-1992     Created

**********************************************************************/

UINT LBI::CalcHeight( UINT nSingleLineHeight )
{
    return nSingleLineHeight;
}

/**********************************************************************

    NAME:       LBI::Paint

    SYNOPSIS:   Paint a listbox entry

    ENTRY:
        plb     - pointer to host listbox
        hdc     - current hdc
        prect
        pGUILTT - pointer to testing-information output buffer.
                  NULL if not testing

    EXIT:

    NOTES:

    HISTORY:
        rustanl     21-Feb-1991 Creation
        gregj       01-May-1991 Added GUILTT support
        beng        04-Oct-1991 Const parms
        beng        21-Apr-1992 BLT_LISTBOX -> LISTBOX

**********************************************************************/

VOID LBI::Paint( LISTBOX *     plb,
                 HDC           hdc,
                 const RECT *  prect,
                 GUILTT_INFO * pginfo ) const
{
    //  This is the default implementation of the virtual LBI::Paint
    //  method.  It does nothing.

    UNREFERENCED( plb );
    UNREFERENCED( hdc );
    UNREFERENCED( prect );
    UNREFERENCED( pginfo );
}


/**********************************************************************

    NAME:       LBI::Compare

    SYNOPSIS:   Called to compare two LBI items.

       LBI subclasses are responsible for casting the plbi parameter to
       the appropriate type.  Since several LBI subclassed objects may
       be found in the same listbox, BLT cannot guarantee that the
       parameter is of the same type as the object which is being called.
       BLT will guarantee, however, that the Compare method will only get
       called for objects that are indeed in the same listbox (or an object
       passed to the Find or AddItemIdemp methods of the same listbox).

    ENTRY:

    RETURN:
       The return value of Compare is similar to that of strcmp.  It should
       be:
          negative    if *this < *plbi
          0          if *this == *plbi
          positive    if *this > *plbi

    NOTES:
        This is a virtual method.

    HISTORY:
        rustanl     21-Feb-1991     Creation

**********************************************************************/

INT LBI::Compare( const LBI * plbi ) const
{
    //  This is the default implementation of Compare.  Since the base LBI
    //  object does not contain any private members, this method has nothing
    //  to compare.  Instead, simply return 0.

    UNREFERENCED( plbi );

    return 0;
}


/**********************************************************************

    NAME:       LBI::Compare_HAWforHawaii

    SYNOPSIS:   Called to compare an LBI item to a text prefix string.

       This method is ordinarily called only by
       BLT_LISTBOX::CD_Char_HAWforHawaii, which uses it to check whether
       a particular LBI matches a text prefix.  Listboxes which use
       CD_Char_HAWforHawaii are expected to redefine this method in
       the appropriate LBI class(es).

    ENTRY:

    RETURN:
       The return value of Compare is similar to that of strcmp.  It should
       be:
          negative    if *this < *plbi
          0          if *this == *plbi
          positive    if *this > *plbi

    NOTES:
        This is a virtual method.

    HISTORY:
        jonn        05-Aug-1992     HAW-for-Hawaii support

**********************************************************************/

INT LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    //  This is the default implementation of Compare_HAwforHawaii.
    // Since the base LBI object does not contain any private members,
    // this method has nothing to compare.  Instead, simply return 0.

    UNREFERENCED( nls );

    TRACEEOL(   SZ("NETUI: Default LBI::Compare_HAWforHawaii(\"")
             << nls
             << SZ("\") called") );

    return 0;
}


/**********************************************************************

    NAME:       LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item.
                This enables short-cut keys in the listbox.

    RETURN:     The leading character of the listbox item.

    NOTES:
        This is a virtual method which may be replaced in subclasses.

        CODEWORK - need to generalize

    HISTORY:
        rustanl     21-Feb-1991     Creation
        beng        20-May-1991     Returns WCHAR

**********************************************************************/

WCHAR LBI::QueryLeadingChar() const
{
    return TCH('\0');
}


/*******************************************************************

    NAME:       LBI::OnDeleteItem

    SYNOPSIS:   Response to WM_DELETEITEM message

    ENTRY:      wParam, lParam - as per winproc

    EXIT:

    NOTES:
        This is a static member function.

        The WM_DELETEITEM message may be sent during the DestroyWindow
        call.  At this point, DIALOG_WINDOW::HwndToWinPtr would always
        return NULL; fortunately we keep enough information around
        to clean up w/o that pointer.

    HISTORY:
        beng        20-May-1991     Created (from BltDlgProc code)
        kevinl      04-Nov-1991     Added the ability to override the
                                    destruction of the LBI.
        KeithMo     29-Oct-1992     Sanity check pointer before deleting.

********************************************************************/

VOID LBI::OnDeleteItem( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED(wParam);

    //  This message should only be called for deleting LBI objects.
    //
    UIASSERT( (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_LISTBOX) ||
              (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_COMBOBOX)  );

    //  Note.  Although the listbox AddItem methods attempt
    //  to ensure that NULL is never added as a listbox item,
    //  this function must not assume that plbi is non-NULL.
    //  (See LISTBOX::DeleteAllItems for more info).
    //  Either way, this doesn't really matter here, because
    //  'delete'-ing a NULL pointer is always valid (even for
    //  a pointer to a type with a virtual destructor, as is
    //  the case here).
    //
    LBI * plbi = (LBI *)((DELETEITEMSTRUCT *)lParam)->itemData;

    if( HIWORD( (ULONG_PTR)plbi ) != 0 )
    {
        if ( plbi->IsDestroyable() )
             delete plbi;
    }
}


/*******************************************************************

    NAME:       LBI::IsDestroyable

    SYNOPSIS:   This is called by LBI::OnDeleteItem.  This method
                returns a BOOL.  If TRUE is returned, then the
                LBI is deleted.  Otherwise, the LBI is not destructed.

    HISTORY:
        kevinl      04-Nov-1991     Created.

********************************************************************/

BOOL LBI::IsDestroyable()
{
    return TRUE;
}


/*******************************************************************

    NAME:       LBI::OnCompareItem

    SYNOPSIS:   Response to WM_COMPAREITEM message

    ENTRY:      wParam, lParam - as per winproc

    EXIT:

    RETURNS:

    NOTES:
        This is a static member function.

    HISTORY:
        beng        20-May-1991     Created (from BltDlgProc code)

********************************************************************/

INT LBI::OnCompareItem( WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED(wParam);

    //  This message should only be called for comparing LBI objects.
    //
    UIASSERT( (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_LISTBOX) ||
              (((DELETEITEMSTRUCT *)lParam)->CtlType == ODT_COMBOBOX)  );

    LBI * plbi0 = (LBI *)((COMPAREITEMSTRUCT *)lParam)->itemData1;
    LBI * plbi1 = (LBI *)((COMPAREITEMSTRUCT *)lParam)->itemData2;

    if ( plbi0 == NULL )
        return -1;
    if ( plbi1 == NULL )
        return 1;

    return plbi0->Compare( plbi1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlbsrt.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlbsrt.cxx
    BLT_LISTBOX::Resort method, et al.


    FILE HISTORY:
	rustanl     01-Jul-1991     Created
	rustanl     12-Jul-1991     Added to BLT
	rustanl     15-Jul-1991     Code review changes (comment changes).
				    CR attended by BenG, ChuckC, JimH,
				    Hui-LiCh, TerryK, RustanL.

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:	BLT_LISTBOX::Resort

    SYNOPSIS:	Resorts the listbox

    EXIT:	On success, the items in the listbox resorted according
		to the current sort order.
		On failure, the order of the listbox items are left
		unchanged.

    RETURNS:	An API error, which is NERR_Success on success.

    NOTES:
	Assumes sort order is consistent throughout this method.

	CODEWORK.  Add fSugar parameter, defaulting to TRUE.
	If TRUE, this method works like it does today.	If
	FALSE, this method does not use AUTO_CURSOR, and does
	not call SetRedraw or Invalidate.

    HISTORY:
	rustanl     01-Jul-1991     Created

********************************************************************/

DECLARE_HEAP_OF( LBI );
DEFINE_HEAP_OF( LBI );

APIERR BLT_LISTBOX::Resort()
{
    AUTO_CURSOR autocur;	// this may take a while

    INT clbi = QueryCount();

    /*	Create a heap to do most of the job  */

    LBI_HEAP heap( clbi, FALSE );

    if ( heap.QueryError() != NERR_Success )
	return heap.QueryError();

    /*	Place listbox items in the heap  */

    for ( INT ilbi = 0; ilbi < clbi; ilbi++ )
    {
	//  Guaranteed to succeed since heap construction with parameter
	//  clbi succeeded.
	REQUIRE( heap.AddItem( QueryItem( ilbi )) == NERR_Success );
    }

    heap.Adjust();

    /*	Fill the listbox with the items in the new sort order  */

    SetRedraw( FALSE );

    for ( ilbi = 0; ilbi < clbi; ilbi++ )
    {
	SetItem( ilbi, heap.RemoveTopItem());
    }

    //	All items should have been removed from the heap
    UIASSERT( heap.QueryCount() == 0 );

    SetRedraw( TRUE );
    Invalidate();

    return NERR_Success;
}


/*******************************************************************

    NAME:	BLT_LISTBOX::SetItem

    SYNOPSIS:	Sets the 32-bit value for a particular listbox item

    ENTRY:	ilbi -	    The index of the item to set.  Must be
			    a valid listbox item.
		plbi -	    Pointer to LBI item which will be the
			    new listbox item at position ilbi.

    EXIT:	Listbox item at ilbi will be plbi.

    RETURN:	return CODE of the LB_SETITEMDATA command.
		LB_ERR if error.

    NOTES:
	This private method is used in Resort.	It is private so
	that no BLT client will use it, since that could
	break some of the BLT assumptions about listbox items.

    HISTORY:
	rustanl     01-Jul-1991 Created
	beng	    15-Oct-1991 Win32 conversion

********************************************************************/

VOID BLT_LISTBOX::SetItem( INT ilbi, LBI * plbi )
{
    UIASSERT( ilbi >= 0 );
    UIASSERT( ilbi < QueryCount());

    REQUIRE(((INT) Command( IsCombo() ? CB_SETITEMDATA :
					LB_SETITEMDATA,
			    ilbi,
			    (LPARAM)plbi ) ) != LB_ERR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlocal.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlocal.cxx
    Local BLT stuff: implementations

    FILE HISTORY:
	RustanL     04-Jan-91	    Created, adding BLT_SCRATCH
	beng	    11-Feb-1991     Uses lmui.hxx
	beng	    14-May-1991     Exploded blt.hxx into components

*/
#include "pchblt.hxx"   // Precompiled header


/**********************************************************************

    NAME:	BLT_SCRATCH::BLT_SCRATCH

    SYNOPSIS:	Constructor

    ENTRY:
	cbSize names desired amount of storage, in bytes

    EXIT:
	_cbSize set to passed parameter
	_pbStorage points to storage, either on the stack or heap

    NOTES:

    HISTORY:
	RustanL     04-Jan-91	Created, adding BLT_SCRATCH
	beng	    04-Oct-1991 Win32 conversion

**********************************************************************/

BLT_SCRATCH::BLT_SCRATCH( UINT cbSize )
    : _cbSize(cbSize),
      _pbStorage(0)
{
    _cbSize = cbSize;
    if ( cbSize > BLT_SCRATCH_STATIC_SIZE )
    {
	_pbStorage = new BYTE[ cbSize ];
	if ( _pbStorage == NULL )
	{
	    _cbSize = 0;
	    ReportError(ERROR_NOT_ENOUGH_MEMORY);
	}
    }
    else
    {
	_pbStorage = _abStaticBuffer;
    }
}


/**********************************************************************

    NAME:	BLT_SCRATCH::~BLT_SCRATCH

    SYNOPSIS:	Destructor

    HISTORY:
	RustanL     04-Jan-91	    Created, adding BLT_SCRATCH
	beng	    23-May-1991     Made zeroing DEBUG-only

**********************************************************************/

BLT_SCRATCH::~BLT_SCRATCH()
{
    if ( _pbStorage != _abStaticBuffer )
	delete _pbStorage;

#if defined(DEBUG)
    _pbStorage = NULL;
    _cbSize = 0;
#endif
}


/**********************************************************************

    NAME:	BLT_SCRATCH::QueryPtr

    SYNOPSIS:	Returns a pointer to the available storage

    HISTORY:
	RustanL     04-Jan-91	    Created, adding BLT_SCRATCH

**********************************************************************/

BYTE * BLT_SCRATCH::QueryPtr() const
{
    return _pbStorage;
}


/**********************************************************************

    NAME:	BLT_SCRATCH::QuerySize

    SYNOPSIS:	Returns amount of storage available, in bytes

    HISTORY:
	RustanL     04-Jan-91	Created, adding BLT_SCRATCH
	beng	    04-Oct-1991 Win32 conversion

**********************************************************************/

UINT BLT_SCRATCH::QuerySize() const
{
    return _cbSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltlc.cxx
    BLT list control: implementations

    FILE HISTORY:
        rustanl     20-Nov-1990     Created
        beng        11-Feb-1991     Uses lmui.hxx
        rustanl     22-Feb-1991     Changes due to new LC hierarchy
        rustanl     19-Mar-1991     Added COMBOBOX::SetMaxLength, and
                                    corresponding constructor parameter
        rustanl     21-Mar-1991     Folded in code review changes from
                                    CR on 20-Mar-1991 attended by
                                    JimH, GregJ, Hui-LiCh, RustanL.
        beng        14-May-1991     Exploded blt.hxx into components
        terryk      25-Jul-1991     Add SetItemData, QuerySelCount and
                                    QuerySelItems to LIST_CONTROL class
                                    Also add SetTopIndex, ChangeSel
        rustanl     12-Aug-1991     Hid some single/mult sel differences
                                    between the cozy covers of BLT
        terryk      22-Mar-1992     add STRING_LIST_CONTROL's InsertItem
        jonn        09-Sep-1993     Moved fns from SET_CONTROL_LISTBOX
                                    to LISTBOX

*/

#include "pchblt.hxx"   // Precompiled header

//  -----  Local macros  -----

/*  The following macro is used to conveniently specify a LB_ or CB_
 *  manifest, depending on the value of _fCombo.  Note, although
 *  most (not all!) LB_ and CB_ manifests have the same name (apart from
 *  the prefix) and SendMessage semantics, they do not have the same values
 *  at all.  An experienced PM programmer may at this point be stunned.
 */

#define LC_MSG( suffix )    ( IsCombo() ? ( CB_##suffix ) : ( LB_##suffix ))


//  This file assumes that LB_ERR has the same value as CB_ERR.  The file
//  only uses LB_ERR when checking return codes.  If the two values differ,
//  the code needs to change to use ( IsCombo() ? CB_ERR : LB_ERR ) instead.
#if ( LB_ERR != CB_ERR )
#error "This file assumes LB_ERR == CB_ERR."
#endif


/**********************************************************************

    NAME:           LIST_CONTROL::LIST_CONTROL

    SYNOPSIS:   Constructor for list-control abstract object

    ENTRY:      OWNER_WINDOW * powin - pointer to the owner window
                CID cid - cid of the listbox
                BOOL fCombo - flag for combo box

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

LIST_CONTROL::LIST_CONTROL( OWNER_WINDOW * powin, CID cid, BOOL fCombo )
    :   CONTROL_WINDOW( powin, cid ),
        _fCombo( fCombo ) ,
        _iSavedSelection( 0 ),
        _piSavedMultSel( NULL )
{
    if ( QueryError() )
        return;
}

LIST_CONTROL::LIST_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fCombo,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    :   CONTROL_WINDOW( powin, cid, xy, dxy, flStyle, pszClassName ),
        _fCombo( fCombo ) ,
        _iSavedSelection( 0 ),
        _piSavedMultSel( NULL )
{
    if ( QueryError() )
        return;
}

LIST_CONTROL::~LIST_CONTROL()
{
    delete _piSavedMultSel;
}


/*******************************************************************

    NAME:       LIST_CONTROL::IsMultSel

    SYNOPSIS:   Returns whether or not several items in the list control
                can be selected at one time.

    RETURNS:    FALSE if at most one item can be selected at one time
                    in the list control (i.e., the list control is
                    either a combo box or a single select listbox)
                TRUE if several items can be selected simultaneously
                    (i.e., the list control is either a extended select
                    listbox or a multiple select listbox)

    HISTORY:
        rustanl     12-Aug-1991     Created

********************************************************************/

BOOL LIST_CONTROL::IsMultSel() const
{
    if ( IsCombo())
        return FALSE;

    ULONG ulStyle = QueryStyle();
    if ( ( ulStyle & LBS_MULTIPLESEL ) ||
         ( ulStyle & LBS_EXTENDEDSEL ))
    {
        return TRUE;
    }

    return FALSE;
}


/**********************************************************************

   NAME:        LIST_CONTROL::AddItemData

   SYNOPSIS:    Add an item to the list box control

   ENTRY:       VOID * pv - pointer to the item to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE - not enough space to add the item
                Otherwise, it will be index of the item in the listbox

   HISTORY:
      rustanl   20-Nov-1990     Created

**********************************************************************/

INT LIST_CONTROL::AddItemData( VOID * pv )
{
    return (INT)Command( LC_MSG( ADDSTRING), 0, (LPARAM)pv );
}


/**********************************************************\

    NAME:       LIST_CONTROL::SetItemData

    SYNOPSIS:   set the data item to new value

    ENTRY:      INT i - index of the item
                VOID *pv - the new data

    RETURN:     The return value is LB_ERR if an error occurs

    HISTORY:
                terryk  25-Jul-1991 Created

\**********************************************************/

INT LIST_CONTROL::SetItemData( INT i, VOID * pv )
{
    return (INT)Command( LC_MSG( SETITEMDATA ), i, (LPARAM)pv );
}


/**********************************************************\

    NAME:       LIST_CONTROL::InsertItemData

    SYNOPSIS:   insert the item data in the given index

    ENTRY:      INT i - index of the item
                VOID *pv - the new data

    RETURN:     The return value is LB_ERR if an error occurs

    HISTORY:
                kevinl  23-Oct-1991 Created
                jonn    16-Feb-1993 Maintains caret position on WIN32

\**********************************************************/

INT LIST_CONTROL::InsertItemData( INT i, VOID * pv )
{
#ifdef WIN32
    INT nCaretIndex = 0;
    BOOL fMultSel = IsMultSel();
    if ( fMultSel )
    {
        nCaretIndex = QueryCaretIndex();
    }
#endif
    INT nReturn = (INT)Command( LC_MSG( INSERTSTRING ), i, (LPARAM)pv );
    // nReturn could be LB_ERR or LB_ERRSPACE
#ifdef WIN32
    if ( fMultSel && (nReturn <= nCaretIndex) && (nReturn >= 0) )
    {
        SetCaretIndex( nCaretIndex+1 );
    }
#endif
    return nReturn;
}


/**********************************************************************

    NAME:       LIST_CONTROL::SetTopIndex

    SYNOPSIS:   Set the index of the first visible control in list ctrl

    ENTRY:      i - the index

    NOTES:
        CODEWORK - this method only works on listboxes.  As such, it
        should move to some intermediate class.

    HISTORY:
        terryk      26-Jul-1991     Created

***********************************************************************/

VOID LIST_CONTROL::SetTopIndex( INT i )
{
    REQUIRE( (INT)Command( LB_SETTOPINDEX, i, 0 ) != LB_ERR );
}


/*******************************************************************

    NAME:       LIST_CONTROL::QueryTopIndex

    SYNOPSIS:   Returns the index of the topmost visible line

    RETURNS:    listbox index

    NOTES:
        CODEWORK - this method only works on listboxes.  As such, it
        should move to some intermediate class.

    HISTORY:
        beng        22-Aug-1991     Created

********************************************************************/

INT LIST_CONTROL::QueryTopIndex() const
{
    return (INT)Command(LB_GETTOPINDEX);
}


/**********************************************************************

    NAME:       LIST_CONTROL::SetCaretIndex

    SYNOPSIS:   Set the index of the item with the caret, and scroll the
                item into view.

    ENTRY:      i - the index
                fPartiallyVisibleOK - if TRUE, the listbox will be scrolled
                        until the item is at least partially visible.
                        If TRUE, the item will be fully visible.

    HISTORY:
        jonn        15-Sep-1993     Created

***********************************************************************/

VOID LIST_CONTROL::SetCaretIndex( INT i, BOOL fPartiallyVisibleOK )
{
    REQUIRE( (INT)Command( LB_SETCARETINDEX, i, fPartiallyVisibleOK ) != LB_ERR );
}


/*******************************************************************

    NAME:       LIST_CONTROL::QueryCaretIndex

    SYNOPSIS:   Returns the index of the item with the caret

    RETURNS:    listbox index

    HISTORY:
        jonn        15-Sep-1993     Created

********************************************************************/

INT LIST_CONTROL::QueryCaretIndex() const
{
    return (INT)Command( LB_GETCARETINDEX );
}


/**********************************************************************

   NAME:        LIST_CONTROL::QueryCount

   SYNOPSIS:    query the total number of items in the list box

   EXIT:        total number of item in the list box

   HISTORY:
                rustanl 20-Nov-1990     Created

**********************************************************************/

INT LIST_CONTROL::QueryCount() const
{
    return (INT)Command( LC_MSG( GETCOUNT ));

}


/**********************************************************\

    NAME:       LIST_CONTROL::QuerySelCount

    SYNOPSIS:   get the number of items selected in the list control

    RETURN:     total number of selected items

    HISTORY:
                terryk  25-Jul-1991 Created
                rustanl 12-Aug-1991 Added support for both single
                                    sel listboxes, too.

\**********************************************************/

INT LIST_CONTROL::QuerySelCount() const
{
    if ( IsMultSel())
    {
        INT c = (INT)Command( LB_GETSELCOUNT );
        UIASSERT( c >= 0 );
        return c;
    }

    // combo or single sel listbox
    if ( QueryCurrentItem() < 0 )
        return 0;

    return 1;
}


/*********************************************************************

    NAME:       LIST_CONTROL::QuerySelItem

    SYNOPSIS:   return an array of integer indecies for the currently
                selected list control items

    ENTRY:      piSel -         Pointer to buffer (array) which will
                                receive the selected items.
                ciMax -         Maximum number of entries that array
                                pointed to by piSel can hold

    RETURN:     An API return code, which is NERR_Success on success.
                Other often-returned errors may include:
                        ERROR_MORE_DATA -   More than ciMax items are
                                            selected, but only ciMax indicies
                                            were copied into the piSel
                                            buffer.

    HISTORY:
                terryk  25-JUl-1991 Created
                rustanl 12-Aug-1991 Added support for single
                                    select listboxes, too.

**********************************************************************/

APIERR LIST_CONTROL::QuerySelItems( INT * piSel, INT ciMax ) const
{
    UIASSERT( ciMax >= 0 );
    UIASSERT( ciMax == 0 || piSel != NULL );

    if ( IsMultSel())
    {
        INT c = (INT)Command( LB_GETSELITEMS, ciMax, (LPARAM)piSel );
        UIASSERT( c >= 0 );

        if ( QuerySelCount() < ciMax )
            return ERROR_MORE_DATA;

        return NERR_Success;
    }

    INT iCurr = QueryCurrentItem();
    if ( iCurr < 0 )
    {
        // no item is selected
        return NERR_Success;
    }

    if ( ciMax < 1 )
        return ERROR_MORE_DATA;

    piSel[ 0 ] = iCurr;
    return NERR_Success;
}


/*********************************************************************

    NAME:       LISTBOX::QueryItemHeight

    SYNOPSIS:   Calculate the height of any entry in the listbox

    HISTORY:
        beng        21-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to LISTBOX

*********************************************************************/

UINT LIST_CONTROL::QueryItemHeight( UINT ilb ) const
{
    LONG nRet = (LONG)Command( LB_GETITEMHEIGHT, ilb );
    ASSERT( nRet != LB_ERR );

    return nRet;
}


/*********************************************************************

    NAME:       LISTBOX::IsItemSelected

    SYNOPSIS:   Returns whether a given item is selected

    HISTORY:
        beng        21-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to LISTBOX

*********************************************************************/

BOOL LIST_CONTROL::IsItemSelected( UINT ilb ) const
{
    LONG nRet = (LONG)Command( LB_GETSEL, ilb );
    ASSERT(nRet != LB_ERR);

    return (nRet > 0) ? TRUE : FALSE; // works in error case, too
}


/**********************************************************************

   NAME:        LIST_CONTROL::SelectItem

   SYNOPSIS:    Select the specified item

   ENTRY:       INT i -         index for the selected item
                BOOL fSelect -  TRUE to select the item (default)
                                FALSE to unselect the item

    EXIT:       If fSelect is TRUE and i is a valid index,
                        Item i will be selected.
                If fSelect is TRUE and i is -1,
                        No item will be selected.
                If fSelect is FALSE and i is a valid index,
                        Item i will be unselected.

   NOTES:
      Passing i as -1 and fSelect as TRUE means to remove the hi-lite
      bar marking the current selection.  A client should try to avoid
      depending on this, and instead calling RemoveSelection.  If
      fSelect is FALSE, i must specify a valid index.

   HISTORY:
      rustanl   20-Nov-1990     Created
      rustanl   13-Aug-1991     Added fSelect parameter and multiple
                                select support

**********************************************************************/

VOID LIST_CONTROL::SelectItem( INT i, BOOL fSelect )
{
    if ( fSelect )
    {

        if ( IsMultSel())
        {
            REQUIRE( Command( LB_SETSEL, ( i >= 0 ), (ULONG)((LONG)i))
                     != LB_ERR );
            return;
        }

        //  Although not documented in the Windows SDK, the LB_SETCURSEL (and
        //  CB_SETCURSEL, which eventually maps to LB_SETCURSEL) message
        //  returns wParam if wParam is a valid index or is -1; otherwise, it
        //  returns LB_ERR.  (Note, that a return code of -1 can thus mean two
        //  different things, depending on what was passed in.)
        //
        //  The SDK only says that the message returns LB_ERR on error; it does
        //  not say anything about the return code if no error occurs.
        //
        //  The REQUIRE statement will fail precisely when the given index
        //  is not a valid index and is not -1.
        //
        REQUIRE( (LONG)Command( LC_MSG( SETCURSEL ), (UINT)i ) == (LONG)i );
    }
    else
    {
        UIASSERT( 0 <= i && i < QueryCount());

        if ( IsMultSel())
        {
            REQUIRE( Command( LB_SETSEL, FALSE, (ULONG)((LONG)i)) != LB_ERR );
            return;
        }

        if ( QueryCurrentItem() == i )
            RemoveSelection();
    }
}


/**********************************************************************

   NAME:        LIST_CONTROL::SelectItems

   SYNOPSIS:    Select the specified items

   ENTRY:       INT * pi -      indexes for the selected items
                INT c -         number of items
                BOOL fSelect -  TRUE to select the item (default)
                                FALSE to unselect the item

   NOTES:
      Only pass valid indices as parameters.  The current selection
      will not be cleared (for multi-select listboxes).

   HISTORY:
      jonn      15-Sep-1993     Created

**********************************************************************/

VOID LIST_CONTROL::SelectItems( INT * pi, INT c, BOOL fSelect )
{
    ASSERT( c == 0 || pi != NULL );

    INT i;
    for ( i = 0; i < c; i++ )
    {
        SelectItem( pi[i], fSelect );
    }
}


/**********************************************************************

   NAME:        LIST_CONTROL::DeleteItem

   SYNOPSIS:    delete the specified item from the listbox

   ENTRY:       INT i - item to be deleted

   RETURN:      The return value is a count of the strings remaining in the
                list. THe return value is LB_ERR if an error occurs.

   HISTORY:
      rustanl   20-Nov-1990     Created
      jonn      16-Feb-1993     Maintains caret position on WIN32

**********************************************************************/

INT LIST_CONTROL::DeleteItem( INT i )
{
    //  The LC_MSG( DELETESTRING ) message returns the number of items
    //  remaining in the list control on success, and LB_ERR (a negative
    //  value) on failure.

#ifdef WIN32
    INT nCaretIndex = 0;
    BOOL fMultSel = IsMultSel();
    if ( fMultSel )
    {
        nCaretIndex = QueryCaretIndex();
    }
#endif
    INT nReturn = (INT)Command( LC_MSG( DELETESTRING ), (UINT)i );
#ifdef WIN32
    if ( fMultSel && (i <= nCaretIndex) && (nReturn != LB_ERR) )
    {
        // move caret position back one if earlier item was deleted
        // if caret was on first item, then i >= nCaretPosition, so this
        //  will not move position to nCaretPosition < 0
        if ( i < nCaretIndex )
        {
            nCaretIndex--;
        }

        // move caret position to end of list if it is past end
        if ( nCaretIndex >= QueryCount() )
        {
            nCaretIndex = QueryCount() - 1;
        }

        // only set caret position if item exists
        if ( (nCaretIndex >= 0) && (nCaretIndex < QueryCount()) )
        {
            SetCaretIndex( nCaretIndex );
        }
    }
#endif
    return nReturn;

}


/**********************************************************************

   NAME:        LIST_CONTROL::DeleteAllItems

   SYNOPSIS:    delete all the item from the listbox

   HISTORY:
      rustanl   20-Nov-1990 Created
      beng      22-Sep-1991 Correct usage of GetVersion

**********************************************************************/

VOID LIST_CONTROL::DeleteAllItems()
{
    Command( LC_MSG( RESETCONTENT ));

    ULONG ulWindowsVersion = ::GetVersion();
    if ( ! _fCombo &&
         LOBYTE( LOWORD(ulWindowsVersion) ) == 3 &&     // major version no.
         HIBYTE( LOWORD(ulWindowsVersion) ) < 10 )      // minor version no.
    {
        //  This function uses a RustanL/ChuckC hack to get around a
        //  Windows 3.00 listbox problem where Windows doesn't get rid of the
        //  scrollbar when a listbox is emptied.  The work-around works as
        //  follows:
        //
        //      First, all items are removed from the listbox (above).  At
        //      this time, the scrollbar may still be there.
        //
        //      Then, one item is added to the listbox.  The listbox will at
        //      this time realize that it is not in need of the scrollbar, so
        //      it will remove it, if it was there.
        //
        //      Finally, the listbox is cleared again, removing the one
        //      item that was inserted.
        //
        //  This problem has been fixed in Windows 3.10; hence, the version
        //  check above.
        //

        VOID * pv;

        ULONG flStyle = QueryStyle();
        if ( ( flStyle & ( LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE )) &&
             ! ( flStyle & LBS_HASSTRINGS ))
        {
            //  The list control is a BLT listbox.  We should thus make pv a
            //  pointer to an LBI item.  Rather than calling 'new' and the LBI
            //  constructor (which may fail and return a NULL anyway), we
            //  simply set pv to NULL.  ShellDlgProc will still be able to
            //  properly delete this item (since C++ always defines delete
            //  on NULL pointers).  However, this will generate a WM_DRAWITEM
            //  message.  Hence, every CD_Draw routine must check the pointer
            //  for NULL before beginning to draw.
            pv = NULL;
        }
        else
        {
            //  The list control is a string list control
            pv = SZ("");
        }

        //  Note.  The item to be temporarily added to the list control, pv,
        //  is either NULL or points to the empty string, neither one of
        //  which will cause anything to be painted (even though it may
        //  generate a WM_DRAWITEM message).  Hence, the user will not
        //  get any flickering as a result of adding this item.
        AddItemData( pv );

        Command( LC_MSG( RESETCONTENT ));

    }
}


/**********************************************************************

   NAME:        LIST_CONTROL::QueryCurrentItem

   SYNOPSIS:    get the index of the first currently selected item

   RETURN:      The return value is the index of the first currently selected
                item.  It is a negative value if no item is selected.

   NOTES:       Since LIST_CONTROL::QuerySelItems calls this method, this
                method needs to be careful if calling QuerySelItems.  For
                this reason, this method calls Command directly with
                the LB_GETSELITEMS parameter.

   HISTORY:
      rustanl   20-Nov-1990     Created
      rustanl   12-Aug-1991     Added multiple selection support

**********************************************************************/

INT LIST_CONTROL::QueryCurrentItem() const
{
    if ( IsMultSel())
    {
        INT iSel;
        INT cRet = (INT)Command( LB_GETSELITEMS, 1, (LPARAM)&iSel );
        UIASSERT( cRet == 0 || cRet == 1 );
        if ( cRet == 1 )
            return iSel;
        return -1;
    }

    return (INT)Command( LC_MSG( GETCURSEL ));

}


/*******************************************************************

    NAME:     LIST_CONTROL::SaveValue

    SYNOPSIS: Saves the state of the list control and unselects the
              current item

    EXIT:     Unselected listbox

    NOTES:    See LIST_CONTROL header notes for comments on multiselection

    HISTORY:
        Johnl   25-Apr-1991     Created
        JonN    04-Dec-1992     Supports multiple-selection

********************************************************************/

VOID LIST_CONTROL::SaveValue( BOOL fInvisible )
{
    if ( IsMultSel() )
    {
        delete _piSavedMultSel;
        _piSavedMultSel = NULL;

        _iSavedSelection = QuerySelCount();
        _piSavedMultSel = new INT[ _iSavedSelection ];

        if (    _piSavedMultSel == NULL
             || QuerySelItems( _piSavedMultSel, _iSavedSelection ) != NERR_Success )
        {
            DBGEOL( "NETUI: LIST_CONTROL::SaveValue(): Could not save selection" );
            delete _piSavedMultSel;
            _piSavedMultSel = NULL;
        }
    }
    else
    {
        _iSavedSelection = QueryCurrentItem();
    }

    if ( fInvisible )
        RemoveSelection();
}


/*******************************************************************

    NAME:     LIST_CONTROL::RestoreValue

    SYNOPSIS: Restores LIST_CONTROL after SaveValue

    NOTES:    See CONTROL_VALUE for more details.

              See LIST_CONTROL header notes for comments on multiselection

    HISTORY:
        Johnl   25-Apr-1991     Created
        JonN    04-Dec-1992     Supports multiple-selection

********************************************************************/

VOID LIST_CONTROL::RestoreValue( BOOL fInvisible )
{
    if ( fInvisible )
    {
        if ( IsMultSel() )
        {
            if ( _piSavedMultSel == NULL )
            {
                DBGEOL( "NETUI: LIST_CONTROL::RestoreValue(): Could not restore selection" );
            }
            else
            {
                RemoveSelection();
                for ( INT i = 0; i < _iSavedSelection; i++ )
                    SelectItem( _piSavedMultSel[i] );
            }
        }
        else
        {
            SelectItem( _iSavedSelection );
        }
    }
}


/*******************************************************************

    NAME:       LIST_CONTROL::QueryEventEffects

    SYNOPSIS:   Returns one of the CVMI_* values.
                See CONTROL_VALUE for more information.

    ENTRY:      Let the parent group test the lParam to see whether it will
                change the listbox or not

    RETURNS:    If the selection is changed, it will return CVMI_VALUE_CHANGE
                CVMI_NO_VALUE_CHANGE otherwise

    NOTES:
        This only handles listbox messages, COMBOBOX::QueryEventEffects
        handles the combobox messages.

    HISTORY:
        Johnl       29-Apr-1991 Created
        beng        31-Jul-1991 Renamed from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT LIST_CONTROL::QueryEventEffects( const CONTROL_EVENT & e )
{
    // UIASSERT( !IsMultSel());        // not support (yet)

    switch ( e.QueryCode() )
    {
    case LBN_SELCHANGE:
        return CVMI_VALUE_CHANGE;

    case LBN_SETFOCUS:
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::STRING_LIST_CONTROL

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to the owner window
                CID cid - cid of the string list control
                BOOL fCombo - flag for combo box

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        17-May-1991     Added app-window constructor

**********************************************************************/

STRING_LIST_CONTROL::STRING_LIST_CONTROL( OWNER_WINDOW * powin,
                                          CID cid,
                                          BOOL fCombo )
    : LIST_CONTROL( powin, cid, fCombo )
{
    if ( QueryError() )
        return;

    // nothing else to do
}

STRING_LIST_CONTROL::STRING_LIST_CONTROL(
    OWNER_WINDOW * powin,
    CID            cid,
    BOOL           fCombo,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : LIST_CONTROL( powin, cid, fCombo, xy, dxy, flStyle, pszClassName )
{
    if ( QueryError() )
        return;

    // nothing else to do
}


/**********************************************************************

   NAME:        STRING_LIST_CONTROL::AddItem

   SYNOPSIS:    Add a string to list box

   ENTRY:       TCHAR * pch - string to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE if not enough space to add the item
                index of the new added string if no error occurs

   HISTORY:
      rustanl   20-Nov-1990     Created

**********************************************************************/

INT STRING_LIST_CONTROL::AddItem( const TCHAR * pch )
{
    return AddItemData( (VOID *)pch );
}


/**********************************************************************

   NAME:        STRING_LIST_CONTROL::AddItemIdemp

   SYNOPSIS:    Same as add item, however, it will not add the item to
                the listbox if the item already existed in the listbox

   ENTRY:       TCHAR * psz - string to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE if not enough space to add the item
                index of the new added string if no error occurs

   HISTORY:
      rustanl   20-Nov-1990     Created

**********************************************************************/

INT STRING_LIST_CONTROL::AddItemIdemp( const TCHAR * pch )
{
    INT i = FindItemExact( pch );

    if ( i < 0 )
        return AddItem( pch );

    return i;
}


/**********************************************************************

   NAME:        STRING_LIST_CONTROL::InsertItem

   SYNOPSIS:    Insert the item in the specified location

   ENTRY:       INT i - location index
                TCHAR * psz - string to be added

   EXIT:        LB_ERR if an error occurs
                LB_ERRSPACE if not enough space to add the item
                index of the new added string if no error occurs

   HISTORY:
      terryk   22-Mar-1992     Created

**********************************************************************/

INT STRING_LIST_CONTROL::InsertItem( INT i, const TCHAR * pch )
{
    return InsertItemData( i, (VOID *) pch );
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::FindItem

    SYNOPSIS:   find the string from the listbox

    ENTRY:
        pchPrefix         - point to the prefix string, the string
                            must be null-terminated

        iLastSearchResult - contains the index of the item
                            before the first item to be searched.
                            When the search reaches the bottom of the
                            listbox, it continues from the top of the
                            listbox back to the item specified by
                            this value.


    RETURNS:    The return value is the index of the matching item or
                LB_ERR if the search was unsuccessful.

    NOTES:      If the index given is -1, Windows searches the entire
                listbox from the beginning.

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        21-Aug-1991     Removed magic LC_NEW_SEARCH value

**********************************************************************/

INT STRING_LIST_CONTROL::FindItem( const TCHAR * pchPrefix ) const
{
    return FindItem(pchPrefix, -1);
}

INT STRING_LIST_CONTROL::FindItem( const TCHAR * pchPrefix,
                                   INT iLastSearchResult ) const
{
    return (INT)Command( LC_MSG( FINDSTRING ),
                         (UINT)iLastSearchResult,
                         (LPARAM)pchPrefix );
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::FindItemExact

    SYNOPSIS:   Returns the index of the precise match

    ENTRY:          psz             - pointer to string sought
                    iLastSearchResult   - index from which to search

    RETURNS:    the position of the specified string, or -1 if not found.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        10-Jun-1991 Unicode mods
        beng        01-May-1992 API changes

**********************************************************************/

INT STRING_LIST_CONTROL::FindItemExact( const TCHAR * psz ) const
{
    return FindItemExact(psz, -1);
}

INT STRING_LIST_CONTROL::FindItemExact( const TCHAR * psz,
                                        INT iLastSearchResult ) const
{
    INT iFirstMatch = FindItem( psz, iLastSearchResult );
    if ( iFirstMatch < 0 )
    {
        //  Prefix not found.  Return failure.
        //
        return -1;
    }

    INT cchLen = ::strlenf( psz );

    INT i = iFirstMatch;
    do
    {
        // We find out whether or not FindItem can find any item matching
        // the given one before the loop.  If it can't find the item,
        // we don't even enter the loop.  Since FindItem has the property
        // of always returning a non-negative index when given a string
        // which is indeed a prefix of some item in the list control,
        // regardless of how many consecutive times FindItem is called,
        // i should invariably not be negative within this loop.
        //
        UIASSERT( i >= 0 );

        // Item i has prefix pch, but matches the string pointed to by
        // pch if and only if it has the same length as pch.
        //
        if ( QueryItemLength( i ) == cchLen )
            return i;           //  exact match; return index

        i = FindItem( psz, i );
    }
    while ( i != iFirstMatch );

    return -1;      // we circled through all items with prefix pch,
                    // but none match pch exactly
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::QueryItemText

    SYNOPSIS:   Returns the text of a given entry in the listbox

    ENTRY:
        pnls    - pointer to host NLS_STR
        i       - index into listbox

            or

        pb      - pointer to BYTE buffer
        cb      - number of BYTES available in buffer
        i       - index into listbox

    EXIT:

    RETURNS:    0 if successful

    NOTES:
        The <pch, i> version is private to the class.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        10-Jun-1991 Changed return type
        beng        21-Aug-1991 Eliminated LC_CURRENT_ITEM magic number
        beng        01-May-1992 API changes

**********************************************************************/

APIERR STRING_LIST_CONTROL::QueryItemText( NLS_STR * pnls, INT i ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    if (i < 0) // no item selected, or else invalid param
        return ERROR_NEGATIVE_SEEK;

    INT cbLen = QueryItemSize( i );
    if ( cbLen < 0 )
    {
        UIASSERT( FALSE ); // invalid list control index
        return ERROR_INVALID_TARGET_HANDLE;
    }

    BLT_SCRATCH scratch( cbLen );
    if (!scratch)
        return scratch.QueryError();

    APIERR err = QueryItemTextAux( (TCHAR*)scratch.QueryPtr(), i );
    if (err != NERR_Success)
        return err;

    return pnls->CopyFrom((TCHAR *)scratch.QueryPtr());
}

APIERR STRING_LIST_CONTROL::QueryItemText( TCHAR * pchBuffer, INT cbBuffer,
                                           INT i ) const
{
    if (pchBuffer == NULL)
        return ERROR_INVALID_PARAMETER;

    if ( i < 0 ) // no item selected, or else invalid param
        return ERROR_NEGATIVE_SEEK;

    if ( cbBuffer < QueryItemSize(i) )
        return NERR_BufTooSmall;

    return QueryItemTextAux(pchBuffer, i); // call through to private member
}

APIERR STRING_LIST_CONTROL::QueryItemTextAux(TCHAR * pchBuffer, INT i) const
{
    INT nRet = (INT)Command( ( IsCombo() ? CB_GETLBTEXT : LB_GETTEXT ),
                             (WPARAM)i,
                             (LPARAM)pchBuffer );

    return (nRet < 0) ? ERROR_INVALID_TARGET_HANDLE : NERR_Success;
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::QueryItemLength

    SYNOPSIS:   Returns the cch (character count) of a given item

    ENTRY:      i - index of item in listbox

    EXIT:

    RETURNS:
        cch if >= 0; error if -1

    NOTES:
        This character count does not include the terminating char.
        On DBCS systems this will not correspond to the number of
        glyphs in the string.

    HISTORY:
        beng        10-Jun-1991 Created anew
        beng        21-Aug-1991 Eliminated LC_CURRENT_ITEM magic number
        beng        30-Apr-1992 API changes

**********************************************************************/

INT STRING_LIST_CONTROL::QueryItemLength( INT i ) const
{
    if (i < 0)
        return -1; // cascade errors

    // Note that these messages return a length in TCHARs
    // which does not include the terminating character.
    //
    return (INT)Command( ( IsCombo()
                           ? CB_GETLBTEXTLEN
                           : LB_GETTEXTLEN ), (UINT)i );
}


/**********************************************************************

    NAME:       STRING_LIST_CONTROL::QueryItemSize

    SYNOPSIS:   Returns the cb (byte count) of a given item,
                including the terminating character

    ENTRY:      i - index of item in listbox

    RETURNS:
        cb if >= 0; -1 if error

    NOTES:
        The character count corresponds to the value returned
        by strlen().  This is not the same as the number of
        glyphs in the string.

    HISTORY:
        rustanl     20-Nov-1990 Initially created
        beng        10-Jun-1991 Created from old QueryItemLen
        beng        21-Aug-1991 Eliminated LC_CURRENT_ITEM magic number
        beng        30-Apr-1992 API changes

**********************************************************************/

INT STRING_LIST_CONTROL::QueryItemSize( INT i ) const
{
    INT cchRet = QueryItemLength(i);     // get chars.  (handle errors)

    if ( cchRet < 0 )
        return -1;

    return (cchRet + 1) * sizeof(TCHAR); // convert to total bytes
}


/**********************************************************************

   NAME:        STRING_LISTBOX::STRING_LISTBOX

   SYNOPSIS:    constructor

   ENTRY:       OWNER_WINDOW * powin - pointer to the owner window
                CID cid - cid of the listbox

   HISTORY:
      rustanl   20-Nov-1990     Created
      DavidHov  21-Jan-1992     Added FONT member support

**********************************************************************/

STRING_LISTBOX::STRING_LISTBOX(
     OWNER_WINDOW * powin, CID cid, enum FontType font )
    : STRING_LIST_CONTROL( powin, cid, FALSE ),
      _fontListBox( font )
{
    if ( QueryError() )
        return;

    //  Note: construction should not fail if font unavailable.
    if ( ! _fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM) _fontListBox.QueryHandle(),
                 (LPARAM) FALSE ) ;
}


/**********************************************************************

   NAME:        STRING_LISTBOX::STRING_LISTBOX

   SYNOPSIS:    constructor for control directly on the face
                of a window.

   ENTRY:       OWNER_WINDOW *    pointer to the owner window
                CID               control id
                XYPOINT           location of control in parent window
                XYDIMENSION       size of control
                ULONG             style control bits
                TCHAR *           class name
                enum FontType     font to be used

   HISTORY:
      DavidHov  21-Jan-1992     Created, since FONT member disallowed
                                default construction.

**********************************************************************/

STRING_LISTBOX::STRING_LISTBOX( OWNER_WINDOW * powin,
                                CID cid,
                                XYPOINT xy, XYDIMENSION dxy,
                                ULONG flStyle, const TCHAR * pszClassName,
                                enum FontType font )
    : STRING_LIST_CONTROL( powin, cid, FALSE, xy, dxy, flStyle, pszClassName ),
    _fontListBox( font )
{
    if ( QueryError() )
        return;

    //  Note: construction should not fail if font unavailable.
    if ( ! _fontListBox.QueryError() )
        Command( WM_SETFONT, (WPARAM) _fontListBox.QueryHandle(),
                             (LPARAM) FALSE );
}


/**********************************************************************

    NAME:       COMBOBOX::COMBOBOX

    SYNOPSIS:   Constructor for combo box control

    ENTRY:

    EXIT:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-May-1991 Added app-window constructor
        beng        04-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Error mapping
        beng        30-Apr-1992 API change; cch instead of cb

**********************************************************************/

COMBOBOX::COMBOBOX( OWNER_WINDOW * powin, CID cid, UINT cchMaxLen )
    : STRING_LIST_CONTROL( powin, cid, TRUE ) ,
      _nlsSaveValue()
{
    if ( QueryError() )
        return;

    if ( _nlsSaveValue.QueryError() )
    {
        ReportError( _nlsSaveValue.QueryError() );
        return;
    }

    if ( cchMaxLen > 0 && !SetMaxLength( cchMaxLen ))
    {
        // assume low memory (why did SetMaxLength fail?)
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
}

COMBOBOX::COMBOBOX( OWNER_WINDOW * powin,
                    CID            cid,
                    UINT           cchMaxLen,
                    XYPOINT        xy,
                    XYDIMENSION    dxy,
                    ULONG          flStyle,
                    const TCHAR *  pszClassName )
    : STRING_LIST_CONTROL( powin, cid, TRUE, xy, dxy, flStyle, pszClassName ),
      _nlsSaveValue()
{
    if ( QueryError() )
        return;

    if ( _nlsSaveValue.QueryError() )
    {
        ReportError( _nlsSaveValue.QueryError() );
        return;
    }

    if ( cchMaxLen > 0 && !SetMaxLength( cchMaxLen ))
    {
        // assume low memory
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
}


/*******************************************************************

    NAME:       COMBOBOX::SetMaxLength

    SYNOPSIS:   Sets a limit on the number of bytes that the text
                string contained in the combo box may be.

    ENTRY:      cchMaxLen -      Indicates the new limit, or 0 to indicate
                                "no limit"

    RETURN:     TRUE on success; FALSE otherwise

    CAVEATS:    This method should not be called any combo without
                an SLE

    HISTORY:
        rustanl     19-Mar-1991 Created
        beng        30-Apr-1992 API changes; cch instead of cb

********************************************************************/

BOOL COMBOBOX::SetMaxLength( UINT cchMaxLen )
{
    ULONG ul = (ULONG)Command( CB_LIMITTEXT, cchMaxLen );

    UIASSERT( (LONG)ul != (LONG)CB_ERR ); // called on combo w/o sle

    return (ul && ((LONG)ul != (LONG)CB_ERR));
}


/*******************************************************************

    NAME:     COMBOBOX::IsDropDown

    SYNOPSIS: Returns TRUE if the combo has the CBS_DROPDOWN style bit
              set.  IsDropDownList and IsSimple are also defined here.

    RETURNS:  Returns TRUE if the appropriate bit is set.

    NOTES:

    HISTORY:
        Johnl   02-May-1991     Created

********************************************************************/

BOOL COMBOBOX::IsDropDown() const
{
    return ( CBS_DROPDOWN ==
             (QueryStyle() & (CBS_DROPDOWN | CBS_SIMPLE | CBS_DROPDOWNLIST) ) );
}

BOOL COMBOBOX::IsDropDownList() const
{
    return ( CBS_DROPDOWNLIST ==
             (QueryStyle() & (CBS_DROPDOWN | CBS_SIMPLE | CBS_DROPDOWNLIST) ) );
}

BOOL COMBOBOX::IsSimple() const
{
    return ( CBS_SIMPLE ==
             (QueryStyle() & (CBS_DROPDOWN | CBS_SIMPLE | CBS_DROPDOWNLIST) ) );
}


/*******************************************************************

    NAME:     COMBOBOX::SaveValue

    SYNOPSIS: Saves the state of the list control and unselects the
              current item

    EXIT:     Unselected listbox

    NOTES:

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID COMBOBOX::SaveValue( BOOL fInvisible )
{
    if ( !IsUserEdittable() )
    {
        STRING_LIST_CONTROL::SaveValue( fInvisible );
        return;
    }

    if ( _nlsSaveValue.QueryError() == NERR_Success )
        QueryText( &_nlsSaveValue );

    if ( _nlsSaveValue.QueryError() != NERR_Success )
    {
        DBGEOL("COMBOBOX::SaveValue - Error saving combobox string");
        _nlsSaveValue = NULL;
    }

    if ( IsSimple() && fInvisible )
        RemoveSelection();

    if ( fInvisible )
        ClearText();
}


/*******************************************************************

    NAME:     COMBOBOX::RestoreValue

    SYNOPSIS: Restores COMBOBOX after SaveValue

    ENTRY:

    EXIT:

    NOTES:    See CONTROL_VALUE for more details.

    HISTORY:
        Johnl   25-Apr-1991     Created

********************************************************************/

VOID COMBOBOX::RestoreValue( BOOL fInvisible )
{
    if ( !IsUserEdittable() )
    {
        STRING_LIST_CONTROL::RestoreValue( fInvisible );
        return;
    }

    if ( _nlsSaveValue.QueryError() == NERR_Success )
    {
        if ( fInvisible )
        {
            SetText( _nlsSaveValue );
        }

        // no, don't SelectString();
    }
}


/*******************************************************************

    NAME:      COMBOBOX::QueryEventEffects

    SYNOPSIS:  Returns one of the CVMI_* values.
               See CONTROL_VALUE for more information.

    ENTRY:

    EXIT:

    HISTORY:
        Johnl       29-Apr-1991 Created
        beng        31-Jul-1991 Renamed from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

********************************************************************/

UINT COMBOBOX::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch ( e.QueryCode() )
    {
    case CBN_EDITCHANGE:
    case CBN_SELCHANGE:
        return CVMI_VALUE_CHANGE;

    /* If someone clicks on the SLT of the drop down list...
    */
    case CBN_SETFOCUS:
        // if ( IsDropDownList() )
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    case CBN_DROPDOWN:
        return CVMI_VALUE_CHANGE | CVMI_RESTORE_ON_INACTIVE;

    default:
        break;
    }

    return CVMI_NO_VALUE_CHANGE;
}


/**********************************************************

    NAME:       COMBOBOX::SelectString

    SYNOPSIS:   Selects the string in the combo box.

    HISTORY:
        kevinl          19-Nov-1991     Created/stolen from Gregj

**********************************************************/

VOID COMBOBOX::SelectString()
{
#if defined(WIN32)
    Command( CB_SETEDITSEL, 0, MAKELPARAM(0,-1) );
#else
    Command( CB_SETEDITSEL, 0, MAKELONG( 0, 0x7fff ));
#endif
}


/**********************************************************

    NAME:       LIST_CONTROL::RemoveSelection

    SYNOPSIS:   Removes the hi-lite bar from the current selection

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        21-Aug-1991     Removed to .cxx file

**********************************************************/

VOID LIST_CONTROL::RemoveSelection()
{
    SelectItem( -1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlbst.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    BLTLBST.CXX:    Windows/NT Network Control Panel Applet.

        Classes in support of a "state listbox".  That is, one in which
        each item is prefaced by an icon indicating its current state.
        If only two icons are used, each item in the list box is
        equivalent to a checkbox.

    FILE HISTORY:
        DavidHov    1/8/92        Created

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       STATELBGRP::STATELBGRP

    SYNOPSIS:   Constructor for State Listbox Control Group.

    ENTRY:      INT aiMapIds []         array of bit map id numbers,
                                        terminated by zero.
                OWNER_WINDOW * powin    owner window
                CID cid                 control id for list box
                int cCols               number of columns (default 2)
                BOOL fReadOnly          read-only flag (default FALSE)
                enum FontType font      font info (default NULL)

    EXIT:       nothing

    RETURNS:    standard

    NOTES:

    HISTORY:

********************************************************************/

STATELBGRP::STATELBGRP(
    INT aiMapIds [],
    OWNER_WINDOW * powin,
    CID cid,
    INT cCols,
    BOOL fReadOnly,
    enum FontType font )
{
    APIERR err ;
    if ( QueryError() )
    {
        return ;
    }

    _pstlb = new STATELB( aiMapIds, powin, cid, cCols, fReadOnly, font ) ;
    if ( _pstlb == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
    }
    if ( err = _pstlb->QueryError() )
    {
        ReportError( err ) ;
    }
    _pstlb->SetGroup( this ) ;
}


/*******************************************************************

    NAME:       STATELBGRP::STATELBGRP

    SYNOPSIS:   Constructor for State Listbox Control Group
                which accepts an existing listbox WHICH IS
                DELETED UPON DESCTRUCTION.

    ENTRY:      INT aiMapIds []         array of bit map id numbers,
                                        terminated by zero.
                OWNER_WINDOW * powin    owner window
                STATELB * pstlb         pointer to listbox to manage
                BOOL fReadOnly          read-only flag (default FALSE)
                enum FontType font      font info (default NULL)

    EXIT:       nothing

    RETURNS:    standard

    NOTES:      Destructor deletes the given listbox!

    HISTORY:

********************************************************************/

STATELBGRP::STATELBGRP( STATELB * pstlb )
    : _pstlb( pstlb )
{
    REQUIRE( _pstlb != NULL && _pstlb->QueryError() == 0 ) ;

    if ( QueryError() )
    {
        return ;
    }
    _pstlb->SetGroup( this ) ;
}


/*******************************************************************

    NAME:       STATELBGRP:: ~ STATELBGRP

    SYNOPSIS:   Destructor of State Listbox Control Group

********************************************************************/

STATELBGRP::~STATELBGRP ()
{
    delete _pstlb ;
}


/*******************************************************************

    NAME:       STATELBGRP::OnUserAction

    SYNOPSIS:   Handle user event notifications for the contained
                list box.

                The purpose of overridding this virtual member
                is to catch double clicks and change the state
                of the item.

    ENTRY:      CONTROL_WINDOW * pcw          window where event
                                              occurred
                const CONTROL_EVENT & cEvent  BLT encoded event

    EXIT:

    RETURNS:    APIERR, but never fails

    NOTES:

    HISTORY:

********************************************************************/

APIERR STATELBGRP::OnUserAction( CONTROL_WINDOW * pcw,
                                 const CONTROL_EVENT & cEvent )
{
    UNREFERENCED( pcw ) ;

    if (   cEvent.QueryMessage() == WM_COMMAND
        && cEvent.QueryCode() == LBN_DBLCLK )
    {
        STLBITEM * pstlbi = _pstlb->QueryItem();

        REQUIRE( pstlbi != NULL ) ;

        pstlbi->NextState() ;
    }
    return NERR_Success ;
}


/*******************************************************************

    NAME:       STATELB::STATELB

    SYNOPSIS:   Constructor for a state-oriented list box.
                Along with the standard baggage for a BLT_LISTBOX,
                construction requires a table of ids (integers)
                for bit maps in the resource file.  These bitmaps
                are converted to DISPLAY_MAPs and stored into a
                dynamically allocated array.  Each STLBITEM is
                given a pointer to its parent listbox and can
                query the number and location of the maps.

    ENTRY:      Same as for STATELBGRP.  Since this is a contained
                (hidden) class, do not instantiate.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

STATELB::STATELB( INT aiMapIds [],
                  OWNER_WINDOW * powin,
                  CID cid,
                  INT cCols,
                  BOOL fReadOnly,
                  enum FontType font )
    : BLT_LISTBOX( powin, cid, fReadOnly, font ),
    _ppdmMaps( NULL )
{
    APIERR err ;

    if ( QueryError() )
        return ;

    //  Check that the number of columns is legal.

    if ( cCols > STLBMAXCOLS )
    {
        ReportError( ERROR_GEN_FAILURE ) ;
        return ;
    }

    INT iMapIndex ;

    //  Count the number of bitmaps; table is zero-delimited.

    for ( _cMaps = 0 ; aiMapIds[_cMaps] != 0 ; _cMaps++ ) ;

    //  Allocate the pointer-to-bitmaps array

    _ppdmMaps = new DISPLAY_MAP * [ _cMaps + 1 ] ;
    if ( _ppdmMaps == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
        return ;
    }

    //  Load the bitmaps, convert them to DISPLAY_MAPs

    for ( iMapIndex = 0 ; iMapIndex < _cMaps ; iMapIndex++ )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
        _ppdmMaps[iMapIndex] = new DISPLAY_MAP( aiMapIds[iMapIndex] ) ;
        if ( _ppdmMaps[iMapIndex] == NULL )
            break ;
        if ( err = _ppdmMaps[iMapIndex]->QueryError() )
            break ;
    }

    _ppdmMaps[iMapIndex] = NULL ;

    //  If not all of the DISPLAY_MAPs were allocated and constructed,
    //     report the error and fail.

    if ( iMapIndex < _cMaps )
    {
        ReportError( err ) ;
        return ;
    }

    //  Perform the initialization of the column widths for a DISPLAY_TABLE

    for ( INT i = 0 ; i < STLBMAXCOLS ; i++ )
    {
        _adxColumns[i] = 0 ;
    }

    err = DISPLAY_TABLE::CalcColumnWidths( _adxColumns, cCols,
                                           powin, cid, TRUE );
    if ( err )
    {
        ReportError( err ) ;
        return ;
    }
}


/*******************************************************************

    NAME:       STATELB::~STATELB

    SYNOPSIS:   Destroy the State Listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Destroy all allocated DISPLAY_MAPs and the array
                of pointers to them.

    HISTORY:

********************************************************************/

STATELB::~ STATELB ()
{
    if ( _ppdmMaps != NULL )
    {
        for ( INT i = 0 ; _ppdmMaps[i] ; i++ )
        {
            delete _ppdmMaps[i] ;
        }
        delete _ppdmMaps ;
    }
}


/*******************************************************************

    NAME:       STATELB::CD_Char

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

INT STATELB::CD_Char ( WCHAR wch, USHORT nLastPos )
{
    return BLT_LISTBOX::CD_Char( wch, nLastPos ) ;
}


/*******************************************************************

    NAME:       STATELB::CD_VKey

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

INT STATELB::CD_VKey ( USHORT nVKey, USHORT nLastPos )
{
    UNREFERENCED( nLastPos ) ;

    if ( nVKey == VK_SPACE )
    {
        STLBITEM * pstlbi = QueryItem() ;

        REQUIRE( pstlbi != NULL ) ;

        pstlbi->NextState() ;

        return -2 ;   // No further action required
    }
    else
    {
        return BLT_LISTBOX::CD_VKey( nVKey, nLastPos ) ;
    }
}


/*******************************************************************

    NAME:       STLBITEM::STLBITEM

    SYNOPSIS:   Constructor of State List Box Control Group item.
                Since the list box contains the array of DISPLAY_MAPs,
                each list box item has a pointer to its parent
                list box.

    ENTRY:      STATELBGRP * pstgGroup     pointer to list box group

    EXIT:       nothing

    RETURNS:    standard

    NOTES:      The STATELBGRP is required for construction to
                discourage attempts to subclass STATELB.

    HISTORY:

********************************************************************/

STLBITEM::STLBITEM ( STATELBGRP * pstgGroup )
    : _pstlb( pstgGroup->QueryLb() ),
    _iState( 0 )
{

}


/*******************************************************************

    NAME:       STLBITEM:: ~ STLBITEM

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

STLBITEM::~ STLBITEM ()
{
}


/*******************************************************************

    NAME:       STLBITEM:: Paint

    SYNOPSIS:   Override of virtual member to paint the ownder-drawn
                item.

    ENTRY:      See LBI::Paint() for details

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      The internal STATELB pointer is used to access its
                array of DISPLAY_MAPs.  The list item's state is
                assumed to be valid because SetState() will not
                allow it to be set to a value outside the known range.

    HISTORY:
        beng        21-Apr-1992 Interface change in LBI::Paint

********************************************************************/

VOID STLBITEM::Paint (
     LISTBOX * plb,
     HDC hdc,
     const RECT * prect,
     GUILTT_INFO * pGUILTT ) const
{
    DM_DTE   dteMap( _pstlb->QueryMapArray()[ _iState ] );
    STR_DTE  dteStr( QueryDisplayString() );

    DISPLAY_TABLE dtab( STLBCOLUMNS, _pstlb->QueryColData() );

    dtab[0] = & dteMap;
    dtab[1] = & dteStr;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:       STLBITEM::QueryLeadingChar

    SYNOPSIS:   Standard routine, overridden to take advantage
                of the fact that every subclass of STLBITEM must have
                a QueryDisplayString() function; thus, the data
                is publically available.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    WCHAR of 1st character in string

    NOTES:

    HISTORY:

********************************************************************/

WCHAR STLBITEM::QueryLeadingChar () const
{
    return *QueryDisplayString() ;
}


/*******************************************************************

    NAME:       STLBITEM::Compare

    SYNOPSIS:   Standard routine, overridden to take advantage
                of the fact that every subclass of STLBITEM must have
                a QueryDisplayString() function; thus, the data
                is publically available.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    Standate "strcmp" values of string comparison.

    NOTES:      List boxes are not necessarily sorted; cf. LBS_SORT.

    HISTORY:

********************************************************************/

INT STLBITEM::Compare ( const LBI * plbi ) const
{
    return ::stricmpf( QueryDisplayString(),
                       ((const STLBITEM *)plbi)->QueryDisplayString() );
}

/*******************************************************************

    NAME:       STLBITEM::SetState

    SYNOPSIS:   Set the internal and visible state of the list
                box item.

    ENTRY:      INT iState          new state desired

    EXIT:       item is set to new state;
                display updated accordingly

    RETURNS:    INT   old state

    NOTES:      The modulus operator is used to guarantee that
                the item is always set to a value within the
                range of the map list.

    HISTORY:

********************************************************************/

INT STLBITEM::SetState( INT iState )
{
    INT iOldState = _iState ;

    if ( iState < 0 )
        iState = 0 ;
    else
        _iState = iState % _pstlb->QueryMapCount() ;

    _pstlb->InvalidateItem( _pstlb->FindItem( *this ) ) ;

    return iOldState ;
}

// End of BLTLBST.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmain.cxx
    BLT application startup code

    This file contains the C-linkage glue functions binding BLT to
    the application.


    FILE HISTORY:
        beng        01-Apr-1991     Created

*/

#include "pchblt.hxx"

/*******************************************************************

    NAME:       BltMain

    SYNOPSIS:   Glue function binding BLT to the application.

    NOTES:
        BltMain is generated by the SET_ROOT_OBJECT macro.  This
        implementation will only link into the application if the
        client neglected to set a root object.

    HISTORY:
        beng        01-Apr-1991 Created
        beng        14-Oct-1991 APPSTART deleted; now used to detect
                                a missing root object
        beng        24-Apr-1992 Removed pszCmdLine parameter

********************************************************************/

INT BltMain(
    HINSTANCE   hInstance,       // current instance
    HINSTANCE   hPrevInstance,   // previous instance
    INT      nCmdShow )       // show-window type (open/icon)
{
    UNREFERENCED(hInstance);
    UNREFERENCED(hPrevInstance);
    UNREFERENCED(nCmdShow);

    ::MessageBox(NULL, SZ("Client application never declared a root object"),
                 SZ("BLT"), (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltlbsel.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlbsel.cxx
    BLT listbox selection control classes: implementation

    FILE HISTORY:
	beng	    07-Aug-1991     Created

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:	LB_SELECTION::LB_SELECTION

    SYNOPSIS:	Constructor

    ENTRY:	Pointer to host listbox

    EXIT:	Constructed

    NOTES:

    HISTORY:
	beng	    07-Aug-1991     Created

********************************************************************/

LB_SELECTION::LB_SELECTION( LISTBOX* plb )
    : _plb(plb),
      _cilbSelected(0),
      _pilbSelected(NULL)
{
    if (plb->IsMultSel())
    {
	_cilbSelected = plb->QuerySelCount();
	_pilbSelected = new INT[_cilbSelected];
	if (_pilbSelected == NULL)
	{
	    ReportError(ERROR_NOT_ENOUGH_MEMORY;
	    return;
	}
	plb->QuerySelItems(_cilbSelected, _pilbSelected);
    }
    else
    {
	INT ilbSelected = plb->QueryCurrentItem();
	if (ilbSelected != -1)
	{
	    _cilbSelected = 1;
	    _pilbSelected = new INT;
	    _pilbSelected[0] = ilbSelected;
	}
    }
}


/*******************************************************************

    NAME:	LB_SELECTION::~LB_SELECTION

    SYNOPSIS:	Destructor

    NOTES:

    HISTORY:
	beng	    14-Aug-1991     Created

********************************************************************/

LB_SELECTION::~LB_SELECTION()
{
    if (_cilbSelected > 0)
	delete[_cilbSelected] _pilbSelected;
}


/*******************************************************************

    NAME:	LB_SELECTION::QueryCount

    SYNOPSIS:	Returns the number of items in the selection

    NOTES:

    HISTORY:
	beng	    14-Aug-1991     Created

********************************************************************/

UINT LB_SELECTION::QueryCount()
{
    return _cilbSelected;
}


/*******************************************************************

    NAME:	LB_SELECTION::Select

    SYNOPSIS:	Add a line in the listbox to the selection

    ENTRY:	iIndex - index into the listbox

    EXIT:

    NOTES:

    HISTORY:
	beng	    14-Aug-1991     Created

********************************************************************/

VOID LB_SELECTION::Select( INT iIndex )
{
    plb->ChangeSel(iIndex, TRUE);
}


/*******************************************************************

    NAME:	LB_SELECTION::Unselect

    SYNOPSIS:	Remove a line in the listbox from the selection

    ENTRY:	iIndex - index into the listbox

    EXIT:	Line named is no longer selected.

    NOTES:

    HISTORY:

********************************************************************/

VOID LB_SELECTION::Unselect( INT iIndex )
{
    plb->ChangeSel(iIndex, FALSE);
}


/*******************************************************************

    NAME:	LB_SELECTION::UnselectAll

    SYNOPSIS:	Render the listbox without selection

    EXIT:	Nothing in the listbox is selected.
		The selection is empty.

    NOTES:

    HISTORY:

********************************************************************/

VOID LB_SELECTION::UnselectAll()
{
    for (INT iilb = 0; iilb < _cilbSelected; iilb++)
	plb->ChangeSel(_pilbSelected[iilb], FALSE);
}


/*******************************************************************

    NAME:	LB_SELECTION::AddItem

    SYNOPSIS:	Adds an item to the listbox, leaving it selected.

    ENTRY:	plbi	- pointer to listbox item for new line

    EXIT:	Line added to listbox.
		Line is selected.


    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

INT LB_SELECTION::AddItem(const LBI* plbi)
{

}


/*******************************************************************

    NAME:	LB_SELECTION::DeleteAllItems

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID LB_SELECTION::DeleteAllItems()
{

}


/*******************************************************************

    NAME:	ITER_LB::ITER_LB

    SYNOPSIS:	Constructor

    ENTRY:	Several forms exist; may take any one of

	plb - pointer to source listbox.  Resulting iterator will
	      count all items in listbox

	psel - pointer to listbox selection.  Iterator will count
	       all items in selection

	iter - another listbox iterator.  Iterator will count
	       whatever the source iterator counts, and will do
	       so from the last point of the source iterator.

    EXIT:	Constructed

    NOTES:

    HISTORY:

********************************************************************/

ITER_LB::ITER_LB(const BLT_LISTBOX * plb)
{

}


ITER_LB::ITER_LB(const LB_SELECTION * psel)
{

}


ITER_LB::ITER_LB(const ITER_LB & iter)
{

}


/*******************************************************************

    NAME:	ITER_LB::Reset

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID ITER_LB::Reset()
{

}


/*******************************************************************

    NAME:	ITER_LB::Next

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

LBI* ITER_LB::Next()
{

}


/*******************************************************************

    NAME:	ITER_LB::DeleteThis

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID ITER_LB::DeleteThis()
{

}


/*******************************************************************

    NAME:	ITER_LB::UnselectThis

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

VOID ITER_LB::UnselectThis()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltmenu.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltmenu.cxx
    This file contains the class definitions for the MENU_BASE,
    POPUP_MENU, and SYSTEM_MENU classes.

    These classes are used to manipulate menus.  The classes are
    structured as follows:

                                MENU_BASE
                                /       \
                              /           \
                         POPUP_MENU   SYSTEM_MENU

    A POPUP_MENU represents any popup menu.  These menus may or may
    not actually be attached to a window.

    A SYSTEM_MENU represents the system menu of a particular window.


    FILE HISTORY:
        KeithMo     12-Oct-1992     Created.

*/

#include "pchblt.hxx"   // Precompiled header


//
//  This is the maximum size allowed for the text in a menu item.
//  This value is used in the NLS_STR form of QueryItemText.
//  If the need ever arises to get more robust, we could allocate
//  a buffer for the string, then grow it as needed until the
//  string will fit into the buffer.
//

#define CCH_MAX_ITEM    1024



//
//  MENU_BASE methods.
//

/*******************************************************************

    NAME:       MENU_BASE :: MENU_BASE

    SYNOPSIS:   MENU_BASE class constructor.

    ENTRY:      hMenu                   - Menu handle, defaults to NULL.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
MENU_BASE :: MENU_BASE( HMENU hMenu )
  : BASE(),
    _hMenu( hMenu )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // MENU_BASE :: MENU_BASE


/*******************************************************************

    NAME:       MENU_BASE :: ~MENU_BASE

    SYNOPSIS:   MENU_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
MENU_BASE :: ~MENU_BASE( VOID )
{
    _hMenu = NULL;

}   // MENU_BASE :: ~MENU_BASE


/*******************************************************************

    NAME:       MENU_BASE :: W_Append

    SYNOPSIS:   Append worker function, appends a new item onto
                the menu.

    ENTRY:      pItemData               - Contains either a string pointer,
                                          a bitmap handle, or a pointer to
                                          user-defined data.

                ItemIdOrHmenu           - Either a menu item identifier,
                                          or a menu handle (for popups).

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: W_Append( const VOID * pItemData,
                              UINT_PTR     ItemIdOrHmenu,
                              UINT         nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::AppendMenu( QueryHandle(),
                       nFlags,
                       ItemIdOrHmenu,
                       (LPCTSTR)pItemData ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: W_Append


/*******************************************************************

    NAME:       MENU_BASE :: W_Insert

    SYNOPSIS:   Insert worker function, inserts a new item into
                the menu.

    ENTRY:      pItemData               - Contains either a string pointer,
                                          a bitmap handle, or a pointer to
                                          user-defined data.

                nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                ItemIdOrHmenu           - Either a menu item identifier,
                                          or a menu handle (for popups).

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: W_Insert( const VOID * pItemData,
                              UINT         nPosition,
                              UINT_PTR     ItemIdOrHmenu,
                              UINT         nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::InsertMenu( QueryHandle(),
                       nPosition,
                       nFlags,
                       ItemIdOrHmenu,
                       (LPCTSTR)pItemData ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: W_Insert


/*******************************************************************

    NAME:       MENU_BASE :: W_Modify

    SYNOPSIS:   Modify worker function, modifies an existing menu item.

    ENTRY:      pItemData               - Contains either a string pointer,
                                          a bitmap handle, or a pointer to
                                          user-defined data.

                idItem                  - The item to modify.

                ItemIdOrHmenu           - Either a menu item identifier,
                                          or a menu handle (for popups).

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been modified.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: W_Modify( const VOID * pItemData,
                              UINT         idItem,
                              UINT_PTR     ItemIdOrHmenu,
                              UINT         nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::ModifyMenu( QueryHandle(),
                       idItem,
                       nFlags,
                       ItemIdOrHmenu,
                       (LPCTSTR)pItemData ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: W_Modify


/*******************************************************************

    NAME:       MENU_BASE :: W_QueryItemText

    SYNOPSIS:   Worker function for querying the display string of a
                specific menu item.

    ENTRY:      pszBuffer               - Destination buffer for the string.

                cchBuffer               - Size of the desination buffer
                                          (in characters).

                nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    INT                     - Number of characters copied,
                                          not including the terminator.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
INT MENU_BASE :: W_QueryItemText( TCHAR * pszBuffer,
                                  UINT    cchBuffer,
                                  UINT    nItem,
                                  UINT    nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( pszBuffer != NULL );
    UIASSERT( ( nFlags & ~( MF_BYCOMMAND | MF_BYPOSITION ) ) == 0 );

    return (INT)::GetMenuString( QueryHandle(),
                                 nItem,
                                 (LPTSTR)pszBuffer,
                                 (int)cchBuffer,
                                 nFlags );

}   // MENU_BASE :: W_QueryItemText


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemCount

    SYNOPSIS:   Returns the number of items in the popup.

    RETURNS:    INT                     - Number of items in the popup menu.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
INT MENU_BASE :: QueryItemCount( VOID ) const
{
    UIASSERT( QueryHandle() != NULL );

    return (INT)::GetMenuItemCount( QueryHandle() );

}   // MENU_BASE :: QueryItemCount


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemID

    SYNOPSIS:   Returns the ID of a specific menu item.

    ENTRY:      nPosition               - The position of the item to query.

    RETURNS:    UINT                    - The ID of the specified item.
                                          Will be -1L if item was a popup.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: QueryItemID( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    return (UINT)::GetMenuItemID( QueryHandle(),
                                  nPosition );

}   // MENU_BASE :: QueryItemID


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemState

    SYNOPSIS:   Returns the state of a specific menu item.

    ENTRY:      nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    UINT                    - The state of the specified item.
                                          Will be -1L if item does not exist.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: QueryItemState( UINT nItem,
                                  UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( ( nFlags & ~( MF_BYCOMMAND | MF_BYPOSITION ) ) == 0 );

    return (UINT)::GetMenuState( QueryHandle(),
                                 nItem,
                                 nFlags );

}   // MENU_BASE :: QueryItemState


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemText

    SYNOPSIS:   Returns the display string of a specific menu item.

    ENTRY:      pszBuffer               - Destination buffer for the string.

                cchBuffer               - Size of the desination buffer
                                          (in characters).

                nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    APIERR                  - NERR_Success if success,
                                          ERROR_NOT_ENOUGH_MEMORY otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: QueryItemText( TCHAR * pszBuffer,
                                   UINT    cchBuffer,
                                   UINT    nItem,
                                   UINT    nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( pszBuffer != NULL );

    INT cchCopied = W_QueryItemText( pszBuffer,
                                     cchBuffer,
                                     nItem,
                                     nFlags );

    //
    //  The API gives us no easy way to determine the exact
    //  length of the string.  We'll assume that if the number
    //  of characters returned >= cchBuffer-1, then the buffer
    //  size was insufficient.
    //

    return ( cchCopied >= (INT)( cchBuffer - 1 ) ) ? ERROR_NOT_ENOUGH_MEMORY
                                              : NERR_Success;

}   // MENU_BASE :: QueryItemText


/*******************************************************************

    NAME:       MENU_BASE :: QueryItemText

    SYNOPSIS:   Returns the display string of a specific menu item.

    ENTRY:      pnls                    - The NLS_STR that will receive
                                          the text.

                nItem                   - Either the position or the ID
                                          of the item to query.

                nFlags                  - MF_* flags.  Should be either
                                          MF_BYPOSITION or MF_BYCOMMAND.

    RETURNS:    APIERR                  - NERR_Success if success,
                                          ERROR_NOT_ENOUGH_MEMORY otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: QueryItemText( NLS_STR * pnls,
                                   UINT      nItem,
                                   UINT      nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );
    UIASSERT( pnls != NULL );
    UIASSERT( pnls->QueryError() == NERR_Success );

    //
    //  Allocate some scratch space for the string.
    //

    BLT_SCRATCH scratch( CCH_MAX_ITEM * sizeof(TCHAR) );

    APIERR err = scratch.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Query the string into the scratch buffer.
        //

        err = QueryItemText( (TCHAR *)scratch.QueryPtr(),
                             scratch.QuerySize() / sizeof(TCHAR),
                             nItem,
                             nFlags );
    }

    if( err == NERR_Success )
    {
        //
        //  Copy the scratch buffer into the NLS_STR.
        //

        err = pnls->CopyFrom( (TCHAR *)scratch.QueryPtr() );
    }

    return err;

}   // MENU_BASE :: QueryItemText


/*******************************************************************

    NAME:       MENU_BASE :: QuerySubMenu

    SYNOPSIS:   Returns the handle of a popup-menu within the current
                menu.

    ENTRY:      nPosition               - The position of the popup.

    RETURNS:    HMENU                   - Handle of the popup,
                                          NULL if the specified item
                                          is not a popup.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
HMENU MENU_BASE :: QuerySubMenu( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    return ::GetSubMenu( QueryHandle(),
                         nPosition );

}   // MENU_BASE :: QuerySubMenu


/*******************************************************************

    NAME:       MENU_BASE :: Append

    SYNOPSIS:   Append a new item onto the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                idNewItem               - Menu ID of the new item.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Append( const TCHAR * pszName,
                            UINT          idNewItem,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Append( (const VOID *)pszName,
                     idNewItem,
                     nFlags );

}   // MENU_BASE :: Append


/*******************************************************************

    NAME:       MENU_BASE :: Append

    SYNOPSIS:   Append a new item onto the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                hMenu                   - Menu handle of the new popup menu.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Append( const TCHAR * pszName,
                            HMENU         hMenu,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Append( (const VOID *)pszName,
                     (UINT_PTR)hMenu,
                     nFlags | MF_POPUP );

}   // MENU_BASE :: Append


/*******************************************************************

    NAME:       MENU_BASE :: AppendSeparator

    SYNOPSIS:   Appends a separator onto the menu.

    EXIT:       If successful, the separator has been appended to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: AppendSeparator( VOID ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Append( NULL,
                     0,
                     MF_SEPARATOR );

}   // MENU_BASE :: AppendSeparator


/*******************************************************************

    NAME:       MENU_BASE :: Delete

    SYNOPSIS:   Delete an existing item from the menu.

    ENTRY:      idItem                  - The item to delete.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been deleted from the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Delete( UINT idItem,
                            UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::DeleteMenu( QueryHandle(),
                       idItem,
                       nFlags ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: Delete


/*******************************************************************

    NAME:       MENU_BASE :: Insert

    SYNOPSIS:   Inserts a new item into the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                idNewItem               - Menu ID of the new item.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Insert( const TCHAR * pszName,
                            UINT          nPosition,
                            UINT          idNewItem,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Insert( (const VOID *)pszName,
                     nPosition,
                     idNewItem,
                     nFlags );

}   // MENU_BASE :: Insert


/*******************************************************************

    NAME:       MENU_BASE :: Insert

    SYNOPSIS:   Inserts a new item into the menu.

    ENTRY:      pszName                 - The name (display string) of the
                                          new menu item.

                nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                hMenu                   - Menu handle of the new popup menu.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the new item has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Insert( const TCHAR * pszName,
                            UINT          nPosition,
                            HMENU         hMenu,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Insert( (const VOID *)pszName,
                     nPosition,
                     (UINT_PTR)hMenu,
                     nFlags | MF_POPUP );

}   // MENU_BASE :: Insert


/*******************************************************************

    NAME:       MENU_BASE :: InsertSeparator

    SYNOPSIS:   Inserts a separator into the menu.

    ENTRY:      nPosition               - Specifies the menu item before
                                          which the new item is to be
                                          inserted.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the separator has been inserted to the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: InsertSeparator( UINT nPosition,
                                     UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Insert( NULL,
                     nPosition,
                     0,
                     nFlags | MF_SEPARATOR );

}   // MENU_BASE :: InsertSeparator


/*******************************************************************

    NAME:       MENU_BASE :: Modify

    SYNOPSIS:   Modifies an existing menu item.

    ENTRY:      pszName                 - The new name (display string)
                                          for the menu item.

                idItem                  - The item to modify.

                idNewItem               - New menu ID for the item.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been modified.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Modify( const TCHAR * pszName,
                            UINT          idItem,
                            UINT          idNewItem,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Modify( (const VOID *)pszName,
                     idItem,
                     idNewItem,
                     nFlags );

}   // MENU_BASE :: Modify


/*******************************************************************

    NAME:       MENU_BASE :: Modify

    SYNOPSIS:   Modifies an existing menu item.

    ENTRY:      pszName                 - The new name (display string)
                                          for the menu item.

                idItem                  - The item to modify.

                hMenu                   - New menu handle for the popup.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been modified.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Modify( const TCHAR * pszName,
                            UINT          idItem,
                            HMENU         hMenu,
                            UINT          nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    return W_Modify( (const VOID *)pszName,
                     idItem,
                     (UINT_PTR)hMenu,
                     nFlags | MF_POPUP );

}   // MENU_BASE :: Modify


/*******************************************************************

    NAME:       MENU_BASE :: Remove

    SYNOPSIS:   Removes an existing item from the menu.

    ENTRY:      idItem                  - The item to remove.

                nFlags                  - Various & sundry MF_* menu flags.

    EXIT:       If successful, the item has been removed from the menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR MENU_BASE :: Remove( UINT idItem,
                            UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::RemoveMenu( QueryHandle(),
                       idItem,
                       nFlags ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // MENU_BASE :: Remove


/*******************************************************************

    NAME:       MENU_BASE :: CheckItem

    SYNOPSIS:   Checks/unchecks the specified menu item.

    ENTRY:      idItem                  - The item to check/uncheck.

                fCheck                  - Check item if TRUE,
                                          uncheck if FALSE.

                nFlags                  - Various & sundry MF_* menu flags.

    RETURNS:    UINT                    - Previous item state,
                                          -1 if item does not exist.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: CheckItem( UINT idItem,
                             BOOL fCheck,
                             UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    if( fCheck )
    {
        nFlags |= MF_CHECKED;
    }
    else
    {
        nFlags &= ~MF_CHECKED;
    }

    return (UINT)::CheckMenuItem( QueryHandle(),
                                  idItem,
                                  nFlags );

}   // MENU_BASE :: CheckItem


/*******************************************************************

    NAME:       MENU_BASE :: EnableItem

    SYNOPSIS:   Enables/disables the specified menu item.

    ENTRY:      idItem                  - The item to check/uncheck.

                fEnable                 - Enable item if TRUE,
                                          disable if FALSE.

                nFlags                  - Various & sundry MF_* menu flags.

    RETURNS:    UINT                    - Previous item state,
                                          -1 if item does not exist.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
UINT MENU_BASE :: EnableItem( UINT idItem,
                              BOOL fEnable,
                              UINT nFlags ) const
{
    UIASSERT( QueryHandle() != NULL );

    if( fEnable )
    {
        nFlags &= ~( MF_GRAYED | MF_DISABLED );
    }
    else
    {
        nFlags |= ( MF_GRAYED | MF_DISABLED );
    }

    return (UINT)::EnableMenuItem( QueryHandle(),
                                  idItem,
                                  nFlags );

}   // MENU_BASE :: EnableItem


/*******************************************************************

    NAME:       MENU_BASE :: IsPopup

    SYNOPSIS:   Determine if a particular menu item invokes a popup.

    ENTRY:      nPosition               - The relative position of the
                                          item in question.

    RETURNS:    BOOL                    - TRUE if the item invokes a popup,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
BOOL MENU_BASE :: IsPopup( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    return (BOOL)( QuerySubMenu( nPosition ) != NULL );

}   // MENU_BASE :: IsPopup


/*******************************************************************

    NAME:       MENU_BASE :: IsSeparator

    SYNOPSIS:   Determine if a particular menu item is a separator.

    ENTRY:      nPosition               - The relative position of the
                                          item in question.

    RETURNS:    BOOL                    - TRUE if the item is a separator,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
BOOL MENU_BASE :: IsSeparator( INT nPosition ) const
{
    UIASSERT( QueryHandle() != NULL );

    UINT nState = QueryItemState( nPosition, MF_BYPOSITION );

    return (BOOL)( ( nState & MF_SEPARATOR ) != 0 );

}   // MENU_BASE :: IsSeparator



//
//  POPUP_MENU methods.
//

/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Creates a new (empty)
                popup menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( VOID )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    //
    //  Create a new popup.
    //

    HMENU hMenu = ::CreatePopupMenu();

    if( hMenu == NULL )
    {
        //
        //  CreatePopupMenu failed.  Probably out of memory.
        //

        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        //  We have a popup.  Finish construction.
        //

        err = CtAux( hMenu );

        if( err != NERR_Success )
        {
            //
            //  Something failed during construction.  Nuke
            //  the popup.
            //

            ::DestroyMenu( hMenu );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Loads a menu from
                a resource template.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( IDRESOURCE & id )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    //
    //  Load the menu.
    //

    HMODULE hMod = BLT::CalcHmodRsrc( id );
    UIASSERT( hMod != NULL );

    HMENU hMenu = ::LoadMenu( hMod, id.QueryPsz() );

    if( hMenu == NULL )
    {
        //
        //  LoadMenu failed.
        //

        err = (APIERR)::GetLastError();
    }
    else
    {
        //
        //  Popup loaded.  Finish construction.
        //

        err = CtAux( hMenu );

        if( err != NERR_Success )
        {
            //
            //  Something failed during construction.  Nuke
            //  the popup.
            //

            ::DestroyMenu( hMenu );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Aliases an existing
                menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( HMENU hMenu )
  : MENU_BASE()
{
    UIASSERT( hMenu != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = CtAux( hMenu );

    if( err != NERR_Success )
    {
        //
        //  Something failed during construction.
        //

        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: POPUP_MENU

    SYNOPSIS:   POPUP_MENU class constructor.  Aliases a window's
                menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: POPUP_MENU( const PWND2HWND & wnd )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    HMENU hMenu = ::GetMenu( wnd.QueryHwnd() );
    UIASSERT( hMenu != NULL );

    APIERR err = CtAux( hMenu );

    if( err != NERR_Success )
    {
        //
        //  Something failed during construction.
        //

        ReportError( err );
        return;
    }

}   // POPUP_MENU :: POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: ~POPUP_MENU

    SYNOPSIS:   POPUP_MENU class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
POPUP_MENU :: ~POPUP_MENU( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // POPUP_MENU :: ~POPUP_MENU


/*******************************************************************

    NAME:       POPUP_MENU :: CtAux

    SYNOPSIS:   Constructor helper method.

    ENTRY:      hMenu                   - The new menu handle.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: CtAux( HMENU hMenu )
{
    UIASSERT( hMenu != NULL );

    //
    //  Not much to do here (yet).
    //

    SetHandle( hMenu );

    return NERR_Success;

}   // POPUP_MENU :: CtAux


/*******************************************************************

    NAME:       POPUP_MENU :: Destroy

    SYNOPSIS:   Destroys the current menu.

    EXIT:       The menu is destroyed, and the saved _hMenu is set
                to NULL.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: Destroy( VOID )
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    //
    //  Destroy the menu.
    //

    if( !::DestroyMenu( QueryHandle() ) )
    {
        //
        //  The destroy failed, get the error code.
        //

        err = (APIERR)::GetLastError();
    }
    else
    {
        //
        //  Destroy successful, clear the handle.
        //

        SetHandle( NULL );
    }

    return err;

}   // POPUP_MENU :: Destroy


/*******************************************************************

    NAME:       POPUP_MENU :: Attach

    SYNOPSIS:   Attaches this POPUP_MENU object to a given window.

    ENTRY:      wnd                     - Either an HWND or APP_WINDOW *
                                          representing the target window.

    EXIT:       The current menu is destroyed, replaced by the given
                window's menu.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: Attach( const PWND2HWND & wnd )
{
    UIASSERT( QueryHandle() != NULL );

    //
    //  Get the window's menu handle.
    //

    HMENU hMenu = ::GetMenu( wnd.QueryHwnd() );
    UIASSERT( hMenu != NULL );

    //
    //  Destroy the menu.
    //

    APIERR err = Destroy();

    if( err == NERR_Success )
    {
        //
        //  Destroy successful, set the menu handle
        //  to the handle retrieved from the window.
        //

        SetHandle( hMenu );
    }

    return err;

}   // POPUP_MENU :: Attach


/*******************************************************************

    NAME:       POPUP_MENU :: Track

    SYNOPSIS:   Tracks a popup menu.  Used for "floating" menus.

    ENTRY:      wnd                     - Either an HWND or APP_WINDOW *
                                          representing the target window.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
APIERR POPUP_MENU :: Track( const PWND2HWND & wnd,
                            UINT              nFlags,
                            INT               x,
                            INT               y,
                            const RECT      * pRect ) const
{
    UIASSERT( QueryHandle() != NULL );

    APIERR err = NERR_Success;

    if( !::TrackPopupMenu( QueryHandle(),
                           nFlags,
                           x, y,
                           0,
                           wnd.QueryHwnd(),
                           pRect ) )
    {
        err = (APIERR)::GetLastError();
    }

    return err;

}   // POPUP_MENU :: Attach



//
//  SYSTEM_MENU methods.
//

/*******************************************************************

    NAME:       SYSTEM_MENU :: SYSTEM_MENU

    SYNOPSIS:   SYSTEM_MENU class constructor.  Creates an alias for
                a given window's system menu.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
SYSTEM_MENU :: SYSTEM_MENU( const PWND2HWND & wnd )
  : MENU_BASE()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Get the system menu.
    //

    HMENU hMenu = ::GetSystemMenu( wnd.QueryHwnd(), FALSE );
    UIASSERT( hMenu != NULL );

    //
    //  Save it away.
    //

    SetHandle( hMenu );

}   // SYSTEM_MENU :: SYSTEM_MENU


/*******************************************************************

    NAME:       SYSTEM_MENU :: ~SYSTEM_MENU

    SYNOPSIS:   SYSTEM_MENU class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     12-Oct-1992     Created.

********************************************************************/
SYSTEM_MENU :: ~SYSTEM_MENU( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SYSTEM_MENU :: ~SYSTEM_MENU
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmisc.cxx
    Misc BLT windows definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        rustanl     06-Mar-1991 Fixed up atom classes; made PROC_INSTANCE
                                        inherit from BASE
        rustanl     07-Mar-1991 Improved ATOM_BASE hierarchy
        rustanl     12-Mar-1991 Added CURSOR and AUTO_CURSOR
        beng        14-May-1991 Exploded blt.hxx into components;
                                        removed TABSTOP objects
        beng        09-Jul-1991 Added implementation of ACCELTABLE
        terryk      18-Jul-1991 Add more functions to DEVICE_CONTEXT
                                SetBkColor, SetTextColor, SetTextAlign,
                                and ExtTextOut
        terryk      20-Jul-1991 Add _fRelease to DISPLAY_CONTEXT
                                Add one more constructor in DISPLAY_CONTEXT
        rustanl     07-Aug-1991 Added SOLID_BRUSH
        rustanl     29-Aug-1991 ACCELTABLE ct now takes const TCHAR *
        beng        30-Sep-1991 PROC_INSTANCE removed elsewhere
        beng        30-Mar-1992 Outlined a couple more functions
        beng        28-Jul-1992 Add reference to hmodBlt
        KeithMo     07-Aug-1992 STRICTified.
*/
#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       DEVICE_CONTEXT::DrawRect

    SYNOPSIS:   Draw a rectangle with the given attributes of the device
                context.

    ENTRY:      lpRect - pointer to rectangle to draw the focus rect

    NOTES:      See SDK help file for detail.

    HISTORY:
        Johnl       09-Sep-1991  Created
        beng        22-Jul-1992 "top" and "right" args swapped

********************************************************************/

VOID DEVICE_CONTEXT::DrawRect( const RECT * pRect ) const
{
    ::Rectangle(_hDC, pRect->left, pRect->top, pRect->right, pRect->bottom);
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::DrawFocusRect

    SYNOPSIS:   Draw the official windows focus rectangle.  This is an
                xor operation, so call once to put on, and another time
                to take off.

    ENTRY:      lpRect - pointer to rectangle to draw the focus rect

    NOTES:      See SDK help file for detail.

    HISTORY:
        Johnl       09-Sep-1991 Created
        beng        04-Oct-1991 Additional const parms

********************************************************************/

VOID DEVICE_CONTEXT::DrawFocusRect( const RECT * pRect ) const
{
    ::DrawFocusRect( _hDC, (RECT*)pRect );
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::FrameRect

    SYNOPSIS:   Draw an unfilled rectangle using the passed brush

    ENTRY:      lpRect - pointer to rectangle to draw the focus rect

    NOTES:      See SDK help file for detail.

    HISTORY:
        Johnl       12-Sep-1991 Created
        beng        04-Oct-1991 Additional const parms

********************************************************************/

VOID DEVICE_CONTEXT::FrameRect( const RECT * pRect, HBRUSH hBrush ) const
{
    ::FrameRect( _hDC, (RECT*)pRect, hBrush );
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::InvertRect

    SYNOPSIS:   Invert the color within a rectangle

    ENTRY:      LPRECT - pointer to the given rectangle data structure

    NOTES:      See SDK help file for detail

    HISTORY:
        terryk      10-Apr-1991 creation
        beng        04-Oct-1991 Additional const parms

**********************************************************************/

VOID DEVICE_CONTEXT::InvertRect( const RECT * pRect ) const
{
   ::InvertRect( _hDC, (RECT*)pRect );
}


#if 0 // polygon methods have been disabled

/*********************************************************************

   NAME:       DEVICE_CONTEXT::SetPolyFillMode

   SYNOPSIS:   set the polygon filling method

   ENTRY:      INT nPolyFillMode - either ALTERNATE oe WINDING

   NOTES:      See SDK help file for detail

   HISTORY:
        terryk      10-Apr-1991 creation
        beng        09-Oct-1991 Disabled

*********************************************************************/

INT DEVICE_CONTEXT::SetPolyFillMode( INT nPolyFillMode )
{
   return ( ::SetPolyFillMode( _hDC, nPolyFillMode ));
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::GetPolyFillMode

    SYNOPSIS:   get the current polygon fill mode

    RETURN:     return either ALTERNATE OR WINDING

    NOTES:      See SDK help file for detail

    HISTORY:
        terryk      10-Apr-1991 creation
        beng        09-Oct-1991 Disabled

***********************************************************************/

INT DEVICE_CONTEXT::GetPolyFillMode() const
{
    return( ::GetPolyFillMode( _hDC ));
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::Polygon

    SYNOPSIS:   build the polgyon and fill it out

    ENTRY:      POINT * pxyPoly - the points of the polygon
                INT     cxy     - nunber of vertices

    NOTES:      See SDK help file for detail

    HISTORY:
        terryk      10-Apr-1991 Creation
        beng        09-Oct-1991 Disabled

**********************************************************************/

BOOL DEVICE_CONTEXT::Polygon( POINT * pxyPoly, INT cxy ) const
{
    return( ::Polygon( _hDC, pxyPoly, cxy ));
}

#endif // disabled


/**********************************************************************

    NAME:       DEVICE_CONTEXT::SetTextAlign

    SYNOPSIS:   set the text alignment flags for the given device context

    ENTRY:      flag to be set. Specifies a mask of the values in the
                following list. Only one flag may be chosen from those that
                affect horizontal an dvertical alignment. In addition, only
                one of the two flags that alter the current position can be
                chosen:
                    TA_BASELINE
                    TA_BOTTOM
                    TA_CENTER
                    TA_LEFT
                    TA_NOUPDATECP
                    TA_RIGHT
                    TA_TOP
                    TA_UPDATECP
                The defaults are TA_LEFT, TA_TOP, and TA_NOUPDATECP

    RETURN:     the original wFlags

    HISTORY:
        terryk      18-Jul-91   Created
        beng        04-Oct-1991 Win32 conversion

**********************************************************************/

UINT DEVICE_CONTEXT::SetTextAlign( UINT wFlag )
{
    return( ::SetTextAlign( _hDC, wFlag ));
}


/*********************************************************************

    NAME:       DEVICE_CONTEXT::ExtTextOut

    SYNOPSIS:   write a character string to the specified
                display and position

    ENTRY:      INT x     - x-coordinate
                INT y     - y-coordinate
                WORD wOption - option, any combination of
                        ETO_CLIPPED
                        ETO_OPAQUE
                pRect     - the specified location
                pszString - the display string
                cch       - count of chars
                lpDx      - points to an array of values that indicate the
                             distance between origins of adjacent character
                             cells.

    RETURN:     TRUE if string is drawn

    HISTORY:
        terryk      18-Jul-91   Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

BOOL DEVICE_CONTEXT::ExtTextOut( INT x, INT y, UINT nOptions,
                                 const RECT * prect,
                                 const TCHAR * pszString,
                                 INT cch, INT *pDx )
{
    return( ::ExtTextOut( _hDC, x, y, nOptions, prect,
                          pszString, cch, pDx ));
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::QueryTextExtent

    SYNOPSIS:   This method computes the width and height in
                logical units of the line of text pointed to by psz.

    ENTRY:
        nls         String reference
            - or -
        psz         Pointer to a string
        cch         Length (NOT size) of string pointed to by psz, in TCHARs

    RETURN:
        Ax XYDIMENSION object

    NOTES:
        For more information, please consult the GetTextExtent description
        in the Windows SDK.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        15-May-1991 Returns a DIMENSION object
        beng        09-Oct-1991 Unicode fixes
        beng        17-Oct-1991 Win32 conversion
        beng        05-May-1992 API changes

**********************************************************************/

XYDIMENSION DEVICE_CONTEXT::QueryTextExtent( const TCHAR * psz,
                                             UINT cch ) const
{
    UIASSERT( _hDC != NULL );

#if defined(WIN32)
    SIZE size;
    ::GetTextExtentPoint( _hDC, (TCHAR*)psz, cch, &size );
    return XYDIMENSION(size);
#else
    ULONG ul = ::GetTextExtent( _hDC, (TCHAR*)psz, cch );
    return XYDIMENSION(ul);
#endif
}

XYDIMENSION DEVICE_CONTEXT::QueryTextExtent( const NLS_STR &nls ) const
{
    return QueryTextExtent(nls.QueryPch(), nls.QueryTextLength());
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::QueryTextMetrics

    SYNOPSIS:   Fills the given buffer with the metrics of the selected font.

    ENTRY:
       ptm      A pointer to a TEXTMETRIC structure.

    RETURNS:
       TRUE on success, FALSE otherwise

    NOTES:      See the Windows SDK for a description of
                the TEXTMETRIC structure.

    HISTORY:
        rustanl     20-Nov-1990     Created

***********************************************************************/

BOOL DEVICE_CONTEXT::QueryTextMetrics( TEXTMETRIC * ptm ) const
{
    UIASSERT(ptm != NULL);
    return ::GetTextMetrics( _hDC, ptm );
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::QueryFontHeight

    SYNOPSIS:   Returns the height metric of the current font

    RETURNS:    Height in logical units (0 if error)

    NOTES:
        Ad hoc, yet convenient.

        This ia a fairly expensive call; the client should cache
        its returned value.

    HISTORY:
        beng        10-Jul-1991     Created

********************************************************************/

INT DEVICE_CONTEXT::QueryFontHeight() const
{
    TEXTMETRIC tm;
    if (!QueryTextMetrics(&tm))
        return 0;

    return tm.tmHeight;
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::QueryAveCharWidth

    SYNOPSIS:   Returns the average-width metric of the current font

    RETURNS:    Width in logical units (0 if error)

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

INT DEVICE_CONTEXT::QueryAveCharWidth() const
{
    TEXTMETRIC tm;
    if (!QueryTextMetrics(&tm))
        return 0;

    return tm.tmAveCharWidth;
}


/*******************************************************************

    NAME:       DEVICE_CONTEXT::TextOut

    SYNOPSIS:   Writes a character string on a device

    ENTRY:
        nls         - NLS string
           or
        psz, cb     - pointer to a character string, and its byte count

        xLeft, yTop - position at which to start the string
           or
        xy

        prectClip   - rectangle within which to clear and clip


    RETURNS:    TRUE if string successfully written

    NOTES:

    HISTORY:
        beng        10-Jul-1991 Created
        beng        04-Oct-1991 Additional const args
        beng        01-May-1992 API changes

********************************************************************/

BOOL DEVICE_CONTEXT::TextOut( const TCHAR * psz, INT cch,
                              INT xLeft, INT yTop ) const
{
    return ::TextOut( _hDC, xLeft, yTop, psz, cch );
}


BOOL DEVICE_CONTEXT::TextOut( const NLS_STR &nls, XYPOINT xy ) const
{
    return ::TextOut( _hDC, xy.QueryX(), xy.QueryY(),
                      nls.QueryPch(), nls.QueryTextLength() );
}


BOOL DEVICE_CONTEXT::TextOut( const TCHAR * psz, INT cch,
                              INT xLeft, INT yTop,
                              const RECT * prcClip ) const
{
    return ::ExtTextOut( _hDC, xLeft, yTop, ETO_CLIPPED|ETO_OPAQUE,
                         prcClip, psz, cch, NULL);
}


BOOL DEVICE_CONTEXT::TextOut( const NLS_STR &nls,
                              XYPOINT xy,
                              const RECT * prcClip ) const
{
    return ::ExtTextOut( _hDC, xy.QueryX(), xy.QueryY(),
                         ETO_CLIPPED|ETO_OPAQUE,
                         prcClip, nls.QueryPch(),
                         nls.QueryTextLength(), NULL);
}


/**********************************************************************

    NAME:       DEVICE_CONTEXT::BitBlt

    SYNOPSIS:   Wrapper for Win BITBLT function.
                Moves a bitmap from the named source DC to
                the current DC.

    RETURN:     TRUE if bitmap is drawn; FALSE otherwise.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        10-Jul-1991 Update parms
        beng        04-Oct-1991 Additional const parms

**********************************************************************/

BOOL DEVICE_CONTEXT::BitBlt( INT xDest,   INT yDest,
                             INT dxWidth, INT dyHeight,
                       const DEVICE_CONTEXT & dcSource,
                             INT xSrc,    INT ySrc,
                             ULONG ulRasterOperation )
{
    return ::BitBlt( _hDC,
                     xDest,
                     yDest,
                     dxWidth,
                     dyHeight,
                     dcSource.QueryHdc(),
                     xSrc,
                     ySrc,
                     ulRasterOperation );
}

BOOL DEVICE_CONTEXT::BitBlt( const XYPOINT &  xyDest,
                             XYDIMENSION      dxyDest,
                       const DEVICE_CONTEXT & dcSource,
                             const XYPOINT &  xySource,
                             ULONG ulRasterOperation )
{
    return ::BitBlt( _hDC,
                     xyDest.QueryX(),
                     xyDest.QueryY(),
                     dxyDest.QueryWidth(),
                     dxyDest.QueryHeight(),
                     dcSource.QueryHdc(),
                     xySource.QueryX(),
                     xySource.QueryY(),
                     ulRasterOperation );
}


/**********************************************************************

    NAME:       DISPLAY_CONTEXT::DISPLAY_CONTEXT

    SYNOPSIS:   Make a DC corresponding to a window

    ENTRY:      pwnd - pointer to window
            or
                hwnd - Win handle

    HISTORY:
        rustanl     20-Nov-1990     Created
        terryk      20-Jul-1991     Add a constructor which take WINDOW *
                                    and DC all together.
                                    Also, add _fRelaseDC boolean

**********************************************************************/

DISPLAY_CONTEXT::DISPLAY_CONTEXT( HWND hwnd )
    : DEVICE_CONTEXT( ::GetDC(hwnd) ),
    _fReleaseDC( TRUE )
{
    _hwnd = hwnd;
}

DISPLAY_CONTEXT::DISPLAY_CONTEXT( WINDOW * pwnd )
    : DEVICE_CONTEXT( ::GetDC( pwnd->QueryHwnd() ) ),
    _fReleaseDC( TRUE )
{
    _hwnd = pwnd->QueryHwnd();
}

DISPLAY_CONTEXT::DISPLAY_CONTEXT( WINDOW * pwnd, HDC hdc )
    : DEVICE_CONTEXT( hdc ),
    _fReleaseDC( FALSE )
{
    _hwnd = pwnd->QueryHwnd();
}


/*********************************************************************

   NAME:       DISPLAY_CONTEXT::~DISPLAY_CONTEXT

   SYNOPSIS:   destructor of display context

   NOTES:      if _fReleaseDC is TRUE, release the dc, otherwise keep it.

   HISTORY:
      rustanl   20-Nov-1990     Created
      terryk    20-Jul-1991 Add _fReleaseDC boolean

*********************************************************************/

DISPLAY_CONTEXT::~DISPLAY_CONTEXT()
{
    if ( _fReleaseDC )
        ::ReleaseDC( _hwnd, QueryHdc() );
}


/**********************************************************************

   NAME:       DISPLAY_CONTEXT::QueryTextWidth

   SYNOPSIS:   return the width of the given string with the given length

   ENTRY:      PSZ - the given string
               UINT - the given length of the string

   RETURN:     return the text width of the given string

   HISTORY:
        terryk      4-Apr-1991  Creation
        beng        15-May-1991 Fix parms
        beng        14-Oct-1991 Unicode fixes
        beng        01-May-1992 API changes

**********************************************************************/

INT DISPLAY_CONTEXT::QueryTextWidth( const TCHAR * psz, UINT cch ) const
{
    RECT rectRect;

    ::GetClientRect( _hwnd, &rectRect );
    ::DrawText( QueryHdc(), (TCHAR*)psz, cch, &rectRect, DT_CALCRECT );

    return( rectRect.right - rectRect.left + 1 );
}

INT DISPLAY_CONTEXT::QueryTextWidth( const NLS_STR & nls ) const
{
    return QueryTextWidth(nls.QueryPch(), nls.QueryTextLength());
}


/*********************************************************************

    NAME:       SCREEN_DC::SCREEN_DC

    SYNOPSIS:   constructor

    NOTES:      call the GetDC with NULL parameter to get the screen HDC
                and pass it to DEVICE_CONTEXT

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

SCREEN_DC::SCREEN_DC()
    : DEVICE_CONTEXT( ::GetDC( NULL ))
{
    // Nothing else to do...
}


/*********************************************************************

    NAME:       SCREEN_DC::~SCREEN_DC

    SYNOPSIS:   destructor - release the dc.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

SCREEN_DC::~SCREEN_DC()
{
    ::ReleaseDC( NULL, QueryHdc() );
}


/*********************************************************************

    NAME:       MEMORY_DC::MEMORY_DC

    SYNOPSIS:   memory DC constructor

    ENTRY:      DEVICE_CONTEX &dc - device context to build
                compatibleDC

    NOTES:      Call createCamptibleDC to create another DC and pass
                the dc to DEVICE_CONTEXT

    HISTORY:
                rustanl 20-Nov-1990     Created

*********************************************************************/

MEMORY_DC::MEMORY_DC( DEVICE_CONTEXT & dc )
    : DEVICE_CONTEXT( ::CreateCompatibleDC( dc.QueryHdc() ))
{
    //  nothing to do here
}


/*********************************************************************

    NAME:       MEMORY_DC::~MEMORY_DC

    SYNOPSIS:   destructor - delete the dc

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

MEMORY_DC::~MEMORY_DC()
{
    ::DeleteDC( QueryHdc() );
}


/*********************************************************************

    NAME:       ATOM_BASE::ATOM_BASE

    SYNOPSIS:   constructor

    ENTRY:      nothing
                OR
                ATOM hAtom to create a compatible DC

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM_BASE::ATOM_BASE()
    :   _hAtom( NULL )
{
    //  nothing else to do
}


ATOM_BASE::ATOM_BASE( ATOM hAtom )
    :   _hAtom( hAtom )
{
    //  nothing else to do
}


/*********************************************************************

    NAME:       ATOM_BASE::~ATOM_BASE

    SYNOPSIS:   destructor

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM_BASE::~ATOM_BASE()
{
    _hAtom = NULL;
}


/**********************************************************************

    NAME:       ATOM_BASE::AssignAux

    SYNOPSIS:   Assign a new atom handle to the atom object.

       This protected method assumes that the currently stored atom
       handle can be overwritten, i.e., the caller first deleted this
       atom, if applicable.

    ENTRY:
       pch      Pointer to new string to be assigned.  May be NULL.
                If NULL, the atom treats it like the empty string,
                and guarantees that the assignment operation will succeed.

    RETURN:     pch, as passed in (i.e., the right hand sign of the op=)

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        07-Nov-1991 Error mapping

**********************************************************************/

const TCHAR * ATOM_BASE::AssignAux( const TCHAR * pch )
{
    _hAtom = NULL;
    if ( pch != NULL )
    {
        _hAtom = W_AddAtom( pch );
        if ( _hAtom == NULL )
        {
            ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
            return pch;
        }
    }

    ResetError();

    return pch;
}


/*********************************************************************

    NAME:       ATOM_BASE::QueryString

    SYNOPSIS:   Copies the string stored in the atom to the given buffer.

    ENTRY:
      pchBuffer     Pointer to buffer of size cbBuf
      cbBuf                 Size of buffer pointed to by pchBuffer

    RETURN:     An error value, which is NERR_Success on success.

    NOTES:
      Due to shortcomings in the Windows API, this method can not (easily)
      determine whether or not the given buffer was big enough.

    HISTORY:
      rustanl   20-Nov-1990 Created
      beng      04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR ATOM_BASE::QueryString( TCHAR * pchBuffer, UINT cbBuf ) const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( cbBuf == 0 )
        return NERR_BufTooSmall;

    if ( QueryHandle() == NULL )
    {
        //  Note, we already checked for buffer size of 0
        pchBuffer[ 0 ] = TCH('\0');
        return NERR_Success;
    }

    return W_QueryString( pchBuffer, cbBuf );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::GLOBAL_ATOM

    SYNOPSIS:
      This constructor first (implicitly) constructs an ATOM_BASE with
      a NULL handle.  Then, it checks the superclass for errors.        If
      none, it assigns pch as the string in this atom.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

GLOBAL_ATOM::GLOBAL_ATOM( const TCHAR * pch )
{
    if ( QueryError() != NERR_Success )
        return;

    AssignAux( pch );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::~GLOBAL_ATOM

    SYNOPSIS:   This destructor deletes the atom unless the atom handle is NULL.

    HISTORY:
      rustanl   20-Nov-1990     Created
      KeithMo   13-Sep-1992     Delete the atom if the handle is *NOT* NULL...

*********************************************************************/

GLOBAL_ATOM::~GLOBAL_ATOM()
{
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::GlobalDeleteAtom( QueryHandle()) == NULL );
    }
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::operator=

    SYNOPSIS:   This method is used to assign a new string to the object.
      The method first deletes the previous atom, if any, and then
      assigns the new one.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    RETURN:
      pch, as it was passed in (i.e., the right hand side of op=)

    NOTES:

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

const TCHAR * GLOBAL_ATOM::operator=( const TCHAR * pch )
{
    //  First, delete the old atom, if any
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::GlobalDeleteAtom( QueryHandle()) == NULL );
    }

    //  Set the new atom
    return AssignAux( pch );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::W_AddAtom

    SYNOPSIS:
      This virtual replacement worker routine calls out to the Windows API
      to add the atom.

    ENTRY:
      pch       Pointer to string to be added as an atom.  It must not
              be NULL.

    RETURN:
      The atom handle of the newly added atom.  On failure, this handle
      is NULL.

    NOTES:
      This method does not use any data member of the object.  Rather,
      the caller (the ATOM_BASE class) will modify the object accordingly.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM GLOBAL_ATOM::W_AddAtom( const TCHAR * pch ) const
{
    UIASSERT( pch != NULL );

    return ::GlobalAddAtom( (TCHAR *)pch );
}


/*********************************************************************

    NAME:       GLOBAL_ATOM::W_QueryString

    SYNOPSIS:   Calls the Windows API to retrieve a string corresponding
                to an atom.

    ENTRY:
      pchBuffer Pointer to buffer which receives the atom string.
      cbBuf     Size of buffer pointed to by pchBuffer.  This size
                must be positive.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        04-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Error mapping
        beng        01-May-1992 API changes

*********************************************************************/

APIERR GLOBAL_ATOM::W_QueryString( TCHAR * pchBuffer, UINT cbBuf ) const
{
    UINT cchCopied = ::GlobalGetAtomName( QueryHandle(),
                                          pchBuffer, cbBuf/sizeof(TCHAR) );
    if ( cchCopied == 0 )
        return BLT::MapLastError(ERROR_GEN_FAILURE);

    return NERR_Success;
}


/*********************************************************************

    NAME:       LOCAL_ATOM::LOCAL_ATOM

    SYNOPSIS:   First, implicitly constructs an ATOM_BASE with
                a NULL handle.  Then, it checks the superclass for errors.
                If none, it assigns pch as the string in this atom.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

LOCAL_ATOM::LOCAL_ATOM( const TCHAR * pch )
{
    if ( QueryError() != NERR_Success )
        return;

    AssignAux( pch );
}


/*********************************************************************

    NAME:       LOCAL_ATOM::~LOCAL_ATOM

    SYNOPSIS:   This destructor deletes the atom unless the atom handle is NULL.

    HISTORY:
      rustanl   20-Nov-1990     Created
      KeithMo   13-Sep-1992     Delete the atom if the handle is *NOT* NULL...

*********************************************************************/

LOCAL_ATOM::~LOCAL_ATOM()
{
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::DeleteAtom( QueryHandle()) == NULL );
    }
}


/*********************************************************************

    NAME:       LOCAL_ATOM::operator=

    SYNOPSIS:
      This method is used to assign a new string to the object.

      The method first deletes the previous atom, if any, and then
      assigns the new one.

    ENTRY:
      pch       Pointer to string with which to set the atom.  If it is
              NULL, it is treated like the empty string is is guaranteed
              to succeed.

    RETURN:     pch, as it was passed in (i.e., the right hand side of op=)

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

const TCHAR * LOCAL_ATOM::operator=( const TCHAR * pch )
{
    //  First, delete the old atom, if any
    if ( QueryHandle() != NULL )
    {
        REQUIRE( ::DeleteAtom( QueryHandle()) == NULL );
    }

    //  Set the new atom
    return AssignAux( pch );
}


/*********************************************************************

    NAME:       LOCAL_ATOM::W_AddAtom

    SYNOPSIS:   This virtual replacement worker routine calls out to the
                Windows API to add the atom.

    ENTRY:
      pch       Pointer to string to be added as an atom.  It must not
              be NULL.

    RETURN:
      The atom handle of the newly added atom.  On failure, this handle
      is NULL.

    NOTES:
      This method does not use any data member of the object.  Rather,
      the caller (the ATOM_BASE class) will modify the object accordingly.

    HISTORY:
      rustanl   20-Nov-1990     Created

*********************************************************************/

ATOM LOCAL_ATOM::W_AddAtom( const TCHAR * pch ) const
{
    UIASSERT( pch != NULL );

    return ::AddAtom( (TCHAR *)pch );
}


/*********************************************************************

    NAME:       LOCAL_ATOM::W_QueryString

    SYNOPSIS:   This method calls the Windows API to retrieve a string '
                corresponding to an atom.

    ENTRY:
      pchBuffer Pointer to buffer which receives the atom string.
      cbBuf             Size of buffer pointed to by pchBuffer.  This size
                      must be positive.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        04-Oct-1991 Win32 conversion
        beng        07-Nov-1991 Error mapping
        beng        01-May-1992 API changes

*********************************************************************/

APIERR LOCAL_ATOM::W_QueryString( TCHAR * pchBuffer, UINT cbBuf ) const
{
    UINT cchCopied = ::GetAtomName( QueryHandle(),
                                   pchBuffer, cbBuf/sizeof(TCHAR) );
    if ( cchCopied == 0 )
        return BLT::MapLastError(ERROR_GEN_FAILURE);

    return NERR_Success;
}


/*******************************************************************

    NAME:       CURSOR::Load

    SYNOPSIS:   Loads a cursor from the resource file

    ENTRY:      The new cursor, by name or number.

    RETURN:     Returns handle to the loaded cursor, or NULL on failure.

    NOTES:
        This is a static member function.

    HISTORY:
        rustanl     12-Mar-1991 Created
        beng        04-Oct-1991 Const parms
        beng        28-May-1992 Uses IDRESOURCE; sep'd LoadSystem
        beng        03-Aug-1992 Dllization delta

********************************************************************/

HCURSOR CURSOR::Load( const IDRESOURCE & idrsrcCursor )
{
    ASSERT( idrsrcCursor.QueryPsz() != NULL ); // Would be a LoadSystem instead

    HMODULE hmod = BLT::CalcHmodRsrc( idrsrcCursor );

    HCURSOR hcur = ::LoadCursor(hmod, idrsrcCursor.QueryPsz());
    if (hcur == NULL)
    {
#if defined(WIN32)
        DBGEOL( "BLT: CURSOR::Load() failed, err = " << ::GetLastError() );
#else
        DBGEOL( "BLT: CURSOR::Load() could not load cursor");
#endif
    }

    return hcur;
}


/*******************************************************************

    NAME:       CURSOR::LoadSystem

    SYNOPSIS:   Loads a cursor from the system

    ENTRY:      The new cursor, by name.  This should be one of the
                system predef'd cursors (e.g. IDC_WAIT).

    RETURN:     Returns handle to the loaded cursor, or NULL on failure.

    NOTES:
        This is a static member function.

    HISTORY:
        beng        28-May-1992 Created

********************************************************************/

HCURSOR CURSOR::LoadSystem( const IDRESOURCE & idrsrcCursor )
{
    ASSERT( idrsrcCursor.QueryPsz() != NULL );
    HCURSOR hcur = ::LoadCursor(NULL, idrsrcCursor.QueryPsz());

    if ( hcur == NULL )
    {
#if defined(WIN32)
        DBGEOL( "BLT: CURSOR::LoadSystem() failed, err = " << ::GetLastError() );
#else
        DBGEOL( "BLT: CURSOR::LoadSystem() could not load cursor");
#endif
    }

    return hcur;
}


/*******************************************************************

    NAME:       CURSOR::Set

    SYNOPSIS:   Sets the cursor

    ENTRY:      The new cursor, either by name or handle.

    RETURN:     Returns a handle to the previously used cursor

    NOTES:
        This is a static member function.

    HISTORY:
        rustanl     12-Mar-1991 Created
        beng        04-Oct-1991 Const parms
        beng        28-May-1992 Remove set-by-name

********************************************************************/

HCURSOR CURSOR::Set( HCURSOR hCursor )
{
    return ::SetCursor( hCursor );
}


/*******************************************************************

    NAME:       CURSOR::Query

    SYNOPSIS:   Returns the current cursor

    RETURN:     Returns a handle to the cursor

    NOTES:
        This is a static member function.

    HISTORY:
        beng        27-May-1992 Created

********************************************************************/

HCURSOR CURSOR::Query()
{
    return ::GetCursor();
}


/*******************************************************************

    NAME:       CURSOR::Show

    SYNOPSIS:   Increases or decreases the cursor display count

    ENTRY:      f - TRUE to increase cursor display count
                    FALSE to decrease cursor display count

    NOTES:
        This is a static member function.

        See Windows SDK for a description of the cursor display count.

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

VOID CURSOR::Show( BOOL f )
{
    ::ShowCursor( f );
}


/*******************************************************************

    NAME:       CURSOR::QueryPos

    SYNOPSIS:   Returns the current position of the cursor

    RETURNS:    A XYPOINT, specifying the current pos in screen coords.

    NOTES:
        This is a static member function.

    HISTORY:
        beng        16-Oct-1991 Created

********************************************************************/

XYPOINT CURSOR::QueryPos()
{
    POINT pt;
    ::GetCursorPos(&pt);
    return XYPOINT(pt);
}


/*******************************************************************

    NAME:       CURSOR::SetPos

    SYNOPSIS:   Sets the cursor to the specified position

    ENTRY:      xy - desired position of cursor

    NOTES:
        This is a static member function.

    HISTORY:
        beng        16-Oct-1991 Created

********************************************************************/

VOID CURSOR::SetPos( const XYPOINT & xy )
{
    ::SetCursorPos(xy.QueryX(), xy.QueryY());
}


/*******************************************************************

    NAME:       AUTO_CURSOR::AUTO_CURSOR

    SYNOPSIS:   Sets the cursor to the one specified, and sets the state
                of the object to ON.

    ENTRY:      lpCursorName - specifies cursor to be used, either NULL
                to use hourglass, or else some other system cursor.

    HISTORY:
        rustanl     12-Mar-1991 created
        beng        04-Oct-1991 Const parms
        beng        28-May-1992 Changes to CURSOR::Load

********************************************************************/

AUTO_CURSOR::AUTO_CURSOR( const TCHAR * pszCursorName )
{
    _hOnCursor = LoadSystem( (pszCursorName == NULL)
                              ? IDC_WAIT
                              : pszCursorName );
    _hOffCursor = Set( _hOnCursor );
    _fState = TRUE;         // to indicate state = ON

    //  Discover the inital cursor count, which is one less than
    //  the value return by ShowCursor().  Immediately restore the
    //  cursor count back to what it was.

    _cCurs = ::ShowCursor( TRUE ) - 1 ;
    ::ShowCursor( FALSE ) ;

    if ( _cCurs >= 0 )
    {
        Show( TRUE );
    }
}


/*******************************************************************

    NAME:       AUTO_CURSOR::~AUTO_CURSOR

    SYNOPSIS:   Sets the cursor back to the one used before the
                constructor was called, and then destroys the
                AUTO_CURSOR object.

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

AUTO_CURSOR::~AUTO_CURSOR()
{
    TurnOff();
}


/*******************************************************************

    NAME:       AUTO_CURSOR::TurnOn

    SYNOPSIS:   Sets the auto cursor to its ON state

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

VOID AUTO_CURSOR::TurnOn()
{
    if ( ! _fState )
    {
        Set( _hOnCursor );
        if ( _cCurs >= 0 )
        {
            Show( TRUE );
        }
        _fState = TRUE;
    }
}


/*******************************************************************

    NAME:       AUTO_CURSOR::TurnOff

    SYNOPSIS:   Sets the auto cursor to its OFF state

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

VOID AUTO_CURSOR::TurnOff()
{
    if ( _fState )
    {
        Set( _hOffCursor );
        if ( _cCurs >= 0 )
        {
            Show( FALSE );
        }
        _fState = FALSE;
    }
}


/*******************************************************************

    NAME:       ACCELTABLE::ACCELTABLE

    SYNOPSIS:   From resource, construct an accelerator table

    ENTRY:      pszResourceName - pointer to resource name

    EXIT:       Table loaded from file

    HISTORY:
        beng        09-Jul-1991 Created
        rustanl     29-Aug-1991 Ct now takes const TCHAR *
        beng        03-Aug-1992 Uses IDRESOURCE; dllization

********************************************************************/

ACCELTABLE::ACCELTABLE( const IDRESOURCE & idrsrc )
    : _hAccTable(0)
{
    HMODULE hmod = BLT::CalcHmodRsrc(idrsrc);

    HACCEL h = (HACCEL)::LoadAccelerators( hmod, idrsrc.QueryPsz() );
    if (h == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    _hAccTable = h;
}


/*******************************************************************

    NAME:       ACCELTABLE::~ACCELTABLE

    SYNOPSIS:   Destroy an accelerator table

    ENTRY:      Instance of table object

    EXIT:       Table unloaded

    HISTORY:
        beng        09-Jul-1991     Created

********************************************************************/

ACCELTABLE::~ACCELTABLE()
{
    if (_hAccTable)
        ::FreeResource( (HGLOBAL)_hAccTable );
}


/*******************************************************************

    NAME:       ACCELTABLE::QueryHandle

    SYNOPSIS:   Return Win handle to table, for Win APIs

    RETURNS:    HANDLE

    HISTORY:
        beng        09-Jul-1991     Created

********************************************************************/

HACCEL ACCELTABLE::QueryHandle() const
{
    return _hAccTable;
}


/*******************************************************************

    NAME:       ACCELTABLE::Translate

    SYNOPSIS:   Translate a window's accelerators

    ENTRY:      pwnd - pointer to window in question
                pmsg - message, hot off of the Windows queue

    EXIT:       If accelerator, xlated appropriately

    RETURNS:    TRUE if it ate the message

    HISTORY:
        beng        09-Jul-1991     Created

********************************************************************/

BOOL ACCELTABLE::Translate( const WINDOW* pwnd, MSG* pmsg ) const
{
    return ::TranslateAccelerator(pwnd->QueryHwnd(),
                                  _hAccTable,
                                  (LPMSG)pmsg );
}


/*******************************************************************

    NAME:       SOLID_BRUSH::SOLID_BRUSH

    SYNOPSIS:   SOLID_BRUSH constructor

    ENTRY:      iSolidBrush -   Specifies the Windows-defined
                                index of the solid brush

    HISTORY:
        rustanl     22-Jul-1991 Created
        beng        06-Nov-1991 uses MapLastError

********************************************************************/

SOLID_BRUSH::SOLID_BRUSH( INT iSolidBrush )
    :   _hbrush( ::CreateSolidBrush( ::GetSysColor( iSolidBrush )))
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _hbrush == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
}


/*******************************************************************

    NAME:       SOLID_BRUSH::~SOLID_BRUSH

    SYNOPSIS:   SOLID_BRUSH destructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

SOLID_BRUSH::~SOLID_BRUSH()
{
    if ( _hbrush != NULL )
        ::DeleteObject( (HGDIOBJ)_hbrush );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltmets.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmets.cxx
    METALLIC_STR_DTE implementation

    FILE HISTORY:
        rustanl     22-Jul-1991     Created
        rustanl     07-Aug-1991     Added to BLT
        KeithMo     07-Aug-1992     STRICTified.

*/

#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       METALLIC_STR_DTE::Paint

    SYNOPSIS:   Paints the 3D string DTE

    ENTRY:      hdc -       handle to DC to be used for painting
                prect -     pointer to rectangle in which to paint

    NOTES:      CODEWORK:  Are the below the right colors to use?
                This area is not push-able, so perhaps some hard-coded
                color should be used instead.  Win 3.1 File Man uses
                button colors for its status bar (which resembles this
                more than anything else), whereas Excel's ribbon of
                buttons seems to use some hard-coded colors.

    HISTORY:
        terryk      13-Jun-91   Created as COLUMN_HEADER control
        rustanl     12-Jul-1991 Modified for METALLIC_STR_DTE use
        beng        05-Oct-1991 Win32 conversion
        beng        08-Nov-1991 Unsigned widths
        KeithMo     21-Feb-1992 Use COLOR_BTNHIGHLIGHT instead of white.
                                Also fixed problem of deleting HPENs while
                                they're still selected in the DC.
        beng        30-Mar-1992 Use new DEVICE_CONTEXT wrappers
        beng        28-Jun-1992 Paint text in button colors

********************************************************************/

VOID METALLIC_STR_DTE::Paint( HDC hdc, const RECT * prect ) const
{
#if 0   // we just gotta keep this nifty comment for posterity...

/*
    //  This method will paint an area to look as follows.
    //
    //      .       Background (button face color)
    //      \       Dark shadow (button shadow color)
    //      /       Light shadow (buttin highlight color)
    //      t       text
    //
    //           dxMargin                             dxMargin
    //          /\                                   /\
    // Calc    /.......................................    \  _dyTopMargin
    // Top-   | .......................................    /
    // Text-   \..\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
    // Margin() ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    //          ..\..ttttttttttttttttttttttttttttt../..
    // Calc-   /...//////////////////////////////////..
    // Bottom-| .......................................    \  _dyBottomMargin
    // Text-   \.......................................    /
    // Margin() \___/                             \___/
    //         dxTextMargin                      dxTextMargin
    //
    //
    //
    //
    //
    //  Note, depending on the size of the overall rectangle, the variable
    //  area (the area between the margins) may not fit at all.
    //
*/

    const UINT dxMargin = 3;
    const UINT dxTextMargin = dxMargin + 1 + 2;

    //  First draw the background
    {
        SOLID_BRUSH sbFace( COLOR_BTNFACE );
        if ( sbFace.QueryError() == NERR_Success )
            ::FillRect( hdc, (RECT*)prect, sbFace.QueryHandle());
    }

    //  If there's no space for the variable size region, bag out
    //  now.  The "+1"'s are for the light and dark lines, since the
    //  corners of the light/dark rectangle are not painted (so
    //  as to portray a 3D effect).

    if ( prect->right - prect->left <= 2 * dxMargin + 1 ||
         prect->bottom - prect->top <= _dyTopMargin + _dyBottomMargin + 1 )
    {
        return;
    }

    DEVICE_CONTEXT dc( hdc );

    //  Draw the two lines
    {
        HPEN hpenDark  = ::CreatePen( PS_SOLID, 1,
                                      ::GetSysColor( COLOR_BTNSHADOW ));
        if ( hpenDark == NULL )
        {
            DBGEOL( "METALLIC_STR_DTE::Paint: Pen creation failed" );
        }
        else
        {
            HPEN hpenOld = dc.SelectPen( hpenDark );
            ::MoveToEx( hdc,
                        (int)( prect->left + dxMargin ),
                        (int)( prect->bottom - _dyBottomMargin - 2 ),
                        NULL );
            ::LineTo( hdc,
                      (int)( prect->left + dxMargin ),
                      (int)( prect->top + _dyTopMargin ) );
            ::LineTo( hdc,
                      (int)( prect->right - dxMargin - 1 ),
                      (int)( prect->top + _dyTopMargin ) );

            dc.SelectPen( hpenOld );
            ::DeleteObject( (HGDIOBJ)hpenDark );
        }
    }
    {
        HPEN hpenLight = ::CreatePen( PS_SOLID, 1,
                                      ::GetSysColor( COLOR_BTNHIGHLIGHT ));
        if ( hpenLight == NULL )
        {
            DBGEOL( SZ("METALLIC_STR_DTE::Paint: Pen creation failed") );
        }
        else
        {
            HPEN hpenOld = dc.SelectPen( hpenLight );
            ::MoveToEx( hdc,
                        (int)( prect->left + dxMargin + 1 ),
                        (int)( prect->bottom - _dyBottomMargin - 1 ),
                        NULL );
            ::LineTo( hdc,
                      (int)( prect->right - dxMargin - 1 ),
                      (int)( prect->bottom - _dyBottomMargin - 1 ) );
            ::LineTo( hdc,
                      (int)( prect->right - dxMargin - 1 ),
                      (int)( prect->top + _dyTopMargin ) );

            dc.SelectPen( hpenOld );
            ::DeleteObject( (HGDIOBJ)hpenLight );
        }
    }


    //  Set the background of the area to be that color, so the text
    //  that will paint there will have the correct background.  Note,
    //  that the background mode and color is per dc, so make sure
    //  these are restored on exit.
    {
        INT nOldBkMode = dc.SetBkMode(OPAQUE);
        COLORREF rgbOldBkColor = dc.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
        COLORREF rgbTextPrev = dc.SetTextColor( ::GetSysColor(COLOR_BTNTEXT) );

        //  Call STR_DTE to paint the string
        RECT rect;
        rect.left =   prect->left   + dxTextMargin;
        rect.right =  prect->right  - dxTextMargin;
        rect.top =    prect->top    + CalcTopTextMargin();
        rect.bottom = prect->bottom - CalcBottomTextMargin();
        if ( rect.left <= rect.right )
            STR_DTE::Paint( hdc, &rect );

        //  Restore the old background mode and color for the dc

        dc.SetBkMode( nOldBkMode );
        dc.SetBkColor( rgbOldBkColor );
        dc.SetTextColor( rgbTextPrev );
    }

#else

/*
    //  This method will paint an area to look as follows.
    //
    //      .       Background (button face color)
    //      \       Dark shadow (button shadow color)
    //      /       Light shadow (buttin highlight color)
    //      t       text
    //
    //           dxMargin                       dxMargin+1
    //          /\                             /-\
    // Calc    /.................................\   \  _dyTopMargin
    // Top-   | .................................\   /
    // Text-   \..ttttttttttttttttttttttttttttt..\
    // Margin() ..ttttttttttttttttttttttttttttt..\
    //          ..ttttttttttttttttttttttttttttt..\
    //          ..ttttttttttttttttttttttttttttt..\
    //         /..ttttttttttttttttttttttttttttt..\
    // Calc-  | .................................\   \  _dyBottomMargin
    // Bottom- \.................................\   /
    // Text-
    // Margin()
    //
    //
    //
    //
    //
    //
    //  Note, depending on the size of the overall rectangle, the variable
    //  area (the area between the margins) may not fit at all.
    //
*/

    const UINT dxMargin = 2;

    //
    //  Draw the background.
    //

    {
        SOLID_BRUSH sbFace( COLOR_BTNFACE );

        //
        //  CODEWORK:  We should add FillRect to DEVICE_CONTEXT!
        //

        ::FillRect( hdc, (RECT *)prect, sbFace.QueryHandle() );
    }

    //
    //  If there's no space for the variable size region, bag out
    //  now.
    //

    if( ( prect->right - prect->left <= 2 * dxMargin + 1 ) ||
        ( prect->bottom - prect->top <= (INT)(_dyTopMargin + _dyBottomMargin) ) )
    {
        return;
    }

    DEVICE_CONTEXT dc( hdc );

    //
    //  Draw the right border (line).
    //

    {
        HPEN hpenDark = ::CreatePen( PS_SOLID,
                                     1,
                                     ::GetSysColor( COLOR_BTNSHADOW ) );

        if (NULL != hpenDark) // JonN 01/27/00: PREFIX bug 444900
        {
            HPEN hpenOld = dc.SelectPen( hpenDark );

            dc.MoveTo( (INT)prect->right - 1, 0 );
            dc.LineTo( (INT)prect->right - 1, (INT)prect->bottom );

            dc.SelectPen( hpenOld );
            ::DeleteObject( (HGDIOBJ)hpenDark );
        }
    }

    //
    //  Set the background of the area to be that color, so the text
    //  that will paint there will have the correct background.  Note,
    //  that the background mode and color is per dc, so make sure
    //  these are restored on exit.
    //

    {
        INT nOldBkMode = dc.SetBkMode(OPAQUE);
        COLORREF rgbOldBkColor = dc.SetBkColor( ::GetSysColor(COLOR_BTNFACE) );
        COLORREF rgbTextPrev = dc.SetTextColor( ::GetSysColor(COLOR_BTNTEXT) );

        //  Call STR_DTE to paint the string
        RECT rect;
        rect.left =   prect->left   + dxMargin;
        rect.right =  prect->right  - dxMargin - 1;
        rect.top =    prect->top    + CalcTopTextMargin();
        rect.bottom = prect->bottom - CalcBottomTextMargin();
        if ( rect.left <= rect.right )
            STR_DTE::Paint( hdc, &rect );

        //  Restore the old background mode and color for the dc

        dc.SetBkMode( nOldBkMode );
        dc.SetBkColor( rgbOldBkColor );
        dc.SetTextColor( rgbTextPrev );
    }

#endif

}


/*******************************************************************

    NAME:       METALLIC_STR_DTE::QueryLeftMargin

    SYNOPSIS:   Returns the left margin of this DTE

    RETURNS:    The left margin of this DTE

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

UINT METALLIC_STR_DTE::QueryLeftMargin() const
{
    return 0;
}


const UINT METALLIC_STR_DTE::_dyTopMargin = 1;
const UINT METALLIC_STR_DTE::_dyBottomMargin = 1;


/*******************************************************************

    NAME:       METALLIC_STR_DTE::CalcTopTextMargin

    SYNOPSIS:   Returns the top text margin

    RETURNS:    The top text margin

    NOTES:      See picture at top of METALLIC_STR_DTE::Paint
                function

    HISTORY:
        rustanl     07-Aug-1991 Created
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

UINT METALLIC_STR_DTE::CalcTopTextMargin()
{
    return _dyTopMargin + 1;
}


/*******************************************************************

    NAME:       METALLIC_STR_DTE::CalcBottomTextMargin

    SYNOPSIS:   Returns the bottom text margin

    RETURNS:    The bottom text margin

    NOTES:      See picture at bottom of METALLIC_STR_DTE::Paint
                function

    HISTORY:
        rustanl     07-Aug-1991 Created
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

UINT METALLIC_STR_DTE::CalcBottomTextMargin()
{
    return _dyBottomMargin + 1;
}


/*******************************************************************

    NAME:       METALLIC_STR_DTE::QueryVerticalMargins

    SYNOPSIS:   Returns the number of pixels taken up by vertical margins
                when the DTE is painted.  No text will be painted in
                these margins.

    RETURNS:    Said value

    HISTORY:
        rustanl     07-Aug-1991 Created
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

UINT METALLIC_STR_DTE::QueryVerticalMargins()
{
    return CalcTopTextMargin() + CalcBottomTextMargin();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltmitem.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltmitem.cxx
    MENUITEM implementation


    FILE HISTORY:
	rustanl     11-Jul-1991     Created
	rustanl     12-Jul-1991     Added to BLT
	rustanl     15-Jul-1991     Code review changes (change
				    CLIENT_WINDOW * to APP_WINDOW *)
				    CR attended by BenG, ChuckC,
				    Hui-LiCh, TerryK, RustanL.
	terryk	    27-Nov-1991	    Added SetText for MENUITEM

*/
#include "pchblt.hxx"   // Precompiled header


/*******************************************************************

    NAME:	MENUITEM::MENUITEM

    SYNOPSIS:	MENUITEM constructor

    ENTRY:	pawin - 	Pointer to APP_WINDOW which owns
				the menu
		mid -		Menu item ID

    HISTORY:
	rustanl     11-Jul-1991 Created
	beng	    31-Oct-1991 Added protected ctor taking raw hmenu,
				for derived classes

********************************************************************/

MENUITEM::MENUITEM( APP_WINDOW * pawin, MID mid )
    : _hmenu( ::GetMenu( pawin->QueryHwnd() )),
      _mid( mid )
{
    if ( QueryError() != NERR_Success )
	return;

    if ( _hmenu == NULL )
    {
	DBGEOL( SZ("MENUITEM ct: Cannot find menu") );
	ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
	return;
    }
}


MENUITEM::MENUITEM( HMENU hmenu, MID mid )
    : _hmenu(hmenu),
      _mid(mid)
{
    if ( QueryError() != NERR_Success )
	return;

    if ( _hmenu == NULL )
    {
	DBGEOL( SZ("MENUITEM ct: given null _hmenu") );
	ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
	return;
    }
}


/*******************************************************************

    NAME:	MENUITEM::Enable

    SYNOPSIS:	Enables or disables a menu item

    ENTRY:	f -	TRUE to enable menu item
			FALSE to disable menu item

    EXIT:	Menu item is enabled or disabled, as requested

    HISTORY:
	rustanl     11-Jul-1991     Created
	rustanl     05-Sep-1991     Added MF_GRAYED

********************************************************************/

VOID MENUITEM::Enable( BOOL f )
{
    REQUIRE( ::EnableMenuItem( _hmenu, _mid,
			       MF_BYCOMMAND |
			       ( f ?
				    MF_ENABLED :
				    ( MF_DISABLED | MF_GRAYED ))) != -1 );
}


/*******************************************************************

    NAME:	MENUITEM::IsEnabled

    SYNOPSIS:	Returns whether or not the menu item is enabled

    RETURNS:	TRUE if menu item is enabled; FALSE otherwise

    NOTES:	It is assumed that a menu item is MF_DISABLED'd exactly
		when it is also MF_GRAYED'd.

    HISTORY:
	rustanl     11-Sep-1991 Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

BOOL MENUITEM::IsEnabled() const
{
    UINT nState = ::GetMenuState( _hmenu, _mid, MF_BYCOMMAND );

    //	assert that the menu item is disabled exactly when it is grayed
    UIASSERT( !( nState & MF_ENABLED ) == !( nState & MF_GRAYED ));

    return !( nState & MF_DISABLED );
}


/*******************************************************************

    NAME:	MENUITEM::SetCheck

    SYNOPSIS:	Sets or removes the check mark next to a menu item

    ENTRY:	f -	Specifies whether to set or remove the check mark
			TRUE sets it, whereas FALSE removes it

    EXIT:	The menu item check mark has the requested state

    HISTORY:
	rustanl     11-Jul-1991     Created

********************************************************************/

VOID MENUITEM::SetCheck( BOOL f )
{
    REQUIRE( ::CheckMenuItem( _hmenu, _mid,
			      ( f ? MF_CHECKED : MF_UNCHECKED ) |
			      MF_BYCOMMAND ) != -1 );
}


/*******************************************************************

    NAME:	MENUITEM::IsChecked

    SYNOPSIS:	Returns whether or not the menu item is checked

    RETURNS:	TRUE if menu item is checked; FALSE otherwise

    HISTORY:
	rustanl     11-Sep-1991 Created
	beng	    04-Oct-1991 Made BOOL-safe

********************************************************************/

BOOL MENUITEM::IsChecked() const
{
    return !!( ::GetMenuState( _hmenu, _mid, MF_BYCOMMAND ) & MF_CHECKED );
}

/*******************************************************************

    NAME:	MENUITEM::SetText

    SYNOPSIS:	set the menu item to the given string

    ENTRY:	const TCHAR * pszString - string to be set

    RETURNS:	TRUE if succeed

    HISTORY:
	terryk	    27-Nov-1991	Created

********************************************************************/

BOOL MENUITEM::SetText( const TCHAR * pszString )
{
    return ::ModifyMenu( _hmenu, _mid, MF_BYCOMMAND | MF_STRING, _mid,
	(TCHAR *)pszString );
}

#ifdef WIN32

/*******************************************************************

    NAME:	MENUITEM::ItemExists

    SYNOPSIS:	This static method checks whether the specified menu
                item exists.

    RETURNS:	TRUE if the menu item exists, FALSE otherwise

    HISTORY:
        jonn        19-Mar-1993 Created

********************************************************************/

BOOL MENUITEM::ItemExists( HMENU hmenu, MID mid )
{
    return ( ::GetMenuState( hmenu, mid, MF_BYCOMMAND ) != 0xFFFFFFFF );
}

BOOL MENUITEM::ItemExists( APP_WINDOW * pawin, MID mid )
{
    ASSERT( pawin != NULL );
    HMENU hmenu = ::GetMenu( pawin->QueryHwnd() );
    ASSERT( hmenu != NULL );
    return MENUITEM::ItemExists( hmenu, mid );
}

#endif


/*******************************************************************

    NAME:	SYSMENUITEM::SYSMENUITEM

    SYNOPSIS:	Ctor for system menu item

    ENTRY:	pwnd - pointer to either app or dialog window
		mid  - menu item ID in question

    HISTORY:
	beng	    31-Oct-1991 Created

********************************************************************/

SYSMENUITEM::SYSMENUITEM( OWNER_WINDOW * pwnd, MID mid )
    : MENUITEM ( ::GetSystemMenu( pwnd->QueryHwnd(), FALSE ), mid )
{
    if ( QueryError() != NERR_Success )
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltmsgp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmsgp.cxx
    BLT Message popup functions

    This file defines the BLT MsgPopup functions


    FILE HISTORY:
        Rustanl      7-Dec-1990 Created
        Johnl       14-Feb-1991 Made functional
        Rustanl      4-Mar-1991 Removed comment about QueryRobustHwnd,
                                which is now being used in the header
                                file
        JohnL       19-Apr-1991 Removed vhInst reference, grays Close sys
                                menu item
        beng        14-May-1991 Exploded blt.hxx into components
        beng        23-Oct-1991 Replace min, max
        Yi-HsinS     6-Dec-1991 change behavior of DisplayGenericError
                                when err not in NERR range
        beng        17-Jun-1992 Restructuring, extensive rewrite
        KeithMo     07-Aug-1992 STRICTified.
        Yi-HsinS    10-Aug-1992 Added MPSEV_QUESTION
        JonN        25-Aug-1992 Merged in PERFORMER::DisplayError()
        Yi-HsinS    09-Oct-1992 Added SetHelpContextBase()
*/

#include "pchblt.hxx"   // Precompiled header

#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

inline INT min(INT a, INT b)
{
    return (a < b) ? a : b;
}

inline INT max(INT a, INT b)
{
    return (a > b) ? a : b;
}

// Maximum number of buttons that can be displayed at one time
#define MAX_DISPLAY_BUTTONS     4

// Maximum number of characters of the lanman message box captions
#define MAX_CAPTION_LEN 80

// Number of dialog units between controls in the dialog box
#define DU_DIST_BETWEEN_BUTTONS    3

// Number of dialog units between controls in the dialog box and the edge of
// the dialog box
#define DU_DIST_TO_DLG_EDGE        6

// The following two macros convert horizontal and vertical (respectively)
// dialog unit measurements to pixel measurements
// lBaseUnits == the value returned from GetDialogBaseUnits
// w?DlgUnits == Vert.or Horiz. dialog units
#define HDUTOPIXELS( lBaseUnits, wXDlgUnits ) \
                    ( (wXDlgUnits*LOWORD( lBaseUnits ))/4 )

#define VDUTOPIXELS( lBaseUnits, wYDlgUnits ) \
                    ( (wYDlgUnits*HIWORD( lBaseUnits ))/8 )


/*************************************************************************

    NAME:       MSGPOPUP_DIALOG

    SYNOPSIS:   Class that handles all of the dialog aspects of the message
                popup dialog

    INTERFACE:

    PARENT:     DIALOG_WINDOW

    USES:       PUSH_BUTTON, ICON_CONTROL, SLT

    CAVEATS:

    NOTES:
        Private to message-popup module.

    HISTORY:
        Johnl       7-Feb-1991  Added meat to Rustan's original outline
        beng        30-Sep-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

**************************************************************************/

class MSGPOPUP_DIALOG : public DIALOG_WINDOW
{
private:
    PUSH_BUTTON   _pbOK, _pbCancel, _pbYes, _pbNo, _pbHelp;
    PUSH_BUTTON * _appbDisplay[MAX_DISPLAY_BUTTONS + 1];
    ICON_CONTROL  _iconSev;
    SLT           _sltMsgText;      // Message gets displayed in this
    ULONG         _ulHC;            // Save the help context
    UINT          _usMessageNum;    // Save the message number
    MSGID         _msgidCaption;    // Caption, if set

    VOID FillButtonArray( UINT usButtons, INT *piWidthReq, INT *piHeightReq );
    VOID PlaceButtons();
    PUSH_BUTTON * QueryButton( UINT usMsgPopupButton );
    const TCHAR * QueryIcon( MSG_SEVERITY msgsev );

    static BOOL Msg2HC( MSGID msgid, ULONG * hc );

protected:
    virtual BOOL OnOK();
    virtual BOOL OnCancel();
    virtual BOOL OnCommand( const CONTROL_EVENT & e );
    virtual ULONG QueryHelpContext();

public:
    MSGPOPUP_DIALOG( HWND           hwndParent,
                     const NLS_STR& nlsMessage,
                     MSGID          msgid,
                     MSG_SEVERITY   msgsev,
                     ULONG          ulHelpContext,
                     UINT           nButtons,
                     UINT           nDefButton,
                     MSGID          msgidCaption = 0,
                     ULONG          ulHelpContextBase = 0 );

    ~MSGPOPUP_DIALOG();
};


//
// Local variables
//

NLS_STR * POPUP::_vpnlsEmergencyText = NULL;
NLS_STR * POPUP::_vpnlsEmergencyCapt = NULL;
MSGID     POPUP::_vmsgidCaption = 0;
ULONG     POPUP::_ulHelpContextBase = 0;
MSGMAPENTRY * POPUP::_vpmmeTable = NULL;

BOOL      POPUP::_fInit = FALSE;

POPUP::POPUP( HWND hwndOwner, MSGID msgid, MSG_SEVERITY msgsev,
              UINT nButtons, UINT nDefButton, BOOL fTrySystem )
    : _hwndParent(hwndOwner),
      _msgid( msgid ),
      _msgsev(msgsev),
      _ulHelpContext(HC_DEFAULT_HELP),
      _nButtons(nButtons),
      _nDefButton(CalcDefButton(nButtons, nDefButton)),
      _pnlsText(NULL)
{

    _pnlsText = LoadMessage(msgid, fTrySystem);
    if (_pnlsText == NULL)
        return; // already reported error
}


POPUP::POPUP( HWND hwndOwner, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG ulHelpTopic, UINT nButtons,
              const NLS_STR ** apnlsParams, UINT nDefButton )
    : _hwndParent(hwndOwner),
      _msgid( msgid ),
      _msgsev(msgsev),
      _ulHelpContext(ulHelpTopic),
      _nButtons(nButtons),
      _nDefButton(CalcDefButton(nButtons, nDefButton)),
      _pnlsText(NULL)
{

    _pnlsText = LoadMessage(msgid);
    if (_pnlsText == NULL)
        return; // already reported error

    if (apnlsParams != NULL)
    {
        if (_pnlsText->InsertParams( apnlsParams ) != NERR_Success)
        {
            Emergency();
            ReportError(1); // A simple true/false will suffice
            return;
        }
    }
}


#if 0 // strlist form never used
POPUP::POPUP( HWND hwndOwner, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG ulHelpContext, UINT nButtons,
              STRLIST & strlst, UINT nDefButton )
    : _hwndParent(hwndOwner),
      _msgid( msgid ),
      _msgsev(msgsev),
      _ulHelpContext(ulHelpContext),
      _nButtons(nButtons),
      _nDefButton(CalcDefButton(nButtons, nDefButton)),
      _pnlsText(NULL)
{

    _pnlsText = LoadMessage(msgid);
    if (_pnlsText == NULL)
        return; // Already reported the error

    // Get a vector which will accommodate the strlist

    ITER_STRLIST iter(strlst);
    UINT cnls = 0;
    while (iter.Next() != NULL)
        ++cnls;

    NLS_STR ** apnlsParams = (NLS_STR**) new NLS_STR* [cnls+1];
    if (apnlsParams == NULL)
    {
        Emergency();
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    // Copy the strlist into the vector

    iter.Reset();
    cnls = 0; // This time, it's an index instead of a count
    while ((apnlsParams[cnls] = iter.Next()) != NULL)
        ++cnls;

    APIERR err;
    if ((err = _pnlsText->InsertParams( apnlsParams )) != NERR_Success)
    {
        Emergency();
        ReportError(err);
        delete[] apnlsParams;
        return;
    }

    delete[] apnlsParams;
}
#endif // never used


POPUP::~POPUP()
{
    delete _pnlsText;
}



/*******************************************************************

    NAME:       POPUP::SetMsgMapTable

    SYNOPSIS:  Sets the message mapping table.

    INPUT:     pmmeTable - mapping table allocated by the application

    RETURNS:   none

    HISTORY:
        thomaspa    13-Apr-1993 Created

********************************************************************/
VOID POPUP::SetMsgMapTable( MSGMAPENTRY * pmmeTable )
{
    _vpmmeTable = pmmeTable;
}

/*******************************************************************

    NAME:       POPUP::MapMessage

    SYNOPSIS:  Uses the Application supplied message map table to map
               the input message.

    INPUT:      Message to be mapped.

    RETURNS:    The mapped message.

    HISTORY:
        thomaspa    13-Apr-1993 Created

********************************************************************/
MSGID POPUP::MapMessage( MSGID msgidIn )
{
    MSGID msgidRet = msgidIn;
    if ( _vpmmeTable != NULL )
    {
        for ( INT i = 0; _vpmmeTable[i].msgidIn != 0; i++ )
        {
            if ( msgidIn == _vpmmeTable[i].msgidIn )
            {
                msgidRet = _vpmmeTable[i].msgidOut;
                break;
            }
        }
    }
    return msgidRet;
}

/*******************************************************************

    NAME:       POPUP::Emergency

    SYNOPSIS:   This popup gets called when MsgPopup gets stuck due to
                Low memory or resource failures.  It is guaranteed to come
                up and will display either "Low memory" or "Can't load
                resource"

    RETURNS:    Identifier of the default button.

    NOTES:
        InitMsgPopup must be called before calling this function.

    HISTORY:
        Johnl       5-Feb-1991  Created
        beng        17-Jun-1992 Restructured, rewritten

********************************************************************/

INT POPUP::Emergency() const
{
    ASSERT( _fInit );
    ASSERT( _vpnlsEmergencyText != NULL && _vpnlsEmergencyCapt != NULL );

    ::MessageBox( _hwndParent,
                  (TCHAR*)_vpnlsEmergencyText->QueryPch(),
                  (TCHAR*)_vpnlsEmergencyCapt->QueryPch(),
                  (UINT)  ( MB_ICONHAND | MB_SYSTEMMODAL) );

    return MapButton(_nDefButton);
}


/*******************************************************************

    NAME:     POPUP::Init

    SYNOPSIS: Initializes resource strings at start, returns NERR_Success
              if successful, ERROR_NOT_ENOUGH_MEMORY if a memory
              failur. occurred or ERROR_GEN_FAILURE if a resource could
              not be loaded.

              The application should not continue if InitMsgPopup
              returns an error.

    ENTRY:

    EXIT:
        Loads the resources required for emergency situations

    NOTES:
        Should fold into the rest of BLTInit

    HISTORY:
        Johnl       12-Feb-1991 Created
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructured
        beng        23-Jul-1992 Tune error reporting a bit

********************************************************************/

APIERR POPUP::Init()
{
# if !defined(WIN32)
    DWORD wWinFlags = ::GetWinFlags();
    ASSERT( wWinFlags & WF_PMODE );
# endif

    ASSERT(!_fInit);
    _fInit = TRUE;

    _vpnlsEmergencyText = new NLS_STR;
    _vpnlsEmergencyCapt = new NLS_STR;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _vpnlsEmergencyText == NULL
        || _vpnlsEmergencyCapt == NULL
        || (err = _vpnlsEmergencyText->Load( (MSGID) IDS_BLT_TEXT_MSGP )) != NERR_Success
        || (err = _vpnlsEmergencyCapt->Load( (MSGID) IDS_BLT_CAPT_MSGP )) != NERR_Success )
    {
        DBGEOL("POPUP::Init: failed, error " << err);
        POPUP::Term();
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:     POPUP::Term

    SYNOPSIS: Uninitializes the message popup stuff.  Free the emergency
              strings allocated by InitMsgPopup

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl       12-Feb-1991 Created
        beng        17-Jun-1992 Restructured

********************************************************************/

VOID POPUP::Term()
{
    ASSERT( _fInit );
    _fInit = FALSE;

    delete _vpnlsEmergencyText;
    delete _vpnlsEmergencyCapt;

    _vpnlsEmergencyText = _vpnlsEmergencyCapt = NULL;
}


/*******************************************************************

    NAME:       POPUP::LoadMessage

    SYNOPSIS:   Loads the initial message string from the resource file
                and puts up an appropriate popup if any error occurred.

    ENTRY:      msgid - Message/string resource ID to retrieve
                fTrySystem - set if system error text is interesting

    RETURNS:    Pointer to a newly allocated NLS_STR that contains the message
                text, or NULL if an error occurred (in which case it reports
                the error).

    CAVEATS:
        * THE CLIENT IS RESPONSIBLE FOR DELETING THE RETURNED NLS_STR*! *

    NOTES:
        A popup will be displayed if an error occurs.  The text is
        dependent on the range of msgid.  The text will be:

        "DOS error %1 occurred" if  0 < msgid < NERR_BASE
        "Network error %1 occurred" if NERR_BASE <= msgid <= MAX_NERR
        "LAN Manager network driver error %1 occurred" anything else.

    HISTORY:
        Johnl       19-Mar-1991 Created
        beng        04-Oct-1991 Win32 conversion
        beng        21-Nov-1991 Remove STR_OWNERALLOC
        beng        27-Feb-1992 Add InsertParams call
        beng        05-Mar-1992 Remove ltoa usage
        beng        17-Jun-1992 Restructured, rewritten
        beng        05-Aug-1992 Use NLS_STR::LoadSystem
        KeithMo     06-Jan-1993 Map ERROR_MR_MID_NOT_FOUND to
                                IDS_BLT_UNKNOWN_ERROR.

********************************************************************/

NLS_STR * POPUP::LoadMessage( MSGID msgid, BOOL fTrySystem )
{
    NLS_STR * pnlsMessage = new NLS_STR( MAX_RES_STR_LEN + 1 );

    msgid = POPUP::MapMessage( msgid );

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pnlsMessage == NULL
        || (err = pnlsMessage->QueryError()) != NERR_Success )
    {
        delete pnlsMessage;
        Emergency();
        ReportError(err);
        return NULL;
    }

    if( msgid == ERROR_MR_MID_NOT_FOUND )
    {
        //
        //  ERROR_MR_MID_NOT_FOUND is returned by RtlNtStatusToDosError
        //  if there was no ERROR_* code corresponding to a particular
        //  STATUS_* code.  We'll map this to IDS_BLT_UNKNOWN_ERROR,
        //  which is slightly less cryptic than the text associated
        //  with ERROR_MR_MID_NOT_FOUND.
        //

        msgid = IDS_BLT_UNKNOWN_ERROR;
    }

    // Attempt to load the string; if successful, return it.

    if ((err = pnlsMessage->Load( msgid )) == NERR_Success)
        return pnlsMessage;

    // If appropriate, next try the system for the text.

#if defined(WIN32)
    if (fTrySystem)
    {
        if ((err = pnlsMessage->LoadSystem(msgid)) == NERR_Success)
            return pnlsMessage;
    }
#endif

    // Didn't find the string.

    if (   msgid == IDS_BLT_DOSERROR_MSGP
        || msgid == IDS_BLT_NETERROR_MSGP
        || msgid == IDS_BLT_WINNET_ERROR_MSGP )
    {
        // Prevent recursion

        Emergency();
    }
    else
    {
        // Convert the message number to an NLS_STR so we can insert it into
        // the message string.
        //
        const DEC_STR nlsDecMsgNum(msgid);
        const HEX_STR nlsHexMsgNum(msgid);
        const NLS_STR * apnls[2]; // Do this by hand here
        apnls[0] = &nlsDecMsgNum;
        apnls[1] = NULL;

        MSGID idMessage;

        if ( msgid >= 0 && msgid < NERR_BASE )
            idMessage = IDS_BLT_DOSERROR_MSGP;
        else if ( msgid >= NERR_BASE && msgid <= MAX_NERR )
            idMessage = IDS_BLT_NETERROR_MSGP;
        else if ( msgid > MAX_NERR && msgid < 0x10000000 )
            idMessage = IDS_BLT_WINNET_ERROR_MSGP;
        else
        {
            DBGEOL( "NETUI: MsgPopup: NTSTATUS error code " << msgid );
            ASSERT( FALSE );
            idMessage = IDS_BLT_NTSTATUS_ERROR_MSGP;
            apnls[0] = &nlsHexMsgNum;
        }

        // Post the stand-in popup.  If this fails, the next time
        // through it will hit the Emergency case above.

        POPUP popup(_hwndParent, idMessage, MPSEV_ERROR, (ULONG)HC_NO_HELP,
                    MP_OK, apnls, MP_UNKNOWN);
        popup.Show();
    }

    // This was an error path; return NULL, which will prematurely
    // terminate the caller.  (All the above popups took place in the
    // caller's ctor.)

    delete pnlsMessage;
    ReportError(err);
    return NULL;
}


/*******************************************************************

    NAME:      POPUP::CalcDefButton

    SYNOPSIS:  Returns usDefButton (input value) if usDefButton != 0
               else it selects the appropriate default from the presented
               selection in usButtons (will either be OK, or Yes).

    ENTRY:

    EXIT:

    CAVEATS:
        nButtons must contain either MP_OK or MP_YES

    NOTES:
        This is a static, private member function.

    HISTORY:
        Johnl       15-Feb-1991 Created
        beng        17-Jun-1992 Restructured

********************************************************************/

INT POPUP::CalcDefButton( UINT nButtons, UINT nDefButton )
{
    if ( nDefButton == MP_UNKNOWN )
    {
        if ( nButtons & MP_OK )
            nDefButton = MP_OK;
        else if ( nButtons & MP_YES )
            nDefButton = MP_YES;
        else
        {
            DBGEOL("BLT: MSGPOPUP::CalcDefButton - Bad button combination");
            ASSERT(FALSE);
        }
    }

    return nDefButton;
}


/*******************************************************************

    NAME:       POPUP::MapButton

    SYNOPSIS:   Converts a MP button code to the CID

    ENTRY:      MP button code (MP_OK, etc.)

    RETURNS:    CID

    NOTES:
        This is a static, private member function.

    HISTORY:
        beng        17-Jun-1992 Created

********************************************************************/

INT POPUP::MapButton( UINT nButton )
{
    switch (nButton)
    {
    case MP_OK:
        return IDOK;

    case MP_YES:
        return IDYES;

    case MP_NO:
        return IDNO;

    case MP_CANCEL:
        return IDCANCEL;

    default:
        DBGEOL("BLT: Unknown MP button code passed to MsgPopup");
        ASSERT(FALSE);
        return IDCANCEL;
    }
}


/*******************************************************************

    NAME:      POPUP::Show

    SYNOPSIS:  Worker routine for the message popup stuff, this is the
               routine that actually puts up the dialog box

    ENTRY:     hwndParent - Parent window handle
               nlsMessage - Expanded message to display
               msgid      - Message number (used to obtain help context)
               msgsev     - Message severity, determines icon
               ulHelpContext - Help file context, 0 if we should use #
                               associated with msgid from the resource file.
               usButtons  - Buttons to display
               usDefButton- Default button, 0 to use windows default

    EXIT:      Returns button pressed or the default button

    NOTES:     If no buttons were passed in usButtons, then the OK button
               is displayed by default.

    HISTORY:
        JohnL       1/31/91     Created
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructured, rewritten

********************************************************************/

INT POPUP::Show()
{
    ASSERT( _fInit );

    /* Must have at least OK button...
     */
    ASSERT( _nButtons );
    if ( _nButtons == 0 )
        _nButtons |= MP_OK;

    if (QueryError())
        return MapButton(_nDefButton);

    MSGPOPUP_DIALOG dlgMsgPopup( _hwndParent, *_pnlsText, _msgid, _msgsev,
                                 _ulHelpContext, _nButtons, _nDefButton,
                                 _vmsgidCaption, _ulHelpContextBase );
    if (!dlgMsgPopup)
        return Emergency();

    // Process the dialog.

    UINT nButtonUserPressed;
    if ( dlgMsgPopup.Process( &nButtonUserPressed ) != NERR_Success )
    {
        return Emergency();
    }

    return (INT) nButtonUserPressed;
}


/*******************************************************************

    NAME:      POPUP::SetCaption

    SYNOPSIS:  Set the default caption

    ENTRY:     msgid      - ID of title

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Outlined as part of dllization delta

********************************************************************/

VOID POPUP::SetCaption( MSGID msgid )
{
    _vmsgidCaption = msgid;
}


/*******************************************************************

    NAME:      POPUP::ResetCaption

    SYNOPSIS:  Reset the default caption to its original setting

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Outlined as part of dllization delta

********************************************************************/

VOID POPUP::ResetCaption()
{
    _vmsgidCaption = 0;
}

/*******************************************************************

    NAME:      POPUP::SetHelpContextBase

    SYNOPSIS:  Set the help context base for the help contexts
               contained in the msg2help.tbl

    ENTRY:     ulHelpContextBase - the base of the help contexts

    RETURNS:   Returns the old help context base

    NOTES:
        This is a static member function.

    HISTORY:
        Yi-HsinS     09-Oct-1992 Created

********************************************************************/

ULONG POPUP::SetHelpContextBase( ULONG ulHelpContextBase )
{
    ULONG ulOldHelpContextBase = _ulHelpContextBase;
    _ulHelpContextBase = ulHelpContextBase;
    return ulOldHelpContextBase;
}

/*******************************************************************

    NAME:      MSGPOPUP_DIALOG::MSGPOPUP_DIALOG

    SYNOPSIS:  Constructor for Message popup dialog

    ENTRY:

    EXIT:

    NOTES:     Initializes the controls and places everything where it
               is supposed to go.

               Note: You cannot make the help button the default button.
               If no default is specified, then either the OK or Yes button
               gets the default (specified in the resource file).

         The dialog box looks roughly like:

              +---------------------------------------------------------+
              | - |                     Lan Manager                     |
              +---+-----------------------------------------------------+
              |             : } Six DUs
              |     +-----+
              |     |     |
              |     |     |     This is some message text
              |     |     |
              |^^^^^+-----+^^^^^
              |{six DUs) : {six DUs}
              |          :
              |   6 DUs {:     3DUs between buttons, 6DUs on each side
              |         |   OK   |    |  Cancel  |    |   Help   |
              |     6 DUs to frame {:
              +-----------------------------------------------

    HISTORY:
        Johnl       5-Feb-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        20-Feb-1992 Uses numeric resource ID for dialog

********************************************************************/

MSGPOPUP_DIALOG::MSGPOPUP_DIALOG( HWND           hwndParent,
                                  const NLS_STR& nlsMessage,
                                  MSGID          msgid,
                                  MSG_SEVERITY   msgsev,
                                  ULONG          ulHelpContext,
                                  UINT           usButtons,
                                  UINT           usDefButton,
                                  MSGID          msgidCaption,
                                  ULONG          ulHelpContextBase )
  : DIALOG_WINDOW( IDD_BLT_HELPMSG, hwndParent ),
    _pbOK( this, IDOK ),
    _pbCancel( this, IDCANCEL ),
    _pbYes( this, IDYES ),
    _pbNo( this, IDNO ),
    _pbHelp( this, IDHELPBLT ),
    _sltMsgText( this, IDC_MSGPOPUPTEXT ),
    _iconSev( this, IDC_MSGPOPUPICON )
{
    UNREFERENCED( hwndParent );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _iconSev.SetPredefinedIcon( QueryIcon( msgsev ) );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    /* Is there a help context available?  If no, then we won't display
     * the help button.
     */
    if ( ulHelpContext == HC_DEFAULT_HELP )
    {
        if ( !Msg2HC( msgid, &ulHelpContext ) )
            ulHelpContext = (ULONG) HC_NO_HELP;
        else
            ulHelpContext += ulHelpContextBase;
    }

#if defined(DEBUG)
    switch (ulHelpContext)
    {
    case HC_NO_HELP:
        DBGEOL( "Msgpopup help = HC_NO_HELP" );
        break;
    case HC_DEFAULT_HELP:
        DBGEOL( "Msgpopup help = HC_DEFAULT_HELP" );
        break;
    default:
        DBGEOL( "Msgpopup help = " << ulHelpContext );
        break;
    }
#endif

    _ulHC = ulHelpContext;
    _usMessageNum = (UINT) msgid;
    _sltMsgText.SetText( nlsMessage.QueryPch() );

    // If the client has requested an alternate caption, set it here.

    if (msgidCaption != 0)
    {
        RESOURCE_STR nlsCaption(msgidCaption);
        if (!nlsCaption)
        {
            DBGEOL("BLT: Couldn't load alternate popup caption "
                   << msgidCaption);
        }
        else
        {
            SetText(nlsCaption);
        }
        // If this failed, carry on.
    }

    /* Now we need to figure how large to make the dialog box, we will get
     * the minimum of each group then set the size accordingly.  There are
     * two groups, the button group and the icon + text group.
     */
    INT  cxButtons, cyButtons,
         cxIcon,    cyIcon,
         cxCaption,
         cxMaxCapBtn;            // Maximum between cxButtons & cxCaption
    LONG lBaseDlgUnits = GetDialogBaseUnits();

    /* Margins for controls (6 DUs)
     */
    INT  cxBigContMargin = HDUTOPIXELS( lBaseDlgUnits, DU_DIST_TO_DLG_EDGE );
    INT  cyBigContMargin = VDUTOPIXELS( lBaseDlgUnits, DU_DIST_TO_DLG_EDGE );

    DISPLAY_CONTEXT dcDlg( QueryHwnd() );
    SCREEN_DC dcScreen;
    RECT rcText;            // Message text bounding rectangle

    if ( dcDlg.QueryHdc() == NULL || dcScreen.QueryHdc() == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }

    HFONT hfontDlg = dcDlg.SelectFont( _sltMsgText.QueryFont() );

    /* Get the width of the caption + width of system menu and the width of
     * the button group, then compute the maximum between the two
     */
    STACK_NLS_STR( nlsCaption, MAX_CAPTION_LEN );
    QueryText(&nlsCaption);

    XYDIMENSION dxy = dcScreen.QueryTextExtent( nlsCaption );

    cxCaption = dxy.QueryWidth() + GetSystemMetrics( SM_CXSIZE );

    FillButtonArray( usButtons, &cxButtons, &cyButtons );

    cxMaxCapBtn = max( cxButtons, cxCaption );

    /* Compute the maximum width we will allow the dialog to be.
     * This is 5/8 of the screen width (this was taken directly from the
     * windows code).
     */
    INT cxMBMax = ( GetSystemMetrics( SM_CXSCREEN ) >> 3 ) * 5;

    /* This is the max width we will allow the text to be
     *  Max text width = Max dialog width - left & right borders - icon width - icon border
     */
    _iconSev.QuerySize( &cxIcon, &cyIcon );
    INT cxTextMax = cxMBMax - 3*cxBigContMargin - cxIcon;

    /* Use DrawText to calculate how high the resultant text will be.
     * (with DT_CALCRECT the text is not drawn, but rcText will be adjusted
     * to bound the text).
     *
     * The DT_* parameters are the same used by the windows message box
     * function (see winmsg.c).
     */
    SetRect( &rcText, 0, 0, cxTextMax, cxTextMax );
    INT cyText = dcDlg.DrawText(nlsMessage, &rcText,
                                DT_CALCRECT   |
                                DT_WORDBREAK  |
                                DT_EXPANDTABS | DT_NOPREFIX );
    INT cxText = (INT) ( rcText.right - rcText.left );
    _sltMsgText.SetSize( (INT) rcText.right, (INT) rcText.bottom );

    /* Find the window size -
     *    x = max( Cap/But, text width ) + 3 wide borders + dlgframe width
     *    y = Button group height + max( text, icon ) + 1 larger border +
     *          caption height + dlgframe height
     */
    INT cxBox = max( cxMaxCapBtn, cxText) + cxIcon + 3 * cxBigContMargin + GetSystemMetrics( SM_CXDLGFRAME );
    INT cyBox = cyButtons + max( cyText, cyIcon ) + cyBigContMargin +
                GetSystemMetrics( SM_CYCAPTION ) + GetSystemMetrics( SM_CYDLGFRAME );
    SetSize( cxBox, cyBox );

    /* Place the dialog centered over the app, checking to make sure we
     * don't go off the screen.
     */
    INT xScreen = GetSystemMetrics( SM_CXSCREEN );
    INT yScreen = GetSystemMetrics( SM_CYSCREEN );
    INT xParent, yParent, cxParent, cyParent;

    if ( QueryOwnerHwnd() != NULL )
    {
        RECT rect;
        ::GetWindowRect( QueryOwnerHwnd(), &rect );
        xParent = (INT) rect.left;
        yParent = (INT) rect.top;
        cxParent= (INT) (rect.right - rect.left);
        cyParent= (INT) (rect.bottom - rect.top);
    }
    else
    {
        xParent = yParent = 0;
        cxParent = xScreen;
        cyParent = yScreen;
    }

    POINT ptDlgBox;
    ptDlgBox.x = xParent + cxParent/2 - cxBox/2;
    ptDlgBox.y = yParent + cyParent/2 - cyBox/2;

    ptDlgBox.x = max( 0, (INT) ptDlgBox.x );
    ptDlgBox.y = max( 0, (INT) ptDlgBox.y );
    ptDlgBox.x = min( (INT) (xScreen - cxBox), (INT) ptDlgBox.x );
    ptDlgBox.y = min( (INT) (yScreen - cyBox), (INT) ptDlgBox.y );

    SetPos( ptDlgBox );

    /* Determine where to place the icon and the text on the dialog box.
     * They get placed half way between the button group and the top of the
     * client area in the y direction.  In the x direction, the icon gets
     * placed one large margin width from the left of the control, then the
     * text gets placed one large margin width to the right of the icon
     */
    INT cyCapIconMidpt = (2*cyBigContMargin + max( cyIcon, cyText ))/2;
    {
        XYPOINT xyIconPos(cxBigContMargin,
                          cyCapIconMidpt - cyIcon/2);
        XYPOINT xyTextPos(xyIconPos.QueryX() + cxIcon + cxBigContMargin,
                          cyCapIconMidpt - cyText/2);

        _iconSev.SetPos( xyIconPos );
        _sltMsgText.SetPos( xyTextPos );
    }

    PlaceButtons();

    /* Set the default button if it's specified and give it the focus
     * First we assert that if a default button is specified, that it had
     * better be one of the requested buttons to display.
     */
    ASSERT( (usButtons & usDefButton) );
    PUSH_BUTTON * pbDefault;
    if ( (pbDefault = QueryButton( usDefButton )) != NULL )
    {
        pbDefault->MakeDefault();
        pbDefault->ClaimFocus();
    }

    dcDlg.SelectFont( hfontDlg );
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::~MSGPOPUP_DIALOG

   HISTORY:
        Johnl   5-Feb-1991  Created

**********************************************************************/

MSGPOPUP_DIALOG::~MSGPOPUP_DIALOG()
{
    // Nothing to do...
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::OnOK

   HISTORY:
        Johnl   5-Feb-1991  Created

**********************************************************************/

BOOL MSGPOPUP_DIALOG::OnOK()
{
    Dismiss( IDOK );
    return TRUE;
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::OnCancel

   HISTORY:
        Johnl   5-Feb-1991  Created

**********************************************************************/

BOOL MSGPOPUP_DIALOG::OnCancel()
{
    /* OnCancel won't be called if there is no cancel button displayed
     * (since the Close system menu option was disabled).
     */
    Dismiss( IDCANCEL );
    return TRUE;
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::OnCommand

   HISTORY:
        Johnl       5-Feb-1991  Created
        beng        30-Sep-1991 Win32 conversion

**********************************************************************/

BOOL MSGPOPUP_DIALOG::OnCommand( const CONTROL_EVENT & e )
{
    switch ( e.QueryCid() )
    {
    case IDYES:
        Dismiss( IDYES );
        return TRUE;

    case IDNO:
        Dismiss( IDNO );
        return TRUE;

    default:
        break;
    }

    return DIALOG_WINDOW::OnCommand( e );
}


/**********************************************************************

    NAME:       MSGPOPUP_DIALOG::QueryHelpContext

    SYNOPSIS:   Return help context for popup (callback)

    HISTORY:
        Johnl       5-Feb-1991      Created

**********************************************************************/

ULONG MSGPOPUP_DIALOG::QueryHelpContext()
{
    return _ulHC;
}


/*******************************************************************

    NAME:     MSGPOPUP_DIALOG::FillButtonArray

    SYNOPSIS: Looks at the usButton parameter and fills the class member
              _appbDisplay (array of buttons to display on the message box).
              The ordering of the buttons is determined in this function.

    ENTRY:

    EXIT:      Returns minimum width and height (in pixels) the dialog box
               needs to be to accomodate the buttons requested in piWidthReq and
               piHeightReq respectively.

    NOTES:

    HISTORY:
        Johnl   11-Feb-1991     Created

********************************************************************/

VOID MSGPOPUP_DIALOG::FillButtonArray(
    UINT usButtons,
    INT  * piWidthReq,
    INT  * piHeightReq )
{
    INT iButtonIndex = 0;

    // Watch for invalid button combinations
    ASSERT( !( (usButtons & MP_OK) && (usButtons & MP_YES) ) );

    if ( usButtons & MP_OK )
        _appbDisplay[iButtonIndex++] = &_pbOK;
    else
    {
        _pbOK.Show(FALSE);
        _pbOK.Enable(FALSE);
    }

    if ( usButtons & MP_YES )
        _appbDisplay[iButtonIndex++] = &_pbYes;
    else
    {
        _pbYes.Show(FALSE);
        _pbYes.Enable(FALSE);
    }

    if ( usButtons & MP_NO )
        _appbDisplay[iButtonIndex++] = &_pbNo;
    else
    {
        _pbNo.Show(FALSE);
        _pbNo.Enable(FALSE);
    }

    if ( usButtons & MP_CANCEL )
        _appbDisplay[iButtonIndex++] = &_pbCancel;
    else
    {
        /* Delete the "Close" system menu item if there isn't a Cancel
         * button
         */
        HMENU hSysMenu = ::GetSystemMenu( QueryHwnd(), FALSE );
        ASSERT( hSysMenu != NULL );
        if ( !::DeleteMenu( hSysMenu, SC_CLOSE, (UINT) MF_BYCOMMAND ) )
        {
            DWORD dwErr = ::GetLastError();
            DBGEOL( "NETUI2.DLL: MSGPOPUP_DIALOG::FillButtonArray; DeleteMenu error "
                    << dwErr );
            ASSERT(FALSE); // JonN 8/7/95 see bug report 16768
        }

        _pbCancel.Show(FALSE);
        _pbCancel.Enable(FALSE);
    }

    if ( _ulHC != HC_NO_HELP )
        _appbDisplay[iButtonIndex++] = &_pbHelp;
    else
    {
        _pbHelp.Show(FALSE);
        _pbHelp.Enable(FALSE);
    }

    ASSERT( iButtonIndex > 0 && iButtonIndex <= MAX_DISPLAY_BUTTONS );

    /* Terminate the array
     */
    _appbDisplay[iButtonIndex] = NULL;

    /* The minimum width of the dialog box to display the requested buttons
     * plus the borders is:
     *  Width Req.= 2 * the distance between the end button and the dialog edge +
     *              (# of buttons -1) * distance between buttons +
     *              The width of each button
     */
    LONG lBaseUnits = GetDialogBaseUnits();
    *piWidthReq = 2*HDUTOPIXELS( lBaseUnits, DU_DIST_TO_DLG_EDGE ) +
                    (iButtonIndex-1) * HDUTOPIXELS( lBaseUnits, DU_DIST_BETWEEN_BUTTONS);

    for ( INT i = 0 ; _appbDisplay[i] != NULL ; i++ )
    {
        INT iWidth, iHeight;
        _appbDisplay[i]->QuerySize( &iWidth, &iHeight );

        *piWidthReq += iWidth;
    }

    /* The height of the button group plus border is:
     *   Height Req. = 2* white space border + height of 1st button
     */
    INT iWidth;
    _appbDisplay[0]->QuerySize( &iWidth, piHeightReq );
    *piHeightReq += 2*VDUTOPIXELS( lBaseUnits, DU_DIST_TO_DLG_EDGE );
}


/*******************************************************************

    NAME:     MSGPOPUP_DIALOG::PlaceButtons

    SYNOPSIS: Uses the class member array _appbDisplay filled by
              FillButtonArray and places/sizes the buttons according
              to the MS UI Style guide (Chapter 7).  Also sets the
              default button.  There must be at least one button in
              the button array.

    ENTRY:

    EXIT:

    NOTES:
        The current draft of the style guide states that:

        ...center the group of buttons and space them evenly
        within the group, leaving at least 3 DUs between the
        right edge of one button and the left edge of the next.
        Leave at least 6 DUs between the edge of the dialog
        and the edges of the buttons.  Normally the buttons should
        all be the same width, but individual buttons may be
        made wider to accommodate exceptionally long text...

        It is assumed that the current size of the dialog box is the
        size that will be displayed and that it is at least as wide
        as the value returned by FillButtonArray

        The height of the buttons is determined from the
        first button.  It is assumed that all buttons are of the
        same height (width doesn't matter).

    HISTORY:
        Johnl   11-Feb-1991     Created

********************************************************************/

VOID MSGPOPUP_DIALOG::PlaceButtons()
{
    LONG lDlgBaseUnits = ::GetDialogBaseUnits();
    INT iButtonWidth, iButtonHeight, iDlgWidth, iDlgHeight;

    /* Get the height of the first button (assumed all buttons are of the
     * same height).
     */
    _appbDisplay[0]->QuerySize( &iButtonWidth, &iButtonHeight );

    /* Get the width and height of the dialog for button placement calc.
     */
    QuerySize( &iDlgWidth, &iDlgHeight );

    /* The y-position of the buttons is the height of the dialog minus
     * 6 dialog units minus the height of the button minus the caption
     * bar minus 2 * the horizonatal frame (top & bottom)
     */
    POINT ptButtonPos;
    ptButtonPos.y = iDlgHeight - iButtonHeight -
                    VDUTOPIXELS( lDlgBaseUnits, DU_DIST_TO_DLG_EDGE ) -
                    2 * GetSystemMetrics( SM_CYDLGFRAME ) -
                    GetSystemMetrics( SM_CYCAPTION );

    /* The x-position of the first button is the width of the dialog/2
     * minus the width of the button group/2.
     * First we loop through the buttons to get the total width (excluding
     * white space on end) of the button group.
     */
    ptButtonPos.x = 0;
    INT iButtonGrpWidth = 0, ipbIndex = 0;
    for ( ; _appbDisplay[ipbIndex] != NULL ; ipbIndex++ )
    {
        INT iWidth, iHeight;
        _appbDisplay[ipbIndex]->QuerySize( &iWidth, &iHeight );
        iButtonGrpWidth += iWidth;
    }
    ipbIndex--;      // Adjust for number of buttons

    iButtonGrpWidth += (ipbIndex-1) * HDUTOPIXELS( lDlgBaseUnits, DU_DIST_BETWEEN_BUTTONS );

    ptButtonPos.x = iDlgWidth/2 - iButtonGrpWidth/2;

    /* Loop through each button and place it where it is supposed to go
     */
    for ( ipbIndex = 0 ; _appbDisplay[ipbIndex] != NULL  ; ipbIndex++ )
    {
        INT iWidth, iHeight;

        _appbDisplay[ipbIndex]->SetPos( ptButtonPos );

        _appbDisplay[ipbIndex]->QuerySize( &iWidth, &iHeight );
        ptButtonPos.x += iWidth + HDUTOPIXELS( lDlgBaseUnits, DU_DIST_BETWEEN_BUTTONS );
    }
}


/*******************************************************************

    NAME:       MSGPOPUP_DIALOG::QueryButton

    SYNOPSIS:   Given an MP_*, this function returns a pointer to the
                corresponding button

    ENTRY:      Windows pusbutton identifier (MP_xxx)

    RETURNS:    Pointer to pushbutton object

    NOTES:
        In the debug version, QueryButton Asserts out if you pass
        it an unkown button (usMsgPopupButton cannot be a mask, must
        be a single button).  In the retail version, it returns NULL.

    HISTORY:
        Johnl   14-Feb-1991     Created

********************************************************************/

PUSH_BUTTON * MSGPOPUP_DIALOG::QueryButton( UINT usMsgPopupButton )
{
    switch (usMsgPopupButton)
    {
    case MP_OK:
        return &_pbOK;

    case MP_YES:
        return &_pbYes;

    case MP_NO:
        return &_pbNo;

    case MP_CANCEL:
        return &_pbCancel;

    default:
        DBGEOL("BLT: Unknown button passed to MsgPopup");
        ASSERT(FALSE);
        return NULL;
    }
}


/**********************************************************************

   NAME:        MSGPOPUP_DIALOG::QueryIcon

   SYNOPSIS:    Converts a MsgPopup severity level
                into an equivalent MessageBox icon flag.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Johnl       14-Feb-1991 Created
        beng        30-Sep-1991 Changed return type

**********************************************************************/

const TCHAR * MSGPOPUP_DIALOG::QueryIcon( MSG_SEVERITY msgsev )
{
    switch ( msgsev )
    {
    case MPSEV_ERROR:
        return IDI_HAND;

    case MPSEV_WARNING:
        return IDI_EXCLAMATION;

    case MPSEV_INFO:
        return IDI_ASTERISK;

    case MPSEV_QUESTION:
        return IDI_QUESTION;

    default:
        DBGEOL("BLT: Unknown severity (icon) passed to MsgPopup");
        ASSERT(FALSE);
        return 0;
    }
}


/* The following typedef is the format of the Message/Help number
 * associtation table.
 */
extern "C"
{
    typedef struct
    {
//        MSGID msgid;
//        UINT usHC;
        WORD msgid;
        WORD usHC;

    } MSGHCPAIR, * LPMSGHCTABLE;
}


/*******************************************************************

    NAME:       Msg2HC

    SYNOPSIS:   Attempts to lookup the help context associated with msgid
                from the resource file.

    ENTRY:      msgid - Message we want to find the help context for
                pusHC - Pointer that will receive the associated help context

    EXIT:       Returns TRUE if the help context was successfuly found
                A return of FALSE means the resource could not be found
                or the resource could not be loaded.

    NOTES:
        This is a static, private member function.

        This function attempts to load the custom resource from the
        resource file.  The resource file needs to have the form
        of:

            IDHC_MSG_TO_HELP RCDATA
            BEGIN
                 ERROR_NOT_ENOUGH_MEMORY, HC_NOT_ENOUGH_MEMORY
                 ERROR_ACCESS_DENIED,     HC_ACCESS_DENIED
                 0, 0        // Must be terminated with a pair of zeros
            END

        Note that BLT seeks the custom resource from whichever module
        contains the string.

    HISTORY:
        Johnl       7-Feb-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        29-Mar-1992 Loads resource by numeric ID
        beng        03-Aug-1992 Seeks resource in same hmod as string

********************************************************************/

BOOL MSGPOPUP_DIALOG::Msg2HC( MSGID msgid, ULONG * pulHC )
{
    /* Get help from message to help context resource table
     */
    HMODULE hmod = BLT::CalcHmodString(msgid);

    HRSRC hMsgToHCTable = ::FindResource( hmod,
                                          MAKEINTRESOURCE(IDHC_MSG_TO_HELP),
                                          RT_RCDATA );
    if ( hMsgToHCTable == NULL )
        return FALSE;

    HGLOBAL hMemMsgToHCTable = ::LoadResource( hmod, hMsgToHCTable );
    if ( hMemMsgToHCTable == NULL )
        return FALSE;

    LPMSGHCTABLE lpMsgToHCTable =
        (LPMSGHCTABLE) ::LockResource( hMemMsgToHCTable );
    if ( lpMsgToHCTable == NULL )
    {
#if !defined(WIN32)
        ::FreeResource( hMemMsgToHCTable );
#endif
        return FALSE;
    }

    /* Search for the message number in the table.  We have to do a linear
     * search since we can't assume ordering.
     */
    BOOL fRet = FALSE;          // Assume we will fail
    for ( INT i = 0 ; lpMsgToHCTable[i].usHC != 0 ; i++ )
    {
        if ( (MSGID)lpMsgToHCTable[i].msgid == msgid )
        {
            *pulHC = (ULONG) (lpMsgToHCTable[i].usHC);
            fRet = TRUE;
            break;
        }
    }

#if !defined(WIN32)
    ::UnlockResource( hMemMsgToHCTable );
    ::FreeResource( hMemMsgToHCTable );
#endif

    return fRet;
}


/*******************************************************************

    NAME:       DisplayGenericError

    SYNOPSIS:   Displays a generic error.

    ENTRY:      wnd                     - The "owning" window.

                idMessage               - String ID of the message.
                                          Probably contains insert params.

                errAPI                  - An APIERR.  There should be an
                                          error message in the string table
                                          with this number.  If this value
                                          is > MAX_NERR, we don't even try
                                          to display it.

                pszObject1              - An object for insert params.

                pszObject2              - Another object for insert params.

                msgsev                  - A MsgPopup severity value
                                          (one of the MPSEV_* values).

    NOTES:      The insert parameters are as follows:

                    %1  = pszObject1
                    %2  = pszObject2
                    %3  = errAPI (in decimal)
                    %4  = errAPI (an informative textual description)

                If either (or both) objects are not specified, then the
                remaining parameter numbers are shifted down.  For example,
                if neither object1 nor object2 are specified (passed as
                NULL), then the insert parameters become:

                    %1  = errAPI (in decimal)
                    %2  = errAPI (an informative textual description)

    HISTORY:
        ChuckC      11-Sep-1991 Stole from USER tool.
        beng        04-Oct-1991 Win32 conversion
        Yi-HsinS    06-Dec-1991 Don't print error number if errAPI
                                falls outside the NERR range
        Yi-HsinS    21-Jan-1992 Takes MSG_SEVERITY
        beng        05-Mar-1992 Use new string formatting available
        beng        17-Jun-1992 Look in system for error message text
        beng        05-Aug-1992 Use NLS_STR::LoadSystem
        KeithMo     21-Aug-1992 Added second object, change object
                                handling a bit.

********************************************************************/
DLL_BASED
UINT DisplayGenericError( const OWNINGWND & wnd,
                          MSGID             idMessage,
                          APIERR            errAPI,
                          const TCHAR     * pszObject1,
                          const TCHAR     * pszObject2,
                          MSG_SEVERITY      msgsev )
{
    const TCHAR * pszEmpty = SZ("");

    ALIAS_STR nlsObject1( pszEmpty );
    ALIAS_STR nlsObject2( pszEmpty );
    DEC_STR nlsErrorCode( errAPI, 4 );        // error code given
    NLS_STR nlsEmpty;                         // empty string

    ASSERT(!!nlsEmpty);      // necessary to handle boundary cases
    ASSERT(!!nlsObject1);    // shouldn't fail. really.
    ASSERT(!!nlsObject2);    //

    // Get text describing the error.

    RESOURCE_STR nlsErrorString( errAPI );    // error string
#if defined(WIN32)
    if (!nlsErrorString)
    {
        // If couldn't find it in app resources, check system

        nlsErrorString.LoadSystem(errAPI);
    }
#endif

    if( errAPI > MAX_NERR )
    {
        DBGEOL("Warning - displaying non-error val " << errAPI);
    }

    if( pszObject1 != NULL )
        nlsObject1 = pszObject1;

    if( pszObject2 != NULL )
        nlsObject2 = pszObject2;

    /*
     * Create the insert strings table
     */
    NLS_STR  * apnlsParamStrings[5];
    NLS_STR ** ppnls = apnlsParamStrings;

    if( pszObject1 != NULL )
        *ppnls++ = &nlsObject1;         // apnlsParamStrings[0]

    if( pszObject2 != NULL )
        *ppnls++ = &nlsObject2;         // apnlsParamStrings[1]

    *ppnls++ = &nlsErrorCode;           // apnlsParamStrings[2]
    *ppnls++ = !nlsErrorString          // apnlsParamStrings[3]
                   ? &nlsEmpty
                   : &nlsErrorString;
    *ppnls   = NULL;                    // apnlsParamStrings[4]

    /*
     * pop it up.
     */
    return ( MsgPopup(wnd.QueryHwnd(), idMessage, msgsev, (ULONG)HC_NO_HELP,
                      MP_OK, apnlsParamStrings) );
}


DLL_BASED
UINT DisplayGenericError( const OWNINGWND & wnd,
                          MSGID             idMessage,
                          APIERR            errAPI,
                          const TCHAR     * pszObjectName,
                          MSG_SEVERITY      msgsev )
{
    return ::DisplayGenericError( wnd,
                                  idMessage,
                                  errAPI,
                                  pszObjectName,
                                  (const TCHAR *)NULL,
                                  msgsev );
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: Takes message # and severity, uses OK button, help context
              taken from message number
    ENTRY:

    EXIT:

    NOTES:
        This form will look for the text in the system as well.

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev )
{
    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, MP_OK, MP_UNKNOWN, TRUE );
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: Takes message #, severity, button set and the default button.
              Help context taken from table in resource file.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT nButtons, UINT nDefButton )
{
    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, nButtons, nDefButton );
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: This variety allows either one or two insert strings (which will
              cover 95% of the cases) in addition to specifying the set
              of buttons, the severity and the default buttons.

    ENTRY:

    EXIT:

    NOTES:    If pchString2 is NULL, then we ignore it.

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        21-Nov-1991 Remove STR_OWNERALLOC
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT          nButtons,
              const TCHAR * psz,
              UINT          nDefButton )
{
    if (psz == NULL)
        return MsgPopup(wnd, msgid, msgsev, nButtons, nDefButton);

    const ALIAS_STR nls(psz);
    const NLS_STR * apnls[2];
    apnls[0] = &nls;
    apnls[1] = NULL;

    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, HC_DEFAULT_HELP, nButtons,
                 apnls, nDefButton);
    return popup.Show();
}


DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT          nButtons,
              const TCHAR * pszOne,
              const TCHAR * pszTwo,
              UINT          nDefButton )
{
    if (pszTwo == NULL && pszOne != NULL)
        return MsgPopup(wnd, msgid, msgsev, nButtons, pszOne, nDefButton);
    if (pszOne == NULL)
        return MsgPopup(wnd, msgid, msgsev, nButtons, nDefButton);

    const ALIAS_STR nls1(pszOne);
    const ALIAS_STR nls2(pszTwo);
    const NLS_STR * apnls[3];
    apnls[0] = &nls1;
    apnls[1] = &nls2;
    apnls[2] = NULL;

    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, HC_DEFAULT_HELP, nButtons,
                 apnls, nDefButton);
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: This one allows multiple insert strings stuffed into an apnls
              (Generally preferable to next version which uses the STR_LIST)

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG     ulHelpTopic,
              UINT      nButtons,
              NLS_STR * apnlsParams[],
              UINT      nDefButton )
{
    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, ulHelpTopic, nButtons,
                 (const NLS_STR * * const) apnlsParams, nDefButton );
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: One further refinement:  This form allows the user to
              specify both a MSGID and an APIERR.  The string for this
              APIERR will be inserted into the MSGID string as %1,
              while the apnlsInserted strings will be shifted to %2
              and higher.  If the APIERR string cannot be found,
              a string containing the error number and class will be
              inserted instead.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        JonN        25-Aug-1992 Merged in PERFORMER::DisplayError()
        JonN        01-Feb-1993 Map ERROR_MR_MID_NOT_FOUND to
                                IDS_BLT_UNKNOWN_ERROR.

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd,
              MSGID msgid,
              APIERR       errAPI,
              MSG_SEVERITY msgsev,
              ULONG     ulHelpTopic,
              UINT      nButtons,
              NLS_STR * apnlsParams[],
              UINT      nDefButton )
{
    APIERR err = NERR_Success;

    if( errAPI == ERROR_MR_MID_NOT_FOUND )
    {
        //
        //  ERROR_MR_MID_NOT_FOUND is returned by RtlNtStatusToDosError
        //  if there was no ERROR_* code corresponding to a particular
        //  STATUS_* code.  We'll map this to IDS_BLT_UNKNOWN_ERROR,
        //  which is slightly less cryptic than the text associated
        //  with ERROR_MR_MID_NOT_FOUND.
        //

        errAPI = IDS_BLT_UNKNOWN_ERROR;
    }

    NLS_STR nlsErrorString;
    if (   (err = nlsErrorString.QueryError()) != NERR_Success
        || (err = nlsErrorString.Load(errAPI)) != NERR_Success
       )
    {
        DBGEOL(   SZ("NETUI: MsgPopup(): Could not load error ")
               << errAPI
               << SZ(", failure code ")
               << err );

        DEC_STR nlsErrorCodeDec( errAPI, 4 );
        HEX_STR nlsErrorCodeHex( errAPI, 8 );

        // workaround for NLS_STR *apnlsParamStrings[2]
        // CODEWORK what is the correct syntax?
        PVOID apvoid[2];
        NLS_STR **apnlsParamStrings = (NLS_STR **)apvoid;

        MSGID msgFormat;

        if ( ((ULONG)errAPI) < ((ULONG)NERR_BASE) )
        {
            msgFormat = IDS_BLT_FMT_SYS_error;
            apnlsParamStrings[0] = &nlsErrorCodeDec;
        }
        else if ( ((ULONG)errAPI) <= ((ULONG)MAX_NERR) )
        {
            msgFormat = IDS_BLT_FMT_NET_error;
            apnlsParamStrings[0] = &nlsErrorCodeDec;
        }
        else
        {
            /* We display probable NTSTATUS error codes in hex */
            msgFormat = IDS_BLT_FMT_other_error;
            apnlsParamStrings[0] = &nlsErrorCodeHex;
        }

        apnlsParamStrings[1] = NULL;

        // We ignore error returns, just skip displaying string
        // CODEWORK - should resource_str take params in ctor?
        err = nlsErrorString.Load(msgFormat);
        if (err != NERR_Success)
        {
            DBGEOL(   SZ("NETUI: MsgPopup(): Could not load message ")
                   << msgFormat
                   << SZ(", failure code ")
                   << err );
            MsgPopup( wnd, err );
        }
        else
        {
            nlsErrorString.InsertParams( (const NLS_STR * * const) apnlsParamStrings );
            if ( !nlsErrorString )
            {
                DBGEOL( SZ("NETUI: MsgPopup(): first param insertion failed") );
            }
        }
    }

    if ( !nlsErrorString )
    {
        DBGEOL( SZ("NETUI: MspPopup(): Load of errAPI " << errAPI << " failed.") );
        nlsErrorString.Reset();
        ASSERT( nlsErrorString.QueryError() == NERR_Success );
    }

    INT cParams = 0;
    if (apnlsParams != NULL)
    {
        for (cParams = 0; apnlsParams[cParams] != NULL; cParams++) {};
    }

    NLS_STR ** apnlsNewParams = (NLS_STR **) new PVOID[cParams+2];
    if (apnlsNewParams == NULL)
    {
        return MsgPopup( wnd, ERROR_NOT_ENOUGH_MEMORY );
    }

    // do not return until apnlsNewParams freed

    apnlsNewParams[0] = &nlsErrorString;
    for (INT i = 1; i <= cParams; i++)
    {
        apnlsNewParams[i] = apnlsParams[i-1];
    }

    apnlsNewParams[cParams+1] = NULL;

    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, ulHelpTopic, nButtons,
                 (const NLS_STR * * const) apnlsNewParams, nDefButton );

	// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast:  need to call delete [].
	// Allocated with new []; not calling delete [] is a memory leak.
    delete apnlsNewParams;

    return popup.Show();
}


#if 0 // strlist forms never used
/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: The >2 insert string MsgPopup function, just like the 1 & 2
              MsgPopup, only it stores the insert strings in a strlst

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT nButtons,
              STRLIST & strlst, UINT nDefButton )
{
    POPUP popup(wnd.QueryHwnd(), msgid, msgsev,
                HC_DEFAULT_HELP, nButtons, strlst, nDefButton);
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: The "Works" MsgPopup, 1/2 lb. patty with everything

    ENTRY:

    EXIT:

    NOTES:    Takes insert strings in a STRLIST (which may be empty).

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG     ulHelpContext,
              UINT      nButtons,
              STRLIST & strlst,
              UINT      nDefButton )
{
    POPUP popup(wnd.QueryHwnd(), msgid, msgsev,
                ulHelpContext, nButtons, strlst, nDefButton);
    return popup.Show();
}
#endif // never used
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltorder.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltorder.cxx
        Use the up and down button to move the listbox's items up and down

    FILE HISTORY:
        terryk  28-Jan-1992     Created
*/
#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       ORDER_GROUP::ORDER_GROUP

    SYNOPSIS:   constructor - associate all the controls to this group

    ENTRY:      STRING_LISTBOX *plcList - listbox control
                BUTTON_CONTROL *pbcUp - Up button
                BUTTON_CONTROL *pbcDown - down button
                CONTROL_GROUP *pgroupOwner - owner group

    HISTORY:
                terryk  29-Mar-1992     Created

********************************************************************/

ORDER_GROUP::ORDER_GROUP(
        STRING_LISTBOX * plcList,
        BUTTON_CONTROL * pbcUp,
        BUTTON_CONTROL * pbcDown,
        CONTROL_GROUP *pgroupOwner )
    : CONTROL_GROUP( pgroupOwner ),
    _plcList( plcList ),
    _pbcUp( pbcUp ),
    _pbcDown( pbcDown )
{
    _plcList->SetGroup( this );
    _pbcUp->SetGroup( this );
    _pbcDown->SetGroup( this );
}

/*******************************************************************

    NAME:       ORDER_GROUP::OnUserAction

    SYNOPSIS:   move the listbox item up and down

    ENTRY:      CONTROL_WINDOW * pcw - control window which received the action
                const CONTROL_EVENT & e - action

    RETURNS:    APIERR - NERR_Success if okay

    HISTORY:
                terryk  29-Mar-1992     Created

********************************************************************/

APIERR ORDER_GROUP::OnUserAction( CONTROL_WINDOW * pcw, const CONTROL_EVENT & e )
{
    INT nCurrentSel;
    NLS_STR nlsSelect;

    CID cid = pcw->QueryCid();

    if ( cid == _pbcUp->QueryCid() )
    {
        if (( e.QueryCode() == BN_CLICKED ) ||
            ( e.QueryCode() == BN_DOUBLECLICKED ))
        {
            // Move an item up

            UIASSERT( _plcList->QuerySelCount() == 1 );

            nCurrentSel = _plcList->QueryCurrentItem();
            _plcList->QueryItemText( &nlsSelect, nCurrentSel );
            _plcList->DeleteItem( nCurrentSel );
            _plcList->InsertItem( nCurrentSel - 1, nlsSelect );
            _plcList->SelectItem( nCurrentSel - 1 );
            SetButton();
        }
    }
    else if ( cid == _pbcDown->QueryCid() )
    {
        if (( e.QueryCode() == BN_CLICKED ) ||
            ( e.QueryCode() == BN_DOUBLECLICKED ))
        {
            // move an item down

            UIASSERT( _plcList->QuerySelCount() == 1 );

            nCurrentSel = _plcList->QueryCurrentItem();
            _plcList->QueryItemText( &nlsSelect, nCurrentSel );
            _plcList->DeleteItem( nCurrentSel );
            _plcList->InsertItem( nCurrentSel + 1, nlsSelect );
            _plcList->SelectItem( nCurrentSel + 1 );
            SetButton();
        }
    }
    else if ( cid == _plcList->QueryCid() )
    {
        // reset button status
        if ( e.QueryCode() == LBN_SELCHANGE )
            SetButton();
    }
    return NERR_Success;
}


/*******************************************************************

    NAME:       ORDER_GROUP::SetButton

    SYNOPSIS:   Reset the button status

    HISTORY:
                terryk  29-Mar-1992     Created

********************************************************************/

VOID ORDER_GROUP::SetButton()
{
    BOOL fpbcUpHasFocus   = _pbcUp->HasFocus();
    BOOL fpbcDownHasFocus = _pbcDown->HasFocus();
    if ( _plcList->QuerySelCount() != 1 )
    {
        _pbcUp->Enable( FALSE );
        _pbcDown->Enable( FALSE );
    }
    else
    {
        _pbcUp->Enable( _plcList->QueryCurrentItem() != 0 );
        _pbcDown->Enable( _plcList->QueryCurrentItem() < ( _plcList->QueryCount() - 1 ));
    }

    // set the focus to the buttons or the listbox.

    BOOL fpbcUpEnabled = _pbcUp->IsEnabled();
    BOOL fpbcDownEnabled = _pbcDown->IsEnabled();

    if ( fpbcUpHasFocus && !fpbcUpEnabled)
    {
        if ( fpbcDownEnabled )
        {
            _pbcDown->ClaimFocus();
        }
        else
        {
            _plcList->ClaimFocus();
        }
    } else if ( fpbcDownHasFocus && !fpbcDownEnabled )
    {
        if ( fpbcUpEnabled )
        {
            _pbcUp->ClaimFocus();
        }
        else
        {
            _plcList->ClaimFocus();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltnslt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltnslt.cxx
    This file contains the class definition for the DEC_SLT class.

    The DEC_SLT class is a display object derived from the SLT class.
    DEC_SLT adds a new method SetValue() for setting a numerical value
    into the SLT.


    FILE HISTORY:
        KeithMo     28-Jul-1991 Created.
        KeithMo     26-Aug-1991 Changes from code review attended by
                                RustanL and EricCh.
        KeithMo     23-Mar-1992 Changed formatting from ultoa to DEC_STR.

*/
#include "pchblt.hxx"  // Precompiled header

//
//  DEC_SLT methods.
//

/*******************************************************************

    NAME:       DEC_SLT :: DEC_SLT

    SYNOPSIS:   DEC_SLT class constructor.

    ENTRY:      powner                  - Owning window.

                cid                     - Cid for this control

                cchDigitPad             - Number of pad digits to display.

    HISTORY:
        KeithMo     28-Jul-1991 Created.

********************************************************************/
DEC_SLT :: DEC_SLT( OWNER_WINDOW * powner,
                    CID            cid,
                    UINT           cchDigitPad )
  : SLT( powner, cid ),
    _cchDigitPad( cchDigitPad )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // DEC_SLT :: DEC_SLT


/*******************************************************************

    NAME:       DEC_SLT :: DEC_SLT

    SYNOPSIS:   DEC_SLT class constructor.

    ENTRY:      powner                  - Owning window.

                cid                     - Cid for this control

                xy                      - This control's position.

                dxy                     - This control's size.

                flStyle                 - Window style bits.

                pszClassName            - This control's window class
                                          name.

                cchDigitPad             - Number of pad digits to display.

    HISTORY:
        KeithMo     26-Aug-1991 Created.

********************************************************************/
DEC_SLT :: DEC_SLT( OWNER_WINDOW * powner,
                    CID            cid,
                    XYPOINT        xy,
                    XYDIMENSION    dxy,
                    ULONG          flStyle,
                    const TCHAR  * pszClassName,
                    UINT           cchDigitPad )
  : SLT( powner, cid, xy, dxy, flStyle, pszClassName ),
    _cchDigitPad( cchDigitPad )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // DEC_SLT :: DEC_SLT


/*******************************************************************

    NAME:       DEC_SLT :: ~DEC_SLT

    SYNOPSIS:   DEC_SLT class destructor.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
DEC_SLT :: ~DEC_SLT()
{
    //
    //  This space intentionally left blank.
    //

}   // DEC_SLT :: ~DEC_SLT


/*******************************************************************

    NAME:       DEC_SLT :: SetValue

    SYNOPSIS:   Sets the displayed value (unsigned version).

    ENTRY:      ulValue                 - The value to display.

    EXIT:       The value is displayed.

    HISTORY:
        KeithMo     28-Jul-1991 Created.
        KeithMo     23-Mar-1992 Now uses DEC_STR instead of ultoa().

********************************************************************/
VOID DEC_SLT :: SetValue( ULONG ulValue )
{
    DEC_STR nls( ulValue, _cchDigitPad );

    if( nls.QueryError() == NERR_Success )
    {
        SetText( nls.QueryPch() );
    }
    else
    {
        SetText( SZ("") );
    }

}   // DEC_SLT :: SetValue


/*******************************************************************

    NAME:       DEC_SLT :: SetValue

    SYNOPSIS:   Sets the displayed value (signed version).

    ENTRY:      lValue                  - The value to display.

    EXIT:       The value is displayed.

    HISTORY:
        KeithMo     28-Jul-1991 Created.

********************************************************************/
VOID DEC_SLT :: SetValue( LONG lValue )
{
    SetValue( (ULONG)lValue );          // signed values NYI

}   // DEC_SLT :: SetValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltowin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltowin.cxx
    BLT owner window class definitions

    FILE HISTORY:
        rustanl     27-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        beng        14-May-1991 Exploded blt.hxx into components
        beng        26-Sep-1991 C7 delta
        terryk      27-Nov-1991 Bump the control pair number from 40 to 60
        KeithMo     07-Aug-1992 STRICTified.
        Yi-HsinS    10-Dec-1992 Use WINDOW::CalcFixedHeight
*/

#include "pchblt.hxx"   // Precompiled header

class CONTROL_TABLE;    // fwd refs for local classes
class CONTROL_ENTRY;

/**********************************************************************

    NAME:       CONTROL_TABLE (ctrltable)

    SYNOPSIS:   The CONTROL_TABLE class is used with the OWNER_WINDOW to
                keep track of the controls in the owner window.

    INTERFACE:  CONTROL_TABLE()     - ctor.  No args.
                ~CONTROL_TABLE()    - dtor.
                AddControl()        - Adds a control to the table.
                RemoveControl()     - Locates and removes a control.
                CidToCtrlPtr()      -
                QueryCount()        -
                QueryItem()         -

    PARENT:     BASE

    USES:       CONTROL_ENTRY

    CAVEATS:
        Table has a fixed size.

    NOTES:
        The table is considered to be in an error state if any
        addition to it failed.  This is so that OWNER_WINDOW can
        easily verify that all of the table's contents are accurate.

        CODEWORK:  This class should use an SLIST or DICT or some other
        storage class.  For now, a simple fixed size array is used.

    HISTORY:
        rustanl     27-Nov-1990 Created
        keithmo     24-Apr-1991 Bumped MAX_CONTROL_TABLE_SIZE from 20 to 40
        beng        25-Apr-1991 Added const methods, BASE; changed
                                short QuerySize to INT QueryCount
        beng        30-Oct-1991 Added QueryItem member (for ITER_CTRL);
                                inlined Queries; unsigned integer counts
        terryk      27-Nov-1991 Bumped MAX_CONTROL_TABLE_SIZE from 40 to 60

**********************************************************************/

// CODEWORK - we should used slist instead of array

#define MAX_CONTROL_TABLE_SIZE (60)

class CONTROL_TABLE: public BASE
{
private:
    UINT _cce; // count of entries

    // CODEWORK.  Wasteful storage mechanism - this implementation should
    // probably change later.
    //
    CONTROL_ENTRY * _apce[ MAX_CONTROL_TABLE_SIZE ];

protected:
    // Simple, true-or-false error state
    //
    VOID ReportError()
        { BASE::ReportError(1); }

public:
    CONTROL_TABLE();
    ~CONTROL_TABLE();

    // AddControl adds a control to the table.  Returns TRUE on
    // success, and FALSE otherwise.
    //
    BOOL AddControl( CONTROL_WINDOW * pwinctrl );

    // RemoveControl removes a control from the table.  Returns
    // TRUE if control was found and successfully removed, and
    // FALSE otherwise.
    //
    BOOL RemoveControl( CONTROL_WINDOW * pwinctrl );

    // CidToCtrlPtr return the CONTROL_WINDOW pointer corresponding
    // to the given CID, or NULL on failure.
    //
    CONTROL_WINDOW * CidToCtrlPtr( CID cid ) const;

    // QueryCount returns the number of elements in the CONTROL_TABLE;
    // QueryItem returns one entry.  These export the table for ITER_CTRL.
    //
    UINT QueryCount() const
        { return _cce; }
    CONTROL_ENTRY * QueryItem( UINT i ) const
        { return _apce[i]; }
};


/**********************************************************************

    NAME:       CONTROL_ENTRY (ce)

    SYNOPSIS:   Pair ( pctrlwin, cid ) used in the CONTROL_TABLE.

    INTERFACE:  CONTROL_ENTRY() - constructor
                QueryCid()      - return the cid of the control entry
                QueryCtrlPtr()  - return pointer to control-window

    USES:       CONTROL_WINDOW, CID

    NOTES:
        This class is private to the OWNER_WINDOW and
        to CONTROL_TABLE.

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Private constructor, friends;
                                    made Queries inline and const

**********************************************************************/

class CONTROL_ENTRY // ce
{
friend BOOL CONTROL_TABLE::AddControl(CONTROL_WINDOW *);

private:
    CONTROL_WINDOW * _pctrlwin;
    CID              _cid;

    // Constructor is private, so that only named friends of the class
    // can create instances.
    //
    CONTROL_ENTRY( CONTROL_WINDOW * pctrlwin );

public:
    CID QueryCid() const
        { return _cid; }
    CONTROL_WINDOW * QueryCtrlPtr() const
        { return _pctrlwin; }
};


/**********************************************************************

    NAME:       CONTROL_ENTRY::CONTROL_ENTRY

    SYNOPSIS:   Construct a new entry in a CONTROL_TABLE

    ENTRY:      pctrlwin - pointer to control to include

    NOTES:
        Only CONTROL_TABLE::AddControl may call
        this function - it contains all error checking.

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Folded error checking into called

**********************************************************************/

CONTROL_ENTRY::CONTROL_ENTRY( CONTROL_WINDOW * pctrlwin )
    : _pctrlwin(pctrlwin),
      _cid(pctrlwin->QueryCid())
{
    // No error checking, since only AddControl can create
    // an instance, and it validates pctrlwin before creation.
}


/**********************************************************************

    NAME:       CONTROL_TABLE::CONTROL_TABLE

    SYNOPSIS:   Create a new, empty control table

    NOTES:
        The new control table contains no controls.

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

CONTROL_TABLE::CONTROL_TABLE() :
    _cce(0)
{
    for ( INT i = 0; i < MAX_CONTROL_TABLE_SIZE; i++ )
        _apce[ i ] = NULL;
}


/**********************************************************************

    NAME:       CONTROL_TABLE::~CONTROL_TABLE

    SYNOPSIS:   Destroy a control table

    NOTES:
        Deletes every added entry

    HISTORY:
        rustanl     27-Nov-1990 Created
        beng        30-Oct-1991 Uses dynamic table size
                                instead of static maximum size

**********************************************************************/

CONTROL_TABLE::~CONTROL_TABLE()
{
    for ( UINT i = 0; i < _cce; i++ )
    {
        delete _apce[ i ];
    }
}


/**********************************************************************

    NAME:       CONTROL_TABLE::AddControl

    SYNOPSIS:   Add a record to the table

    ENTRY:

    EXIT:

    RETURNS:    TRUE if the control was successfully added, or
                FALSE if not.

    NOTES:

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Uses Query/ReportError

**********************************************************************/

BOOL CONTROL_TABLE::AddControl( CONTROL_WINDOW * pwinctrl )
{
    // Return a failure if the table is in an error state
    //
    if ( QueryError() )
        return FALSE;

    // Likewise on illegal input
    //
    if (pwinctrl == NULL)
    {
        DBGEOL(SZ("Tried to add a NULL control"));
        return FALSE;
    }

    // If the table is full, mark the table as being in an
    // error state, and return failure.
    //
    if ( _cce == MAX_CONTROL_TABLE_SIZE )
    {
        ReportError();
        return FALSE;
    }

    // Create a table entry for the new control.  If the allocation
    // fails, marks the table as being in an error state, and return
    // a failure.
    //
    CONTROL_ENTRY * pce = new CONTROL_ENTRY( pwinctrl );
    if ( pce == NULL )
    {
        ReportError();
        return FALSE;
    }

    // Add the new entry into the table
    //
    _apce[ _cce++ ] = pce;

    return TRUE;    // success
}


/**********************************************************************

    NAME:       CONTROL_TABLE::RemoveControl

    SYNOPSIS:   Locate and remove a record from the table

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

BOOL CONTROL_TABLE::RemoveControl( CONTROL_WINDOW * pwinctrl )
{
    // Return a failure if the table is in an error state.
    //
    if ( QueryError() )
        return FALSE;

    // Likewise on illegal input
    //
    if (pwinctrl == NULL)
    {
        DBGEOL(SZ("Tried to remove a NULL control"));
        return FALSE;
    }

    // Attempt to find the given control in the table
    //
    UINT i;
    for ( i = 0; i < _cce; i++ )
    {
        if ( _apce[ i ]->QueryCtrlPtr() == pwinctrl )
            break;
    }

    // Verify success of search
    //
    if ( i == _cce )
        return FALSE;

    // Remove the control from the table, and fill its spot
    // with the last entry, so that all current entries are
    // consecutive.
    //
    delete _apce[ i ];
    _apce[ i ] = _apce[ --_cce ];
    _apce[ _cce ] = NULL;

    return TRUE;    // success
}


/**********************************************************************

    NAME:       CONTROL_TABLE::CidToCtrlPtr

    SYNOPSIS:   Locate a record by its CID, and return appropriate window

    ENTRY:      cid - BLT control-id

    EXIT:

    RETURNS:    Pointer to appropriate CONTROL_WINDOW, or NULL
                if the CID couldn't be found

    NOTES:

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Uses Query/ReportError

**********************************************************************/

CONTROL_WINDOW * CONTROL_TABLE::CidToCtrlPtr( CID cid ) const
{
    // Return a failure if the table is in an error state.
    //
    if ( QueryError() )
        return NULL;

    // Attempt to find the given control in the table
    //
    UINT i;
    for ( i = 0; i < _cce; i++ )
    {
        if ( _apce[ i ]->QueryCid() == cid )
            break;
    }

    // Verify success of search
    //
    if ( i == _cce )
        return NULL;

    return _apce[ i ]->QueryCtrlPtr();
}


/**********************************************************************

    NAME:       OWNER_WINDOW::OWNER_WINDOW

    SYNOPSIS:   Constructor for owner window object

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Removed hwndOwner parm; fixed
                                    error reporting
        beng        08-May-1991     Relocated BASE to WINDOW ancestor

**********************************************************************/

OWNER_WINDOW::OWNER_WINDOW()
    : WINDOW(),
      _pctrltable( new CONTROL_TABLE() ),
      _dwAttributes( 0 )
{
    if ( !_pctrltable || !*_pctrltable )
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
}


OWNER_WINDOW::OWNER_WINDOW(
    const TCHAR *  pszClassName,
    ULONG         flStyle,
    const WINDOW *pwndOwner )
    : WINDOW(pszClassName, flStyle, pwndOwner),
      _pctrltable( new CONTROL_TABLE() )
{
    if ( !_pctrltable || !*_pctrltable )
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
}


/**********************************************************************

    NAME:       OWNER_WINDOW::~OWNER_WINDOW

    SYNOPSIS:   Destructor for OWNER_WINDOW

    ENTRY:

    EXIT:       control table is dust

    NOTES:

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

OWNER_WINDOW::~OWNER_WINDOW()
{
    delete _pctrltable;
    _pctrltable = NULL;
}


/**********************************************************************

    NAME:       OWNER_WINDOW::AddControl

    SYNOPSIS:   Adds a control to a window

    ENTRY:      pctrlwin - pointer to the CONTROL_WINDOW to add

    EXIT:       See CONTROL_TABLE::AddControl()

    NOTES:      This works by forwarding the call to the
                embedded CONTROL_TABLE object.

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

BOOL OWNER_WINDOW::AddControl( CONTROL_WINDOW * pctrlwin )
{
    return _pctrltable->AddControl( pctrlwin );
}


/**********************************************************************

    NAME:       OWNER_WINDOW::SetFocus

    SYNOPSIS:   Sets the focus to a control, ID'd by CID

    ENTRY:      cid - ID of control to receive focus

    EXIT:       That control has focus

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

VOID OWNER_WINDOW::SetFocus( CID cid )
{
    ::SetFocus(::GetDlgItem(QueryHwnd(), cid));
}


/**********************************************************************

    NAME:       OWNER_WINDOW::SetDialogFocus

    SYNOPSIS:   Sets the focus to a control in a dialog

    ENTRY:      ctrlwin - control to receive focus

    EXIT:       That control has focus

    HISTORY:
        jonn      21-May-1993

**********************************************************************/

VOID OWNER_WINDOW::SetDialogFocus( CONTROL_WINDOW & ctrlwin )
{
    Command( WM_NEXTDLGCTL,
             (WPARAM)(ctrlwin.QueryHwnd()),
             (LPARAM)TRUE );
}


/**********************************************************************

    NAME:       OWNER_WINDOW::CidToCtrlPtr

    SYNOPSIS:   Returns the control-window pointer corresponding
                to the named control

    ENTRY:      cid - Control ID (child-window-identifier)

    RETURNS:    A pointer to a control window, or NULL if not found.

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

CONTROL_WINDOW * OWNER_WINDOW::CidToCtrlPtr( CID cid ) const
{
    return _pctrltable->CidToCtrlPtr( cid );
}


/*******************************************************************

    NAME:       OWNER_WINDOW::OnCDMessages

    SYNOPSIS:   Responds to the messages handling custom-draw controls

    ENTRY:      usMsg, wParam, lParam - as per wndproc

    EXIT:

    RETURNS:

    NOTES:
        This *non-virtual* dispatch function is called by both
        dialog and client windows.

        Possible optimization: note that the offset of the CtlID field
        is the same for all of the [...]ITEMSTRUCTs below.

        GUILTT is the UI CT team's testing tool.  It uses a private
        message to extract information from owner-drawn listboxen.
        Talk to DavidBul, or else see the file
        \\testy\lm30ct\src\ui\guiltt\src\bltlist.cxx
        for annoying details.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        beng        27-Jun-1991 Corrected a GUILTT handling bug;
                                added some doc for GUILTT
        beng        15-Oct-1991 Win32 conversion
        beng        14-Feb-1992 Win32 enabling of GUILTT
        beng        30-Apr-1992 API changes
        beng        01-Jun-1992 GUILTT changes

********************************************************************/

INT OWNER_WINDOW::OnCDMessages( UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    switch (nMsg)
    {
    case WM_GUILTT:
        {
            CID cid = (CID)wParam;
            UINT ilb = (UINT)lParam;

            // Find the control

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if (pctrl == NULL)
                return ERROR_CONTROL_ID_NOT_FOUND;

            // Get the data from the control

            NLS_STR nlsData;
            APIERR err = pctrl->CD_Guiltt( ilb, &nlsData );
            if (err != NERR_Success)
                return err;

            // Get the data onto the clipboard
            //
            // This is a one-way trip; we alloc the mem, but never
            // free it, since it becomes the property of the clipboard.

            HANDLE h = ::GlobalAlloc(GMEM_MOVEABLE, nlsData.QueryTextSize());
            if (h == NULL)
                return BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY);

            {
                VOID * pvData = ::GlobalLock(h);
                ASSERT(pvData != NULL);
                ::memcpy(pvData, nlsData.QueryPch(), nlsData.QueryTextSize());
                ::GlobalUnlock(h);
            }

            if (   ! ::OpenClipboard(QueryHwnd())
                || ! ::EmptyClipboard()
#if defined(UNICODE)
                || ! ::SetClipboardData( CF_UNICODETEXT, h )
#else
                || ! ::SetClipboardData( CF_TEXT, h )
#endif
                || ! ::CloseClipboard())
            {
                return BLT::MapLastError(ERROR_BUSY);
            }

            // Over and out - return to GUILTT

            return 0;
        }

    case WM_DRAWITEM:
        {
            CID cid = ((DRAWITEMSTRUCT *)lParam)->CtlID;

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_Draw( (DRAWITEMSTRUCT *)lParam );
        }
        break;

    case WM_MEASUREITEM:
        {
            //  Note, this will only be done for variable-size items.
            //  Fixed size items are handled in WM_MEASUREITEM message
            //  above.

            CID cid = ((MEASUREITEMSTRUCT *)lParam)->CtlID;

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_Measure( (MEASUREITEMSTRUCT *)lParam );
        }
        break;

    case WM_CHARTOITEM:
        {
#if defined(WIN32)
            WCHAR wch = (WCHAR)LOWORD(wParam);
            CID cid = ::GetDlgCtrlID( (HWND)lParam );
            USHORT nCaretPos = HIWORD(wParam);
#else
            WCHAR wch = (WCHAR)wParam;
            CID cid = ::GetDlgCtrlID( LOWORD( lParam ) );
            USHORT nCaretPos = HIWORD(lParam);
#endif

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_Char( wch, nCaretPos );
        }
        break;

    case WM_VKEYTOITEM:
        {
#if defined(WIN32)
            USHORT nVKey = LOWORD(wParam);
            CID cid = ::GetDlgCtrlID( (HWND)lParam );
            USHORT nCaretPos = HIWORD(wParam);
#else
            USHORT nVKey = wParam;
            CID cid = ::GetDlgCtrlID( LOWORD( lParam ) );
            USHORT nCaretPos = HIWORD(lParam);
#endif

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_VKey( nVKey, nCaretPos );
        }
        break;

    default:
        break;
    }

    return 0;
}


/* Maximum height we expect bitmaps to be in the owner drawn list boxes
 */
const USHORT yMaxCDBitmap = 16;


/*******************************************************************

    NAME:       OWNER_WINDOW::CalcFixedCDMeasure

    SYNOPSIS:   Calculate size of fixed-size owner-draw object

    ENTRY:      hwnd   - handle to window owning the control
                pmis   - as passed by WM_MEASUREITEM in lParam

    EXIT:

    RETURNS:    FALSE if the calculation fails for some reason

    NOTES:
        This is a static member of the class.

        This WM_MEASUREITEM message is sent before the
        WM_INITDIALOG message (except for variable size owner-draw
        list controls).  Since the window properties are not yet set
        up, the owner dialog cannot be called.

        The chosen solution for list controls is to assume that every
        owner-draw control will always have the same height as the font
        of that list control.  This is a very reasonable guess for most
        owner-draw list controls.  Since owner-draw list controls with
        variable size items call the owner for every item, the window
        properties will have been properly initialized by that time.  Hence,
        a client may respond to these messages through OnOther.

        Currently, owner-draw buttons are not supported.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        beng        15-Oct-1991 Win32 conversion
        Yi-Hsin     10-Dec-1992 Call WINDOW?::CalcFixedHeight instead

********************************************************************/

BOOL OWNER_WINDOW::CalcFixedCDMeasure( HWND hwnd, MEASUREITEMSTRUCT * pmis )
{
    // Get the handle of the control
    //
    return ( WINDOW::CalcFixedHeight( ::GetDlgItem( hwnd, pmis->CtlID ),
                                      &( pmis->itemHeight ) ));

}


/*******************************************************************

    NAME:       OWNER_WINDOW::OnLBIMessages

    SYNOPSIS:   Handle LBI messages which need no pwnd

    ENTRY:

    EXIT:

    RETURNS:    Value for wndproc to return

    NOTES:
        This is a static member of the class.

    HISTORY:
        beng        21-May-1991 Created
        beng        15-Oct-1991 Win32 conversion

********************************************************************/

INT OWNER_WINDOW::OnLBIMessages(
    UINT   nMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (nMsg)
    {
    case WM_COMPAREITEM:
        return LBI::OnCompareItem(wParam, lParam);

    case WM_DELETEITEM:
        LBI::OnDeleteItem(wParam, lParam);
        return TRUE;

    default:
        break;
    }

    return 0;
}


/*******************************************************************

    NAME:       OWNER_WINDOW::OnUserMessage

    SYNOPSIS:   Handles all user-defined messages

    ENTRY:      event - an untyped EVENT

    RETURNS:    TRUE if event handled, FALSE otherwise

    NOTES:
        Clients handling user-defined messages should supply
        OnOther instead of redefining DispatchMessage.

    HISTORY:
        beng        14-May-1991     Created (in CLIENT_WINDOW).
        KeithMo     14-Oct-1992     Moved to OWNER_WINDOW.

********************************************************************/

BOOL OWNER_WINDOW::OnUserMessage( const EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       ITER_CTRL::ITER_CTRL

    SYNOPSIS:   Construct a control iterator

    ENTRY:      pwndOwning - owner-window owning controls

    EXIT:       Iterator constructed.  If the window is in some
                error state, the resulting enumeration will have
                length 0.

    HISTORY:
        beng        30-Oct-1991 Created

********************************************************************/

ITER_CTRL::ITER_CTRL( const OWNER_WINDOW * pwndOwning )
    : _pwndOwning(pwndOwning),
      _pctrltable(NULL),
      _ictrl(0),
      _cctrl(0)
{
    if (pwndOwning == NULL || !*pwndOwning)
    {
        // Yields a zero-length sequence.
        return;
    }

    // The iterator is a friend of owner window, and so has access
    // to this private member.
    //
    _pctrltable = pwndOwning->_pctrltable;
    _cctrl = _pctrltable->QueryCount();
}


/*******************************************************************

    NAME:       ITER_CTRL::Reset

    SYNOPSIS:   Resets the control iterator to its initial state

    EXIT:       Iterator is fresh and new

    NOTES:
        If the owner window acquires or loses any controls, this
        method will synchronize the iterator anew.

    HISTORY:
        beng        30-Oct-1991 Created

********************************************************************/

VOID ITER_CTRL::Reset()
{
    ASSERT(!!*_pwndOwning);

    _ictrl = 0;
    _cctrl = _pctrltable->QueryCount();
}


/*******************************************************************

    NAME:       ITER_CTRL::Next

    SYNOPSIS:   Fetch the next control in the sequence

    RETURNS:    A pointer to a control-window

    NOTES:
        The sequence is that in which the controls were constructed.

    HISTORY:
        beng        30-Oct-1991 Created

********************************************************************/

CONTROL_WINDOW * ITER_CTRL::Next()
{
    if (_ictrl >= _cctrl)
        return NULL;

    // I should just make this class
    // a friend of CONTROL_TABLE.  This is absurd, particularly
    // within a private class.

    return _pctrltable->QueryItem(_ictrl++)->QueryCtrlPtr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltpump.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltpump.cxx
    The BLT message pump

    FILE HISTORY:
	beng	    07-Oct-1991 Created

*/

#include "pchblt.hxx"   // Precompiled header


/*******************************************************************

    NAME:	HAS_MESSAGE_PUMP::RunMessagePump

    SYNOPSIS:	Run message loop.

	Acquires and dispatches messages until a WM_QUIT message
	is received, or else until some client-specified termination
	condition is satisfied.

    ENTRY:	New application.  App object has been "constructed"
		and app has been properly initialized.

    EXIT:	App has received WM_QUIT

    RETURNS:	Value from PostQuitMessage, or 0 if at client request.

    HISTORY:
	beng	    01-Apr-1991 Created (as APPSTART::MessageLoop)
	rustanl     17-Jun-1991 Copied from APPSTART::MessageLoop
				into APPLICATION::RunMessageLoop
	beng	    09-Jul-1991 Added new FilterMessage scheme
	beng	    07-Oct-1991 Incorporated into new HAS_MESSAGE_PUMP

********************************************************************/

WPARAM HAS_MESSAGE_PUMP::RunMessagePump()
{
    MSG msg;

    while ( ::GetMessage( &msg,     // message structure
			  NULL,     // handle of window receiving the message
			  0,	    // lowest message to examine
			  0 ) )     // highest message to examine
    {
	// Call the app's filter, giving it an opportunity to
	// translate menu accelerators, etc.  If the filter handles
	// the message, continue to the next message.
	//
	if (!FilterMessage( &msg ))
	{
	    ::TranslateMessage( &msg ); // Translates virtual key codes
	    ::DispatchMessage( &msg );	// Dispatches message to window
	}

	// Not all message loops run to app termination -
	// e.g., any dialog.  This predicate is supplied by the client.
	//
	if (IsPumpFinished())
	    return 0;
    }

    return msg.wParam;		    // Returns the value from PostQuitMessage
}


/*******************************************************************

    NAME:	HAS_MESSAGE_PUMP::FilterMessage

    SYNOPSIS:	Client-installable hook into the messageloop.

	This default implementation does nothing.

    ENTRY:	pmsg	- pointer to message fresh off the queue

    EXIT:	pmsg	- could possibly be changed

    RETURNS:
	FALSE to proceed with translating and dispatching
	the message.

	TRUE indicates that the message has already been
	handled by the filter.	In this case, the message
	loop will continue on to the next message in the
	queue.

    CAVEATS:
	When parsing the contents of *pmsg, clients should take care
	to retain portability between different Win environments.
	While "message" is usually safe, wParam and lParam may change.

    NOTES:
	This is a virtual member function.

	A client which needs menu-accelerator support should supply
	an implementation which calls TranslateAccelerator as appropriate.
	(See the ACCELTABLE class.)

    HISTORY:
	beng	    09-Jul-1991 Created (within APPLICATION)
	beng	    07-Oct-1991 Moved into HAS_MESSAGE_PUMP

********************************************************************/

BOOL HAS_MESSAGE_PUMP::FilterMessage( MSG* pmsg )
{
    UNREFERENCED(pmsg);

    return FALSE;
}


/*******************************************************************

    NAME:	HAS_MESSAGE_PUMP::IsPumpFinished

    SYNOPSIS:	Client-installable pump termination condition

	This default implementation does nothing but return "FALSE;"
	hence a client which does not replace this will run until
	the pump receives WM_QUIT.

    ENTRY:	Message pump has dispatched a message

    RETURNS:	TRUE to end the pump; FALSE to continue

    CAVEATS:
	A class derived from APPLICATION proably shouldn't replace
	this function.

    NOTES:
	This is a virtual member function.

    HISTORY:
	beng	    07-Oct-1991 Created

********************************************************************/

BOOL HAS_MESSAGE_PUMP::IsPumpFinished()
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\blttcurs.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltcurs.cxx
    Misc BLT cursor extensions

    FILE HISTORY:
        DavidHov    13-Mar-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        beng        05-Mar-1992     Removed load-by-name resource stuff
        KeithMo     07-Aug-1992     STRICTified.
*/

#include "pchblt.hxx"   // Precompiled header

/**********************************************************************

    NAME:       TIME_CURSOR::TIME_CURSOR

    SYNOPSIS:   Construct a timed cursor

    ENTRY:      cMsInterval - interval in milliseconds
                idResourceBase - ID of first cursor in sequence

    EXIT:       Cursors loaded; first cursor shown

    NOTES:

    HISTORY:
        DavidHov    13-Mar-1991 Created
        beng        05-Oct-1991 Win32 conversion
        beng        05-Mar-1992 Loads resources by number
        beng        03-Aug-1992 Dllization

**********************************************************************/

TIME_CURSOR::TIME_CURSOR( UINT cMsInterval, UINT idResourceBase )
    : _cMsInterval(cMsInterval),
      _fState(FALSE) // not on... yet
{
    HMODULE hmod = BLT::CalcHmodRsrc(idResourceBase);
    UINT ihCursors = 0;

    // From the base, load cursors sequentially until we find no more,
    // or else until we read end-of-range

    for (UINT idResourceLoad = idResourceBase;
         ihCursors < TIME_CURSOR_MAX-1 ;
         ihCursors++, idResourceLoad++ )
    {
        HCURSOR h = ::LoadCursor( hmod, MAKEINTRESOURCE(idResourceLoad) );
        if ( h == NULL )
            break;
        _ahCursors[ihCursors] = h;
    }

    // If no cursors were found, set the first entry in the table
    // to the standard wait cursor.

    if ( ihCursors == 0 )
    {
        _ahCursors[ihCursors++] = ::LoadCursor(NULL, IDC_WAIT);
    }

    // Delimit the table with NULL.

    _ahCursors[ ihCursors ] = NULL;

    // Show the first cursor. Don't use operator++, because we
    // must remember the user's current cursor.

    _ihCursor = 0;
    _hCursPrev = Set( _ahCursors[0] );
    _fState = TRUE;
    _cMsLast = ::GetCurrentTime();
}


/**********************************************************************

    NAME:       TIME_CURSOR::~TIME_CURSOR

    SYNOPSIS:   Dtor for timed cursor

    HISTORY:
        DavidHov    13-Mar-1991     Created

**********************************************************************/

TIME_CURSOR::~TIME_CURSOR()
{
    TurnOff();
    Show( TRUE );
}


/*******************************************************************

    NAME:       TIME_CURSOR::operator++

    SYNOPSIS:   Increments the cursor if define interval has elapsed.

    NOTES:      This operator allows the caller to increment the cursor
                as often (or as infrequently) as convenient, knowing
                that the cursor will only be changed according to the
                interval defined during construction; the default is
                every 2 seconds.

    HISTORY:
        davidhov     18-Mar-1991     created

********************************************************************/

INT TIME_CURSOR::operator++()
{
    DWORD cMsCurrent = ::GetCurrentTime();

    if ( cMsCurrent - _cMsLast > (DWORD)_cMsInterval )
    {
       _cMsLast = cMsCurrent;
       if ( _ahCursors[ ++_ihCursor ] == NULL )
         _ihCursor = 0;
       Set( _ahCursors[ _ihCursor ] );
    }
    return _ihCursor;
}


/*******************************************************************

    NAME:       TIME_CURSOR::TurnOn

    SYNOPSIS:   Sets the time cursor to its ON state; that is,
                is sets the cursor to the current cursor in the cycle.

    HISTORY:
        davidhov  18-Mar-1991     created

********************************************************************/

VOID TIME_CURSOR::TurnOn()
{
    if ( _fState )
    {
        //  Already turned on.  Do nothing.
    }
    else
    {
        Set( _ahCursors[ _ihCursor ] );
        Show( TRUE );

        _fState = TRUE;
    }
}


/*******************************************************************

    NAME:       TIME_CURSOR::TurnOff

    SYNOPSIS:   Sets the time cursor to its OFF state; that is, it
                restores the cursor to the state it was in when the
                TIME_CURSOR was constructed.

    HISTORY:
        davidhov   18-Mar-1991     created

********************************************************************/

VOID TIME_CURSOR::TurnOff()
{
    if ( ! _fState )
    {
        //  Already turned off.  Do nothing.
    }
    else
    {
        Show( FALSE );
        Set( _hCursPrev );

        _fState = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltrect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltrect.hxx
    Rectangle functions

    FILE HISTORY:
        terryk      29-Jul-1991 Created
        terryk      16-Aug-1991 Code review changed.
                                Attend: rustanl davidhov davidbul terryk
        beng        09-Oct-1991 Added XYPOINT members (once all inline)
*/

#include "pchblt.hxx"   // Precompiled header

/******************************************************************

    NAME:       XYRECT

    SYNOPSIS:   Constructor

    HISTORY:
        terryk      29-Jul-1991 Created
        beng        09-Oct-1991 Added window-rect calculation;
                                simplified
        beng        12-May-1992 Fixed bug in xy, dxy ctor
        beng        28-May-1992 Make pwnd arg const

*******************************************************************/

XYRECT::XYRECT()
{
    _rect.left = 0;
    _rect.top  = 0;
    _rect.right  = 0;
    _rect.bottom = 0;
}

XYRECT::XYRECT( XYPOINT xyUl, XYPOINT xyLr )
{
    _rect.left = xyUl.QueryX();
    _rect.top  = xyUl.QueryY();
    _rect.right  = xyLr.QueryX();
    _rect.bottom = xyLr.QueryY();
}

XYRECT::XYRECT( XYPOINT xy, XYDIMENSION dxy )
{
    _rect.left = xy.QueryX();
    _rect.top  = xy.QueryY();
    _rect.right  = dxy.QueryWidth() + xy.QueryX();
    _rect.bottom = dxy.QueryHeight() + xy.QueryY();
}

XYRECT::XYRECT( INT xUl, INT yUl, INT xLr, INT yLr )
{
    _rect.left = xUl;
    _rect.top  = yUl;
    _rect.right  = xLr;
    _rect.bottom = yLr;
}

XYRECT::XYRECT( const RECT & rect )
{
    _rect = rect;
}

XYRECT::XYRECT( HWND hwnd, BOOL fClientOnly )
{
    UIASSERT( hwnd != NULL );

    if (fClientOnly)
        ::GetClientRect( hwnd, &_rect );
    else
        ::GetWindowRect( hwnd, &_rect );
}

XYRECT::XYRECT( const WINDOW *pwnd, BOOL fClientOnly )
{
    UIASSERT( pwnd != NULL );

    if (fClientOnly)
        ::GetClientRect( pwnd->QueryHwnd(), &_rect );
    else
        ::GetWindowRect( pwnd->QueryHwnd(), &_rect );
}

XYRECT::XYRECT( const XYRECT & rect )
{
    _rect = rect._rect;
}


/*********************************************************************

    NAME:       XYRECT::operator=

    SYNOPSIS:   assign operation

    ENTRY:      XYRECT rect - the source xyrect

    RETURN:     XYRECT &rect - the result xyrect

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::operator=( const XYRECT & rect )
{
    _rect = rect._rect;
    return *this;
}


/*********************************************************************

    NAME:       XYREC::Offset

    SYNOPSIS:   Move the given rectangle by the specified offsets

    ENTRY:      INT x - x position
                INT y - y position
                OR
                XYDIMENSION xy - xy dimension which specify width and height

    RETURN:     XYRECT & - the resultant xyrect

    HISTORY:
                terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::Offset( INT dx, INT dy )
{
    ::OffsetRect( &_rect, dx, dy );
    return *this;
}

XYRECT& XYRECT::Offset( XYDIMENSION dxy )
{
    ::OffsetRect( &_rect, dxy.QueryWidth(), dxy.QueryHeight() );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::Inflate

    SYNOPSIS:   Increase ot decrease the width and height of the rectangle

    ENTRY:      INT x - x value
                INT y - y value
                OR
                XYDIMENSION dxy - the width and height

    RETURN:     XYRECT &rect - the resultant xyrect

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::Inflate( INT dx, INT dy )
{
    ::InflateRect( &_rect, dx, dy );
    return *this;
}

XYRECT& XYRECT::Inflate( XYDIMENSION dxy )
{
    ::InflateRect( &_rect, dxy.QueryWidth(), dxy.QueryHeight() );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::CalcIntersect

    SYNOPSIS:   Create the intersection of 2 existing rectangle

    ENTRY:      XYRECT xysrc1 - the first rectangle
                XYRECT xysrc2 - the second rectangle

    RETURN:     XYRECT & - the resultant rectangle - the intersection of
                    the two source rectangles

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::CalcIntersect( const XYRECT &xySrc1, const XYRECT & xySrc2 )
{
    ::IntersectRect( &_rect, (RECT *)&xySrc1._rect, (RECT *)&xySrc2._rect );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::CalcUnion

    SYNOPSIS:   Create the union of two rectangles

    ENTRY:      XYRECT xysrc1 - the first rectangle
                XYRECT xysrc2 - the second rectangle

    RETURN:     XYRECT & - the resultant rectangle - the union of the two

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::CalcUnion( const XYRECT &xySrc1, const XYRECT &xySrc2 )
{
    ::UnionRect( &_rect, (RECT *)&xySrc1._rect, (RECT *)&xySrc2._rect );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::operator+=

    SYNOPSIS:   adjust the current rectangle by adding the dimension of
                the passing parameter.

    ENTRY:      const XYRECT& xySrc - the dimension to be adjust

    RETURN:     the resultant rectangle

    HISTORY:
        terryk  16-Aug-1991     Created

*********************************************************************/

XYRECT& XYRECT::operator+=( const XYRECT& xySrc )
{
    AdjustLeft( xySrc._rect.left );
    AdjustRight( xySrc._rect.right );
    AdjustTop( xySrc._rect.top );
    AdjustBottom( xySrc._rect.bottom );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::ContainsXY

    SYNOPSIS:   check whether the point is located within the rectangle or
                not

    ENTRY:      XYPOINT xy - the xy point to be checked

    RETURN:     TRUE is the point is located within the rectangle.
                FALSE otherwise

    HISTORY:
        terryk      29-Jul-1991 Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

BOOL XYRECT::ContainsXY( XYPOINT xy ) const
{
    return ::PtInRect( (RECT *)&_rect, xy.QueryPoint() );
}


/*********************************************************************

    NAME:       XYRECT::IsEmpty

    SYNOPSIS:   check whether the rectangle is empty or not

    RETURN:     TRUE if the rectangle is empty.
                FALSE otherwise

    HISTORY:
        terryk  29-JUl-1991 Created

*********************************************************************/

BOOL XYRECT::IsEmpty() const
{
    return ::IsRectEmpty( (RECT *) &_rect );
}


/*********************************************************************

    NAME:       XYRECT::operator==

    SYNOPSIS:   given a rectangle. Check whether it is equal to the
                original rectangle

    ENTRY:      XYRECT &xyrect - rectangle to be compared

    RETURN:     TRUE if the rectangle are the same
                FALSE otherwise

    HISTORY:
                terryk  29-Jul-1991 Created

*********************************************************************/

BOOL XYRECT::operator==( const XYRECT& xyrect ) const
{
    return ::EqualRect( (RECT *)&_rect, (RECT *)&xyrect._rect );
}


/*********************************************************************

    NAME:       XYRECT::ConvertClientToScreen

    SYNOPSIS:   convert the rectangle to Screen coordinate

    ENTRY:      HWND hwnd - the associated window handle

    HISTORY:
        terryk      15-Aug-1991 Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

VOID XYRECT::ConvertClientToScreen( HWND hwnd )
{
    UIASSERT( hwnd != NULL );

    POINT pt;

    pt.x = _rect.left;
    pt.y = _rect.top;
    ::ClientToScreen( hwnd, &pt );
    _rect.left = pt.x;
    _rect.top  = pt.y;

    pt.x = _rect.right;
    pt.y = _rect.bottom;
    ::ClientToScreen( hwnd, &pt );
    _rect.right  = pt.x;
    _rect.bottom = pt.y;
}


/*********************************************************************

    NAME:       XYRECT::ConvertScreenToClient

    SYNOPSIS:   convert the current rectangle coordinate to client
                coordinate

    ENTRY:      HWND hwnd - the associated window handle

    HISTORY:
        terryk      15-Aug-1991 Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

VOID XYRECT::ConvertScreenToClient( HWND hwnd )
{
    UIASSERT( hwnd != NULL );

    POINT pt;

    pt.x = _rect.left;
    pt.y = _rect.top;
    ::ScreenToClient( hwnd, &pt );
    _rect.left = pt.x;
    _rect.top  = pt.y;

    pt.x = _rect.right;
    pt.y = _rect.bottom;
    ::ScreenToClient( hwnd, &pt );
    _rect.right  = pt.x;
    _rect.bottom = pt.y;
}


/*******************************************************************

    NAME:       XYPOINT::ScreenToClient

    SYNOPSIS:   Convert a point from screen to client coordinates

    ENTRY:      HWND - handle of target window

    EXIT:       Coordinate system changed

    NOTES:

    HISTORY:
        beng        09-Oct-1991 Created

********************************************************************/

VOID XYPOINT::ScreenToClient( HWND hwnd )
{
    POINT pt;
    pt.x = _x;
    pt.y = _y;
    ::ScreenToClient( hwnd, &pt );
    _x = pt.x;
    _y = pt.y;
}


/*******************************************************************

    NAME:       XYPOINT::ClientToScreen

    SYNOPSIS:   Convert a point from client to screen coordinates

    ENTRY:      HWND - handle of current client window

    EXIT:       Coordinate system changed

    NOTES:

    HISTORY:
        beng        09-Oct-1991 Created

********************************************************************/

VOID XYPOINT::ClientToScreen( HWND hwnd )
{
    POINT pt;
    pt.x = _x;
    pt.y = _y;
    ::ClientToScreen( hwnd, &pt );
    _x = pt.x;
    _y = pt.y;
}


/*******************************************************************

    NAME:       XYPOINT::InRect

    SYNOPSIS:   Return whether the point is within a rectangle

    ENTRY:      xyr - rectangle under consideration

    RETURNS:    TRUE if point fits within rectagle

    NOTES:

    HISTORY:
        beng        09-Oct-1991 Created

********************************************************************/

BOOL XYPOINT::InRect( const XYRECT & xyr ) const
{
    POINT pt;
    pt.x = _x;
    pt.y = _y;

    return !!(::PtInRect( (RECT*)(const RECT *)xyr, pt ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltsload.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsload.cxx
    NLS/DBCS-aware string class:  Load

*/

#include "pchblt.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::Load

    SYNOPSIS:   Loads a string from a resource file.

    ENTRY:      msgid   - ID of the string resource to load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    CAVEATS:
        Please use RESOURCE_STR instead of this function, if possible.

    NOTES:
        This function may fragment the heap somewhat if its realloc
        requires in new memory for the string.  Alternatives include
        always bloating the string up to MAX_RES_STR_LEN, so that we
        can load the resource directly into its buffer without the
        temp buffer; creating the temp buffer on the stack; or creating
        the temp buffer in a new BUFFER object.  Should profile heap
        usage in our apps and revisit.  REVIEW PROFILE

    HISTORY:
        rustanl     31-Jan-1991 Created
        beng        23-Jul-1991 Allow on erroneous string
        beng        07-Oct-1991 Use MSGID and APIERR
        beng        18-Oct-1991 Renamed from "LoadString"
        beng        20-Nov-1991 Unicode fixes
        beng        31-Dec-1991 No longer bloats strings unnecessarily
        beng        03-Aug-1992 Loads strings itself; dllization;
                                remove size limit

********************************************************************/

APIERR NLS_STR::Load( MSGID msgid )
{
    if (QueryError())
        return QueryError();

    if ( msgid < IDS_UI_BASE )
    {
#if defined(WIN32)
        return LoadSystem( msgid );
#endif
    }

    return Load( msgid, BLT::CalcHmodString(msgid) ) ;
}


#if defined(WIN32)
/*******************************************************************

    NAME:       NLS_STR::LoadSystem

    SYNOPSIS:   Loads a string from the system's resource files.

    ENTRY:      msgid   - ID of the string resource to load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    HISTORY:
        beng        05-Aug-1992 Created
        YiHsinS     01-Jan-1993 Use W version of FormatMessage

********************************************************************/

APIERR NLS_STR::LoadSystem( MSGID msgid )
{
    if (QueryError())
        return QueryError();

    HANDLE hmod = NULL;
    DWORD dwFlags =  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_IGNORE_INSERTS  |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK;

    if ((msgid <= MAX_LANMAN_MESSAGE_ID) && (msgid >= MIN_LANMAN_MESSAGE_ID))
    {
        // Net Errors
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hmod = BLT::CalcHmodString(msgid);
    }
    else   // other system errors
    {
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }


    TCHAR* pchBuffer = NULL;
    UINT cch = (UINT) ::FormatMessage( dwFlags,
                                       hmod,
                                       msgid,
                                       0,
                                       (LPTSTR)&pchBuffer,
                                       1024,
                                       NULL );
    if (cch > 0)
    {
        APIERR err = CopyFrom(pchBuffer);
        ::LocalFree((VOID*)pchBuffer);
        return err;
    }
    else
    {
        return ::GetLastError();
    }
}
#endif // WIN32


/*******************************************************************

    NAME:       RESOURCE_STR::RESOURCE_STR

    SYNOPSIS:   Constructs a nls-string from a resource ID.

    ENTRY:      idResource

    EXIT:       Successful construct, or else ReportError

    NOTES:      This string may not be owner-alloc!  For owner-alloc,
                cons up a new one and copy this into it.

    HISTORY:
        beng        23-Jul-1991 Created
        beng        07-Oct-1991 Use MSGID

********************************************************************/

RESOURCE_STR::RESOURCE_STR( MSGID msgid )
    : NLS_STR()
{
    UIASSERT(!IsOwnerAlloc());

    APIERR err = Load(msgid);
    if (err)
        ReportError(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\blttimer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    blttimer.cxx
    BLT's timer object.

    Currently, window only have 16 timers at one
    time. However, in order to provide more timer for the blt
    application, a timer class is created. This is a timer multiplexer.
    It will first get a timer from the system and then set up a global
    call back function. Depending on each element in the request list,
    the global call back function will call the requested element's
    call back function when time is up.

    FILE HISTORY:
        terryk      29-May-1991 Created
        terryk      14-Jun-1991 Add a serve request counter
        terryk      18-Jul-1991 code review changed. Attend: terryk jonn ericch
        rustanl     10-Sep-1991 Large changes, introducing new timer hierarchy
*/

#include "pchblt.hxx"   // Precompiled header

#define TICKCOUNT_50_PERCENT  ( 1L << ( sizeof( ULONG ) * 8 - 1 ))

DEFINE_SLIST_OF( TIMER_BASE );


/*********************************************************************

    NAME:       TIMER_WINDOW

    SYNOPSIS:   An invisible window which contains the timer object and
                handle all the WM_TIMER message.

    PARENT:     CLIENT_WINDOW

    USES:       BLT_MASTER_TIMER, TIMER_BASE

    CAVEATS:    User does not have to directly access this class because
                BLT_MASTER_TIMER will create this object during
                initialization.

    HISTORY:
                terryk  1-Jun-91    Created
                rustanl 06-Sep-91   Moved class decl. into .cxx file
                rustanl 9-Sep-91    Removed _dwOldTime data member

**********************************************************************/

class TIMER_WINDOW: public CLIENT_WINDOW
{
private:
    BLT_MASTER_TIMER * _pmastertimer;

protected:
    BOOL OnTimer( const TIMER_EVENT & tEvent );

public:
    TIMER_WINDOW( BLT_MASTER_TIMER * pmastertimer );
};


/*********************************************************************

    NAME:       TIMER_WINDOW::TIMER_WINDOW

    SYNOPSIS:   An invisible app to trap the WM_TIMER message.

    HISTORY:
                terryk  1-Jun-91    Created
                rustanl 9-Sep-91    Removed _dwOldTime data member; added
                                    pmastertimer parameter and corresponding
                                    data member

**********************************************************************/

TIMER_WINDOW::TIMER_WINDOW( BLT_MASTER_TIMER * pmastertimer )
    :   CLIENT_WINDOW( WS_OVERLAPPEDWINDOW, NULL ),
        _pmastertimer( pmastertimer )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _pmastertimer != NULL );
}


/*********************************************************************

    NAME:       TIMER_WINDOW::OnTimer

    SYNOPSIS:   Trap the WM_TIMER message.

    ENTRY:      const TIMER_EVENT &tEvent - Timer event

    HISTORY:
                terryk  01-Jun-91   Created
                terryk  14-Jun-91   Add a serve request count
                rustanl 06-Sep-91   Use DispatchTimer
                rustanl 10-Sep-91   Removed unneeded serve request count

**********************************************************************/

BOOL TIMER_WINDOW::OnTimer( const TIMER_EVENT &tEvent )
{
    UNREFERENCED( tEvent );

    TIMER_BASE * pTimer;

    _pmastertimer->ResetIterator();
    while (( pTimer = _pmastertimer->NextTimer()) != NULL )
    {
        if ( ( ! pTimer->IsEnabled()) || pTimer->_fBeingServed )
            continue;

        ULONG ulCurrentTickCount = ::GetTickCount();
        ULONG ulNextDue = pTimer->_ulNextTimerDue;

        //  Note, since the tick count may wrap, we need to take special
        //  action.  This gets a bit hairy.  Simplified, this is the
        //  algorithm used:
        //
        //      fTimeIsDue =
        //          ( ulNextDue <= ulCurrentTickCount &&
        //            ulCurrentTickCount < ulNextDue + TICKCOUNT_50_PERCENT );
        //
        //  The tricky part is that ulNextDue + TICKCOUNT_50_PERCENT
        //  may overflow what can be stored in a ULONG.  This occurs when
        //  ulNextDue is at least TICKCOUNT_50_PERCENT.
        //

        BOOL fTimerIsDue;
        if ( ulNextDue < TICKCOUNT_50_PERCENT )
        {
            //  ulNextDue + TICKCOUNT_50_PERCENT won't overflow
            fTimerIsDue =
                    ( ulNextDue <= ulCurrentTickCount &&
                      ulCurrentTickCount < ulNextDue + TICKCOUNT_50_PERCENT );
        }
        else
        {
            //  ulNextDue + TICKCOUNT_50_PERCENT will overflow
            fTimerIsDue =
                    ( ulNextDue <= ulCurrentTickCount ||
                      ulCurrentTickCount < ulNextDue - TICKCOUNT_50_PERCENT );
        }

        if ( fTimerIsDue )
        {
            /*  Timer is due.  Make the callout.
             */

            pTimer->_fBeingServed = TRUE;
            pTimer->DispatchTimer();
            pTimer->_fBeingServed = FALSE;

            pTimer->SetNewTimeDue();
        }
    }
    return TRUE;
}


#define MASTER_TIMER_INTERVAL       (500)
#define IDT_MASTER_TIMER            (1)

BLT_MASTER_TIMER * BLT_MASTER_TIMER::_pBltMasterTimer = NULL;

static UINT _cInit = 0; // CODEWORK - make a static class member
                        // (I'm saving myself a rebuild here, that's all)


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::Init

    SYNOPSIS:   Initialize the global object - Master Timer

    NOTES:      This method must be called before any timer can be used
                successfully

    HISTORY:
        terryk      30-May-1991 Created
        rustanl     09-Sep-1991 Allocate global objects dynamically
        beng        05-Aug-1992 Dllization

**********************************************************************/

APIERR BLT_MASTER_TIMER::Init()
{
    TRACEEOL( "BLT_MASTER_TIMER::Init()" );

    if (_cInit++ != 0) // Allow multiple registrands.  (Only first has effect.)
        return NERR_Success;

    TRACEEOL( "BLT_MASTER_TIMER::Init(); creating master timer" );

    // Make sure Init has not been called before
    ASSERT( _pBltMasterTimer == NULL );

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    _pBltMasterTimer = new BLT_MASTER_TIMER;
    if (   (_pBltMasterTimer == NULL)
        || ((err = _pBltMasterTimer->QueryError()) != NERR_Success) )
    {
        DBGEOL("NETUI2.DLL: BLT_MASTER_TIMER::Init failed, err " << (UINT)err);
    }

    return err;
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::Term

    SYNOPSIS:   Terminate the global object - Master Timer

    HISTORY:
        terryk      30-May-1991 Created
        rustanl     09-Sep-1991 Allocate global objects dynamically
        beng        05-Aug-1992 Dllization

**********************************************************************/

VOID BLT_MASTER_TIMER::Term()
{
    TRACEEOL( "BLT_MASTER_TIMER::Term()" );

    ASSERT(_cInit > 0); // Ensure that Terms match Inits

    if (--_cInit != 0)
        return;

    TRACEEOL( "BLT_MASTER_TIMER::Term(); deleting master timer" );

    delete _pBltMasterTimer;
    _pBltMasterTimer = NULL;
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::BLT_MASTER_TIMER

    SYNOPSIS:   constructor - request a timer from the system

    HISTORY:
        terryk      30-May-1991 Created
        rustanl     09-Sep-1991 Allocate TIMER_WINDOW from here
        beng        05-Aug-1992 Twiddled error reporting

**********************************************************************/

BLT_MASTER_TIMER::BLT_MASTER_TIMER()
    : BASE(),
    _slTimer( FALSE ),
    _iterTimer( _slTimer ),
    _wTimerId( 0 ),
    _pclwinTimerApp( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    _pclwinTimerApp = new TIMER_WINDOW( this );
    if (   (_pclwinTimerApp == NULL)
        || ((err = _pclwinTimerApp->QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }

    //  Note, the destructor assumes that _wTimerId is assigned to after
    //  *_pclwinTimerApp is successfully constructed.

    TRACEEOL("BLT_MASTER_TIMER::ctor; setting timer for HWND "
                << (DWORD)(_pclwinTimerApp->QueryHwnd()) );
    _wTimerId = ::SetTimer( _pclwinTimerApp->QueryHwnd(),
                            IDT_MASTER_TIMER,
                            MASTER_TIMER_INTERVAL,
                            NULL );
    DWORD dwErr = ::GetLastError();
    TRACEEOL("BLT_MASTER_TIMER::ctor; SetTimer returned timer ID " << (DWORD)_wTimerId);
    if ( _wTimerId == 0 )
    {
        DBGEOL( "NETUI2.DLL: BLT_MASTER_TIMER::SetTimer failed with error "
                << dwErr);
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::~BLT_MASTER_TIMER

    SYNOPSIS:   destructor - kill the timer from the window system

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Use _wTimerId and handle _pclwinTimerApp

**********************************************************************/

BLT_MASTER_TIMER::~BLT_MASTER_TIMER()
{
    TRACEEOL("BLT_MASTER_TIMER::dtor; HWND is "
                << (DWORD)(_pclwinTimerApp->QueryHwnd()) );
    TRACEEOL("BLT_MASTER_TIMER::dtor; timer ID is " << (DWORD)_wTimerId);
    if ( _wTimerId != 0 )
    {
        UIASSERT( _pclwinTimerApp != NULL );   // assume ct constructed this
                                               // before assigning to _wTimerId
        BOOL fTimerErr = ::KillTimer(_pclwinTimerApp->QueryHwnd(), IDT_MASTER_TIMER);
        DWORD dwErr = ::GetLastError();
        TRACEEOL("BLT_MASTER_TIMER::dtor; KillTimer returned " << fTimerErr);
        if (!fTimerErr)
        {
            DBGEOL("NETUI2.DLL: BLT_MASTER_TIMER::dtor; KillTimer failed with error " << dwErr);
        }
        else
        {
            _wTimerId = 0;
        }
        // REQUIRE( fTimerErr );
    }

    delete _pclwinTimerApp;
    _pclwinTimerApp = NULL;
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::ResetIterator

    SYNOPSIS:   Reset the master timer list to the beginning

    HISTORY:
                terryk  30-May-91   Created

**********************************************************************/

VOID BLT_MASTER_TIMER::ResetIterator()
{
    _iterTimer.Reset();
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::NextTimer

    SYNOPSIS:   return the next timer to the caller

    HISTORY:
                terryk  30-May-91   Created

**********************************************************************/

TIMER_BASE *BLT_MASTER_TIMER::NextTimer()
{
    return (TIMER_BASE *)_iterTimer.Next();
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::RemoveTimer

    SYNOPSIS:   remove the timer from the master timer list

    ENTRY:      TIMER_BASE *Timer - Timer to be removed

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Changed parameter name

**********************************************************************/

VOID BLT_MASTER_TIMER::RemoveTimer( TIMER_BASE * pTimer )
{
    ITER_SL_OF( TIMER_BASE ) iterTimer( _slTimer );
    TIMER_BASE * ptimerTmp;

    while ( ( ptimerTmp = iterTimer.Next()) != NULL )
    {
        if ( ptimerTmp == pTimer )
        {
            _slTimer.Remove( iterTimer );
            return ;
        }
    }
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::InsertTimer

    SYNOPSIS:   Add an element to the master timer list

    ENTRY:      TIMER_BASE *p - Timer to be added

    RETURN:     return the apierr if the insertion is failed.

    NOTES:      This function assumes that there will never be more
                than 2^16 different timers instantiated.  No check
                is being made to handle overflows; in the unlikely
                event that 'tidNext' below wraps around from 0 reusing
                an ID, *and* that ID is currently in use by another timer,
                *and* that timer happens to be dispatched to the same
                timer recipient, all that would happen is that some
                timer would seem to occur before or after when it was
                set up to occur.

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Added timer ID assignment

**********************************************************************/

APIERR BLT_MASTER_TIMER::InsertTimer( TIMER_BASE * pTimer )
{
    static TIMER_ID tidNext = 0;
    pTimer->_tid = tidNext;
    tidNext++;
    UIASSERT( tidNext != 0 );       // assume no overflow will ever occur

    return _slTimer.Add( pTimer );
}


/*******************************************************************

    NAME:       BLT_MASTER_TIMER::QueryMasterTimer

    SYNOPSIS:   Returns a pointer to the master timer

    ENTRY:      ppmastertimer -     Pointer to location which will receive
                                    pointer to master timer

    EXIT:       On success, *ppmastertimer will contain a pointer to the
                master timer

    RETURNS:    An API return value, which is NERR_Success on success

    NOTES:      BLT_MASTER_TIMER::Init is called from the APPLICATION
                constructor.  Since a derived application may contain
                a timer, which will be constructed regardless of whether
                or not the application constructed, this method must
                be able to gracefully handle cases where _pBltMasterTimer
                does not point to a successfully constructed master
                timer.

    HISTORY:
        rustanl     09-Sep-1991 Created
        beng        05-Aug-1992 Twiddle error reporting

********************************************************************/

APIERR BLT_MASTER_TIMER::QueryMasterTimer( BLT_MASTER_TIMER * * ppmastertimer )
{
    UIASSERT( ppmastertimer != NULL );

    if ( _pBltMasterTimer == NULL )
        return ERROR_NOT_ENOUGH_MEMORY; // hey, just a guess

    APIERR err = _pBltMasterTimer->QueryError();
    if ( err != NERR_Success )
        return err;

    *ppmastertimer = _pBltMasterTimer;

    return NERR_Success;
}


/*******************************************************************

    NAME:       BLT_MASTER_TIMER::ClearMasterTimerHotkey

    SYNOPSIS:   Clears the hotkey (if any) associated with the master timer,
                and returns its vkey code.

    RETURNS:    vkey code, or NULL if no vkey or on error

    NOTES:      BLT_MASTER_TIMER::Init creates the master timer window,
                which for many apps is the first window they will create.
                Program Manager will assign the default hotkey to this
                window.  This method clears that hotkey and returns its
                vkey code so that the hotkey can be applied to the
                correct window.

    HISTORY:
        jonn        05-Jul-1995 Created

********************************************************************/

ULONG BLT_MASTER_TIMER::ClearMasterTimerHotkey()
{
    BLT_MASTER_TIMER * pbltmastertimer = NULL;
    APIERR err = QueryMasterTimer( &pbltmastertimer );
    if (err != NERR_Success)
    {
        DBGEOL( "NETUI2.DLL: BLT_MASTER_TIMER::ClearMasterTimerHotKey error "
                << err );
        return NULL;
    }
    UIASSERT(   pbltmastertimer != NULL
             && pbltmastertimer->QueryError() == NERR_Success
             && pbltmastertimer->_pclwinTimerApp != NULL );
    TIMER_WINDOW * ptimerMasterTimer = pbltmastertimer->_pclwinTimerApp;
    ULONG vkeyHotkey = (ULONG)ptimerMasterTimer->Command( WM_GETHOTKEY );
    if (vkeyHotkey != NULL)
    {
        ULONG retval = (ULONG)ptimerMasterTimer->Command( WM_SETHOTKEY, NULL );
        switch (retval)
        {
        case 1:
            break;
        case 2:
            TRACEEOL( "NETUI2.DLL: BLT_MASTER_TIMER::ClearMasterTimerHotkey: "
                      << "another window already has hotkey NULL" );
            break;
        default:
            DBGEOL( "NETUI2.DLL: BLT_MASTER_TIMER::ClearMasterTimerHotkey retval "
                    << retval );
        }
    }

    return vkeyHotkey;
}


/*********************************************************************

    NAME:       TIMER_BASE::TIMER_BASE

    SYNOPSIS:   Constructor - create the timer object and add it to the
                master timer list

    ENTRY:      msInterval - Interval, measured in milliseconds, at which
                             the timer should go off.  This interval may
                             not exceed TICKCOUNT_50_PERCENT, which is defined
                             to be exactly half of the number of unique tick
                             counts.  (Today, a tick count is stored in
                             a ULONG, so TICKCOUNT_50_PERCENT amounts to
                             about 25 days.)

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Use QueryMasterTimer method

**********************************************************************/

TIMER_BASE::TIMER_BASE( ULONG msInterval,
                        BOOL fEnabled )
    :   BASE(),
        _msInterval( msInterval ),
        _fEnabled( fEnabled ),
        _ulNextTimerDue( 0 ),   // for now; initialized later in SetNewTimeDue
        _fBeingServed( FALSE ),
        _tid( 0 )               // for now; initialized later in BMT::InsertTimer
{
    if ( QueryError() != NERR_Success )
        return;

    if ( TICKCOUNT_50_PERCENT <= _msInterval )
    {
        ASSERT( FALSE ); // Interval too long. Can only support intervals less than TICKCOUNT_50_PERCENT
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

    if ( fEnabled )
        SetNewTimeDue();

    BLT_MASTER_TIMER * pmastertimer;
    APIERR err;
    if (   (err = BLT_MASTER_TIMER::QueryMasterTimer( &pmastertimer ))
                                                     != NERR_Success
        || (err = pmastertimer->InsertTimer( this )) != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*********************************************************************

    NAME:       TIMER_BASE::~TIMER_BASE

    SYNOPSIS:   destructor - delete the blt timer object from the
                master timer list

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Use QueryMasterTimer method

**********************************************************************/

TIMER_BASE::~TIMER_BASE()
{
    BLT_MASTER_TIMER * pmastertimer;
    if ( BLT_MASTER_TIMER::QueryMasterTimer( &pmastertimer ) == NERR_Success )
    {
        pmastertimer->RemoveTimer( this );
    }
}


/*******************************************************************

    NAME:       TIMER_BASE::SetNewTimeDue

    SYNOPSIS:   Sets up the next time at which the timer is due

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER_BASE::SetNewTimeDue()
{
    _ulNextTimerDue = ::GetTickCount() + _msInterval;
}


/*********************************************************************

    NAME:       TIMER_BASE::Enable

    SYNOPSIS:   Enables or disables the timer

    ENTRY:      fEnable -       TRUE to enable the timer; FALSE to disable
                                the timer

    HISTORY:
        rustanl     10-Sep-1991     Created

**********************************************************************/

VOID TIMER_BASE::Enable( BOOL fEnable )
{
    if ( fEnable && !_fEnabled )
    {
        SetNewTimeDue();
    }

    _fEnabled = fEnable;
}


/*******************************************************************

    NAME:       TIMER_BASE::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER_BASE::DispatchTimer()
{
    //  do nothing
}


/*******************************************************************

    NAME:       TIMER_BASE::TriggerNow

    SYNOPSIS:   Forces the timer to be triggered.  Does not affect
                the next interval at which it will ripen anyway.

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER_BASE::TriggerNow()
{
    DispatchTimer();
}


/*******************************************************************

    NAME:       WINDOW_TIMER::WINDOW_TIMER

    SYNOPSIS:   WINDOW_TIMER constructor

    ENTRY:      hwnd -      Window handle of window that will receive the
                            timers
                            CODEWORK.  Could create version of constructor
                            that takes a WINDOW *.  However, the TIMER
                            class seems like a better choice anyway since
                            we have control over it, rather than that
                            Windows imposes its queue priorities.

                msInterval - Interval, measured in milliseconds, at which
                             the timer should go off.

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

                fPostMsg -  Specifies whether timer messages should be
                            posted or sent.  TRUE indicates they will
                            be posted; FALSE (default) indicates they will
                            be sent.

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

WINDOW_TIMER::WINDOW_TIMER( HWND hwnd,
                            ULONG msInterval,
                            BOOL fEnabled,
                            BOOL fPostMsg     )
    :   TIMER_BASE( msInterval, fEnabled ),
        _hwnd( hwnd ),
        _fPostMsg( fPostMsg )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _hwnd != NULL );
}


/*******************************************************************

    NAME:       WINDOW_TIMER::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID WINDOW_TIMER::DispatchTimer()
{
    if ( _fPostMsg )
    {
        // post a message to the window
        ::PostMessage( _hwnd, WM_TIMER, QueryID(), NULL );
    }
    else
    {
        // send a message to the window
        ::SendMessage( _hwnd, WM_TIMER, QueryID(), NULL );
    }
}


/*******************************************************************

    NAME:       PROC_TIMER::PROC_TIMER

    SYNOPSIS:   PROC_TIMER constructor

    ENTRY:      hwnd -          Handle to window to be used

                lpTimerFunc -   Pointer to timer function which will
                                get timer notifications

                msInterval -    Interval, measured in milliseconds, at which
                                the timer should go off.

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

    HISTORY:
        rustanl     06-Sep-1991 Created
        beng        17-Oct-1991 Win32 conversion

********************************************************************/

PROC_TIMER::PROC_TIMER( HWND hwnd,
                        MFARPROC lpTimerFunc,
                        ULONG msInterval,
                        BOOL fEnabled          )
    :   TIMER_BASE( msInterval, fEnabled ),
        _hwnd( hwnd ),
        _lpTimerFunc( lpTimerFunc )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( lpTimerFunc != NULL );
}


/*******************************************************************

    NAME:       PROC_TIMER::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991 Created
        beng        17-Oct-1991 Win32 conversion

********************************************************************/

VOID PROC_TIMER::DispatchTimer()
{
    // directly call the WndProc
    ::CallWindowProc( (WNDPROC)_lpTimerFunc, _hwnd, WM_TIMER,
                      QueryID(), NULL );
}


/*******************************************************************

    NAME:       TIMER_CALLOUT::OnTimerNotification

    SYNOPSIS:   Called when a TIMER object matures

    ENTRY:      tid -       Specifies the timer ID of the timer that
                            matured

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

VOID TIMER_CALLOUT::OnTimerNotification( TIMER_ID tid )
{
    UNREFERENCED( tid );

    DBGEOL( "TIMER_CALLOUT::OnTimerNotification called with tid="
           << (UINT)tid );
}


/*******************************************************************

    NAME:       TIMER::TIMER

    SYNOPSIS:   TIMER constructor

    ENTRY:      ptimercallout - Pointer to TIMER_CALLOUT object which will
                                receive timer notifications

                msInterval -    Interval, measured in milliseconds, at which
                                the timer should go off.

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

TIMER::TIMER( TIMER_CALLOUT * ptimercallout,
              ULONG msInterval,
              BOOL fEnabled                    )
    :   TIMER_BASE( msInterval, fEnabled ),
        _ptimercallout( ptimercallout )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( ptimercallout != NULL );
}


/*******************************************************************

    NAME:       TIMER::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER::DispatchTimer()
{
    _ptimercallout->OnTimerNotification( QueryID());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\maskmap.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    Maskmap.cxx

    This file contains the implementation for the MASK_MAP class.

    FILE HISTORY:
	Johnl	02-Aug-1991	Created

*/

#include "pchblt.hxx"  //  Precompiled header inclusion

#include "maskmap.hxx"


DEFINE_SLIST_OF( STRING_BITSET_PAIR ) ;

/*******************************************************************

    NAME:	MASK_MAP::MASK_MAP

    SYNOPSIS:	Constructor, does nothing except initialize slist and
		iterators.

    NOTES:

    HISTORY:
	Johnl	02-Aug-1991	Created

********************************************************************/

MASK_MAP::MASK_MAP()
  : _slbitnlsPairs( TRUE ),
    _sliterStrings( _slbitnlsPairs ),
    _sliterBits( _slbitnlsPairs )
{
    /* Nothing to do */

}

MASK_MAP::~MASK_MAP()
{ }
/*******************************************************************

    NAME:	MASK_MAP::Add

    SYNOPSIS:	Adds an association to the MASK_MAP

    ENTRY:	bitfieldMask - Bitfield to associate the string with
		nlsString    - String to associate the bitfield with
		nID	     - User defined ID to categorize the association

    RETURNS:	NERR_Success if the addition was successful, an
		appropriate error code otherwise

    NOTES:

    HISTORY:
	Johnl	02-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::Add( const BITFIELD & bitfieldMask,
		      const NLS_STR  & nlsString,
		      INT   nID )
{
    UIASSERT( bitfieldMask.QueryError() == NERR_Success ) ;
    UIASSERT( nlsString.QueryError() == NERR_Success ) ;

    STRING_BITSET_PAIR * pnewpair = new STRING_BITSET_PAIR( nlsString,
							    bitfieldMask, nID ) ;
    if ( pnewpair == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    APIERR err = pnewpair->QueryError()  ;
    if ( err != NERR_Success )
    {
	delete pnewpair ;
	return err ;
    }

    err = _slbitnlsPairs.Append( pnewpair ) ;

    return err ;
}

/*******************************************************************

    NAME:	MASK_MAP::Add

    SYNOPSIS:	Adds multiple entities based on the passed array.  Good
		for static initializers.  Automatically loads the string
		IDS using nls.LoadString.

    ENTRY:	usidspairs - Array of struct US_IDS_PAIRS
		cCount - Number of items in the array

    EXIT:	The MASK_MAP will be initialized with the data in the
		array if no error occurs.

    RETURNS:	NERR_Success if no error occurred.

    NOTES:

    HISTORY:
	Johnl	9-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::Add( US_IDS_PAIRS usidspairs[], USHORT cCount )
{
    APIERR err ;
    NLS_STR  nls ;

    for ( unsigned i = 0 ; i < cCount ; i++ )
    {
	BITFIELD bitsMask( (USHORT)usidspairs[i].usBitMask ) ;

	if ( err = nls.Load( usidspairs[i].idsStringID ) != NERR_Success )
	    return err ;

	if ( (err = Add( bitsMask, nls, usidspairs[i].nID )) != NERR_Success )
	    return err ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	MASK_MAP::BitsToString

    SYNOPSIS:	Finds the first bitfield in the list that matches the
		passed bitfield, and returns its associated string.

    ENTRY:	bitfieldKey - Search key
		pnlsString - Pointer to NLS_STR that will receive this
		    associated string

    EXIT:	pnlsString will contain the associated string

    RETURNS:	NERR_Success if successful
		ERROR_NO_ITEMS if the matching bitfield is not found
		Some Other standard error

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::BitsToString( const BITFIELD & bitfieldKey,
			       NLS_STR	* pnlsString,
			       INT	  nID,
			       UINT	* puiFoundIndex )
{
    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;
    UINT uiFoundIndex = 0 ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
	if ( (BITFIELD &) bitfieldKey == *(pbitnlsPair->QueryBitfield()) &&
	     nID == pbitnlsPair->QueryID() )
	{
	    *pnlsString = *(pbitnlsPair->QueryString()) ;
	    if ( puiFoundIndex != NULL )
		*puiFoundIndex = uiFoundIndex ;

	    return pnlsString->QueryError() ;
	}

	uiFoundIndex++ ;
    }

    // Couldn't find a match, return a "couldn't find" error message
    return ERROR_NO_ITEMS ;
}

/*******************************************************************

    NAME:	MASK_MAP::StringToBits

    SYNOPSIS:	Finds the first string in the list that matches the
		passed key string, and returns its associated bitfield.

    ENTRY:	nlsStringKey - Search key
		pbitfield - Pointer to BITFIELD that will receive this
		    associated bitfield

    EXIT:	pbitfield will contain the associated bitfield

    RETURNS:	NERR_Success if successful
		ERROR_NO_ITEMS if the matching bitfield is not found
		Some Other standard error

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::StringToBits( const NLS_STR  & nlsStringKey,
			       BITFIELD * pbitfield,
			       INT	  nID,
			       UINT	* puiFoundIndex )
{
    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;
    UINT uiFoundIndex = 0 ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
	if ( *(pbitnlsPair->QueryString()) == nlsStringKey &&
	     nID == pbitnlsPair->QueryID()  )
	{
	    APIERR err = pbitfield->Resize( (pbitnlsPair->QueryBitfield())->QueryCount() ) ;
	    if ( err != NERR_Success )
		return err ;

	    *pbitfield = *(pbitnlsPair->QueryBitfield()) ;
	    if ( puiFoundIndex != NULL )
		*puiFoundIndex = uiFoundIndex ;
	    return pbitfield->QueryError() ;
	}

	uiFoundIndex++ ;
    }

    // Couldn't find a match, return a "couldn't find" error message
    return ERROR_NO_ITEMS ;

}

/*******************************************************************

    NAME:	MASK_MAP::EnumStrings

    SYNOPSIS:	Lists all of the strings in the table with a particular
		ID.

    ENTRY:	pnlsString - Pointer to receive enumerated string
		pfMoreData - Set to FALSE when no more data
		fFromBeginning - Start listing from beginning (should be
		    set to FALSE on subsequent calls)
		nID - Enumerate all values with this ID

    EXIT:	pnlsString will contain the enumerated string
		pfMoreData will be set to FALSE if there isn't any(more)
		    data to enumerate

    RETURNS:	NERR_Success if all went well, else some standard error code.

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::EnumStrings( NLS_STR * pnlsString,
			      BOOL *	pfMoreData,
			      BOOL *	pfFromBeginning,
			      INT	nID )
{
    if ( *pfFromBeginning )
    {
	_sliterStrings.Reset() ;
	*pfFromBeginning = FALSE ;
    }

    STRING_BITSET_PAIR * pbitnlsPair ;

    while ( (pbitnlsPair = _sliterStrings.Next()) != NULL )
    {
	if ( pbitnlsPair->QueryID() == nID )
	{
	    *pnlsString = *(pbitnlsPair->QueryString()) ;
	    *pfMoreData = TRUE ;
	    return pnlsString->QueryError() ;
	}
    }

    *pfMoreData = FALSE ;
    return NERR_Success ;
}


/*******************************************************************

    NAME:	MASK_MAP::EnumBits

    SYNOPSIS:	Lists all of the bitfields in the table with a particular
		ID.

    ENTRY:	pbitfield - Pointer to receive enumerated bitield
		pfMoreData - Set to FALSE when no more data
		fFromBeginning - Start listing from beginning (should be
		    set to FALSE on subsequent calls)
		nID - Enumerate all values with this ID

    EXIT:	pbitfield will contain the enumerated bitfield
		pfMoreData will be set to FALSE if there isn't any(more)
		    data to enumerate

    RETURNS:	NERR_Success if all went well, else some standard error code.

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::EnumBits( BITFIELD* pbitfield,
			   BOOL *    pfMoreData,
			   BOOL *    pfFromBeginning,
			   INT	     nID )

{
    if ( *pfFromBeginning )
    {
	_sliterStrings.Reset() ;
	*pfFromBeginning = FALSE ;
    }

    STRING_BITSET_PAIR * pbitnlsPair ;

    while ( (pbitnlsPair = _sliterStrings.Next()) != NULL )
    {
	if ( pbitnlsPair->QueryID() == nID )
	{
	    *pbitfield = *(pbitnlsPair->QueryBitfield()) ;
	    *pfMoreData = TRUE ;
	    return pbitfield->QueryError() ;
	}
    }

    *pfMoreData = FALSE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:	MASK_MAP::QueryBits

    SYNOPSIS:	Retrieves the nth item of this mask map

    ENTRY:	uiIndex - index of string/bitfield pair to retrieve
		pbitfield - pointer to bitfield to receive the bitfield
		pnlsString - Pointer to NLS_STR to receive the string
		pnID	   - Pointer to the ID for this entry.	If it is
		    NULL, then this parameter is ignored.

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	10-Feb-1992	Created

********************************************************************/

APIERR MASK_MAP::QueryBits(   UINT	       uiIndex,
			      BITFIELD	     * pbitfield,
			      NLS_STR	     * pnlsString,
			      int	     * pnID	  )
{
    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;

    if ( uiIndex > QueryCount() )
	return ERROR_INVALID_PARAMETER ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
	if ( uiIndex-- == 0 )
	{
	    break ;
	}
    }

    UIASSERT( pbitnlsPair != NULL ) ;

    APIERR err = pbitfield->Resize( (pbitnlsPair->QueryBitfield())->QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    *pbitfield = *(pbitnlsPair->QueryBitfield()) ;
    *pnlsString = *(pbitnlsPair->QueryString()) ;

    if ( pnID != NULL )
	*pnID = pbitnlsPair->QueryID() ;

    return (pbitfield->QueryError() ? pbitfield->QueryError() :
					      pnlsString->QueryError()) ;
}

/*******************************************************************

    NAME:       MASK_MAP::IsPresent

    SYNOPSIS:   Makes sure all of the bits contained in the past bitfield
                have corresponding bits in this mask map.

    ENTRY:      pbitfield - Bitfield to look for

    RETURNS:    TRUE if found, FALSE otherwise

    NOTES:

    HISTORY:
        Johnl   02-Feb-1993     Created

********************************************************************/

BOOL MASK_MAP::IsPresent( BITFIELD * pbitfield )
{
    UIASSERT( pbitfield != NULL ) ;
    BITFIELD bitfield( *pbitfield ) ;

    if ( bitfield.QueryError() )
        return FALSE ;

    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;
    BOOL fFound = FALSE ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
        bitfield |= *pbitnlsPair->QueryBitfield() ;

        //
        //  Get out early if we found an exact match
        //
        if ( *pbitnlsPair->QueryBitfield() == *pbitfield )
        {
            fFound = TRUE ;
	    break ;
	}
    }

    if ( !fFound )
    {
        bitfield.Not() ;
        fFound = !(bitfield & *pbitfield) ;
    }

    return fFound ;
}

/*******************************************************************

    NAME:	STRING_BITSET_PAIR::STRING_BITSET_PAIR

    SYNOPSIS:	Constructor for the STRING_BITSET_PAIR class

    ENTRY:	nlsString - string to associate with this bitfield
		bitfieldMask - Bitfield to associate with this string
		nID is a user defined tag that can be used to group
		    the bitset/string pairs.

    NOTES:

    HISTORY:
	Johnl	02-Aug-1991	Created

********************************************************************/

STRING_BITSET_PAIR::STRING_BITSET_PAIR( const NLS_STR &  nlsString,
					const BITFIELD & bitfieldMask,
					      INT	 nID	       )
    : _nlsString( nlsString ),
      _bitfieldMask( bitfieldMask ),
      _nID( nID )
{
    APIERR err ;
    if ( ( err = _nlsString.QueryError() ) ||
	 ( err = _bitfieldMask.QueryError() ) )
    {
	ReportError( err ) ;
	return ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\bltwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltwin.cxx
    BLT base window class definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        beng        14-May-1991 Exploded blt.hxx into components
        terryk      10-Jul-1991 Added IsEnable to Window class
        beng        31-Jul-1991 Reloc'd fClientGen'dMsg to class
        terryk      12-Aug-1991 Change QueryWindowRect to QueryClient
                                window rect
        terryk      20-Aug-1991 Change QueryClientRect back to
                                QueryWindowRect
        beng        30-Sep-1991 Added ASSOCHWNDTHIS class
        beng        18-Oct-1991 Threw in some tracing
        Yi-Hsins     8-Jan-1991 Added HasFocus method
        terryk      02-Apr-1992 Added Z position in SetPos
        terryk      28-Apr-1992 fixed Z position problem in SetPos
        KeithMo     11-Nov-1992 Added new ctor form and Center method.
        Yi-HsinS    10-Dec-1992 Added CalcFixedHeight
        DavidHov    17-Sep-1993 Changes for C8 and re-dllization
*/


#include "pchblt.hxx"   // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

#define WIN32_REMOVEPROP_BUG 1

// Indicates that the message was generated internally and not
// by the user manipulating controls.
//
BOOL WINDOW::_fClientGeneratedMessage = FALSE;

const TCHAR * ASSOCHWNDTHIS::_pszPropThisLo = SZ("BltPropThisL");
const TCHAR * ASSOCHWNDTHIS::_pszPropThisHi = SZ("BltPropThisH");


#if defined(DEBUG) && defined(TRACE) && 0
DBGSTREAM& operator<<(DBGSTREAM &out, const WINDOW * pwnd)
{
    TCHAR szBuf[12];
    FMT(szBuf, SZ("%lx"), (ULONG)pwnd);
    out << SZ("WINDOW ") << szBuf;

    return out;
}

DBGSTREAM& operator<<(DBGSTREAM &out, HWND hwnd)
{
    out << (ULONG)hwnd;

    return out;
}
#endif

#ifndef max
inline INT max(INT a, INT b)
{
    return (a > b) ? a : b;
}
#endif

/**********************************************************************

    NAME:       WINDOW::WINDOW

    SYNOPSIS:   Constructor for the WINDOW object.

    ENTRY:      Without parameters, leaves an empty object which can
                later adopt an existing window (via SetHwnd).

        - or -

                pszClassName - class name of window class
                flStyle      - dword of style bits
                pwndOwner    - pointer to owner window
                cid          - control ID.  Default is 0, which
                               means no ID (and no menu if not
                               a WS_CHILD).


    NOTES:
        The parmless WINDOW object does no real construction;
        rather, it is a repository for a large body of common
        methods and information, much of which can only be
        calculated well into the construction process by one
        of its derived classes.  Hence this version of the ctor
        does nearly nothing.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        25-Apr-1991 Removed unused hwndOwner parm
        beng        07-May-1991 Added CreateWindow versions
        beng        15-May-1991 Added CID child-window support
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

WINDOW::WINDOW(
    const TCHAR * pszClassName,
    ULONG         flStyle,
    const WINDOW *pwndOwner,
    CID           cid )
    : _hwnd(NULL),
      _fCreator(FALSE)
{
    // CODEWORK: make these const with C7

    UIASSERT( ((cid == 0) || (flStyle & WS_CHILD)) );

    HWND hwndOwner = (pwndOwner == 0) ? 0 : pwndOwner->_hwnd;

    HWND hwnd = ::CreateWindow(pszClassName,
                               SZ(""), flStyle,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               hwndOwner, (HMENU)LongToHandle(cid), hmodBlt, 0);
    if (hwnd == 0)
    {
        ReportError(hwnd == 0);
        return;
    }

    _hwnd = hwnd;
    _fCreator = TRUE;
}


WINDOW::WINDOW()
    : _hwnd( NULL ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


WINDOW::WINDOW( HWND hwnd )
    : _hwnd( hwnd ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


/**********************************************************************

    NAME:       WINDOW::~WINDOW

    SYNOPSIS:   Destructor of WINDOW

    ENTRY:      Valid WINDOW base.  If _fCreator set, has a window
                object (id'd by _hwnd) which it needs to destroy.

    EXIT:       Window destroyed

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        07-May-1991     Added DestroyWindow function

**********************************************************************/

WINDOW::~WINDOW()
{
    if (_fCreator)
    {
        if (!::DestroyWindow(_hwnd))
        {
            DWORD err = ::GetLastError();
            DBGEOL( "NETUI: WINDOW::dtor: DestroyWindow( " << ((DWORD)(DWORD_PTR)_hwnd)
                    << " ) failed with error " << err );
            // ASSERT( FALSE ); removing again
        }
    }
}


/*******************************************************************

    NAME:       WINDOW::ResetCreator

    SYNOPSIS:   Resets the fCreator flag

    ENTRY:      fCreator is set; presumably, we just noticed that
                some cad called DestroyWindow(this->QueryHwnd()).

    EXIT:       fCreator is clear

    NOTES:
        This is for when ClientWindow notices that some outside
        agency called DestroyWindow on its window.  Under normal
        circumstances it should never run.

    HISTORY:
        beng        10-May-1991     Created

********************************************************************/

VOID WINDOW::ResetCreator()
{
    UIASSERT(_fCreator);
    _fCreator = FALSE;
}


/*******************************************************************

    NAME:       WINDOW::SetHwnd

    SYNOPSIS:   Sets the window-handle member of WINDOW.
                This is integral to complete object construction
                (i.e. including derived classes).

    ENTRY:      hwnd - new value of window handle

    EXIT:       _hwnd has been set

    NOTES:
        This method should be called only once in the lifetime of
        a window.

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n
        beng        07-May-1991     Updated to honor _fCreator

********************************************************************/

VOID WINDOW::SetHwnd( HWND hwnd )
{
    UIASSERT(!_fCreator);   // better not have created any window
    UIASSERT(_hwnd == 0);   // or for that matter have already called this

    _hwnd = hwnd;
}


/*******************************************************************

    NAME:       WINDOW::QueryHwnd

    SYNOPSIS:   Return the Windows HWND associated with the WINDOW

    RETURNS:    the value of _hwnd

    NOTES:

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n

********************************************************************/

HWND WINDOW::QueryHwnd() const
{
    return _hwnd;
}


/**********************************************************************

    NAME:       WINDOW::QueryOwnerHwnd

    SYNOPSIS:   Return the hwnd of the window's owner

    RETURNS:    HWND of window's owner

    NOTES:

    HISTORY:
       beng     25-Apr-1991 Moved out of the class def'n
       beng     09-Oct-1991 Win32 conversion

***********************************************************************/

HWND WINDOW::QueryOwnerHwnd() const
{
#if defined(WIN32)
    return (HWND) ::GetWindowLongPtr( _hwnd, GWLP_HWNDPARENT );
#else
    return (HWND) ::GetWindowWord( _hwnd, GWW_HWNDPARENT );
#endif
}


/**********************************************************************

    NAME:       WINDOW::Command

    SYNOPSIS:   This method sends a message to the window.

    ENTRY:
        usMsg               Message
        wParam, lParam      Message parameters

    RETURNS:    The return code of the message.

    CAVEATS:
        This method is obviously not host environment independent.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG_PTR WINDOW::Command( UINT nMsg, WPARAM wParam, LPARAM lParam ) const
{
    return ::SendMessage( _hwnd, nMsg, wParam, lParam );
}


/**********************************************************************

    NAME:       WINDOW::QueryStyle

    SYNOPSIS:   Return the style bits for the window

    RETURNS:    Style bits (dword)

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG WINDOW::QueryStyle() const
{
    return (ULONG) ::GetWindowLong( _hwnd, GWL_STYLE );
}


/**********************************************************************

    NAME:       WINDOW::SetStyle

    SYNOPSIS:   Set the style bits for the window

    NOTES:
        This is a protected member function, intended to allow controls
        to change their style.

    HISTORY:
        beng        13-Feb-1992 Created

**********************************************************************/

VOID WINDOW::SetStyle( ULONG nValue )
{
    ::SetWindowLong( _hwnd, GWL_STYLE, (LONG)nValue );
}


/**********************************************************************

    NAME:       WINDOW::QueryClientRect

    SYNOPSIS:   get the client coordinates of a window's client area

    ENTRY:      RECT * pRect - the returned coordinates

    EXIT:       RECT * pRect - fill the data structure with the window's
                               coordinates.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      20-Jul-1991 Created
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryClientRect( RECT * pRect ) const
{
    ::GetClientRect( _hwnd, pRect );
}

VOID WINDOW::QueryClientRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, TRUE );
    *pxyxy = xyxy;
}


/*********************************************************************

    NAME:       WINDOW::QueryWindowRect

    SYNOPSIS:   get the window's screen coordinate

    ENTRY:      RECT *pRect - rectangle data structure to store the
                information.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      2-Aug-1991  Created
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryWindowRect( RECT * pRect ) const
{
    ::GetWindowRect( _hwnd, pRect );
}

VOID WINDOW::QueryWindowRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, FALSE );
    *pxyxy = xyxy;
}


/**********************************************************************

    NAME:       WINDOW::SetText

    SYNOPSIS:
        This method sets the text of a window.  The text of an application
        window or dialog is the caption, whereas it is the text contents of
        a controls for many controls.

    ENTRY:
         psz             A pointer to the text
     or
         nls             NLS text string

    EXIT:

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        rustanl     27-Apr-1991 Changed PSZ to const TCHAR *
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

VOID WINDOW::SetText( const TCHAR * psz )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, psz );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


VOID WINDOW::SetText( const NLS_STR & nls )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, nls.QueryPch() );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


/**********************************************************************

    NAME:       WINDOW::QueryText

    SYNOPSIS:   Returns the text of a window.

    ENTRY:
        pszBuffer   A pointer to a buffer, where the window text
                    will be copied.
        cbBufSize   The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough.

            - or -

        pnls        Pointer to a NLS_STR

    RETURNS:
        0 if successful; NERR_BufTooSmall if given buffer too small.

    NOTES:
        The length of the window text can be retrieved by calling
        WINDOW::QueryTextLength, while the storage needed to copy
        that text is available via WINDOW::QueryTextSize.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Changed return type; made const
        beng        10-Jun-1991 Tinkered for Unicode
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

**********************************************************************/

APIERR WINDOW::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    UINT cbActual = QueryTextSize();

    if (cbBufSize < cbActual)
        return NERR_BufTooSmall;

    if (cbBufSize > 0 && pszBuffer == NULL)
        return ERROR_INVALID_PARAMETER;

    // This Win API works in total TCHARs, including terminator.
    //
    ::GetWindowText(_hwnd, (TCHAR *)pszBuffer, cbBufSize/sizeof(TCHAR) );

    return 0;
}

APIERR WINDOW::QueryText( NLS_STR * pnls ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    UINT cbActual = QueryTextSize();

    BLT_SCRATCH scratch( cbActual );
    if (!scratch)
        return scratch.QueryError();

    ::GetWindowText( _hwnd,
                     (TCHAR*)scratch.QueryPtr(),
                     scratch.QuerySize()/sizeof(TCHAR) );

    return pnls->CopyFrom((TCHAR*)scratch.QueryPtr());
}


/**********************************************************************

    NAME:       WINDOW::QueryTextLength

    SYNOPSIS:   Returns the length of the window text.
                See WINDOW::SetText for a description of "window text".

    RETURNS:    The length, in actual characters (as opposed to the
                byte-characters of strlen), of the window text.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Made const
        beng        10-Jun-1991 Changed return type
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

***********************************************************************/

INT WINDOW::QueryTextLength() const
{
    return ::GetWindowTextLength( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::QueryTextSize

    SYNOPSIS:   Returns the byte count of the window text,
                including the terminating character

    RETURNS:    Count of bytes

    NOTES:

    HISTORY:
        beng        10-Jun-1991 Created
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

********************************************************************/

INT WINDOW::QueryTextSize() const
{
    INT cchRet = ::GetWindowTextLength( _hwnd );

    return (cchRet + 1) * sizeof(TCHAR);
}


/**********************************************************************

    NAME:       WINDOW::ClearText

    SYNOPSIS:   Clears the window text of the window.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::ClearText()
{
    SetText( SZ("") );
}


/**********************************************************************

    NAME:       WINDOW::Show

    SYNOPSIS:   This method shows or hides a window.

    ENTRY:
       f        Indicates whether to show or hide the window:
                TRUE to show the window, and FALSE to hide it.

    RETURNS:    The previous state of the windows:
                  FALSE if the window was previously hidden
                  TRUE if the window was previously visible

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::Show( BOOL f )
{
    return ::ShowWindow( _hwnd, ( f ? SW_SHOW : SW_HIDE ));
}


/**********************************************************************

    NAME:       WINDOW::Enable

    SYNOPSIS:   Enables or disables a window.

    ENTRY:
        f       Indicates whether to enable or disable the
                window:  TRUE to enable, and FALSE to disable.

    EXIT:
        Window is enabled or disabled (duh) as requested.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        26-Dec-1991 With full understanding, removed some tracery

**********************************************************************/

VOID WINDOW::Enable( BOOL f )
{
    if ( f != IsEnabled() )
    {
        ::EnableWindow( _hwnd, f );
    }
}


/*********************************************************************

    NAME:       WINDOW::IsEnabled

    SYNOPSIS:   return the current status of the window

    RETURN:     return TRUE if the window is enable, FALSE if the window
                is disable.

    HISTORY:
        terryk      8-Jul-91    Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::IsEnabled() const
{
    return !! ::IsWindowEnabled( _hwnd );
}


/**********************************************************************

    NAME:       WINDOW::SetRedraw

    SYNOPSIS:   Sets or clears the redraw flag of the window.

    ENTRY:
       f        Indicates whether to set or clear the redraw flag.
                TRUE sets it, whereas FALSE clears it.
                TRUE is the default value for this parameter.

    EXIT:

    NOTES:
        Setting the redraw flag on does not refresh listboxes.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::SetRedraw( BOOL f )
{
    Command( WM_SETREDRAW, f );
}


/**********************************************************************

    NAME:       WINDOW::Invalidate

    SYNOPSIS:   Invalidates some or all of the client area of the window.

    ENTRY:
       fErase   Indicates whether the window's background is to
                be erased (default FALSE).  This version invalidates
                the entire client region.

       rect     Rectangle to invalidate within client area.  This version
                doesn't erase.

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        13-Feb-1992 Rolled in CLIENT_WINDOW::Repaint

**********************************************************************/

VOID WINDOW::Invalidate( BOOL fErase )
{
    ::InvalidateRect( _hwnd, NULL, fErase );
}

VOID WINDOW::Invalidate( const XYRECT & rect )
{
    ::InvalidateRect( _hwnd, (RECT*)(const RECT *)rect, FALSE );
}


/*******************************************************************

    NAME:       WINDOW::RepaintNow

    SYNOPSIS:   Force an immediate repaint of the window

    EXIT:       Window is completely valid, and has been repainted
                irregardless of outstanding PAINT messages

    HISTORY:
        beng        10-May-1991 Implemented
        beng        13-Feb-1992 Relocated to WINDOW from CLIENT_WINDOW

********************************************************************/

VOID WINDOW::RepaintNow()
{
    ::UpdateWindow( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::ShowFirst

    SYNOPSIS:   The first "Show" call for a client or owned window

    ENTRY:      Window has never been shown - just created

    EXIT:       Window is visible on screen

    NOTES:
        A window's creator should make this call when it is ready
        for the window to appear.

    HISTORY:
        beng        31-Jul-1991     Created

********************************************************************/

VOID WINDOW::ShowFirst()
{
    Show(TRUE);
    Invalidate(FALSE);
}


/*******************************************************************

    NAME:      WINDOW::SetPos

    SYNOPSIS:  Moves a windows to the new cooridinates

    ENTRY:     xy - New position of window,
               fRepaint = TRUE if repaint after move
               WINDOW *pwin - the Z value for the control.
                      The TAB order of the control is placed after pwin.
                      If pwin is NULL, the tab order of the control
                      will be the same as its position in the resource
                      file or according to its creation time.

    NOTES:     Cooridinates are relative to:
                Screen if pop-up window
                Client if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Uses XYPOINT
        beng        09-Oct-1991 Win32 conversion
        terryk      02-Apr-1992 Added Z position

********************************************************************/

VOID WINDOW::SetPos( XYPOINT xy, BOOL fRepaint, WINDOW *pwin )
{
#if 0 // this is the old way - required a Query before could Set
    INT nWidth, nHeight;

    QuerySize( &nWidth, &nHeight );

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  nWidth, nHeight, fRepaint );
#else
    ::SetWindowPos(_hwnd, ( pwin == NULL ) ? 0 : pwin->QueryHwnd(),
                   xy.QueryX(), xy.QueryY(), 0, 0,
                   ((( pwin == NULL ) ?  SWP_NOZORDER : 0 ) | SWP_NOSIZE |
                   (fRepaint?0:SWP_NOREDRAW)));
#endif
}


/*******************************************************************

    NAME:       WINDOW::QueryPos

    SYNOPSIS:   Get the current position (top left corner) of *this

    RETURNS:    Current position of window

    NOTES:
        Cooridinates are relative to:
        Screen if pop-up window
        Client area of parent if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYPOINT version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Withdrew vanilla POINT version

********************************************************************/

XYPOINT WINDOW::QueryPos() const
{
    RECT rc;
    ::GetWindowRect(_hwnd, &rc);

    XYPOINT xy(rc.left, rc.top);

    /* If the window is a child window, then we need to get the coordinates
     * relative to the parent's client area
     */
    if (IsChild())
        xy.ScreenToClient(QueryOwnerHwnd());

    return xy;
}


/*******************************************************************

    NAME:       WINDOW::SetSize

    SYNOPSIS:   Sets the width and height of a window

    ENTRY:      nWidth, nHeight - width and height for window
                -or-
                dxy - desired dimensions of window

    EXIT:

    NOTES:
        Size is not the client area, but full size including borders,
        menus and captions.

        This command causes the window to receive OnMove and OnSize
        events.

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYDIM version
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::SetSize( INT cxWidth, INT cyHeight, BOOL fRepaint )
{
#if 0 // this is the old way - required a Query before could Set
    XYPOINT xy = QueryPos();

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  cxWidth, cyHeight, fRepaint );

#else

    ::SetWindowPos(_hwnd, 0, 0, 0, cxWidth, cyHeight,
                   (SWP_NOZORDER|SWP_NOMOVE|(fRepaint?0:SWP_NOREDRAW)));
#endif
}

VOID WINDOW::SetSize( XYDIMENSION dxy, BOOL fRepaint )
{
    SetSize(dxy.QueryWidth(), dxy.QueryHeight(), fRepaint);
}


/*******************************************************************

    NAME:      WINDOW::QuerySize

    SYNOPSIS:  Get the current size of this window

    ENTRY:     pnWidth, pnHeight - pointers to receive
                                   current size of window

    EXIT:
        If px, py supplied, they've been loaded with X and Y.

        Otherwise, returns XYDIM.

    NOTES:

    HISTORY:
        Johnl       7-Feb-91    Created
        beng        15-May-1991 Added XYDIM version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::QuerySize( INT *pnWidth, INT *pnHeight ) const
{
    RECT rcRect;
    ::GetWindowRect(_hwnd, &rcRect);

    *pnWidth  = rcRect.right - rcRect.left;
    *pnHeight = rcRect.bottom - rcRect.top;
}

XYDIMENSION WINDOW::QuerySize() const
{
    INT dx, dy;

    QuerySize(&dx, &dy);

    return XYDIMENSION(dx, dy);
}


/*******************************************************************

    NAME:       WINDOW::IsChild

    SYNOPSIS:   Determine whether window has CHILD style

    RETURNS:    TRUE if the WS_CHILD window style bits are set for window

    NOTES:

    HISTORY:
        Johnl       14-Feb-1991     Created
        beng        31-Jul-1991     Made 'const'

********************************************************************/

BOOL WINDOW::IsChild() const
{
    return ( WS_CHILD & QueryStyle() ) != 0 ;
}


/*******************************************************************

    NAME:     WINDOW::SetClientGeneratedMsgFlag

    SYNOPSIS: Sets the global flag _fClientGeneratedMessage.

    NOTES:
      Set to TRUE if this is a message we generated ourselves (and you don't
      want the shell dialog proc. to "process" it (i.e., send out notices
      to children etc.).  Be careful you only use this on messages that are
      sent immediately.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

VOID WINDOW::SetClientGeneratedMsgFlag( BOOL fInClientGeneratedMessage )
{
    _fClientGeneratedMessage = fInClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::IsClientGeneratedMsg

    SYNOPSIS: Returns TRUE if the _fClientGeneratedMessage flag is set.
              This means the current message is a message we should
              ignore.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

BOOL WINDOW::IsClientGeneratedMessage()
{
    return _fClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::HasFocus

    SYNOPSIS: Returns TRUE if the current window has the focus.

    HISTORY:
        Yi-HsinS    8-Jan-1992     Created

********************************************************************/

BOOL WINDOW::HasFocus( VOID ) const
{
    return ( QueryHwnd() == ::GetFocus() );
}


/*******************************************************************

    NAME:     WINDOW::Center

    SYNOPSIS: Centers the window above another window.

    ENTRY:    hwnd      - The window to center *this over.  If this
                          value is NULL, then the window is centered
                          over its parent.

    CODEWORK: It may be more aesthetically appealing to center
              child windows their parent's client area, rather
              than over the parent's window proper.

    HISTORY:
        KeithMo    11-Nov-1992     Created.

********************************************************************/

VOID WINDOW::Center( HWND hwnd )
{
    //
    //  If no window was specified, use the parent.
    //  If there is no parent, use the screen size.
    //

    INT xThis;
    INT yThis;

    XYRECT xycdThis;
    UIASSERT( !!xycdThis );

    QueryWindowRect( &xycdThis );

    if( hwnd == NULL )
    {
        hwnd = QueryOwnerHwnd();
    }

    if( hwnd == NULL )
    {
        HDC hdc;

        hdc = GetDC(_hwnd);
        if (!hdc) // JonN 01/23/00: PREFIX bug 444891
            return;

        xThis =  ( GetDeviceCaps(hdc, HORZRES) - xycdThis.CalcWidth()  ) / 2;

        yThis =  ( GetDeviceCaps(hdc, VERTRES) - xycdThis.CalcHeight() ) / 3;

        (void) ReleaseDC( _hwnd, hdc ); // JonN 01/23/00: PREFIX bug 444892
    }
    else
    {
        WINDOW windowParent( hwnd );
        UIASSERT( !!windowParent );

        //
        //  Get the bounding rectangles of this window & the
        //  parent window.  Note that QueryWindowRect returns
        //  *screen* coordinates!
        //

        XYRECT xycdParent;
        UIASSERT( !!xycdParent );

        windowParent.QueryWindowRect( &xycdParent );

        //
        //  Calculate the new window position relative
        //  to the parent.
        //

        xThis = xycdParent.QueryLeft() +
                ( xycdParent.CalcWidth()  - xycdThis.CalcWidth()  ) / 2;
        yThis = xycdParent.QueryTop() +
                ( xycdParent.CalcHeight() - xycdThis.CalcHeight() ) / 3;

    }

    XYPOINT xyThis( xThis, yThis );

    //
    //  Move the window into position.  The SetWindowPos API
    //  is documented as taking client coordinates when
    //  dealing with child windows, but it seems to actually
    //  want screen coordinates.
    //

    SetPos( xyThis );
}

/* Maximum height we expect bitmaps to be in the owner drawn list boxes
 */
const USHORT yMaxCDBitmap = 16;

/*******************************************************************

    NAME:       WINDOW::CalcFixedHeight

    SYNOPSIS:   Calculate height of fixed-size (single line) owner-draw object

    ENTRY:      hwnd   - handle to the window
                pmis   - as passed by WM_MEASUREITEM in lParam

    EXIT:

    RETURNS:    FALSE if the calculation fails for some reason

    NOTES:
        This is a static member of the class.

        This WM_MEASUREITEM message is sent before the
        WM_INITDIALOG message (except for variable size owner-draw
        list controls).  Since the window properties are not yet set
        up, the owner dialog cannot be called.

        The chosen solution for list controls is to assume that every
        owner-draw control will always have the same height as the font
        of that list control.  This is a very reasonable guess for most
        owner-draw list controls.  Since owner-draw list controls with
        variable size items call the owner for every item, the window
        properties will have been properly initialized by that time.  Hence,
        a client may respond to these messages through OnOther.

        Currently, owner-draw buttons are not supported.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        Yi-HsinS    10-Dec-1992 Moved from bltowin.cxx

********************************************************************/

BOOL WINDOW::CalcFixedHeight( HWND hwnd, UINT *pnHeight )
{
    DISPLAY_CONTEXT dc( hwnd );

    HFONT hFont = (HFONT)::SendMessage( hwnd, WM_GETFONT, 0, 0L );
    if ( hFont != NULL )
    {
        // Font isn't the system font
        dc.SelectFont( hFont );
    }

    TEXTMETRIC tm;
    if ( ! dc.QueryTextMetrics( &tm ))
        return FALSE;

    *pnHeight = max((USHORT)tm.tmHeight, yMaxCDBitmap);

    return TRUE;
}

/*******************************************************************

    NAME:       ASSOCHWNDTHIS::ASSOCHWNDTHIS

    SYNOPSIS:   Associates a hwnd with a pwnd

    ENTRY:      hwnd - handle of window
                pwnd - pointer to WINDOW

    EXIT:       Window has two properties added

    NOTES:
        This class inherits from BASE.  If the association fails,
        it will report an error.

    HISTORY:
        beng        30-Sep-1991 Created
        beng        07-Nov-1991 Error mapping

********************************************************************/

ASSOCHWNDTHIS::ASSOCHWNDTHIS( HWND hwnd, const VOID * pv )
    : _hwnd(hwnd)
{
    if (hwnd == 0 || pv == 0)
    {
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

#ifdef _WIN64
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)pv ))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#else
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)LOWORD( (ULONG_PTR)pv )))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)HIWORD( (ULONG_PTR)pv )))
    {
        ::RemoveProp( hwnd, (TCHAR*)_pszPropThisLo );
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#endif
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::~ASSOCHWNDTHIS

    SYNOPSIS:   Disassociate a hwnd from the WINDOW object.

    ENTRY:      There are two properties on the hwnd which
                contain the seg:off of the WINDOW object.

    EXIT:       Those two props are dust

    NOTES:
        This might seem unnecessary - after all, won't the
        DestroyWindow delete these properties?

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::DisassocHwndPwnd
        beng        30-Sep-1991 Made own class
        beng        04-Jun-1992 A little error checking needed here

********************************************************************/

ASSOCHWNDTHIS::~ASSOCHWNDTHIS()
{
    if (QueryError() == NERR_Success)
    {
#if defined(WIN32) && defined(WIN32_REMOVEPROP_BUG)
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)0 );
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)0 );
#else
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisLo );
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisHi );
#endif
    }
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::HwndToThis

    SYNOPSIS:   Given a hwnd, locate the corresponding object

    ENTRY:      hwnd - window handle returned by Windows

    RETURNS:    Pointer to some anonymous object, or NULL
                if nothing found

    NOTES:
        This is a static member function.

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::HwndToPwnd
        beng        30-Sep-1991 Made own class

********************************************************************/

VOID * ASSOCHWNDTHIS::HwndToThis( HWND hwnd )
{
    // GetProp returns 0 if it fails; hence these two will build
    // one 0L if they fail.
    //
#ifdef _WIN64
    return ::GetProp( hwnd, (TCHAR*)_pszPropThisLo );
#else
    return (VOID *)MAKELONG( ::GetProp( hwnd, (TCHAR*)_pszPropThisLo ),
                             ::GetProp( hwnd, (TCHAR*)_pszPropThisHi ));
#endif
}


/*********************************************************************

    NAME:       PROC_INSTANCE::PROC_INSTANCE

    SYNOPSIS:   constructor - create a Proc Instance

    ENTRY:      FARPROC fp

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::PROC_INSTANCE( MFARPROC fp )
#if defined(WIN32)
    : _fpInstance(fp)
#else
    : _fpInstance( ::MakeProcInstance( fp, BLT::QueryInstance() ))
#endif
{
    if ( _fpInstance == NULL )
    {
        //  Assume memory failure
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
    }
}


/*********************************************************************

    NAME:       PROC_INSTANCE::~PROC_INSTANCE

    SYNOPSIS:   destructor - free the procedure instance

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::~PROC_INSTANCE()
{
#if !defined(WIN32)
    if ( _fpInstance != NULL )
    {
        ::FreeProcInstance( _fpInstance );
# if defined(DEBUG)
        _fpInstance = NULL;
# endif
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\blt\progress.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    progress.cx
    This file contains the class definition for the PROGRESS_CONTROL
    class.

    The PROGRESS_CONTROL class is a display object derived from the
    ICON_CONTROL class.  PROGRESS_CONTROL adds a new method Advance()
    for cycling through a set of icons.


    FILE HISTORY:
        KeithMo     03-Oct-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.

*/
#include "pchblt.hxx"  // Precompiled header

//
//  PROGRESS_INDICATOR methods.
//

/*******************************************************************

    NAME:       PROGRESS_CONTROL :: PROGRESS_CONTROL

    SYNOPSIS:   PROGRESS_CONTROL class constructor.

    ENTRY:      powner                  - Owning window.

                cid                     - Cid for this control

                idFirstIcon             - Resource ID for the first
                                          icon in the icon list.

                cIcons                  - The number of icons to cycle.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
PROGRESS_CONTROL :: PROGRESS_CONTROL( OWNER_WINDOW * powner,
                                      CID            cid,
                                      UINT           idFirstIcon,
                                      UINT           cIcons )
  : ICON_CONTROL( powner, cid ),
    _cIcons( cIcons ),
    _idFirstIcon( idFirstIcon ),
    _usCurrent( 0 )
{
    CtAux();

}   // PROGRESS_CONTROL :: PROGRESS_CONTROL


/*******************************************************************

    NAME:       PROGRESS_CONTROL :: ~PROGRESS_CONTROL

    SYNOPSIS:   PROGRESS_CONTROL class destructor.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
PROGRESS_CONTROL :: ~PROGRESS_CONTROL()
{
    //
    //  This space intentionally left blank.
    //

}   // PROGRESS_CONTROL :: ~PROGRESS_CONTROL


/*******************************************************************

    NAME:       PROGRESS_CONTROL :: CtAux

    SYNOPSIS:   Auxilliary constructor.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
VOID PROGRESS_CONTROL :: CtAux( VOID )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Display the initial icon.
    //

    Advance();

}   // PROGRESS_CONTROL :: CtAux


/*******************************************************************

    NAME:       PROGRESS_CONTROL :: Advance

    SYNOPSIS:   Advance the progress indicator to the next icon.

    ENTRY:      nStep                   - The number of "steps" to
                                          increment the icon by.
                                          Default = 1.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
VOID PROGRESS_CONTROL :: Advance( INT nStep )
{
    //
    //  Display the current icon.
    //

    SetIcon( MAKEINTRESOURCE( _idFirstIcon + _usCurrent ) );

#ifdef WIN32
    //
    //  We need this Invalidate() call here to get around a bug
    //  in Win/NT which causes icon controls to not be repainted
    //  after a STM_SETICON message.  Remove this bulls**t when
    //  NT has been fixed!
    //

    Invalidate( TRUE );
#endif

    //
    //  Advance to the next icon in the cycle.
    //

    _usCurrent = ( _usCurrent + nStep ) % _cIcons;

}   // PROGRESS_CONTROL :: Advance
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltarrow.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltarrow.cxx
        Source file for SPIN_GROUP 's arrow control

    FILE HISTORY:
        terryk  15-May-91   Created
        terryk  12-Aug-91   create its own timer instead of using the
                            BLT_TIMER class
        terryk  19-Aug-91   Add OnLMouseDblClk to handle double click
                            problem
        terryk  26-Aug-91   Change the button behavious such that it
                            will be released if the mouse moves outside
                            the button area.
*/

#include "pchblt.hxx"  // Precompiled header



#define TIME_DELAY (75)


/**********************************************************************

    NAME:       ARROW_BUTTON::ARROW_BUTTON

    SYNOPSIS:   constructor for the arrow button within the
                SPIN_GROUP .

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control
                TCHAR * pszEnable - enable bitmap name
                TCHAR * pszEnableInvert - enable invert bitmap name
                CHA R* pszDisable - disable bitmap name

    HISTORY:
        terryk      15-May-91   Created
        beng        31-Jul-1991 Control error handling changed
        beng        17-Sep-1991 Elided winclass name (now uses that of
                                button control)
        beng        05-Oct-1991 Win32 conversion
        beng        04-Aug-1992 Load bitmaps by ordinal

**********************************************************************/

ARROW_BUTTON::ARROW_BUTTON( OWNER_WINDOW *powin, CID cid,
                            BMID nIdEnable, BMID nIdEnableInvert,
                            BMID nIdDisable )
    : GRAPHICAL_BUTTON_WITH_DISABLE( powin, cid, nIdEnable, nIdEnableInvert,
                                     nIdDisable ),
      CUSTOM_CONTROL( this ),
      _cTimerClick ( 0 ),
      _fPress( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

ARROW_BUTTON::ARROW_BUTTON( OWNER_WINDOW *powin, CID cid,
                            BMID nIdEnable, BMID nIdEnableInvert,
                            BMID nIdDisable,
                            XYPOINT pXY, XYDIMENSION dXY, ULONG flStyle )
    : GRAPHICAL_BUTTON_WITH_DISABLE( powin, cid, nIdEnable, nIdEnableInvert,
                                     nIdDisable, pXY, dXY, flStyle ),
      CUSTOM_CONTROL( this ),
      _cTimerClick ( 0 ),
      _fPress( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}


/*********************************************************************

    NAME:       ARROW_BUTTON::OnLMouseButtonDown

    SYNOPSIS:   Start the timer when the mouse button is down

    ENTRY:      MOUSE_EVENT &event

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL ARROW_BUTTON::OnLMouseButtonDown( const MOUSE_EVENT &event )
{
    UNREFERENCED( event );

    CaptureMouse();
    SetSelected( TRUE );
    Invalidate();
    RepaintNow();
    _fPress = TRUE;
    _cTimerClick = 0;
    REQUIRE( ::SetTimer( WINDOW::QueryHwnd(), 1, TIME_DELAY, NULL ) != 0 );
    return TRUE;
}


/*********************************************************************

    NAME:       ARROW_BUTTON::OnLMouseButtonUp

    SYNOPSIS:   stop the timer when the Mouse button up

    ENTRY:      MOUSE_EVENT &event

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

#define CLICK_COUNTER   20

BOOL ARROW_BUTTON::OnLMouseButtonUp( const MOUSE_EVENT & event )
{
    if ( !_fPress )
        return TRUE;

    _fPress = FALSE;
    ReleaseMouse();
    SetSelected( FALSE );
    REQUIRE( ::KillTimer( WINDOW::QueryHwnd(), 1 ));
    Invalidate();
    RepaintNow();

    XYRECT xyrect( WINDOW::QueryHwnd() );
    if ( xyrect.ContainsXY( event.QueryPos() ))
    {
        SPIN_GROUP  *pSB = (SPIN_GROUP *)QueryGroup();

        if ( _cTimerClick > CLICK_COUNTER )
        {
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_BIGINC );
        }
        else
        {
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_SMALLINC );
            _cTimerClick ++;
        }
    }
    _cTimerClick = 0;
    return TRUE;
}


/*********************************************************************

    NAME:       ARROW_BUTTON::OnTimer

    SYNOPSIS:   For each timer message, send a increase message to
                the spin button

    ENTRY:      TIMER_EVENT &tEvent

    HISTORY:
        terryk      29-May-91   Created
        beng        16-Oct-1991 Win32 conversion

*********************************************************************/

BOOL ARROW_BUTTON::OnTimer( const TIMER_EVENT & tEvent )
{
    UNREFERENCED( tEvent );

    BOOL fOldSelected = QuerySelected();

    XYPOINT xy = CURSOR::QueryPos();
    xy.ScreenToClient( WINDOW::QueryHwnd() );

    XYRECT xyrect( WINDOW::QueryHwnd() );
    if ( xyrect.ContainsXY( xy ))
    {
        SetSelected( TRUE );
        SPIN_GROUP  *pSB = (SPIN_GROUP *)QueryGroup();

        if ( _cTimerClick > 10 )
        {
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_BIGINC );
        }
        else
        {
            if ( _cTimerClick % 2 == 1 )
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_SMALLINC );
            _cTimerClick ++;
        }
    }
    else
    {
        SetSelected( FALSE );
    }
    if ( fOldSelected != QuerySelected() )
    {
        Invalidate();
        RepaintNow();
    }
    return TRUE;
}


/*********************************************************************

    NAME:       ARROW_BUTTON::QueryEventEffects

    SYNOPSIS:   request for the button status after this WM_COMMAND

    ENTRY:      Args of the WM_COMMAND

    RETURN:     CVMI_VALUE_CHANGE of the command is a clicked.
                CVMI_NO_VALUE_CHANGE otherwise.

    HISTORY:
        terryk      10-Jul-1991 Created
        beng        31-Jul-1991 Renamed, from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

UINT ARROW_BUTTON::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch( e.QueryCode() )
    {
    case BN_CLICKED:
        return CVMI_VALUE_CHANGE;

    default:
        break;
    }
    return CVMI_NO_VALUE_CHANGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltcolh.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltcolh.cxx
    Column header control implementation

    The column header control typically goes above a listbox where
    it tells the contents of each listbox column.


    FILE HISTORY:
	rustanl     22-Jul-1991     Created
	rustanl     07-Aug-1991     Added to BLT

*/


#include "pchblt.hxx"  // Precompiled header


/*******************************************************************

    NAME:	LB_COLUMN_HEADER::LB_COLUMN_HEADER

    SYNOPSIS:	LB_COLUMN_HEADER constructor

    ENTRY:	powin - 	Pointer to owner window
		cid -		Control ID
		xy -		Window position
		dxy -		Window size

    HISTORY:
	rustanl     22-Jul-1991     Created
	beng	    31-Jul-1991     Control error handling changed
        congpay     07-Jan-1993     add QueryHeight()

********************************************************************/

LB_COLUMN_HEADER::LB_COLUMN_HEADER( OWNER_WINDOW * powin, CID cid,
				    XYPOINT xy, XYDIMENSION dxy )
    :	SLT( powin, cid, xy, dxy,
	     SS_LEFT | WS_CHILD ),
	CUSTOM_CONTROL( this )
{
    if ( QueryError() != NERR_Success )
	return;
}

INT LB_COLUMN_HEADER::QueryHeight()
{
    DISPLAY_CONTEXT dc (this);

    return ((dc.QueryFontHeight()) + (METALLIC_STR_DTE::QueryVerticalMargins()));
}


/*********************************************************************

    NAME:       LB_COLUMN_HEADER::Dispatch

    SYNOPSIS:   Main routine to dispatch the event appropriately

    ENTRY:      EVENT event - general event

    HISTORY:
        jonn        26-May-1993 Created

*********************************************************************/

BOOL LB_COLUMN_HEADER::Dispatch( const EVENT &event, ULONG * pnRes )
{
    if ( event.QueryMessage() == WM_ERASEBKGND )
    {
        DWORD dwColor = ::GetSysColor( COLOR_WINDOW );

        HBRUSH hBrush = ::CreateSolidBrush( dwColor );
        ASSERT( hBrush != NULL );

        RECT r;
        QueryClientRect( &r );
        REQUIRE( ::FillRect( (HDC)event.QueryWParam(), &r, hBrush ) != FALSE );

        REQUIRE( ::DeleteObject( hBrush ) != FALSE );

        return TRUE;
    }

    return CUSTOM_CONTROL::Dispatch( event, pnRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltmeter.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltmeter.cxx
        Source file for Activity Meter custom control

    FILE HISTORY:
        terryk  10-Jun-91   Created
        o-SimoP 31-Jan-92   Added Frame
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * METER::_pszClassName = SZ("static");


/*********************************************************************

    NAME:       METER::METER

    SYNOPSIS:   Meter is an activity indicator object. It displays the
                number of percentage complete and mark the specified
                percentage of the rectangle with the specified color.

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control
                COLORREF color - color to paint the rectangle. Optional.
                                 If the color is missing, use BLUE.

    HISTORY:
        terryk      15-May-91       Created
        beng        31-Jul-1991     Control error reporting changed

**********************************************************************/

METER::METER( OWNER_WINDOW *powin, CID cid, COLORREF color )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        DBGOUT(SZ("BLTMETER error: constructor failed."));
        return;
    }

}

METER::METER( OWNER_WINDOW *powin, CID cid,
              XYPOINT xy, XYDIMENSION dxy, ULONG flStyle, COLORREF color )
    : CONTROL_WINDOW ( powin, cid, xy, dxy, flStyle, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        DBGOUT(SZ("BLTMETER error: constructor failed."));
        return ;
    }
}


/*********************************************************************

    NAME:       METER::SetComplete

    SYNOPSIS:   Reset the number of percentage completed

    ENTRY:      INT nComplete - completed percentage

    NOTES:      It will repaint the object every reset the percentage.

    HISTORY:
                terryk  15-May-91   Created

**********************************************************************/

VOID METER::SetComplete( INT nComplete )
{
    _nComplete = ( nComplete < 0 ) ? 0 :
                 (( nComplete > 100 ) ? 100 : nComplete );
    Invalidate( TRUE );
}


/*********************************************************************

    NAME:       METER::OnPaintReq

    SYNOPSIS:   Redraw the whole object

    HISTORY:
        terryk  15-May-91   Created
        o-SimoP 31-Jan-92   Added Frame
        beng    05-Mar-1992 Remove wsprintf; add BUG-BUG; use PAINT_dc
        beng    29-Mar-1992 Fix for Unicode (ExtTextOut usage)
        beng    05-May-1992 API changes

**********************************************************************/

BOOL METER::OnPaintReq()
{
    RECT rectClient, rectPercent;

    NLS_STR nlsPercent(SZ("%1%"));
    DEC_STR nlsNumber(_nComplete);
    ASSERT(!!nlsPercent && !!nlsNumber);

    if (!nlsPercent || !nlsNumber)
        return FALSE;

    APIERR err = nlsPercent.InsertParams(nlsNumber);
    ASSERT(err == NERR_Success);
    if (err != NERR_Success)
        return FALSE;

    PAINT_DISPLAY_CONTEXT dc(this);

    COLORREF rgbBkColor   = dc.SetBkColor( ::GetSysColor( COLOR_WINDOW ) );
    COLORREF rgbTextColor = dc.SetTextColor( _color );

    dc.SetTextAlign( TA_CENTER | TA_TOP );

    COLORREF rgbColor = dc.GetBkColor();

    // fill up the rectangle first

    dc.SetBkColor( dc.SetTextColor( rgbColor ));
    ::GetClientRect( WINDOW::QueryHwnd(), &rectClient );

    RECT rectOrg;       // Original rect
    ::SetRect( &rectOrg, (INT)rectClient.left, (INT)rectClient.top,
             (INT)rectClient.right, (INT)rectClient.bottom );

    ::InflateRect( &rectClient, -2, -2 );
    ::SetRect( &rectPercent, (INT)rectClient.left, (INT)rectClient.top,
             (( INT )((( LONG )rectClient.right * ( LONG )_nComplete )/ 100 )),
             (INT)rectClient.bottom );

    TEXTMETRIC  textmetric;

    dc.QueryTextMetrics( &textmetric );

    // draw half of the text
    dc.ExtTextOut( (INT)rectClient.right/2,
                   (INT)( rectClient.bottom - textmetric.tmHeight )/ 2,
                   ETO_OPAQUE | ETO_CLIPPED,
                   &rectPercent,
                   nlsPercent );

    rectPercent.left = rectPercent.right;
    rectPercent.right = rectClient.right;

    // draw the other half of the text
    rgbColor = dc.GetBkColor( );
    dc.SetBkColor( dc.SetTextColor( rgbColor ));
    dc.ExtTextOut( (INT)rectClient.right /2,
                   (INT)( rectClient.bottom - textmetric.tmHeight ) / 2,
                   ETO_OPAQUE | ETO_CLIPPED,
                   &rectPercent,
                   nlsPercent );

    dc.SetBkColor( rgbBkColor );
    dc.SetTextColor( rgbTextColor );

    dc.FrameRect( &rectOrg, ::CreateSolidBrush( 0x00000000 ) ); // Black

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltcc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltcc.cxx
    BLT custom control class implementation

    FILE HISTORY:
        terryk      16-Apr-1991 Creation
        terryk      05-Jul-1991 Second code review.
                                Attend: beng chuckc rustanl annmc terryk
        beng        18-May-1992 Added mouse handling
        beng        28-May-1992 The great bltcc/bltdisph scramble
*/

#include "pchblt.hxx"  // Precompiled header


extern "C"
{
    /* C7 CODEWORK - nuke this stub */
    /* main call back function */
    extern LPARAM _EXPORT APIENTRY BltCCWndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
    {
        return CUSTOM_CONTROL::WndProc(hwnd, nMsg, wParam, lParam);
    }
}



/*********************************************************************

    NAME:       CUSTOM_CONTROL::CUSTOM_CONTROL

    SYNOPSIS:   constructor. The constructor will set the internal
                call back function to DisphWndProc.

    ENTRY:      CONTROL_WINDOW * pWin - window's handler of the object

    HISTORY:
        terryk      22-May-1991 created
        beng        17-Oct-1991 Win32 conversion

*********************************************************************/

CUSTOM_CONTROL::CUSTOM_CONTROL( CONTROL_WINDOW * pctrl )
    : DISPATCHER( pctrl ),
    _pctrl( pctrl ),
    _instance( (MFARPROC)BltCCWndProc ),
    _lpfnOldWndProc(
        (MFARPROC)::SetWindowLongPtr( QueryHwnd(),
                                      GWLP_WNDPROC,
                                      (LONG_PTR) _instance.QueryProc()) )
{
    if ( _instance.QueryError() != NERR_Success )
    {
        DBGEOL( "BLTCC: ctor failed." );
    }
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::~CUSTOM_CONTROL

    SYNOPSIS:   destructor

    NOTE:       reset the call back function to the orginial one.

    HISTORY:
                terryk      22-May-1991 Created

*********************************************************************/

CUSTOM_CONTROL::~CUSTOM_CONTROL( )
{
    ::SetWindowLongPtr( QueryHwnd(), GWLP_WNDPROC, (LONG_PTR) _lpfnOldWndProc );
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::SubClassWndProc

    SYNOPSIS:   Depending on the original class call back function.
                If it is defined, it will pass the parameters to the
                original function. Otherwise, it will pass the
                parameters to Default Window Procedure.

    ENTRY:      EVENT event - the current event

    HISTORY:
        terryk      22-May-1991 created
        beng        17-Oct-1991 Win32 conversion

*********************************************************************/

LPARAM CUSTOM_CONTROL::SubClassWndProc( const EVENT & event )
{
    if ( _lpfnOldWndProc != NULL )
    {
        return ::CallWindowProc( (WNDPROC)_lpfnOldWndProc,
                                 QueryHwnd(),
                                 event.QueryMessage(),
                                 event.QueryWParam(),
                                 event.QueryLParam() );
    }
    else
    {
        return ::DefWindowProc( QueryHwnd(),
                                event.QueryMessage(),
                                event.QueryWParam(),
                                event.QueryLParam() );
    }
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::CVSaveValue

    SYNOPSIS:   Call the SaveValue method in the control window

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID CUSTOM_CONTROL::CVSaveValue( BOOL fInvisible )
{
    _pctrl->SaveValue( fInvisible );
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::CVRestoreValue

    SYNOPSIS:   Call the RestoreValue method in the control window

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID CUSTOM_CONTROL::CVRestoreValue( BOOL fInvisible )
{
    _pctrl->RestoreValue( fInvisible );
}


/*******************************************************************

    NAME:       CUSTOM_CONTROL::WndProc

    SYNOPSIS:   Window-proc for BLT custom control windows

    ENTRY:      As per wndproc

    EXIT:       As per wndproc

    RETURNS:    The usual code returned by a wndproc

    NOTES:
        This is a static member function.

        This is the wndproc proper for BLT custom control windows.  In
        the "extern C" clause above I declare a tiny exported stub
        which calls this.

    HISTORY:
        beng        10-May-1991 Implemented
        beng        20-May-1991 Add custom-draw control support
        beng        15-Oct-1991 Win32 conversion
        beng        28-May-1992 Great custom control dispatcher shuffle

********************************************************************/

LPARAM CUSTOM_CONTROL::WndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    // First, handle messages which are not concerned about whether or
    // not hwnd can be converted into pwnd.

#if 0 // These make no sense in a subclassed control - they're owner messages
    switch (nMsg)
    {
    case WM_COMPAREITEM:
    case WM_DELETEITEM:
        return OWNER_WINDOW::OnLBIMessages(nMsg, wParam, lParam);
    }
#endif

    CUSTOM_CONTROL * pwnd = (CUSTOM_CONTROL *)DISPATCHER::HwndToPwnd( hwnd );

    if (pwnd == NULL)
    {
        // If HwndToPwnd returns NULL, then either CreateWindow call
        // has not yet returned, or else this class's destructor has
        // already been called - important, since this proc will continue
        // to receive messages such as WM_DESTROY.  Since Blt Windows perform
        // their WM_CREATE style code in their constructor, it's okay to
        // let most of the traditional early messages pass us by.
        //
        // The exception is WM_GETMINMAXINFO, I suppose...
        //
        return ::DefWindowProc(hwnd, nMsg, wParam, lParam);
    }

#if 0 // These make no sense in a subclassed control - they're owner msgs
    switch (nMsg)
    {
    case WM_GUILTT:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        // Responses to owner-draw-control messages are defined
        // in the owner-window class.
        //
        // It makes no sense to redefine one of these without
        // redefining the others.  Proper redefinition of control
        // behavior is done in the CONTROL_WINDOW::CD_* functions.
        //
        return pwnd->OnCDMessages(nMsg, wParam, lParam);
    }
#endif

    // Assemble an EVENT object, and dispatch appropriately.

    // CODEWORK: this is a bit pokey, especially when subclassing
    // controls which extensively use messages internally (e.g., the
    // listbox).  Might want to build some sort of sparse map at ctor
    // time which would allow us to skip the dispatch for messages
    // we don't catch.

    EVENT event( nMsg, wParam, lParam );
    ULONG lRes32 = 0;
    LPARAM lRes;
    BOOL fRes = pwnd->Dispatch(event, &lRes32);
    if (fRes) {
        lRes = lRes32;
    } else {
        lRes = pwnd->SubClassWndProc(event);
    }

#if 0
    if (nMsg == WM_NCDESTROY)
    {
        // This is the last message that any window receives before its
        // hwnd becomes invalid.  This case will only be run if a BLT
        // client-window is destroyed by DestroyWindow instead of by
        // its destructor: a pathological case, since BLT custom controls
        // die by destructor even in a BLT dialog.
        //
        // Normally, a client window will receive DESTROY only after
        // its destructor has already disassociated the hwnd and pwnd.
        //
        // pwnd->DisassocHwndPwnd(); !!REVIEW!!
    }
#endif

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltlhour.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltlhour.cxx
    Source file for the Logon Hours custom control

    FILE HISTORY:
        beng        07-May-1992 Created
        KeithMo     07-Aug-1992 STRICTified.
        KeithMo     03-Nov-1992 Added hash marks, fixed some paint bugs.
*/

#include "pchblt.hxx"  // Precompiled header


// All lines ("wires") in the grid are 1x1

#define DXGRIDWIRES 1
#define DYGRIDWIRES 1

//
//  Drawing area offset from top of control.
//

#define Y_OFFSET (_dyRow + DYGRIDWIRES)


const TCHAR * LOGON_HOURS_CONTROL::_pszClassName = SZ("static");


inline VOID LOGON_HOURS_CONTROL::Beep() const
{
    ::MessageBeep(0);
}

inline BOOL LOGON_HOURS_CONTROL::IsButtonACell( INT iButton ) const
{
    return (iButton > 32);
}


/*********************************************************************

    NAME:       LOGON_HOURS_CONTROL::LOGON_HOURS_CONTROL

    SYNOPSIS:   Ctor for logon-hours custom control.

    ENTRY:      powin - owner window of the control
                cid   - cid of the control

    HISTORY:
        beng        07-May-1992 Created

**********************************************************************/

LOGON_HOURS_CONTROL::LOGON_HOURS_CONTROL( OWNER_WINDOW *powin, CID cid )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _hcurCross( CURSOR::LoadSystem(IDC_CROSS) ),
      _fSpaceIsDown(FALSE),
      _fMouseTrap(FALSE),
      _fFocusVisible(FALSE),
      _fCellsSelected(FALSE),
      _iCellSelUpper(0),
      _iCellSelLower(0),
      _iButtonDown(0), // Start with no buttons down
      _iWithFocus(33),
      _iFocusSave(33)  // Upper lefthand cell gets initial focus
{
    APIERR err = QueryError();
    if (err != NERR_Success)
        return;

    ::memset(_abSetting, 0, sizeof(_abSetting));

    HFONT hfont = (HFONT) ::SendMessage(QueryOwnerHwnd(), WM_GETFONT, 0, 0);
    if (hfont != NULL)
        SetFont(hfont);

    err = LoadLabels( IDS_SUNDAY );
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    err = CalcSizes(QuerySize());
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    Invalidate();
}

LOGON_HOURS_CONTROL::LOGON_HOURS_CONTROL( OWNER_WINDOW *powin, CID cid,
                                          XYPOINT xy, XYDIMENSION dxy )
    : CONTROL_WINDOW( powin, cid, xy, dxy, WS_CHILD, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _hcurCross( CURSOR::LoadSystem(IDC_CROSS) ),
      _fSpaceIsDown(FALSE),
      _fMouseTrap(FALSE),
      _fFocusVisible(FALSE),
      _fCellsSelected(FALSE),
      _iCellSelUpper(0),
      _iCellSelLower(0),
      _iButtonDown(0), // Start with no buttons down
      _iWithFocus(33),
      _iFocusSave(33)  // Upper lefthand cell gets initial focus
{
    APIERR err = QueryError();
    if (err != NERR_Success)
        return;

    ::memset(_abSetting, 0, sizeof(_abSetting));

    HFONT hfont = (HFONT) ::SendMessage(QueryOwnerHwnd(), WM_GETFONT, 0, 0);
    if (hfont != NULL)
        SetFont(hfont);

    err = LoadLabels( IDS_SUNDAY );
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    err = CalcSizes(dxy);
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    Invalidate();
}


/*********************************************************************

    NAME:       LOGON_HOURS_CONTROL::~LOGON_HOURS_CONTROL

    SYNOPSIS:   Dtor for logon-hours custom control.

    HISTORY:
        beng        07-May-1992 Created

**********************************************************************/

LOGON_HOURS_CONTROL::~LOGON_HOURS_CONTROL()
{
    UnloadLabels();
}



/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::QueryHours

    SYNOPSIS:   Queries the control as to the currently permitted hours.

    ENTRY:      plhrs - points to a "setting" collection, into which
                        the control will report its selected hours.

    EXIT:       Setting has been set

    RETURNS:    Error code, NERR_Success if OK

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::QueryHours( LOGON_HOURS_SETTING * plhrs ) const
{
    if (plhrs == NULL)
        return ERROR_INVALID_PARAMETER;
    if (!*plhrs)
        return plhrs->QueryError();

    // At present the control and logon hours both count from
    // midnight Sunday, making this a simple loop.

    APIERR err = NERR_Success;
    for (INT iHour = 0; iHour < 24*7 && err == NERR_Success; iHour++)
    {
        err = plhrs->SetHourInWeek( _abSetting[iHour], iHour );
    }

    return err;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::SetHours

    SYNOPSIS:   Paints the "wires" in the grid, along with the borders
                of the control and its buttons.

    ENTRY:      plhrs - points to a "setting" collection containing
                        the desired hours

    EXIT:       _abSetting has changed; grid is inval'd

    RETURNS:    Error code, NERR_Success if OK

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::SetHours( const LOGON_HOURS_SETTING * plhrs )
{
    if (plhrs == NULL)
        return ERROR_INVALID_PARAMETER;
    if (!*plhrs)
        return plhrs->QueryError();

    for (INT iHour = 0; iHour < 24*7; iHour++)
    {
        _abSetting[iHour] = (BYTE)plhrs->QueryHourInWeek(iHour);
    }

    // Grid contents now need a complete repaint.  Inval entire grid.

    XYRECT rGrid;
    CalcGridRect(&rGrid);
    Invalidate(rGrid);

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DoPermitButton

    SYNOPSIS:   Dialog hook, called when user hits Permit

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DoPermitButton()
{
    if (!_fCellsSelected)
        Beep();
    else
    {
        SetSelectedCells(TRUE);
    }
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DoBanButton

    SYNOPSIS:   Dialog hook, called when user hits Ban

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DoBanButton()
{
    if (!_fCellsSelected)
        Beep();
    else
    {
        SetSelectedCells(FALSE);
    }
}


/*********************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnPaintReq

    SYNOPSIS:   Handles paint messages for the control

    NOTES:
        Concerning the layout of the control -

        The control itself subsumes the grid, bars within the grid, quasi
        buttons bounding the grid, and the labels on the Days Of Week buttons.
        It does not include the labels of the Hours Of Day buttons, since those
        at present carry no labels, nor does it include the captions and bitmaps
        above the Hours Of Day buttons, the Permit/Ban push buttons, or any
        other controls which the dialog may need.

        The control takes whatever size its creator specifies and adjusts the
        dimensions of its components accordingly.  It divides itself into 8
        rows, each with equal height, and 25 columns, of which the first column
        contains a labeled quasibutton and so is wider than the remaining
        columns.  The first column sizes itself dynamically to accommodate the
        longest label in its set; the remaining columns divide the remaining
        horizontal space equally between them.

    HISTORY:
        beng        12-May-1992 Created

**********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnPaintReq()
{
    if (QueryError() != NERR_Success)
        return FALSE; // bail out!

    PAINT_DISPLAY_CONTEXT dc(this);

    if (   !DrawBackground(dc)
        || !DrawGridWires(dc)
        || !DrawAllButtons(dc)
        || !DrawGridSetting(dc) )
        return FALSE;

    if (_fFocusVisible)
        DrawFocusSomewhere(dc, _iWithFocus);

    DrawCurrentSelection(dc);

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnFocus

    SYNOPSIS:   Callback when the control receives focus

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnFocus( const FOCUS_EVENT & e )
{
    // Restore the control's subfocus

    _iWithFocus = _iFocusSave;

    // Draw the has-focus rectangle at the correct location

    DISPLAY_CONTEXT dc(this);
    DrawFocusSomewhere(dc, _iWithFocus);
    _fFocusVisible = TRUE;

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnDefocus

    SYNOPSIS:   Callback when the control loses focus

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnDefocus( const FOCUS_EVENT & e )
{
    // Erase the has-focus rectangle if it's present

    if (_fFocusVisible)
    {
        DISPLAY_CONTEXT dc(this);
        DrawFocusSomewhere(dc, _iWithFocus); // will XOR it out of existence
        _fFocusVisible = FALSE;
    }

    // Save away the subfocus, then mark the control as not having any

    _iFocusSave = _iWithFocus;
    _iWithFocus = 0;

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnKeyDown

    SYNOPSIS:   Callback when the control sees a key go down

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnKeyDown( const VKEY_EVENT & e )
{
    switch (e.QueryVKey())
    {
    case VK_LEFT:
        MoveFocusLeft();
        break;

    case VK_RIGHT:
        MoveFocusRight();
        break;

    case VK_UP:
        MoveFocusUp();
        break;

    case VK_DOWN:
        MoveFocusDown();
        break;

    case VK_SPACE:
        if (!_fSpaceIsDown)
        {
            _fSpaceIsDown = TRUE;
            DoButtonDownVisuals();
        }
        break;

    default:
        // Default case throws back to our distant ancestors
        return CUSTOM_CONTROL::OnKeyDown(e);
    }

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnKeyUp

    SYNOPSIS:   Callback when the control sees a key pop back up

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnKeyUp( const VKEY_EVENT & e )
{
    if (_fSpaceIsDown && e.QueryVKey() == VK_SPACE)
    {
        _fSpaceIsDown = FALSE;
        DoButtonUpVisuals();
        return TRUE;
    }

    return CUSTOM_CONTROL::OnKeyUp(e);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQDlgCode

    SYNOPSIS:   Callback defining the input a control expects from a dlg

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

ULONG LOGON_HOURS_CONTROL::OnQDlgCode()
{
    return (DLGC_WANTARROWS);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQHitTest

    SYNOPSIS:   Callback determining the subloc within a window

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

ULONG LOGON_HOURS_CONTROL::OnQHitTest( const XYPOINT & xy )
{
    XYPOINT xyTmp = xy;
    xyTmp.ScreenToClient( WINDOW::QueryHwnd() );

    return ( (UINT)xyTmp.QueryY() < Y_OFFSET ) ? HTNOWHERE : HTCLIENT;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQMouseActivate

    SYNOPSIS:   Callback determining whether a mouse awakens a control

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

ULONG LOGON_HOURS_CONTROL::OnQMouseActivate( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    ClaimFocus();
    return MA_ACTIVATE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQMouseCursor

    SYNOPSIS:   Callback determining whether mouse movement should
                change the cursor

    HISTORY:
        beng        28-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnQMouseCursor( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    CURSOR::Set(_hcurCross);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnLMouseButtonDown

    SYNOPSIS:   Callback on a mouse-down event

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnLMouseButtonDown( const MOUSE_EVENT & e )
{
    XYPOINT xy = e.QueryPos();

    if( (UINT)xy.QueryY() < Y_OFFSET )
        return CUSTOM_CONTROL::OnLMouseButtonDown(e); // punt

    CaptureMouse();
    _fMouseTrap = TRUE;

    INT iLoc = CalcButtonFromPoint(e.QueryPos());
    MoveFocusTo(iLoc);
    DoButtonDownVisuals();

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnLMouseButtonUp

    SYNOPSIS:   Callback on a mouse-up event

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnLMouseButtonUp( const MOUSE_EVENT & e )
{
    if (!_fMouseTrap)
        return CUSTOM_CONTROL::OnLMouseButtonUp(e); // punt

    _fMouseTrap = FALSE;
    ReleaseMouse();

    INT iLoc = CalcButtonFromPoint(e.QueryPos());
    DoButtonUpVisuals(iLoc == (INT)_iButtonDown);

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnMouseMove

    SYNOPSIS:   Callback on a mouse-move event

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnMouseMove( const MOUSE_EVENT & e )
{
    if (!_fMouseTrap || _iWithFocus == 0)
        return CUSTOM_CONTROL::OnMouseMove(e);

    INT iLoc = CalcButtonFromPoint(e.QueryPos());

    if (!IsButtonACell(_iWithFocus)) // button has focus
    {
        if (_iButtonDown != 0 && iLoc != (INT)_iButtonDown)
            DoButtonUpVisuals(FALSE);
        else if (_iButtonDown == 0 && iLoc == (INT)_iWithFocus)
            DoButtonDownVisuals();
    }
    else                             // cell has focus
    {
        if (IsButtonACell(iLoc))     // drag into another cell?
        {
            SetSelection(_iWithFocus-33, iLoc-33);
        }
    }

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::CalcButtonFromPoint

    SYNOPSIS:   Given a mouse loc, returns the assoc'd button

    ENTRY:      xy - mouse coords (client)

    RETURNS:    "cell index" (which may indicate either a button or
                a cell)

    NOTES:
        Called by OnLButton{Up,Down}, OnMouseMove

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

INT LOGON_HOURS_CONTROL::CalcButtonFromPoint( XYPOINT xy ) const
{
    // Range check.  0 = "nothing" for button indices.

    XYDIMENSION dxy = QuerySize();
    const INT x = xy.QueryX();
    const INT y = xy.QueryY();

    if (x < 0 || x >= (INT)dxy.QueryWidth())
        return 0;
    if (y < 0 || y >= (INT)dxy.QueryHeight())
        return 0;


    // From point, compute [i, j] of the absolute cell or button.
    // The upper lefthand edge belongs to the leftmost/uppermost
    // cell; each cell includes its lower/rightmost edge.

    INT j = (y < (INT)(DYGRIDWIRES + Y_OFFSET))
            ? 0
            : ((y - DYGRIDWIRES - Y_OFFSET) / (_dyRow + DYGRIDWIRES));

    INT i = (x < (INT)(_dxFirstColumn + 2*DXGRIDWIRES))
            ? 0
            : 1 + (x - 2*DXGRIDWIRES - _dxFirstColumn)
                   / (_dxColumn + DXGRIDWIRES);

    ASSERT(i >= 0 && i < 25);
    ASSERT(j >= 0 && j < 8);

    // Convert to button index.

    if (i == 0)      // either day or corner
    {
        if (j == 0)
            return 32;
        else
            return j;
    }
    else if (j == 0) // must be hour
    {
        return i+7;
    }
    else             // must be cell
    {
        return 8 + (j*24) + i;
    }
}


VOID LOGON_HOURS_CONTROL::DoButtonDownVisuals()
{
    if (_iWithFocus > 0 && _iWithFocus < 33)
    {
#if 0
        DISPLAY_CONTEXT dc(this);
        DrawFocusSomewhere(dc, _iWithFocus); // will XOR it out of existence
#endif

        _iButtonDown = _iWithFocus;
        InvalidateButton(_iButtonDown);
    }
    else if (_iWithFocus != 0)
    {
        ASSERT(_iWithFocus < 201);

        // Space-down in a cell:
        // Sets selection to the cell with focus, unless that cell
        // is the only one selected, in which case it deselects it.
        //

        const INT iCellFocus = _iWithFocus-33; // convert c/b index to c index

        if (   _fCellsSelected
            && (_iCellSelUpper == _iCellSelLower)
            && (iCellFocus == (INT)_iCellSelUpper))
        {
            DISPLAY_CONTEXT dc(this);
            EraseSelection(dc);
        }
        else
        {
            SetSelection(iCellFocus);
        }
    }
}


VOID LOGON_HOURS_CONTROL::DoButtonUpVisuals( BOOL fTrigger )
{
    if (_iButtonDown > 0 && _iButtonDown < 33)
    {
#if 0
        DISPLAY_CONTEXT dc(this);
        DrawFocusSomewhere(dc, _iWithFocus); // will XOR it out of existence
#endif

        UINT iButtonWasDown = _iButtonDown;
        _iButtonDown = 0;
        InvalidateButton(iButtonWasDown);
        if (fTrigger)
            DoButtonClick(iButtonWasDown);
    }
}


VOID LOGON_HOURS_CONTROL::DoButtonClick( INT iButton )
{
    ASSERT(iButton > 0 && iButton < 33);

    if (iButton < 8) // Day button
    {
        const INT iCellLower =  (iButton-1)*24; // note index conversion
        SetSelection( iCellLower, iCellLower+23 );
    }
    else if (iButton < 32) // Hour button
    {
        const INT iCellLower = iButton-8;       // again, different indices
        SetSelection( iCellLower, iCellLower + (6*24) );
    }
    else
    {
        SetSelection( 0, (7*24) - 1 );
    }
}


VOID LOGON_HOURS_CONTROL::InvalidateButton( INT iButtonOrCell )
{
    ASSERT( iButtonOrCell > 0 && iButtonOrCell < 201 );

    if (iButtonOrCell > 32)
    {
        XYRECT r;
        CalcRectForCell(&r, iButtonOrCell-33);
        Invalidate(r);
    }
    else if (iButtonOrCell < 8)
    {
        XYRECT r;
        CalcRectForDay(&r, iButtonOrCell-1);
        Invalidate(r);
    }
    else if (iButtonOrCell < 32)
    {
        XYRECT r;
        CalcRectForHour(&r, iButtonOrCell-8);
        Invalidate(r);
    }
    else
    {
        XYRECT r;
        CalcRectForCorner(&r);
        Invalidate(r);
    }
}


VOID LOGON_HOURS_CONTROL::SetSelectedCells( BOOL fPermit )
{
    ASSERT(_fCellsSelected);

    const INT cj = (_iCellSelUpper / 24) - (_iCellSelLower / 24) + 1;
    const INT ci = (_iCellSelUpper % 24) - (_iCellSelLower % 24) + 1;

    const INT iBase = _iCellSelLower;

    for (INT j = 0; j < cj; j++)
    {
        for (INT i = 0; i < ci; i++)
        {
            _abSetting[iBase+i+(24*j)] = (BYTE)fPermit;
        }
    }

    // Grid contents now need repainting.

    XYRECT r1, r2;

    CalcRectForCell(&r1, _iCellSelLower);
    CalcRectForCell(&r2, _iCellSelUpper);

    XYRECT rChanged;
    rChanged.CalcUnion(r1, r2);
    rChanged.AdjustLeft(-1);    // Move left over one so that the line
                                // between cells gets repainted
    Invalidate(rChanged);
}


VOID LOGON_HOURS_CONTROL::MoveFocusLeft()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;

    if (iCurrentFocus < 8 || iCurrentFocus == 32) // left margin
        Beep();
    else if (iCurrentFocus == 8) // leftmost hour button
        MoveFocusTo(32);         // go to corner button
    else if (iCurrentFocus > 32 && ((iCurrentFocus-32)%24) == 1) // leftmost
        MoveFocusTo( (iCurrentFocus-9)/24 ); // move into day buttons
    else
        MoveFocusTo(iCurrentFocus-1);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


VOID LOGON_HOURS_CONTROL::MoveFocusRight()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;


    if ((iCurrentFocus == 31) ||                // right margin
        (iCurrentFocus > 32 && ((iCurrentFocus-32)%24) == 0))
        Beep();
    else if (iCurrentFocus == 32)               // corner button
        MoveFocusTo(8);                         // go to first hour button
    else if (iCurrentFocus < 8)                 // left margin, day buttons
        MoveFocusTo(32 + (iCurrentFocus-1)*24 + 1); // go to first grid cell
    else                                        // top row button OR grid cell
        MoveFocusTo(iCurrentFocus+1);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


VOID LOGON_HOURS_CONTROL::MoveFocusUp()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;

    if (iCurrentFocus > 7 && iCurrentFocus < 33) // topmost, including corner
        Beep();
    else if (iCurrentFocus == 1) // topmost day button
        MoveFocusTo(32);         // go to corner button
    else if (iCurrentFocus < 8)  // other day buttons
        MoveFocusTo(iCurrentFocus-1);
    else if (iCurrentFocus < 57)       // topmost row of grid
        MoveFocusTo(iCurrentFocus-25); // go to hour button
    else
        MoveFocusTo(iCurrentFocus-24);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


VOID LOGON_HOURS_CONTROL::MoveFocusDown()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;

    if (iCurrentFocus > 176 || iCurrentFocus == 7) // lowest row of cells
        Beep();
    else if (iCurrentFocus == 32) // corner button
        MoveFocusTo(1);           // goto first day button
    else if (iCurrentFocus < 7)
        MoveFocusTo(iCurrentFocus+1);
    else if (iCurrentFocus < 32)       // hour buttons
        MoveFocusTo(iCurrentFocus+25); // goto topmost grid row
    else
        MoveFocusTo(iCurrentFocus+24);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


BOOL LOGON_HOURS_CONTROL::DrawBackground( PAINT_DISPLAY_CONTEXT &dc ) const
{
    HBRUSH hbrZap = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
    if (hbrZap == NULL)
        return FALSE;

    XYRECT rGrid;
    CalcGridRect(&rGrid);

    XYRECT rPaint;
    rPaint.CalcIntersect(rGrid, dc.QueryInvalidRect());

    ::FillRect(dc.QueryHdc(), (const RECT *)rPaint, hbrZap);

    ::DeleteObject( (HGDIOBJ)hbrZap);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawGridWires

    SYNOPSIS:   Paints the "wires" in the grid, along with the borders
                of the control and its buttons.

    ENTRY:      dc         - the OnPaint display context

    EXIT:       Button is drawn

    RETURNS:    FALSE if something in GDI went boom

    NOTES:
        This is a private member function.

    HISTORY:
        beng        14-May-1992 Created
        KeithMo     03-Nov-1992 Also draws hash marks.

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawGridWires( PAINT_DISPLAY_CONTEXT &dc ) const
{
    ASSERT(DXGRIDWIRES == DYGRIDWIRES); // Laziness - lets me use same
                                        // pen vertically and horizontally

    HPEN hpenMain = ::CreatePen(PS_SOLID, DXGRIDWIRES,
                                ::GetSysColor(COLOR_BTNTEXT));
    if (hpenMain == NULL)
        return FALSE;
    HPEN hpenGrid = ::CreatePen(PS_SOLID, DXGRIDWIRES,
                                ::GetSysColor(COLOR_GRAYTEXT));
    if (hpenGrid == NULL)
    {
        ::DeleteObject((HGDIOBJ)hpenMain);
        return FALSE;
    }
    HPEN hpenBar = ::CreatePen(PS_SOLID, DXGRIDWIRES,
                                ::GetSysColor(COLOR_BTNSHADOW));
    if (hpenBar == NULL)
    {
        ::DeleteObject((HGDIOBJ)hpenGrid);
        ::DeleteObject((HGDIOBJ)hpenMain);
        return FALSE;
    }

    HPEN hpenOld = dc.SelectPen(hpenMain);

    // Draw outermost lines, plus button/grid edges
    // (Following sequence optimizes out some adds where I know
    // that one addend is zero.)

    XYDIMENSION dxyTotal = QuerySize();

    INT x = 0;
    INT y = Y_OFFSET;
    dc.MoveTo(x, y);
    x = (INT) dxyTotal.QueryWidth()-1;
    dc.LineTo(x, y);
    y = (INT) dxyTotal.QueryHeight()-1;
    dc.LineTo(x, y);
    x = 0;
    dc.LineTo(x, y);
    y = Y_OFFSET;
    dc.LineTo(x, y);
    y = (INT) _dyRow + DYGRIDWIRES + Y_OFFSET;
    dc.MoveTo(x, y);
    x = (INT) dxyTotal.QueryWidth()-1;
    dc.LineTo(x, y);
    x = (INT) _dxFirstColumn+DXGRIDWIRES;
    y = Y_OFFSET;
    dc.MoveTo(x, y);
    y = (INT) dxyTotal.QueryHeight()-1;
    dc.LineTo(x, y);

    // Draw rest of button separators, along with the grid separators.
    // REVIEW: by doubling loop could save overhead of switching pens
    // back and forth.  Worth the bloat?

    const INT xMainOrigin = 0;
    const INT xMainEndPt = (INT) _dxFirstColumn + DXGRIDWIRES;
    const INT xGreyOrigin = (INT) _dxFirstColumn + 2*DXGRIDWIRES;
    const INT xGreyEndPt = (INT) dxyTotal.QueryWidth() - DXGRIDWIRES;

    INT i;
    for (i = 2, y = 2*_dyRow + 2*DYGRIDWIRES + Y_OFFSET; i < 8;
         i++, y += _dyRow + DYGRIDWIRES)
    {
        dc.SelectPen(hpenMain);
        dc.MoveTo(xMainOrigin, y);
        dc.LineTo(xMainEndPt, y);

        dc.SelectPen(hpenGrid);
        dc.MoveTo(xGreyOrigin, y);
        dc.LineTo(xGreyEndPt, y);
    }

    const INT yMainOrigin = Y_OFFSET;
    const INT yMainEndPt = (INT) _dyRow + DYGRIDWIRES + Y_OFFSET;
    const INT yGreyOrigin = (INT) _dyRow + 2*DYGRIDWIRES + Y_OFFSET;
    const INT yGreyEndPt = (INT) dxyTotal.QueryHeight() - DYGRIDWIRES;

    for (i = 2, x = _dxFirstColumn + _dxColumn + 2*DXGRIDWIRES; i < 25;
         i++, x += _dxColumn + DXGRIDWIRES)
    {
        dc.SelectPen(hpenMain);
        dc.MoveTo(x, yMainOrigin);
        dc.LineTo(x, yMainEndPt);

        if( ( i == 7 ) || ( i == 13 ) || ( i == 19 ) )
            dc.SelectPen(hpenBar);
        else
            dc.SelectPen(hpenGrid);

        dc.MoveTo(x, yGreyOrigin);
        dc.LineTo(x, yGreyEndPt);
    }

    //
    //  Draw the hash marks.  The marks at noon & both midnights
    //  are _dyRow units high.  The marks at 6am & 6pm are 2*_dyRow/3
    //  units high.  The marks at other two-hour intervals are
    //  _dyRow/3 units high.  There is a one pixel whitespace border
    //  between the bottom of the hash marks and the top of the
    //  actual grid.
    //

    const INT yLargeOrigin  = 0;
    const INT yMediumOrigin = _dyRow/3;
    const INT ySmallOrigin  = 2*_dyRow/3;
    const INT yHashEndPt    = _dyRow + DYGRIDWIRES - 1;

    dc.SelectPen(hpenMain);

    for( i = 1, x = _dxFirstColumn + DXGRIDWIRES ;
         i <= 25 ;
         i += 2, x += 2*_dxColumn + 2*DXGRIDWIRES )
    {
        INT yHashOrigin;

        if( ( i == 1 ) || ( i == 13 ) || ( i == 25 ) )
            yHashOrigin = yLargeOrigin;
        else
        if( ( i == 7 ) || ( i == 19 ) )
            yHashOrigin = yMediumOrigin;
        else
            yHashOrigin = ySmallOrigin;

        dc.MoveTo( x, yHashOrigin );
        dc.LineTo( x, yHashEndPt );
    }

    dc.SelectPen(hpenOld);
    ::DeleteObject( (HGDIOBJ)hpenBar );
    ::DeleteObject( (HGDIOBJ)hpenGrid );
    ::DeleteObject( (HGDIOBJ)hpenMain );
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::QueryXForRow

    SYNOPSIS:   Returns the X-position in pixels for a row separator

    ENTRY:      1 <= iRow <= 25, 1 for left midnight, 13 for noon,
                25 for right mignight

    RETURNS:    X-location relative to control position, in pixels

    NOTES:      This is a public member function.

    HISTORY:
        jonn        29-Jan-1993 Created

********************************************************************/

UINT LOGON_HOURS_CONTROL::QueryXForRow( INT nRow )
{
    ASSERT( 1 <= nRow && nRow <= 25 );

    return (_dxFirstColumn - _dxColumn) + (nRow * (_dxColumn + DXGRIDWIRES));
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawAllButtons

    SYNOPSIS:   Paints the rows of buttons along the top and left edges.
                (Excel style)

    ENTRY:      dc         - the OnPaint display context

    EXIT:       Button is drawn

    RETURNS:    FALSE if something in GDI went boom

    NOTES:
        This is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawAllButtons( PAINT_DISPLAY_CONTEXT &dc ) const
{
    // For the face - get these once for every button

    HBRUSH hbrFace = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
    if (hbrFace == NULL)
        return FALSE;
    HPEN hpenShadow= ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW));
    if (hpenShadow == NULL)
    {
        ::DeleteObject((HGDIOBJ)hbrFace);
        return FALSE;
    }
    HPEN hpenHlight= ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT));
    if (hpenHlight == NULL)
    {
        ::DeleteObject((HGDIOBJ)hpenShadow);
        ::DeleteObject((HGDIOBJ)hbrFace);
        return FALSE;
    }

    // Draw the buttons in the left-hand column (All and Days).

    {
        XYRECT r(XYPOINT(DXGRIDWIRES, DYGRIDWIRES + Y_OFFSET),
                 XYDIMENSION(_dxFirstColumn-1, _dyRow-1));

        DrawOneCornerButton(dc, r, (_iButtonDown == 32),
                            hbrFace, hpenShadow, hpenHlight);


        // I would think this was already selected - but apparently not.
        // N.b. no need for save/restore here....
        dc.SelectFont(QueryFont());

        XYRECT rScratch;
        for (INT i = 1; i < 8; i++)
        {
            BOOL fDown = ((INT)_iButtonDown == i);
            r.Offset(0, _dyRow+DYGRIDWIRES);
            rScratch.CalcIntersect(r, dc.QueryInvalidRect());
            if (rScratch.IsEmpty())
                continue;

            DrawOneFlatButton(dc, r, fDown, hbrFace, hpenShadow, hpenHlight);
            COLORREF crOldBack = dc.SetBkColor(::GetSysColor(COLOR_BTNFACE));
            COLORREF crOldText = dc.SetTextColor(::GetSysColor(COLOR_BTNTEXT));
            r.AdjustLeft(_dxLabelFudge);
            if (fDown)
                r.Offset(1, 1);
            dc.DrawText(*_apnlsDayOfWeek[i-1], (RECT*)(const RECT *)r,
                        DT_LEFT|DT_VCENTER|DT_NOPREFIX|DT_SINGLELINE);
            if (fDown)
                r.Offset(-1, -1);
            r.AdjustLeft(-_dxLabelFudge);
            dc.SetBkColor(crOldBack);
            dc.SetTextColor(crOldText);
        }
    }

    // Draw the buttons in the topmost row (Hours).

    {
        XYRECT r2(XYPOINT(2*DXGRIDWIRES+_dxFirstColumn, DYGRIDWIRES + Y_OFFSET),
                  XYDIMENSION(_dxColumn-1, _dyRow-1));

        XYRECT rScratch;
        for (INT i = 8; i < 32;
             i++, r2.Offset(_dxColumn+DXGRIDWIRES, 0))
        {
            rScratch.CalcIntersect(r2, dc.QueryInvalidRect());
            if (rScratch.IsEmpty())
                continue;
            DrawOneFlatButton(dc, r2, ((INT)_iButtonDown == i),
                              hbrFace, hpenShadow, hpenHlight);
        }
    }

    ::DeleteObject((HGDIOBJ)hpenHlight);
    ::DeleteObject((HGDIOBJ)hpenShadow);
    ::DeleteObject((HGDIOBJ)hbrFace);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawOneCornerButton

    SYNOPSIS:   Paints a single high corner "select all" point
                (Excel style)

    ENTRY:      dc         - the OnPaint display context
                r          - rectangle of button position
                fDown      - TRUE if button is in mid-click
                hbrFace    - brush with which to paint button face
                hpenShadow - pen with which to draw button shadows
                hpenHlight - pen with which to draw button highlights

    EXIT:       Button is drawn

    NOTES:
        This is a private member function.

        The function doesn't draw any focus rect on the button.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawOneCornerButton(
    PAINT_DISPLAY_CONTEXT &dc,
    const XYRECT &r, BOOL fDown,
    HBRUSH hbrFace, HPEN hpenShadow, HPEN hpenHlight) const
{
    // Draw the face of the button.  (Caller will draw any text.)

    ::FillRect(dc.QueryHdc(), (const RECT *)r, hbrFace);

    // Draw the 3D FX (shadowing).

    HPEN hpenSave = dc.SelectPen(hpenShadow);
    if (fDown)
    {
        dc.MoveTo(r.QueryLeft(),  r.QueryBottom()-1);
        dc.LineTo(r.QueryLeft(),  r.QueryTop());
        dc.LineTo(r.QueryRight(), r.QueryTop());
    }
    else
    {
        dc.MoveTo(r.QueryRight(),   r.QueryTop());
        dc.LineTo(r.QueryRight(),   r.QueryBottom());
        dc.LineTo(r.QueryLeft(),    r.QueryBottom());
        dc.MoveTo(r.QueryRight()-1, r.QueryTop()+1);
        dc.LineTo(r.QueryRight()-1, r.QueryBottom()-1);
        dc.LineTo(r.QueryLeft()+1,  r.QueryBottom()-1);

        dc.SelectPen(hpenHlight); // Highlight above

        dc.MoveTo(r.QueryLeft(),    r.QueryBottom());
        dc.LineTo(r.QueryLeft(),    r.QueryTop());
        dc.LineTo(r.QueryRight(),   r.QueryTop());
        dc.MoveTo(r.QueryLeft()+1,  r.QueryBottom()-1);
        dc.LineTo(r.QueryLeft()+1,  r.QueryTop()+1);
        dc.LineTo(r.QueryRight()-1, r.QueryTop()+1);
    }

    dc.SelectPen(hpenSave);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawOneFlatButton

    SYNOPSIS:   Paints a single flat row/column header

    ENTRY:      dc         - the OnPaint display context
                r          - rectangle of button position
                fDown      - TRUE if button is in mid-click
                hbrFace    - brush with which to paint button face
                hpenShadow - pen with which to draw button shadows
                hpenHlight - pen with which to draw button highlights

    EXIT:       Button is drawn

    NOTES:
        This is a private member function.

        The function doesn't draw any text or focus rect on the button.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawOneFlatButton(
    PAINT_DISPLAY_CONTEXT &dc,
    const XYRECT &r, BOOL fDown,
    HBRUSH hbrFace, HPEN hpenShadow, HPEN hpenHlight) const
{
    // Draw the face of the button.  (Caller will draw any text.)
    // We have to stretch a copy of the rect to get the last bit colored;
    // this is still faster than getting another pen and drawing more lines.

    {
        XYRECT rPrime = r;
        rPrime.AdjustRight(1);
        rPrime.AdjustBottom(1);
        ::FillRect(dc.QueryHdc(), (const RECT *)rPrime, hbrFace);
    }

    // Draw the minimal 3D FX for these Excel-style flat buttons.

    HPEN hpenSave = dc.SelectPen( fDown ? hpenShadow : hpenHlight );

    dc.MoveTo(r.QueryLeft(),  r.QueryBottom());
    dc.LineTo(r.QueryLeft(),  r.QueryTop());
    dc.LineTo(r.QueryRight(), r.QueryTop());

    dc.SelectPen(hpenSave);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawGridSetting

    SYNOPSIS:   Paints all the bars in the grid of permitted hours

    ENTRY:      dc       - the OnPaint display context

    EXIT:       Bars are painted

    NOTES:
        THis is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawGridSetting( PAINT_DISPLAY_CONTEXT &dc ) const
{
    XYRECT rGrid;
    CalcGridRect(&rGrid);

    XYRECT rIntersect;
    rIntersect.CalcIntersect(rGrid, dc.QueryInvalidRect());

    if (rIntersect.IsEmpty()) // None of the grid needs painting
        return TRUE;

    // Otherwise, paint the whole ding dang thing.
    // CODEWORK: paint only what is necessary.  Will require integrating
    // some of the grid-wire-paint code here.  Worth it?  Prolly not.

    // CODEWORK - what if background is blue?  need to check

    HBRUSH hbrBar = ::CreateSolidBrush( RGB(0, 0, 255) );
    if (hbrBar == NULL)
        return FALSE;

    // ibSetting optimizes away the array indexing math
    INT ibSetting = 0;

    for (INT i = 0; i < 7; i++)
    {
        BOOL fCarrying = FALSE;
        INT  jStart = 0;

        for (INT j = 0; j < 24; j++)
        {
            ASSERT(24*i+j == ibSetting);

            if (fCarrying != _abSetting[ibSetting++])
            {
                fCarrying = !fCarrying;

                if (!fCarrying)
                {
                    // Time to draw the line we'd been carrying
                    if (!DrawOneDayBar(dc, i, jStart, j-1, hbrBar))
                    {
                        ::DeleteObject((HGDIOBJ)hbrBar);
                        return FALSE;
                    }
                }
                else
                {
                    // Mark this point as the beginning of a line
                    jStart = j;
                }
            }
        }

        if (fCarrying) // Still carrying? Paint the bar to the end
        {
            if (!DrawOneDayBar(dc, i, jStart, 23, hbrBar))
            {
                ::DeleteObject((HGDIOBJ)hbrBar);
                return FALSE;
            }
        }
    }

    ::DeleteObject((HGDIOBJ)hbrBar);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawOneDayBar

    SYNOPSIS:   Paints a bar representing a range of permitted times

    ENTRY:      dc       - the OnPaint display context
                iRow     - index of row
                iColHead - index of first column of bar
                iColTail - index of last column of bar
                hbrBar   - brush with which to paint bar

    EXIT:       Bar is painted

    NOTES:
        This is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawOneDayBar( PAINT_DISPLAY_CONTEXT & dc,
                                         INT iRow, INT iColHead,
                                         INT iColTail, HBRUSH hbrBar ) const
{
    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (iColHead * (DXGRIDWIRES + _dxColumn));
    const INT xEnd = xStart-1 + (1+iColTail-iColHead) * (DXGRIDWIRES+_dxColumn);

    // Buttons at the top are the same size as grid cells -
    // hence the 1+iRow below.

    const INT yStart = (1+iRow) * (DYGRIDWIRES+_dyRow)
                       + DYGRIDWIRES + _dyRow/4 + 1 + Y_OFFSET;
    const INT yEnd = yStart + _dyRow/2 - 1;

    XYRECT r(xStart, yStart, xEnd, yEnd);

    if (!::FillRect(dc.QueryHdc(), (const RECT *)r, hbrBar))
        return FALSE;

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnCell

    SYNOPSIS:   Draws or undraws the focus rectangle on a grid cell

    ENTRY:      dc    - the OnPaint display contect
                iCell - 0-base cell index in the sequence

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnCell( const DISPLAY_CONTEXT &dc,
                                           INT iCell ) const
{
    // Convert cell index to [i, j] row/col indices

    const INT i = iCell%24;
    const INT j = iCell/24;

    // Convert [i, j] row indices to (x, y, x', y') coordinates

    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (i * (DXGRIDWIRES+_dxColumn));
    const INT xEnd = xStart + _dxColumn;

    // Buttons at the top are the same size as grid cells -
    // hence the 1+j below.

    const INT yStart = (1+j) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd = yStart + _dyRow;

    // Build a slightly diminished rectangle from the coords

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::SetSelection( INT iCell )
{
    SetSelection(iCell, iCell);
}


VOID LOGON_HOURS_CONTROL::SetSelection( INT iFrom, INT iTo )
{
    // Normalize implicit rectangle so that, for (x, y) and (x', y'),
    // x' > x and y' > y

    INT iLower = iFrom % 24;
    INT jLower = iFrom / 24;
    INT iUpper = iTo % 24;
    INT jUpper = iTo / 24;

    if (iLower > iUpper)
    {
        INT iTmp = iLower;
        iLower = iUpper;
        iUpper = iTmp;
    }

    if (jLower > jUpper)
    {
        INT jTmp = jLower;
        jLower = jUpper;
        jUpper = jTmp;
    }

    const INT iCellSelLower = iLower + (24*jLower);
    const INT iCellSelUpper = iUpper + (24*jUpper);

    // Avoid the flickering effect: skip erase-redraw cycles
    // that won't change the rectangle.
    //
    // JonN 7/31/95:  Added _fCellsSelected term, otherwise cell 0 is not
    // updated properly

    if (   _fCellsSelected
        && iCellSelLower == (INT)_iCellSelLower
        && iCellSelUpper == (INT)_iCellSelUpper )
    {
        return;
    }

    DISPLAY_CONTEXT dc(this);

    EraseSelection(dc);

    _fCellsSelected = TRUE;

    _iCellSelLower = iCellSelLower;
    _iCellSelUpper = iCellSelUpper;

    DrawCurrentSelection(dc);
}


VOID LOGON_HOURS_CONTROL::DrawCurrentSelection( const DISPLAY_CONTEXT &dc ) const
{
    if (_fCellsSelected)
    {
        if (_iCellSelUpper == _iCellSelLower)
            DrawSelectionOnCell(dc, _iCellSelUpper);
        else
            DrawSelectionOnCells(dc, _iCellSelLower, _iCellSelUpper);
    }
}


VOID LOGON_HOURS_CONTROL::EraseSelection( const DISPLAY_CONTEXT &dc )
{
    if (_fCellsSelected)
        DrawCurrentSelection(dc); // XOR it away
    _fCellsSelected = FALSE;
    _iCellSelUpper = _iCellSelLower = 0;
}


VOID LOGON_HOURS_CONTROL::DrawSelectionOnCell( const DISPLAY_CONTEXT &dc,
                                               INT iCell ) const
{
    XYRECT r;
    CalcRectForCell(&r, iCell);

    dc.InvertRect(r);
}


VOID LOGON_HOURS_CONTROL::DrawSelectionOnCells( const DISPLAY_CONTEXT &dc,
                                                INT iFrom, INT iTo ) const
{
    ASSERT(iFrom <= iTo);

    XYRECT r1, r2;

    CalcRectForCell(&r1, iFrom);
    CalcRectForCell(&r2, iTo);

    XYRECT r;
    r.CalcUnion(r1, r2);

    dc.InvertRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForCell( XYRECT * pr, INT iCell ) const
{
    // Convert cell index to [i, j] row/col indices

    const INT i = iCell%24;
    const INT j = iCell/24;

    // Convert [i, j] row indices to (x, y, x', y') coordinates

    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (i * (DXGRIDWIRES+_dxColumn));
    const INT xEnd = xStart + _dxColumn;

    // Buttons at the top are the same size as grid cells -
    // hence the 1+j below.

    const INT yStart = (1+j) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnDayButton

    SYNOPSIS:   Draws or undraws the focus rectangle on a day button
                (up the left-hand-side of the control)

    ENTRY:      dc    - the OnPaint display contect
                iCell - 0-base button index in the sequence, counting
                        from the top down

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnDayButton( const DISPLAY_CONTEXT &dc,
                                                INT iDay ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT xEnd   = xStart + _dxFirstColumn;

    // 1+iDay takes the Corner button (same size as day button) into account

    const INT yStart = (1+iDay) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    // Build a slightly diminished rectangle from the coords

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForDay( XYRECT *pr, INT iDay ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT xEnd   = xStart + _dxFirstColumn;

    // 1+iDay takes the Corner button (same size as day button) into account

    const INT yStart = (1+iDay) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnHourButton

    SYNOPSIS:   Draws or undraws the focus rectangle on an hour button
                (across the top of the control)

    ENTRY:      dc    - the OnPaint display contect
                iHour - 0-base button index in the sequence, counting
                        from left to right

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnHourButton( const DISPLAY_CONTEXT &dc,
                                                 INT iHour ) const
{
    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (iHour * (DXGRIDWIRES+_dxColumn));
    const INT xEnd   = xStart + _dxColumn;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    // Build a slightly diminished rectangle from the coords

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForHour( XYRECT *pr, INT iHour ) const
{
    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (iHour * (DXGRIDWIRES+_dxColumn));
    const INT xEnd   = xStart + _dxColumn;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnCornerButton

    SYNOPSIS:   Draws or undraws the focus rectangle on the corner button
                (upper left corner, denoting Select All)

    ENTRY:      dc    - the OnPaint display contect

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnCornerButton(
    const DISPLAY_CONTEXT &dc ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT xEnd   = xStart + _dxFirstColumn;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForCorner( XYRECT * pr ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT xEnd   = xStart + _dxFirstColumn;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusSomewhere

    SYNOPSIS:   Determines where to draw focus, then dispatches

    ENTRY:      dc    - the OnPaint display contect
                iFocus- the focus index (uses same scheme as _iWithFocus)

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusSomewhere( const DISPLAY_CONTEXT &dc,
                                              INT iFocus ) const
{
    if (iFocus == 0 || iFocus > 200)
        return;
    else if (iFocus > 32)
        DrawFocusOnCell(dc, iFocus-33);
    else if (iFocus < 8)
        DrawFocusOnDayButton(dc, iFocus-1);
    else if (iFocus < 32)
        DrawFocusOnHourButton(dc, iFocus-8);
    else
        DrawFocusOnCornerButton(dc);
}


VOID LOGON_HOURS_CONTROL::MoveFocusTo( INT iGetsFocus )
{
    DISPLAY_CONTEXT dc(this);

    if (_fFocusVisible)
        DrawFocusSomewhere(dc, _iWithFocus); // OUT with the old focus...

    _iWithFocus = iGetsFocus;
    DrawFocusSomewhere(dc, _iWithFocus); // IN with the new focus!
    _fFocusVisible = TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::CalcGridRect

    SYNOPSIS:   Calcs the rectangle occupied by the grid

    ENTRY:      prDest - points to destination XYRECT

    EXIT:       *prDest is set

    NOTES:
        THis is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::CalcGridRect( XYRECT * prDest ) const
{
    XYDIMENSION dxyTotal = QuerySize();

    const INT xOrigin = (INT) _dxFirstColumn + 2*DXGRIDWIRES;
    const INT yOrigin = (INT) _dyRow + 2*DYGRIDWIRES + Y_OFFSET;
    const INT xEndPt = (INT) dxyTotal.QueryWidth() - DXGRIDWIRES;
    const INT yEndPt = (INT) dxyTotal.QueryHeight() - DYGRIDWIRES;

    *prDest = XYRECT(xOrigin, yOrigin, xEndPt, yEndPt);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::CalcSizes

    SYNOPSIS:   Calculates relative sizes within control

    ENTRY:      dxy - the total dimensions of the control

    EXIT:       Sets some members of the class: _dyRow, _dxFirstColumn,
                _dxColumn,  Resizes control so that an integral number
                of cells fit within it.

    RETURNS:    NERR_Success if control has enough real estate to work.
                Some other error code if not.

    NOTES:
        This is a private member function.
        Assumes that labels have already been loaded.

    HISTORY:
        beng        12-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::CalcSizes( XYDIMENSION dxy )
{
    // All the sanity checks below just keep the math legal.  A control
    // can pass them and still be unusable, depending on the font sel'd
    // etc.

    // Row height is easy: take the total height, subtract the space used
    // by the grid wires, and divide the remainder evenly between each row.

    if (dxy.QueryHeight() < (10*DYGRIDWIRES + (3*9)))
    {
        ASSERT(FALSE); // Each row needs height >= 3
        return ERROR_INVALID_PARAMETER; // The dxy parameter, that is
    }

    _dyRow = (dxy.QueryHeight() - 10*(DYGRIDWIRES)) / 9;


    // Column 1 width: enough to accommodate the longest label (day of
    // week), plus padding.

    {
        DISPLAY_CONTEXT dc(this);

        // I would think this was already selected - but apparently not.
        // N.b. no need for save/restore here....
        dc.SelectFont(QueryFont());

        _dxLabelFudge = dc.QueryAveCharWidth();

        UINT dxInsane = dxy.QueryWidth()/4 - 2*_dxLabelFudge;
        UINT dxMax = 0;
        INT i = 0;
        while (i < 7)
        {
            ASSERT(_apnlsDayOfWeek[i] != NULL);
            UINT dx = dc.QueryTextWidth(*_apnlsDayOfWeek[i++]);
            if (dx < dxInsane && dx > dxMax)
                dxMax = dx;
        }

        if (dxMax == 0)
        {
            // REVIEW: Perhaps should try the abbrev day strings instead?
            // Or perhaps should sub them in as needed for the too-long
            // days, one at a time.

            ASSERT(FALSE); // Every label was longer than 25% of the control
            return ERROR_INVALID_PARAMETER;
        }

        _dxFirstColumn = dxMax + 2*_dxLabelFudge;
    }


    // Each remaining column gets an equal part of the leftovers
    // after gridwire overhead.

    {
        UINT dxRemaining = dxy.QueryWidth() - _dxFirstColumn;

        if (dxRemaining < (26*DXGRIDWIRES + 3*24))
        {
            ASSERT(FALSE); // Each lesser col needs width >= 3
            return ERROR_INVALID_PARAMETER;
        }

        _dxColumn = (dxRemaining - 26*DXGRIDWIRES) / 24;
    }

    // Now that the control knows the dimensions of its components,
    // let it resize itself to remove "dead space."

    SetSize(_dxFirstColumn + 24*_dxColumn + 26*DXGRIDWIRES,
            9*_dyRow + 10*DYGRIDWIRES,
            FALSE);

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::LoadLabels

    SYNOPSIS:   Load the strings for the button labels

    ENTRY:      Object is incompletely constructed

    EXIT:

    RETURNS:
        Error code if couldn't load strings.  NERR_Success otherwise.

    NOTES:
        This is a private member function.

        This function assumes that no previous strings have been loaded;
        do not call it more than once per object.

        Assumes that all strings are contiguous, following Sunday.
        Assumes seven days per week (gasp!).

    HISTORY:
        beng        12-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::LoadLabels( MSGID idDay0 )
{
    INT i = 0;

    while (i < 7)
        _apnlsDayOfWeek[i++] = NULL;

    APIERR err = NERR_Success;
    for (i = 0; i < 7 && err == NERR_Success; i++)
    {
        if ((_apnlsDayOfWeek[i] = new RESOURCE_STR(idDay0 + i)) == NULL)
            err = ERROR_NOT_ENOUGH_MEMORY;
        else
            err = _apnlsDayOfWeek[i]->QueryError();
    }

    return err;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::UnloadLabels

    SYNOPSIS:   Unrolls LoadLabels

    ENTRY:      Object has some (perhaps all) labels loaded

    EXIT:       They're been freed

    NOTES:
        This is a private member function.

    HISTORY:
        beng        12-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::UnloadLabels()
{
    INT i = 0;

    while (i < 7)
    {
        delete _apnlsDayOfWeek[i];
        _apnlsDayOfWeek[i++] = NULL; // play it safe
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltsb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsb.cxx
    Source file for the BLT spin button object

    FILE HISTORY:
        terryk      15-Apr-1991 created
        terryk      20-Jun-1991 code review changed. Attend: beng
        terryk      05-Jul-1991 second code review changed. Attend:
                                beng chuckc rustanl annmc terryk
        terryk      19-Jul-1991 Change the bitmap parameter from ULONG
                                to TCHAR *
        terryk      27-Sep-1991 solve spin group restore bug
        terryk      07-Oct-1991 Add update
        terryk      17-APr-1992 Created the up and down arrow during
                                construction time

*/

#include "pchblt.hxx"  // Precompiled header


// BUGBUG:
// DEFINE_DLIST_OF(SPIN_ITEM);


/*********************************************************************

    NAME:       DownArrowLocation

    SYNOPSIS:   Given the current XY position and the dimension of
                the control, this function will return the xy
                location of the down arrow within the SPIN_GROUP .

    ENTRY:      XYPOINT xy - the xy position of the SPIN_GROUP
                XYDIMENSION dxy - the total dimension of the SPIN_GROUP

    RETURN_VALUE:   The starting position of the down arrow in the SPIN_GROUP

    HISTORY:
        terryk      22-May-91   Created
        beng        04-Aug-1992 Made local and inline

*********************************************************************/

static inline XYPOINT DownArrowLocation( XYPOINT xy, XYDIMENSION dxy )
{
    return XYPOINT( xy.QueryX(), xy.QueryY() + dxy.QueryHeight() / 2 );
}


/*********************************************************************

    NAME:       HalfSpinDimension

    SYNOPSIS:   Given the total dimension of the SPIN_GROUP , it will
                return the dimension of the arrow button within the
                SPIN_GROUP .

    ENTRY:      XYDIMENSION dxy - the SPIN_GROUP  dimension.

    RETURN_VALUE:   the dimension of a arrow button within the SPIN_GROUP

    HISTORY:
        terryk      22-May-91   Created
        beng        04-Aug-1992 Made local and inline

*********************************************************************/

static inline XYDIMENSION HalfSpinDimension( XYDIMENSION dxy )
{
    return XYDIMENSION( dxy.QueryWidth(), dxy.QueryHeight() / 2 );
}


/**********************************************************************

    NAME:       SPIN_GROUP::SPIN_GROUP

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - owner window handler
                CID cidSpinButton    - cid for the SPIN BUTTON control
                CID cidUpArrow       - cid for the up arrow control
                CID cidDownArrow     - cid for the down arrow control
                BOOL fActive         - Initial state of the SPIN_GROUP.
                                       Assume that it is inactive

                Parameter for the apps window
                XYPOINT xy      - xy position of the custom control
                XYDIMENSION dxy - xy dimension of the custom control
                ULONG flStyle   - style of the custom control
                TCHAR * pszClassName - if it is undefined, it will be
                                      "button".

    HISTORY:
        terryk      22-May-91   Created
        beng        05-Oct-1991 Win32 conversion
        terryk      17-Apr-1992 use the resource file's up and down arrows
        beng        04-Aug-1992 Bitmap ids now ordinals, and fixed

**********************************************************************/

SPIN_GROUP::SPIN_GROUP( OWNER_WINDOW *powin, CID cidSpinButton,
                        CID cidUpArrow, CID cidDownArrow, BOOL fActive )
    : CONTROL_GROUP(),
    _SpinButton( powin, cidSpinButton ),
    _dlsiControl( FALSE ),
    _arrowUp( powin, cidUpArrow, BMID_UP, BMID_UP_INV, BMID_UP_DIS ),
    _arrowDown( powin, cidDownArrow, BMID_DOWN, BMID_DOWN_INV, BMID_DOWN_DIS ),
    _fModified ( FALSE ),
    _psiCurrentField( NULL ),
    _psiFirstField( NULL ),
    _psiLastField( NULL ),
    _fActive( fActive )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    _arrowUp.SetPos(_SpinButton.QueryPos());
    _arrowUp.SetSize( HalfSpinDimension( _SpinButton.QuerySize() ));
    _arrowDown.SetPos( DownArrowLocation( _SpinButton.QueryPos(), _SpinButton.QuerySize()));
    _arrowDown.SetSize( HalfSpinDimension( _SpinButton.QuerySize() ));

    _arrowUp.SetGroup( (CONTROL_GROUP *)this );
    _arrowDown.SetGroup( (CONTROL_GROUP * )this );

    _arrowUp.Show();
    _arrowDown.Show();
}

SPIN_GROUP::SPIN_GROUP( OWNER_WINDOW *powin, CID cidSpinButton,
                        CID cidUpArrow, CID cidDownArrow,
                        XYPOINT xy, XYDIMENSION dxy, ULONG flStyle,
                        BOOL fActive )
    : CONTROL_GROUP(),
    _SpinButton( powin, cidSpinButton, xy, dxy, flStyle ),
    _dlsiControl( FALSE ),
    _arrowUp( powin, cidUpArrow,
              BMID_UP, BMID_UP_INV, BMID_UP_DIS,
              xy, HalfSpinDimension( dxy ),
              BS_OWNERDRAW|WS_BORDER|WS_CHILD|WS_GROUP ),
    _arrowDown( powin, cidDownArrow,
                BMID_DOWN, BMID_DOWN_INV, BMID_DOWN_DIS,
                DownArrowLocation( xy, dxy ), HalfSpinDimension( dxy ),
                BS_OWNERDRAW|WS_BORDER|WS_CHILD ),
    _fModified( FALSE ),
    _psiCurrentField( NULL ),
    _psiFirstField( NULL ),
    _psiLastField( NULL ),
    _fActive( fActive )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    _arrowUp.SetGroup( (CONTROL_GROUP *)this );
    _arrowDown.SetGroup( (CONTROL_GROUP * )this );

    _arrowUp.Show();
    _arrowDown.Show();

}


/*********************************************************************

    NAME:       SPIN_GROUP::~SPIN_GROUP

    SYNOPSIS:   destructor - clear up all the internal variables

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

SPIN_GROUP::~SPIN_GROUP()
{
    // let the private variable's destructors do the job
}


/*********************************************************************

    NAME:       SPIN_GROUP::DoChar

    SYNOPSIS:   Character handler

    ENTRY:      CHAR_EVENT & event - the TCHAR message

    BOOL:       return TRUE if one of the control item use the character
                FALSE otherwise

    NOTES:      When it receives the WM_CHAR message, it will
                ask each of the control in the list. If one
                of the control wants to handle the character,
                let it has the character. Otherwise, Beeps the user.

    HISTORY:
                terryk  22-May-91   Created
                terryk  20-Jun-91   Changed sendmessage to OnXXX.

*********************************************************************/

BOOL SPIN_GROUP::DoChar( const CHAR_EVENT & event )
{
    // if the valid is invalid then skip it and don't do anything
    if ( !QueryCurrentField()->IsStatic() && !IsValidField() )
    {
        SetArrowButtonStatus();
        return TRUE;
    }

    SPIN_ITEM *psiOldItem = QueryCurrentField();
    SPIN_ITEM *psiCurrent;
    ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );

    while (( psiCurrent = itersi.Next() )!= NULL )
    {
        // find the current item
        if ( psiCurrent == QueryCurrentField() )
            break;
    }

    UIASSERT( psiCurrent != NULL );

    do
    {
        psiCurrent = itersi.Next();
        if ( psiCurrent == NULL )
        {
            itersi.Reset();
            psiCurrent = itersi.Next();
        }

        if ( psiCurrent->QueryAccCharPos( event.QueryChar() ) >= 0 )
        {
            SetCurrentField( psiCurrent );
            // the inputed character is one of the accelerator key
            if ( psiCurrent->IsStatic() )
            {
                // it must be a separator
                // so we must jump to the next field
               JumpNextField( );
            }
            else
            {
                // let the item handles the character
                psiCurrent->DoChar( event );
                CHANGEABLE_SPIN_ITEM *pcsi = (CHANGEABLE_SPIN_ITEM *)psiCurrent;
                pcsi->SaveCurrentData();
            }
            return TRUE;
        }
    } while ( psiCurrent != psiOldItem );

    if ( (event.QueryChar() != VK_TAB)
         && (event.QueryChar() != VK_ESCAPE)
         && (event.QueryChar() != VK_RETURN) )
    {
        TRACEEOL(   SZ("SPIN_GROUP::DoChar(): invalid character ")
                 << ((INT)event.QueryChar()) );
        ::MessageBeep(0);
    }

    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::IsValidField

    SYNOPSIS:   check the current field is valid or not

    RETURN:     BOOL - TRUE if the current field item is valid
                       FALSE otherwise

    HISTORY:
                terryk  10-Jul-91   Created

*********************************************************************/

BOOL SPIN_GROUP::IsValidField()
{
    UIASSERT( QueryCurrentField() != NULL );
    UIASSERT( !QueryCurrentField()->IsStatic() );

    CHANGEABLE_SPIN_ITEM *pcsiCurrentFocus =
        (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

    BOOL fValid;

    if (!( fValid = pcsiCurrentFocus->CheckValid() ))
    {
        // reset the up and down arrow
        _arrowUp.SetSelected( FALSE );
        _arrowDown.SetSelected( FALSE );
        _arrowUp.Invalidate();
        _arrowDown.Invalidate();
    }

    return fValid;
}


/*********************************************************************

    NAME:       SPIN_GROUP::JumpNextField

    SYNOPSIS:   Set the current field to the next changeable field

    RETURN:     always TRUE

    HISTORY:
                terryk  20-Jun-91   Created
                terryk  10-Jul-91   Use ITER_DL inside the routine

*********************************************************************/

BOOL SPIN_GROUP::JumpNextField( )
{
    if ( _fActive )
    {
        if ( !QueryCurrentField()->IsStatic() && !IsValidField() )
        {
            return TRUE;
        }
    }
     ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );
    SPIN_ITEM * psi;
    while (( psi = itersi.Next() )!= NULL )
    {
        if ( psi == QueryCurrentField() )
            break;
    }

    UIASSERT( psi != NULL );

    while (( psi = itersi.Next() )!= NULL )
    {
        if (! psi->IsStatic() )
        {
            SetCurrentField( psi );
            SetArrowButtonStatus();
            return TRUE;
        }
    }
    ::MessageBeep( 0 );
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::JumpPrevField

    SYNOPSIS:   Jump to the previous field

    RETURN:     always true

    HISTORY:
                terryk  20-Jun-91   Created
                terryk  10-Jul-91   use ITER_DL inside the routine

*********************************************************************/

BOOL SPIN_GROUP::JumpPrevField( )
{
    if ( _fActive )
    {
        if ( !QueryCurrentField()->IsStatic() && !IsValidField() )
        {
            return TRUE;
        }
    }

    RITER_DL_OF( SPIN_ITEM ) ritersi( _dlsiControl );
    SPIN_ITEM * psi;
    while (( psi = ritersi.Next() )!= NULL )
    {
        if ( psi == QueryCurrentField() )
            break;
    }

    UIASSERT( psi != NULL );

    while (( psi = ritersi.Next() )!= NULL )
    {
        if (! psi->IsStatic() )
        {
            SetCurrentField( psi );
            SetArrowButtonStatus();
            return TRUE;
        }
    }
    ::MessageBeep( 0 );
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::DoNewFocus

    SYNOPSIS:   Set the current field to the new focus

    ENTRY:      SPIN_ITEM * pSpinItem - Spin item to be focused

    RETURN:     always TRUE

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL    SPIN_GROUP::DoNewFocus( SPIN_ITEM * pSpinItem )
{
    if ( !_fActive )
    {
        if ( QueryCurrentField() != pSpinItem )
        {
            SetCurrentField( pSpinItem );
        }
        return TRUE;
    }

    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        // set the field to current focus
        if ( QueryCurrentField() != pSpinItem )
        {
            SetCurrentField( pSpinItem );
        }
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::DoArrowCommand

    SYNOPSIS:   Whenever the up/down arrow is hit, it will send a message
                to here. Then the OnArrowCommand will increase or
                decrease the control item value.

    ENTRY:      CID cidArrow - the cid of the active arrow
                WORD Msg  = SPN_ARROW_SMALLINC or
                            SPN_ARROW_BIGINC

    EXIT:       increase or decrease the control item value.

    RETURN:     always TRUE

    NOTE:       depend on the cid value, we can find out the button is
                up arrow or down arrow and do the incease/decrease.

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL    SPIN_GROUP::DoArrowCommand( CID cidArrow, WORD wMsg )
{
    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        CHANGEABLE_SPIN_ITEM *pcsiCurrentFocus =
            (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

        pcsiCurrentFocus->SaveCurrentData();

        // inc or dec the number depended on the arrow key
        if ( cidArrow == _arrowUp.QueryCid() )
        {

            (*pcsiCurrentFocus) += ( wMsg == SPN_ARROW_SMALLINC ) ?
                                    pcsiCurrentFocus->QuerySmallIncValue() :
                                    pcsiCurrentFocus->QueryBigIncValue();

        }
        else
        {
            (*pcsiCurrentFocus) -= ( wMsg == SPN_ARROW_SMALLINC ) ?
                                    pcsiCurrentFocus->QuerySmallDecValue() :
                                    pcsiCurrentFocus->QueryBigDecValue();
        }
        _fModified = TRUE;
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::ChangeFieldValue

    SYNOPSIS:   handle all the VKey command

    ENTRY:      WORD Msg: SPN_INCREASE - increase by a small value
                          SPN_DECREASE - decrease by a small value
                          SPN_BIGINCREASE - big increase
                          SPN_BIGDECREASE - big decrease
                INT nRepeatCount - the repeat number

    EXIT:       Change the current control item's value

    RETURN:     TRUE

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL SPIN_GROUP::ChangeFieldValue( WORD wMsg, INT nRepeatCount )
{
    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        CHANGEABLE_SPIN_ITEM * pcsiCurrentFocus =
            (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

        // check for the repeat count
        for ( INT i =0; i < nRepeatCount; i++ )
        {
            pcsiCurrentFocus->SaveCurrentData();

            switch ( wMsg )
            {
            case SPN_INCREASE:
                (*pcsiCurrentFocus)+= pcsiCurrentFocus->QuerySmallIncValue();
                break;

            case SPN_DECREASE:
                (*pcsiCurrentFocus)-= pcsiCurrentFocus->QuerySmallDecValue();
                break;

            case SPN_BIGINCREASE:
                (*pcsiCurrentFocus)+= pcsiCurrentFocus->QueryBigIncValue();
                break;

            case SPN_BIGDECREASE:
                (*pcsiCurrentFocus)-= pcsiCurrentFocus->QueryBigDecValue();
                break;
            }
        }
        _fModified = TRUE;
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetFieldMinMax

    SYNOPSIS:   Set the value to either MAX or MIN

    ENTRY:      WORD Msg: either SPN_MAX or SPN_MIN

    EXIT:       set the current control item to either MAX or MIN

    RETURN:     TRUE

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL SPIN_GROUP::SetFieldMinMax( WORD wMsg )
{
    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        CHANGEABLE_SPIN_ITEM * pcsiCurrentFocus =
            (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

        pcsiCurrentFocus->SetValue( ( wMsg == SPN_MAX ) ?
            pcsiCurrentFocus->QueryMax() : pcsiCurrentFocus->QueryMin() );

        _fModified = TRUE;
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetArrowButtonStatus

    SYNOPSIS:   disable the button(s) if the current control reach the upper
                or lower limit

    NOTES:      disable the button if necessary

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetArrowButtonStatus()
{
    UIASSERT( QueryCurrentField() != NULL );
    UIASSERT( !QueryCurrentField()->IsStatic() );

    // set the arrow button. Disable the button if we reach the upper or
    // lower limit.

    CHANGEABLE_SPIN_ITEM *pcsiCurrentFocus = (CHANGEABLE_SPIN_ITEM *)
        QueryCurrentField();

    // do all the checking in order to avoid the blinking

    if (( ! pcsiCurrentFocus->QueryWrap() ) &&
        ( pcsiCurrentFocus->QueryValue() == pcsiCurrentFocus->QueryMax() ))
    {
        _arrowUp.Enable( FALSE );
        ::SendMessage( ((WINDOW)_arrowUp).QueryHwnd(), WM_LBUTTONUP, 0, 0);
    }
    else
    {
        _arrowUp.Enable( TRUE );
    }
    if (( ! pcsiCurrentFocus->QueryWrap() ) &&
        ( pcsiCurrentFocus->QueryValue() == pcsiCurrentFocus->QueryMin() ))
    {
        _arrowDown.Enable( FALSE );
        ::SendMessage( ((WINDOW)_arrowUp).QueryHwnd(), WM_LBUTTONUP, 0, 0);
    }
    else
    {
        _arrowDown.Enable( TRUE );
    }

    pcsiCurrentFocus->Update();
    SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::AddAssociation

    SYNOPSIS:   associated a control with the spin button

    ENTRY:      SPIN_ITEM * psiControl - control to be associated with

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

APIERR SPIN_GROUP::AddAssociation( SPIN_ITEM * psiControl )
{
    APIERR err = _dlsiControl.Append( psiControl );

    if ( err != NERR_Success )
    {
        return err;
    }

    if ( _psiFirstField == NULL )
    {
        _psiFirstField = psiControl;
    }
    _psiLastField = psiControl;
    CONTROL_WINDOW *pcw = psiControl->QueryControlWin();
    pcw->SetGroup( this );

    if (( ! psiControl->IsStatic() ) && ( _psiCurrentField == NULL ))
    {
        _psiCurrentField = psiControl;
    }
    return err;

}


/*********************************************************************

    NAME:       SPIN_GROUP::SetCurrentField

    SYNOPSIS:   set the current focus to the given control

    ENTRY:      SPIN_ITEM * psiControl - control to be focused
                if psiControl is NULL, it will set the spin button to
                the first changeable item.

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetCurrentField( SPIN_ITEM * psiControl )
{
    if ( psiControl == NULL )
    {
        // if no parameter is given, then set the first list item
        SPIN_ITEM * psi;
        ITER_DL_OF(SPIN_ITEM) itersi( _dlsiControl );
        for ( psi = itersi.Next(); (( psi != NULL ) && ( psi->IsStatic()));
              psi = itersi.Next())
        {
        }
        _psiCurrentField = psi;

    }
    else
    {
        _psiCurrentField = psiControl;
    }
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetControlValueFocus

    SYNOPSIS:   set the current focus to the first field

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetControlValueFocus()
{
    UIASSERT( QueryCurrentField() != NULL );

    CONTROL_WINDOW * pWin = QueryCurrentField()->QueryControlWin();
    pWin->SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::SaveValue

    SYNOPSIS:   save all the value within the spin_button's control(s)

    NOTES:      save the control value one by one

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::SaveValue( BOOL fInvisible )
{
    _fActive = FALSE;

    SPIN_ITEM * psiCurrentField;
    ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );

    while (( psiCurrentField = itersi.Next()) != NULL )
    {
        CONTROL_WINDOW * pYuck = psiCurrentField->QueryControlWin();

        if ( ! psiCurrentField->IsStatic())
        {
            CVSaveValue( pYuck, fInvisible );
        }
    }
//    SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::RestoreValue

    SYNOPSIS:   restore all the value within the spin button's control(s)

    NOTES:      call each control one by one and restore the value

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::RestoreValue( BOOL fInvisible )
{
    if ( _fActive )
        return;

    _fActive = TRUE;

    SPIN_ITEM * psiCurrentField;
    ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );

    while (( psiCurrentField = itersi.Next()) != NULL )
    {
        CONTROL_WINDOW * pYuck = psiCurrentField->QueryControlWin();

        if ( ! psiCurrentField->IsStatic() )
           // && ( psiCurrentField->QueryHwnd() != ::GetFocus()))
        {
            CVRestoreValue( pYuck, fInvisible );
        }
    }
//    SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::IsModified

    SYNOPSIS:   return the status of the spin button

    EXIT:       return TRUE if the spin button's controls have been modified.
                FALSE otherwise

    HISTORY:
                terryk  16-Jun-91   Created

*********************************************************************/

BOOL SPIN_GROUP::IsModified( VOID ) const
{
    return _fModified;
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetModified

    SYNOPSIS:   Set the internal Modified flag to the given parameter

    ENTRY:      BOOl fModified - modified state

    HISTORY:
                terryk  10-Jul-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetModified( BOOL fModified )
{
    _fModified = fModified;
}


/*********************************************************************

    NAME:       SPIN_GROUP::OnUserAction

    SYNOPSIS:   Restore the value if necessary

    ENTRY:      CONTROL_WINDOW * pcw - one of the control item
                ULPARAM lParam - the message type.

    RETURN:     Always NERR_Success

    HISTORY:
        terryk      10-Jul-91   Created
        beng        31-Jul-1991 Renamed QMessageInfo to QEventEffects
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR SPIN_GROUP::OnUserAction( CONTROL_WINDOW *      pcw,
                                 const CONTROL_EVENT & e )
{
    UINT nChangeFlags = pcw->QueryEventEffects( e );

    if ( nChangeFlags == CVMI_NO_VALUE_CHANGE )
        return GROUP_NO_CHANGE;

    RestoreValue();

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltsetbx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsetbx.cxx
    Set control object.

    It consists of 2 listboxes and 2 push buttons.
    Inside the listboxes are LBI items. Each item consists of
    a bitmap and a string. The user can drag on the string to select
    the string and drag on the icon to move the string from 1 listbox
    to the other. These are 2 push buttons associated with the control.
    The first one is Add button to add the items from the original
    listbox to the new listbox. Then, we also have a Delete button to
    delete all the selected items from the new listbox to the
    original listbox.

    FILE HISTORY:
        terryk      01-Jul-91   Created
        terryk      12-Aug-91   Add bitmap parameter to the constructor
        terryk      31-Oct-91   Fix enable move problem
        beng        20-May-1992 Add direct manipulation
        jonn      09-Sep-93    Modified to allow SET_CONTROL listboxes
                               to be lazy
*/

#include "pchblt.hxx"  // Precompiled header


static inline UINT absval( INT x )
{
    return (x < 0) ? -x : x;
}


/*********************************************************************

    NAME:       SET_CONTROL::SET_CONTROL

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *powin - owner window
                CID cidAdd - cid of the Add push button
                CID cidDelete - cid of the Delete button
                SET_CONTROL_LISTBOX *plbOrigBox - pointer to the orginial
                        listbox
                SET_CONTROL_LISTBOX *plbNewBox - pointer to the new listbox

    NOTES:      Construct the listboxes first.  Then construct the
                SET_CONTROL.  Finally, redirect the listboxes'
                OnLMouse and OnMouseMove messages to the SET_CONTROL.
                Reverse order on destruction.

    HISTORY:
        terryk      02-Jul-91   Created
        terryk      12-Aug-91   Add bitmap name parameter to the
                                constructor
        beng        03-Oct-1991 Checks listboxes
        beng        27-May-1992 Direct-manipulation delta
        jonn      09-Sep-93    Modified to allow SET_CONTROL listboxes
                               to be lazy

*********************************************************************/

SET_CONTROL::SET_CONTROL( OWNER_WINDOW *powin, CID cidAdd, CID cidDelete,
                          HCURSOR hcurSingle, HCURSOR hcurMultiple,
                          LISTBOX * plbOrigBox,
                          LISTBOX * plbNewBox,
                          UINT dxIconColumn )
    : _plbOrigBox( plbOrigBox ),
      _plbNewBox( plbNewBox ),
      _butAdd( powin, cidAdd ), // CODEWORK - why do these create a new obj?
      _butDelete( powin, cidDelete ), // shouldn't the dialog do that instead??
      _hcurNoDrop( CURSOR::LoadSystem(IDC_NO) ),
      _hcurSingle(hcurSingle),
      _hcurMultiple(hcurMultiple),
      _hcurSave( NULL ),
      _hcurUse( NULL ),
      _fEnableMove( TRUE ),
      _fInDrag(FALSE),
      _fInFakeClick(FALSE),
      _dxIconColumn(dxIconColumn),
      _eMouseDownSave(0,0,0)
{
    if (QueryError() != NERR_Success)
    {
        // error in parent ctor - abort
        return;
    }
    if (!*plbOrigBox)
    {
        // error in component listbox
        ReportError(plbOrigBox->QueryError());
        return;
    }
    if (!*plbNewBox)
    {
        // error in component listbox
        ReportError(plbNewBox->QueryError());
        return;
    }

    if (   _hcurNoDrop   == (HCURSOR)NULL
        || _hcurSingle   == (HCURSOR)NULL
        || _hcurMultiple == (HCURSOR)NULL
       )
    {
        DBGEOL( "SET_CONTROL::ctor; hcur error" );
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    // Associate the group objects

    _butAdd.SetGroup( this );
    _butDelete.SetGroup( this );

    plbOrigBox->SetGroup( this );
    plbNewBox->SetGroup( this );

    // if necessary, disable both buttons first
    INT clbiOrigCount = plbOrigBox->QuerySelCount();
    if ( clbiOrigCount == 0 )
    {
        _butAdd.Enable( FALSE );
    }

    INT clbiNewCount = plbNewBox->QuerySelCount();
    if ( clbiNewCount == 0 )
    {
        _butDelete.Enable( FALSE );
    }
    else if ( clbiOrigCount != 0 )
    {
        plbNewBox->RemoveSelection();
    }
}


/*********************************************************************

    NAME:       SET_CONTROL::~SET_CONTROL

    SYNOPSIS:   destructor

    HISTORY:
                terryk  02-Jul-91   Created

*********************************************************************/

SET_CONTROL::~SET_CONTROL()
{
    // do nothing
}


/*********************************************************************

    NAME:       SET_CONTROL::CalcAppropriateCursor

    SYNOPSIS:   Determine the cursor to use during a drag

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

HCURSOR SET_CONTROL::CalcAppropriateCursor( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    // n.b. do this with POINT instead of XYPOINT because w-from-pt
    // needs such anyway.  maybe someday heavy up XYPOINT to track
    // coordinate types.  (class CLIENT_XYPOINT: public XYPOINT?)

    POINT pt = xy.QueryPoint();
    REQUIRE( ::ClientToScreen(plbThis->WINDOW::QueryHwnd(), &pt) );

    HWND hwnd = ::WindowFromPoint(pt);

    if (hwnd == plbThis->WINDOW::QueryHwnd() || hwnd == plbOther->WINDOW::QueryHwnd())
        return _hcurUse;
    else
        return _hcurNoDrop;
}


/*********************************************************************

    NAME:       SET_CONTROL::IsWithinHitZone

    SYNOPSIS:   Determine whether a mousedown may init a drag

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsWithinHitZone( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    // The "hit zone" is the column consisting of all the visible
    // icons in the listbox.

    // CODEWORK: cache most of this stuff.

    XYRECT xyrClient(plbThis, TRUE);
    XYRECT xyrIcons( 0, 0,
                     _dxIconColumn,
                     (plbThis->QueryCount()-plbThis->QueryTopIndex())*plbThis->QueryItemHeight() );
    XYRECT xyrFinal;
    xyrFinal.CalcIntersect(xyrClient, xyrIcons);

    return xyrFinal.ContainsXY(xy);
}


/*********************************************************************

    NAME:       SET_CONTROL::IsOnSelectedItem

    SYNOPSIS:   Determine whether a mousedown landed on an item
                in the listbox which was already selected

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    NOTES:
        Assumes that xy already passed IsWithinHitZone

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsOnSelectedItem( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    //ASSERT(IsWithinHitZone(xy)); -- presupposed

    // Assumes fixed-height listbox, too.

    const UINT iFirst = plbThis->QueryTopIndex();
    const UINT iHit = iFirst + (xy.QueryY() / plbThis->QueryItemHeight());

    return plbThis->IsItemSelected(iHit);
}


/*********************************************************************

    NAME:       SET_CONTROL::IsOverTarget

    SYNOPSIS:   Determine whether a mouseup may successfully end a drag

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsOverTarget( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    POINT pt = xy.QueryPoint();
    REQUIRE( ::ClientToScreen(plbThis->WINDOW::QueryHwnd(), &pt) );

    return (::WindowFromPoint(pt) == plbOther->WINDOW::QueryHwnd());
}


/*********************************************************************

    NAME:       SET_CONTROL::IsOnDragStart

    SYNOPSIS:   Determine whether a mouseup didn't move from the down

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsOnDragStart( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    // Size of fudge for a drag which goes nowhere to be considered a click.
    // CODEWORK: cache the metrics calls

    const UINT cxFudge = ::GetSystemMetrics(SM_CXDOUBLECLK);
    const UINT cyFudge = ::GetSystemMetrics(SM_CYDOUBLECLK);

    XYPOINT xyDown = _eMouseDownSave.QueryPos();

    INT cx = xy.QueryX() - xyDown.QueryX();
    INT cy = xy.QueryY() - xyDown.QueryY();

    return ((absval(cx) <= cxFudge) && (absval(cy) <= cyFudge));
}


/*********************************************************************

    NAME:       SET_CONTROL::OnUserAction

    SYNOPSIS:   Depend on the push button, it will call the proper
                function.

    ENTRY:      CONTROL_WINDOW *pcw - control object which receive
                                      the message
                ULPARAM lParam - the lParam of the window message

    RETURN:     NERR_Success if success.

    HISTORY:
        terryk      02-Jul-91   Created
        beng        08-Oct-1991 Win32 conversion

**********************************************************************/

APIERR SET_CONTROL::OnUserAction( CONTROL_WINDOW *      pcw,
                                  const CONTROL_EVENT & e )
{
    UIASSERT( pcw != NULL );

    APIERR err = NERR_Success;

    CID cid = pcw->QueryCid();

    if ( cid == _plbOrigBox->QueryCid() )
    {
        // the user selected the items within the original listbox
        switch ( e.QueryCode() )
        {
        case LBN_SELCHANGE:
            _plbNewBox->RemoveSelection();
            if ( _fEnableMove )
            {
                EnableButtons();
            }
            break;
        case LBN_DBLCLK:
            if ( _fEnableMove )
            {
                err = DoAdd();
            }
            break;
        default:
            break;
        }
    }
    else if ( cid == _plbNewBox->QueryCid() )
    {
        // the user selected the items within the new listbox
        switch ( e.QueryCode() )
        {
        case LBN_SELCHANGE:
            _plbOrigBox->RemoveSelection();
            if ( _fEnableMove )
            {
                EnableButtons();
            }
            break;
        case LBN_DBLCLK:
            if ( _fEnableMove )
            {
                err = DoRemove();
            }
            break;
        default:
            break;
        }
    }
    else if ( _fEnableMove )
    {
        if ( cid == _butAdd.QueryCid() )
        {
            // add button is hit by the user
            err = DoAdd();
            if ( err == NERR_Success )
                _butDelete.ClaimFocus();
        }
        else if ( cid == _butDelete.QueryCid() )
        {
            // delete button is hit by the user
            err = DoRemove();
            if ( err == NERR_Success )
                _butAdd.ClaimFocus();
        }
        else
        {
            DBGEOL("BLT: Set control - unknown cid");
            ASSERT( FALSE );
            return ERROR_GEN_FAILURE;
        }
    }

    return err;
}


/*********************************************************************

    NAME:       SET_CONTROL::DoAdd

    SYNOPSIS:   move all the selected strings from original box
                to the new listbox

    HISTORY:
        terryk      02-Jul-91   Created
        beng        27-May-1992 Direct manipulation delta

*********************************************************************/

APIERR SET_CONTROL::DoAdd()
{
    return MoveItems(_plbOrigBox, _plbNewBox);
}


/*********************************************************************

    NAME:       SET_CONTROL::DoRemove

    SYNOPSIS:   move all the selected strings from the new listbox
                to the original listbox

    HISTORY:
        terryk      02-Jul-91   Created
        beng        27-May-1992 Direct manipulation delta

*********************************************************************/

APIERR SET_CONTROL::DoRemove()
{
    return MoveItems(_plbNewBox, _plbOrigBox);
}


/*********************************************************************

    NAME:       SET_CONTROL::DoAddOrRemove

    SYNOPSIS:   move all the selected strings from the new listbox
                to the original listbox

    HISTORY:
        thomaspa    17-Mar-93   Created

*********************************************************************/

APIERR SET_CONTROL::DoAddOrRemove( LISTBOX *plbFrom,
                                   LISTBOX *plbTo )
{
    if ( plbFrom == _plbOrigBox )
    {
        return DoAdd();
    }
    else
    {
        return DoRemove();
    }
}


/*********************************************************************

    NAME:       SET_CONTROL::EnableMoves

    SYNOPSIS:   enable the set control or not

    ENTRY:      BOOL fEnable - the enable flag of the set control

    NOTES:      It will disable the 2 push buttons if the flag is
                FALSE.

    HISTORY:
                terryk  15-Aug-1991     Created

*********************************************************************/

VOID SET_CONTROL::EnableMoves( BOOL fEnable )
{
    if ( _fEnableMove == fEnable )
        return;

    _fEnableMove = fEnable;
    if ( _fEnableMove )
    {
        EnableButtons();
    }
    else
    {
        _butAdd.Enable( FALSE );
        _butDelete.Enable( FALSE );
    }
}


/*********************************************************************

    NAME:       SET_CONTROL::EnableButtons

    SYNOPSIS:   enable or disable the push button

    NOTES:      Depending the select count of each listbox, it will enable
                or disable the 2 push buttons

    HISTORY:
                terryk  15-Aug-1991     Created

*********************************************************************/

VOID SET_CONTROL::EnableButtons()
{
    // set the buttons disable mode

    UIASSERT( _fEnableMove );

    _butAdd.Enable( _plbOrigBox->QuerySelCount() != 0 );
    _butDelete.Enable( _plbNewBox->QuerySelCount() != 0 );
}

/*********************************************************************

    NAME:       SET_CONTROL::OtherListbox

    SYNOPSIS:   Gets pointer to the other listbox

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/
LISTBOX * SET_CONTROL::OtherListbox( LISTBOX * plb ) const
{
    LISTBOX * plbRet = _plbNewBox;
    if (plb != _plbOrigBox)
    {
        if (plb == _plbNewBox)
        {
            plbRet = _plbOrigBox;
        }
        else
        {
            ASSERT( FALSE );
        }
    }
    return plbRet;
}

/*********************************************************************

    NAME:       SET_CONTROL::HandleOnLMouseButtonDown

    SYNOPSIS:   Response to a left-mouse-button-down event

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::HandleOnLMouseButtonDown( LISTBOX * plb,
                                            CUSTOM_CONTROL * pcc,
                                            const MOUSE_EVENT & e )
{
    if (   _fInFakeClick  // This is a faked mouse-down.  Punt to superclass.
        || !_fEnableMove )  // Moves are disabled
    {
        return FALSE;
    }

    ASSERT(!_fInDrag);

    XYPOINT xy = e.QueryPos(); // n.b. already in client coords

    if (!IsWithinHitZone(plb, OtherListbox(plb), xy))
        return FALSE; // let defproc handle it

    _fAlreadyFakedClick = FALSE; // Prevents faking the click twice

    if (!IsOnSelectedItem(plb, OtherListbox(plb), xy))
    {
        // If item not selected, fake a click on it before dragging.
        // Have to do it this way because underlying lb captures the
        // mouse itself....

        ASSERT(!_fInFakeClick);
        _fInFakeClick = TRUE;
        MOUSE_EVENT eFakeDown = e;
        eFakeDown.SendTo(plb->WINDOW::QueryHwnd());
        MOUSE_EVENT eFakeUp(WM_LBUTTONUP, e.QueryWParam(), e.QueryLParam());
        eFakeUp.SendTo(plb->WINDOW::QueryHwnd());
        _fInFakeClick = FALSE;

        _fAlreadyFakedClick = TRUE;
    }

    // Mousedown took place on the draggable region of an already
    // selected item: initiate the drag proper.

    pcc->CaptureMouse();
    _fInDrag = TRUE;
    _eMouseDownSave = e; // save it in case we have to fake one later,
                         // or to remember where the mousedown took place

    // Prep various cursors.  (Wait until actual "pull" of the drag
    // before setting the cursor to hcurUse, so that a single down, up
    // click on the hit zone won't strobe the cursor.)

    _hcurUse = (plb->QuerySelCount() > 1) ? _hcurMultiple : _hcurSingle;
    _hcurSave = CURSOR::Query();

    return TRUE; // message handled - don't pass along
}


/*********************************************************************

    NAME:       SET_CONTROL::HandleOnLMouseButtonUp

    SYNOPSIS:   Response to a left-mouse-button-up event

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::HandleOnLMouseButtonUp( LISTBOX * plb,
                                          CUSTOM_CONTROL * pcc,
                                          const MOUSE_EVENT & e )
{
    if (!_fInDrag || _fInFakeClick)
        return FALSE;

    XYPOINT xy = e.QueryPos();

    BOOL fNeedsFakeClick = FALSE;

    if (IsOverTarget(plb, OtherListbox(plb), xy)) // In the crosshairs? Drop the bomb
    {
        // DoAddOrRemove may do a MsgPopup, so release the mouse now
        CURSOR::Set(_hcurSave);
        pcc->ReleaseMouse();
        DoAddOrRemove(plb, OtherListbox(plb));
    }
    else if (!_fAlreadyFakedClick && IsOnDragStart(plb, OtherListbox(plb), xy))
    {
        // If mouse went down on the hit zone of a selected item, but then
        // the drag didn't go anywhere, then we need to fake a mousedown
        // (since we ate the mouse-down ourselves without passing it along)
        // before passing along the mouse-up.
        //
        // Fake the click only after this routine releases the capture.

        fNeedsFakeClick = TRUE;
    }
    // Otherwise, drag aborted w/ no special handling needed.

    // Clean up from drag-mode

    CURSOR::Set(_hcurSave);
    pcc->ReleaseMouse();

    if (fNeedsFakeClick)
    {
        // Now that capture released, fake the click.

        ASSERT(!_fInFakeClick);
        _fInFakeClick = TRUE;
        _eMouseDownSave.SendTo(plb->WINDOW::QueryHwnd());
        _fInFakeClick = FALSE;
    }

    _fInDrag = FALSE;

    // If faking click, don't eat the message, so that the superclass
    // gets this mouseup to compliment the (faked) mousedown.

    return fNeedsFakeClick ? FALSE : TRUE;
}


/*********************************************************************

    NAME:       SET_CONTROL::HandleOnMouseMove

    SYNOPSIS:   Response to a mouse-move event

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::HandleOnMouseMove( LISTBOX * plb, const MOUSE_EVENT & e )
{
    if (!_fInDrag)
        return FALSE;

    XYPOINT xy = e.QueryPos();

    CURSOR::Set( CalcAppropriateCursor(plb, OtherListbox(plb), xy) );
    return TRUE;
}


/*********************************************************************

    NAME:       SET_CONTROL::BLTMoveItems

    SYNOPSIS:   Move the selected LBIs from one listbox to the other.

    ENTRY:
        plbFrom - the listbox containing selected items, from which
                  those items will be moved
        plbTo   - the destination listbox, which will receive the
                  moved items

    RETURN:     APIERR

    HISTORY:
        terryk      02-Jul-91   Created
        beng        27-May-1992 Takes plbFrom, plbTo instead of fWhichWay
        jonn        09-Sep-1993 Moved to BLTMoveItems

*********************************************************************/

APIERR SET_CONTROL::BLTMoveItems( BLT_LISTBOX * plbFrom,
                                  BLT_LISTBOX * plbTo )
{
    ASSERT( plbFrom == _plbOrigBox || plbFrom == _plbNewBox );
    ASSERT( plbTo == _plbOrigBox || plbTo == _plbNewBox );
    ASSERT( plbFrom != plbTo );

    INT clbiSel = plbFrom->QuerySelCount();
    APIERR err = NERR_Success;
    INT iPos;           // index Position

    if ( clbiSel == 0 )
        return err;

    INT *aiLBI = new INT[ clbiSel ];
    if ( aiLBI == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    REQUIRE( plbFrom->QuerySelItems( aiLBI, clbiSel ) == NERR_Success );
    plbFrom->SetRedraw( FALSE );
    plbTo->SetRedraw( FALSE );

    for ( INT i = clbiSel - 1; i >= 0; i -- )
    {
        const INT ilbiSource = aiLBI[i];

        LBI * plbi = plbFrom->QueryItem( ilbiSource );
        // set the pointer to move. Otherwise, DeleteItem will clear up
        // the memory space.
        plbFrom->SetItem( ilbiSource, NULL );

        // Assume the sorting method is the same, the last added item
        // must be in the top of all the added items.

        iPos = plbTo->AddItem( plbi );
        if ( iPos < 0 )
        {
            plbFrom->SetItem( ilbiSource, plbi );
            err = ERROR_NOT_ENOUGH_MEMORY;
            plbTo->RemoveSelection();
            break;
        }
        else
        {
            plbTo->SelectItem( iPos, TRUE );
            plbFrom->DeleteItem( ilbiSource );
        }

    }

	// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast: need to call delete [].
	// aiLBI allocated with new []; need to call delete [] to avoid
	// memory leak
    delete aiLBI;

	// NTRAID#NTBUG9-577061-2002/03/08-artm  Prefast: iPos may be uninitialized.
	// If for loop never executed then iPos is never initialized.
    if ( iPos >= 0 )
    {
        plbTo->SetTopIndex( iPos );
    }

    plbFrom->SetRedraw( TRUE );
    plbTo->SetRedraw( TRUE );

    plbFrom->Invalidate( TRUE );
    plbTo->Invalidate( TRUE );
    EnableButtons();

    return err;
}


/*********************************************************************

    NAME:       BLT_SET_CONTROL::MoveItems

    SYNOPSIS:   Move the selected LBIs from one listbox to the other.

    ENTRY:
        plbFrom - the listbox containing selected items, from which
                  those items will be moved
        plbTo   - the destination listbox, which will receive the
                  moved items

    RETURN:     APIERR

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/

APIERR BLT_SET_CONTROL::MoveItems( LISTBOX * plbFrom,
                                   LISTBOX * plbTo )
{
    return BLTMoveItems( (BLT_LISTBOX *)plbFrom, (BLT_LISTBOX *)plbTo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltbmctl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbmctl.cxx
    BIT_MAP_CONTROL declaration

    FILE HISTORY:
        JonN        13-Aug-1992 Created
*/

#include "pchblt.hxx"  // Precompiled header


/*******************************************************************

    NAME:     BIT_MAP_CONTROL::BIT_MAP_CONTROL

    SYNOPSIS: Static bitmap control class

    ENTRY:    powin - Owner window of this control
              cidBitmap - Control ID of the bitmap

    EXIT:

    HISTORY:
        JonN        11-Aug-1992     Created (templated from LOGON_HOURS_CONTROL)

********************************************************************/

BIT_MAP_CONTROL::BIT_MAP_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidBitmap,
    BMID           bmid )
    : CONTROL_WINDOW( powin, cidBitmap ),
      CUSTOM_CONTROL( this ),
      _dmap( bmid )
{
    if (QueryError())
        return;

    APIERR err = _dmap.QueryError();
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

BIT_MAP_CONTROL::BIT_MAP_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidBitmap,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    BMID           bmid,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : CONTROL_WINDOW( powin, cidBitmap, xy, dxy, flStyle, pszClassName ),
      CUSTOM_CONTROL( this ),
      _dmap( bmid )
{
    if (QueryError())
        return;

    APIERR err = _dmap.QueryError();
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*********************************************************************

    NAME:       BIT_MAP_CONTROL::OnPaintReq

    SYNOPSIS:   Handles paint messages for the control

    HISTORY:
        jonn        13-Aug-1992 Templated from LOGON_HOURS_CONTROL

**********************************************************************/

BOOL BIT_MAP_CONTROL::OnPaintReq()
{
    if (QueryError() != NERR_Success)
        return FALSE; // bail out!

    PAINT_DISPLAY_CONTEXT dc(this);

    return _dmap.Paint( dc.QueryHdc(), 0, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltsi.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltsi.cxx
    Source file the BLT spin item

    FILE HISTORY:
	terryk	    15-Apr-1991 Created
	terryk	    20-Jun-1991 code review changed. Attend: beng
	terryk	    11-Nov-1991	changed SPIN_ITEM type from INT to LONG
	terryk	    20-Dec-1991	long conversions
	terryk	    22-Mar-1992	changed LONG to ULONG
*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       SPIN_ITEM::SPIN_ITEM

    SYNOPSIS:   constructor

    ENTRY:      HWND hwnd - pass the hwnd to the dispatcher

    HISTORY:
                terryk  01-May-1991 Created
                terryk  20-Jun-1991 Use dispatcher method

*********************************************************************/

SPIN_ITEM::SPIN_ITEM( CONTROL_WINDOW *pWin )
    : CUSTOM_CONTROL( pWin )
{
    // do nothing
}


/*********************************************************************

    NAME:       SPIN_ITEM::~SPIN_ITEM

    SYNOPSIS:   destrcutor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_ITEM::~SPIN_ITEM()
{
    // do nothing
}


/*********************************************************************

    NAME:       SPIN_ITEM::OnFocus

    SYNOPSIS:   OnFocus

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL SPIN_ITEM::OnFocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );

    SPIN_GROUP  * pSB = (SPIN_GROUP *)QueryGroup();
    return pSB->DoNewFocus( this );
}


/*********************************************************************

    NAME:       SPIN_ITEM::OnChar

    SYNOPSIS:   Pass the character to the spin group.

    ENTRY:      CHAR_EVENT event.

    RETURN:     return a BOOL from DoChar method of SPIN_GROUP

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_ITEM::OnChar( const CHAR_EVENT & event )
{
    SPIN_GROUP  *pSB = (SPIN_GROUP *)QueryGroup();
    return pSB->DoChar( (CHAR_EVENT & )event );
}


/*********************************************************************

    NAME:       SPIN_ITEM::QueryGroup

    SYNOPSIS:   return the associated group of this spin item

    RETURN:     CONTROL_GROUP * control_group

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

CONTROL_GROUP * SPIN_ITEM::QueryGroup()
{
    CONTROL_WINDOW *pcw=QueryControlWin();
    return pcw->QueryGroup();
}


/*********************************************************************

    NAME:       SPIN_ITEM::SetAccKey

    SYNOPSIS:   set the internal variable for accelerator keys.

    ENTRY:      NLS_STR nlsStr - it is the accelerator keys string
                OR
                USHORT usMsgID - string ID

    NOTES:      It get the accelerator key string from the caller
                and set the string to an internal string.

    HISTORY:
	terryk	    23-May-91	Created
	beng	    04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR SPIN_ITEM::SetAccKey( const NLS_STR & nlsStr )
{
    APIERR apierr = nlsStr.QueryError();

    if ( apierr != NERR_Success )
    {
        return apierr;
    }

    _nlsAccKey = nlsStr;

    return _nlsAccKey.QueryError();
}

APIERR SPIN_ITEM::SetAccKey( MSGID msgid )
{
    NLS_STR nlsStr;

    APIERR err = nlsStr.Load( msgid ) ;

    if ( err != NERR_Success )
    {
        return err;
    }

    return SetAccKey( nlsStr );
}


/*********************************************************************

    NAME:       SPIN_ITEM::QueryAccCharPos

    SYNOPSIS:   check whether the given character is one of
                accelerator key within the object.

    ENTRY:      WCHAR cInput - key to be checked

    RETURN:     the position of the character within the accelerator
                or -1 if the character does not belong to the accelerator
                key set.

    NOTE:       CODEWORK. change to NLS_STR if it returns an integer

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

LONG SPIN_ITEM::QueryAccCharPos( WCHAR wchInput )
{
    ISTR istrAccKey( _nlsAccKey );
    LONG cwcNumChar = _nlsAccKey.QueryNumChar();
    LONG i;

    // AnsiUpperBuff( (TCHAR *)&wchInput, 1 );

    // CODEWORK: create a virtual function call LeadingChar for each string
    //           object
    for ( i=0; ( wchInput != _nlsAccKey.QueryChar( istrAccKey )) &&
        i < cwcNumChar; i++, ++istrAccKey )
        ;

    return ( i < cwcNumChar ) ? i : ( -1 );
}

/*********************************************************************

    NAME:       SPIN_ITEM::QueryAccKey

    SYNOPSIS:   return the accelator key string in NLS_STR format

    ENTRY:      NLS_STR *nlsAccKey - the returned accelator key list

    EXIT:       NLS_STR *nlsAccKey - the returned key list

    RETURN:     APIERR. return code.

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

APIERR SPIN_ITEM::QueryAccKey( NLS_STR * pnlsAccKey )
{
    UIASSERT( pnlsAccKey != NULL );

    *pnlsAccKey = _nlsAccKey;
    return pnlsAccKey->QueryError();
}


/*****************************************************************/


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::CHANGEABLE_SPIN_ITEM

    SYNOPSIS:   constructor

    ENTRY:      CONTROL_WINDOW *pWin - a control window pointer
                ULONG nValue - the default value
                ULONG nMin - min number
                ULONG dRange - the range
                BOOL fWrap - wrap-around or not

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

CHANGEABLE_SPIN_ITEM::CHANGEABLE_SPIN_ITEM( CONTROL_WINDOW *pWin, ULONG nValue,
                                            ULONG nMin, ULONG dRange, BOOL fWrap)
    : SPIN_ITEM ( pWin),
    _nValue( nValue ),
    _nMin( nMin ),
    _dRange( dRange ),
    _fWrap( fWrap ),
    _dBigIncValue( 10 ),
    _dSmallIncValue( 1 ),
    _dBigDecValue( 10 ),
    _dSmallDecValue( 1 )
{
    // No action needed here
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetRange

    SYNOPSIS:   Set the object's range

    ENTRY:      ULONG dRange - range of the object

    EXIT:       set the internal dRange variable

    NOTE:       CODEWORK: use itoa in NLS_STR when available.

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetRange( const ULONG dRange )
{
    _dRange = dRange;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetMin

    SYNOPSIS:   set the minimal number of the object

    ENTRY:      ULONG nMin - the minimal number

    EXIT:       set the minimal number within the object

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetMin( const ULONG nMin )
{
    _nMin = nMin;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetValue

    SYNOPSIS:   set the current value of the control item

    ENTRY:      ULONG nValue - value to be set

    NOTES:      The program will die if the value is invalid

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetValue( const ULONG nValue )
{
    UIASSERT ( CheckRange( nValue ) == 0 );

    _nValue = nValue;

}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetBigIncValue

    SYNOPSIS:   set the big increase value

    ENTRY:      ULONG dBigIncValue - the value to be increased by.

    NOTES:      The big increase value for the SPIN_GROUP .
                The default is 10.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetBigIncValue( const ULONG dBigIncValue )
{
    _dBigIncValue = dBigIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetSmallIncValue

    SYNOPSIS:   set the small increase value

    ENTRY:      ULONG dSmallIncValue - the value to be increased by

    NOTES:      The small increase value for the SPIN_GROUP .
                The default is 1.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetSmallIncValue( const ULONG dSmallIncValue )
{
    _dSmallIncValue = dSmallIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetBigDecValue

    SYNOPSIS:   set the big decrease value

    ENTRY:      ULONG dBigDecValue - the value to be decreased by.

    NOTES:      The big decrease value for the SPIN_GROUP .
                The default is 10.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetBigDecValue( const ULONG dBigDecValue )
{
    _dBigDecValue = dBigDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetSmallDecValue

    SYNOPSIS:   set the small decrease value

    ENTRY:      ULONG dSmallDecValue - the value to be decreased by

    NOTES:      The small decrease value for the SPIN_GROUP .
                The default is 1.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetSmallDecValue( const ULONG dSmallDecValue )
{
    _dSmallDecValue = dSmallDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QuerySmallIncValue

    SYNOPSIS:   return the small increase value

    RETURN:     the small increase value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QuerySmallIncValue() const
{
    return _dSmallIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QueryBigIncValue

    SYNOPSIS:   return the big increase value

    RETURN:     the big increase value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QueryBigIncValue() const
{
    return _dBigIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QuerySmallDecValue

    SYNOPSIS:   return the small decrease value

    RETURN:     the small decrease value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QuerySmallDecValue() const
{
    return _dSmallDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QueryBigDecValue

    SYNOPSIS:   return the bid decrease value

    RETURN:     the big decrease value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QueryBigDecValue() const
{
    return _dBigDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::operator+=

    SYNOPSIS:   add an integer value to the object

    ENTRY:      ULONG nValue - integer value to be added to the object

    NOTES:      Increase the internal value of the object

    HISTORY:
                terryk  01-May-1991 	Created
		terryk	20-Dec-1991	Long conversion

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::operator+=( const ULONG nValue )
{
    UIASSERT( _dRange > 0 );

    if ( _nValue > ( _nValue + nValue ))
    {
	// okay we are overflow.
	_nValue = _fWrap
                  ? _nMin + ( nValue - ( QueryMax() - _nValue + 1)) %_dRange
		  : QueryMax();
    }
    else
    {

    	_nValue += nValue;

    	if ( _nValue > QueryMax() )
            _nValue = _fWrap
                      ? _nMin + (( _nValue - QueryLimit()) % _dRange )
		      : QueryMax();
    }
    Update();
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::operator-=

    SYNOPSIS:   subtract an integer value from the object

    ENTRY:      ULONG nValue - an inetger to be subtracted

    NOTES:      decrease the internal value of the object.
                Depending on the wrap variable, the function will
                wrap the number or set it to the min number.

    HISTORY:
                terryk  01-May-1991 	Created
		terryk	20-Dec-1991	Long conversions

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::operator-=( const ULONG nValue )
{
    UIASSERT( _dRange > 0 );

    if (( _nValue < ( _nValue - nValue )) || (( _nValue - nValue ) < _nMin ))
    {
    	// okay, we are underflow
    	_nValue = _fWrap
                  ? QueryMax() - (nValue - (_nValue - QueryMin() + 1)) % _dRange
    		  : _nMin;
    }
    else
    {
	_nValue -= nValue;
    }
    Update();
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::Update

    SYNOPSIS:   update the item value

    NOTE:       This is a virtual function.

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::Update( )
{
    // do nothing
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::CheckRange

    SYNOPSIS:   check withthe the given number is within the range

    ENTRY:      ULONG nValue - number to be checked

    RETURN:     -1 if the nValue is smaller than the range
                0 if the nValue is within the range
                1 if the nValue is bigger than the range

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

INT CHANGEABLE_SPIN_ITEM::CheckRange( const ULONG nValue ) const
{
    if ( nValue < _nMin )
    {
        return -1;
    }
    else
    {
        if ( nValue >= ( _nMin + _dRange ))
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SaveCurrentData

    SYNOPSIS:   save the window text into the internal variable

    RETURN:     APIERR - since this is a vritual function, it always
                return NERR_Success.

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

APIERR CHANGEABLE_SPIN_ITEM::SaveCurrentData()
{
    return NERR_Success;
}


/*********************************************************************

    NAME:       STATIC_SPIN_ITEM::STATIC_SPIN_ITEM

    SYNOPSIS:   constructor

    ENTRY:      HWND hWnd - window handler

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

STATIC_SPIN_ITEM::STATIC_SPIN_ITEM( CONTROL_WINDOW *pWin )
    : SPIN_ITEM( pWin )
{
    // No action needed
}

/*********************************************************************

    NAME:       STATIC_SPIN_ITEM::OnFocus

    SYNOPSIS:   OnFocus

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL STATIC_SPIN_ITEM::OnFocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltsplit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltsplit.cxx
        Source file for the Splitter Bar custom control

    FILE HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)
*/


#include "pchblt.hxx"  // Precompiled header

#include "bltsplit.hxx"


const TCHAR * H_SPLITTER_BAR::_pszClassName = SZ("static");


/*********************************************************************

    NAME:       H_SPLITTER_BAR::H_SPLITTER_BAR

    SYNOPSIS:   Splitter bars can seperate the window pane into two or
                more parts.  This splitter bar is modelled after
                WinWord 6's splitter bar with visual modifications
                recommended by KeithL.

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

H_SPLITTER_BAR::H_SPLITTER_BAR( OWNER_WINDOW *powin, CID cid )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _fCapturedMouse( 0 ),
      _dxActiveArea( 0 ),
      _dyLineWidth( 0 ),
      _xyrectHitZone(),
      _xyrectNotHitZone(),
      _pdcDrag( NULL ),
      _fInDrag( FALSE ),
      _fShowingDragBar( FALSE ),
      _xyLastDragPoint( 0, 0 ),
      _hcurActive( NULL ),
      _hcurSave( NULL )
{
    ASSERT( powin != NULL );

    CtAux();
}

H_SPLITTER_BAR::H_SPLITTER_BAR( OWNER_WINDOW *powin, CID cid,
              XYPOINT xy, XYDIMENSION dxy, ULONG flStyle )
    : CONTROL_WINDOW ( powin, cid, xy, dxy, flStyle, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _fCapturedMouse( 0 ),
      _dxActiveArea( 0 ),
      _dyLineWidth( 0 ),
      _xyrectHitZone(),
      _xyrectNotHitZone(),
      _pdcDrag( NULL ),
      _fInDrag( FALSE ),
      _fShowingDragBar( FALSE ),
      _xyLastDragPoint( 0, 0 ),
      _hcurActive( NULL ),
      _hcurSave( NULL )
{
    ASSERT( powin != NULL );

    CtAux();
}

VOID H_SPLITTER_BAR::CtAux()
{
    if (QueryError() != NERR_Success)
    {
        DBGEOL( "H_SPLITTER_BAR::CtAux(): parent ctor failed" );
        return;
    }

    APIERR err;
    if (   (err = _xyrectHitZone.QueryError()) != NERR_Success
        || (err = _xyrectNotHitZone.QueryError()) != NERR_Success
       )
    {
        DBGEOL( "H_SPLITTER_BAR error: ctor failed " << err );
        ReportError( err );
        return ;
    }

    _hcurActive = CURSOR::Load( ID_CURS_BLT_VSPLIT );
    if (_hcurActive == NULL)
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        DBGEOL( "H_SPLITTER_BAR error: CURSOR::Load failed" );
        return ;
    }

    _dxActiveArea = ::GetSystemMetrics( SM_CXVSCROLL );
    _dyLineWidth  = ::GetSystemMetrics( SM_CYBORDER  );

    TRACEEOL( "H_SPLITTER_BAR ctor: _dxActiveArea = " << _dxActiveArea );
    TRACEEOL( "H_SPLITTER_BAR ctor: _dyLineWidth  = " << _dyLineWidth  );
}


H_SPLITTER_BAR::~H_SPLITTER_BAR()
{
    if (_hcurSave != NULL)
    {
        CURSOR::Set(_hcurSave);
        _hcurSave = NULL;
    }

    if (_hcurActive != NULL)
    {
        ::DeleteObject( _hcurActive );
        _hcurActive = NULL;
    }

    delete _pdcDrag;
    _pdcDrag = NULL;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnPaintReq

    SYNOPSIS:   Redraw the whole object

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

BOOL H_SPLITTER_BAR::OnPaintReq()
{
    BOOL fWasShowingDrag = _fShowingDragBar;
    ClearDragBar();

    PAINT_DISPLAY_CONTEXT dc(this);

    HBRUSH hbrBlack = NULL;

    do {   // false loop

        INT xActiveArea = QueryActiveArea();

        hbrBlack = ::CreateSolidBrush( 0x00000000 );
        SOLID_BRUSH brushBkgnd( COLOR_BTNFACE );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   hbrBlack == NULL
            || (err = brushBkgnd.QueryError()) != NERR_Success
           )
        {
            DBGEOL( "H_SPLITTER_BAR::OnPaintReq(): SOLID_BRUSH error " << err );
            break;
        }

        /*
         *   Draw active area (in scrollbar zone) black and rest white
         */
        ::FillRect(  dc.QueryHdc(),
                     (const RECT *)_xyrectHitZone,
                     hbrBlack );

        ::FillRect(  dc.QueryHdc(),
                     (const RECT *)_xyrectNotHitZone,
                     brushBkgnd.QueryHandle() );

        ::FrameRect( dc.QueryHdc(),
                     (const RECT *)_xyrectNotHitZone,
                     hbrBlack );

    } while (FALSE);  // false loop

    if (hbrBlack != NULL)
    {
        ::DeleteObject( hbrBlack );
    }

#if 0 // old look

    HPEN hpenOld = NULL;
    HBRUSH hbrBlack = NULL;

    do {   // false loop

        INT xActiveArea = QueryActiveArea();

        // are these the right colors?
        hbrBlack = ::CreateSolidBrush( 0x00000000 );
        SOLID_BRUSH brushBkgnd( COLOR_WINDOW );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   hbrBlack == NULL
            || (err = brushBkgnd.QueryError()) != NERR_Success
           )
        {
            DBGEOL( "H_SPLITTER_BAR::OnPaintReq(): SOLID_BRUSH error " << err );
            break;
        }

        /*
         *   Draw active area (in scrollbar zone) black and rest white
         */
        ::FillRect( dc.QueryHdc(),
                    (const RECT *)_xyrectHitZone,
                    hbrBlack );

        ::FillRect( dc.QueryHdc(),
                    (const RECT *)_xyrectNotHitZone,
                    brushBkgnd.QueryHandle() );

        HPEN hpenBlack = ::CreatePen( PS_SOLID, _dyLineWidth, 0x00000000 );
        if (hpenBlack == NULL)
        {
            DBGEOL( "H_SPLITTER_BAR::OnPaintReq(): HPEN error" );
            break;
        }
        hpenOld = dc.SelectPen( hpenBlack );

        /*
         *  Draw splitter lines through main area
         */
        dc.MoveTo( 0,                              2 * _dyLineWidth );
        dc.LineTo( _xyrectNotHitZone.CalcWidth(),  2 * _dyLineWidth );
        dc.MoveTo( 0,                              4 * _dyLineWidth );
        dc.LineTo( _xyrectNotHitZone.CalcWidth(),  4 * _dyLineWidth );

        /*
         *  Draw line to set off lower column header
         */
        dc.MoveTo( 0,                              7 * _dyLineWidth );
        dc.LineTo( _xyrectNotHitZone.CalcWidth(),  7 * _dyLineWidth );

    } while (FALSE);  // false loop

    if (hpenOld != NULL)
    {
        HPEN hpenNew = dc.SelectPen( hpenOld );
        if (hpenNew != NULL)
        {
            ::DeleteObject( hpenNew );
        }
    }

    if (hbrBlack != NULL)
    {
        ::DeleteObject( hbrBlack );
    }

#endif // old look

    if (fWasShowingDrag)
        ShowDragBar( _xyLastDragPoint );

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnResize

    SYNOPSIS:   Change on object size

    HISTORY:
        jonn    11-Oct-93   Created

**********************************************************************/

BOOL H_SPLITTER_BAR::OnResize( const SIZE_EVENT & ev )
{
    XYPOINT     xyOrigin( 0, 0 );
    XYDIMENSION dxySize( ev.QueryWidth(), ev.QueryHeight() );
    XYRECT      xyrectClient( xyOrigin, dxySize );

    INT dxActiveArea = QueryActiveArea();
    ASSERT( xyrectClient.CalcWidth() > dxActiveArea );

    // must adjust top/bottom to make golumn headers look right
    // CODEWORK column headers should take care of themselves
    xyrectClient.AdjustTop( -1 );
    xyrectClient.AdjustBottom( -1 );

    _xyrectHitZone = _xyrectNotHitZone = xyrectClient;

    _xyrectHitZone.AdjustLeft( _xyrectHitZone.CalcWidth() - dxActiveArea );
    _xyrectNotHitZone.AdjustRight( -dxActiveArea );

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::QueryActiveArea

    SYNOPSIS:   Get width of active area, defaults to width of scrollbar thumb

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

INT H_SPLITTER_BAR::QueryActiveArea()
{
    return _dxActiveArea;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::QueryDesiredHeight

    SYNOPSIS:   Get height desired by control

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

INT H_SPLITTER_BAR::QueryDesiredHeight()
{
    return 8 * _dyLineWidth;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnLMouseButtonDown

    SYNOPSIS:   Response to a left-mouse-button-down event

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::OnLMouseButtonDown( const MOUSE_EVENT & e )
{
    TRACEEOL( "H_SPLITTER_BAR::OnLMouseButtonDown()" );

    ASSERT(!_fInDrag);

    XYPOINT xy = e.QueryPos(); // n.b. already in client coords

    if (!IsWithinHitZone(xy))
        return FALSE; // let defproc handle it

    MakeDisplayContext( &_pdcDrag );
    if (_pdcDrag == NULL)
    {
        DBGEOL( "H_SPLITTER_BAR::OnLMouseButtonDown: MakeDisplayContext failed" );
        return FALSE;
    }

    // Mousedown took place on the draggable region of an already
    // selected item: initiate the drag proper.

    CaptureMouse();
    _fInDrag = TRUE;
    ShowDragBar( xy );
    ShowSpecialCursor( TRUE );

    return TRUE; // message handled - don't pass along
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnLMouseButtonUp

    SYNOPSIS:   Response to a left-mouse-button-up event

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::OnLMouseButtonUp( const MOUSE_EVENT & e )
{
    TRACEEOL( "H_SPLITTER_BAR::OnLMouseButtonUp()" );

    if (!_fInDrag)
        return FALSE;

    // Clean up from drag-mode

    ShowSpecialCursor( FALSE );
    ClearDragBar();
    _fInDrag = FALSE;
    ReleaseMouse();

    delete _pdcDrag;
    _pdcDrag = NULL;

    OnDragRelease( e.QueryPos() );

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnMouseMove

    SYNOPSIS:   Response to a mouse-move event

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::OnMouseMove( const MOUSE_EVENT & e )
{
    TRACEEOL( "H_SPLITTER_BAR::OnMouseMove()" );

    if (_fInDrag)
    {
        ShowDragBar( e.QueryPos() );
    }

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::IsWithinHitZone

    SYNOPSIS:   Determines whether cursor is inside active area

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::IsWithinHitZone( const XYPOINT & xy )
{
    return _xyrectHitZone.ContainsXY( xy );
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::ShowSpecialCursor

    SYNOPSIS:   Changes to/from special splitter-bar cursor

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::ShowSpecialCursor( BOOL fSpecialCursor )
{
    if ( fSpecialCursor )
    {
        if (_hcurSave == NULL)
        {
            _hcurSave = CURSOR::Query();
            if (_hcurSave == NULL)
            {
                DBGEOL( "H_SPLITTER_BAR::ShowSpecialCursor(): CURSOR::Query failed" );
            }
            else
            {
                CURSOR::Set( _hcurActive );
            }
        }
    }
    else
    {
        if (_hcurSave != NULL)
        {
            CURSOR::Set( _hcurSave );
            _hcurSave = NULL;
        }
    }
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::ShowDragBar

    SYNOPSIS:   Adds/moves drag bar

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::ShowDragBar( const XYPOINT & xyClientCoords )
{
    if ( _fShowingDragBar )
    {
        /*
         *  Do nothing if vertical position has not changed
         */
        if ( xyClientCoords.QueryY() == _xyLastDragPoint.QueryY() )
        {
            return;
        }

        ClearDragBar();
    }

    InvertDragBar( xyClientCoords );
    _xyLastDragPoint = xyClientCoords;
    _fShowingDragBar = TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::ClearDragBar

    SYNOPSIS:   Removes drag bar

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::ClearDragBar()
{
    if ( _fShowingDragBar )
    {
        InvertDragBar( _xyLastDragPoint );
        _fShowingDragBar = FALSE;
    }
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::InvertDragBar

    SYNOPSIS:   Adds/moves drag bar

    CODEWORK:   The appearance of the drag bar is somewhat different from
                WinWord6.  WinWord6 seems to combine a gray bar with what
                is already on screen, then restore the screen contents
                somehow.  I invert the screen contents, which looks more like
                a black bar which turns white over text.

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::InvertDragBar( const XYPOINT & xyClientCoords )
{
    if (_pdcDrag == NULL)
    {
        DBGEOL( " H_SPLITTER_BAR::InvertDragBar(): no DISPLAY_CONTEXT" );
    }
    else
    {
        XYRECT xyrectOwner( WINDOW::QueryOwnerHwnd() );

        ::PatBlt( _pdcDrag->QueryHdc(),
                  0,
                  xyClientCoords.QueryY() - ((_dyLineWidth-1) / 2),
                  xyrectOwner.CalcWidth(),
                  _dyLineWidth,
                  DSTINVERT
                );
    }
}


/*******************************************************************

    NAME:       H_SPLITTER_BAR::OnQMouseCursor

    SYNOPSIS:   Callback determining whether mouse movement should
                change the cursor

    HISTORY:
        jonn        11-Oct-1993 Templated from bltlhour.cxx
        jonn        11-Oct-1993 only hit in active area

********************************************************************/

BOOL H_SPLITTER_BAR::OnQMouseCursor( const QMOUSEACT_EVENT & e )
{
    BOOL fInActiveArea = (e.QueryHitTest() == HTCLIENT);
    if (fInActiveArea)
        CURSOR::Set( _hcurActive );

    return fInActiveArea;
}


/*******************************************************************

    NAME:       H_SPLITTER_BAR::OnQHitTest

    SYNOPSIS:   Callback determining the subloc within a window

    HISTORY:
        jonn        11-Oct-1993 Templated from bltlhour.cxx
        jonn        11-Oct-1993 only hit in active area

********************************************************************/

ULONG H_SPLITTER_BAR::OnQHitTest( const XYPOINT & xy )
{
    XYPOINT xyTmp = xy;
    xyTmp.ScreenToClient( WINDOW::QueryHwnd() );

    return ( IsWithinHitZone(xyTmp) ) ? HTCLIENT : HTNOWHERE;
}


/*******************************************************************

    NAME:       H_SPLITTER_BAR::OnDragRelease

    SYNOPSIS:   Subclasses will redefine this

    HISTORY:
        jonn        11-Oct-1993 Created

********************************************************************/

VOID H_SPLITTER_BAR::OnDragRelease( const XYPOINT & xyClientCoords )
{
    DBGEOL( "H_SPLITTER_BAR::OnDragRelease: why wasn't this redefined??" );
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::Dispatch

    SYNOPSIS:   Main routine to dispatch the event appropriately

    ENTRY:      EVENT event - general event

    CODEWORK:   There should be a common routine to deal with this,
                rather than having so many copies of this code.

    HISTORY:
        jonn        12-Oct-1993 templated from bltcolh.cxx

*********************************************************************/

BOOL H_SPLITTER_BAR::Dispatch( const EVENT &event, ULONG * pnRes )
{
    if ( event.QueryMessage() == WM_ERASEBKGND )
    {
        DWORD dwColor = ::GetSysColor( COLOR_WINDOW );

        HBRUSH hBrush = ::CreateSolidBrush( dwColor );
        ASSERT( hBrush != NULL );

        RECT r;
        QueryClientRect( &r );
        REQUIRE( ::FillRect( (HDC)event.QueryWParam(), &r, hBrush ) != FALSE );

        REQUIRE( ::DeleteObject( hBrush ) != FALSE );

        return TRUE;
    }

    return CUSTOM_CONTROL::Dispatch( event, pnRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltssn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltssn.cxx
        SLE object but only accept number and it will live only in
        a spin button.

    FILE HISTORY:
        terryk      01-May-1991 Created
        beng        18-Sep-1991 prune UIDEBUG clauses
        terryk      07-Oct-1991 Change SendMessage Position
        terryk      11-Nov-1991 change SPIN_ITEM's type from INT to LONG
        terryk      20-Dec-1991 change all the %d to %ld
        beng        05-Mar-1992 Remove all wsprintf usage
        terryk      22-Mar-1992 change LONG to ULONG
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * SPIN_SLE_NUM::_pszClassName = SZ("EDIT");


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SPIN_SLE_NUM

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to owner window
                CID cidEdit - id for the edit field
                CID cidFrame - id for the frame
                ULONG nValue - default value
                ULONG nMin - min value
                ULONG dRange - range
                BOOL fWrap - wrap around boolean flag

    NOTES:      It will pass the information to the SLE and SPIN_ITEM
                parent classes.

    HISTORY:
        terryk      01-May-1991     Created
        beng        31-Jul-1991     Control error reporting changed
        beng        05-Mar-1992     Use DEC_STR

*********************************************************************/

SPIN_SLE_NUM::SPIN_SLE_NUM( OWNER_WINDOW * powin, CID cidEdit, ULONG nValue,
                            ULONG nMin, ULONG dRange, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit ),
      _pbkgndframe( NULL ),
      CHANGEABLE_SPIN_ITEM( this, nValue, nMin, dRange, fWrap)
{
    if ( QueryError() != NERR_Success )
        return;

    if ( cidFrame != -1 )
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        APIERR frameerr = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (frameerr = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSN: bkgndframe error " << frameerr );
            ReportError( frameerr );
            return;
        }
    }

    DEC_STR nlsValue(nValue);
    APIERR err = nlsValue.QueryError();
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    SetText( nlsValue );
    SetMaxInput();

    err = SaveCurrentData();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    Update();
}

SPIN_SLE_NUM::SPIN_SLE_NUM( OWNER_WINDOW * powin, CID cidEdit,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, ULONG nValue,
                            ULONG nMin, ULONG dRange, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit, xy, dxy, flStyle, _pszClassName ),
      _pbkgndframe( NULL ),
      CHANGEABLE_SPIN_ITEM( this, nValue, nMin, dRange, fWrap )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( cidFrame != -1 )
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        APIERR frameerr = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (frameerr = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSN: bkgndframe error " << frameerr );
            ReportError( frameerr );
            return;
        }
    }

    DEC_STR nlsValue(nValue);
    APIERR err = nlsValue.QueryError();
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    SetText( nlsValue );
    SetMaxInput();

    err = SaveCurrentData();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    Update();
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::~SPIN_SLE_NUM

    SYNOPSIS:   destructor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_SLE_NUM::~SPIN_SLE_NUM()
{
      delete _pbkgndframe;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetMaxInput

    SYNOPSIS:   get the max number and find out how many character in it

    HISTORY:
        terryk  10-Jul-1991 Created
        beng    05-Mar=1992 Replaced wsprintf

*********************************************************************/

VOID SPIN_SLE_NUM::SetMaxInput()
{
    DEC_STR nlsMaxVal(QueryMax());
    ASSERT(!!nlsMaxVal);

    SetMaxLength( _cchMaxInput = nlsMaxVal.QueryTextLength() );
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetMin

    SYNOPSIS:   whenever we set min, we need to recompute the max length

    ENTRY:      ULONG nMin - min number

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID SPIN_SLE_NUM::SetMin( const ULONG nMin )
{
    CHANGEABLE_SPIN_ITEM::SetMin( nMin );
    SetMaxInput();
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetRange

    SYNOPSIS:   whenever we set the range, we need to recompute the
                max length

    ENTRY:      ULONG dRange - range

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID SPIN_SLE_NUM::SetRange( const ULONG dRange )
{
    CHANGEABLE_SPIN_ITEM::SetRange( dRange );
    SetMaxInput();
}

/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetSaveValue

    SYNOPSIS:

    ENTRY:

    HISTORY:

*********************************************************************/

APIERR SPIN_SLE_NUM::SetSaveValue( const ULONG nValue )
{
    SetValue( nValue );

    APIERR err;
    DEC_STR nlsFormatted(nValue, (SLE::QueryStyle() & SPIN_SSN_ADD_ZERO)
                                 ? _cchMaxInput : 1 );

    if ( (err = nlsFormatted.QueryError()) == NERR_Success )
    {
        err = SLE::SetSaveValue( nlsFormatted );
    }

    return err;

}

/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnKeyDown

    SYNOPSIS:   When the user hit a key, perform the proper action

    ENTRY:      VKEY_EVENT event - the WM_MESSAGE

    RETURN:     TRUE if the routine handle the character.
                FALSE otherwise

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnKeyDown( const VKEY_EVENT & event )
{
    SPIN_GROUP  * psb = ( SPIN_GROUP * )SPIN_ITEM::QueryGroup();
    switch ( event.QueryVKey() )
    {
    case VK_UP:
        psb->ChangeFieldValue( SPN_INCREASE, event.QueryRepeat() );
        break;

    case VK_DOWN:
        psb->ChangeFieldValue( SPN_DECREASE, event.QueryRepeat() );
        break;

    case VK_PRIOR:
        psb->ChangeFieldValue( SPN_BIGINCREASE, event.QueryRepeat() );
        break;

    case VK_NEXT:
        psb->ChangeFieldValue( SPN_BIGDECREASE, event.QueryRepeat() );
        break;

    case VK_LEFT:
        psb->JumpPrevField();
        break;

    case VK_RIGHT:
        psb->JumpNextField();
        break;

    case VK_HOME:
        psb->SetFieldMinMax( SPN_MIN );
        break;

    case VK_END:
        psb->SetFieldMinMax( SPN_MAX );
        break;

    default:
        return FALSE;
    }
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SaveCurrentData

    SYNOPSIS:   get the current data from the window and set the
                internal variable value

    NOTES:      Assume the data in the window is corrected, save the
                current data

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

APIERR SPIN_SLE_NUM::SaveCurrentData()
{
    SPIN_GROUP * psg = (SPIN_GROUP *) SPIN_ITEM::QueryGroup();

    if ( ( psg != NULL ) && ! psg->IsActive() )
        return NERR_Success;

    NLS_STR nlsValue;

    APIERR err = QueryText( &nlsValue );

    if ( err != NERR_Success )
    {
        CONTROL_WINDOW::ReportError( err );
        return err;
    }

    ULONG nValue;

    if ( nlsValue.strlen() == 0 )
        nValue = QueryValue();
    else
        nValue = nlsValue.atoul();

    INT nCheckRange = CheckRange( nValue );

    nValue = ( nCheckRange < 0 ) ? QueryMin() :
             ( nCheckRange > 0 ) ? QueryMax() : nValue;

    SetValue( nValue );
    Update();
    return err;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::QueryContent

    SYNOPSIS:   Get the current value in the object

    ENTRY:      You can request the value in one of the following forms:
                ULONG * nValue - integer
                NLS_STR *nlsStr - return as a nls string

    EXIT:       return the value to the data structure

    HISTORY:
        terryk  01-May-1991 Created
        beng    05-mar-1992 Replace wsprintf

*********************************************************************/

VOID SPIN_SLE_NUM::QueryContent( ULONG * pnValue ) const
{
    UIASSERT( pnValue != NULL );

    *pnValue = QueryValue() ;
}

VOID SPIN_SLE_NUM::QueryContent( NLS_STR * pnlsStr ) const
{
    ASSERT( pnlsStr != NULL );
    ASSERT( pnlsStr->QueryError() == NERR_Success );

    DEC_STR nlsValue(QueryValue());
    ASSERT(!!nlsValue);

    *pnlsStr = nlsValue;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::DisplayNum

    SYNOPSIS:   set the window text to the given number

    ENTRY:      ULONG nNum - number to be set

    HISTORY:
        terryk      01-May-1991 Created
        beng        16-Oct-1991 Win32 conversion
        beng        05-Mar-1992 Use DEC_STR for formatting
        beng        13-Aug-1992 Hide and show caret appropriately

*********************************************************************/

VOID SPIN_SLE_NUM::DisplayNum( ULONG nValue )
{
    DEC_STR nlsFormatted(nValue, (SLE::QueryStyle() & SPIN_SSN_ADD_ZERO)
                                 ? _cchMaxInput : 1 );
    if (!nlsFormatted) return; // JonN 01/23/00 PREFIX bug 444894

    ::HideCaret(WINDOW::QueryHwnd());
    SetText(nlsFormatted);
    ::ShowCaret(WINDOW::QueryHwnd());
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::Update

    SYNOPSIS:   update the window text

    NOTES:      call DisplayNum to update the number

    HISTORY:
        terryk      01-May-1991 Created
        beng        16-Oct-1991 Win32 conversion
        beng        13-Aug-1992 Send EN_UPDATE and EN_CHANGE correctly
        beng        16-Aug-1992 Disabled EN_UPDATE

*********************************************************************/

VOID SPIN_SLE_NUM::Update()
{
    // CODEWORK: should share code with SPIN_SLE_STR::Update (qv).

#if 0 // Nobody listens for this message, anyway
#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_UPDATE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_UPDATE ) );
#endif
#endif // disabled

    DisplayNum( QueryValue() );

    // Tell the spin group that we are changed

    // CODEWORK - roll this into BLT for proper portability.

#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_CHANGE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_CHANGE ) );
#endif
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnChar

    SYNOPSIS:   The object only accept backspace key and numerical input.
                Other input is sent to the parent - SPIN_GROUP

    ENTRY:      CHAR_EVENT event - character event

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnChar( const CHAR_EVENT & event )
{
    SPIN_GROUP  * pSB = (SPIN_GROUP *)SPIN_ITEM::QueryGroup();

    // check for backspace
    if (event.QueryChar() == VK_BACK )
    {
        pSB->SetModified( TRUE );
        // return FALSE and let the window handle it
        // pretend I do nothing
        return FALSE;
    }
    if (IsCharAlphaNumeric( event.QueryChar() ) &&
        !IsCharAlpha( event.QueryChar()))
    {
        pSB->SetModified( TRUE );
        // return FALSE and let the window handle it
        // pretend I do nothing
        return FALSE;
    }
    if ( QueryAccCharPos( event.QueryChar() ) >= 0 )
    {
        SLE::SetControlValueFocus();
        return TRUE;
    }
    else
    {
        // I don't want this character
        pSB->DoChar( (CHAR_EVENT &)event );
        return TRUE;
    }
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnEnter

    SYNOPSIS:   check for valid when the user hits ENTER

    ENTRY:      CONTROL_EVENT & event

    HISTORY:
                terryk  6-Jun-91    Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnEnter( const CONTROL_EVENT & event )
{
    UNREFERENCED( event );

    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();

    pSB->SetModified( TRUE );
    SaveCurrentData();
    Update();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnDefocus

    SYNOPSIS:   if the object is defocused, save the current data.

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnDefocus( const FOCUS_EVENT &event )
{
    UNREFERENCED( event );

    SaveCurrentData();
    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnFocus

    SYNOPSIS:   if the object is focused, highlight the string in the window

    ENTRY:      FOCUS_EVENT & fEvent

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnFocus( const FOCUS_EVENT &event )
{
    UNREFERENCED( event );

#if 0
    SPIN_GROUP * psg = ( SPIN_GROUP * ) SPIN_ITEM::QueryGroup();
    if ( ( psg != NULL ) && ! psg->IsActive() )
        return FALSE;
#endif

    SLE::SetControlValueFocus();
    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();
    pSB->DoNewFocus( (SPIN_ITEM *)this );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltssnv.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltssnv.cxx

    SLE object but only accept number and it will live only in
    a spin button. It will also check for valid when the object lose
    focus.

    FILE HISTORY:
        terryk      27-Jun-91   Created
        beng        18-Sep-1991 pruned UIDEBUG clauses
        terryk      29-Sep-1991 Does not display the message on error
        terryk      11-Nov-1991 Change SPIN_ITEM's type from INT to LONG
        terryk      20-Dec-1991 Change all the %d to %ld
        terryk      22-Mar-1992 Converted LONG to ULONG
*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::SPIN_SLE_NUM_VALID

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to owner window
                CID cid - id for the object

    NOTES:      It will pass the information to the SLE and SPIN_ITEM
                parent classes.

    HISTORY:
        terryk      01-May-1991     Created
        beng        31-Jul-1991     Control error preorting changed

*********************************************************************/

SPIN_SLE_NUM_VALID::SPIN_SLE_NUM_VALID( OWNER_WINDOW * powin, CID cid,
                                        ULONG nValue, ULONG nMin, ULONG nRange,
                                        BOOL fWrap )
    : SPIN_SLE_NUM( powin, cid, nValue, nMin, nRange, fWrap ),
    _nlsFieldName()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsFieldName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_NUM_VALID::SPIN_SLE_NUM_VALID( OWNER_WINDOW * powin, CID cid,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, ULONG nValue, ULONG nMin, ULONG nRange,
                            BOOL fWrap )
    : SPIN_SLE_NUM( powin, cid, xy, dxy, flStyle, nValue, nMin, nRange, fWrap ),
    _nlsFieldName()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsFieldName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::~SPIN_SLE_NUM_VALID

    SYNOPSIS:   destructor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_SLE_NUM_VALID::~SPIN_SLE_NUM_VALID()
{
    // do nothing
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::CheckValid

    SYNOPSIS:   check whether the field is valid or not. If not,
                then display an error message.

    RETURN:     BOOL - TRUE if valid. FALSE otherwise

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_SLE_NUM_VALID::CheckValid()
{
    BOOL fValid = IsValid();

    if ( ! fValid )
    {
        //DisplayErrorMsg();
    }
    return fValid;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::IsValid

    SYNOPSIS:   handle the special requirement for SPIN_SLE_NUM_VALID

    ENTRY:      HWND hWnd - window handler
                WORD message - message
                WPARAM wParam - word parameter
                LPARAM lParam - LONG paramter

    NOTES:      It is a call back function

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL SPIN_SLE_NUM_VALID::IsValid( )
{
    NLS_STR nlsValue;

    if ( QueryText( & nlsValue ) != NERR_Success )
    {
        return FALSE;
    }

    ULONG nValue;

    if (nlsValue.strlen() != 0 )
    {
        nValue = nlsValue.atoul();
    }
    else
    {
        nValue = QueryValue();
    }

    INT nCheckRange = CheckRange( nValue );
    if ( nCheckRange == 0 )
    {
        return TRUE;
    }
    // fix the data
    nValue = ( nCheckRange < 0 ) ? QueryMin() : QueryMax();
    SetValue( nValue );
    Update();

    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::DisplayErrorMsg

    SYNOPSIS:   display an error message if the field is not valid

    NOTES:
        Does anybody call this?  Can I nuke it?

    HISTORY:
        terryk  10-Jul-1991 Created
        beng    05-Mar-1992 Removed wsprintfs

*********************************************************************/

VOID SPIN_SLE_NUM_VALID::DisplayErrorMsg()
{
    // CODEWORK - what does this do upon failure?  what will it display?

    NLS_STR * apnlsInsert[3] ;
    NLS_STR nlsFieldName;

    if ( _nlsFieldName.strlen() == 0 )
    {
        nlsFieldName.Load( IDS_FIELD );
    }
    else
    {
        nlsFieldName = _nlsFieldName;
    }

    ASSERT(!!nlsFieldName);

    apnlsInsert[0] = &nlsFieldName ;

    DEC_STR nlsMin(QueryMin());
    DEC_STR nlsMax(QueryMax());

    ASSERT(!!nlsMin);
    ASSERT(!!nlsMax);

    apnlsInsert[1] = &nlsMin ;
    apnlsInsert[2] = &nlsMax ;

    ::MessageBeep( 0 );

    MsgPopup( QueryOwnerHwnd(), IDS_BLT_SB_SLENUM_OUTRANGE, MPSEV_INFO, 0,
              MP_OK, apnlsInsert );
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::OnEnter

    SYNOPSIS:   check for valid when the user hits ENTER

    ENTRY:      CONTROL_EVENT & event

    HISTORY:
                terryk  6-Jun-91    Created

*********************************************************************/

BOOL SPIN_SLE_NUM_VALID::OnEnter( const CONTROL_EVENT & event )
{
    UNREFERENCED( event );
    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();

    pSB->SetModified( TRUE );
    if ( CheckValid() != FALSE )
    {
        SaveCurrentData();
    }
    Update();
    return TRUE;
}


BOOL SPIN_SLE_NUM_VALID::OnDefocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );

    if ( CheckValid() != FALSE )
    {
        SaveCurrentData();
    }
    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::SetFieldName

    SYNOPSIS:   set the field name of the item

    ENTRY:      msgid - string table id

    RETURN:     APIERR err - load string error

    HISTORY:
        terryk      10-Jul-1991 Created
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR SPIN_SLE_NUM_VALID::SetFieldName( MSGID msgid )
{
    return _nlsFieldName.Load( msgid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltsslt.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltsslt.cxx
    Source file for SPIN_SLT_SEPARATOR class.
    SPIN_ITEM is the same as SLT. However, it is only used within a
    SPIN_GROUP . It cannot used outside a SPIN_GROUP.

    FILE HISTORY:
	terryk	    8-May-91	Creation
	beng	    18-Sep-1991 Prune UIDEBUG clauses
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * SPIN_SLT_SEPARATOR::_pszClassName = SZ("STATIC");


/*********************************************************************

    NAME:       SPIN_SLT_SEPARATOR::SPIN_SLT_SEPARATOR

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *powin - pointer to the owner window
                CID cid - the current ID for the SPIN_SLT_SEPARATOR object

                For APP_WIN:
                TCHAR * pszText - the initial Text
                ULONG flStyle - the control style
                TCHAR * pszClassName - class name of the control object

    NOTES:      It will call SLT's constructor to create the object.
                Meanwhile, it will also call the STATIC_SPIN_ITEM's
                constructor to setup its properties

    HISTORY:
	terryk	    8-May-91	    Creation
	beng	    31-Jul-1991     Control error reporting changed

*********************************************************************/

SPIN_SLT_SEPARATOR::SPIN_SLT_SEPARATOR( OWNER_WINDOW * powin, CID cid )
    : SLT( powin, cid ),
      STATIC_SPIN_ITEM( this )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    if ( Initialize() != NERR_Success )
    {
	// Init has already reported the error
        return;
    }
}

SPIN_SLT_SEPARATOR::SPIN_SLT_SEPARATOR( OWNER_WINDOW * powin, CID cid,
					const TCHAR * pszText,
					XYPOINT xy, XYDIMENSION dxy,
					ULONG flStyle )
    : SLT( powin, cid, xy, dxy, flStyle, _pszClassName ),
      STATIC_SPIN_ITEM( this )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    SetText( pszText );
    if ( Initialize() != NERR_Success )
    {
        return;
    }
}


/*********************************************************************

    NAME:       SPIN_SLT_SEPARATOR::Initialize

    SYNOPSIS:   Initialize the internal Accelerator key

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

APIERR SPIN_SLT_SEPARATOR::Initialize()
{
    NLS_STR nlsAccKey;
    APIERR  err = GetAccKey( & nlsAccKey );

    if ( err != NERR_Success )
    {
	ReportError( err );
        return err;
    }
    return SetAccKey( nlsAccKey );
}


/*********************************************************************

    NAME:       SPIN_SLT_SEPARATOR::GetAccKey

    SYNOPSIS:   Get the accelerator key. It will always consider the
                first character within the separator as the accelerator
                key.

    ENTRY:      NLS_STR * nlsAccKey - the returned accelerator key string.

    EXIT:       nlsAccKey will contain the accelerator key string

    RETURN:     APIERR err - it will pass the err code to the caller
                             function

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

APIERR SPIN_SLT_SEPARATOR::GetAccKey( NLS_STR * pnlsAccKey )
{
    UIASSERT( pnlsAccKey != NULL );

    APIERR err = QueryText( pnlsAccKey );
    if ( err != NERR_Success )
    {
        return pnlsAccKey->QueryError();
    }

    ISTR istrPosition( *pnlsAccKey );

    // we just need the first character
    ++istrPosition;
    pnlsAccKey->DelSubStr( istrPosition );
    return pnlsAccKey->QueryError();
}


/*******************************************************************

    NAME:       SPIN_SLT_SEPARATOR::OnCtlColor

    SYNOPSIS:   Dialogs pass WM_CTLCOLOR* here

    RETURNS:    brush handle if you handle it

    HISTORY:
        jonn        05-Sep-1995 Created

********************************************************************/
HBRUSH SPIN_SLT_SEPARATOR::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    UNREFERENCED( hdc );
    UNREFERENCED( hwnd );
    ASSERT( pmsgid != NULL && *pmsgid == WM_CTLCOLORSTATIC );

    // Use same background color handling as an edit control
    *pmsgid = WM_CTLCOLOREDIT;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltspobj.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    spinobj.cxx
    Spin button object source file.

    This file contain some spin button object as:
	DISK_SPACE_SUBCLASS

    FILE HISTORY:
	terryk	    30-Jun-91	Created
	terryk	    05-Aug-91	Add initial status parameter to the object
	terryk	    30-Aug-91	Code review changes.
				Attend: o-simop davidbul beng
	terryk	    11-Nov-91	change SPIN_ITEM's type from INT to LONG
	terryk	    17-Apr-92	changed LONG to ULONG

*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::SPIN_SLE_VALID_SECOND

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - owner window
		CID cid - cid of the spin item
		const TCHAR * pszFieldName - field name ( NULL is default)
		LONG nValue - the initial value
		LONG nMin - min value
		LONG nRange - the range
		LONG nSecondInc - Increase figure
		BOOL fWrap - wrap around or not

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

SPIN_SLE_VALID_SECOND::SPIN_SLE_VALID_SECOND(OWNER_WINDOW * powin, CID cid,
    LONG nValue, LONG nMin, LONG nRange, LONG nSecondInc, BOOL fWrap )
    : SPIN_SLE_NUM_VALID( powin, cid, nValue, nMin, nRange, fWrap ),
    _nSecondInc( nSecondInc )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
    SetBigIncValue( _nSecondInc );
    SetSmallIncValue( _nSecondInc );
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QuerySmallIncValue

    SYNOPSIS:   return the small increase value. It is the different
		between nearest multiple of the _nSecondInc and the
		current value.

    RETURN:     the nearest multiple of _nSecondInc

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QuerySmallIncValue() const
{
    return _nSecondInc - (LONG)QueryValue() % _nSecondInc;
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QueryBigIncValue

    SYNOPSIS:   the same as QuerySmallIncValue

    RETURN:     the different between the nearest number of the multiple
		of _nSecondInc and the current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QueryBigIncValue() const
{
    return QuerySmallIncValue();
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QuerySmallDecValue

    SYNOPSIS:   return the different between the nearest multiple of
		_nSecondInc, which is below the current value, and the
		current value.

    RETURN:     the different between the current value and the
		nearest multiple of _nSecondInc which is below
		the current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QuerySmallDecValue() const
{
    LONG nNum = (LONG)QueryValue() % _nSecondInc;

    return ( nNum == 0 ) ? _nSecondInc : nNum;
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QueryBigDecValue

    SYNOPSIS:   same as QuerySmallDecValue

    RETURN:     return the different between the current value and the
		nearest multiple of _nSecondInc which is below
		the current value.

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QueryBigDecValue() const
{
    return QuerySmallDecValue();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::ELAPSED_TIME_CONTROL

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * pointer to the owner window
		CID cidMinute - minute field cid
		CID cidSeparator - sepaprator field cid
		CID cidSecond - second field cid
		CID cidSpinButton - spin button cid
		CID cidUpArrow - up arrow cid
		CID cidDownArrow - down arrow cid
		SLT &sltMinute - associated minute string
		LONG nMinuteDefault - default value of the minute field
		LONG nMinuteMin - min value of the minute field
		LONG dMinuteRange - the range of the minute field
		SLT &sltSeparator - associate separator string
		SLT &sltSecond - associate second string
		LONG nSecondDefault - default second field value
		LONG nSecondMin - min second value
		LONG dSecondRange - the range of the second field
		LONG nSecondInc - Increase second value
		BOOL fActive - initial status of the button

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ELAPSED_TIME_CONTROL::ELAPSED_TIME_CONTROL(
	OWNER_WINDOW * powin,
        CID cidMinute,
        CID cidSeparator,
        CID cidSecond,
        CID cidSpinButton,
        CID cidUpArrow,
        CID cidDownArrow,
        SLT & sltMinute,
        LONG nMinuteDefault,
        LONG nMinuteMin,
        LONG dMinuteRange,
        SLT & sltSeparator,
        SLT & sltSecond,
        LONG nSecondDefault,
        LONG nSecondMin,
        LONG dSecondRange,
	LONG nSecondInc,
	BOOL fActive )
    : SPIN_GROUP( powin, cidSpinButton, cidUpArrow, cidDownArrow, fActive ),
    _spsleMinute( powin, cidMinute, nMinuteDefault, nMinuteMin,
                  dMinuteRange ),
    _spsltSeparator( powin, cidSeparator ),
    _spsleSecond( powin, cidSecond, nSecondDefault, nSecondMin,
                  dSecondRange, nSecondInc )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }

    // set the Accelator key
    APIERR err = SetSpinItemAccKey( & _spsleMinute, sltMinute, 1 );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = SetSpinItemAccKey( & _spsltSeparator, sltSeparator, 0 );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = SetSpinItemAccKey( & _spsleSecond, sltSecond, 1 );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ((( err = AddAssociation( & _spsleMinute )) != NERR_Success ) ||
	(( err = AddAssociation( & _spsltSeparator )) != NERR_Success ) ||
    	(( err = AddAssociation( & _spsleSecond )) != NERR_Success ))
    {
	ReportError( err );
	return;
    }
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSpinItemAccKey

    SYNOPSIS:   set the spin items' accelerator key.
		Get the first character of each of the associate SLT
		string and set them as the accelerator key

    ENTRY:      SPIN_ITEM * psi - spin item to be associated
		SLT & slt - the slt string which contains the
		    accelerator key
		INT cchPos - the accelerator key position

    EXIT:       NERR_Success if success. Otherwise it is failure.

    HISTORY:
		terryk	29-Jun-1991	Created

*********************************************************************/

APIERR ELAPSED_TIME_CONTROL::SetSpinItemAccKey( SPIN_ITEM * psi, SLT & slt,
    INT cchPos )
{
    NLS_STR nlsAccKey;

    APIERR err = slt.QueryText( & nlsAccKey );

    if ( err != NERR_Success )
    {
        DBGEOL( SZ("ELAPSED_TIME_CONTROL: constructor failed.") );
        return err;
    }

    ISTR istrFirstChar( nlsAccKey );
    istrFirstChar += cchPos;

    ISTR istrSecondChar = istrFirstChar;
    ++istrSecondChar;

    NLS_STR *pnlsTemp = nlsAccKey.QuerySubStr( istrFirstChar, istrSecondChar );
    if (NULL == pnlsTemp)
        return ERROR_NOT_ENOUGH_MEMORY; // JonN 01/27/00 PREFIX bug 444899

    if ((( err = pnlsTemp->QueryError()) != NERR_Success ) ||
    	(( err = psi->SetAccKey( *pnlsTemp )) != NERR_Success ))
    {
	DBGEOL( SZ("ELAPSED_TIME_CONTROL: constructor failed.") );
    }

    delete pnlsTemp;

    return err;
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetMinuteMin

    SYNOPSIS:   set the minute field min value

    ENTRY:      const LONG nMin - min value to be set

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteMin( const LONG nMin )
{
    _spsleMinute.SetMin( nMin );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetMinuteRange

    SYNOPSIS:   set the minute field range

    ENTRY:      const LONG dRange - the new range value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteRange( const LONG dRange )
{
    _spsleMinute.SetRange( dRange );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSecondMin

    SYNOPSIS:   set the second field min value

    ENTRY:      const LONG nMin - min value number

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondMin( const LONG nMin )
{
    _spsleSecond.SetMin( nMin );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSecondRange

    SYNOPSIS:   set the second field range value

    ENTRY:      const LONG dRange - the new range value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondRange( const LONG dRange )
{
    _spsleSecond.SetRange( dRange );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetMinuteValue

    SYNOPSIS:   set the minute field current value

    ENTRY:      const LONG nMinute - new current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteValue( const LONG nMinute )
{
    _spsleMinute.SetValue( nMinute );
    _spsleMinute.Update();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSecondValue

    SYNOPSIS:   set the second field current value

    ENTRY:      const LONG nSecond - new current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondValue( const LONG nSecond )
{
    _spsleSecond.SetValue( nSecond );
    _spsleSecond.Update();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::QueryMinuteValue

    SYNOPSIS:   get the minute field current value

    RETURN:     current minute field value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

LONG ELAPSED_TIME_CONTROL::QueryMinuteValue() const
{
    return _spsleMinute.QueryValue();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::QuerySecondValue

    SYNOPSIS:   get the second field current value

    RETURN:     current second field value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

LONG ELAPSED_TIME_CONTROL::QuerySecondValue() const
{
    return _spsleSecond.QueryValue();
}


/*******************************************************************

    NAME:	ELAPSED_TIME_CONTROL::SetMinuteFieldName

    SYNOPSIS:	If the Minute field's value is too big or too small, it
		will display a message as:
			The XXXX field value is invalid
		This function will set the string XXXX in the display
		message.

    ENTRY:	USHORT uIDS - id number of the string in the string
		table

    HISTORY:
	terryk	    30-Aug-91	Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteFieldName( MSGID msgid )
{
    _spsleMinute.SetFieldName( msgid );
}


/*******************************************************************

    NAME:	ELAPSED_TIME_CONTROL::SetSecondFieldName

    SYNOPSIS:	If the Second field's value is too big or too small, it
		will display a message as:
			The XXXX field value is invalid
		This function will set the string XXXX in the display
		message.

    ENTRY:	USHORT uIDS - id number of the string in the string
		table

    HISTORY:
	terryk	    30-Aug-91	Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondFieldName( MSGID msgid )
{
    _spsleSecond.SetFieldName( msgid );
}


/*********************************************************************

    NAME:       DISK_SPACE_SUBCLASS::DISK_SPACE_SUBCLASS

    SYNOPSIS:   Disk space subclass constructor

    ENTRY:      OWNER_WINDOW * powin - owner window pointer
                CID cidSpinButton    - cid for the spin button
                CID cidUpArrow       - cid for the up arrow
                CID cidDownArrow     - cid for the down arrow
                CID cidDiskSpace     - cid for the disk space item
                CID cidUnit          - cid for the Unit item
		LONG nInitDkSp	     - Inital value of the disk space field
		LONG nMinDkSp 	     - Min value of the disk space field
		LONG nRangeDkSp	     - the range of disk space field
		LONG nStartUnit       - the ID of the first string for
				       the unit field
		LONG nUnit 	     - Number of the unit string
		BOOL fActive	     - initial status of the
					DISK_SPACE_SUBCLASS

    HISTORY:
                terryk  20-Jun-1991 Created

*********************************************************************/

DISK_SPACE_SUBCLASS::DISK_SPACE_SUBCLASS( OWNER_WINDOW * powin,
	CID cidSpinButton, CID cidUpArrow, CID cidDownArrow,
	CID cidDiskSpace, CID cidUnit,
	LONG nInitDkSp, LONG nMinDkSp, LONG nRangeDkSp,
	LONG nStartUnit, LONG nUnit,
	BOOL fActive )
    : SPIN_GROUP( powin, cidSpinButton, cidUpArrow, cidDownArrow, fActive),
    _spsleDiskSpace( powin, cidDiskSpace, nInitDkSp, nMinDkSp, nRangeDkSp ),
    _spsleUnit( powin, cidUnit, nStartUnit, nUnit ),
    _nStartUnit( nStartUnit )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }

    APIERR err;

    if ((( err = AddAssociation( & _spsleDiskSpace )) != NERR_Success ) ||
	(( err = AddAssociation( & _spsleUnit )) != NERR_Success ))
    {
	ReportError( err );
	UIASSERT( !SZ("DISK_SPACE_SUBCLASS error: assoication failure.\n"));
	return;
    }
}


/*******************************************************************

    NAME:	DISK_SPACE_SUBCLASS::SetDSFieldName

    SYNOPSIS:	If the disk spaec field's value is too big or too small, it
		will display a message as:
			The XXXX field value is invalid
		This function will set the string XXXX in the display
		message.

    ENTRY:	USHORT uIDS - id number of the string in the string
		table

    HISTORY:
	terryk	    30-Aug-91	Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

VOID DISK_SPACE_SUBCLASS::SetDSFieldName( MSGID msgid )
{
    _spsleDiskSpace.SetFieldName( msgid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\blttd.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    blttd.cxx
    BLT time/date control object

    FILE HISTORY:
        terryk      01-Jun-91   Created
        terryk      11-Jul-91   Make it to a group
        terryk      12-Aug-91   Create its own timer and change the spacing
        terryk      29-Aug-91   Code review changes
        terryk      11-Nov-91   Change SPIN_ITEM's return type from INT to LONG
        terryk      26-Nov-91   Added Update to the AMPM field
        terryk      17-Apr-92   changed LONG to ULONG
        beng        13-Aug-1992 Disabled unused TIME_DATE_DIALOG
        YiHsinS	    15-Dec-1992 Use SelectFont and call QueryTextWidth only
				if the string is non-empty
*/

#include "pchblt.hxx"  // Precompiled header


#if defined(DEBUG) && 0
static DBGSTREAM & operator<< (DBGSTREAM & dbg, const XYPOINT & xy)
{
    dbg << "(x = " << xy.QueryX()
        << ", y = " << xy.QueryY()
        << ")";
    return dbg;
}

static DBGSTREAM & operator<< ( DBGSTREAM & dbg, const XYDIMENSION & dxy)
{
    dbg << "(dx = " << dxy.QueryWidth()
        << ", dy = " << dxy.QueryHeight()
        << ")";
    return dbg;
}
#endif // DEBUG


/*
 * CalcMaxDigitWidth
 * Determine the width of the widest digit, taking proportional fonts
 * into account.
 *
 * HISTORY
 *      beng     13-Aug-1992 Written (design stolen from control panel)
 */

static INT CalcMaxDigitWidth( const DEVICE_CONTEXT & dc )
{
    INT adxDigit[10];

    ASSERT( ('9' - '0' + 1) == (sizeof(adxDigit)/sizeof(adxDigit[0])) );

    if (! ::GetCharWidth(dc.QueryHdc(), (UINT)'0', (UINT)'9', adxDigit) )
    {
        DBGEOL("BLT: GetCharWidth failed, very bad");

        // Make a last desperate try

        TEXTMETRIC tm;
        REQUIRE( dc.QueryTextMetrics(&tm) );
        return tm.tmMaxCharWidth;
    }

    INT * pdxDigit;
    INT   dxMax;
    for (pdxDigit = adxDigit+1, dxMax = adxDigit[0];
         pdxDigit < adxDigit+10;
         pdxDigit++)
    {
        if (*pdxDigit > dxMax)
            dxMax = *pdxDigit;
    }

    return dxMax;
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::BLT_TIME_SPIN_GROUP

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *powin - owner window
                CID cidTimeControl - the group box for the time control
                CID cidSpinButton - the spin button control
                CID cidUpArrow - up arrow object
                CID cidDownArrow - down arrow object
                CID cidHour - hour object
                CID cidSeparator1 - separator object 1
                CID cidMin - minute object
                CID cidSeparator2 - the second separator
                CID cidSec - second object
                CID cidAMPM - AM/PM indicator
    NOTES:

    HISTORY:
        terryk       1-Jun-91   Created
        beng        31-Jul-1991 Control error reporting changed
        beng        13-Aug-1992 Change size calculations

*********************************************************************/

BLT_TIME_SPIN_GROUP::BLT_TIME_SPIN_GROUP( OWNER_WINDOW *powin,
                                          const INTL_PROFILE &intlprof,
                                          CID cidSpinButton,
                                          CID cidUpArrow,
                                          CID cidDownArrow,
                                          CID cidHour,
                                          CID cidTimeSep1,
                                          CID cidMin,
                                          CID cidTimeSep2,
                                          CID cidSec,
                                          CID cidAMPM,
                                          CID cidFrame )
    : CONTROL_GROUP(),
    _sbControl( powin, cidSpinButton, cidUpArrow, cidDownArrow, TRUE ),
    _ssnHour( powin, cidHour, 0, 0, 24 ),
    _ssltSeparator1( powin, cidTimeSep1),
    _ssnMin( powin, cidMin, 0, 0, 60 ),
    _ssltSeparator2( powin, cidTimeSep2 ),
    _ssnSec( powin, cidSec, 0, 0, 60 ),
    _psssAMPM( NULL ),
    _bkgndFrame( powin, cidFrame ),
    _f24Hour( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    NLS_STR nlsAM;
    NLS_STR nlsPM;
    NLS_STR nlsTimeSep;
    APIERR err;

    if ((( err = _sbControl.QueryError()) != NERR_Success ) ||
        (( err = _ssnHour.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator1.QueryError()) != NERR_Success ) ||
        (( err = _ssnMin.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator2.QueryError()) != NERR_Success ) ||
        (( err = _ssnSec.QueryError()) != NERR_Success ) ||
        (( err = _bkgndFrame.QueryError()) != NERR_Success ) ||
        (( err = intlprof.QueryAMStr( & nlsAM )) != NERR_Success ) ||
        (( err = intlprof.QueryPMStr( & nlsPM )) != NERR_Success ) ||
        (( err = intlprof.QueryTimeSeparator( & nlsTimeSep )) != NERR_Success ))
    {
        ReportError( err );
        return;
    }

    _f24Hour = intlprof.Is24Hour();

    BOOL	_fTimePrefix = intlprof.IsTimePrefix(); // DBCS only

    // Find out the location of the controls

    DISPLAY_CONTEXT dc( powin->QueryHwnd() );
    dc.SelectFont( _ssnHour.QueryFont() );

    INT dAMPM = 0;

    if ( !_f24Hour )
    {
        INT dxAM = 0;
        INT dxPM = 0;

        if ( nlsAM.QueryTextLength() > 0 )
            dxAM = dc.QueryTextWidth(nlsAM);

        if ( nlsPM.QueryTextLength() > 0 )
            dxPM = dc.QueryTextWidth(nlsPM);

        dAMPM = ((dxAM > dxPM) ? dxAM : dxPM);
    }

    INT dxDigitMax = CalcMaxDigitWidth(dc);
    dxDigitMax += 1; // FE_SB looks nice...
    INT dyLine  = dc.QueryFontHeight();

    // distance for 2 numbers
    INT dTwoNum = 2 * dxDigitMax;

    // distance to use to right of fields
    INT dxRightFudge = dxDigitMax/4;

    // distance to use from the left of fields
    INT dxLeftFudge = dxDigitMax/8;

    // distance for the separator
    INT dTimeSep = dc.QueryTextWidth(nlsTimeSep);

    // spin button control location
    XYPOINT xyTime      = _sbControl.QueryPos();
    xyTime.SetX( xyTime.QueryX() - dxRightFudge);
    XYDIMENSION dxyTime = _sbControl.QuerySize();

    // AMPM location
    if( !NETUI_IsDBCS() || !_fTimePrefix )	xyTime.SetX( xyTime.QueryX() - dAMPM );
    if ( dxyTime.QueryHeight() > (UINT) dyLine )
    {
        xyTime.SetY( xyTime.QueryY()
                     + ( (dxyTime.QueryHeight() / 2) - (dyLine / 2) ));
        dxyTime.SetHeight( dyLine );
    }
    dxyTime.SetWidth( dAMPM );
    XYPOINT xyAMPM( xyTime.QueryX(), xyTime.QueryY() );
    XYDIMENSION dxyAMPM = dxyTime;

    // Second location
    if( NETUI_IsDBCS() && _fTimePrefix )
        xyTime.SetX( xyTime.QueryX() - dTwoNum );
     else
        xyTime.SetX( xyTime.QueryX() - dTwoNum - dxRightFudge );
    dxyTime.SetWidth( dTwoNum );
    XYPOINT xySec( xyTime.QueryX() + dxLeftFudge, xyTime.QueryY() );
    XYDIMENSION dxySec = dxyTime;

    // Separator location
    xyTime.SetX( xyTime.QueryX() - dTimeSep );
    dxyTime.SetWidth( dTimeSep + dxLeftFudge );
    XYPOINT xySep2 = xyTime;
    XYDIMENSION dxySep2 = dxyTime;

    // Minute location
    xyTime.SetX( xyTime.QueryX() - dTwoNum - dxRightFudge );
    dxyTime.SetWidth( dTwoNum );
    XYPOINT xyMin( xyTime.QueryX() + dxLeftFudge, xyTime.QueryY() );
    XYDIMENSION dxyMin = dxyTime;

    // Separator 1 location
    xyTime.SetX( xyTime.QueryX() - dTimeSep );
    dxyTime.SetWidth( dTimeSep + dxLeftFudge );
    XYPOINT xySep1 = xyTime;
    XYDIMENSION dxySep1 = dxyTime;

    // Hour location
    xyTime.SetX( xyTime.QueryX() - dTwoNum - dxRightFudge );
    dxyTime.SetWidth( dTwoNum );
    XYPOINT xyHour( xyTime.QueryX() + dxLeftFudge, xyTime.QueryY() );
    XYDIMENSION dxyHour = dxyTime;

    if( NETUI_IsDBCS() && _fTimePrefix )
    {
        xyTime.SetX( xyTime.QueryX() - dAMPM - dxRightFudge );
        xyAMPM.SetX( xyTime.QueryX() + dxLeftFudge );
    }

    // construction of the object

    // NOTE that when checking each of these included objects' construction
    // status, if it has an error state visible to us then it has already
    // forwarded its error state into us.  Hence we need only return.

    if (intlprof.IsHourLZero())
        _ssnHour.SetStyle( _ssnHour.QueryStyle() | SPIN_SSN_ADD_ZERO );
    _ssnHour.SetPos( xyHour );
    _ssnHour.SetSize( dxyHour);

    // iTime: 0 - 12 hours time
    //        1 - 24 hours time
    if ( _f24Hour )
    {
        _ssnHour.SetMin( 0 );
        _ssnHour.SetRange( 24 );
    }
    else
    {
        _ssnHour.SetMin( 1 );
        _ssnHour.SetRange( 12 );
    }

    _ssnHour.SetValue( 12 ); // since we init as 2 digits, and I don't
                             // want it to change alignment visibly

    _ssltSeparator1.SetText( nlsTimeSep.QueryPch());
    _ssltSeparator1.SetPos( xySep1 );
    _ssltSeparator1.SetSize( dxySep1 );

    _ssnMin.SetStyle( _ssnMin.QueryStyle() | SPIN_SSN_ADD_ZERO );
    _ssnMin.SetPos( xyMin );
    _ssnMin.SetSize( dxyMin );

    _ssltSeparator2.SetText( nlsTimeSep.QueryPch());
    _ssltSeparator2.SetPos( xySep2 );
    _ssltSeparator2.SetSize( dxySep2 );

    _ssnSec.SetStyle( _ssnSec.QueryStyle() | SPIN_SSN_ADD_ZERO );
    _ssnSec.SetPos( xySec );
    _ssnSec.SetSize( dxySec );

    // Show the objects
    _ssnHour.Show();
    _ssltSeparator1.Show();
    _ssnMin.Show();
    _ssltSeparator2.Show();
    _ssnSec.Show();

    _sbControl.SetGroup( this );

    // Associate the objects
    if ((( err = _sbControl.AddAssociation( &_ssnHour )) != NERR_Success) ||
        (( err = _sbControl.AddAssociation( &_ssltSeparator1 )) != NERR_Success ) ||
        (( err = _sbControl.AddAssociation( &_ssnMin )) != NERR_Success) ||
        (( err = _sbControl.AddAssociation( &_ssltSeparator2 )) != NERR_Success ) ||
        (( err = _sbControl.AddAssociation( &_ssnSec )) != NERR_Success))
    {
        ReportError( err );
        DBGEOL("BLT_TIME_SPIN_GROUP: construction failure.");
        return;
    }

    // do we need the AMPM field?
    if ( !_f24Hour )
    {
        // Yes!
        const TCHAR *apszAMPMtemp[3];
        apszAMPMtemp[0] = nlsAM.QueryPch();
        apszAMPMtemp[1] = nlsPM.QueryPch();
        apszAMPMtemp[2] = NULL;

        _psssAMPM = new SPIN_SLE_STR ( powin, cidAMPM, apszAMPMtemp, 2 );

        if ( IsConstructionFail( _psssAMPM ))
        {
            return;
        }

        _psssAMPM->SetPos( xyAMPM, FALSE, &_ssnSec );
        _psssAMPM->SetSize( dxyAMPM, FALSE );
        _psssAMPM->SetBigIncValue( 1 );
        _psssAMPM->SetBigDecValue( 1 );
        _psssAMPM->Enable();
        _psssAMPM->ShowFirst();

        if (( err = _sbControl.AddAssociation( _psssAMPM )) != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }


    // Set the field name
    if ((( err = _ssnHour.SetFieldName( IDS_HOUR )) != NERR_Success ) ||
        (( err = _ssnMin.SetFieldName( IDS_MIN )) != NERR_Success ) ||
        (( err = _ssnSec.SetFieldName( IDS_SEC )) != NERR_Success ))
    {
        ReportError( err );
        DBGEOL("BLT_TIME_SPIN_GROUP: construction failure.");
        return;
    }
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::~BLT_TIME_SPIN_GROUP

    SYNOPSIS:   destructor

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BLT_TIME_SPIN_GROUP::~BLT_TIME_SPIN_GROUP()
{
    delete _psssAMPM;
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::IsConstructionFail

    SYNOPSIS:   check whether the contrustion of the control is succeed
                or not. If not, then ReportError and UIASSERT.

    ENTRY:      CONTROL_WINDOW * pwin - control window to be test

    RETURNS:    BOOL. TRUE for failure and FALSE for succeed

    HISTORY:
        terryk      29-Aug-91   Created
        beng        13-Aug-1992 Copy from BLT_DATE_SPIN_GROUP

********************************************************************/

BOOL BLT_TIME_SPIN_GROUP::IsConstructionFail( CONTROL_WINDOW * pwin)
{
    APIERR err = (pwin == NULL)
                 ? ERROR_NOT_ENOUGH_MEMORY
                 : pwin->QueryError();

    if (err != NERR_Success)
    {
        ReportError( err );
        DBGEOL("BLT_TIME_SPIN_GROUP: construction failed.");
        return TRUE;
    }

    return FALSE;
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SaveValue

    SYNOPSIS:   Save the current value in the Hour, Min, Sec fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SaveValue( BOOL fInvisible )
{
    _sbControl.SaveValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::RestoreValue

    SYNOPSIS:   Restore the current value in the Hour, Min, Sec fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::RestoreValue( BOOL fInvisible )
{
    _sbControl.RestoreValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetControlValueFocus

    SYNOPSIS:   Set the current focus

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetControlValueFocus()
{
    _sbControl.SetControlValueFocus();
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::IsValid

    SYNOPSIS:   check whether the data in the spin button is valid or not

    RETURN:     TRUE if the data is valid. FALSE otherwise

    NOTES:      Since the SPIN_SLE_NUM type will check the input,
                we can ensure that the data is always correct

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BOOL BLT_TIME_SPIN_GROUP::IsValid()
{
    return TRUE;
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetCurrentTime

    SYNOPSIS:   update the data within the spin button to set it to
                the current time

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

APIERR BLT_TIME_SPIN_GROUP::SetCurrentTime()
{
    WIN_TIME winTime;
    APIERR err;
    if (  ((err = winTime.QueryError()) == NERR_Success )
       && ((err = winTime.SetCurrentTime()) == NERR_Success )
       )
    {
        SetHour( winTime.QueryHour());
        SetMinute( winTime.QueryMinute());
        SetSecond( winTime.QuerySecond());
        SetControlValueFocus();
    }

    return err;
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::QueryHour

    SYNOPSIS:   return the current hour in 24 hour format

    RETURN:     return the hour

    HISTORY:
                terryk  13-Jul-91   Created

*********************************************************************/

INT BLT_TIME_SPIN_GROUP::QueryHour() const
{
    if ( _f24Hour )
    {
        // 24 hour
        return (INT)_ssnHour.QueryValue();
    }

    return (INT)( _ssnHour.QueryValue() % 12 + _psssAMPM->QueryValue() * 12);
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::QueryMin

    SYNOPSIS:   return the minute value

    RETURN:     return the minute value

    HISTORY:
                terryk  13-Jul-91   Created

*********************************************************************/

INT BLT_TIME_SPIN_GROUP::QueryMin() const
{
    return (INT)_ssnMin.QueryValue();
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::QuerySec

    SYNOPSIS:   return the second value

    RETURN:     return the second value

    HISTORY:
                terryk  13-Jul-91   Created

*********************************************************************/

INT BLT_TIME_SPIN_GROUP::QuerySec() const
{
    return (INT)_ssnSec.QueryValue();
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetHour

    SYNOPSIS:   set the hour field value

    ENTRY:      the new hour value

    HISTORY:
        terryk      29-Aug-91   Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetHour( INT nHour )
{
    UIASSERT(( nHour > -1 ) && ( nHour < 25 ));

    if ( _f24Hour )
    {
        _ssnHour.SetValue( nHour );
    }
    else
    {
        _psssAMPM->SetValue((( nHour < 12 ) || ( nHour == 24 ))? 0 : 1 );
        _psssAMPM->Update();

        nHour = nHour % 12;
        nHour = ( nHour == 0 ) ? 12 : nHour ;
        _ssnHour.SetValue( nHour );
    }
    _ssnHour.Update();
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetMinute

    SYNOPSIS:   set the minute field value

    ENTRY:      the new minute value

    HISTORY:
                terryk  29-Aug-91       Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetMinute( INT nMinute )
{
    UIASSERT(( nMinute > -1 ) && ( nMinute < 61 ));
    _ssnMin.SetValue( nMinute );
    _ssnMin.Update();
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetSecond

    SYNOPSIS:   set the second field value

    ENTRY:      the new second value

    HISTORY:
                terryk  29-Aug-91       Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetSecond( INT nSecond )
{
    UIASSERT(( nSecond > -1 ) && ( nSecond < 61 ));
    _ssnSec.SetValue( nSecond );
    _ssnSec.Update();
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::BLT_DATE_SPIN_GROUP

    SYNOPSIS:   constructor

    NOTES:      Same as BLT_TIME_SPIN_GROUP, we have 2 types of contrustor.
                One for dialog box and the other one for the app window.

    HISTORY:
        terryk      1-Jun-91    Created
        beng        13-Aug-1992 Min year now 1980

*********************************************************************/

BLT_DATE_SPIN_GROUP::BLT_DATE_SPIN_GROUP( OWNER_WINDOW *powin,
                                          const INTL_PROFILE & intlprof,
                                          CID cidSpinButton,
                                          CID cidUpArrow,
                                          CID cidDownArrow,
                                          CID cidMonth,
                                          CID cidSeparator1,
                                          CID cidDay,
                                          CID cidSeparator2,
                                          CID cidYear,
                                          CID cidFrame)
    : CONTROL_GROUP(),
    _sbControl( powin, cidSpinButton, cidUpArrow, cidDownArrow, TRUE ),
    _ssnMonth( powin, cidMonth, 1, 1, 12 ),
    _ssltSeparator1( powin, cidSeparator1 ),
    _ssnDay( powin, cidDay, 1, 1, 31 ),
    _ssltSeparator2( powin, cidSeparator2 ),
    _ssnYear( powin, cidYear, 0, 0, 100 ), // assume !fYrCentury
    _bkgndFrame( powin, cidFrame ),
    _fYrCentury( intlprof.IsYrCentury() )
{
    if ( QueryError() )
        return;

    APIERR err;

    if ((( err = _sbControl.QueryError()) != NERR_Success ) ||
        (( err = _ssnMonth.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator1.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator2.QueryError()) != NERR_Success ) ||
        (( err = _ssnDay.QueryError()) != NERR_Success ) ||
        (( err = _ssnYear.QueryError()) != NERR_Success ) ||
        (( err = _bkgndFrame.QueryError()) != NERR_Success ))
    {
        ReportError( err );
        return;
    }

    if (_fYrCentury)
    {
        _ssnYear.SetRange(100);
        _ssnYear.SetMin(1980);
        _ssnYear.SetValue(1980);
    }

    NLS_STR nlsDateSep;
    if (( err = intlprof.QueryDateSeparator( & nlsDateSep )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    DISPLAY_CONTEXT dc( powin->QueryHwnd() );
    dc.SelectFont( _ssnMonth.QueryFont() );

    INT dxDigitMax = CalcMaxDigitWidth(dc);
    dxDigitMax += 1; // FE_SB looks nice...
    INT dyLine  = dc.QueryFontHeight();

    INT dTwoNum = 2 * dxDigitMax;
    INT dFourNum = 4 * dxDigitMax;
    INT dxRightFudge = dxDigitMax/4;
    INT dxLeftFudge = dxDigitMax/8;
    INT dDateSep = dc.QueryTextWidth(nlsDateSep);

    // find out all the position
    XYPOINT xyDate      = _sbControl.QueryPos();
    xyDate.SetX( xyDate.QueryX() - dxRightFudge );
    XYDIMENSION dxyDate = _sbControl.QuerySize();

    if ( dxyDate.QueryHeight() > (UINT) dyLine )
    {
        xyDate.SetY( xyDate.QueryY()
                     + ( (dxyDate.QueryHeight() / 2) - (dyLine / 2) ));
        dxyDate.SetHeight( dyLine );
    }

    INT dYearSize = _fYrCentury ? dFourNum : dTwoNum ;
    INT dxFieldThree = (intlprof.QueryYearPos() == 3) ? dYearSize : dTwoNum;

    // Find year field

    INT xWork = xyDate.QueryX();
    switch (intlprof.QueryYearPos())
    {
    case 1:
        xWork -= dTwoNum + dDateSep + dxRightFudge;
        // fall through
    case 2:
        xWork -= dTwoNum + dDateSep + dxRightFudge;
        // fall through
    case 3:
        xWork -= dYearSize + dxRightFudge;
        break;
    }

    XYPOINT     xyYear(xWork+dxLeftFudge, xyDate.QueryY());
    XYDIMENSION dxyYear( dYearSize, dxyDate.QueryHeight());

    // Find first separator

    xWork = xyDate.QueryX() - dDateSep*2 - dTwoNum - dxRightFudge*2;
    xWork -= (intlprof.QueryYearPos() == 1) ? dTwoNum : dYearSize;

    XYPOINT     xySep1( xWork, xyDate.QueryY());
    XYDIMENSION dxySep1( dDateSep + dxLeftFudge, dxyDate.QueryHeight());

    // Find month field

    xWork = xyDate.QueryX() - dTwoNum - dxRightFudge;
    switch (intlprof.QueryMonthPos())
    {
    case 1:
        xWork -= dYearSize + dTwoNum + dDateSep*2 + dxRightFudge*2;
        break;
    case 2:
        xWork -= dDateSep + dxFieldThree + dxRightFudge;
        break;
    }

    XYPOINT     xyMonth( xWork + dxLeftFudge, xyDate.QueryY());
    XYDIMENSION dxyMonth( dTwoNum, dxyDate.QueryHeight() );

    // Find second separator

    xWork = xyDate.QueryX() - dDateSep - dxFieldThree - dxRightFudge;

    XYPOINT     xySep2( xWork, xyDate.QueryY());
    XYDIMENSION dxySep2( dDateSep + dxLeftFudge, dxyDate.QueryHeight());

    // Find day field

    xWork = xyDate.QueryX() - dTwoNum - dxRightFudge;
    switch (intlprof.QueryDayPos())
    {
    case 1:
        xWork -= dYearSize + dTwoNum + dDateSep*2 + dxRightFudge*2;
        break;
    case 2:
        xWork -= dDateSep + dxFieldThree + dxRightFudge;
        break;
    }

    XYPOINT     xyDay( xWork + dxLeftFudge, xyDate.QueryY());
    XYDIMENSION dxyDay( dTwoNum, dxyDate.QueryHeight() );

    // set up the first control

    if ( PlaceControl( 1, powin, intlprof, xyYear, dxyYear,
        xyMonth, dxyMonth, xyDay, dxyDay ) != NERR_Success )
    {
        return;
    }

    _ssltSeparator1.SetText( nlsDateSep.QueryPch());
    _ssltSeparator1.SetPos( xySep1 );
    _ssltSeparator1.SetSize( dxySep1 );

    if (( err = _sbControl.AddAssociation( &_ssltSeparator1 )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    // set up the second control

    if ( PlaceControl( 2, powin, intlprof, xyYear, dxyYear,
        xyMonth, dxyMonth, xyDay, dxyDay ) != NERR_Success )
    {
        return;
    }

    _ssltSeparator2.SetText( nlsDateSep.QueryPch());
    _ssltSeparator2.SetPos( xySep2 );
    _ssltSeparator2.SetSize( dxySep2 );

    if (( err = _sbControl.AddAssociation( &_ssltSeparator2 )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    // set up the third control

    if ( PlaceControl( 3, powin, intlprof, xyYear, dxyYear,
        xyMonth, dxyMonth, xyDay, dxyDay ) != NERR_Success )
    {
        return;
    }

    // show the item

    _ssnYear.ShowFirst();
    _ssnMonth.ShowFirst();
    _ssnDay.ShowFirst();
    _ssltSeparator1.ShowFirst();
    _ssltSeparator2.ShowFirst();

    // Set field name

    if ((( err = _ssnMonth.SetFieldName( IDS_MONTH )) != NERR_Success) ||
        (( err = _ssnDay.SetFieldName( IDS_DAY )) != NERR_Success ) ||
        (( err = _ssnYear.SetFieldName( IDS_YEAR )) != NERR_Success))
    {
        ReportError( err );
        return;
    }

    _sbControl.SetGroup( this );

}


#define YEAR_LIMIT_1    10000   // the year field is ranged from 0-9999
#define YEAR_LIMIT_2    100     // the year field is ranged from 0-99

APIERR BLT_DATE_SPIN_GROUP::PlaceControl( INT                   nPos,
                                          OWNER_WINDOW *        powin,
                                          const INTL_PROFILE &  intlprof,
                                          const XYPOINT &       xyYear,
                                          const XYDIMENSION &   dxyYear,
                                          const XYPOINT &       xyMonth,
                                          const XYDIMENSION &   dxyMonth,
                                          const XYPOINT &       xyDay,
                                          const XYDIMENSION &   dxyDay )
{
    UNREFERENCED( powin );

    APIERR err;
    static WINDOW * pInsertAfterWin;

    if ( nPos == 1 )
    {
        pInsertAfterWin = NULL;
    }

    if ( intlprof.QueryYearPos() == nPos )
    {
        _ssnYear.SetStyle( _ssnYear.QueryStyle() | SPIN_SSN_ADD_ZERO );
        _ssnYear.SetPos( xyYear, FALSE, pInsertAfterWin );
        _ssnYear.SetSize( dxyYear, FALSE );

        pInsertAfterWin = & _ssnYear;

        if (( err = _sbControl.AddAssociation( &_ssnYear )) != NERR_Success )
        {
            ReportError( err );
            return err;
        }
    }
    else if ( intlprof.QueryMonthPos() == nPos )
    {
        _ssnMonth.SetStyle(_ssnMonth.QueryStyle()
                           | (intlprof.IsMonthLZero() ? SPIN_SSN_ADD_ZERO : 0));
        _ssnMonth.SetPos( xyMonth, FALSE, pInsertAfterWin );
        _ssnMonth.SetSize( dxyMonth, FALSE );

        pInsertAfterWin = & _ssnMonth;

        if (( err = _sbControl.AddAssociation( &_ssnMonth )) != NERR_Success )
        {
            ReportError( err );
            return err;
        }
    }
    else if ( intlprof.QueryDayPos() == nPos )
    {
        _ssnDay.SetStyle(_ssnDay.QueryStyle()
                         | (intlprof.IsDayLZero() ? SPIN_SSN_ADD_ZERO : 0));
        _ssnDay.SetPos( xyDay, FALSE, pInsertAfterWin );
        _ssnDay.SetSize( dxyDay, FALSE );

        pInsertAfterWin = & _ssnDay;

        if (( err = _sbControl.AddAssociation( &_ssnDay )) != NERR_Success )
        {
            ReportError( err );
            return err;
        }
    }
    return NERR_Success;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::~BLT_DATE_SPIN_GROUP

    SYNOPSIS:   destructor

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BLT_DATE_SPIN_GROUP::~BLT_DATE_SPIN_GROUP()
{
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::IsConstructionFail

    SYNOPSIS:   check whether the contrustion of the control is succeed
                or not. If not, then ReportError and UIASSERT.

    ENTRY:      CONTROL_WINDOW * pwin - control window to be test

    RETURNS:    BOOL. TRUE for failure and FALSE for succeed

    HISTORY:
        terryk      29-Aug-91   Created
        beng        16-Oct-1991 Tinkered a bit

********************************************************************/

BOOL BLT_DATE_SPIN_GROUP::IsConstructionFail( CONTROL_WINDOW * pwin)
{
    APIERR err = (pwin == NULL)
                 ? ERROR_NOT_ENOUGH_MEMORY
                 : pwin->QueryError();

    if (err != NERR_Success)
    {
        ReportError( err );
        DBGEOL("BLT_DATE_SPIN_GROUP: construction failed.");
        return TRUE;
    }

    return FALSE;
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::SaveValue

    SYNOPSIS:   Save the current value in the Month, Day, Year fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_DATE_SPIN_GROUP::SaveValue( BOOL fInvisible )
{
    _sbControl.SaveValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::RestoreValue

    SYNOPSIS:   Restore the current value in the Month, Day, Year fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_DATE_SPIN_GROUP::RestoreValue( BOOL fInvisible )
{
    _sbControl.RestoreValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::SetControlValueFocus

    SYNOPSIS:   Set the current focus

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_DATE_SPIN_GROUP::SetControlValueFocus()
{
    _sbControl.SetControlValueFocus();
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::SetCurrentDay

    SYNOPSIS:   update the data within the spin button to display the current
                date

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

APIERR BLT_DATE_SPIN_GROUP::SetCurrentDay()
{
    WIN_TIME winTime;
    APIERR err;
    if (  ((err = winTime.QueryError()) == NERR_Success )
       && ((err = winTime.SetCurrentTime()) == NERR_Success )
       )
    {
        SetMonth( winTime.QueryMonth() );
        SetDay( winTime.QueryDay() );
        SetYear( winTime.QueryYear() );

        SetControlValueFocus();
    }

    return err;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::IsValid

    SYNOPSIS:   check the spin button's data is valid or not

    RETURN:     TRUE if the data is valid, FALSE otherwise.

    NOTES:      This subroutine consider ((YEAR/4)*YEAR)==YEAR as a leap year.

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BOOL BLT_DATE_SPIN_GROUP::IsValid()
{
    INT nMonth =(INT) _ssnMonth.QueryValue();
    INT nDay =(INT) _ssnDay.QueryValue();
    INT nYear =(INT) _ssnYear.QueryValue();

    if (( nDay > 28 ) && (nMonth == 2))
    {
        BOOL fLeapYear = (0 == nYear%4) && ((0 == nYear%400) || (0 != nYear%100));
        if ( !fLeapYear || (nDay > 29) )
        {
            MsgPopup( _ssnYear.QueryOwnerHwnd(),
                     (fLeapYear) ? IDS_FEBRUARY_LEAP : IDS_FEBRUARY_NOT_LEAP,
                     MPSEV_ERROR, MP_OK );
            _sbControl.SetControlValueFocus();
            return FALSE;
        }
    }
    else
    {
        if (nDay> 31 )
        {
            MsgPopup( _ssnYear.QueryOwnerHwnd(), IDS_DAY_TOO_BIG,
                      MPSEV_ERROR, MP_OK );
            _sbControl.SetControlValueFocus();
            return FALSE;
        }
        else if (nDay > 30)
        {
            switch (nMonth)
            {
            case 4:
            case 6:
            case 9:
            case 11:
                MsgPopup( _ssnYear.QueryOwnerHwnd(), IDS_DAY_TOO_BIG,
                          MPSEV_ERROR, MP_OK );
                _sbControl.SetControlValueFocus();
                return FALSE;

            default:
                break;
            }
        }
    }
    return TRUE;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::QueryYear

    SYNOPSIS:   Return the year in the range 1980-2079

    NOTE:       Strange range is mandated by mktime()

    HISTORY:
        terryk      12-Jul-91   Created
        beng        13-Aug-1992 mktime doesn't grok pre-1980

*********************************************************************/

INT BLT_DATE_SPIN_GROUP::QueryYear() const
{
    INT nTmp = ((INT)_ssnYear.QueryValue());

    if ( nTmp < 100 )
    {
        if (nTmp < 80)
            nTmp += 2000;  // Adjust for presumably "2079" dates
        else
            nTmp += 1900;  // Adjust for presumably "1995" dates
    }

    return nTmp;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::QueryMonth

    SYNOPSIS:   return the month in the range 1-12

    RETURN:     return the month value

    HISTORY:
                terryk  12-Jul-91   Created

*********************************************************************/

INT BLT_DATE_SPIN_GROUP::QueryMonth() const
{
    return (INT)_ssnMonth.QueryValue();
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::QueryDay

    SYNOPSIS:   return the day in the range 1-31

    RETURN:     return the day

    HISTORY:
                terryk  12-Jul-91   Created

*********************************************************************/

INT BLT_DATE_SPIN_GROUP::QueryDay() const
{
    return (INT)_ssnDay.QueryValue();
}


VOID BLT_DATE_SPIN_GROUP::SetMonth( INT nMonth )
{
    UIASSERT (( nMonth >= 1 ) && ( nMonth < 13 ));
    _ssnMonth.SetValue( nMonth );
    _ssnMonth.Update();
}


VOID BLT_DATE_SPIN_GROUP::SetDay( INT nDay )
{
    UIASSERT (( nDay > 0 ) && ( nDay < 32 ));
    _ssnDay.SetValue( nDay );
    _ssnDay.Update();
}


VOID BLT_DATE_SPIN_GROUP::SetYear( INT nYear )
{
    UIASSERT( nYear >= 0 );
    if ( !_fYrCentury )
    {
        _ssnYear.SetValue( nYear % 100 );
    }
    else
    {
        if ( nYear < 100 )
        {
            _ssnYear.SetValue( nYear + 1900 );
        }
        else
        {
            _ssnYear.SetValue( nYear );
        }
    }
    _ssnYear.Update();
}


#if 0 // disabled
/*********************************************************************

    NAME:       TIME_DATE_DIALOG::TIME_DATE_DIALOG

    SYNOPSIS:   constructor

    ENTRY:      TCHAR* pszResourceName - dialog resurce name
                HWND hwndOwner - handle for owner window

                // CID for all the controls
                CID cidTimeSpinButton
                CID cidTimeUpArrow
                CID cidTimeDownArrow
                CID cidHour
                CID cidTimeSeparator1
                CID cidMin
                CID cidTimeSeparator2
                CID cidSec
                CID cidAMPM
                CID cidDateSpinButton
                CID cidDateUpArrow
                CID cidDateDownArrow
                CID cidMonth
                CID cidDateSeparator1
                CID cidDay
                CID cidDateSeparator2
                CID cidYear

    HISTORY:
                terryk  11-Jul-91   Created
                rustanl 11-Sep-91   Changed BLT_TIMER to WINDOW_TIMER

*********************************************************************/

TIME_DATE_DIALOG::TIME_DATE_DIALOG( const TCHAR * pszResourceName,
                      HWND hwndOwner, const INTL_PROFILE & intlprof,
                      CID cidTimeSpinButton,
                      CID cidTimeUpArrow, CID cidTimeDownArrow, CID cidHour,
                      CID cidTimeSeparator1, CID cidMin, CID cidTimeSeparator2,
                      CID cidSec, CID cidAMPM,
                      CID cidDateSpinButton,
                      CID cidDateUpArrow, CID cidDateDownArrow, CID cidMonth,
                      CID cidDateSeparator1, CID cidDay, CID cidDateSeparator2,
                      CID cidYear)
    : DIALOG_WINDOW( pszResourceName, hwndOwner ),
    _TimeSG( this, intlprof, cidTimeSpinButton, cidTimeUpArrow,
        cidTimeDownArrow, cidHour, cidTimeSeparator1, cidMin,
        cidTimeSeparator2, cidSec,  cidAMPM ),
    _DateSG( this, intlprof, cidDateSpinButton, cidDateUpArrow,
        cidDateDownArrow, cidMonth, cidDateSeparator1, cidDay,
        cidDateSeparator2, cidYear),
    _pTimer( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _TimeSG.SetCurrentTime()) != NERR_Success )
       || ((err = _DateSG.SetCurrentDay()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    _pTimer = new WINDOW_TIMER( QueryHwnd(), 1000 );
    UIASSERT( _pTimer != NULL );
}


TIME_DATE_DIALOG::~TIME_DATE_DIALOG()
{
    delete _pTimer;
}


/*********************************************************************

    NAME:       TIME_DATE_DIALOG::OnOther

    SYNOPSIS:   get the timer message and update the box.

    ENTRY:      USHORT usMsg - message
                USHORT wParam - word parameter
                ULPARAM lParam - lParam

    RETURN:     Always TRUE

    HISTORY:
        terryk      12-Jul-91   Created (as OnOther)
        beng        30-Sep-1991 Converted to OnTimer

*********************************************************************/

BOOL TIME_DATE_DIALOG::OnTimer( const TIMER_EVENT & e )
{
    UNREFERENCED(e);

    if ( _TimeSG.IsModified() || _DateSG.IsModified() )
    {
        // stop the timer if either one of them is modified
        _pTimer->Enable( FALSE );
    }
    else
    {
        APIERR err;
        if (  ((err = _TimeSG.SetCurrentTime()) != NERR_Success )
           || ((err = _DateSG.SetCurrentDay()) != NERR_Success )
           )
        {
            ::MsgPopup( this, err );
        }
    }

    // Event handled
    //
    return TRUE;
}
#endif // disabled entire TIME_DATE_DIALOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\bltsss.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsss.cxx
    Spin button edit field - implementation

    SLE object but only accept number and it will live only in
    a spin button.

    FILE HISTORY:
        terryk      01-May-1991 Created
        beng        18-Sep-1991 Pruned UIDEBUGs
        terryk      08-Oct-1991 Change SendMessage Position
        terryk      11-Nov-1991 Change SPIN_ITEM's type from INT to LONG
        terryk      11-Nov-1991 cast QueryRange to LONG
        YiHsinS     15-Dec-1992 Got rid of redundant MessageBeep
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * SPIN_SLE_STR::_pszClassName = SZ("EDIT");


/*********************************************************************

    NAME:       SPIN_SLE_STR::SPIN_SLE_STR

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to owner window
                CID cidEdit - id for the edit field
                CID cidFrame - id for the frame
                LONG idsStart - the IDS number of the first string
                LONG cIDString - the total number of string
                BOOL fWrap - wrap around flag

    NOTES:      It will pass the information to the SLE and SPIN_ITEM
                parent classes.

    HISTORY:
        terryk      01-May-1991     Created
        beng        31-Jul-1991     Control error handling changed

*********************************************************************/

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            LONG idsStart, LONG cIDString, BOOL fWrap,
                            CID cidFrame )
    : SLE( powin, cidEdit ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( idsStart, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            LONG idsStart, LONG cIDString,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit, xy, dxy, flStyle, _pszClassName ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( idsStart, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            const TCHAR *apszString[],
                            LONG cIDString, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( apszString, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            const TCHAR *apszString[],
                            LONG cIDString, XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit, xy, dxy, flStyle, _pszClassName ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( apszString, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::~SPIN_SLE_STR

    SYNOPSIS:   destructor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_SLE_STR::~SPIN_SLE_STR()
{
    delete _pbkgndframe;
    delete [ QueryRange() ] _anlsStr;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::SetRange

    SYNOPSIS:   you cannot set range again

    ENTRY:      LONG dRange - range

    NOTES:      display UIDEBUG message to warn the  programmer

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID SPIN_SLE_STR::SetRange( const LONG dRange )
{
    UNREFERENCED( dRange );

    DBGEOL( "NETUI2: BLTSSS: does not allow to change range." );
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::Initialize

    SYNOPSIS:   Initialize the internal string

    HISTORY:
        terryk      20-Jun-1991 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR SPIN_SLE_STR::Initialize( LONG idsStart,
                                 OWNER_WINDOW * powin,
                                 CID cidFrame )
{
    APIERR err;
    if (cidFrame != -1)
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (err = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSS: bkgndframe error " << err );
            return err;
        }
    }

    _anlsStr= new NLS_STR[ QueryRange() ];

    if ( _anlsStr == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( LONG i = 0; i < (LONG)QueryRange() ; i++ )
    {
        _anlsStr[ i ].Load((INT)( idsStart + i ));
        if (( err = _anlsStr[ i ].QueryError()) != NERR_Success )
        {
            return err;
        }
    }

    if (( err = SaveCurrentData()) != NERR_Success )
    {
        return err;
    }

    NLS_STR nlsAccKey;

    if (( err = GetAccKey( & nlsAccKey )) != NERR_Success )
    {
        return err;
    }

    return SetAccKey( nlsAccKey );
}

APIERR SPIN_SLE_STR::Initialize( const TCHAR *apszString[],
                                 OWNER_WINDOW * powin,
                                 CID cidFrame )
{
    APIERR err;

    if (cidFrame != -1)
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (err = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSS: bkgndframe error " << err );
            return err;
        }
    }

    _anlsStr= new NLS_STR[ QueryRange() ];

    if ( _anlsStr == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( LONG i = 0; i < (LONG)QueryRange() ; i++ )
    {
        _anlsStr[ i ] = apszString[ i ];
        if (( err =  _anlsStr[ i ].QueryError()) != NERR_Success )
        {
            return err;
        }
    }

    if (( err = SaveCurrentData()) != NERR_Success )
    {
        return err;
    }

    NLS_STR nlsAccKey;

    if (( err = GetAccKey( & nlsAccKey )) != NERR_Success )
    {
        return err;
    }

    return SetAccKey( nlsAccKey );
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::OnKeyDown

    SYNOPSIS:   do the action when a key is hit

    ENTRY:      VKEY_EVENT event - contain the key

    RETURN:     TRUE if the routine handles the character
                FALSE otherwise

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_SLE_STR::OnKeyDown( const VKEY_EVENT & event )
{
    SPIN_GROUP  * psb = ( SPIN_GROUP * )SPIN_ITEM::QueryGroup();
    switch ( event.QueryVKey() )
    {
    case VK_UP:
    case VK_PRIOR:
        psb->ChangeFieldValue( SPN_INCREASE, event.QueryRepeat() );
        break;

    case VK_DOWN:
    case VK_NEXT:
        psb->ChangeFieldValue( SPN_DECREASE, event.QueryRepeat() );
        break;

    case VK_LEFT:
        psb->JumpPrevField();
        break;

    case VK_RIGHT:
        psb->JumpNextField();
        break;

    case VK_HOME:
        psb->SetFieldMinMax( SPN_MIN );
        break;

    case VK_END:
        psb->SetFieldMinMax( SPN_MAX );
        break;

    default:
        return FALSE;
    }
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::SaveCurrentData

    SYNOPSIS:   save the current window data to the internal variable

    NOTES:      Assume the current value is correct, otherwise,
                the first element is set

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

APIERR SPIN_SLE_STR::SaveCurrentData()
{
    SPIN_GROUP * psg = ( SPIN_GROUP * ) SPIN_ITEM::QueryGroup();

    if ( ( psg != NULL ) && ! psg->IsActive() )
        return NERR_Success;

    NLS_STR nlsValue;

    APIERR err = QueryText( &nlsValue );
    if ( err != NERR_Success )
    {
        return err;
    }

    LONG nValue = QueryStrNum( nlsValue, (LONG)QueryRange());

    if ( nValue < 0 )
        nValue = QueryValue();

    SetValue( nValue );
    Update();
    return err;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::QueryStrNum

    SYNOPSIS:   Find the position of the given string within the array of
                string.

    ENTRY:      NLS_STR & nlsStr - string to look for.
                NLS_STR anlsStr[] - array of string
                LONG cStr - number of string within the array

    RETURN:     The location of the given string within the array of string.
                It will return -1 if the given string is not in the array
                list.

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

LONG SPIN_SLE_STR::QueryStrNum( const NLS_STR & nlsStr, LONG cStr )
{
    for ( LONG i = 0; i < cStr; i++ )
    {
        if ( nlsStr.strcmp( _anlsStr[ i ] ) == 0 )
            return i;
    }
    return -1;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::QueryContent

    SYNOPSIS:   Get the current value in the object

    ENTRY:      You can request the value in one of the following forms:
                NLS_STR *pnlsStr - return as a nls string

    EXIT:       return the value to the data structure

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

APIERR SPIN_SLE_STR::QueryContent( NLS_STR * pnlsStr ) const
{
    UIASSERT( pnlsStr != NULL );
    UIASSERT( pnlsStr->QueryError() == NERR_Success );

    * pnlsStr = _anlsStr[ QueryValue() ];

    return pnlsStr->QueryError();
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::SetStr

    SYNOPSIS:   set the window text to the given number

    ENTRY:      LONG iStringIndex - number to be set

    HISTORY:
        terryk      01-May-1991 Created
        beng        13-Aug-1992 Hide and show caret appropriately

*********************************************************************/

VOID SPIN_SLE_STR::SetStr( LONG iStringIndex )
{
    ::HideCaret(WINDOW::QueryHwnd());
    SetText( _anlsStr[ iStringIndex ] );
    ::ShowCaret(WINDOW::QueryHwnd());
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::Update

    SYNOPSIS:   update the window text

    NOTES:      call SetNum to update the number

    HISTORY:
        terryk      01-May-1991 Created
        beng        16-Oct-1991 Win32 conversion
        beng        13-Aug-1992 Send EN_UPDATE and EN_CHANGE correctly
        beng        16-Aug-1992 Disabled EN_UPDATE

*********************************************************************/

VOID SPIN_SLE_STR::Update()
{
    // CODEWORK: this and SPIN_SLE_NUM::Update should share the
    // below sendmessages.  e.g. embed it in an CHANGEABLE_SPIN_ITEM::Update
    // call and give the class another virtual for the SetStr/SetValue calls.

#if 0 // Nobody listens for this message, anyway
#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_UPDATE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_UPDATE ) );
#endif
#endif // disabled

    SetStr( QueryValue() );

    // Tell the spin group that we have been changed

    // CODEWORK - roll this into BLT for proper portability.

#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_CHANGE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_CHANGE ) );
#endif
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::OnChar

    SYNOPSIS:   function to be called if the WM_CHAR message is received.

    ENTRY:      CHAR_EVENT & event

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL SPIN_SLE_STR::OnChar( const CHAR_EVENT & event )
{
    LONG iString = QueryAccCharPos( event.QueryChar() );

    if ( iString == (-1) )
    {
        // cannot find it
        CHANGEABLE_SPIN_ITEM::OnChar( event );
        return TRUE;
    }
    else
    {
        SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();

        pSB->SetModified( TRUE );
        SetValue( iString );
        Update();
        SLE::SetControlValueFocus();
    }
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::OnFocus

    SYNOPSIS:   select the whole string

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_STR::OnFocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );

#if 0
    SPIN_GROUP * psg = ( SPIN_GROUP * ) SPIN_ITEM::QueryGroup();
    if ( ( psg != NULL ) && ! psg->IsActive() )
        return FALSE;
#endif

    SLE::SetControlValueFocus();
    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();
    pSB->DoNewFocus((SPIN_ITEM *)this);
    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::GetAccKey

    SYNOPSIS:   get the accelerated key - the first character of
                each string

    ENTRY:      NLS_STR *pnlsStr - the accelerated key list

    EXIT:       NLS_STR *pnlsStr - the accelerated key list

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

APIERR SPIN_SLE_STR::GetAccKey( NLS_STR * pnlsStr )
{
    APIERR apierr = pnlsStr->QueryError();
    if ( apierr != NERR_Success )
    {
        return apierr;
    }

    *pnlsStr = NULL;

    apierr = pnlsStr->QueryError();
    if ( apierr != NERR_Success )
    {
        return apierr;
    }

    for ( LONG i = 0; i < (LONG)QueryRange(); i++ )
    {
        ISTR istrFirstChar( _anlsStr[ i ] );
        ISTR istrEndChar = istrFirstChar;

        ++istrEndChar;

        // CODEWORK: need AppendChar in NLS_STR
        NLS_STR *pnlsFirstChar = _anlsStr[ i ].QuerySubStr( istrFirstChar,
                                                            istrEndChar );
        if ( NULL == pnlsFirstChar ) // JonN 01/23/00 PREFIX bug 444893
        {
            UIASSERT(FALSE);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        apierr = pnlsFirstChar->QueryError();
        if ( apierr != NERR_Success )
        {
            return apierr;
        }

        if ( pnlsFirstChar->QueryTextLength() == 0 )
            pnlsStr->strcat( SZ(" ") );
        else
            pnlsStr->strcat( *pnlsFirstChar );

        apierr = pnlsStr->QueryError();
        if ( apierr != NERR_Success )
        {
            return apierr;
        }
        delete pnlsFirstChar;

    }
    pnlsStr->_strupr();

    return NERR_Success;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::QueryAccCharPos

    SYNOPSIS:   given a character. return the character position
                in the accelator keys list depended on whether
                the character is an accelerator key or not

    ENTRY:      WCHAR wcInput - character to be tested

    EXIT:       if the given character is one of the accelator key,
                it will return the position. Otherwise, it will return 0.

    HISTORY:
        terryk  29-May-91       Created
        beng    05-Mar-1992     Eliminate wsprintf calls; Unicode fixes

*********************************************************************/

LONG SPIN_SLE_STR::QueryAccCharPos( WCHAR wcInput )
{
    NLS_STR nlsAccKey;

    QueryAccKey( &nlsAccKey );
    ASSERT( !!nlsAccKey );
    ISTR istrAccKey( nlsAccKey );

    // setup a circular search
    INT iResult = (INT)QueryValue();
    INT iOldIndex = iResult;

    // Uppercase search char (this is really awkward)

    WCHAR wcSearch;
    {
        NLS_STR nlsTmp;
        nlsTmp.AppendChar(wcInput);
        nlsTmp._strupr();
        ASSERT(!!nlsTmp);
        ISTR istrTmp(nlsTmp);
        wcSearch = nlsTmp.QueryChar(istrTmp);
    }

    istrAccKey += iResult;

    for (;;)
    {
        if ( (UINT)(iResult + 1) > nlsAccKey.QueryTextLength() )
        {
            iResult = 0;
            istrAccKey.Reset();
        }
        else
        {
            iResult ++;
            ++istrAccKey;
        }
        if ( wcSearch == nlsAccKey.QueryChar( istrAccKey ))
        {
            return iResult;
        }

        if ( iResult == iOldIndex )
        {
            return -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\dead\bltgcb.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    <file.extension>
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        <name>	    <curdate>	<comment>

*/

GRAPHICAL_CHECKBOX::GRAPHICAL_CHECKBOX( OWNER_WINDOW *powin, CID cid,
    ULONG ulIDCheck, ULONG ulIDUnCheck )
    : CHECKBOX ( powin, cid ),
    _pbmCheck(( ulIDCheck == 0 ) ? NULL : new BIT_MAP ( ulIDCheck )),
    _pbmUnCheck(( ulIDUnCheck == 0 ) ? NULL : new BIT_MAP ( ulIDUnCheck ))
{
    UIASSERT( ( _pbmCheck == NULL ) || ( _pbmCheck->QueryError() == NERR_Success ));
    UIASSERT( ( _pbmUnCheck == NULL ) || ( _pbmUnCheck->QueryError() == NERR_Success ));
}

GRAPHICAL_CHECKBOX::~GRAPHICAL_CHECKBOX()
{
    delete _pbmCheck;
    delete _pbmUnCheck;
}

BOOL GRAPHICAL_CHECKBOX::CD_Draw( DRAWITEMSTRUCT *pdis, GUILTT_INFO * pGUILTT)
{
	BITMAP bitmap;
	RECT rcImage;

    // excluding the border
	rcImage.left    = pdis->rcItem+1;
    rcImage.top     = pdis->top+1;
    rcImage.right   = pdis->right-1;
    rcImage.bottom  = pdis->bottom-1;

	DEVICE_CONTEXT dcT( CreateCompatibleDC( pdis->hDC ));

    if (( pdis->itemState & ODS_CHECKED ) == 0 )
    {
        // display normal bitmap
    	::GetObject( _pbmCheck, sizeof(bitmap), (LPSTR)&bitmap);
    	dcT.SelectObject( _pbmCheck );
    }
    else
    {
        // display disable bitmap
    	::GetObject( _pbmUnCheck, sizeof(bitmap), (LPSTR)&bitmap);
        dcT.SelectObject( _pbmUnCheck ) ;
    }

    // fit the bitmap into the button position
	::StretchBlt( pdis->hDC, rcImage.left,
		   rcImage.top, rcImage.right - rcImage.left, rcImage.bottom - 
           rcImage.top,
		   dcT.QueryHdc(), 0, 0, bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);

    ::DeleteDC( dcT.QueryHdc() );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\dead\bltmeter.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltmeter.cxx
        Source file for Activity Meter custom control

    FILE HISTORY:
        terryk  10-Jun-91   Created

*/

#ifdef  LM_3

#define  INCL_WINDOWS
#define  INCL_WINDOWS_GDI
#define  INCL_NETERRORS
#include <lmui.hxx>

extern "C"
{
    #include <netlib.h>
}


#if defined(DEBUG)
static const TCHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>
#include <uitrace.hxx>

#define _BLT_HXX_ // "private"
#include <bltrc.h>
#include <bltglob.hxx>
#include <bltcons.h>
#include <bltinit.hxx>
#include <bltwin.hxx>
#include <bltmisc.hxx>
#include <bltctlvl.hxx>
#include <bltgroup.hxx>
#include <bltctrl.hxx>
#include <bltdlg.hxx>
#include <bltmsgp.hxx>
#include <bltclwin.hxx>
#include <bltdisph.hxx>
#include <bltcc.hxx>
#include <bltmeter.hxx>

#define DEBUG
#include <dbgstr.hxx>

const TCHAR * METER::_pszClassName = "static";

/**********************************************************\

    NAME:       METER::METER

    SYNOPSIS:   Meter is an activity indicator object. It displays the
                number of percentage complete and mark the specified 
                percentage of the rectangle with the specified color.

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control
                COLORREF color - color to paint the rectangle. Optional.
                                 If the color is missing, use BLUE.

    HISTORY:    
	terryk	    15-May-91	    Created
	beng	    31-Jul-1991     Control error reporting changed

\**********************************************************/

METER::METER( OWNER_WINDOW *powin, CID cid, COLORREF color )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        UIDEBUG("BLTMETER error: constructor failed.\n\r");
    }

}

METER::METER( OWNER_WINDOW *powin, CID cid, 
              XYPOINT xy, XYDIMENSION dxy, ULONG flStyle, COLORREF color )
    : CONTROL_WINDOW ( powin, cid, xy, dxy, flStyle, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        UIDEBUG("BLTMETER error: constructor failed.\n\r");
        return ;
    }
}


/**********************************************************\

    NAME:       METER::SetComplete

    SYNOPSIS:   Reset the number of percentage completed

    ENTRY:      INT nComplete - completed percentage

    NOTES:      It will repaint the object every reset the percentage.

    HISTORY:    
                terryk  15-May-91   Created

\**********************************************************/

VOID METER::SetComplete( INT nComplete )
{
    _nComplete = ( nComplete < 0 ) ? 0 : 
                 (( nComplete > 100 ) ? 100 : nComplete );
    Invalidate( TRUE );
}    


/**********************************************************\

    NAME:       METER::OnPaintReq

    SYNOPSIS:   Redraw the whole object

    HISTORY:    
                terryk  15-May-91   Created

\**********************************************************/

BOOL METER::OnPaintReq()
{
    RECT    rectClient, rectPercent;
    TCHAR    pszBuf[ 10 ];

    wsprintf( pszBuf, "%d%%", _nComplete );

    PAINTSTRUCT     ps;

    ::BeginPaint( WINDOW::QueryHwnd(), & ps );
    DISPLAY_CONTEXT dc( WINDOW::QueryHwnd() );

    DWORD dwBkColor      = dc.SetBkColor( GetSysColor( COLOR_WINDOW ) );
    DWORD dwTextColor    = dc.SetTextColor( _color );

    dc.SetTextAlign( TA_CENTER | TA_TOP );

    DWORD   dwColor = dc.GetBkColor( );

    // fill up the rectangle first

    dc.SetBkColor( dc.SetTextColor( dwColor ));
    ::GetClientRect( WINDOW::QueryHwnd(), &rectClient );
    ::SetRect( &rectPercent, 0, 0, 
             (( INT )((( LONG )rectClient.right * ( LONG )_nComplete )/ 100 )), 
             rectClient.bottom );

    TEXTMETRIC  textmetric;

    dc.QueryTextMetrics( &textmetric );

    // draw half of the text
    dc.ExtTextOut( rectClient.right/2, ( rectClient.bottom - 
                   textmetric.tmHeight )/ 2, ETO_OPAQUE | ETO_CLIPPED, 
                   &rectPercent, pszBuf, strlenf( pszBuf ), NULL );

    rectPercent.left = rectPercent.right;
    rectPercent.right = rectClient.right;

    // draw the other half of the text
    dwColor = dc.GetBkColor( );
    dc.SetBkColor( dc.SetTextColor( dwColor ));
    dc.ExtTextOut( rectClient.right /2, ( rectClient.bottom - 
                   textmetric.tmHeight ) / 2, ETO_OPAQUE | ETO_CLIPPED, 
                   &rectPercent, pszBuf, strlenf( pszBuf ), NULL );
    dc.SetBkColor( dwBkColor );
    dc.SetTextColor( dwTextColor );

    ::EndPaint( WINDOW::QueryHwnd(), &ps );
    return TRUE;
    
}

#endif  //  LM_3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\aheap.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    aheap.cxx
    HEAP_BASE implementation


    FILE HISTORY:
	rustanl     05-Jul-1991     Created
	rustanl     15-Jul-1991     Code review changes (SetAllocCount
				    heuristics).  CR attended by
				    BenG, ChuckC, JimH, Hui-LiCh, TerryK,
				    RustanL.

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:	HEAP_BASE::HEAP_BASE

    SYNOPSIS:	HEAP_BASE constructor

    ENTRY:	cInitialAllocCount -	The number of items that
					the heap should initially
					allocate space for.
		fAutoReadjust - 	Specifies whether or not the
					heap is supposed to auto-readjust
					after each call to AddItem (defined
					in subclasses).  If FALSE,
					Adjust must be called before
					the contents of the heap is
					publically queried.  (Note, Adjust
					sets the auto-readjust state to
					TRUE.)

    NOTES:	On successful construction, the heap guarantees that
		it will be able to add and remove items successfully,
		provided the number of items in the heap never exceeds
		cInitialAllocCount.  If AddItem is called when the
		number of items in the heap is at least cIntialAllocCount,
		the add operation may fail (presumably because of
		insufficient memory).

		The SetAllocCount method can be used to adjust the
		cInitialAllocCount passed to this constructor.	That method
		may also be able to rectify unsuccessful constructions.

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

HEAP_BASE::HEAP_BASE( int cInitialAllocCount, BOOL fAutoReadjust )
    : _cItems( 0 ),
      _fAutoReadjust( fAutoReadjust ),
      _buf( cInitialAllocCount * sizeof( VOID * ))
{
    if ( QueryError() != NERR_Success )
	return;

    UIASSERT( cInitialAllocCount >= 0 );

    APIERR err = _buf.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

}  // HEAP_BASE::HEAP_BASE


/*******************************************************************

    NAME:	HEAP_BASE::~HEAP_BASE

    SYNOPSIS:	HEAP_BASE destructor

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

HEAP_BASE::~HEAP_BASE()
{
    // do nothing else

}  // HEAP_BASE::~HEAP_BASE


/*******************************************************************

    NAME:	HEAP_BASE::I_AddItem

    SYNOPSIS:	Adds another item to the bottom of the heap, but does
		not ajust the heap.

		This method is called by the AddItem methods of derived
		classes.

    ENTRY:	Heap in successful state.

		pv -	    Pointer to item to add to heap

    EXIT:	On success, the new item will be stored in the last
		position in the heap, and the count of items in the
		heap will be increased accordingly.  Note, however,
		the caller is responsible for adjusting the heap
		afterwards.
		On failure, the heap is left unchanged.

    RETURNS:	An API error code, which is NERR_Success on success.

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

APIERR HEAP_BASE::I_AddItem( VOID * pv )
{
    UIASSERT( QueryError() == NERR_Success );

    APIERR err = SetAllocCount( _cItems + 1 );
    if ( err != NERR_Success )
	return err;

    VOID * * ppv = (VOID * *)_buf.QueryPtr();
    UIASSERT( ppv != NULL );	    // this could only happen if the size of
				    // the buffer were 0.
    ppv[ _cItems++ ] = pv;

    return NERR_Success;

}  // HEAP_BASE::I_AddItem


/*******************************************************************

    NAME:	HEAP_BASE::PeekItem

    SYNOPSIS:	Returns a pointer to an item in the heap.

    ENTRY:	The heap must be in a successful state, and must be
		in the auto-readjust state.

		i -	The index of the item to be returned

		The heap must have more than i items.

    EXIT:	The heap is left unchanged.

    RETURNS:	A poitner to the requested item.

    NOTES:	Note, this method is protected, since a general client
		should not be given access to any item but the top
		one (as governed by the properties of a heap).

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

void * HEAP_BASE::PeekItem( int i ) const
{
    UIASSERT( QueryError() == NERR_Success );
    UIASSERT( IsAutoReadjusting());
    UIASSERT( 0 <= i && i < QueryCount());

    return ((VOID * *)_buf.QueryPtr())[ i ];

}  // HEAP_BASE::PeekItem


/*******************************************************************

    NAME:	HEAP_BASE::SetItem

    SYNOPSIS:	Sets an existing item in the heap

    ENTRY:	The heap must be in a successful state

		i -	Index of an existing item
		pv -	New value for item i

    EXIT:	Item i has the value pv.  The heap is not adjusted.

    HISTORY:
	rustanl     08-Jul-1991     Created

********************************************************************/

void HEAP_BASE::SetItem( int i, void * pv )
{
    UIASSERT( QueryError() == NERR_Success );
    UIASSERT( 0 <= i && i < QueryCount());

    VOID * * ppv = (VOID * *)_buf.QueryPtr();

    ppv[ i ] = pv;

}  // HEAP_BASE::SetItem


/*******************************************************************

    NAME:	HEAP_BASE::I_RemoveTopItem

    SYNOPSIS:	Removes the top item and returns it.  Leaves the
		heap in an unadjusted state (see Exit:).

    ENTRY:	A non-empty heap in a successful and auto-readjusting
		state

    EXIT:	Left and right subtrees of the heap are subheaps
		(i.e., they have the heap property), but the
		root may need adjustment (performed by calling
		AdjustDown( 0 )).

    RETURNS:	Pointer to the top (smallest) item.

    HISTORY:
	rustanl     08-Jul-1991     Created

********************************************************************/

void * HEAP_BASE::I_RemoveTopItem( void )
{
    UIASSERT( QueryCount() > 0 );
    UIASSERT( IsAutoReadjusting());

    VOID * pvReturnItem = PeekItem( 0 );

    //	Place bottom-most item as first item

    int iLastItem = _cItems - 1;
    SetItem( 0, PeekItem( iLastItem ));

    _cItems = iLastItem;

    return pvReturnItem;

}  // HEAP_BASE::I_RemoveTopItem


/*******************************************************************

    NAME:	HEAP_BASE::SetAllocCount

    SYNOPSIS:	Resizes the buffer in use.

    ENTRY:	cNewAllocCount -    The smallest number of items that
				    the heap should be able to store
				    upon successful return of this
				    method

    EXIT:	On success, the heap can store at least cNewAllocCount
		items.	The BASE error recorded will then always be
		NERR_Success.
		On failure, the heap is left unchanged.

    RETURNS:	An API error code, which is NERR_Success on success.

    NOTES:	On successful returns from this method, the heap
		is, like after successful construction, guaranteed
		to successfully perform AddItem and RemoveItem operations,
		provided the number of items does not exceed
		cNewAllocCount.  If construction was successful, and if
		Trim has not been called, this guarantee extends to
		max( cInitialAllocCount, cNewAllocCount ) items.
		(See also constructor.)

		This method will never discard any items in the heap,
		and will never shrink the buffer being used,  Hence,
		requests for the new alloc count to be less than the
		number of items currently in the heap will always
		succeed without changing the object at all.

		This method can be applied to objects that were not
		successfully constructed.  If the new alloc count
		is small enough to succeed, the object will, on exit,
		be in a successful state.

		To shrink the buffer to get rid of excess space, use
		the Trim method.

    HISTORY:
	rustanl     05-Jul-1991     Created
	rustanl     15-Jul-1991     If resize of buffer is necessary,
				    resize to next bigger 4Kb boundary.

********************************************************************/

#define NICE_MEMORY_INCREMENT		(0x1000)

APIERR HEAP_BASE::SetAllocCount( int cNewAllocCount )
{
    if ( cNewAllocCount <= _cItems )
	return NERR_Success;

    UINT cbSizeNeeded = cNewAllocCount * sizeof( VOID * );

    if ( cbSizeNeeded <= _buf.QuerySize())
	return NERR_Success;	    // buffer is already big enough

    /*	Resize the buffer.  While we're at it, get a bit extra memory
     *	by rounding up to the nearest 4 Kb boundary.  4 Kb was chosen
     *	as an arbitrary nice number.  It also happens to be the hardware
     *	page size used on x86's.
     *
     *	Note, the rounding is done in two steps, so as to avoid overflows.
     *	The first step really computes the 4Kb boundary next below
     *	cbSizeNeeded.  If cbSizeNeeded is exactly on a 4Kb boundary, then
     *	this is also the next 4Kb boundary above.  If the 4Kb boundary
     *	below is not cbSizeNeeded, then add 4Kb to it.	This will then
     *	produce the desired new alloc size.
     */

    UINT cbNewAllocSize = ( cbSizeNeeded / NICE_MEMORY_INCREMENT )
			  * NICE_MEMORY_INCREMENT;
    if ( cbNewAllocSize < cbSizeNeeded )
    {
	cbNewAllocSize += NICE_MEMORY_INCREMENT;
    }
    UIASSERT( cbSizeNeeded <= cbNewAllocSize );

    APIERR err = _buf.Resize( cbNewAllocSize );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("_buf.Resize failed in HEAP_BASE::SetAllocCount\r\n") );
	return err;
    }

    if ( QueryError() != NERR_Success )
	ReportError( NERR_Success );

    return NERR_Success;

}  // HEAP_BASE::SetAllocCount


/*******************************************************************

    NAME:	HEAP_BASE::Trim

    SYNOPSIS:	Trims the buffer used to store the pointers to the items
		contained in the heap

    ENTRY:	The object in a valid state

    EXIT:	The buffer trimmed.  Note, all items in the heap remain
		the same.

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

void HEAP_BASE::Trim( void )
{
    UIASSERT( QueryError() == NERR_Success );

    _buf.Trim();

}  // HEAP_BASE::Trim
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\pch\bltwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltwin.cxx
    BLT base window class definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        beng        14-May-1991 Exploded blt.hxx into components
        terryk      10-Jul-1991 Added IsEnable to Window class
        beng        31-Jul-1991 Reloc'd fClientGen'dMsg to class
        terryk      12-Aug-1991 Change QueryWindowRect to QueryClient
                                window rect
        terryk      20-Aug-1991 Change QueryClientRect back to
                                QueryWindowRect
        beng        30-Sep-1991 Added ASSOCHWNDTHIS class
        beng        18-Oct-1991 Threw in some tracing
        Yi-Hsins     8-Jan-1991 Added HasFocus method
        terryk      02-Apr-1992 Added Z position in SetPos
        terryk      28-Apr-1992 fixed Z position problem in SetPos
        KeithMo     11-Nov-1992 Added new ctor form and Center method.
        Yi-HsinS    10-Dec-1992 Added CalcFixedHeight
        DavidHov    17-Sep-1993 Changes for C8 and re-dllization
*/


#include "pchblt.hxx"   // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

#define WIN32_REMOVEPROP_BUG 1

// Indicates that the message was generated internally and not
// by the user manipulating controls.
//
BOOL WINDOW::_fClientGeneratedMessage = FALSE;

const TCHAR * ASSOCHWNDTHIS::_pszPropThisLo = SZ("BltPropThisL");
const TCHAR * ASSOCHWNDTHIS::_pszPropThisHi = SZ("BltPropThisH");


#if defined(DEBUG) && defined(TRACE) && 0
DBGSTREAM& operator<<(DBGSTREAM &out, const WINDOW * pwnd)
{
    TCHAR szBuf[12];
    FMT(szBuf, SZ("%lx"), (ULONG)pwnd);
    out << SZ("WINDOW ") << szBuf;

    return out;
}

DBGSTREAM& operator<<(DBGSTREAM &out, HWND hwnd)
{
    out << (ULONG)hwnd;

    return out;
}
#endif

inline INT max(INT a, INT b)
{
    return (a > b) ? a : b;
}

/**********************************************************************

    NAME:       WINDOW::WINDOW

    SYNOPSIS:   Constructor for the WINDOW object.

    ENTRY:      Without parameters, leaves an empty object which can
                later adopt an existing window (via SetHwnd).

        - or -

                pszClassName - class name of window class
                flStyle      - dword of style bits
                pwndOwner    - pointer to owner window
                cid          - control ID.  Default is 0, which
                               means no ID (and no menu if not
                               a WS_CHILD).


    NOTES:
        The parmless WINDOW object does no real construction;
        rather, it is a repository for a large body of common
        methods and information, much of which can only be
        calculated well into the construction process by one
        of its derived classes.  Hence this version of the ctor
        does nearly nothing.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        25-Apr-1991 Removed unused hwndOwner parm
        beng        07-May-1991 Added CreateWindow versions
        beng        15-May-1991 Added CID child-window support
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

WINDOW::WINDOW(
    const TCHAR * pszClassName,
    ULONG         flStyle,
    const WINDOW *pwndOwner,
    CID           cid )
    : _hwnd(NULL),
      _fCreator(FALSE)
{
    // CODEWORK: make these const with C7

    UIASSERT( ((cid == 0) || (flStyle & WS_CHILD)) );

    HWND hwndOwner = (pwndOwner == 0) ? 0 : pwndOwner->_hwnd;

    HWND hwnd = ::CreateWindow(pszClassName,
                               SZ(""), flStyle,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               hwndOwner, (HMENU)LongToHandle(cid), hmodBlt, 0);
    if (hwnd == 0)
    {
        ReportError(hwnd == 0);
        return;
    }

    _hwnd = hwnd;
    _fCreator = TRUE;
}


WINDOW::WINDOW()
    : _hwnd( NULL ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


WINDOW::WINDOW( HWND hwnd )
    : _hwnd( hwnd ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


/**********************************************************************

    NAME:       WINDOW::~WINDOW

    SYNOPSIS:   Destructor of WINDOW

    ENTRY:      Valid WINDOW base.  If _fCreator set, has a window
                object (id'd by _hwnd) which it needs to destroy.

    EXIT:       Window destroyed

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        07-May-1991     Added DestroyWindow function

**********************************************************************/

WINDOW::~WINDOW()
{
    if (_fCreator)
    {
        if (!::DestroyWindow(_hwnd))
        {
            DWORD err = ::GetLastError();
            DBGEOL( "NETUI: WINDOW::dtor: DestroyWindow( " << ((DWORD)(DWORD_PTR)_hwnd)
                    << " ) failed with error " << err );
            // ASSERT( FALSE ); removing again
        }
    }
}


/*******************************************************************

    NAME:       WINDOW::ResetCreator

    SYNOPSIS:   Resets the fCreator flag

    ENTRY:      fCreator is set; presumably, we just noticed that
                some cad called DestroyWindow(this->QueryHwnd()).

    EXIT:       fCreator is clear

    NOTES:
        This is for when ClientWindow notices that some outside
        agency called DestroyWindow on its window.  Under normal
        circumstances it should never run.

    HISTORY:
        beng        10-May-1991     Created

********************************************************************/

VOID WINDOW::ResetCreator()
{
    UIASSERT(_fCreator);
    _fCreator = FALSE;
}


/*******************************************************************

    NAME:       WINDOW::SetHwnd

    SYNOPSIS:   Sets the window-handle member of WINDOW.
                This is integral to complete object construction
                (i.e. including derived classes).

    ENTRY:      hwnd - new value of window handle

    EXIT:       _hwnd has been set

    NOTES:
        This method should be called only once in the lifetime of
        a window.

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n
        beng        07-May-1991     Updated to honor _fCreator

********************************************************************/

VOID WINDOW::SetHwnd( HWND hwnd )
{
    UIASSERT(!_fCreator);   // better not have created any window
    UIASSERT(_hwnd == 0);   // or for that matter have already called this

    _hwnd = hwnd;
}


/*******************************************************************

    NAME:       WINDOW::QueryHwnd

    SYNOPSIS:   Return the Windows HWND associated with the WINDOW

    RETURNS:    the value of _hwnd

    NOTES:

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n

********************************************************************/

HWND WINDOW::QueryHwnd() const
{
    return _hwnd;
}


/**********************************************************************

    NAME:       WINDOW::QueryOwnerHwnd

    SYNOPSIS:   Return the hwnd of the window's owner

    RETURNS:    HWND of window's owner

    NOTES:

    HISTORY:
       beng     25-Apr-1991 Moved out of the class def'n
       beng     09-Oct-1991 Win32 conversion

***********************************************************************/

HWND WINDOW::QueryOwnerHwnd() const
{
#if defined(WIN32)
    return (HWND) ::GetWindowLongPtr( _hwnd, GWLP_HWNDPARENT );
#else
    return (HWND) ::GetWindowWord( _hwnd, GWW_HWNDPARENT );
#endif
}


/**********************************************************************

    NAME:       WINDOW::Command

    SYNOPSIS:   This method sends a message to the window.

    ENTRY:
        usMsg               Message
        wParam, lParam      Message parameters

    RETURNS:    The return code of the message.

    CAVEATS:
        This method is obviously not host environment independent.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG_PTR WINDOW::Command( UINT nMsg, WPARAM wParam, LPARAM lParam ) const
{
    return ::SendMessage( _hwnd, nMsg, wParam, lParam );
}


/**********************************************************************

    NAME:       WINDOW::QueryStyle

    SYNOPSIS:   Return the style bits for the window

    RETURNS:    Style bits (dword)

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG WINDOW::QueryStyle() const
{
    return (ULONG) ::GetWindowLong( _hwnd, GWL_STYLE );
}


/**********************************************************************

    NAME:       WINDOW::SetStyle

    SYNOPSIS:   Set the style bits for the window

    NOTES:
        This is a protected member function, intended to allow controls
        to change their style.

    HISTORY:
        beng        13-Feb-1992 Created

**********************************************************************/

VOID WINDOW::SetStyle( ULONG nValue )
{
    ::SetWindowLong( _hwnd, GWL_STYLE, (LONG)nValue );
}


/**********************************************************************

    NAME:       WINDOW::QueryClientRect

    SYNOPSIS:   get the client coordinates of a window's client area

    ENTRY:      RECT * pRect - the returned coordinates

    EXIT:       RECT * pRect - fill the data structure with the window's
                               coordinates.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      20-Jul-1991 Created
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryClientRect( RECT * pRect ) const
{
    ::GetClientRect( _hwnd, pRect );
}

VOID WINDOW::QueryClientRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, TRUE );
    *pxyxy = xyxy;
}


/*********************************************************************

    NAME:       WINDOW::QueryWindowRect

    SYNOPSIS:   get the window's screen coordinate

    ENTRY:      RECT *pRect - rectangle data structure to store the
                information.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      2-Aug-1991  Created
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryWindowRect( RECT * pRect ) const
{
    ::GetWindowRect( _hwnd, pRect );
}

VOID WINDOW::QueryWindowRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, FALSE );
    *pxyxy = xyxy;
}


/**********************************************************************

    NAME:       WINDOW::SetText

    SYNOPSIS:
        This method sets the text of a window.  The text of an application
        window or dialog is the caption, whereas it is the text contents of
        a controls for many controls.

    ENTRY:
         psz             A pointer to the text
     or
         nls             NLS text string

    EXIT:

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        rustanl     27-Apr-1991 Changed PSZ to const TCHAR *
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

VOID WINDOW::SetText( const TCHAR * psz )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, psz );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


VOID WINDOW::SetText( const NLS_STR & nls )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, nls.QueryPch() );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


/**********************************************************************

    NAME:       WINDOW::QueryText

    SYNOPSIS:   Returns the text of a window.

    ENTRY:
        pszBuffer   A pointer to a buffer, where the window text
                    will be copied.
        cbBufSize   The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough.

            - or -

        pnls        Pointer to a NLS_STR

    RETURNS:
        0 if successful; NERR_BufTooSmall if given buffer too small.

    NOTES:
        The length of the window text can be retrieved by calling
        WINDOW::QueryTextLength, while the storage needed to copy
        that text is available via WINDOW::QueryTextSize.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Changed return type; made const
        beng        10-Jun-1991 Tinkered for Unicode
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

**********************************************************************/

APIERR WINDOW::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    UINT cbActual = QueryTextSize();

    if (cbBufSize < cbActual)
        return NERR_BufTooSmall;

    if (cbBufSize > 0 && pszBuffer == NULL)
        return ERROR_INVALID_PARAMETER;

    // This Win API works in total TCHARs, including terminator.
    //
    ::GetWindowText(_hwnd, (TCHAR *)pszBuffer, cbBufSize/sizeof(TCHAR) );

    return 0;
}

APIERR WINDOW::QueryText( NLS_STR * pnls ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    UINT cbActual = QueryTextSize();

    BLT_SCRATCH scratch( cbActual );
    if (!scratch)
        return scratch.QueryError();

    ::GetWindowText( _hwnd,
                     (TCHAR*)scratch.QueryPtr(),
                     scratch.QuerySize()/sizeof(TCHAR) );

    return pnls->CopyFrom((TCHAR*)scratch.QueryPtr());
}


/**********************************************************************

    NAME:       WINDOW::QueryTextLength

    SYNOPSIS:   Returns the length of the window text.
                See WINDOW::SetText for a description of "window text".

    RETURNS:    The length, in actual characters (as opposed to the
                byte-characters of strlen), of the window text.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Made const
        beng        10-Jun-1991 Changed return type
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

***********************************************************************/

INT WINDOW::QueryTextLength() const
{
    return ::GetWindowTextLength( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::QueryTextSize

    SYNOPSIS:   Returns the byte count of the window text,
                including the terminating character

    RETURNS:    Count of bytes

    NOTES:

    HISTORY:
        beng        10-Jun-1991 Created
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

********************************************************************/

INT WINDOW::QueryTextSize() const
{
    INT cchRet = ::GetWindowTextLength( _hwnd );

    return (cchRet + 1) * sizeof(TCHAR);
}


/**********************************************************************

    NAME:       WINDOW::ClearText

    SYNOPSIS:   Clears the window text of the window.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::ClearText()
{
    SetText( SZ("") );
}


/**********************************************************************

    NAME:       WINDOW::Show

    SYNOPSIS:   This method shows or hides a window.

    ENTRY:
       f        Indicates whether to show or hide the window:
                TRUE to show the window, and FALSE to hide it.

    RETURNS:    The previous state of the windows:
                  FALSE if the window was previously hidden
                  TRUE if the window was previously visible

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::Show( BOOL f )
{
    return ::ShowWindow( _hwnd, ( f ? SW_SHOW : SW_HIDE ));
}


/**********************************************************************

    NAME:       WINDOW::Enable

    SYNOPSIS:   Enables or disables a window.

    ENTRY:
        f       Indicates whether to enable or disable the
                window:  TRUE to enable, and FALSE to disable.

    EXIT:
        Window is enabled or disabled (duh) as requested.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        26-Dec-1991 With full understanding, removed some tracery

**********************************************************************/

VOID WINDOW::Enable( BOOL f )
{
    if ( f != IsEnabled() )
    {
        ::EnableWindow( _hwnd, f );
    }
}


/*********************************************************************

    NAME:       WINDOW::IsEnabled

    SYNOPSIS:   return the current status of the window

    RETURN:     return TRUE if the window is enable, FALSE if the window
                is disable.

    HISTORY:
        terryk      8-Jul-91    Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::IsEnabled() const
{
    return !! ::IsWindowEnabled( _hwnd );
}


/**********************************************************************

    NAME:       WINDOW::SetRedraw

    SYNOPSIS:   Sets or clears the redraw flag of the window.

    ENTRY:
       f        Indicates whether to set or clear the redraw flag.
                TRUE sets it, whereas FALSE clears it.
                TRUE is the default value for this parameter.

    EXIT:

    NOTES:
        Setting the redraw flag on does not refresh listboxes.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::SetRedraw( BOOL f )
{
    Command( WM_SETREDRAW, f );
}


/**********************************************************************

    NAME:       WINDOW::Invalidate

    SYNOPSIS:   Invalidates some or all of the client area of the window.

    ENTRY:
       fErase   Indicates whether the window's background is to
                be erased (default FALSE).  This version invalidates
                the entire client region.

       rect     Rectangle to invalidate within client area.  This version
                doesn't erase.

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        13-Feb-1992 Rolled in CLIENT_WINDOW::Repaint

**********************************************************************/

VOID WINDOW::Invalidate( BOOL fErase )
{
    ::InvalidateRect( _hwnd, NULL, fErase );
}

VOID WINDOW::Invalidate( const XYRECT & rect )
{
    ::InvalidateRect( _hwnd, (RECT*)(const RECT *)rect, FALSE );
}


/*******************************************************************

    NAME:       WINDOW::RepaintNow

    SYNOPSIS:   Force an immediate repaint of the window

    EXIT:       Window is completely valid, and has been repainted
                irregardless of outstanding PAINT messages

    HISTORY:
        beng        10-May-1991 Implemented
        beng        13-Feb-1992 Relocated to WINDOW from CLIENT_WINDOW

********************************************************************/

VOID WINDOW::RepaintNow()
{
    ::UpdateWindow( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::ShowFirst

    SYNOPSIS:   The first "Show" call for a client or owned window

    ENTRY:      Window has never been shown - just created

    EXIT:       Window is visible on screen

    NOTES:
        A window's creator should make this call when it is ready
        for the window to appear.

    HISTORY:
        beng        31-Jul-1991     Created

********************************************************************/

VOID WINDOW::ShowFirst()
{
    Show(TRUE);
    Invalidate(FALSE);
}


/*******************************************************************

    NAME:      WINDOW::SetPos

    SYNOPSIS:  Moves a windows to the new cooridinates

    ENTRY:     xy - New position of window,
               fRepaint = TRUE if repaint after move
               WINDOW *pwin - the Z value for the control.
                      The TAB order of the control is placed after pwin.
                      If pwin is NULL, the tab order of the control
                      will be the same as its position in the resource
                      file or according to its creation time.

    NOTES:     Cooridinates are relative to:
                Screen if pop-up window
                Client if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Uses XYPOINT
        beng        09-Oct-1991 Win32 conversion
        terryk      02-Apr-1992 Added Z position

********************************************************************/

VOID WINDOW::SetPos( XYPOINT xy, BOOL fRepaint, WINDOW *pwin )
{
#if 0 // this is the old way - required a Query before could Set
    INT nWidth, nHeight;

    QuerySize( &nWidth, &nHeight );

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  nWidth, nHeight, fRepaint );
#else
    ::SetWindowPos(_hwnd, ( pwin == NULL ) ? 0 : pwin->QueryHwnd(),
                   xy.QueryX(), xy.QueryY(), 0, 0,
                   ((( pwin == NULL ) ?  SWP_NOZORDER : 0 ) | SWP_NOSIZE |
                   (fRepaint?0:SWP_NOREDRAW)));
#endif
}


/*******************************************************************

    NAME:       WINDOW::QueryPos

    SYNOPSIS:   Get the current position (top left corner) of *this

    RETURNS:    Current position of window

    NOTES:
        Cooridinates are relative to:
        Screen if pop-up window
        Client area of parent if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYPOINT version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Withdrew vanilla POINT version

********************************************************************/

XYPOINT WINDOW::QueryPos() const
{
    RECT rc;
    ::GetWindowRect(_hwnd, &rc);

    XYPOINT xy(rc.left, rc.top);

    /* If the window is a child window, then we need to get the coordinates
     * relative to the parent's client area
     */
    if (IsChild())
        xy.ScreenToClient(QueryOwnerHwnd());

    return xy;
}


/*******************************************************************

    NAME:       WINDOW::SetSize

    SYNOPSIS:   Sets the width and height of a window

    ENTRY:      nWidth, nHeight - width and height for window
                -or-
                dxy - desired dimensions of window

    EXIT:

    NOTES:
        Size is not the client area, but full size including borders,
        menus and captions.

        This command causes the window to receive OnMove and OnSize
        events.

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYDIM version
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::SetSize( INT cxWidth, INT cyHeight, BOOL fRepaint )
{
#if 0 // this is the old way - required a Query before could Set
    XYPOINT xy = QueryPos();

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  cxWidth, cyHeight, fRepaint );

#else

    ::SetWindowPos(_hwnd, 0, 0, 0, cxWidth, cyHeight,
                   (SWP_NOZORDER|SWP_NOMOVE|(fRepaint?0:SWP_NOREDRAW)));
#endif
}

VOID WINDOW::SetSize( XYDIMENSION dxy, BOOL fRepaint )
{
    SetSize(dxy.QueryWidth(), dxy.QueryHeight(), fRepaint);
}


/*******************************************************************

    NAME:      WINDOW::QuerySize

    SYNOPSIS:  Get the current size of this window

    ENTRY:     pnWidth, pnHeight - pointers to receive
                                   current size of window

    EXIT:
        If px, py supplied, they've been loaded with X and Y.

        Otherwise, returns XYDIM.

    NOTES:

    HISTORY:
        Johnl       7-Feb-91    Created
        beng        15-May-1991 Added XYDIM version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::QuerySize( INT *pnWidth, INT *pnHeight ) const
{
    RECT rcRect;
    ::GetWindowRect(_hwnd, &rcRect);

    *pnWidth  = rcRect.right - rcRect.left;
    *pnHeight = rcRect.bottom - rcRect.top;
}

XYDIMENSION WINDOW::QuerySize() const
{
    INT dx, dy;

    QuerySize(&dx, &dy);

    return XYDIMENSION(dx, dy);
}


/*******************************************************************

    NAME:       WINDOW::IsChild

    SYNOPSIS:   Determine whether window has CHILD style

    RETURNS:    TRUE if the WS_CHILD window style bits are set for window

    NOTES:

    HISTORY:
        Johnl       14-Feb-1991     Created
        beng        31-Jul-1991     Made 'const'

********************************************************************/

BOOL WINDOW::IsChild() const
{
    return ( WS_CHILD & QueryStyle() ) != 0 ;
}


/*******************************************************************

    NAME:     WINDOW::SetClientGeneratedMsgFlag

    SYNOPSIS: Sets the global flag _fClientGeneratedMessage.

    NOTES:
      Set to TRUE if this is a message we generated ourselves (and you don't
      want the shell dialog proc. to "process" it (i.e., send out notices
      to children etc.).  Be careful you only use this on messages that are
      sent immediately.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

VOID WINDOW::SetClientGeneratedMsgFlag( BOOL fInClientGeneratedMessage )
{
    _fClientGeneratedMessage = fInClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::IsClientGeneratedMsg

    SYNOPSIS: Returns TRUE if the _fClientGeneratedMessage flag is set.
              This means the current message is a message we should
              ignore.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

BOOL WINDOW::IsClientGeneratedMessage()
{
    return _fClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::HasFocus

    SYNOPSIS: Returns TRUE if the current window has the focus.

    HISTORY:
        Yi-HsinS    8-Jan-1992     Created

********************************************************************/

BOOL WINDOW::HasFocus( VOID ) const
{
    return ( QueryHwnd() == ::GetFocus() );
}


/*******************************************************************

    NAME:     WINDOW::Center

    SYNOPSIS: Centers the window above another window.

    ENTRY:    hwnd      - The window to center *this over.  If this
                          value is NULL, then the window is centered
                          over its parent.

    CODEWORK: It may be more aesthetically appealing to center
              child windows their parent's client area, rather
              than over the parent's window proper.

    HISTORY:
        KeithMo    11-Nov-1992     Created.

********************************************************************/

VOID WINDOW::Center( HWND hwnd )
{
    //
    //  If no window was specified, use the parent.
    //  If there is no parent, use the screen size.
    //

    INT xThis;
    INT yThis;

    XYRECT xycdThis;
    UIASSERT( !!xycdThis );

    QueryWindowRect( &xycdThis );

    if( hwnd == NULL )
    {
        hwnd = QueryOwnerHwnd();
    }

    if( hwnd == NULL )
    {
        HDC hdc;

        hdc = GetDC(_hwnd);
        if (!hdc) // JonN 01/23/00: PREFIX bug 444891
            return;

        xThis =  ( GetDeviceCaps(hdc, HORZRES) - xycdThis.CalcWidth()  ) / 2;

        yThis =  ( GetDeviceCaps(hdc, VERTRES) - xycdThis.CalcHeight() ) / 3;

        (void) ReleaseDC( _hwnd, hdc ); // JonN 01/23/00: PREFIX bug 444892
    }
    else
    {
        WINDOW windowParent( hwnd );
        UIASSERT( !!windowParent );

        //
        //  Get the bounding rectangles of this window & the
        //  parent window.  Note that QueryWindowRect returns
        //  *screen* coordinates!
        //

        XYRECT xycdParent;
        UIASSERT( !!xycdParent );

        windowParent.QueryWindowRect( &xycdParent );

        //
        //  Calculate the new window position relative
        //  to the parent.
        //

        xThis = xycdParent.QueryLeft() +
                ( xycdParent.CalcWidth()  - xycdThis.CalcWidth()  ) / 2;
        yThis = xycdParent.QueryTop() +
                ( xycdParent.CalcHeight() - xycdThis.CalcHeight() ) / 3;

    }

    XYPOINT xyThis( xThis, yThis );

    //
    //  Move the window into position.  The SetWindowPos API
    //  is documented as taking client coordinates when
    //  dealing with child windows, but it seems to actually
    //  want screen coordinates.
    //

    SetPos( xyThis );
}

/* Maximum height we expect bitmaps to be in the owner drawn list boxes
 */
const USHORT yMaxCDBitmap = 16;

/*******************************************************************

    NAME:       WINDOW::CalcFixedHeight

    SYNOPSIS:   Calculate height of fixed-size (single line) owner-draw object

    ENTRY:      hwnd   - handle to the window
                pmis   - as passed by WM_MEASUREITEM in lParam

    EXIT:

    RETURNS:    FALSE if the calculation fails for some reason

    NOTES:
        This is a static member of the class.

        This WM_MEASUREITEM message is sent before the
        WM_INITDIALOG message (except for variable size owner-draw
        list controls).  Since the window properties are not yet set
        up, the owner dialog cannot be called.

        The chosen solution for list controls is to assume that every
        owner-draw control will always have the same height as the font
        of that list control.  This is a very reasonable guess for most
        owner-draw list controls.  Since owner-draw list controls with
        variable size items call the owner for every item, the window
        properties will have been properly initialized by that time.  Hence,
        a client may respond to these messages through OnOther.

        Currently, owner-draw buttons are not supported.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        Yi-HsinS    10-Dec-1992 Moved from bltowin.cxx

********************************************************************/

BOOL WINDOW::CalcFixedHeight( HWND hwnd, UINT *pnHeight )
{
    DISPLAY_CONTEXT dc( hwnd );

    HFONT hFont = (HFONT)::SendMessage( hwnd, WM_GETFONT, 0, 0L );
    if ( hFont != NULL )
    {
        // Font isn't the system font
        dc.SelectFont( hFont );
    }

    TEXTMETRIC tm;
    if ( ! dc.QueryTextMetrics( &tm ))
        return FALSE;

    *pnHeight = max((USHORT)tm.tmHeight, yMaxCDBitmap);

    return TRUE;
}

/*******************************************************************

    NAME:       ASSOCHWNDTHIS::ASSOCHWNDTHIS

    SYNOPSIS:   Associates a hwnd with a pwnd

    ENTRY:      hwnd - handle of window
                pwnd - pointer to WINDOW

    EXIT:       Window has two properties added

    NOTES:
        This class inherits from BASE.  If the association fails,
        it will report an error.

    HISTORY:
        beng        30-Sep-1991 Created
        beng        07-Nov-1991 Error mapping

********************************************************************/

ASSOCHWNDTHIS::ASSOCHWNDTHIS( HWND hwnd, const VOID * pv )
    : _hwnd(hwnd)
{
    if (hwnd == 0 || pv == 0)
    {
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

#ifdef _WIN64
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)pv ))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#else
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)LOWORD( (ULONG_PTR)pv )))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)HIWORD( (ULONG_PTR)pv )))
    {
        ::RemoveProp( hwnd, (TCHAR*)_pszPropThisLo );
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#endif
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::~ASSOCHWNDTHIS

    SYNOPSIS:   Disassociate a hwnd from the WINDOW object.

    ENTRY:      There are two properties on the hwnd which
                contain the seg:off of the WINDOW object.

    EXIT:       Those two props are dust

    NOTES:
        This might seem unnecessary - after all, won't the
        DestroyWindow delete these properties?

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::DisassocHwndPwnd
        beng        30-Sep-1991 Made own class
        beng        04-Jun-1992 A little error checking needed here

********************************************************************/

ASSOCHWNDTHIS::~ASSOCHWNDTHIS()
{
    if (QueryError() == NERR_Success)
    {
#if defined(WIN32) && defined(WIN32_REMOVEPROP_BUG)
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)0 );
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)0 );
#else
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisLo );
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisHi );
#endif
    }
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::HwndToThis

    SYNOPSIS:   Given a hwnd, locate the corresponding object

    ENTRY:      hwnd - window handle returned by Windows

    RETURNS:    Pointer to some anonymous object, or NULL
                if nothing found

    NOTES:
        This is a static member function.

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::HwndToPwnd
        beng        30-Sep-1991 Made own class

********************************************************************/

VOID * ASSOCHWNDTHIS::HwndToThis( HWND hwnd )
{
    // GetProp returns 0 if it fails; hence these two will build
    // one 0L if they fail.
    //
#ifdef _WIN64
    return ::GetProp( hwnd, (TCHAR*)_pszPropThisLo );
#else
    return (VOID *)MAKELONG( ::GetProp( hwnd, (TCHAR*)_pszPropThisLo ),
                             ::GetProp( hwnd, (TCHAR*)_pszPropThisHi ));
#endif
}


/*********************************************************************

    NAME:       PROC_INSTANCE::PROC_INSTANCE

    SYNOPSIS:   constructor - create a Proc Instance

    ENTRY:      FARPROC fp

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::PROC_INSTANCE( MFARPROC fp )
#if defined(WIN32)
    : _fpInstance(fp)
#else
    : _fpInstance( ::MakeProcInstance( fp, BLT::QueryInstance() ))
#endif
{
    if ( _fpInstance == NULL )
    {
        //  Assume memory failure
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
    }
}


/*********************************************************************

    NAME:       PROC_INSTANCE::~PROC_INSTANCE

    SYNOPSIS:   destructor - free the procedure instance

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::~PROC_INSTANCE()
{
#if !defined(WIN32)
    if ( _fpInstance != NULL )
    {
        ::FreeProcInstance( _fpInstance );
# if defined(DEBUG)
        _fpInstance = NULL;
# endif
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\dlist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    dlist.cxx
    LM 3.0 Generic dlist package

    This file contains the base routines for the DLIST class defined in
    dlist.hxx

    See the beginning of dlist.hxx for usage examples.

    FILE HISTORY:
        johnl       23-Jul-1990 Created
        Johnl       31-Oct-1990 Updated to reflect new iterator functionality
                                (Current pos. of iter. is the item previously
                                returned by next, remove(iter) removes the
                                element the iter is pointing to).
        Johnl        1-Jan-1991 Updated to use UIAssert
        beng        07-Feb-1991 Uses lmui.hxx
        johnl        7-Mar-1991 Made code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        terryk      21-Sep-1991 Added {} between UIDEBUG
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output
*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*********************************************************************

    NAME:       DLIST::DLIST

    SYNOPSIS:   Constructor for the DLIST

    HISTORY:    johnl   23-Jul-90   Created

*********************************************************************/

DLIST::DLIST()
{
    _pdlHead = _pdlTail = NULL;
    _pdliterRegisteredIters = NULL;
}


/*********************************************************************

    NAME:       DLIST::~DLIST

    SYNOPSIS:   Destructor for the DLIST

    HISTORY:    johnl   23-Jul-90   Created

*********************************************************************/

DLIST::~DLIST()
{
    /* Deregister bumps _pdliterRegisteredIters to the next iterator...
     */
    while ( _pdliterRegisteredIters != NULL )
        Deregister( _pdliterRegisteredIters );
}


/*********************************************************************

    NAME:       DLIST::Add

    SYNOPSIS:   Adds the passed element to the beginning of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY of not successful

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR DLIST::Add( VOID *pelem )
{
    UIASSERT( pelem != NULL );

    DL_NODE * pdlnodeNew = new DL_NODE( NULL, _pdlHead, pelem );
    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;       /* failure */

    if ( _pdlTail == NULL )           /* First item in list */
        _pdlTail = pdlnodeNew;
    else
        _pdlHead->_pdlnodePrev = pdlnodeNew;

    _pdlHead = pdlnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       DLIST::QueryNumElem

    SYNOPSIS:   Returns the number of elements in the dlist

    ENTRY:      NONE

    EXIT:       A UINT indicating the number of elements in the list.

    HISTORY:    rustanl   15-Jul-90       Created
                johnl     19-Jul-90       Adapted for the DLIST package

*********************************************************************/

UINT DLIST::QueryNumElem()
{
    register DL_NODE * pdlnode = _pdlHead;
    UINT uNumElem = 0;

    while ( pdlnode != NULL )
    {
        uNumElem++;
        pdlnode = pdlnode->_pdlnodeNext;
    }

    return uNumElem;
}


/*********************************************************************

    NAME:       DLIST::Append

    SYNOPSIS:   Adds the passed element to the end of the list.

    ENTRY:      A pointer to a valid element (NOTE: the outer layer actually
                accepts a const reference to the element then copies it and
                sends the address along).

    EXIT:       NERR_Success if successful, otherwise an error code, one of:
                ERROR_NOT_ENOUGH_MEMORY

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR DLIST::Append( VOID *pelem )
{
    UIASSERT( pelem != NULL );

    DL_NODE * pdlnodeNew = new DL_NODE( _pdlTail, NULL, pelem );

    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    if ( _pdlHead == NULL )
        _pdlHead = pdlnodeNew;
    else
        _pdlTail->_pdlnodeNext = pdlnodeNew;

    _pdlTail = pdlnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       DLIST::Insert

    SYNOPSIS:   Insert an element into a dlist using the location of the
                passed iterator.

    ENTRY:      Pointer to the element to insert
                Iterator indicating insertion point

    EXIT:       return NERR_Success if successful,
                ERROR_NOT_ENOUGH_MEMORY if an allocation failure occurred
                ERROR_INVALID_DATA if a bad iterator was passed in

    NOTES:      -ITER_DL & RITER_DL
                    If a bad iterator is passed in (i.e., one not registered on
                this list), the current behavior is to assert out.  We may
                want to change this to return an error code (even though this
                should be considered as a programmer's error).

                The insertion point is always "previous" to the element the
                iterator is pointing at (which means the forward and reverse
                iterators have the same logical insertion point, but the
                opposite absolute insertion point).

    HISTORY:    johnl   7-25-90     Created
                Johnl  10-31-90     Reflects new iterator functionality
                MikeMi 6-30-95      Added previous next pointer fix

*********************************************************************/

APIERR DLIST::Insert( VOID *pelem, ITER_DL& dliter )
{
    UIASSERT( pelem != NULL );

    if ( !CheckIter( &dliter ) )
    {
        UIDEBUG(SZ("DLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    DL_NODE *pdlnodeCurrent = dliter._pdlnodeCurrent;

    if ( pdlnodeCurrent == NULL ) /* Check if iter at end */
            return (Append( pelem ));

    DL_NODE * pdlnodeNew = new DL_NODE( pdlnodeCurrent,
                                        pdlnodeCurrent->_pdlnodeNext,
                                        pdlnodeCurrent->_pelem       );

    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pdlnodeCurrent->Set( pdlnodeCurrent->_pdlnodePrev,
                         pdlnodeNew, pelem );

    
    if ( _pdlTail == pdlnodeCurrent )   // Fixup tail pointer if necessary
    {
        _pdlTail = pdlnodeNew;
    }
    else
    {
        // rememer to set next's previouses to us
        pdlnodeNew->_pdlnodeNext->_pdlnodePrev = pdlnodeNew;
    }
    BumpIters( pdlnodeCurrent );

    return NERR_Success;
}


/*
 * Insert using a RITER_DL
 */

APIERR DLIST::Insert( VOID *pelem, RITER_DL& dlriter )
{
    UIASSERT( pelem != NULL );

    if ( !CheckIter( &dlriter ) )
    {
        UIDEBUG(SZ("DLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    DL_NODE *pdlnodeCurrent = dlriter._pdlnodeCurrent;

    if ( pdlnodeCurrent == NULL ) /* Check if iter at end/beginning */
            return (Append( pelem ));

    DL_NODE * pdlnodeNew = new DL_NODE( pdlnodeCurrent->_pdlnodePrev,
                                        pdlnodeCurrent,
                                        pdlnodeCurrent->_pelem       );
    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pdlnodeCurrent->Set( pdlnodeNew,
                         pdlnodeCurrent->_pdlnodeNext, pelem );

    if ( _pdlHead == pdlnodeCurrent )   // Fixup tail pointer if necessary
    {
        _pdlHead = pdlnodeNew;
    }
    else
    {
        // rememer to set previous next to us
        pdlnodeNew->_pdlnodePrev->_pdlnodeNext = pdlnodeNew;
    }

    BumpIters( pdlnodeCurrent );

    return NERR_Success;
}


/*********************************************************************

    NAME:       DLIST::Remove

    SYNOPSIS:   Removes the element the passed iterator points to

    ENTRY:      A Valid registered iterator

    EXIT:       A pointer to the newly removed element
                NULL if the list is empty or the iterator is at the end of the
                list

    NOTES:      If an unregistered iterator is passed in, the current
                implementation asserts out.

    HISTORY:    johnl   7-25-90     Created
                Johnl  10-31-90     Reflects new iterator functionality

*********************************************************************/

VOID * DLIST::Remove( ITER_DL& dliter )
{
    if ( !CheckIter( &dliter ) )
    {
        UIDEBUG(SZ("DLIST::Remove - Attempted to remove w/ Unregistered iterator\n\r"));
        return NULL;
    }

    return Unlink( dliter._pdlnodeCurrent );
}


/*
 * Reverse iterator version of the above
 */

VOID * DLIST::Remove( RITER_DL& dlriter )
{
    if ( !CheckIter( &dlriter ) )
    {
        UIDEBUG(SZ("DLIST::Remove - Attempted to remove w/ Unregistered iterator\n\r"));
        return NULL;
    }

    return Unlink( dlriter._pdlnodeCurrent );
}


/*******************************************************************

    NAME:     DLIST::Unlink

    SYNOPSIS: Removes and deletes the passed DL_NODE from the dlist.  Returns
              a pointer to the nodes properties if successful, NULL
              if not found.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   7-Mar-1991      Created

********************************************************************/

VOID * DLIST::Unlink( DL_NODE * pdlnodeTarget )
{
    if ( _pdlHead == NULL || pdlnodeTarget == NULL )
        return NULL;  /* Empty dlist or iter on last node of dlist */

    if ( _pdlTail == _pdlHead )       /* Only node in list */
        _pdlTail = _pdlHead = NULL;
    else if ( pdlnodeTarget == _pdlHead )         /* First */
    {
        pdlnodeTarget->_pdlnodeNext->_pdlnodePrev = NULL;
        _pdlHead = pdlnodeTarget->_pdlnodeNext;
    }
    else if ( pdlnodeTarget == _pdlTail )         /* Last */
    {
        pdlnodeTarget->_pdlnodePrev->_pdlnodeNext = NULL;
        _pdlTail = pdlnodeTarget->_pdlnodePrev;
    }
    else                                   /* Middle */
    {
        pdlnodeTarget->_pdlnodePrev->_pdlnodeNext = pdlnodeTarget->_pdlnodeNext;
        pdlnodeTarget->_pdlnodeNext->_pdlnodePrev = pdlnodeTarget->_pdlnodePrev;
    }

    BumpIters( pdlnodeTarget );  /* Move iters to next node... */

    VOID * pelem = pdlnodeTarget->_pelem;
    delete pdlnodeTarget;
    return pelem;
}

/*********************************************************************

    NAME:       DLIST::Register

    SYNOPSIS:   Adds the pointer to the passed iterator to the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator

    EXIT:       0 if successful, non-zero if an error occurred

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::Register( ITER_L * pdliter )
{
    pdliter->_pdliterNext = _pdliterRegisteredIters;
    _pdliterRegisteredIters = pdliter;
}


/*********************************************************************

    NAME:       DLIST::Deregister

    SYNOPSIS:   Removes the pointer to the passed iterator from the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator, registered iterator

    EXIT:       NONE

    NOTES:      Deregister must succeed, if it fails, then an internal error
                has occurred.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::Deregister( ITER_L * pdliter )
{
    register ITER_L *piter     = _pdliterRegisteredIters,
                    *piterPrev = NULL;

    while ( piter != NULL )
    {
        if ( piter == pdliter )
        {
            if ( piterPrev != NULL ) /* if not first node in list */
                 piterPrev->_pdliterNext = piter->_pdliterNext;
            else
            {
                if ( piter->_pdliterNext == NULL )
                    _pdliterRegisteredIters = NULL; /* only item in list */
                else
                    _pdliterRegisteredIters = piter->_pdliterNext;
            }

            pdliter->_pdlist = NULL;
            pdliter->_pdlnodeCurrent = NULL;
            pdliter->_pdliterNext = NULL;
            return;
        }
        else
        {
            piterPrev = piter;
            piter = piter->_pdliterNext;
        }
    }
    UIASSERT( !SZ("DLIST::Deregister Internal Error") ); /* We should never get here */
}

/*********************************************************************

    NAME:       DLIST::BumpIters

    SYNOPSIS:   Moves iterators to next element that point to the passed node

    ENTRY:      A valid DL_NODE that will be going away

    EXIT:       None

    NOTES:      BumpIters is used in cases where a particular element is going
                to be deleted.  BumpIters finds all of the iterators that
                point to the soon to be deceased node and bumps them to the
                next element using their Next() method.

                If the iterator hasn't been used, then it will need to be
                bumped twice to get its internal info to move to the next
                item in the list

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::BumpIters( DL_NODE* pdlnode )
{
    register ITER_L * piter = _pdliterRegisteredIters;

    while ( piter != NULL )
        if ( piter->_pdlnodeCurrent == pdlnode )
            piter->vNext();
        else
            piter = piter->_pdliterNext;
}


/*********************************************************************

    NAME:       DLIST::SetIters

    SYNOPSIS:   Sets all registered iterators to the passed value

    ENTRY:      A pointer to a a DL_NODE (or NULL)

    EXIT:       All iterators will point to the passed value

    NOTES:      This is generally used in cases after the list has been
                emptied, so the passed in value will normally be NULL.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::SetIters( DL_NODE *pdlnode )
{
    register ITER_L * piter = _pdliterRegisteredIters;

    while ( piter != NULL )
    {
        piter->_pdlnodeCurrent = pdlnode;
        piter = piter->_pdliterNext;
    }
}


/*********************************************************************

    NAME:       DLIST::CheckIter

    SYNOPSIS:   Confirms the passed iter belongs to this list

    ENTRY:      A pointer to an iterator

    EXIT:       TRUE if the passed iterator belongs, FALSE otherwise.

    NOTES:      CheckIter is generally used with methods that pass in an
                iterator as a parameter (such as Insert).  It is the option
                of the method whether to abort or not when a bad iterator
                is passed in.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

BOOL DLIST::CheckIter( ITER_L *pdliter )
{
    ITER_L * piter = _pdliterRegisteredIters;

    while ( piter != NULL && piter != pdliter )
        piter = piter->_pdliterNext;

    return ( piter != NULL );
}


/*********************************************************************

    NAME:       ITER_DL::ITER_DL

    SYNOPSIS:   Constructor for DLIST iterator

    ENTRY:      Pointer to a valid DLIST

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_DL::ITER_DL( DLIST * pdl )
{
    UIASSERT( pdl != NULL );

    _pdlist         = pdl;
    _pdlnodeCurrent = pdl->_pdlHead;
    _fUsed          = FALSE;
    _pdliterNext    = NULL;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       ITER_DL::ITER_DL

    SYNOPSIS:   Constructor for DLIST iterator,
                uses passed iterator for new position

    ENTRY:      Pointer to a valid DLIST iterator

    HISTORY:    johnl   10-16-90     Created

*********************************************************************/

ITER_DL::ITER_DL( const ITER_DL& iterdl )
{
    _pdlist         = iterdl._pdlist;
    _pdlnodeCurrent = iterdl._pdlnodeCurrent;
    _fUsed          = iterdl._fUsed;
    _pdliterNext    = iterdl._pdliterNext;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       ITER_DL::~ITER_DL

    SYNOPSIS:   Destructor for ITER_DL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_DL::~ITER_DL()
{
    if ( _pdlist != NULL )
        _pdlist->Deregister( this );

    _pdlist = NULL;
    _pdlnodeCurrent = NULL;
    _pdliterNext = NULL;
}


/*********************************************************************

    NAME:       ITER_DL::vNext

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL
                Goes to next node in the list.

    NOTES:

    HISTORY:    johnl   7-25-90     Created
                Johnl  10-31-90     Updated to reflect new iterator functionality

*********************************************************************/

VOID * ITER_DL::vNext()
{
    if ( _pdlnodeCurrent != NULL )
        if ( _fUsed )
            _pdlnodeCurrent = _pdlnodeCurrent->_pdlnodeNext;
        else
            _fUsed = TRUE;

    return ( _pdlnodeCurrent != NULL ? _pdlnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       ITER_DL::Reset

    SYNOPSIS:   Resets the iterator to the beginning of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:    johnl   7-25-90     Created
                JohnL   4-16-91     Added check if slist is already destructed

*********************************************************************/

VOID ITER_DL::Reset()
{
    if ( _pdlist != NULL )
        _pdlnodeCurrent = _pdlist->_pdlHead;
    _fUsed = FALSE;
}


/*********************************************************************

    NAME:       RITER_DL::RITER_DL

    SYNOPSIS:   Constructor for DLIST Reverse iterator

    ENTRY:      Pointer to a valid DLIST

    EXIT:

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

RITER_DL::RITER_DL( DLIST * pdl )
{
    _pdlist        = pdl;
    _pdlnodeCurrent= _pdlist->_pdlTail;
    _fUsed         = FALSE;
    _pdliterNext   = NULL;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       RITER_DL::RITER_DL

    SYNOPSIS:   Constructor for DLIST iterator, uses passed iterator for new position

    ENTRY:      Pointer to a valid DLIST riterator

    HISTORY:    johnl   10-16-90     Created

*********************************************************************/

RITER_DL::RITER_DL( const RITER_DL& riterdl )
{
    _pdlist         = riterdl._pdlist;
    _pdlnodeCurrent = riterdl._pdlnodeCurrent;
    _fUsed          = riterdl._fUsed;
    _pdliterNext    = riterdl._pdliterNext;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       RITER_DL::~RITER_DL

    SYNOPSIS:   Destructor for RITER_DL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

RITER_DL::~RITER_DL()
{
    if ( _pdlist != NULL )
        _pdlist->Deregister( this );

    _pdlist = NULL;
    _pdlnodeCurrent = NULL;
    _pdliterNext = NULL;
}


/*********************************************************************

    NAME:       RITER_DL::vNext

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL
                Goes to next node in the list.

    NOTES:

    HISTORY:

*********************************************************************/

VOID * RITER_DL::vNext()
{
    if ( _pdlnodeCurrent != NULL )
        if ( _fUsed )
            _pdlnodeCurrent = _pdlnodeCurrent->_pdlnodePrev;
        else
            _fUsed = TRUE;

    return ( _pdlnodeCurrent != NULL ? _pdlnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       RITER_DL::Reset

    SYNOPSIS:   Resets the reverse iterator to the end of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:

*********************************************************************/

VOID RITER_DL::Reset()
{
    if ( _pdlist != NULL )
        _pdlnodeCurrent = _pdlist->_pdlTail;
    _fUsed = FALSE;
}

/*
 * Debug information for DLIST
 */

VOID DLIST::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    register DL_NODE *_pdlnode = _pdlHead;
    UINT uCnt = 0;
    char buff[250];

    UIDEBUG(SZ("DLIST::DebugPrint - Dlist status:") );

    if ( _pdlHead == NULL )
    {
        UIDEBUG(SZ("Empty dlist"));
    }

    if ( _pdliterRegisteredIters == NULL )
    {
        UIDEBUG(SZ("No registered iterators"));
    }
    else
    {
        register ITER_L * piter = _pdliterRegisteredIters;
        UIDEBUG(SZ("Iter->dlnode:"));
        while ( piter != NULL )
        {
            sprintf(buff, SZ("[%Fp]->[%Fp fEnd=%s]"),
                     piter,
                     piter->_pdlnodeCurrent,
                     piter->_fUsed ? SZ("TRUE") : SZ("FALSE") );
            UIDEBUG(buff);
            piter = piter->_pdliterNext;
        }
    }

    sprintf(buff,SZ("Head = [%Fp], Tail = [%Fp]\n"), _pdlHead, _pdlTail );
    UIDEBUG(buff);

    while ( _pdlnode != NULL )
    {
        register ITER_L *piter = _pdliterRegisteredIters;
        UINT uNumIters = 0;

        while ( piter != NULL ) /* Get # of iters pointing here */
        {
            if ( piter->_pdlnodeCurrent == _pdlnode )
                uNumIters++;
            piter = piter->_pdliterNext;
        }

        sprintf( buff, SZ("[%Fp](%d)"), _pdlnode, uNumIters );
        UIDEBUG( buff );

        _pdlnode = _pdlnode->_pdlnodeNext;
    }

#endif //DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\lhourset.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lhourset.cxx

    This file contains the implementation for the class
    LOGON_HOURS_SETTING, which communicates between LMOBJ and BLTCC.

    FILE HISTORY:
        beng        06-May-1992 Created (from lmouser.cxx)

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

#include "lhourset.hxx"


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::LOGON_HOURS_SETTING

    SYNOPSIS:   constructor for the LOGON_HOURS_SETTING object

    ENTRY:      pLogonHours -   packed bit block
                unitsperweek -  number of bits in LogonHours block

                default means new user defaults

    EXIT:       Object is constructed

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

LOGON_HOURS_SETTING::LOGON_HOURS_SETTING( const BYTE * pbLogonHours,
                                          UINT unitsperweek )
    : BASE(),
      _cUnitsPerWeek( 0 ),
      _buf()
{
    APIERR err = _buf.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( pbLogonHours == NULL )
        err = MakeDefault();
    else
        err = SetFromBits( pbLogonHours, unitsperweek );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

LOGON_HOURS_SETTING::LOGON_HOURS_SETTING( const LOGON_HOURS_SETTING & lhours )
    : BASE(),
      _cUnitsPerWeek( 0 ),
      _buf()
{
    APIERR err = _buf.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = Set( lhours );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::~LOGON_HOURS_SETTING

    SYNOPSIS:   destructor for the LOGON_HOURS_SETTING object

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

LOGON_HOURS_SETTING::~LOGON_HOURS_SETTING()
{
    // Does nothing further of any interest (BUFFER dtor does all)
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::SetFromBits

    SYNOPSIS:   Changes logon hours setting

    ENTRY:      unitsperweek -  number of bits in LogonHours block
                pLogonHours -   packed bit block

    RETURNS:    Standard error code

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::SetFromBits( const BYTE * pLogonHours,
                                         UINT unitsperweek )
{
    UINT cb = QueryByteCount( unitsperweek );

    APIERR err = _buf.Resize( cb );
    if ( err != NERR_Success )
        return err;

    BYTE * pNewLogonHours = _buf.QueryPtr();

    ::memcpy(  (TCHAR *)pNewLogonHours,
                (TCHAR *)pLogonHours,
                cb );

    // clear extra bits in last byte
    UINT cLeftoverBits = (unitsperweek % 8);
    if ( cLeftoverBits != 0 )
        pNewLogonHours[cb - 1] &=
                (BYTE)((WORD)0x00ff >> (8 - cLeftoverBits));

    _cUnitsPerWeek = unitsperweek;

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::PermitAll

    SYNOPSIS:   Changes logon hours setting to always allow logon

    RETURNS:    Standard error code

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::PermitAll()
{
    BYTE * pNewLogonHours = _buf.QueryPtr();

    ::memset( (TCHAR *)pNewLogonHours, 0xFF, QueryByteCount() );

    // clear extra bits in last byte
    UINT cLeftoverBits = (_cUnitsPerWeek % 8);
    if ( cLeftoverBits != 0 )
        pNewLogonHours[QueryByteCount() - 1] &=
                (BYTE)((WORD)0x00ff >> (8 - cLeftoverBits));

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::MakeDefault

    SYNOPSIS:   Changes logon hours setting new user default

    RETURNS:    Standard error code

    HISTORY:
        jonn        12/19/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::MakeDefault()
{
    UINT cb = QueryByteCount( cHoursPerWeek );

    APIERR err = _buf.Resize( cb );
    if ( err != NERR_Success )
        return err;

    _cUnitsPerWeek = cHoursPerWeek;

    return PermitAll();
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::IsIdenticalToBits

    SYNOPSIS:   Compares two logon hours settings

    RETURNS:    TRUE iff they are identical

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

BOOL LOGON_HOURS_SETTING::IsIdenticalToBits( const BYTE * pLogonHours,
                                             UINT unitsperweek ) const
{
    return (    (unitsperweek == _cUnitsPerWeek)
            && !(::memcmp( (TCHAR *)(_buf.QueryPtr()),
                           (TCHAR *)pLogonHours,
                            QueryByteCount() ))
           );
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::QueryHourInWeek

    SYNOPSIS:   Determines whether logon is allowed in a specific hour
                of the week.  UnitsPerWeek is required to be
                HoursPerWeek.

    RETURNS:    TRUE iff logon is allowed.  Returns FALSE if
                UnitsPerWeek is not HoursPerWeek (plus assertion for
                DEBUG).

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

BOOL LOGON_HOURS_SETTING::QueryHourInWeek( UINT hourinweek ) const
{
    ASSERT( hourinweek < cHoursPerWeek );
    ASSERT( _cUnitsPerWeek == cHoursPerWeek );
    if ( _cUnitsPerWeek != cHoursPerWeek )
        return FALSE;

    // "!!" moves the matching bit to the first position, just in
    //    case some caller misuses the BOOL return value
    return !!( QueryHoursBlock()[ hourinweek / 8 ]
                        & (0x1 << (hourinweek % 8)) );
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::SetHourInWeek

    SYNOPSIS:   Changes whether logon is allowed in a specific hour
                of the week.  UnitsPerWeek is required to be
                HoursPerWeek.

    RETURNS:    Standard error return, ERROR_INVALID_PARAMETER if
                UnitsPerWeek is not HoursPerWeek (plus assertion for
                DEBUG).

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::SetHourInWeek( BOOL fLogonAllowed,
                                           UINT hourinweek )
{
    ASSERT( hourinweek < cHoursPerWeek );
    ASSERT( _cUnitsPerWeek == cHoursPerWeek );
    if ( _cUnitsPerWeek != cHoursPerWeek )
        return ERROR_INVALID_PARAMETER;

    BYTE byte = 0x1 << (hourinweek % 8);
    UINT byteposition = (hourinweek / 8);
    BYTE *pb = QueryHoursBlock();
    if (fLogonAllowed)
        pb[ byteposition ] |= byte;
    else
        pb[ byteposition ] &= ~byte;
    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::ConvertToHoursPerWeek

    SYNOPSIS:   Converts the logon hours setting to HoursPerWeek
                format.  Only converts from DaysPerWeek or HoursPerWeek
                format.

    RETURNS:    Standard error return, ERROR_INVALID_PARAMETER if
                UnitsPerWeek is not DaysPerWeek or HoursPerWeek (plus
                assertion for DEBUG).

    NOTES:      Failure may leave the LOGON_HOURS_SETTING in an
                incomplete but internally consistent state.

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::ConvertToHoursPerWeek()
{
    switch ( _cUnitsPerWeek )
    {
        case HOURS_PER_WEEK:
            return NERR_Success;

        case DAYS_PER_WEEK:
            {
                APIERR err = MakeDefault();
                if ( err != NERR_Success )
                    return err;
                BYTE hoursblock = *( _buf.QueryPtr() );
                for ( UINT day = 0; day < cDaysPerWeek; day++ )
                {
                    BOOL fLogonToday = !!( hoursblock & (0x1 << day) );
                    for ( UINT hour = 0; hour < cHoursPerWeek; hour++ )
                    {
                        err = SetHourInDay( fLogonToday, hour, day );
                        if ( err != NERR_Success )
                            return err;
                    }
                }
            }
            return NERR_Success;

        // case cMinutesPerWeek:
        // default:
            // fall through
    }

    ASSERT( FALSE );
    return ERROR_INVALID_PARAMETER;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::ConvertToGMT

    SYNOPSIS:   Converts the logon hours setting to relative to GMT

    RETURNS:

    HISTORY:
        thomaspa        3/18/93    Created

********************************************************************/
BOOL LOGON_HOURS_SETTING::ConvertToGMT()
{
    return NetpRotateLogonHours( QueryHoursBlock(),
                                 QueryUnitsPerWeek(),
                                 TRUE );
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::ConvertFromGMT

    SYNOPSIS:   Converts the logon hours setting from relative to GMT

    RETURNS:

    HISTORY:
        thomaspa        3/18/93    Created

********************************************************************/
BOOL LOGON_HOURS_SETTING::ConvertFromGMT()
{
    return NetpRotateLogonHours( QueryHoursBlock(),
                                 QueryUnitsPerWeek(),
                                 FALSE );
}

APIERR LOGON_HOURS_SETTING::SetHourInDay(
    BOOL fLogonAllowed, UINT hourinday, UINT dayinweek )
{
    return SetHourInWeek(fLogonAllowed, hourinday + (dayinweek * cHoursPerDay));
}


BOOL LOGON_HOURS_SETTING::QueryHourInDay(
    UINT hourinday, UINT dayinweek ) const
{
    return QueryHourInWeek( hourinday + (dayinweek * cHoursPerDay) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\blt\bltcc\dead\bltlogon.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlogon.cxx
        Logon control objects

    FILE HISTORY:
        terryk  22-Jul-1991 Created

*/

LOGON_CHECKBOX::LOGON_CHECKBOX( OWNER_WINDOW *powin, CID cid, 
                                TCHAR * pszIDCheck, TCHAR * pszIDUnCheck )
    : GRAPHICAL_CHECKBOX( powin, cid, pszIDCheck, pszIDUnCheck ),
    CUSTOM_CONTROL( this )
{
    if ( QueryError( powin ) != NERR_Success )
        return;
}

LOGON_CHECKBOX::LOGON_CHECKBOX( OWNER_WINDOW *powin, CID cid,
                                TCHAR * pszIDCheck, TCHAR * pszIDUnCheck,
                                XYPOINY xy, XYDIMENSION dxy, ULONG flStyle )
    : GRAPHICAL_CHECKBOX( powin, cid, pszIDCheck, pszIDUnCheck, xy, dxy,
                          flStyle ),
    CUSTOM_CONTROL( this )
{
    if ( QueryError( powin ) != NERR_Success )
        return;
}

LOGON_DIALOG::LOGON_DIALOG( TCHAR * pszResourceName, HWND hwndOwner,
    CID cidClockBitmap, CID cidTopHourLabels, CID cidBotHourLabels,
    CID cidDayLabels, CID cidColumnHeader, CID cidFirstLogonCheckBox,
    CID cidLegends, XYRECT xyRulerPos )
    : DIALOG_WINDOW( pszResourceName, hwndOwner ),
{
    // Load Clock bitmap

    // set SLT
    INT i;

    for ( i = 0; i < 9; i++ )
    {
        sltTopLabel[ i ]( this, cidTopHourLabels + i );
        sltBotLabel[ i ]( this, cidBotHourLabels + i );
    }
}

LOGON_DIALOG::~LOGON_DIALOG()
{
}

VOID LOGON_DIALOG::Initialization()
{
}

VOID LOGON_DIALOG::DrawRuler()
{
}

VOID LOGON_DIALOG::LoadAllBitMap()
{
}

BOOL LOGON_DIALOG::OnKeyDown()
{
    switch ( wParam )
    {
    case VK_SHIFT:
        _fDrag = TRUE;
        break;
    default:
        break;
    }
}

BOOL LOGON_DIALOG::OnKeyUp()
{
    switch ( wParam )
    {
    case VK_SHIFT:
        _fDrag = FALSE;
        break;
    default:
        break;
    }
}

BOOL LOGON_DIALOG::OnChar( const CHAR_EVENT & event )
{
    switch ( event.QueryChar() )
    {
    case ID_CTRL_HOME:
        nCurrentHour = rlcbDayRow[0].FocusFirst();
        nCurrentDay = 0;
        break;

    case ID_CTRL_END:
        nCurrentHour = rlcbDayRow[6].FocusLast();
        nCurrentDay = 0;
        break;

    case ID_LEFT:
        nCurrentHour = rlcbDayRow[ nCurrentDay ].FocusLeft();
        break;

    case ID_RIGHT:
        nCurrentHour = rlcbDayRow[ nCurrentDay ].FocusRight();
        break;

    case ID_UP:
        nCurrentDay --;
        if ( nCurrentDay < 0 )
        {
            nCurrentDay = 0;
        }
        rlcbDayRow[ nCurrentDay].FocusHour( nCurrentHour );
        break;

    case ID_DOWN:
        nCurrentDay ++;
        if ( nCurrentDay > 6 )
        {
            nCurrentDay = 6;
        }
        rlcbDayRow[ nCurrentDay].FocusHour( nCurrentHour );

        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL LOGON_DIALOG::OnDragBegin( const MOUSE_EVENT & event )
{
    XYPOINT xyAnchor = event.QueryPos();
    XYRECT  xyrectTemp( xyAnchor, XYDIMENSION( 0, 0 ));
    _drectRegion = xyrectTemp;
    _drectRegion.Show( TRUE );
    return TRUE;
}

BOOL LOGON_DIALOG::OnDragEnd( const MOUSE_EVENT & event )
{
    UNREFERENCED( event );
    _drectRegion.Show( FALSE );
    return TRUE;    
}

BOOL LOGON_DIALOG::OnDragMove( cosnt MOUSE_EVENT & event )
{
    XYPOINT xyNewPos = event.QueryPos();
    XYPOINT xyAnchor = _drectRegion.QueryPos();
    XYDIMENSION dxyRegion( xyNewPos.QueryX() - xyAnchor.QueryX(),
                           xyNewPos.QueryY() - xyAnchor.QueryY()) ;
    XYRECT xyrectTemp( xyAnchor, dxyRegion );
    _drectRegion = xyrectTemp;                        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\bitfield.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    Bitfield.cxx

    This file contains generic bitfield implementation.

    Currently it is limited to a field of 32 bits.


    FILE HISTORY:
        Johnl       13-Jul-1991     Created

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:       BITFIELD::BITFIELD

    SYNOPSIS:   Various bitfield constructors

    ENTRY:      See different constructors

    EXIT:       If an allocation occurred, ReportError will be called

    NOTES:      (JonN 10/13/94) These constructors don't really make much
                sense.  Why initialize _cBitsinBitfield to some large number
                if _pbBitVector is zero?  Why initialize both _pbBitVector
                and _ulBitfield if they are in a union?

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BITFIELD::BITFIELD( unsigned cBitsInBitfield,
                    enum BITVALUES bitInit )
    : _cBitsInBitfield( cBitsInBitfield ),
      _pbBitVector ( NULL )
{
    UIASSERT( cBitsInBitfield > 0 ) ;

    APIERR err = AllocBitfield( cBitsInBitfield ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }

    SetAllBits( bitInit ) ;

}

BITFIELD::BITFIELD( const BYTE * pbInitValue,
                    unsigned cInitBytes,
                    unsigned cTotalBits )

/* pbInitValue - Pointer to bitfield initializer
 * cInitBytes  - Count of bytes contained in pbInitValue
 * cTotalBits  - Size of bitfield
 */
    : _cBitsInBitfield( cTotalBits ),       // Warning - Maybe 0
      _pbBitVector ( NULL )
{
    /* If the client passed in 0 for the bitfield size, then assume the
     * size should be the same size as the initializer
     */
    if ( !_cBitsInBitfield )
    {
        _cBitsInBitfield = 8*cInitBytes ;
    }

    APIERR err = AllocBitfield( _cBitsInBitfield ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }


    ::memcpyf( (char *) QueryBitPos( 0, QueryCount()),
               (char *) pbInitValue,
               QueryAllocSize() ) ;
}

BITFIELD::BITFIELD( const BITFIELD & bitfieldSrc )
    : _cBitsInBitfield( bitfieldSrc.QueryCount() ),
      _ulBitfield     ( 0L )
{
    UIASSERT( bitfieldSrc.QueryError() == NERR_Success ) ;

    APIERR err = AllocBitfield( _cBitsInBitfield ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }

    BYTE * pbSrc  = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest = QueryBitPos( 0, QueryCount() ) ;
    ::memcpyf( (char *)pbDest, (char *)pbSrc, QueryAllocSize() ) ;
}


BITFIELD::BITFIELD( USHORT usInit )
    : _cBitsInBitfield( 0 ),
      _ulBitfield     ( (ULONG) usInit )
{
    APIERR err = AllocBitfield( 8*sizeof(usInit) ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }
}

BITFIELD::BITFIELD( ULONG ulInit )
    : _cBitsInBitfield( 0 ),
      _ulBitfield     ( ulInit )
{
    APIERR err = AllocBitfield( 8*sizeof(ulInit) ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }
}


/*******************************************************************

    NAME:       BITFIELD::~BITFIELD

    SYNOPSIS:   Bitfield destructor

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BITFIELD::~BITFIELD()
{
    if ( IsAllocated() )
    {
        delete _pbBitVector ;
        _pbBitVector = NULL ;
    }

    _cBitsInBitfield = 0 ;
}


/*******************************************************************

    NAME:       BITFIELD::SetAllBits

    SYNOPSIS:   Sets all of the bits in the bitfield to the value
                specified

    ENTRY:      bit - Either ON or OFF

    EXIT:       All of the bits in the bitfield will be set to "bit"

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::SetAllBits( enum BITVALUES bit )
{
    int iFiller = ( bit == ON ? 0xffff : 0x0000 ) ;

    ::memsetf( (char *)QueryBitPos( 0, QueryCount() ),
                       iFiller,
                       QueryAllocSize() ) ;

}

/*******************************************************************

    NAME:       BITFIELD::SetBit

    SYNOPSIS:   Sets a particular bit to the specified value (default is ON)

    ENTRY:      iBitPos - Index of bit to set
                bitVal  - Value to set specified bit to

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::SetBit( unsigned iBitPos, enum BITVALUES bitVal )
{
    BYTE * pbDest = QueryBitPos( iBitPos, sizeof(BYTE) ) ;

    if ( bitVal )
        *pbDest |= ( ON << QueryOffset( iBitPos ) ) ;
    else
        *pbDest &= ( ~( ON << QueryOffset( iBitPos ) ) ) ;
}

/*******************************************************************

    NAME:       BITFIELD::IsBitSet

    SYNOPSIS:   Returns BOOLEAN indicating if the specified bit is set

    ENTRY:      iBitPos is the requested bit

    RETURNS:    TRUE if the specified bit is set (ON), FALSE otherwise

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BOOL BITFIELD::IsBitSet( unsigned iBitPos ) const
{
    const BYTE * pbSrc = QueryBitPos( iBitPos, sizeof(BYTE) ) ;

    return ( *pbSrc & ( ON << QueryOffset( iBitPos ) ) );
}

/*******************************************************************

    NAME:       BITFIELD::operator=

    SYNOPSIS:   Assignment between two bitfields

    ENTRY:      bitfieldSrc is the src bitfield, this receives the copy

    NOTES:      Currently requires bitfields to be of the same size.

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BITFIELD & BITFIELD::operator=( const BITFIELD & bitfieldSrc )
{
    UIASSERT( QueryCount() == bitfieldSrc.QueryCount() ) ;

    BYTE * pbSrc  = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest = QueryBitPos( 0, QueryCount() ) ;
    ::memcpyf( (char *)pbDest, (char *)pbSrc, QueryAllocSize() ) ;

    return *this ;
}

BITFIELD & BITFIELD::operator=( USHORT usMask )
{
    UIASSERT( QueryCount() == sizeof(usMask)*8 ) ;

    *((USHORT *)QueryBitPos( 0, QueryCount() )) = usMask ;

    return *this ;
}

BITFIELD & BITFIELD::operator=( ULONG ulMask )
{
    UIASSERT( QueryCount() == sizeof(ulMask)*8 ) ;

    *((ULONG *)QueryBitPos( 0, QueryCount() )) = ulMask ;

    return *this ;
}

/*******************************************************************

    NAME:       BITFIELD::operator&=

    SYNOPSIS:   Performs a bitwise AND between *this and the passed bitfield

    ENTRY:      bitfieldSrc is the mask to apply to *this

    EXIT:       *this contains the result after the AND

    NOTES:      The two bitfields must be the same size

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::operator&=( const BITFIELD & bitfieldSrc )
{
    UIASSERT( QueryCount() == bitfieldSrc.QueryCount() ) ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    for ( unsigned i = QueryAllocSize() ; i != 0 ; i--, pbSrc++, pbDest++ )
        *pbDest = *pbSrc & *pbDest ;
}

/*******************************************************************

    NAME:       BITFIELD::operator|=

    SYNOPSIS:   Performs a bitwise OR between *this and the passed bitfield

    ENTRY:      bitfieldSrc is the mask to apply to *this

    EXIT:       *this contains the result after the OR

    NOTES:      The two bitfields must be the same size

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::operator|=( const BITFIELD & bitfieldSrc )
{
    UIASSERT( QueryCount() == bitfieldSrc.QueryCount() ) ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    for ( unsigned i = QueryAllocSize() ; i != 0 ; i--, pbSrc++, pbDest++ )
        *pbDest = *pbSrc | *pbDest ;
}

/*******************************************************************

    NAME:       BITFIELD::operator==

    SYNOPSIS:   Equality operator for the bitfield class

    ENTRY:      bitfieldSrc is the compare item

    RETURNS:    TRUE if bitfieldSrc has the same bits set as *this.

    NOTES:      Bitfields must be of the same size

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BOOL BITFIELD::operator==( BITFIELD & bitfieldSrc )
{
    if ( QueryCount() != bitfieldSrc.QueryCount() )
        return FALSE ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    /* Compare all bytes except for the last one (which may overhang)
     */
    for ( unsigned i = QueryAllocSize()-1 ; i != 0 ; i--, pbSrc++, pbDest++ )
    {
        if ( *pbSrc != *pbDest )
            return FALSE ;
    }

    /* For the last byte, since there might be an overhang, mask out
     * the bits we don't care about and only compare the significant
     * bits.
     */
    unsigned uOffset = QueryOffset( QueryCount() ) ;
    BYTE bMask = ((BYTE) 0xff) >> uOffset ;
    *pbSrc  &= bMask ;
    *pbDest &= bMask ;
    if ( *pbDest != *pbSrc )
        return FALSE ;

    return TRUE ;
}

BOOL BITFIELD::operator==( ULONG ulMask ) const
{
    /* If *this isn't at least as big as the ULONG mask, then assume they
     * are not equal.
     */
    if ( QueryCount() != 8*sizeof(ulMask)  ||
         ( ulMask != *( (ULONG *) QueryBitPos( 0, QueryCount())) ) )
        return FALSE ;

    return TRUE ;
}

BOOL BITFIELD::operator==( USHORT usMask ) const
{
    /* If *this isn't at least as big as the USHORT mask, then assume they
     * are not equal.
     */
    if ( QueryCount() != 8*sizeof(usMask)  ||
         ( usMask != *( (USHORT *) QueryBitPos( 0, QueryCount())) ) )
        return FALSE ;

    return TRUE ;
}

/*******************************************************************

    NAME:       BITFIELD::operator&

    SYNOPSIS:   Performs a bitwise AND of this and the passed bitfield.

    ENTRY:

    EXIT:

    RETURNS:    TRUE if any individual AND operations are TRUE, FALSE
                otherwise.

    NOTES:

    HISTORY:
        Johnl   30-Aug-1991     Created
********************************************************************/

BOOL BITFIELD::operator&( const BITFIELD & bitfieldSrc )
{
    if ( QueryCount() != bitfieldSrc.QueryCount() )
        return FALSE ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    /* Compare all bytes except for the last one (which may overhang)
     */
    for ( unsigned i = QueryAllocSize()-1 ; i != 0 ; i--, pbSrc++, pbDest++ )
    {
        if ( *pbSrc & *pbDest )
            return TRUE ;
    }

    /* For the last byte, since there might be an overhang, mask out
     * the bits we don't care about and only compare the significant
     * bits.
     */
    unsigned uOffset = QueryOffset( QueryCount() ) ;
    BYTE bMask = ((BYTE) 0xff) >> uOffset ;
    *pbSrc  &= bMask ;
    *pbDest &= bMask ;
    if ( *pbDest & *pbSrc )
        return TRUE ;

    return FALSE ;
}

/*******************************************************************

    NAME:       BITFIELD::operator&=

    SYNOPSIS:   Data type-wise AND operation for BYTE, unsigned & ULONG

    ENTRY:      ?Src is the input mask

    EXIT:       The lowest bits will be operated on according to the mask

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

#if 0
void BITFIELD::operator&=( BYTE     bSrc )
{
    BYTE * pbDest= QueryBitPos( 0, sizeof( bSrc ) ) ;

    *pbDest &= bSrc ;
}
#endif

void BITFIELD::operator&=( USHORT usSrc )
{
    USHORT * pusDest= (USHORT *) QueryBitPos( 0, sizeof( usSrc ) ) ;

    *pusDest &= usSrc ;
}

void BITFIELD::operator&=( ULONG    ulSrc )
{
    ULONG * pulDest= (ULONG *) QueryBitPos( 0, sizeof( ulSrc ) ) ;

    *pulDest &= ulSrc ;
}

/*******************************************************************

    NAME:       BITFIELD::operator|=

    SYNOPSIS:   Data type-wise OR operation for BYTE, unsigned & ULONG

    ENTRY:      ?Src is the input mask

    EXIT:       The lowest bits will be operated on according to the mask

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

#if 0
void BITFIELD::operator|=( BYTE     bSrc )
{
    BYTE * pbDest= QueryBitPos( 0, sizeof( bSrc ) ) ;

    *pbDest |= bSrc ;
}
#endif

void BITFIELD::operator|=( USHORT usSrc )
{
    USHORT * pusDest= (USHORT *) QueryBitPos( 0, sizeof( usSrc ) ) ;

    *pusDest |= usSrc ;
}

void BITFIELD::operator|=( ULONG    ulSrc )
{
    ULONG * pulDest= (ULONG *) QueryBitPos( 0, sizeof( ulSrc ) ) ;

    *pulDest |= ulSrc ;
}

/*******************************************************************

    NAME:       BITFIELD::operator()

    SYNOPSIS:   These three methods provide easy ways to get the standard
                data types out of the bitfield.

    NOTES:
                The Bitfield must be the same size as the converted type

    HISTORY:
        Johnl   01-Aug-1991     Created

********************************************************************/

BITFIELD::operator ULONG()
{
    UIASSERT( sizeof(ULONG)*8 == QueryCount() ) ;
    return *( (ULONG *)QueryBitPos( 0, sizeof(ULONG)*8 ) ) ;
}

BITFIELD::operator USHORT()
{
    UIASSERT( sizeof(USHORT)*8 == QueryCount() ) ;
    return *((USHORT *)QueryBitPos( 0, sizeof(USHORT)*8 ) ) ;
}

#if 0
BITFIELD::operator BYTE()
{
    UIASSERT( sizeof(BYTE)*8 == QueryCount() ) ;
    return *((BYTE *)QueryBitPos( 0, sizeof(BYTE)*8 ) ) ;
}
#endif

/*******************************************************************

    NAME:       BITFIELD::QueryBitPos

    SYNOPSIS:   Returns a pointer to the BYTE the requested bit is residing
                in

    ENTRY:      iBitOffset is the bit number (or starting bit number) we
                        are interested in.
                cbitsTargetOpSize is the count of bits we will read from
                        or write to.  This value is used for bounds checking.

    RETURNS:    Pointer to the BYTE that contains the requested bit

    NOTES:
                We assert out if the operation is going to go past the
                end of the bitfield or the requested bit is beyond the
                end of the bitfield.

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BYTE * BITFIELD::QueryBitPos( unsigned iBitOffset,
                              unsigned cbitsTargetOpSize ) const
{
    UIASSERT( QueryError() == NERR_Success ) ;

    /* Assert out if the requested bit is out of range
     */
    UIASSERT( iBitOffset < QueryCount() ) ;

    /* Assert out if the operation to be performed will cause us to
     * go out of range
     */
    UIASSERT( iBitOffset + cbitsTargetOpSize <= QueryCount() ) ;

    BYTE * pbBitVec = ( IsAllocated() ? _pbBitVector : (BYTE *)&_ulBitfield ) ;

    return ( pbBitVec + iBitOffset / 8 ) ;
}

/*******************************************************************

    NAME:       BITFIELD::Not

    SYNOPSIS:   Performs a bitwise complement of the bitfield (i.e., '~')

    NOTES:

    HISTORY:
        Johnl   30-Aug-1991     Created
********************************************************************/

void BITFIELD::Not( void )
{
    BYTE * pbSrc = QueryBitPos( 0, QueryCount() ) ;

    for ( unsigned i = QueryAllocSize() ; i != 0 ; i--, pbSrc++ )
    {
        *pbSrc = ~*pbSrc ;
    }
}

/*******************************************************************

    NAME:       BITFIELD::AllocBitfield

    SYNOPSIS:   Sets up bitfield and allocates memory if necessary

    ENTRY:

    EXIT:       All of the size related members are set properly

    RETURNS:    NERR_Success if successful

    NOTES:      (JonN 10/13/94) This is completely wrong, I'm
                amazed we ever got away with it.  We free the old vector
                if the new one is >32 bits, not if the old one is greater
                than 32 bits.

    HISTORY:
        Johnl   31-Jul-1991     Created
        Johnl   18-Sep-1991     Will snap back if the allocation fails

********************************************************************/

APIERR BITFIELD::AllocBitfield( unsigned cBitsInBitfield )
{
    unsigned cBitsInBitFieldTemp = _cBitsInBitfield ;
    _cBitsInBitfield = cBitsInBitfield ;

    if ( QueryMaxNonAllocBitCount() < QueryCount() )
    {
        BYTE * pbTemp = _pbBitVector ;

        if (  (_pbBitVector = new BYTE[ QueryAllocSize() ]) == NULL )
        {
            /* "Snap" back if we fail
             */
            _cBitsInBitfield = cBitsInBitfield ;
            _pbBitVector = pbTemp ;
            return ERROR_NOT_ENOUGH_MEMORY ;
        }
        else
        {
            delete pbTemp ;
        }
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:       BITFIELD::Resize

    SYNOPSIS:   Dynamically resizes the bitfield (contents are not
                preserved).

    ENTRY:      cBitsInBitfield - Count of bytes to resize this bitfield to

    RETURNS:    NERR_Success if successful

    NOTES:

    HISTORY:
        Johnl   18-Sep-1991     Created

********************************************************************/

APIERR BITFIELD::Resize( unsigned cBitsInBitfield )
{
    return AllocBitfield( cBitsInBitfield ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\slist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    slist.cxx
    LM 3.0 Generic slist package

    This file contains the base routines for the SLIST class defined in
    slist.hxx

    See the beginning of slist.hxx for usage examples.

    FILE HISTORY:
        johnl       24-Jul-1990 Created
        johnl       30-Oct-1990 Modified to reflect functional shift of
                                iterator (item returned by next is the
                                current item)
        beng        07-Feb-1991 Uses lmui.hxx
        johnl       07-Mar-1991 Code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        terryk      19-Sep-1991 Added {} between UIDEBUG
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

/*********************************************************************

    NAME:       SLIST::SLIST

    SYNOPSIS:   Constructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::SLIST()
{
    _pslHead = _pslTail = NULL;
    _psliterRegisteredIters = NULL;
}


/*********************************************************************

    NAME:       SLIST::~SLIST

    SYNOPSIS:   Destructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::~SLIST()
{
    /* Deregister modifies _psliterRegisteredIters (moves it to the next
     * iterator in the list).
     */
    while ( _psliterRegisteredIters != NULL )
        Deregister( _psliterRegisteredIters );
}


/*********************************************************************

    NAME:       SLIST::Add

    SYNOPSIS:   Adds the passed element to the beginning of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Add( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( _pslHead, pelem );
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;       /* failure */

    if ( _pslTail == NULL )  /* First item in list */
        _pslTail = pslnodeNew;

    _pslHead = pslnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::QueryNumElem

    SYNOPSIS:   Returns the number of elements in the slist

    ENTRY:      NONE

    EXIT:       A UINT indicating the number of elements in the list.

    HISTORY:    rustanl   15-Jul-90       Created
                johnl     19-Jul-90       Adapted for the SLIST package

*********************************************************************/

UINT SLIST::QueryNumElem()
{
    register SL_NODE * pslnode = _pslHead;
    UINT uCount = 0;

    while ( pslnode != NULL )
    {
        uCount++;
        pslnode = pslnode->_pslnodeNext;
    }

    return uCount;
}


/*********************************************************************

    NAME:       SLIST::Append

    SYNOPSIS:   Adds the passed element to the end of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Append( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( NULL, pelem );

    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    if ( _pslHead == NULL )
        _pslHead = _pslTail = pslnodeNew;
    else
    {
        _pslTail->_pslnodeNext = pslnodeNew;
        _pslTail = pslnodeNew;
    }

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Insert

    SYNOPSIS:   Insert an element into a slist using the location of the
                passed iterator.  (ITER_SL)

    ENTRY:      Pointer to the element to insert
                Iterator indicating insertion point

    EXIT:       return NERR_Success if successful,
                ERROR_NOT_ENOUGH_MEMORY if an allocation failure occurred
                ERROR_INVALID_DATA if a bad iterator was passed in

    NOTES:      If a bad iterator is passed in (i.e., one not registered on
                this list), the current behavior is to assert out.  We may
                want to change this to return an error code (even though this
                should be considered as a programmer's error).

                The insertion point is always "previous" to the element the
                iterator is pointing at.  If the iterator is at the end of
                the list (i.e., the current position is NULL), then Insert
                is equivalent to Append.

                The algorithm (suggested by PeterWi) looks like:


                    Before         Insert 15 at iter      After

                   A[val=10]                             A[val=10]
                      |                                     |
                   B[val=20]<--iter                      B[val=15]
                      |                                     |
                   C[val=30]                             D[val=20]<--iter
                                                            |
                                                         C[val=30]

    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Modified to reflect functional change in
                                    iterator

*********************************************************************/

APIERR SLIST::Insert( VOID* pelem, ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    SL_NODE * pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )   /* Check if iter at end/beginning */
        return (Append( pelem ));

    SL_NODE * pslnodeNew = new SL_NODE( pslnodeCurrent->_pslnodeNext,
                                        pslnodeCurrent->_pelem);
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pslnodeCurrent->Set( pslnodeNew, pelem );

    if ( _pslTail == pslnodeCurrent )   // Fixup tail pointer if necessary
        _pslTail = pslnodeNew;

    BumpIters( pslnodeCurrent );

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Remove

    SYNOPSIS:   Removes the element the past iterator points at

    ENTRY:      A Valid registered iterator

    EXIT:       A pointer to the newly removed element
                NULL if the list is empty or the iterator is at the end of
                the list.

    NOTES:      NULL is returned if an unregistered iterator is passed in, the
                slist is empty or the iterator is at the end of the list.


    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Changed behavior so it removes the element
                                    the iterator is pointing (as opposed to
                                    the element to the left).

*********************************************************************/

VOID * SLIST::Remove( ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Remove - Attempted to insert w/ Unregistered iterator\n\r"));
        return NULL;
    }

    SL_NODE *pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )
        return NULL;  /* Iter at end of Slist */

    register SL_NODE *_pslnodeTarget = NULL;   // Node that's going away
    VOID * _pelem;

    /*
     *  if ( the next node is not NULL )  // Can we fix things up w/o trav.?
     *      save pelem for the return     // Yes
     *      make target the next node
     *      Update iterators so the element position doesn't change in the list
     *      assign the current node the contents of the next node
     *  else // this is the last item in the list
     *      Find the previous item in the list
     *      if there is no prev. item
     *          set head & tail to NULL, this was the only item in the list
     *      else
     *          set the prev. item's next pointer to NULL (last item in list)
     *      set the target node
     *      save the pelem to return it
     */

    if ( pslnodeCurrent->_pslnodeNext != NULL )
    {
        _pelem = pslnodeCurrent->_pelem;

        _pslnodeTarget = pslnodeCurrent->_pslnodeNext;
        SetIters( _pslnodeTarget, pslnodeCurrent );

        pslnodeCurrent->Set( pslnodeCurrent->_pslnodeNext->_pslnodeNext,
                             pslnodeCurrent->_pslnodeNext->_pelem );

        if ( _pslnodeTarget == _pslTail )   // Fixup tail pointer
            _pslTail = pslnodeCurrent;
    }
    else
    {
        // This is the last (position) item in the list
        SL_NODE *_pslnodePrev = FindPrev( pslnodeCurrent );

        if ( _pslnodePrev == NULL )     // If only item in the slist
            _pslHead = _pslTail = NULL;
        else
        {
            _pslnodePrev->_pslnodeNext = NULL;
            _pslTail = _pslnodePrev;
        }

        _pslnodeTarget = pslnodeCurrent;
        _pelem = pslnodeCurrent->_pelem;
    }

    BumpIters( _pslnodeTarget );  /* Move iters to next node... */

    delete _pslnodeTarget;
    return _pelem;
}


/*********************************************************************

    NAME:       SLIST::FindPrev

    SYNOPSIS:   Private method to find the previous element in the list.

    ENTRY:      SL_NODE that we want to find the previous node to.

    EXIT:       The previous node if successful, or NULL.

    HISTORY:    johnl   7-19-90     Created

*********************************************************************/

SL_NODE* SLIST::FindPrev( SL_NODE *pslnode )
{
    if ( pslnode == NULL )
        return NULL;

    register SL_NODE *_pslnode = _pslHead, *_pslnodePrev = NULL;

    while ( _pslnode != NULL && _pslnode != pslnode )
    {
        _pslnodePrev = _pslnode;
        _pslnode = _pslnode->_pslnodeNext;
    }
    return ( _pslnode == NULL ? NULL : _pslnodePrev );
}


/*********************************************************************

    NAME:       SLIST::Register

    SYNOPSIS:   Adds the pointer to the passed iterator to the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator

    EXIT:

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Register( ITER_SL *psliter )
{
    psliter->_psliterNext = _psliterRegisteredIters;
    _psliterRegisteredIters = psliter;
}


/*********************************************************************

    NAME:       SLIST::Deregister

    SYNOPSIS:   Removes the pointer to the passed iterator from the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator, registered iterator

    EXIT:       NONE

    NOTES:      Deregister must succeed, if it fails, then an internal error
                has occurred.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Deregister( ITER_SL *psliter )
{
    register ITER_SL * pslitersCur  = _psliterRegisteredIters,
                     * pslitersPrev = NULL;

    while ( pslitersCur != NULL )
    {
        if ( pslitersCur == psliter )
        {
            if ( pslitersPrev != NULL ) /* if not first node in list */
                pslitersPrev->_psliterNext = pslitersCur->_psliterNext;

            else
            {
                if ( pslitersCur->_psliterNext == NULL )
                    _psliterRegisteredIters = NULL; /* only item in list */
                else
                    _psliterRegisteredIters = pslitersCur->_psliterNext;
            }

            pslitersCur->_pslist =         NULL;
            pslitersCur->_psliterNext =    NULL;
            pslitersCur->_pslnodeCurrent = NULL;
            return;
        }
        else
        {
            pslitersPrev = pslitersCur;
            pslitersCur = pslitersCur->_psliterNext;
        }
    }
    ASSERT(FALSE); /* We should never get here */
}


/*********************************************************************

    NAME:       SLIST::BumpIters

    SYNOPSIS:   Moves iterators to next element that point to the passed node

    ENTRY:      A valid SL_NODE that will be going away

    EXIT:       None

    NOTES:      BumpIters is used in cases where a particular element is going
                to be deleted.  BumpIters finds all of the iterators that
                point to the soon to be deceased node and bumps them to the
                next element using their Next() method.

                If the iterator has not been used, then Next needs to be called
                twice to actually move the internal current node, the while loop
                takes care of this.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::BumpIters( SL_NODE* pslnode )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
        if ( psliter->_pslnodeCurrent == pslnode )
            psliter->Next();
        else
            psliter = psliter->_psliterNext;
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Sets all registered iterators to the passed value

    ENTRY:      A pointer to a a SL_NODE (or NULL)

    EXIT:       All iterators will point to the passed value

    NOTES:      This is generally used in cases after the list has been
                emptied, so the passed in value will normally be NULL.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnode )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        psliter->_pslnodeCurrent = pslnode;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Changes all registered iterators pointing to the passed SL_NODE
                to point to the passed new SL_NODE

    ENTRY:      Two pointers to SL_NODEs (1st is comparison, second is new)

    EXIT:       All iterators pointing to pslnodeCompVal will point to pslnodeNew

    NOTES:      This is generally used in cases after an element in the list has
                been deleted

    HISTORY:    johnl       30-Oct-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnodeCompVal, SL_NODE *pslnodeNew )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        if ( psliter->_pslnodeCurrent == pslnodeCompVal )
            psliter->_pslnodeCurrent = pslnodeNew;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::CheckIter

    SYNOPSIS:   Confirms the passed iter belongs to this list

    ENTRY:      A pointer to an iterator

    EXIT:       TRUE if the passed iterator belongs, FALSE otherwise.

    NOTES:      CheckIter is generally used with methods that pass in an
                iterator as a parameter (such as Insert).  It is the option
                of the method whether to abort or not when a bad iterator
                is passed in.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

BOOL SLIST::CheckIter( ITER_SL *psliterSearchVal )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL && psliter != psliterSearchVal )
        psliter = psliter->_psliterNext;

    return ( psliter != NULL );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator

    ENTRY:      Pointer to a valid SLIST

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( SLIST *psl )
{
    UIASSERT( psl != NULL );

    _pslist = psl;
    _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
    _psliterNext = NULL;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator that excepts another slist

    ENTRY:      Pointer to a valid SLIST, pointer to valid slist iterator

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( const ITER_SL &itersl )
{
    _pslist         = itersl._pslist;
    _pslnodeCurrent = itersl._pslnodeCurrent;
    _fUsed          = itersl._fUsed;
    _psliterNext    = itersl._psliterNext;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::~ITER_SL

    SYNOPSIS:   Destructor for ITER_SL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::~ITER_SL()
{
    if ( _pslist != NULL)
        _pslist->Deregister( this );

    _pslist = NULL;
    _pslnodeCurrent = NULL;
    _psliterNext = NULL;
}


/*********************************************************************

    NAME:       ITER_SL::Next

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:      The first time Next is called, the iterator isn't bumped, this
                is so the item returned by next is the "current" item.

    HISTORY:

*********************************************************************/

VOID * ITER_SL::Next()
{
    if ( _pslnodeCurrent != NULL )
        if ( _fUsed )
            _pslnodeCurrent = _pslnodeCurrent->_pslnodeNext;
        else
            _fUsed = TRUE;

    return (_pslnodeCurrent!= NULL ? _pslnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       ITER_SL::Reset

    SYNOPSIS:   Resets the iterator to the beginning of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   16-Apr-1991     Added check if slist is already destructed

*********************************************************************/

VOID ITER_SL::Reset()
{
    if ( _pslist != NULL )
        _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
}


/*********************************************************************

    NAME:       ITER_SL::QueryProp

    SYNOPSIS:   Returns the "Current" object iterator is pointing to
                (i.e., the object returned by the last call to Next())

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:

    HISTORY:    JohnL  16-Oct-1990  Created

*********************************************************************/

VOID * ITER_SL::QueryProp()
{
    if ( _pslnodeCurrent != NULL )
        return (_pslnodeCurrent->_pelem);
    else
        return NULL;
}

/*******************************************************************

    NAME:           SLIST::_DebugPrint

    SYNOPSIS:       Prints list & various information

    HISTORY:

********************************************************************/

VOID SLIST::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    register SL_NODE *_pslnode = _pslHead;
    UINT uCnt = 0;
    char buff[250];

    if ( _pslHead == NULL )
        UIDEBUG(SZ("Empty Slist\n"));

    if ( _psliterRegisteredIters == NULL )
    {
        UIDEBUG(SZ("No registered iterators\n"));
    }
    else
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UIDEBUG(SZ("Iter->slnode:\n"));
        while ( psliter != NULL )
        {
            sprintf(buff, SZ("[%Fp]->[%Fp fUsed=%s]\n"),
                     psliter,
                     psliter->_pslnodeCurrent,
                     psliter->_fUsed ? SZ("TRUE") : SZ("FALSE") );
            UIDEBUG( buff );
            psliter = psliter->_psliterNext;
        }
    }

    sprintf(buff,SZ("Head = [%Fp], Tail = [%Fp]\n"), _pslHead, _pslTail );
    UIDEBUG( buff );

    while ( _pslnode != NULL )
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UINT uNumIters = 0;

        while ( psliter != NULL ) /* Get # of iters pointing here */
        {
            if ( psliter->_pslnodeCurrent == _pslnode )
                uNumIters++;
            psliter = psliter->_psliterNext;
        }

        sprintf(buff,SZ("[%Fp](%d)\n"), _pslnode, uNumIters );
        UIDEBUG( buff );

        _pslnode = _pslnode->_pslnodeNext;
    }

#endif // debug

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\tree.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    TREE.CXX
    LM 3.0 Generic general tree package

    This file contains the generic TREE code that is declared in the
    file TREE.HXX.  Please see TREE.HXX for a description.


    FILE HISTORY:
        johnl       06-Sep-1990 Created
        beng        07-Feb-1991 Uses lmui.hxx
        johnl       07-Mar-1991 Made code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output
*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:     TREE::TREE

    SYNOPSIS: TREE constructor

    ENTRY:    None

    EXIT:     Initialized TREE node

    NOTES:

    HISTORY:
        johnl     6-Sep-1990  Created
        johnl    16-Nov-1990  Allowed properties to be NULL

********************************************************************/

TREE::TREE( VOID * pvelem )
{
    SetLeft( NULL );
    SetRight( NULL );
    SetParent( NULL );
    SetFirstSubtree( NULL );
    SetProp( pvelem );
}


/*******************************************************************

    NAME:     TREE::~TREE

    SYNOPSIS: TREE node destructor
              Deletes subtree(s) then unlinks itself from the tree

    ENTRY:

    EXIT:     A free floating tree node

    NOTES:

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

TREE::~TREE()
{
    Unlink();
}


/*******************************************************************

    NAME:     TREE::Unlink

    SYNOPSIS: Unlinks this subtree from its parent tree

    ENTRY:    Valid tree

    EXIT:     Free floating tree

    NOTES:    This is an internal helper routine

    HISTORY:  johnl     6-Sep-1990  Created
              johnl     7-Feb-1991  Added fix peterwi suggested (and wrote)

********************************************************************/

VOID TREE::Unlink()
{
    UIASSERT( QueryParent()!= NULL ||
              (QueryParent() == NULL && QueryRight() == NULL && QueryLeft() == NULL ));
    if ( QueryParent() != NULL )                 // Can't unlink the root...
    {
        if ( QueryLeft() != NULL )
            QueryLeft()->SetRight( QueryRight() );
        else
            QueryParent()->SetFirstSubtree( QueryRight() );

        if ( QueryRight() != NULL )
            QueryRight()->SetLeft( QueryLeft()  );

        SetParent( NULL );
        SetLeft( NULL );
        SetRight( NULL );
    }
}


/*******************************************************************

    NAME:     TREE::BreakOut

    SYNOPSIS: Breaks out this subtree from the rest of the tree and
              returns this subtree

    ENTRY:    Valid tree node

    EXIT:     Free floating Subtree

    NOTES:

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

TREE* TREE::BreakOut()
{
    Unlink();
    return this;
}


/*******************************************************************

    NAME:     TREE::QueryLastSubtree

    SYNOPSIS: Gets the right most child tree of this node

    ENTRY:    Valid tree node

    EXIT:     Returns the right most child

    NOTES:

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

TREE * TREE::QueryLastSubtree() const
{
    register TREE * pt = QueryFirstSubtree();

    if ( pt != NULL )
        while ( pt->QueryRight() != NULL )
            pt = pt->QueryRight();

    return pt;
}


/*******************************************************************

    NAME:     TREE::JoinSubtreeLeft

    SYNOPSIS: Joins the passed tree as the left most subtree of this node

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Can't Fail

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSubtreeLeft( TREE * ptree )
{
    /* Don't allow linking in a tree that is part of another tree
     * or recursively joining this tree.
     */
    UIASSERT( ptree->QueryLeft() == NULL &&
              ptree->QueryRight() == NULL &&
              ptree->QueryParent() == NULL    );
    //UIASSERT( ptree != QueryRoot() );  No QueryRoot, will add...

    ptree->SetLeft( NULL );
    ptree->SetRight( QueryFirstSubtree() );
    ptree->SetParent( this );

    if ( QueryFirstSubtree() != NULL )
        QueryFirstSubtree()->SetLeft( ptree );

    SetFirstSubtree( ptree );
}


/*******************************************************************

    NAME:     TREE::JoinSubtreeRight

    SYNOPSIS: Joins the passed tree as the right most subtree of this node

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Can't Fail

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSubtreeRight( TREE * ptree )
{
    /* Don't allow linking in a tree that is part of another tree
     * or recursively joining this tree.
     */
    UIASSERT( ptree->QueryLeft() == NULL &&
              ptree->QueryRight() == NULL &&
              ptree->QueryParent() == NULL    );
    //UIASSERT( ptree != QueryRoot() );    No QueryRoot, will add

    TREE *ptOldRight = QueryLastSubtree();

    ptree->SetLeft( ptOldRight );
    ptree->SetRight( NULL );
    ptree->SetParent( this );

    if ( ptOldRight == NULL )
        SetFirstSubtree( ptree );
    else
        ptOldRight->SetRight( ptree );
}


/*******************************************************************

    NAME:     TREE::JoinSiblingLeft

    SYNOPSIS: Joins the passed tree as the immediate left sibling of "this"

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Asserts out if "this" is the root (can't have two roots...)

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSiblingLeft( TREE * ptree )
{
    UIASSERT( QueryParent() != NULL );    // Can't join a sibling at the root

    ptree->SetParent( QueryParent() );
    ptree->SetLeft( QueryLeft() );
    ptree->SetRight( this );

    if ( QueryLeft() == NULL )           // First tree of this level?
        QueryParent()->SetFirstSubtree( ptree );
    else
        QueryLeft()->SetRight( ptree );

    SetLeft( ptree );
}


/*******************************************************************

    NAME:     TREE::JoinSiblingRight

    SYNOPSIS: Joins the passed tree as the immediate right sibling of "this"

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Asserts out if "this" is the root (can't have two roots...)

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSiblingRight( TREE * ptree )
{
    UIASSERT( QueryParent() != NULL );    // Can't join a sibling at the root

    ptree->SetParent( QueryParent() );
    ptree->SetLeft( this );
    ptree->SetRight( QueryRight() );

    if ( QueryRight() != NULL )
        QueryRight()->SetLeft( ptree );

    SetRight( ptree );
}


/*******************************************************************

    NAME:     TREE::QueryNumElem

    SYNOPSIS: Returns the number of elements in the subtree

    ENTRY:    Valid tree node

    EXIT:     # of elements in the subtree

    NOTES:    Recursively (to the depth of the tree) counts the number of
              tree nodes in the tree.

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

UINT TREE::QueryNumElem() const
{
    UINT uNumElem = 1;      // Count self

    TREE *pt = QueryFirstSubtree();
    for (; pt != NULL; pt = pt->QueryRight() )
        uNumElem += pt->QueryNumElem();

    return uNumElem;
}


/*******************************************************************
    NAME:     TREE::_DebugPrint

    SYNOPSIS: Prints the contents of the tree node

    ENTRY:    Valid tree node

    EXIT:

    NOTES:    Only defined in the DEBUG version

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    char buff[250];

    sprintf(buff, SZ("TREE::this = %Fp\n"), (VOID *) this );
    UIDEBUG( buff );
    sprintf(buff, SZ("    _ptParent = %Fp, _ptLeftChild = %Fp\n"),
            (VOID *) _ptParent,
             (VOID *) _ptLeftChild );
    UIDEBUG( buff );
    sprintf(buff, SZ("    _ptLeft   = %Fp, _ptRight     = %Fp\n"),
            (VOID *) _ptLeft,
            (VOID *) _ptRight );
    UIDEBUG( buff );

#endif // DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\pch\slist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    slist.cxx
    LM 3.0 Generic slist package

    This file contains the base routines for the SLIST class defined in
    slist.hxx

    See the beginning of slist.hxx for usage examples.

    FILE HISTORY:
        johnl       24-Jul-1990 Created
        johnl       30-Oct-1990 Modified to reflect functional shift of
                                iterator (item returned by next is the
                                current item)
        beng        07-Feb-1991 Uses lmui.hxx
        johnl       07-Mar-1991 Code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        terryk      19-Sep-1991 Added {} between UIDEBUG
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

/*********************************************************************

    NAME:       SLIST::SLIST

    SYNOPSIS:   Constructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::SLIST()
{
    _pslHead = _pslTail = NULL;
    _psliterRegisteredIters = NULL;
}


/*********************************************************************

    NAME:       SLIST::~SLIST

    SYNOPSIS:   Destructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::~SLIST()
{
    /* Deregister modifies _psliterRegisteredIters (moves it to the next
     * iterator in the list).
     */
    while ( _psliterRegisteredIters != NULL )
        Deregister( _psliterRegisteredIters );
}


/*********************************************************************

    NAME:       SLIST::Add

    SYNOPSIS:   Adds the passed element to the beginning of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Add( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( _pslHead, pelem );
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;       /* failure */

    if ( _pslTail == NULL )  /* First item in list */
        _pslTail = pslnodeNew;

    _pslHead = pslnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::QueryNumElem

    SYNOPSIS:   Returns the number of elements in the slist

    ENTRY:      NONE

    EXIT:       A UINT indicating the number of elements in the list.

    HISTORY:    rustanl   15-Jul-90       Created
                johnl     19-Jul-90       Adapted for the SLIST package

*********************************************************************/

UINT SLIST::QueryNumElem()
{
    register SL_NODE * pslnode = _pslHead;
    UINT uCount = 0;

    while ( pslnode != NULL )
    {
        uCount++;
        pslnode = pslnode->_pslnodeNext;
    }

    return uCount;
}


/*********************************************************************

    NAME:       SLIST::Append

    SYNOPSIS:   Adds the passed element to the end of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Append( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( NULL, pelem );

    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    if ( _pslHead == NULL )
        _pslHead = _pslTail = pslnodeNew;
    else
    {
        _pslTail->_pslnodeNext = pslnodeNew;
        _pslTail = pslnodeNew;
    }

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Insert

    SYNOPSIS:   Insert an element into a slist using the location of the
                passed iterator.  (ITER_SL)

    ENTRY:      Pointer to the element to insert
                Iterator indicating insertion point

    EXIT:       return NERR_Success if successful,
                ERROR_NOT_ENOUGH_MEMORY if an allocation failure occurred
                ERROR_INVALID_DATA if a bad iterator was passed in

    NOTES:      If a bad iterator is passed in (i.e., one not registered on
                this list), the current behavior is to assert out.  We may
                want to change this to return an error code (even though this
                should be considered as a programmer's error).

                The insertion point is always "previous" to the element the
                iterator is pointing at.  If the iterator is at the end of
                the list (i.e., the current position is NULL), then Insert
                is equivalent to Append.

                The algorithm (suggested by PeterWi) looks like:


                    Before         Insert 15 at iter      After

                   A[val=10]                             A[val=10]
                      |                                     |
                   B[val=20]<--iter                      B[val=15]
                      |                                     |
                   C[val=30]                             D[val=20]<--iter
                                                            |
                                                         C[val=30]

    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Modified to reflect functional change in
                                    iterator

*********************************************************************/

APIERR SLIST::Insert( VOID* pelem, ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    SL_NODE * pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )   /* Check if iter at end/beginning */
        return (Append( pelem ));

    SL_NODE * pslnodeNew = new SL_NODE( pslnodeCurrent->_pslnodeNext,
                                        pslnodeCurrent->_pelem);
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pslnodeCurrent->Set( pslnodeNew, pelem );

    if ( _pslTail == pslnodeCurrent )   // Fixup tail pointer if necessary
        _pslTail = pslnodeNew;

    BumpIters( pslnodeCurrent );

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Remove

    SYNOPSIS:   Removes the element the past iterator points at

    ENTRY:      A Valid registered iterator

    EXIT:       A pointer to the newly removed element
                NULL if the list is empty or the iterator is at the end of
                the list.

    NOTES:      NULL is returned if an unregistered iterator is passed in, the
                slist is empty or the iterator is at the end of the list.


    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Changed behavior so it removes the element
                                    the iterator is pointing (as opposed to
                                    the element to the left).

*********************************************************************/

VOID * SLIST::Remove( ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Remove - Attempted to insert w/ Unregistered iterator\n\r"));
        return NULL;
    }

    SL_NODE *pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )
        return NULL;  /* Iter at end of Slist */

    register SL_NODE *_pslnodeTarget = NULL;   // Node that's going away
    VOID * _pelem;

    /*
     *  if ( the next node is not NULL )  // Can we fix things up w/o trav.?
     *      save pelem for the return     // Yes
     *      make target the next node
     *      Update iterators so the element position doesn't change in the list
     *      assign the current node the contents of the next node
     *  else // this is the last item in the list
     *      Find the previous item in the list
     *      if there is no prev. item
     *          set head & tail to NULL, this was the only item in the list
     *      else
     *          set the prev. item's next pointer to NULL (last item in list)
     *      set the target node
     *      save the pelem to return it
     */

    if ( pslnodeCurrent->_pslnodeNext != NULL )
    {
        _pelem = pslnodeCurrent->_pelem;

        _pslnodeTarget = pslnodeCurrent->_pslnodeNext;
        SetIters( _pslnodeTarget, pslnodeCurrent );

        pslnodeCurrent->Set( pslnodeCurrent->_pslnodeNext->_pslnodeNext,
                             pslnodeCurrent->_pslnodeNext->_pelem );

        if ( _pslnodeTarget == _pslTail )   // Fixup tail pointer
            _pslTail = pslnodeCurrent;
    }
    else
    {
        // This is the last (position) item in the list
        SL_NODE *_pslnodePrev = FindPrev( pslnodeCurrent );

        if ( _pslnodePrev == NULL )     // If only item in the slist
            _pslHead = _pslTail = NULL;
        else
        {
            _pslnodePrev->_pslnodeNext = NULL;
            _pslTail = _pslnodePrev;
        }

        _pslnodeTarget = pslnodeCurrent;
        _pelem = pslnodeCurrent->_pelem;
    }

    BumpIters( _pslnodeTarget );  /* Move iters to next node... */

    delete _pslnodeTarget;
    return _pelem;
}


/*********************************************************************

    NAME:       SLIST::FindPrev

    SYNOPSIS:   Private method to find the previous element in the list.

    ENTRY:      SL_NODE that we want to find the previous node to.

    EXIT:       The previous node if successful, or NULL.

    HISTORY:    johnl   7-19-90     Created

*********************************************************************/

SL_NODE* SLIST::FindPrev( SL_NODE *pslnode )
{
    if ( pslnode == NULL )
        return NULL;

    register SL_NODE *_pslnode = _pslHead, *_pslnodePrev = NULL;

    while ( _pslnode != NULL && _pslnode != pslnode )
    {
        _pslnodePrev = _pslnode;
        _pslnode = _pslnode->_pslnodeNext;
    }
    return ( _pslnode == NULL ? NULL : _pslnodePrev );
}


/*********************************************************************

    NAME:       SLIST::Register

    SYNOPSIS:   Adds the pointer to the passed iterator to the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator

    EXIT:

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Register( ITER_SL *psliter )
{
    psliter->_psliterNext = _psliterRegisteredIters;
    _psliterRegisteredIters = psliter;
}


/*********************************************************************

    NAME:       SLIST::Deregister

    SYNOPSIS:   Removes the pointer to the passed iterator from the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator, registered iterator

    EXIT:       NONE

    NOTES:      Deregister must succeed, if it fails, then an internal error
                has occurred.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Deregister( ITER_SL *psliter )
{
    register ITER_SL * pslitersCur  = _psliterRegisteredIters,
                     * pslitersPrev = NULL;

    while ( pslitersCur != NULL )
    {
        if ( pslitersCur == psliter )
        {
            if ( pslitersPrev != NULL ) /* if not first node in list */
                pslitersPrev->_psliterNext = pslitersCur->_psliterNext;

            else
            {
                if ( pslitersCur->_psliterNext == NULL )
                    _psliterRegisteredIters = NULL; /* only item in list */
                else
                    _psliterRegisteredIters = pslitersCur->_psliterNext;
            }

            pslitersCur->_pslist =         NULL;
            pslitersCur->_psliterNext =    NULL;
            pslitersCur->_pslnodeCurrent = NULL;
            return;
        }
        else
        {
            pslitersPrev = pslitersCur;
            pslitersCur = pslitersCur->_psliterNext;
        }
    }
    ASSERT(FALSE); /* We should never get here */
}


/*********************************************************************

    NAME:       SLIST::BumpIters

    SYNOPSIS:   Moves iterators to next element that point to the passed node

    ENTRY:      A valid SL_NODE that will be going away

    EXIT:       None

    NOTES:      BumpIters is used in cases where a particular element is going
                to be deleted.  BumpIters finds all of the iterators that
                point to the soon to be deceased node and bumps them to the
                next element using their Next() method.

                If the iterator has not been used, then Next needs to be called
                twice to actually move the internal current node, the while loop
                takes care of this.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::BumpIters( SL_NODE* pslnode )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
        if ( psliter->_pslnodeCurrent == pslnode )
            psliter->Next();
        else
            psliter = psliter->_psliterNext;
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Sets all registered iterators to the passed value

    ENTRY:      A pointer to a a SL_NODE (or NULL)

    EXIT:       All iterators will point to the passed value

    NOTES:      This is generally used in cases after the list has been
                emptied, so the passed in value will normally be NULL.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnode )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        psliter->_pslnodeCurrent = pslnode;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Changes all registered iterators pointing to the passed SL_NODE
                to point to the passed new SL_NODE

    ENTRY:      Two pointers to SL_NODEs (1st is comparison, second is new)

    EXIT:       All iterators pointing to pslnodeCompVal will point to pslnodeNew

    NOTES:      This is generally used in cases after an element in the list has
                been deleted

    HISTORY:    johnl       30-Oct-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnodeCompVal, SL_NODE *pslnodeNew )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        if ( psliter->_pslnodeCurrent == pslnodeCompVal )
            psliter->_pslnodeCurrent = pslnodeNew;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::CheckIter

    SYNOPSIS:   Confirms the passed iter belongs to this list

    ENTRY:      A pointer to an iterator

    EXIT:       TRUE if the passed iterator belongs, FALSE otherwise.

    NOTES:      CheckIter is generally used with methods that pass in an
                iterator as a parameter (such as Insert).  It is the option
                of the method whether to abort or not when a bad iterator
                is passed in.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

BOOL SLIST::CheckIter( ITER_SL *psliterSearchVal )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL && psliter != psliterSearchVal )
        psliter = psliter->_psliterNext;

    return ( psliter != NULL );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator

    ENTRY:      Pointer to a valid SLIST

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( SLIST *psl )
{
    UIASSERT( psl != NULL );

    _pslist = psl;
    _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
    _psliterNext = NULL;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator that excepts another slist

    ENTRY:      Pointer to a valid SLIST, pointer to valid slist iterator

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( const ITER_SL &itersl )
{
    _pslist         = itersl._pslist;
    _pslnodeCurrent = itersl._pslnodeCurrent;
    _fUsed          = itersl._fUsed;
    _psliterNext    = itersl._psliterNext;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::~ITER_SL

    SYNOPSIS:   Destructor for ITER_SL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::~ITER_SL()
{
    if ( _pslist != NULL)
        _pslist->Deregister( this );

    _pslist = NULL;
    _pslnodeCurrent = NULL;
    _psliterNext = NULL;
}


/*********************************************************************

    NAME:       ITER_SL::Next

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:      The first time Next is called, the iterator isn't bumped, this
                is so the item returned by next is the "current" item.

    HISTORY:

*********************************************************************/

VOID * ITER_SL::Next()
{
    if ( _pslnodeCurrent != NULL )
        if ( _fUsed )
            _pslnodeCurrent = _pslnodeCurrent->_pslnodeNext;
        else
            _fUsed = TRUE;

    return (_pslnodeCurrent!= NULL ? _pslnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       ITER_SL::Reset

    SYNOPSIS:   Resets the iterator to the beginning of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   16-Apr-1991     Added check if slist is already destructed

*********************************************************************/

VOID ITER_SL::Reset()
{
    if ( _pslist != NULL )
        _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
}


/*********************************************************************

    NAME:       ITER_SL::QueryProp

    SYNOPSIS:   Returns the "Current" object iterator is pointing to
                (i.e., the object returned by the last call to Next())

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:

    HISTORY:    JohnL  16-Oct-1990  Created

*********************************************************************/

VOID * ITER_SL::QueryProp()
{
    if ( _pslnodeCurrent != NULL )
        return (_pslnodeCurrent->_pelem);
    else
        return NULL;
}

/*******************************************************************

    NAME:           SLIST::_DebugPrint

    SYNOPSIS:       Prints list & various information

    HISTORY:

********************************************************************/

VOID SLIST::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    register SL_NODE *_pslnode = _pslHead;
    UINT uCnt = 0;
    char buff[250];

    if ( _pslHead == NULL )
        UIDEBUG(SZ("Empty Slist\n"));

    if ( _psliterRegisteredIters == NULL )
    {
        UIDEBUG(SZ("No registered iterators\n"));
    }
    else
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UIDEBUG(SZ("Iter->slnode:\n"));
        while ( psliter != NULL )
        {
            sprintf(buff, SZ("[%Fp]->[%Fp fUsed=%s]\n"),
                     psliter,
                     psliter->_pslnodeCurrent,
                     psliter->_fUsed ? SZ("TRUE") : SZ("FALSE") );
            UIDEBUG( buff );
            psliter = psliter->_psliterNext;
        }
    }

    sprintf(buff,SZ("Head = [%Fp], Tail = [%Fp]\n"), _pslHead, _pslTail );
    UIDEBUG( buff );

    while ( _pslnode != NULL )
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UINT uNumIters = 0;

        while ( psliter != NULL ) /* Get # of iters pointing here */
        {
            if ( psliter->_pslnodeCurrent == _pslnode )
                uNumIters++;
            psliter = psliter->_psliterNext;
        }

        sprintf(buff,SZ("[%Fp](%d)\n"), _pslnode, uNumIters );
        UIDEBUG( buff );

        _pslnode = _pslnode->_pslnodeNext;
    }

#endif // debug

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\uatom.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/
/*
    UATOM.CXX
    Universal Atom Management class implementation

    Win32 Atom Management of Unicode strings.


    FILE HISTORY:
        DavidHov    9/10/91     Created

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/**********************************************************************/
/*         Static variables and Class UATOM                           */
/**********************************************************************/

#define HUATOMSIZE     (sizeof (VOID *))
#define UATOMHASHRANGE (256)
#define UATOMHASHMAX   (UATOMHASHRANGE-1)
#define UATOMINFINITY  (10000)
#define UATOMMAXSTRING (256)

/*************************************************************************

    NAME:       UATOM_LINKAGE

    SYNOPSIS:   Base class for linkable objects

    INTERFACE:  Private!

    PARENT:     none

    USES:       none

    CAVEATS:

    NOTES:

    HISTORY:
        DavidHov   9/10/91  Created

**************************************************************************/

class UATOM ;                                   // Forward Definition

  //   Linkage structure; defined independently of UATOM
  //   for use in hash table

class UATOM_LINKAGE
{
public:
    UATOM_LINKAGE * _puaFwd, * _puaBack ;        //  Doubly-linked list

    UATOM_LINKAGE () ;
    ~ UATOM_LINKAGE () ;

    inline UATOM * Fwd ()
        { return (UATOM *) _puaFwd ; }
    inline UATOM * Back ()
        { return (UATOM *) _puaBack ; }
    inline BOOL QueryLinked ()
        { return this != _puaFwd ; }
    inline void Init()                          //  Initialize link
        { _puaFwd = _puaBack = this ; }
    void Link ( UATOM_LINKAGE * pua ) ;
    void Unlink () ;
};

UATOM_LINKAGE :: UATOM_LINKAGE ()
{
    Init();
}

UATOM_LINKAGE :: ~ UATOM_LINKAGE ()
{
    Unlink() ;
}

VOID UATOM_LINKAGE :: Link ( UATOM_LINKAGE * pua )
{
    Unlink() ;

    _puaBack = pua->_puaBack ;
    _puaFwd = pua ;
    pua->_puaBack->_puaFwd = this ;
    _puaFwd->_puaBack = this ;
}

    //  Delink an atom from its chain

VOID UATOM_LINKAGE :: Unlink ()
{
    if ( QueryLinked() )
    {
        _puaFwd->_puaBack = _puaBack ;
        _puaBack->_puaFwd = _puaFwd ;
        Init() ;
    }
}

    //   Structure definition for UATOM_MANAGER's hash table.

class UATOM_REGION
{
public:
    UATOM_LINKAGE _aualTable [ UATOMHASHRANGE ] ;    //  Hash table
    UATOM_REGION () ;
    ~ UATOM_REGION () ;
};

UATOM_REGION :: UATOM_REGION ()
{
}

UATOM_REGION :: ~ UATOM_REGION ()
{
}

/*************************************************************************

    NAME:       UATOM

    SYNOPSIS:   Internal Universal Atom class


    INTERFACE:  Only through HUATOM!

    PARENT:     UATOM_LINKAGE

    USES:       none

    CAVEATS:

    NOTES:

    HISTORY:
        DavidHov    9/10/91     Created

**************************************************************************/

class UATOM : public UATOM_LINKAGE, public NLS_STR
{
public:
    UATOM ( NLS_STR & nlsStr ) ;
    ~ UATOM () ;
};


    //  Constructor.  Use the given NLS_STR.

UATOM :: UATOM ( NLS_STR & nlsStr )
    : NLS_STR( nlsStr )
{
}


UATOM :: ~ UATOM ()
{
}


//  Pointer to the sole UATOM_MANAGER instance

UATOM_MANAGER * UATOM_MANAGER :: pInstance = NULL ;


/*******************************************************************

    NAME:       UATOM_MANAGER::UATOM_MANAGER

    SYNOPSIS:   Constructor of the Atom Manager

    ENTRY:      ulcbSize =  size of memory desired for base allocation
                pvMem    =  optional pointer to extant memory

    EXIT:       Table initialized.

    RETURNS:    nothing

    NOTES:      if given, the "pvMem" pointed data will be used for
                the atom and hash table.

    HISTORY:
        DavidHov    9/10/91     Created

********************************************************************/

UATOM_MANAGER :: UATOM_MANAGER ()
{
    if ( pInstance )
    {
        ReportError( ERROR_INVALID_ACCESS ) ;
        return ;
    }

    //  Allocate the hash table; construction initializes all
    //  the linkage within.

    _pumRegion = new UATOM_REGION ;

    if ( _pumRegion == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
        return ;
    }
}

/*******************************************************************

    NAME:       UATOM_MANAGER::Initialize

    SYNOPSIS:   Static routine to create the sole instance of
                a UATOM_MANAGER.

    ENTRY:      Nothing

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        DavidHov    9/10/91     Created

********************************************************************/
APIERR UATOM_MANAGER :: Initialize ()
{
    if ( pInstance )
    {
        return ERROR_INVALID_ACCESS ;
    }

    pInstance = new UATOM_MANAGER ;

    return pInstance ? pInstance->QueryError()
                     : ERROR_NOT_ENOUGH_MEMORY ;
}

/*******************************************************************

    NAME:       UATOM_MANAGER::Terminate

    SYNOPSIS:   Destroy the instance of the UATOM_MANAGER

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    ERROR_INVALIED_ACCESS if no instance exists.

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/

APIERR UATOM_MANAGER :: Terminate ()
{
    if ( pInstance )
    {
        delete pInstance ;
        pInstance = NULL ;
        return NERR_Success ;
    }
    return ERROR_INVALID_ACCESS ;
}

/*******************************************************************

    NAME:       UATOM_MANAGER::~UATOM_MANAGER

    SYNOPSIS:   Destructor of the atom table manager.

                The linked lists of the UATOM_REGION are walked
                and all UATOMs thereon are destroyed.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/
UATOM_MANAGER :: ~ UATOM_MANAGER ()
{
    UATOM_LINKAGE * pual = _pumRegion->_aualTable ;

    //  Iterate the link-list anchor table and delete every atom.

    for ( int i = 0 ; i < UATOMHASHRANGE ; i++, pual++ )
    {
        for ( int j = 0 ;
              pual != pual->_puaFwd ;
              j++ )
        {
            UIASSERT( j < UATOMINFINITY ) ;
            delete (UATOM *) pual->_puaFwd ;
        }
    }

    delete _pumRegion ;
}


/*******************************************************************

    NAME:       UATOM_MANAGER::Tokenize

    SYNOPSIS:   Hash the given string into a bounded value.  Then,
                if unique, create the UATOM for it and link it
                into the atom table.

    ENTRY:      const TCHAR *       pointer to string
                BOOL                TRUE if string should already
                                    exists; default is FALSE.

    EXIT:

    RETURNS:    pointer to created/found UATOM or NULL if unsuccessful

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/

UATOM * UATOM_MANAGER :: Tokenize ( const TCHAR * puzStr, BOOL fExists )
{
    register int iHash = UATOMHASHRANGE - 1 ;
    register int carry ;
    UATOM_LINKAGE * pualLink ;
    UATOM * puaNext ;
    TCHAR c ;
    ALIAS_STR nlsNew( puzStr ) ;

    //  Hash the string
    {
        ISTR isIndex( nlsNew ) ;
        for ( iHash = UATOMHASHMAX ;
              c = nlsNew.QueryChar( isIndex ) ;
              ++isIndex )
        {
            carry = iHash >=UATOMHASHMAX ;
            iHash = ( iHash << 1 ) | carry ;
            iHash ^= c ;
        }
        iHash &= UATOMHASHMAX ;
    }

    //  See if it's in the linked lists already.

    pualLink = & _pumRegion->_aualTable[ iHash ] ;

    for ( puaNext = pualLink->Fwd() ;
          puaNext != pualLink ;
          puaNext = puaNext->Fwd() )
    {
        if ( *puaNext == nlsNew )
            break ;
    }

    //  If we returned to ground, we've failed

    if ( puaNext == pualLink )
        puaNext = NULL ;

    //  If failure and it isn't supposed to exist, create it.

    if ( puaNext == NULL && (!fExists) )
    {
        puaNext = new UATOM( nlsNew ) ;

        if ( puaNext && puaNext->QueryError() == 0 )
        {
            puaNext->Link( pualLink ) ;
        }
        else
        {
            UIDEBUG( SZ("Out of memory in UATOM_MANAGER::Tokenize") ) ;
            puaNext = NULL ;
        }
    }

    //  Return the result

    return puaNext ;
}


/*******************************************************************

    NAME:       HUATOM::HUATOM

    SYNOPSIS:   Construct for handle to atom.

    ENTRY:      const TCHAR *       pointer to string
                BOOL                TRUE if string should already
                                    exists; default is FALSE.
    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      Creates NULL HUATOM if no string is specified.

    HISTORY:
         DavidHov   9/10/91     Created
         beng       28-Mar-1992 Fixed char-TCHAR bug

********************************************************************/

HUATOM :: HUATOM (  const TCHAR * puzStr, BOOL fExists )
{
    UIASSERT( UATOM_MANAGER::pInstance != NULL );

    if ( puzStr )
    {
        _puaAtom = UATOM_MANAGER::pInstance->Tokenize( puzStr, fExists ) ;
    }
    else
    {
        _puaAtom = NULL ;
    }
}

/*******************************************************************

    NAME:       HUATOM::QueryText

    SYNOPSIS:   Return a const pointer to the underlying text string

    ENTRY:      nothing

    EXIT:       const TCHAR *           of string or NULL if HUATOM
                                        was NULL.

    RETURNS:

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/
const TCHAR * HUATOM :: QueryText ( ) const
{
    return _puaAtom
         ? _puaAtom->QueryPch()
         : NULL ;
}

/*******************************************************************

    NAME:       HUATOM::QueryNls

    SYNOPSIS:   Return a const pointer to the underlying NLS_STR object

    ENTRY:      nothing

    EXIT:       const NLS_STR *         or NULL if HUATOM was NULL.

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
const NLS_STR * HUATOM :: QueryNls () const
{
    return _puaAtom ;
}

/*******************************************************************

    NAME:       HUATOM::QueryError

    SYNOPSIS:   Return result code from construction of underlying
                NLS_STR.

    ENTRY:

    EXIT:

    RETURNS:   APIERR              of construction of NLS_STR
                                    or NERR_ItemNotVound

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/
APIERR HUATOM :: QueryError () const
{
    return _puaAtom
         ? _puaAtom->QueryError()
         : NERR_ItemNotFound ;
}

/*  End of UATOM.CXX  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\dll0\init.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    init.cxx
    Initialization for NETUI0

    FILE HISTORY:
        beng        30-Jul-1992 Header added
        beng        04-Aug-1992 Heap residue added; converted to C++
        jonn        25-Mar-1993 ITG special sort
        jonn        12-Sep-1995 NETUI_InitIsDBCS()
*/

#define INCL_WINDOWS
#define INCL_NETLIB
#include "lmui.hxx"
#include "dbgstr.hxx"

#include "heapdbg.hxx"


extern "C"
{
    #include "lmuicmn.h"
    #include "lmuidbcs.h"

    /* hackety hack hack hack */
    int errno = 0; /* BUGBUG! */

    //  The module handle for this DL

    HMODULE hmodBase = 0 ;

    // This is implemented by misc\misc\lmuidbcs.cxx.  See
    // that module before modifying parameters.
    VOID NETUI_InitIsDBCS();

    //  The init routine itself
    BOOL DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved ) ;

    //  Allow general access to the HMODULE for this DLL.
    extern HMODULE HmodDll0 (void) ;
}


//
    //  As in BLTINIT.CXX, look for NETUI.INI and initialize the
    //  debug output stream.
    //
OUTPUTSINK * makeOutputSink ()
{
    OUTPUTSINK * pOsinkResult = NULL ;

#if defined(DEBUG)
    //
    // We must find a netui.ini, which must contain a section:
    // [BLT]
    //      fDebugOutput=1
    //

    UINT nVal = ::GetPrivateProfileInt( SZ("blt"),
                                        SZ("fDebugOutput"),
                                        0,
                                        SZ("netui.ini") ) ;
    if ( nVal )
        pOsinkResult = new OUTPUT_TO_AUX ;
    else
#endif
        pOsinkResult = new OUTPUT_TO_NUL ;

    return pOsinkResult ;
}

BOOL DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved )
{
    //  Pointers to the initial debug stream.  These are created
    //  in lieu of the real, BLT-leel streams created during the
    //  initialization of NETUI2.DLL.

    static OUTPUTSINK * pStreamSink = NULL ;
    static DBGSTREAM * pDebugStream = NULL ;

    UNREFERENCED(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hdll);

        hmodBase = hdll ;

        NETUI_InitIsDBCS();

        InitCompareParam(); // see string\string\uinetlib.cxx

        if ( pStreamSink = makeOutputSink() )
        {
            pDebugStream = new DBGSTREAM( pStreamSink ) ;
        }
        if ( pDebugStream )
        {
            DBGSTREAM::SetCurrent( pDebugStream ) ;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        delete pDebugStream ;
        delete pStreamSink ;
        hmodBase = 0 ;
    }

    return TRUE;
}

   //
   //  Allow NETUI2.DLL to access resources in this DLL if necessary.
   //
HMODULE HmodDll0 (void)
{
    return hmodBase ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\dll0\makefile.inc ===
#
# List of source libraries for the DLL
#

DLL_SOURCELIBS=..\..\collect\collect\$(O)\uicollct.lib \
               ..\..\string\string\$(O)\uistr.lib      \
               ..\..\string\pch\$(O)\uistrpch.lib      \
               ..\..\misc\bin\$(O)\uimisc.lib          \
               ..\..\profile\profile\$(O)\uiprof.lib   \
               ..\..\reg\reg\$(O)\uireg.lib            \

SOURCE_DEF= netui0.hdr
TARGET_DEF= $(O)\netui0.def

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\dll1\init.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    init.cxx
    Initialization for NETUI1

    FILE HISTORY:
        beng        30-Jul-1992 Header added
        KeithMo     06-May-1993 Optimized into obscurity.
        BruceFo     02-Feb-1996 Added DllMain and DisableThreadLibraryCalls()
*/

#define INCL_WINDOWS
#include "lmui.hxx"

extern "C"
{
    BOOL WINAPI DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved ) ;
}

BOOL WINAPI DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hdll);
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\collect\collect\treeiter.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    treeiter.cxx
    Implements DFS iter for the generic tree class (See treeiter.hxx &
    tree.hxx).


    FILE HISTORY:
	JohnL	Oct. 15, 1990	Created
	beng	07-Feb-1991	Uses lmui.hxx
	Johnl	07-Mar-1991	Made code review changes
	KeithMo	09-Oct-1991	Win32 Conversion.

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:     DFSITER_TREE::DFSITER_TREE

    SYNOPSIS: Constructor for DFS Iterator for the Tree class

    ENTRY:    TREE * = node to start iterator on
	      uDepth = Maximum depth to traverse to (start node is 0)

    EXIT:

    NOTES:

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

DFSITER_TREE::DFSITER_TREE( const TREE * pt, const UINT uDepth )
{
    UIASSERT( pt != NULL );	 // Programmer error to pass in a NULL pointer
    SetNode( pt );
    SetStartNode( pt );
    SetMaxDepth( uDepth );
    SetCurDepth( 0 );
}


/*******************************************************************

    NAME:     DFSITER_TREE::DFSITER_TREE

    SYNOPSIS: Constructor for DFS Iterator for the Tree class, takes
	      another DFS iterator and copies it's information

    ENTRY:    pdfsitertree = pointer to iterator to use for start info

    EXIT:     nothing

    NOTES:

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

DFSITER_TREE::DFSITER_TREE( const DFSITER_TREE * pdfsiterTree )
{
    SetNode( pdfsiterTree->QueryNode() );
    SetMaxDepth( pdfsiterTree->QueryMaxDepth() );
    SetCurDepth( pdfsiterTree->QueryCurDepth() );
    SetStartNode( pdfsiterTree->QueryStartNode() );
}


/*******************************************************************

    NAME:     DFSITER_TREE::~DFSITER_TREE

    SYNOPSIS: destructor for the DFSITER

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

DFSITER_TREE::~DFSITER_TREE()
{
    SetNode( NULL );	// Nullify this iterator (gp fault on next use)
}


/*******************************************************************

    NAME:     DFSITER_TREE::Next

    SYNOPSIS: Advances iterator to the next node in a Depth first fashion

    NOTES: In pseudo code, the algorithm looks like:
	   (Many thanx to RustanL for his collaboration)

	   Save the current node for return
	   if ( We have iterated to the end of the list )
	       return NULL
	   else if ( there is a child )
	       set current node to first child

	   else if ( We are back from where we started from )
	       Set current node to NULL

	   else if ( there is a right sibling )
	       Set current node to right sibling

	   else
	   {
	       pt = parent of current node
	       while ( we aren't where we started and the parent doesn't
		       have a right sibling )
		  Move up to the next parent

	       if ( we are where we started )
		  set current node to NULL
	       else
		  set current node to right sibling of parent
	   }
	   return the previously saved current node


    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

VOID* DFSITER_TREE::Next()
{
    const TREE *ptreeRet = QueryNode();

    if ( QueryNode() == NULL )
	return NULL;

    else if ( QueryNode()->QueryFirstSubtree() != NULL	&&
	      _uCurDepth < _uMaxDepth 		  )
    {
	SetNode( QueryNode()->QueryFirstSubtree() );
	_uCurDepth++;
    }

    else if ( QueryNode() == QueryStartNode() )
	SetNode( NULL );

    else if ( QueryNode()->QueryRight() != NULL )
	SetNode( QueryNode()->QueryRight() );

    else
    {
	TREE *pt = QueryNode()->QueryParent();
	while ( pt != QueryStartNode() && pt->QueryRight() == NULL )
	{
	    pt = pt->QueryParent();
	    _uCurDepth--;
	}

	if ( pt == QueryStartNode() )
	    SetNode( NULL );
	else
	    SetNode( pt->QueryRight() );
    }
    return ptreeRet->QueryProp();
}


/*******************************************************************

    NAME:     DFSITER_TREE::Reset

    SYNOPSIS: Resets the iterator to the starting node

    NOTES:

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

VOID DFSITER_TREE::Reset()
{
    SetNode( QueryStartNode() );
    SetCurDepth( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\makefile.inc ===
# Expects: DLL_SOURCELIBS, SOURCE_DEF, TARGET_DEF

#  Define names of target DLLs
!include $(UI)\common\src\names.mk

!IF $(386)
DLL_SRCLIBS=$(DLL_SOURCELIBS:*=i386)
UISWITCH=-s
!ELSEIF $(AMD64)
DLL_SRCLIBS=$(DLL_SOURCELIBS:*=amd64)
UISWITCH=
!ELSEIF $(IA64)
DLL_SRCLIBS=$(DLL_SOURCELIBS:*=ia64)
UISWITCH=-ia64
!ELSE
!ERROR Must have one of (x86, AMD64, or IA64)
!ENDIF

$(TARGET_DEF): $(DLL_SRCLIBS)
    if exist $(TARGET_DEF) del $(TARGET_DEF)
    @echo Building $(TARGET_DEF)
    link -dump -symbols $(**) | qgrep -v ??_G | qgrep -v ??_E |uixport $(UISWITCH) -h:$(SOURCE_DEF) -o:$(TARGET_DEF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\dll1\makefile.inc ===
DLL_SOURCELIBS=..\..\mnet32\pch\$(O)\pchmn32.lib       \
               ..\..\mnet32\mnet32\$(O)\uimnet32.lib   \
               ..\..\mnet32\netslow\$(O)\netslow.lib   \
               ..\..\lmobj\lmobj\$(O)\lmobj.lib        \
               ..\..\lmobj\lmoenum\$(O)\lmoenum.lib    \
# JonN 1/20/02 remove REG_ENUM and log classes ..\..\lmobj\log\$(O)\lmlog.lib

SOURCE_DEF= netui1.hdr
TARGET_DEF= $(O)\netui1.def

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\dll2\makefile.inc ===
#
# How this works: since lmuicmn.def will (should) be identical between
# MIPS and 386 as long as both use cfront, I only run one even if both
# envs are specified in the build.
#
# When these diverge - i.e. when 386 abandons cfront - each will need to
# build its own .def in $(O).
#

#
# List of source libraries for the DLL
#

DLL_SOURCELIBS=..\..\blt\blt\$(O)\uiblt.lib            \
               ..\..\blt\bltcc\$(O)\uibltcc.lib        \
               ..\..\applib\bin\$(O)\uiapplib.lib


SOURCE_DEF= netui2.hdr
TARGET_DEF= $(O)\netui2.def

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\dll3\dll2\init.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    init.cxx
    Initialization for LMUICMN0

    FILE HISTORY:
        beng        30-Jul-1992 Header added
        beng        04-Aug-1992 Heap residue added; converted to C++
        jonn        25-Mar-1993 ITG special sort
*/

#define INCL_WINDOWS
#define INCL_NETLIB
#include "lmui.hxx"

#include "blt.hxx"

#include "heapdbg.hxx"


extern "C"
{
    #include "lmuicmn.h"

    /* hackety hack hack hack */
    int errno = 0; /* BUGBUG! */

    HMODULE hmodBlt = 0;

    BOOL DllMain( HMODULE hmod, DWORD nReason, LPVOID lpReserved ) ;
}


BOOL DllMain( HMODULE hmod, DWORD nReason, LPVOID lpReserved )
{
    UNREFERENCED(lpReserved);

    if (nReason == DLL_PROCESS_ATTACH)
    {
	DisableThreadLibraryCalls(hmod);

	::hmodBlt = hmod;
	if ( BLT::InitDLL() )
	    return FALSE ;
    }
    else if (nReason == DLL_PROCESS_DETACH)
    {
	BLT::TermDLL() ;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmocnfg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmocnfg.cxx
    Class definitions for the CONFIG class.

    This file contains the class definitions for the LM_CONFIG class.
    The LM_CONFIG class is used for reading & writing a remote server's
    LANMAN.INI configuration file.

    FILE HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        terryk      07/Oct-1991 type changes for NT
        KeithMo     08-Oct-1991 Now includes LMOBJP.HXX.
        terryk      17-Oct-1991 WIN 32 conversion
                                Check strlen of the comment. if the
                                comment is empty string, use the default
                                string
        terryk      21-Oct-1991 WIN 32 conversion

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  LM_CONFIG methods.
//

/*******************************************************************

    NAME:       LM_CONFIG :: LM_CONFIG

    SYNOPSIS:   LM_CONFIG class constructor.

    ENTRY:      pszServerName           - The name of the target server
                                          (with the leading '\\' slashes).

                pszSectionName          - The LANMAN.INI section name.

                pszKeyName              - The LANMAN.INI key name.

    EXIT:       The object is contructed.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Removed all LanMan version checking.
        KeithMo     21-Aug-1991 Changed const TCHAR * to NLS_STR.
        KeithMo     22-Aug-1991 Removed funky LoadModule stuff.

********************************************************************/
LM_CONFIG :: LM_CONFIG( const TCHAR * pszServerName,
                  const TCHAR * pszSectionName,
                  const TCHAR * pszKeyName )
  : _nlsServerName( pszServerName ),
    _nlsSectionName( pszSectionName ),
    _nlsKeyName( pszKeyName )
{
    //
    //  Ensure that we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsServerName.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsSectionName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsKeyName.QueryError()     ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

#ifdef  DEBUG
    if ( _nlsServerName.strlen() != 0 )
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( _nlsServerName );

        UIASSERT( _nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
        ++istrDbg;
        UIASSERT( _nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
    }
#endif  // DEBUG

}   // LM_CONFIG :: LM_CONFIG


/*******************************************************************

    NAME:       LM_CONFIG :: ~LM_CONFIG

    SYNOPSIS:   LM_CONFIG class destructor.  Will free the current
                NETAPI.DLL reference if this was loaded in the
                constructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.

********************************************************************/
LM_CONFIG :: ~LM_CONFIG()
{
    //
    //  This space intentionally left blank.
    //

}   // LM_CONFIG :: ~LM_CONFIG


/*******************************************************************

    NAME:       LM_CONFIG :: QueryValue

    SYNOPSIS:   Read a configuration entry from the target LANMAN.INI.

    ENTRY:      pnlsValue               - This buffer receives the
                                          configuration entry.

                pszDefaultValue         - The default value to be used if
                                          LANMAN.INI cannot be accessed or
                                          if the section/entry name cannot
                                          be found.

    EXIT:       The entry is read.  If the entry was not found, then
                the default value is used.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        KeithMo     21-Aug-1991 Changed const TCHAR * to NLS_STR.
        terryk      17-Oct-1991 Check the string lenght, if it is
                                equal to 0, use the default string

********************************************************************/
APIERR LM_CONFIG :: QueryValue( NLS_STR    * pnlsValue,
                             const TCHAR * pszDefaultValue )
{
    APIERR err;

    //
    //  Determine our buffer length.
    //
    BYTE *pBuffer = NULL;
    err = ::MNetConfigGet( _nlsServerName.QueryPch(),
                           NULL,
                           _nlsSectionName.QueryPch(),
                           _nlsKeyName.QueryPch(),
                           &pBuffer );

    if( ( err == NERR_CfgCompNotFound ) ||
        ( err == NERR_CfgParamNotFound ) ||
        ( ( pBuffer != NULL ) &&
          ( ::strlenf((TCHAR *) pBuffer ) == 0 ) ) )
    {
        //
        //  Either the component or the parameter were
        //  not found.  Ergo, use the default.
        //

        *pnlsValue = pszDefaultValue;

        ::MNetApiBufferFree( &pBuffer );

        return pnlsValue->QueryError();
    }

    if( ( err != NERR_Success     ) &&
        ( err != NERR_BufTooSmall ) &&
        ( err != ERROR_MORE_DATA  ) )
    {
        //
        //  Unknown error.
        //

        return err;
    }

    *pnlsValue = (TCHAR *)pBuffer;

    ::MNetApiBufferFree( &pBuffer );

    return pnlsValue->QueryError();

}   // LM_CONFIG :: QueryValue


/*******************************************************************

    NAME:       LM_CONFIG :: SetValue

    SYNOPSIS:   Write a configuration entry to the target LANMAN.INI.

    ENTRY:      pnlsNewValue            - This buffer is written to
                                          the LANMAN.INI entry.

    EXIT:       The entry is written.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Mapped ERROR_NOT_SUPPORTED to
                                NERR_Success if NetConfigSet() fails.
        KeithMo     21-Aug-1991 Changed const TCHAR * to NLS_STR.
        KeithMo     03-Jan-1993 Removed ERROR_NOT_SUPPORTED mapping.

********************************************************************/
APIERR LM_CONFIG :: SetValue( NLS_STR * pnlsNewValue )
{
    //
    //  Update LANMAN.INI.
    //

    APIERR err = ::MNetConfigSet( _nlsServerName.QueryPch(),
                                  _nlsSectionName.QueryPch(),
                                  _nlsKeyName.QueryPch(),
                                  pnlsNewValue->QueryPch() );

    return err;

}   // LM_CONFIG :: SetValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\apisess.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
 * This module contains the implementation of API_SESSION.
 *
 *
 * History
 *      thomaspa        08/04/92        Created
 */


#include "pchlmobj.hxx"  // Precompiled header

APIERR ConnectToNullSession( const NLS_STR & nlsRemote ) ;

/*******************************************************************

    NAME: API_SESSION::API_SESSION

    SYNOPSIS: Constructor

    ENTRY: pszServer - the server to which to connect.

    EXIT: none

    NOTES:

    HISTORY:
        thomaspa        08/04/92        Created

********************************************************************/
API_SESSION::API_SESSION( const TCHAR * pszServer, BOOL fNullSessionOK ) :
    _pnlsRemote( NULL )
{
    /* We shouldn't have to connect to the local machines IPC$ (i.e.,
     * we've already been validated).
     */
    if ( pszServer == NULL || !*pszServer )
        return ;



    // Construct the UNC path to the IPC$ share on the server
     _pnlsRemote = new NLS_STR(pszServer);

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if ( _pnlsRemote == NULL
        || (err = _pnlsRemote->QueryError()) != NERR_Success )
    {
        delete _pnlsRemote;
        _pnlsRemote = NULL;
        ReportError( err );
        return;
    }

    ISTR istr( *_pnlsRemote );
    if ( _pnlsRemote->QueryChar( istr ) != TCH('\\') )
    {
        ALIAS_STR nlsWhackWhack = SZ("\\\\");
        if ( !_pnlsRemote->InsertStr( nlsWhackWhack, istr ) )
        {
            ReportError( _pnlsRemote->QueryError() );
            return;
        }
    }


    // No need to create session to ourselves
    DWORD cch = MAX_COMPUTERNAME_LENGTH+1;
    BUFFER buf( sizeof(TCHAR)*(cch) );
    if (!buf)
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if ( !::GetComputerName( (LPTSTR)(buf.QueryPtr()), &cch ))
    {
            DWORD errLast = ::GetLastError();
            ReportError( errLast );
            return;
    }

    ISTR istrRemote( *_pnlsRemote );
    istrRemote += 2;

    if( !::I_MNetComputerNameCompare( _pnlsRemote->QueryPch( istrRemote ),
                                      (const TCHAR *)buf.QueryPtr() ) )
    {
        delete _pnlsRemote;
        _pnlsRemote = NULL;
        return;
    }

    ALIAS_STR nlsIPC( SZ("IPC$") );

    if ( (err = _pnlsRemote->AppendChar( TCH('\\') )) != NERR_Success
        || (err = _pnlsRemote->Append( nlsIPC )) != NERR_Success )
    {
        ReportError( err );
        return;
    }


    // Try a connection using the current credentials
    struct use_info_1 ui1;
    ui1.ui1_local = NULL;
    ui1.ui1_remote = (TCHAR *)_pnlsRemote->QueryPch();
    ui1.ui1_password = NULL;
    ui1.ui1_asg_type = USE_IPC;

    err = ::MNetUseAdd( NULL, 1, (BYTE *)&ui1, sizeof(ui1) );

    switch( err )
    {
    case NERR_Success:
        break;
    case ERROR_SESSION_CREDENTIAL_CONFLICT:
        // They must already have a valid session, use it.
        delete _pnlsRemote;
        _pnlsRemote = NULL;
        break;

    default:
        DBGEOL( SZ("ADMIN: API_SESSION: bad first error ") << err );
        // fall through
    case ERROR_ACCESS_DENIED:
    case ERROR_LOGON_FAILURE:
    case ERROR_TRUSTED_DOMAIN_FAILURE:

        if ( err = ::ConnectToNullSession( *_pnlsRemote ) )
        {
            if ( err == ERROR_SESSION_CREDENTIAL_CONFLICT )
            {
                delete _pnlsRemote ;
                _pnlsRemote = NULL ;
                err = NERR_Success ;
            }
            else
                ReportError( err ) ;
        }
        break;
    }

    return;
}



/*******************************************************************

    NAME: API_SESSION::~API_SESSION

    SYNOPSIS: Destructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
        thomaspa        08/04/92        Created

********************************************************************/
API_SESSION::~API_SESSION( )
{

    if ( _pnlsRemote != NULL )
    {
        (void)::MNetUseDel( NULL,
                            (TCHAR *)_pnlsRemote->QueryPch(),
                            USE_NOFORCE );

        delete _pnlsRemote;
        _pnlsRemote = NULL;
    }
}

/*******************************************************************

    NAME:       ConnectToNullSession

    SYNOPSIS:   Attempts to connect using the NULL session

    ENTRY:      nlsRemote - Remote resource to connect to

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   03-Dec-1992     Broke out from constructor

********************************************************************/


APIERR ConnectToNullSession( const NLS_STR & nlsRemote )
{
    // Try a connection using the NULL session
    struct use_info_2 ui2;

    ui2.ui2_local = NULL;
    ui2.ui2_remote = (TCHAR *)nlsRemote.QueryPch();
    ui2.ui2_password = SZ("");
    ui2.ui2_asg_type = USE_IPC;
    ui2.ui2_username = SZ("");
    ui2.ui2_domainname = SZ("");

    return ::MNetUseAdd( NULL, 2, (BYTE *)&ui2, sizeof(ui2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmocomp.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*  HISTORY:
 *	ChuckC	    07-Dec-1990     Created
 *	ChuckC	    3/6/91	    Code Review changes from 2/28/91
 *				    (chuckc,johnl,rustanl,annmc,jonshu)
 *	terryk	    9/17/91	    Change parent class from LM_OBJ to
 *	KeithMo	    10/8/91	    Now includes LMOBJP.HXX.
 *	terryk	    10/17/91	    WIN 32 conversion
 *	terryk	    10/21/91	    Include Windows
 *
 */
#include "pchlmobj.hxx"  // Precompiled header

/*************************** computer *************************/

/**********************************************************\

   NAME:       COMPUTER::COMPUTER

   SYNOPSIS:   constructor for the computer class

   ENTRY:      TCHAR * pszName computer name

   HISTORY:
 	   ChuckC	    07-Dec-1990     Created
	   terryk	    17-Sep-1991	    change LM_OBJ to LOC_LM_OBJ

\**********************************************************/

COMPUTER::COMPUTER(const TCHAR * pszName)
    : LOC_LM_OBJ( pszName ),
    _nlsName( pszName )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
    APIERR err = ValidateName( pszName );
    if ( err != NERR_Success )
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }
}

/**********************************************************\

   NAME:       COMPUTER::~COMPUTER

   SYNOPSIS:   destructor for the computer class

   HISTORY:
 	   ChuckC	    07-Dec-1990     Created
	   terryk           17-Sep-1991	    return the delete stuff

\**********************************************************/

COMPUTER::~COMPUTER()
{
    // do nothing
}

/**********************************************************\

   NAME:       COMPUTER::ValidateName

   SYNOPSIS:   validate the computer name

   HISTORY:
 	   ChuckC	    07-Dec-1990     Created
	   terryk	    17-Sep-1991	    add the computer name as a
					    parameter

\**********************************************************/

APIERR COMPUTER::ValidateName( const TCHAR * pszName )
{
    /*
     * null case is valid
     */

    if (( pszName == NULL ) || ( pszName[0] == TCH('\0')))
	return (NERR_Success) ;

    /*
     * else insist on \\ and valid computer name
     */
    if ( (pszName[0] != TCH('\\') || pszName[1] != TCH('\\')) ||
    	 (::I_MNetNameValidate(NULL, &pszName[2], NAMETYPE_COMPUTER, 0L)
	 != NERR_Success))
	return (ERROR_INVALID_PARAMETER) ;
    else
	return (NERR_Success) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmoacces.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    LMOAcces.cxx
    Definition of the NET_ACCESS_1 class


    FILE HISTORY:
	rustanl     20-May-1991     Created
	Johnl	    05-Aug-1991     Converted ACCPERM to NET_ACCESS
	Johnl	    14-Aug-1991     Modified to conform to NEW_LMOBJ changes
	rustanl     21-Aug-1991     Renamed NEW_LM_OBJ buffer methods
	terryk	    07-Oct-1991	    type changes for NT
	KeithMo	    08-Oct-1991	    Now includes LMOBJP.HXX.
	terryk	    17-Oct-1991	    WIN 32 conversion
	terryk	    21-Oct-1991	    remove memory.h reference
				    change UINT to USHORT2ULONG

*/

#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NET_ACCESS::NET_ACCESS

    SYNOPSIS:	NET_ACCESS constructor

    ENTRY:	pszServer -	    Pointer to server name where
				    the pszResource path resides.
				    May be NULL to indicate the local
				    computer.
		pszResource -	    Indicates a resource on the given
				    server.

    NOTES:	For files, psz can be NULL and pszResource can be a local
		path redirected to a remote server.  The QueryName method
		below will return whatever was passed in as pszResource.

    HISTORY:
	rustanl     29-May-1991     Created from ACCPERM constructor
	Johnl	    05-Aug-1991     Converted to NET_ACCESS class

********************************************************************/

NET_ACCESS::NET_ACCESS( const TCHAR * pszServer,
			const TCHAR * pszResource )
    :	LOC_LM_OBJ( pszServer ),
	_nlsServer( MAX_PATH ),
	_nlsResource( 5 )	// Handle common resource names
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err ;
    if ( (err = _nlsServer.QueryError() ) != NERR_Success ||
	 (err = _nlsResource.QueryError() ) != NERR_Success ||
	 (err = SetServerName( pszServer )) != NERR_Success ||
	 (err = SetName( pszResource ) )    != NERR_Success   )
    {
	UIDEBUG( SZ("NET_ACCESS_OBJ ct:  failed construction\r\n") );
	ReportError( err ) ;
	return;
    }


}  // NET_ACCESS::NET_ACCESS


/*******************************************************************

    NAME:	NET_ACCESS::~NET_ACCESS

    SYNOPSIS:	Empty destructor

    HISTORY:
	Johnl	16-Aug-1991	Created

********************************************************************/

NET_ACCESS::~NET_ACCESS()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NET_ACCESS::QueryName

    SYNOPSIS:	Returns the (canonicalized version of the) resource name
		passed to the constructor

    RETURNS:	Pointer to said name

    NOTES:	For file permissions, the returned string may be a local
		path or a path on a server, depending on what was passed
		to the constructor.  It is therefore questionable how
		useful this method is in general (i.e., where it is not
		known what was passed to the constructor).

    HISTORY:
	rustanl     20-May-1991     Created

********************************************************************/

const TCHAR * NET_ACCESS::QueryName( VOID ) const
{
    if ( QueryError() == NERR_Success )
    {
	//  Note, that this path may be a local path, or a path
	//  on a server.
	return _nlsResource.QueryPch();
    }

    return NULL;
}

/*******************************************************************

    NAME:	NET_ACCESS::SetName

    SYNOPSIS:	Sets the resource name for this object

    ENTRY:	pszResName is the name of the resource

    RETURNS:	NERR_Success if successful, standard error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Aug-1991	Created

********************************************************************/

APIERR NET_ACCESS::SetName( const TCHAR * pszResName )
{
    //	Note, the path parameter should really be validated here.
    //	However, the path may be a long file name, and the I_MNetPathType
    //	validation API automatically sets the INPT_FLAGS_OLDPATHS
    //	flag on DOS (and OS/2 1.1) systems.  Since Windows is such
    //	a system, the API would only be able to validate FAT file names
    //	if called locally.  The I_MNetPathType API could be remoted to
    //	the _nlsServer server.	However, this would cause another net
    //	call which would only do a subset of what NetAccessGetInfo
    //	will do later anyway.  Note, that the same argument cannot be
    //	applied to validating the server name above, since, for one,
    //	that validation is done locally.

    _nlsResource = pszResName ;
    return _nlsResource.QueryError() ;
}

/*******************************************************************

    NAME:	NET_ACCESS::SetServerName

    SYNOPSIS:	Sets the server name for this object

    ENTRY:	pszServerName is the name of the server where the resource
		resides (or NULL for a local resource).

    RETURNS:	NERR_Success if successful, standard error code otherwise

    HISTORY:
	Johnl	27-Aug-1991	Created

********************************************************************/

APIERR NET_ACCESS::SetServerName( const TCHAR * pszServerName )
{
    /* Note: nlsServer cannot be an ALIAS_STR because ALIAS_STRs can't be
     * NULL.
     */
    NLS_STR nlsServer( pszServerName ) ;
    if ( nlsServer.QueryError() != NERR_Success )
	return nlsServer.QueryError() ;

    if ( nlsServer.strlen() == 0 )
    {
	//  No server was given.  This is a valid input.
	//  The given path is assumed to be a local resource (including
	//  a local path, redirected to a server).
    }
    else
    {
	//  A server name was given.  Verify that it is a legal one.
	//  We will assume it is illegal (no '\\') or NetNameValidate
	//  will reassign err

	APIERR err = (APIERR)ERROR_INVALID_PARAMETER ;
	ISTR istr( nlsServer );
	if ( nlsServer.QueryChar( istr ) != TCH('\\')    ||
	     nlsServer.QueryChar( ++istr ) != TCH('\\')  ||
	     ( err = ::I_MNetNameValidate( NULL, nlsServer[ ++istr ],
				NAMETYPE_COMPUTER, 0L ) ) != NERR_Success )
	{
	    UIDEBUG( SZ("Invalid server name") );
	    return err ;
	}
    }

    _nlsServer = nlsServer ;

    return _nlsServer.QueryError() ;
}


/*******************************************************************

    NAME:	NET_ACCESS::QueryServerName

    SYNOPSIS:	Returns a pointer to the (canonicalized version of the)
		server name passed to the constructor

    RETURNS:	A pointer to the said name

    HISTORY:
	rustanl     28-May-1991     Created

********************************************************************/

const TCHAR * NET_ACCESS::QueryServerName( VOID ) const
{
    if ( QueryError() == NERR_Success )
    {
	if ( _nlsServer.strlen() == 0 )
	    return NULL ;
	else
	    return _nlsServer.QueryPch();
    }

    UIDEBUG(SZ("NET_ACCESS:QueryName - Calling when object is in error state\n\r")) ;
    return NULL;
}

/*******************************************************************

    NAME:	NET_ACCESS::Delete

    SYNOPSIS:	Deletes the ACL from the net resource

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	10-Apr-1992	Created

********************************************************************/

APIERR NET_ACCESS::Delete( void )
{
    APIERR err = NERR_Success ;
    err = ::MNetAccessDel( QueryServerName(),
			   (TCHAR *)QueryName() ) ;
    return err ;
}



/*******************************************************************

    NAME:	NET_ACCESS_1::NET_ACCESS_1

    SYNOPSIS:	Constructor for NET_ACCESS_1 class

    ENTRY:	pszServer - server the resource resides (can be NULL)
		pszResource - Resource info we want to get

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

NET_ACCESS_1::NET_ACCESS_1( const TCHAR * pszServer,
			    const TCHAR * pszResource )
    : NET_ACCESS( pszServer, pszResource ),
      _strlstAccountNames(),
      _cACE( 0 )
{
    if ( QueryError() != NERR_Success )
	return ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::~NET_ACCESS_1

    SYNOPSIS:	Empty destructor

    HISTORY:
	Johnl	16-Aug-1991	Created

********************************************************************/

NET_ACCESS_1::~NET_ACCESS_1()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NET_ACCESS_1::I_GetInfo

    SYNOPSIS:	Calls NetAccessGetInfo with the given buffer, resizing
		the buffer until the call is successful or some non-
		buffer size related error occurs.

    ENTRY:	pbuf -		Pointer to BUFFER object which will
				receive the ACL.

    EXIT:	On success, the *pbuf buffer will contain the ACL.

    RETURNS:	An API error code, which is NERR_Success on success.

    HISTORY:
	rustanl     24-May-1991     Created
	rustanl     15-Jul-1991     Modified to work with new BUFFER::Resize
				    return code.
	Johnl	    06-Aug-1991     Made into NET_ACCESS_1

********************************************************************/

APIERR NET_ACCESS_1::I_GetInfo( VOID )
{
    while ( TRUE )
    {
	UIDEBUG(SZ("NET_ACCESS_1::I_GetInfo - Resource Name ==")) ;
	UIDEBUG(QueryName()) ;
	UIDEBUG(SZ("\n\r")) ;
	UIDEBUG(SZ("Server parameter is :")) ;
#ifdef DEBUG
        if ( QueryServerName() == NULL )
        {
            UIDEBUG( SZ("NULL") ) ;
	    UIDEBUG( QueryServerName() ) ;
        }
#endif
	UIDEBUG(SZ("\n\r")) ;

	BYTE * pBuffer = NULL;		// pointer to the buffer

	APIERR err = ::MNetAccessGetInfo( QueryServerName(),
				   	  (TCHAR *)QueryName(),
				   	  1,
				   	  &pBuffer );
	if ( err )
	{
	    SetBufferPtr( NULL ) ;
	    return err ;
	}

	SetBufferPtr( pBuffer );

	switch ( err )
	{
	case NERR_Success:
	{
	    _cACE = (UINT)((access_info_1 *)QueryBufferPtr())->acc1_count;

	    //	Set resource name to NULL, so that no mistake will be made
	    //	trying to access the resource name from there.
	    ((access_info_1 *)QueryBufferPtr())->acc1_resource_name = NULL;

	    return NERR_Success ;
	}

	case NERR_ResourceNotFound:
	    _cACE = 0;
	    // Fall through
	default:
	    return err;

	}
    }

    UIASSERT( !SZ("Should never get here") );
    return NERR_InternalError;

}  // NET_ACCESS_1::GetNetAccessInfo

/*******************************************************************

    NAME:	NET_ACCESS_1::I_CreateNew

    SYNOPSIS:	Initializes to no permissions

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

APIERR NET_ACCESS_1::I_CreateNew( VOID )
{
    APIERR err = NERR_Success ;
    if ( (err = ResizeBuffer( QueryRequiredSpace( 0 ) )) ||
	 (err = SetAuditFlags( 0 )) ||
	 (err = ClearPerms() ) )
    {
	/* Fall through
	 */
    }

    return err ;
}


APIERR NET_ACCESS_1::I_WriteInfo( VOID )
{
    return I_WriteInfoAux() ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::I_WriteNew

    SYNOPSIS:	Writes the ACL

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	We simply call through to I_WriteInfo since it will
		attach the ACL if there isn't one there (thus
		circumventing the need for WriteNew).

    HISTORY:
	Johnl	01-Oct-1991	Created

********************************************************************/

APIERR NET_ACCESS_1::I_WriteNew( VOID )
{
    return I_WriteInfoAux() ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::WriteInfoAux

    SYNOPSIS:	Writes the ACL - can be called from WriteInfo or
		WriteNew.

    RETURNS:	An API error, which is NERR_Success on success.

    NOTES:	If the return code is NERR_UserNotFound, the
		QueryFailingName method can be used to find the
		failing name.

    HISTORY:
	rustanl     24-May-1991     Created
	Johnl	    01-Oct-1991     Created from WriteInfo

********************************************************************/

APIERR NET_ACCESS_1::I_WriteInfoAux( VOID )
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return ERROR_GEN_FAILURE;
    }

    APIERR err;
    {
	//
	//  Any set method will resize the buffer appropriately, and
	//  somebody had better set the data before writing the data out
	//
	UIASSERT( QueryBufferSize() >= QueryRequiredSpace( 0 ) ) ;

	access_info_1 * pai1   = (access_info_1 *)QueryBufferPtr();
	UINT		cbBuf  = QueryBufferSize() ;

	pai1->acc1_resource_name = (TCHAR *)QueryName();
	pai1->acc1_count = _cACE;

	err = ::MNetAccessSetInfo( QueryServerName(),
				   (TCHAR *)QueryName(),
				   1,
				   (BYTE *)pai1,
				   cbBuf,
				   PARMNUM_ALL );

	if ( err == NERR_ResourceNotFound )
	{
	    err = ::MNetAccessAdd( QueryServerName(),
				   1,
				   (BYTE *)pai1,
				   cbBuf );
	}

	//  Set the resource name pointer to NULL, so that accidental
	//  referencing of this object will be detected sooner.
	pai1->acc1_resource_name = NULL;
    }

    return err;

}  // NET_ACCESS_1::WriteInfoAux

/*******************************************************************

    NAME:	NET_ACCESS_1::QueryACECount

    SYNOPSIS:	Returns the number of access control entries (ACEs) for
		the resource

    RETURNS:	The said count

    HISTORY:
	rustanl     08-May-1991     Created

********************************************************************/

UINT NET_ACCESS_1::QueryACECount( VOID ) const
{
    if ( QueryError() == NERR_Success )
	return _cACE;

    UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
    return 0;

}  // NET_ACCESS_1::QueryACECount


/*******************************************************************

    NAME:	NET_ACCESS_1::SetAuditFlags

    SYNOPSIS:	Sets the audit flags of this object

    ENTRY:	sAuditFlags - Mask of audit flags

    EXIT:

    RETURNS:	APIERR if successful

    NOTES:

    HISTORY:
	Johnl	28-Oct-1991	Moved from header file so we can
				reallocate if necessary

********************************************************************/

APIERR NET_ACCESS_1::SetAuditFlags( short sAuditFlags )
{
    APIERR err = NERR_Success  ;

    /* we only want resize if NULL or empty buffer. otherwise,
       it was something we got back from NETAPI with pointers to
       itself and reallocating will be badness,
     */
    if ( QueryBufferPtr() == NULL || QueryBufferSize() < QueryRequiredSpace(0) )
	err = ResizeBuffer( QueryRequiredSpace( 0 )) ;

    if ( !err )
	((access_info_1 *)QueryBufferPtr())->acc1_attr = sAuditFlags ;

    return err ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::ClearPerms

    SYNOPSIS:	Clears all permissions for the resource

    RETURNS:	An API error code, which is NERR_Success on success

    HISTORY:
	rustanl     20-May-1991     Created

********************************************************************/

APIERR NET_ACCESS_1::ClearPerms( VOID )
{
    UIASSERT( QueryError() == NERR_Success );
    _cACE = 0;

    _strlstAccountNames.Clear() ;
    return ( QueryError() == NERR_Success ? NERR_Success : ERROR_INVALID_FUNCTION );

}  // NET_ACCESS_1::ClearPerms

/*******************************************************************

    NAME:	NET_ACCESS_1::CopyAccessPerms

    SYNOPSIS:	Copies all of the access permissions from the passed
		NET_ACCESS_1 object.  This may eventually be replaced
		by a clone method, but clone is currently broken
		under NT.

    ENTRY:	netaccess1Src - Where to get the access permissions from

    EXIT:	The state of the LMOBJ doesn't change (i.e. valid etc.)

    RETURNS:	NERR_Success if successful

    NOTES:	This method replaces any current ACEs in *this.

    HISTORY:
	Johnl	28-Oct-1991	Created

********************************************************************/

APIERR NET_ACCESS_1::CopyAccessPerms( const NET_ACCESS_1 & netaccess1Src )
{
    UIASSERT( QueryError() == NERR_Success );
    UIASSERT( netaccess1Src.QueryError() == NERR_Success ) ;

    APIERR err ;
    if ( err = ResizeBuffer( netaccess1Src.QueryRequiredSpace(
					    netaccess1Src.QueryACECount() ) ) )
    {
	return err ;
    }

    // cast city
    access_list * palSrc  = netaccess1Src.QueryACE( 0 );
    access_list * palDest = QueryACE( 0 );

    for ( UINT i = netaccess1Src.QueryACECount() ; i > 0 ; i--, palSrc++, palDest++ )
    {
#ifdef WIN32
	NLS_STR * pnlsAccount = new NLS_STR( palSrc->acl_ugname ) ;

	err = ERROR_NOT_ENOUGH_MEMORY ;
	if ( (pnlsAccount == NULL) ||
	     (err = pnlsAccount->QueryError()) ||
	     (err = _strlstAccountNames.Add( pnlsAccount )) )
	{
	    return err ;
	}

	palDest->acl_ugname = (LPTSTR) pnlsAccount->QueryPch() ;
#else
	COPYTOARRAY( palDest->acl_ugname, palSrc->acl_ugname );
#endif //WIN32

	palDest->acl_access = palSrc->acl_access ;
    }

    _cACE = netaccess1Src.QueryACECount() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::FindACE

    SYNOPSIS:	Returns a pointer to the ACE for a given user or group

    ENTRY:	pszName -	    Pointer to name of user or group
				    Caution:  See Notes section below.
		nt -		    Specifies whether pszName points to
				    a group name or a user name.

    RETURNS:	Pointer to specified ACE, or NULL if no ACE was found
		for the given user/group

    NOTES:	This method assumes that pszName points to an already
		canonicalized user or group name.

    HISTORY:
	rustanl     24-May-1991     Created

********************************************************************/

access_list * NET_ACCESS_1::FindACE( const TCHAR * pszName,
				enum PERMNAME_TYPE nt ) const
{
    UIASSERT( QueryError() == NERR_Success );	    // here, it's okay to simply assert for the
				// valid state, since the method is private
    UIASSERT( pszName != NULL );

    if ( _cACE == 0 )
    {
	//  If the count is 0, we don't want to reference the _buf object.
	return NULL;
    }

    // cast city
    access_list * pal = QueryACE( 0 );

    //	Note, this is an important assignment, because it ensures that
    //	fUserName is either 0 or 1.  See also the use of operator! below.
    BOOL fUserName = ( nt == PERMNAME_USER );

    for ( UINT i = _cACE; i > 0; i--, pal++ )
    {
	//  Note, the following comparison checks whether
	//  !( pal->acl_access & ACCESS_GROUP ) and fUserName are either
	//  both true or both false.  (Note, operator! must be used on
	//  the left hand side with the & expression, and cannot be used
	//  on the right hand side with fUserName.  This is because we
	//  need to ensure that both sides of operator!= are either 0 or 1.
	//  See also comment at fUserName assignment above.)
	if ( ( ! ( pal->acl_access & ACCESS_GROUP )) != fUserName )
	{
#ifdef DEBUG
	    if ( strcmpf( pszName, pal->acl_ugname ) == 0 )
	    {
		//  In current versions of LAN Man (pre-NT), the following
		//  could be an assert.  However, under NT groups and users
		//  share the  same name space, so asserting out would be
		//  the wrong thing to do.  Hence, a UIDEBUG is used, so
		//  that some degree of noise is made.
		UIDEBUG( SZ("NET_ACCESS_1::FindACE:  Name matches but perm name type value does not\r\n") );
	    }
#endif
	    continue;
	}

	//  Note, strcmpf is fine here since szName is assumed to have
	//  been canonicalized, and acl_ugname should come back
	//  canonicalized.
	if ( strcmpf( pszName, pal->acl_ugname ) == 0 )
	    return pal;
    }

    //	user/group not found among ACEs
    return NULL;

}  // NET_ACCESS_1::FindACE


/*******************************************************************

    NAME:	NET_ACCESS_1::QueryPerm

    SYNOPSIS:	Returns the permissions set for a given user or
		group for the resource

    ENTRY:	pszName -	    Pointer to name of user or group
		nt -		    Specifies whether pszName points to
				    a group name or a user name.

    RETURNS:	A PERM value corresponding to the permissions of the
		given user/group.  This value can be one of the following:

		    PERM_NO_SETTING	There are no explicit permissions
					set on this user or group.  Users
					thus inherit permissions from
					their group memberships

		    PERM_DENY_ACCESS	The user is denied access to the
					resource.  A group cannot have
					PERM_DENY_ACCESS permission.

		    A non-empty (since	The user/group has the indicated
		    PERM_NO_SETTING is	permissions.
		    defined to be 0)
		    union of the
		    following bits:
			PERM_READ
			PERM_WRITE
			PERM_EXEC
			PERM_CREATE
			PERM_DELETE
			PERM_ATTRIB
			PERM_PERM

    HISTORY:
	rustanl     24-May-1991     Created
	rustanl     28-May-1991     Added ACCESS_-to-PERM_ conversions

********************************************************************/

PERM NET_ACCESS_1::QueryPerm( const TCHAR * pszName, enum PERMNAME_TYPE nt ) const
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return PERM_NO_SETTING;
    }

    UIASSERT( pszName != NULL );

    TCHAR szName[ UNLEN + 1 ];
    APIERR err = ::I_MNetNameCanonicalize( NULL, pszName,
					szName,
                                        sizeof szName / sizeof (TCHAR) - 1,
					( ( nt == PERMNAME_USER ) ?
						   NAMETYPE_USER :
						   NAMETYPE_GROUP ),
					0L );
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1::QueryPerm given invalid user/group name") );
	return PERM_NO_SETTING;
    }

    access_list * pal = FindACE( szName, nt );
    if ( pal == NULL )
    {
	return PERM_NO_SETTING;
    }

    PERM perm = (UINT)( pal->acl_access & ( ~ACCESS_GROUP )); // strip off group bit
    UIASSERT( ! ( perm & PERM_DENY_ACCESS ));	// we assume that
						// PERM_DENY_ACCESS is unused
						// by the NetAccess API
    if ( perm == 0 )
    {
	//  There is an ACE with no permission bits.  This means deny.
	UIASSERT( nt != PERMNAME_GROUP );   //	Groups cannot have deny bits.
	return PERM_DENY_ACCESS;
    }

    return perm;

}  // NET_ACCESS_1::QueryPerm

/*******************************************************************

    NAME:	NET_ACCESS_1::SetPerm

    SYNOPSIS:	Sets the permissions for a given user or group

    ENTRY:	pszName -	    Pointer to name of user or group
		nt -		    Specifies whether pszName points to
				    a group name or a user name.
		perm -		    New permissions.  It may take the
				    same values as are returned from
				    QueryPerm.

    RETURNS:	An API error code, which is NERR_Success on success.

    HISTORY:
	rustanl     24-May-1991     Created
	rustanl     28-May-1991     Added PERM_-to-ACCESS_ conversions
	rustanl     15-Jul-1991     Modified to work with new BUFFER::Resize
				    return code.

********************************************************************/

APIERR NET_ACCESS_1::SetPerm( const TCHAR * pszName,
			 enum PERMNAME_TYPE nt,
			 PERM perm )
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return ERROR_INVALID_FUNCTION;
    }

    UIASSERT( pszName != NULL );

    TCHAR szName[ UNLEN + 1 ];
    APIERR err = ::I_MNetNameCanonicalize( NULL, pszName,
					szName,
                                        sizeof szName  / sizeof (TCHAR) - 1,
					( ( nt == PERMNAME_USER ) ?
						   NAMETYPE_USER :
						   NAMETYPE_GROUP ),
					0L );
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1::SetPerm given invalid user/group name") );
	return ERROR_INVALID_PARAMETER;
    }

    //	Convert permissions to an ACCESS_ value
    PERM permNew = ( ( nt == PERMNAME_GROUP ) ? ACCESS_GROUP : 0 );
    if ( perm == PERM_DENY_ACCESS )
    {
	if ( nt == PERMNAME_GROUP )
	{
	    UIASSERT( SZ("Groups don't have a deny bit") );
	    return ERROR_INVALID_PARAMETER;
	}
	//  Don't modify permNew any further
    }
    else if ( ( perm & ( ~( PERM_READ | PERM_WRITE | PERM_EXEC |
			    PERM_CREATE | PERM_DELETE | PERM_ATTRIB |
			    PERM_PERM ))) == 0 )
    {
	//  Note, that the following assignment will leave permNew unchanged
	//  if perm==PERM_NO_SETTING.  This is checked for below, since
	//  this requires special action on the API side.
	permNew |= perm;
    }
    else
    {
	UIASSERT( !SZ("Unexpected perm value") );
	return ERROR_INVALID_PARAMETER;
    }

    access_list * pal = FindACE( szName, nt );
    if ( pal != NULL )
    {
	if ( perm == PERM_NO_SETTING )	// Note, perm is compared, not permNew
	{
	    //	Need to remove ACE from buffer.  We do that by copying the
	    //	last ACE to this spot.
	    _cACE--;
	    access_list * palLast = QueryACE( _cACE );
	    if ( palLast == pal )
	    {
		// The ACE being removed is the last one; thus, we're done.
	    }
	    else
	    {
#ifdef WIN32
		pal->acl_ugname = palLast->acl_ugname ;

		/* Note that we could remove the account name from the accounts
		 * strlist but we will leave it there since it is harmless
		 */
#else
		COPYTOARRAY( pal->acl_ugname, palLast->acl_ugname);
#endif //WIN32

		pal->acl_access = palLast->acl_access;
	    }
	    return NERR_Success;
	}
	else
	{
	    pal->acl_access = permNew;
	    return NERR_Success;
	}
    }

    if ( perm == PERM_NO_SETTING )	// Note, perm is compared, not permNew
    {
	//  We are done, since there is no ACE for this user/group
	return NERR_Success;
    }

    //	Need to add an ACE for this user/group

    err = ResizeBuffer( QueryRequiredSpace( _cACE + 1 ));
    if ( err != NERR_Success )
    {
	return err;
    }

    pal = QueryACE( _cACE );

#ifdef WIN32
    NLS_STR * pnlsAccount = new NLS_STR( szName ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( (pnlsAccount == NULL) ||
	 (err = pnlsAccount->QueryError()) ||
	 (err = _strlstAccountNames.Add( pnlsAccount )) )
    {
	return err ;
    }

    pal->acl_ugname = (LPTSTR) pnlsAccount->QueryPch() ;
#else
    COPYTOARRAY( pal->acl_ugname, szName );
#endif //WIN32

    pal->acl_access = permNew;
    _cACE++;

    return NERR_Success;

}  // NET_ACCESS_1::SetPerm


/*******************************************************************

    NAME:	NET_ACCESS_1::CompareACL

    SYNOPSIS:	Compares the ACL (not the audit info) for the passed ACL

    ENTRY:	pnetacc1 - The item to compare against

    RETURNS:	TRUE if the ACLs grant the same access, FALSE if they do not

    NOTES:

    HISTORY:
	Johnl	10-Nov-1992	Created

********************************************************************/

BOOL NET_ACCESS_1::CompareACL( NET_ACCESS_1 * pnetacc1 )
{
    UIASSERT( pnetacc1 != NULL ) ;

    if ( QueryACECount() != pnetacc1->QueryACECount() )
    {
	return FALSE ;
    }

    for ( UINT i = 0 ; i < QueryACECount() ; i++ )
    {
	access_list * pacclist = QueryACE( i ) ;

	if ( pacclist == NULL )
	{
	    UIASSERT( FALSE ) ;
	    return FALSE ;
	}

	//
	//  Note that QueryPerm strips out the ACCESS_GROUP bit so
	//  we need to do the same before checking for equality
	//

	if ( (pacclist->acl_access & ~ACCESS_GROUP) !=
	     QueryPerm( pacclist->acl_ugname,
			pacclist->acl_access & ACCESS_GROUP ?
			    PERMNAME_GROUP :
			    PERMNAME_USER ))
	{
	    return FALSE ;
	}
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::QueryFailingName

    SYNOPSIS:	Finds a user or group name mentioned in an ACE,
		but no longer in the UAS.

    ENTRY:	pnls -	    Pointer to NLS_STR which will received
			    the failing name
		pnt -	    Pointer to PERMNAME_TYPE object which
			    will receive the type (user or group)
			    of the failing name.

    EXIT:	On success, *pnls contains the name of the failing
		user or group name, and *pnt contains the type thereof.
		If *pnls is the empty string (pnls->strlen() == 0)
		on a successful exit, then no name is failing.

    RETURNS:	The return code is an API error code, which is
		NERR_Success on success.  It indicates the success
		of finding the failing name.

    NOTES:	This function is not necessarily very efficient.
		For example, the user and group enum objects and/or
		the ACEs could be sorted, which may reduce the running
		time from quadratic to linear.	However, for small
		numbers of ACEs, this hardly seems worth it.

		Also, separate NetUserGetInfo and NetGroupGetInfo calls
		(through USER0 and GROUP0, of course) could be made.  This
		may end up taking much longer than searching the enumerated
		list every time, since a net call would be made for
		every user.

		Since it is not clear how much either of these
		alternatives would speed up the function, the implementation
		is left the way it is:	simple, and possibly efficient.

		Moreover, this function will not be called very often
		in reality, since changing the permissions while a user
		or group with permissions on the current resource is being
		deleted happens very infrequently.

    HISTORY:
	rustanl     28-May-1991     Created

********************************************************************/

APIERR NET_ACCESS_1::QueryFailingName( NLS_STR * pnls,
				  enum PERMNAME_TYPE * pnt  ) const
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return ERROR_INVALID_FUNCTION;
    }

    UIASSERT( pnls != NULL );
    UIASSERT( pnt != NULL );

    GROUP0_ENUM ge0( (TCHAR *)QueryServerName());
    APIERR err = ge0.GetInfo();
    if ( err != NERR_Success )
	return err;

    USER0_ENUM ue0( (TCHAR *)QueryServerName());
    err = ue0.GetInfo();
    if ( err != NERR_Success )
	return err;

    access_list * pal = QueryACE( 0 );
    for ( UINT iACE = 0; iACE < _cACE; iACE++, pal++ )
    {
	if ( pal->acl_access & ACCESS_GROUP )
	{
	    GROUP0_ENUM_ITER gei0( ge0 );
	    const GROUP0_ENUM_OBJ * pgi0;
	    while ( ( pgi0 = gei0()) != NULL )
	    {
		if ( strcmpf( pal->acl_ugname, pgi0->QueryName() ) == 0 )
		    break;
	    }

	    if ( pgi0 == NULL )
	    {
		// group was not found
		*pnls = pal->acl_ugname;
		return pnls->QueryError();
	    }
	}
	else
	{
	    USER0_ENUM_ITER uei0( ue0 );
	    const USER0_ENUM_OBJ * pui0;
	    while ( ( pui0 = uei0( &err )) != NULL )
	    {
                if ( err != NERR_Success )
                    return err;

		if ( strcmpf( pal->acl_ugname, pui0->QueryName() ) == 0 )
		    break;
	    }

	    if ( pui0 == NULL )
	    {
		// user was not found
		*pnls = pal->acl_ugname;
		return pnls->QueryError();
	    }
	}
    }

    //	No failing name found
    *pnls = NULL;
    return pnls->QueryError();

}  // NET_ACCESS_1::QueryFailingName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmobjnew.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  HISTORY:
 *      JonN        24-Jul-1991     Created
 *      rustanl     21-Aug-1991     Renamed NEW_LM_OBJ buffer methods
 *      rustanl     26-Aug-1991     Changed [W_]CloneFrom parameter
 *                                  from * to &
 *      jonn    8/29/91         Added ChangeToNew()
 *      jonn    9/05/91         Changes related to IsOKState()
 *      jonn    9/17/91         Moved CHECK_OK / CHECK_VALID strings to static
 *      terryk  10/7/91         type changes for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      terryk  10/21/91        change _pBuf from TCHAR * to BYTE *
 *      jonn    11/20/91        Fixed ResizeBuffer( 0 )
 *      jonn    5/08/92         Added ClearBuffer()
 *
 *      This file contains basic methods for the LM_OBJ root classes.
 */

#include "pchlmobj.hxx"  // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif


/**********************************************************\

   NAME:        NEW_LM_OBJ::NEW_LM_OBJ

   SYNOPSIS:    constructor and destructor

   NOTES:       The BUFFER object must construct successfully

   HISTORY:
        JonN        12-Aug-1991     Created

\**********************************************************/

NEW_LM_OBJ::NEW_LM_OBJ( BOOL fValidate )
    : LM_OBJ_BASE( fValidate ),
      _pBuf( NULL )
{
    if ( QueryError() )
        return;
}

/*******************************************************************

    NAME:       NEW_LM_OBJ::~NEW_LM_OBJ

    SYNOPSIS:   destrcutor

    NOTES:      free up the memory

    HISTORY:
                terryk  17-Oct-91       Created

********************************************************************/

NEW_LM_OBJ::~NEW_LM_OBJ()
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::GetInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::GetInfo()
{
    if ( IsUnconstructed() || IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeValid();

    APIERR err = I_GetInfo();
    if (err != NERR_Success)
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteInfo()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_WriteInfo();
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::CreateNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::CreateNew()
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_CreateNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteNew()
{
    if ( !IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    APIERR err = I_WriteNew();
    if (err != NERR_Success)
        return err;

    MakeValid(); // the object is no longer new

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::Write

    SYNOPSIS:   This method calls either WriteInfo() or WriteNew()
                depending on the state of the object.

    HISTORY:
        JonN        13-Sep-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::Write()
{
    if ( IsNew() )
        return WriteNew();
    else
        return WriteInfo();
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::Delete( UINT uiForce )
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_Delete( uiForce );
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::ChangeToNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::ChangeToNew()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_ChangeToNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}


/**********************************************************\

    NAME:       NEW_LM_OBJ::QueryName

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

const TCHAR * NEW_LM_OBJ::QueryName() const
{
    UIASSERT( FALSE ); // not valid unless redefined
    return NULL;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_GetInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_GetInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_CreateNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_CreateNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_ChangeToNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_ChangeToNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Copies object, including base API buffer

    NOTES:      W_CloneFrom should copy all component objects at each
                level.  Every level which has component objects should
                define W_CloneFrom.  Every W_CloneFrom should start with a call
                to the predecessor W_CloneFrom.

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &
        terryk      14-Oct-1991     Use NT NetApi to allocate a new
                                    buffer. It may not work for some
                                    instance. BUGBUG
        JonN        31-Oct-1991     Enabled

\**********************************************************/

APIERR NEW_LM_OBJ::W_CloneFrom( const NEW_LM_OBJ & lmobj )
{
    UINT uBufSize = lmobj.QueryBufferSize();
    APIERR err = ResizeBuffer( uBufSize );
    if ( err != NERR_Success )
        return err;

    if ( uBufSize > 0 )
    {
        UIASSERT( _pBuf != NULL );
        ::memcpyf( (TCHAR *)_pBuf,
                   (const TCHAR *)lmobj.QueryBufferPtr(),
                   uBufSize );
    }

    _usState = lmobj._usState;

    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CreateNew

    SYNOPSIS:   initializes fields with accessors

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines the
                default values for its own private data members.  This
                is done in W_CreateNew(), where each level calls up to
                its parent.  Every level which has component objects should
                define W_CreateNew.  Every W_CreateNew should start with a call
                to the predecessor W_CreateNew.

    CAVEATS:    Note that NEW_LM_OBJ::W_CreateNew copies the API buffer but
                does not initialize the fields in the API buffer.  These
                fields need only be initialized if they have no accessors.
                Only the I_CreateNew method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_CreateNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_ChangeToNew

    SYNOPSIS:   Transforms object from VALID to NEW

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines
                whether its shadow members take different forms between
                the NEW and VALID states.  W_ChangeToNew changes the
                shadow members, but not the API buffer, from VALID to NEW.
                Only levels with component objects which are different
                between VALID and NEW must define W_ChangeToNew.  Every
                W_ChangeToNew should start with a call to the predecessor
                W_ChangeToNew.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_ChangeToNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::FixupPointer

    SYNOPSIS:   Fixes pointer inside a copied API buffer

    NOTES:      This is a utility routine for the use of CloneFrom() variants.
                When an API buffer is CloneFrom'd, some of its internal
                components may be pointers to strings inside the buffer.
                These pointers should be fixed-up to point into the new
                buffer, otherwise the cloned NEW_LM_OBJ points to a
                string in the old NEW_LM_OBJ and may break it the old
                one is freed.  Only pointers pointing within the old
                buffer need be fixed, NULL pointers  and pointers not
                pointing withing the old buffer can be left alone.
                Pointers which have a shadow NLS_STR can be left
                alone, Query() will use the NLS_STR and the API buffer
                will be fixed by the next WriteInfo/WriteNew.

    ENTRY:      *ppchar is the pointer to be fixed up.
                bufOld is the API buffer for the old NEW_LM_OBJ
                bufNew is the API buffer for the new NEW_LM_OBJ

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

                Also note that you must walk on eggshells to do the
                pointer addition/subtraction without C6 leaving off the
                upper word.

                The pointer is not necessarily either NULL or within the old
                buffer.  In some cases, an obscure pointer may or may
                not point within the buffer, depending on whether the
                object was created with GetInfo or CreateNew.  We must
                handle this case by leaving alone any pointers which are
                non-NULL but point outside the buffer.

                Also note that this will not work for pointers in API
                buffers other than the default API buffer.

    HISTORY:
        JonN        04-Aug-1991     Created

\**********************************************************/

VOID NEW_LM_OBJ::FixupPointer( TCHAR ** ppchar,
                   const NEW_LM_OBJ * plmobjOld
                 )
{
    ULONG_PTR ulCurrPtr = (ULONG_PTR)(*ppchar);

    // return if null pointer
    if ( ulCurrPtr == 0 )
        return;

    ULONG_PTR ulOld = (ULONG_PTR)plmobjOld->QueryBufferPtr();

    // the object size should never be equal to 0

    UIASSERT( plmobjOld->QueryBufferSize() != 0 );

    // return if not pointing in old buffer
    if  (    ( ulCurrPtr < ulOld )
          || ( ulCurrPtr >= ulOld + ((UINT)plmobjOld->QueryBufferSize()) )
        )
    {
        return;
    }

    // do not assume 2's complement math -- avoid overflow
    ULONG_PTR ulNew = (ULONG_PTR)QueryBufferPtr();
    if ( ulOld >= ulNew )
        *ppchar = (TCHAR *)(ulCurrPtr - (ulOld - ulNew));
    else
        *ppchar = (TCHAR *)(ulCurrPtr + (ulNew - ulOld));

}


/*******************************************************************

    NAME:       NEW_LM_OBJ::QueryBufferSize

    SYNOPSIS:   query the buffer size

    HISTORY:
                jonn    31-Oct-91       Created

********************************************************************/

UINT NEW_LM_OBJ::QueryBufferSize() const
{
    UINT uSize = 0;
    APIERR err = NERR_Success;
    if (_pBuf != NULL)
        err = ::MNetApiBufferSize( _pBuf, &uSize );
    if ( err != NERR_Success )
    {
        DBGEOL( "Failure in NEW_LM_OBJ::QueryBufferSize() " << err );
        ASSERT( FALSE );
        return 0;
    }
    return uSize;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::SetBufferPtr

    SYNOPSIS:   set the buffer pointer

    ENTRY:      TCHAR *pBuffer - new pointer

    NOTES:      remove the old buffer if necessary

    HISTORY:
                terryk  16-Oct-91       Created

********************************************************************/

VOID NEW_LM_OBJ::SetBufferPtr( BYTE * pBuffer )
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );

    _pBuf = pBuffer;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ResizeBuffer

    SYNOPSIS:   resize the current buffer and copy the old content to
                the new one

    ENTRY:      UINT cbSize - new buffer size

    RETURNS:    APIERR for buffer creation error

    NOTES:      MNetApiBufferAlloc returns NULL when asked to allocate a
                buffer of length 0.  To get around this, we allocate a
                buffer of length 1 where the requested size is 0.

    HISTORY:
                terryk  14-Oct-91       Created
                jonn    31-Oct-91       Enabled
                jonn    31-Oct-91       Allocate 1 where 0 requested

********************************************************************/

APIERR NEW_LM_OBJ::ResizeBuffer( UINT cbNewRequestedSize )
{
    if ( cbNewRequestedSize == 0 )
        cbNewRequestedSize = 1;

    BYTE * pTemp = ::MNetApiBufferAlloc( cbNewRequestedSize );
    if ( pTemp == NULL )
        return ( ERROR_NOT_ENOUGH_MEMORY );

    if ( _pBuf != NULL )
    {
        UINT uMinSize = QueryBufferSize();
        if ( uMinSize > cbNewRequestedSize )
            uMinSize = cbNewRequestedSize;

        ::memcpyf((TCHAR *) pTemp, (TCHAR *) _pBuf, uMinSize );
    }

    SetBufferPtr( pTemp );

    return NERR_Success;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ClearBuffer

    SYNOPSIS:   Set all bits in the current buffer to 0

    RETURNS:    APIERR for error

    HISTORY:
                jonn    08-May-92       Created

********************************************************************/

APIERR NEW_LM_OBJ::ClearBuffer()
{
    BYTE * pTemp = QueryBufferPtr();
    if ( pTemp == NULL )
    {
        UIASSERT( FALSE );
    }
    else
    {
        ::memsetf( (TCHAR *) pTemp, 0, QueryBufferSize() );
    }

    return NERR_Success;
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::LOC_LM_OBJ

   SYNOPSIS:    constructors

   NOTES:       The LOCATION object must construct successfully

   HISTORY:
        JonN        07-Aug-1991     Created

\**********************************************************/

VOID LOC_LM_OBJ::CtAux( VOID )
{
    if ( QueryError() )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
        ReportError( err );
}

LOC_LM_OBJ::LOC_LM_OBJ( const TCHAR * pszLocation, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(pszLocation)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( enum LOCATION_TYPE loctype, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loctype)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( const LOCATION & loc, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loc)
{
    CtAux();
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::W_CloneFrom

   SYNOPSIS:    Copies object

   NOTES:       see NEW_LM_OBJ::W_CloneFrom

   HISTORY:
        JonN        26-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &

\**********************************************************/

APIERR LOC_LM_OBJ::W_CloneFrom( const LOC_LM_OBJ & lmobj )
{
    APIERR err = NEW_LM_OBJ::W_CloneFrom( lmobj );
    if ( err != NERR_Success )
        return err;

    err = _loc.Set( lmobj._loc );
    if ( err != NERR_Success )
    {
        DBGEOL( "LOC_LM_OBJ::W_CloneFrom failed on LOCATION copy " << err );
        return err;
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmodom.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
 *  lmodom.cxx
 *
 *  HISTORY:
 *      RustanL         08-Jan-1991     Created
 *      beng            11-Feb-1991     Uses lmui.hxx
 *      rustanl         06-Mar-1991     Changed PSZ to const TCHAR * in ct
 *      ChuckC          3/6/91          Code Review changes from 2/28/91
 *                                      (chuckc,johnl,rustanl,annmc,jonshu)
 *      rustanl         23-Mar-1991     Added IsLANServerDomain method
 *      terryk          10-Oct-1991     type changes for NT
 *      KeithMo         10/8/91         Now includes LMOBJP.HXX.
 *      terryk          17-Oct-1991     WIN 32 conversion
 *      terryk          21-Oct-1991     cast _pBuffer to TCHAR *
 *      KeithMo         31-Aug-1992     Added ctor form with server name.
 *      JonN            14-Oct-1993     Now tries to call NetGetAnyDCName
 *      JonN            18-May-1998     Replaced NetGetAnyDCName with DsGetDCName
 *
 */

/*
 *  When searching for any DC, we first try NetGetAnyDCName, then if that
 *  fails, we try I_NetGetDCList.  NetGetAnyDCName only works reliably
 *  when remoted to a machine which trusts the domain in question,
 *  while I_NetGetDCList does not like to be remoted at all (it is a
 *  Bowser internal routine which only returns DCs on the same transport
 *  as the connection).
 *
 * JonN 5/18/98: NetGetAnyDCName(servername) has the following problem
 * associated with networks which do not route NETBIOS throughout:
 * Suppose we call NetGetAnyDCName and specify a servername as well as a
 * domainname.  NetGetAnyDCName will ask the target server to identify a DC
 * it can reach in the target domain.  This DC must share some transport with
 * the target server, but it does not necessarily share any transports with
 * the local machine.
 *
 * On the other hand, if we don't pass the servername, NetGetAnyDCName will fail
 * for workstations in a domain other than the target domain.  For these and other
 * reasons, I am replacing the call to NetGetAnyDCName with a call to DsGetDCName.
 *
 * SPECIAL CAUTION: with these changes, the pszServer parameter
 * no longer has any effect!
 */

/*
 * BUGBUG - this module needs cleanup. the methods QueryDC and QueryPDC
 * both return the same the same thing, which is confusing.
 *
 * THe DOMAIN_WITH_DC_CACHE subclass has been added in a manner to
 * minimize impact on existing code. its functionality should be folded
 * into the DOMAIN class for a cleaner class organization.
 */

#include "pchlmobj.hxx"  // Precompiled header
#include <dsgetdc.h> // DsGetDCName


/**********************************************************\

   NAME:       DOMAIN::DOMAIN

   SYNOPSIS:   constructor for the domain class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created
        DavidHov        6/4/92          Fixed UNICODE "sizeof" problem
                                        in call to ::strncpyf().
        KeithMo         31-Aug-1992     Moved "guts" to CtAux, added
                                        ctor form with server name.

\**********************************************************/

DOMAIN::DOMAIN( const TCHAR * pchDomain,
                BOOL fBackupDCsOK)
  : _fBackupDCsOK(fBackupDCsOK)
{
    CtAux( NULL, pchDomain );

}  // DOMAIN::DOMAIN

// SPECIAL CAUTION: the pszServer parameter no longer has any effect!
DOMAIN::DOMAIN( const TCHAR * pszServer,
                const TCHAR * pszDomain,
                BOOL fBackupDCsOK )
  : _fBackupDCsOK( fBackupDCsOK )
{
    CtAux( pszServer, pszDomain );

}  // DOMAIN::DOMAIN

/**********************************************************\

   NAME:       DOMAIN::~DOMAIN

   SYNOPSIS:   destructor for the domain class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created

\**********************************************************/

DOMAIN::~DOMAIN()
{
}  // DOMAIN::~DOMAIN


/**********************************************************\

   NAME:        DOMAIN::CtAux

   SYNOPSIS:    Constructor helper.

   ENTRY:       pszServer               - Target server (may be NULL).

                pszDomain               - Target domain (may be NULL).

   EXIT:        Private data members initialized.

   HISTORY:
        KeithMo         31-Aug-1992     Created from old ctor.

\**********************************************************/
VOID DOMAIN::CtAux( const TCHAR * pszServer,
                    const TCHAR * pszDomain )
{
    //
    //  Mark the object as unconstructed until proven otherwise.
    //

    MakeUnconstructed();

    //
    //  Blank out our private strings.
    //

    ::memsetf( _szDomain, 0, sizeof(_szDomain) );
    ::memsetf( _szDC,     0, sizeof(_szDC)     );
    ::memsetf( _szServer, 0, sizeof(_szServer) );

    //
    //  If a server name was specified, copy it over.
    //

    if( pszServer != NULL )
    {
        ::strncpyf( _szServer,
                    pszServer,
                    ( sizeof(_szServer) - 1 ) / sizeof(TCHAR) );
    }

    //
    //  If a domain name was specified, copy it over.
    //

    if( pszDomain != NULL )
    {
        ::strncpyf( _szDomain,
                    pszDomain,
                    ( sizeof(_szDomain) - 1 ) / sizeof(TCHAR) );
    }

    //
    //  Construction successful!
    //

    MakeConstructed();

}  // DOMAIN::CtAux


/**********************************************************\

   NAME:       DOMAIN::QueryName

   SYNOPSIS:   query the domain name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created

\**********************************************************/

const TCHAR * DOMAIN::QueryName( VOID ) const
{
    if ( IsUnconstructed())
    {
        DBGEOL(   "DOMAIN::QueryName(): "
               << "Operation applied to unconstructed object" );
        ASSERT( FALSE );
        return NULL;
    }

    return _szDomain;

}  // DOMAIN::QueryName


/**********************************************************\

   NAME:       DOMAIN::GetInfo

   SYNOPSIS:   get information about the domain

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created
        CongpaY         18-Aug-1992     Add GetAnyDC.

\**********************************************************/

APIERR DOMAIN::GetInfo( VOID )
{
    if ( IsUnconstructed())
    {
        DBGEOL(   "DOMAIN::GetInfo(): "
               << "Operation applied to unconstructed object" );
        ASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    // Validate the name
    if (ValidateName() != NERR_Success)
    {
        return (ERROR_INVALID_PARAMETER) ;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err;
    NLS_STR nlsDC;
    if ((err = nlsDC.QueryError()) != NERR_Success)
        return err;

    if (_fBackupDCsOK)
    {
        err = DOMAIN::GetAnyValidDC(_szServer,
                               _szDomain,
                               &nlsDC);
        if (err != NERR_Success)
            return err;

        strcpy(_szDC, nlsDC);
    }
    else
    {
        TCHAR * pszPDC = NULL;
        err = ::MNetGetDCName( _szServer,
                               _szDomain,
                               (BYTE **)&pszPDC );
        if (err != NERR_Success)
            return err;
        ::strcpyf(_szDC, pszPDC);
        ::MNetApiBufferFree( (BYTE **)&pszPDC);
    }

    MakeValid();

    return err;

}  // DOMAIN::GetInfo


/**********************************************************\

   NAME:       DOMAIN::WriteInfo

   SYNOPSIS:   write information to domain

   ENTRY:

   EXIT:

   NOTES:      not supported

   HISTORY:
        RustanL         08-Jan-1991     Created

\**********************************************************/

APIERR DOMAIN::WriteInfo( VOID )
{
    return ERROR_NOT_SUPPORTED;

}  // DOMAIN::WriteInfo


/**********************************************************\

   NAME:       DOMAIN::QueryPDC

   SYNOPSIS:   query pointer of the domain string

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created
        CongpaY         18-Aug-1992     Change _pszPDC to _szDC.

\**********************************************************/

const TCHAR * DOMAIN::QueryPDC( VOID ) const
{
    if ( IsUnconstructed() || IsInvalid())
    {
        DBGEOL(   "DOMAIN::QueryPdc(): "
               << "Operation applied to unconstructed or invalid object" );
        ASSERT( FALSE );
        return NULL;
    }

    return _szDC;

}  // DOMAIN::QueryPDC


/**********************************************************\

   NAME:       DOMAIN::QueryAnyDC

   SYNOPSIS:   query pointer of the domain string

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        KeithMo         31-Aug-1992     Created.

\**********************************************************/
const TCHAR * DOMAIN::QueryAnyDC( VOID ) const
{
    //
    //  CODEWORK:  Should we ASSERT if !fBackupDCsOK??
    //

    return QueryPDC();

}  // DOMAIN::QueryAnyDC



/**********************************************************\

   NAME:       DOMAIN::GetAnyValidDC

   SYNOPSIS:   return a PDC or BDC which is known to be available.

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   EXIT:       pnlsDC stores a BDC name if there is one available,
               otherwise it stores the PDC name.

   NOTES:      returns error if there isn't any DC available.

   HISTORY:
        thomaspa        14-Oct-1992     Created

\**********************************************************/
APIERR DOMAIN::GetAnyValidDC(const TCHAR * pszServer,
                             const TCHAR * pszDomain,
                             NLS_STR * pnlsDC)
{
    return DOMAIN::GetAnyDCWorker(pszServer,
                                  pszDomain,
                                  pnlsDC,
                                  TRUE);
}



/**********************************************************\

   NAME:       DOMAIN::GetAnyDC

   SYNOPSIS:   return a PDC or BDC without validation

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   EXIT:       pnlsDC stores a BDC name if there is one available,
               otherwise it stores the PDC name.

   NOTES:      returns error if there isn't any DC available.

   HISTORY:
        thomaspa        14-Oct-1992     Created

\**********************************************************/
APIERR DOMAIN::GetAnyDC(const TCHAR * pszServer,
                             const TCHAR * pszDomain,
                             NLS_STR * pnlsDC)
{
    return DOMAIN::GetAnyDCWorker(pszServer,
                                  pszDomain,
                                  pnlsDC,
                                  FALSE);
}


/**********************************************************\

   NAME:       DOMAIN::GetAnyDCWorker

   SYNOPSIS:   return a PDC or BDC.

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   EXIT:       pnlsDC stores a BDC name if there is one available,
               otherwise it stores the PDC name.

   NOTES:      returns error if there isn't any DC available.

   HISTORY:
        CongpaY         18-Aug-1992     Created
        ChuckC          30-Sep-1992     Fixed to correctly return PDCs
        Thomaspa        14-Oct-1992     Made into worker function, added
                                        validation
        JonN            20-Sep-1993     Now tries NetGetAnyDCName before
                                        resorting to I_NetGetDCList.
        JonN            15-May-1998     Now uses DsGetDCName

\**********************************************************/

APIERR DOMAIN::GetAnyDCWorker( const TCHAR * pszServer,
                               const TCHAR * pszDomain,
                               NLS_STR     * pnlsDC,
                               BOOL          fValidate)
{
    ASSERT( pnlsDC != NULL && pnlsDC->QueryError() == NERR_Success );

    BOOL fFound = FALSE;
    ULONG cDC;
    PUNICODE_STRING punistrDCList = NULL;
    PDOMAIN_CONTROLLER_INFO pdcinfo = NULL;
    APIERR err = NERR_Success;

    if( pszServer && *pszServer == TCH('\0') )
    {
        pszServer = NULL;
    }

    //
    //  Passing in NULL to I_NetGetDCList will cause it to access violate
    //
    if( (pszDomain == NULL) ||
        (*pszDomain == TCH('\0')) )
    {
        DBGEOL( "DOMAIN::GetAnyDCWorker - NULL or empty domain name" );
        return ERROR_INVALID_PARAMETER ;
    }

    /*
     *  First try DsGetDCName
     */

    do {   // false loop

        //
        // If the fValidate flag is set, first try DsGetDCName without
        // DS_FORCE_RECOVERY.  If validation then fails, retry with DS_FORCE_RECOVERY.
        //
        ULONG flags = DS_IS_FLAT_NAME | DS_RETURN_FLAT_NAME;
        if (fValidate)
        {
            // note that we ignore pszServer
            err = (APIERR) DsGetDcNameW(
                NULL,      // IN LPCWSTR ComputerName OPTIONAL,
                pszDomain, // IN LPCWSTR DomainName OPTIONAL,
                NULL,      // IN GUID *DomainGuid OPTIONAL,
                NULL,      // IN LPCWSTR SiteName OPTIONAL,
                flags,     // IN ULONG Flags,
                &pdcinfo ); // OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
            if ( NERR_Success == err )
            {
                if (   NULL == pdcinfo
                    || NULL == pdcinfo->DomainControllerName
                    || TEXT('\0') == pdcinfo->DomainControllerName[0] )
                {
                    ASSERT(FALSE);
                    break;
                }
                if ( DOMAIN::IsValidDC( pdcinfo->DomainControllerName, pszDomain ) )
                {
                    if (   (err = pnlsDC->CopyFrom( pdcinfo->DomainControllerName )) != NERR_Success
                       )
                    {
                        DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                               << "\", \"" << pszDomain
                               << "\" ), CopyFrom error " << err );
                        break;
                    }
                    fFound = TRUE;
                    break;
                }
            }
        } // if (fValidate)

        flags |= DS_FORCE_REDISCOVERY;

        // note that we ignore pszServer
        err = (APIERR) DsGetDcNameW(
            NULL,      // IN LPCWSTR ComputerName OPTIONAL,
            pszDomain, // IN LPCWSTR DomainName OPTIONAL,
            NULL,      // IN GUID *DomainGuid OPTIONAL,
            NULL,      // IN LPCWSTR SiteName OPTIONAL,
            flags,     // IN ULONG Flags,
            &pdcinfo ); // OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        if ( NERR_Success == err )
        {
            if (   NULL == pdcinfo
                || NULL == pdcinfo->DomainControllerName
                || TEXT('\0') == pdcinfo->DomainControllerName[0] )
            {
                ASSERT(FALSE);
                break;
            }
            if ( !fValidate || DOMAIN::IsValidDC( pdcinfo->DomainControllerName, pszDomain ) )
            {
                if (   (err = pnlsDC->CopyFrom( pdcinfo->DomainControllerName )) != NERR_Success
                   )
                {
                    DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                           << "\", \"" << pszDomain
                           << "\" ), CopyFrom error " << err );
                    break;
                }
                fFound = TRUE;
                break;
            }
        }

    } while (FALSE); // false loop

    /*
     *  Don't try I_NetGetDCList if DsGetDCName fails
     *  with ERROR_NO_LOGON_SERVERS
     *
     *  Don't ever try to call I_NetGetDCList remotely, it will only
     *  find DCs on the same transport.
     */

    do {        //error breakout.

        if ( fFound )
        {
            TRACEEOL( "DOMAIN::GetAnyDCWorker: skipping I_NetGetDCList" );
            break;
        }
        else if (err == ERROR_NO_LOGON_SERVERS)
        {
            /*
             *  Check whether the target machine is a DC of pszDomain
             */

            TRACEEOL( "DOMAIN::GetAnyDCWorker: checking local machine" );
            if ( DOMAIN::IsValidDC( pszServer, pszDomain ) )
            {
                err = pnlsDC->CopyFrom(pszServer);
                DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                       << "\", \"" << pszDomain
                       << "\" ) returns target machine" );
            }

            /*
             *  There is no point in continuing with I_NetGetDCList
             *  after DsGetDCName returns ERROR_NO_LOGON_SERVERS.
             */
            break;
        }



        if ((err = ::I_NetGetDCList(NULL,
                                    (LPTSTR) pszDomain,
                                    &cDC,
                                    &punistrDCList)) != NERR_Success)
        {
            DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                   << "\", \"" << pszDomain
                   << "\" ), I_NetGetDCList error " << err );
            break;
        }

        if( cDC == 0  ||  punistrDCList == NULL)
        {
            DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                   << "\", \"" << pszDomain
                   << "\" ), I_NetGetDCList found nothing " << err );
            err = NERR_DCNotFound;
            break;
        }

        // GetTickCount() is subject to the granularity of the clock
        // of the system on which it is run.  Shift right to make sure
        // we get an mix of odd and even numbers.

        ULONG i = (::GetTickCount() >> 5) % cDC ;

        ULONG j = i;
        do {
            if ( punistrDCList[j].Length == 0 )
            {
                continue;
            }
            err = pnlsDC -> MapCopyFrom(punistrDCList[j].Buffer,
                                            punistrDCList[j].Length);
            if ( err != NERR_Success )
            {
                DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                       << "\", \"" << pszDomain
                       << "\" ), MapCopyFrom error " << err );
                break;
            }

            if( fValidate &&
                !DOMAIN::IsValidDC( pnlsDC->QueryPch(), pszDomain ) )
            {
                //
                //  Whoops, not a valid DC in the target domain.
                //

                continue;
            }

            fFound = TRUE;
            break;

        } while ( (j = (j + 1) % cDC) != i );

        if ( !fFound )
        {
            err = NERR_DCNotFound;
            DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                   << "\", \"" << pszDomain
                   << "\" ), found nothing " << err );
            break;
        }

    } while (FALSE); // false loop

    if (punistrDCList)
        ::MNetApiBufferFree( (BYTE **)&punistrDCList);

    if (pdcinfo)
        ::NetApiBufferFree( pdcinfo );

    if (fFound)
    {
        TRACEEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                    << "\", \"" << pszDomain
                    << "\" ), found \"" << *pnlsDC << "\"" );
    }

    return err;

} //GetAnyDCWorker


/**********************************************************\

   NAME:       DOMAIN::IsValidDC

   SYNOPSIS:   Determines if the specified server is the Primary
               or a Backup in the the specified domain.

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   RETURNS:    BOOL     - TRUE  if the server is the Primary or
                                a Backup in the domain, and the
                                server was indeed active at some
                                point during this method.
                          FALSE if the server is not available, or
                                is not a member of the domain.

   NOTES:      This is a static method.

   HISTORY:
        KeithMo         12-Jan-1993     Created.

\**********************************************************/

BOOL DOMAIN::IsValidDC( const TCHAR * pszServer,
                        const TCHAR * pszDomain )
{
    BOOL fIsValid = TRUE;       // until proven otherwise...

    //
    //  Establish a NULL session to the target server.
    //

    API_SESSION apisess( pszServer );

    APIERR err = apisess.QueryError();

    if( err == NERR_Success )
    {
        //
        //  NULL session established.  Validate domain membership.
        //

        WKSTA_10 wksta( pszServer );

        err = wksta.GetInfo();

        if( ( err == NERR_Success ) &&
            ::I_MNetComputerNameCompare( pszDomain, wksta.QueryWkstaDomain() ) )
        {
            //
            //  Stale data, DC is no longer a domain member.
            //

            fIsValid = FALSE;
        }
    }

    if( fIsValid && ( err == NERR_Success ) )
    {
        //
        //  DC is a member of the target domain.  Now validate
        //  domain role (Primary or Backup).
        //

        LSA_POLICY policy( pszServer, POLICY_VIEW_LOCAL_INFORMATION );

        LSA_ACCT_DOM_INFO_MEM    lsaadim;
        LSA_PRIMARY_DOM_INFO_MEM lsaprim;

        //
        //  Verify construction.
        //

        err = policy.QueryError();
        err = err ? err : lsaadim.QueryError();
        err = err ? err : lsaprim.QueryError();

        //
        //  Query the primary & account domains.
        //

        err = err ? err : policy.GetAccountDomain( &lsaadim );
        err = err ? err : policy.GetPrimaryDomain( &lsaprim );

        if( err == NERR_Success )
        {
            //
            //  The DC is a Primary or Backup if the account & primary
            //  PSIDs are non-NULL and equal.
            //

            if( ( lsaadim.QueryPSID() == NULL ) ||
                ( lsaprim.QueryPSID() == NULL ) ||
                !EqualSid( lsaadim.QueryPSID(), lsaprim.QueryPSID() ) )
            {
                fIsValid = FALSE;
            }
        }
    }

    return fIsValid && ( err == NERR_Success );

}   // DOMAIN::IsValidDC


/**********************************************************\

   NAME:       DOMAIN::ValidateName

   SYNOPSIS:   validate the domain name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
           rustanl     23-Mar-1991     Created

\**********************************************************/

APIERR DOMAIN::ValidateName()
{
    /*
     * null case is invalid
     */
    if (_szDomain[0] == TCH('\0'))
        return (ERROR_INVALID_PARAMETER) ;

    /*
     * else insist on valid domain name
     */
    if (::I_MNetNameValidate(NULL, _szDomain, NAMETYPE_DOMAIN, 0L)
        != NERR_Success)
    {
        return (ERROR_INVALID_PARAMETER) ;
    }

    return (NERR_Success) ;
}


/*
 * defines and macros for DC cache manipulation
 */

#define DC_CACHE_EXPIRY 180000
#define DC_CACHE_SIZE   8
#define DC_CACHE_ENTRY_EXPIRED(t_cache, t_current) \
    ( (t_cache == 0) || \
      (t_current < t_cache) || \
      ((t_current - t_cache) > DC_CACHE_EXPIRY) )

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE

   SYNOPSIS:   constructor for the domain with DC cache class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE( const TCHAR * pchDomain,
                BOOL fBackupDCsOK)
  : DOMAIN(pchDomain, fBackupDCsOK)
{
    ;  // nothing more to do
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE

   SYNOPSIS:   constructor for the domain with DC cache class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

// SPECIAL CAUTION: the pszServer parameter no longer has any effect!
DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE( const TCHAR * pszServer,
                                const TCHAR * pszDomain,
                                BOOL fBackupDCsOK )
  : DOMAIN( pszServer, pszDomain, fBackupDCsOK )
{
    ;  // nothing more to do
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::~DOMAIN_WITH_DC_CACHE

   SYNOPSIS:   destructor for the domain with DC cache class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

DOMAIN_WITH_DC_CACHE::~DOMAIN_WITH_DC_CACHE()
{
    ;  // nothing more to do
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetInfo

   SYNOPSIS:   the standard GetInfo method.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetInfo( VOID )
{
    if ( IsUnconstructed())
    {
        DBGEOL(   "DOMAIN_WITH_DC_CACHE::GetInfo(): "
               << "Operation applied to unconstructed object" );
        ASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    // Validate the name
    if (ValidateName() != NERR_Success)
    {
        return (ERROR_INVALID_PARAMETER) ;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err;
    NLS_STR nlsDC;
    if ((err = nlsDC.QueryError()) != NERR_Success)
        return err;

    if (_fBackupDCsOK)
    {
        if ( (err = DOMAIN_WITH_DC_CACHE::GetAnyValidDC(_szServer,
                                                        _szDomain,
                                                        &nlsDC) ) )
        {
            return err;
        }

        strcpy(_szDC, nlsDC);
    }
    else
    {
        TCHAR * pszPDC = NULL;

        if (pszPDC = (TCHAR *)FindDcCache(_pPrimaryDcCacheTable,_szDomain))
            ::strcpyf(_szDC, pszPDC);
        else
        {
            err = ::MNetGetDCName( _szServer,
                                   _szDomain,
                                   (BYTE **)&pszPDC );
            if ( err != NERR_Success )
                return err;

            ::strcpyf(_szDC, pszPDC);
            ::MNetApiBufferFree( (BYTE **)&pszPDC);
            (void) AddDcCache( &_pPrimaryDcCacheTable,
                               _szDomain,
                               _szDC) ;
        }

    }

    MakeValid();
    return err;
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetAnyDC

   SYNOPSIS:   as DOMAIN::GetAnyDC, except it uses the cache

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Thomaspa        14-Oct-1992     Created
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetAnyDC(const TCHAR * pszServer,
                                      const TCHAR * pszDomain,
                                      NLS_STR * pnlsDC)
{
    return DOMAIN_WITH_DC_CACHE::GetAnyDCWorker( pszServer,
                                                 pszDomain,
                                                 pnlsDC,
                                                 FALSE );
}




/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetAnyValidDC

   SYNOPSIS:   as DOMAIN::GetAnyValidDC, except it uses the cache

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Thomaspa        14-Oct-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetAnyValidDC(const TCHAR * pszServer,
                                      const TCHAR * pszDomain,
                                      NLS_STR * pnlsDC)
{
    return DOMAIN_WITH_DC_CACHE::GetAnyDCWorker( pszServer,
                                                 pszDomain,
                                                 pnlsDC,
                                                 TRUE );
}



/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetAnyDCWorker

   SYNOPSIS:   as DOMAIN::GetAnyDCWorker, except it uses the cache

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created
        Thomaspa        14-Oct-1992     Made into Worker

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetAnyDCWorker(const TCHAR * pszServer,
                                      const TCHAR * pszDomain,
                                      NLS_STR * pnlsDC,
                                      BOOL fValidate)
{
    APIERR err ;
    const TCHAR *pszDC ;

    if (pszDC = FindDcCache(_pAnyDcCacheTable,
                            pszDomain))
    {
        err = pnlsDC->CopyFrom(pszDC) ;
    }
    else
    {
        err = DOMAIN::GetAnyDCWorker(pszServer, pszDomain, pnlsDC, fValidate) ;
        if (err == NERR_Success)
        {
            (void) AddDcCache( &_pAnyDcCacheTable,
                               pszDomain,
                               pnlsDC->QueryPch()) ;
        }
    }

    return err ;
}

#if 0
// Not currently used
/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::FreeDcCache

   SYNOPSIS:   deletes the appropriate Cache

   ENTRY:      ppDcCacheEntry is address of pointer to table to look at.

   EXIT:       the table is freed and contents of ppDcCacheEntry cleared.

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::FreeDcCache(DC_CACHE_ENTRY **ppDcCacheEntry)
{
    if (!ppDcCacheEntry)
        return(ERROR_INVALID_PARAMETER) ;

    ::GlobalFree ( (HGLOBAL) *ppDcCacheEntry) ;
    *ppDcCacheEntry = NULL ;

    return NERR_Success ;
}
#endif

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::ClearDcCache

   SYNOPSIS:   clears the data in the DC cache

   ENTRY:      pDcCacheEntry is pointer to cache table

   EXIT:       all entries in table are null-ed out

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::ClearDcCache(DC_CACHE_ENTRY *pDcCacheEntry)
{
    // nothing to clear
    if (!pDcCacheEntry)
        return(ERROR_INVALID_PARAMETER) ;

    // loop thru and init
    int i ;
    for (i = 0; i < DC_CACHE_SIZE; i++, pDcCacheEntry++)
    {
        pDcCacheEntry->szDomain[0] = TCH('\0') ;
        pDcCacheEntry->szServer[0] = TCH('\0') ;
        pDcCacheEntry->dwTickCount = 0 ;
    }

    return(NERR_Success) ;
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::AddDcCache

   SYNOPSIS:   add a entry to the cache. will allocate the
               cache table if need.

   ENTRY:      ppDcCacheEntry is address of pointer to table.
               of the table is not yet allocated (NULL), we will allocate.
               pszDomain and pszDC are the entries to enter in the cache.

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::AddDcCache(DC_CACHE_ENTRY **ppDcCacheEntry,
                  const TCHAR *pszDomain,
                  const TCHAR *pszDC)
{
    // if weird parameters, just ignore. they dont get in cache
    if (!ppDcCacheEntry)
        return ERROR_INVALID_PARAMETER ;
    if (!pszDC || ::strlenf(pszDC) > MAX_PATH)
        return ERROR_INVALID_PARAMETER ;
    if (!pszDomain || ::strlenf(pszDomain) > DNLEN)
        return ERROR_INVALID_PARAMETER ;

    APIERR err = EnterCriticalSection() ;
    if ( err )
        return err ;

    DC_CACHE_ENTRY *pDcCacheEntry = *ppDcCacheEntry ;

    // allocate if need. note its OK not to free this. there is
    // one per process, we can let the system cleanup when
    // the process exits.
    if (pDcCacheEntry == NULL)
    {
        if ( !(pDcCacheEntry = (DC_CACHE_ENTRY *) ::GlobalAlloc( GPTR,
                                    sizeof(DC_CACHE_ENTRY)*DC_CACHE_SIZE) ) )
        {
            LeaveCriticalSection() ;
            return ERROR_NOT_ENOUGH_MEMORY ;
        }
        (void) ClearDcCache(pDcCacheEntry) ;
        *ppDcCacheEntry = pDcCacheEntry ;
    }

    DWORD dwCurrentTicks = ::GetTickCount() ;

    // go thru looking for free entry
    int i ;
    for (i = 0; i < DC_CACHE_SIZE; i++, pDcCacheEntry++)
    {
        // if domain is empty string or time is expired,
        // we can reuse this entry.
        if ( (pDcCacheEntry->szDomain[0] == TCH('\0')) ||
             DC_CACHE_ENTRY_EXPIRED(pDcCacheEntry->dwTickCount,
                                    dwCurrentTicks) )
        {
            // found either an empty or expired entry. lets use it.
            ::strcpyf( pDcCacheEntry->szDomain, pszDomain ) ;
            ::strcpyf( pDcCacheEntry->szServer , pszDC ) ;
            pDcCacheEntry->dwTickCount = dwCurrentTicks ;

            // we're done
            LeaveCriticalSection() ;
            return NERR_Success ;
        }
    }

    // else no free entry. note this is never reported
    // to the user. if this fails, we just dont get the
    // benefits of a cache.
    LeaveCriticalSection() ;
    return(ERROR_NOT_ENOUGH_MEMORY) ;
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::FindDcCache

   SYNOPSIS:   find a domain the the passed in cache table

   ENTRY:      pDcCacheEntry is pointer to cache.
               pszDomain is the domain whose DC/PDC we wish to lookup.

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

const TCHAR * DOMAIN_WITH_DC_CACHE::FindDcCache(
                        const DC_CACHE_ENTRY *pDcCacheEntry,
                        const TCHAR *pszDomain)
{
    // if weird parameters, just ignore.
    if (!pszDomain || !pszDomain[0])
        return NULL ;

    // if no cache, it aint found
    if (pDcCacheEntry == NULL)
        return NULL ;

    if ( EnterCriticalSection() )
        return NULL ;

    // go thru looking for the entry
    DWORD dwCurrentTicks = ::GetTickCount() ;
    int i ;
    for (i = 0; i < DC_CACHE_SIZE; i++, pDcCacheEntry++)
    {
        if ( !DC_CACHE_ENTRY_EXPIRED(pDcCacheEntry->dwTickCount,
                                     dwCurrentTicks) &&
             !::I_MNetComputerNameCompare( pDcCacheEntry->szDomain, pszDomain ) )
        {
            const TCHAR * pszServer = pDcCacheEntry->szServer ;
            LeaveCriticalSection() ;
            return  pszServer ;
        }
    }

    LeaveCriticalSection() ;

    // not found
    return NULL ;
}

/*******************************************************************

    NAME:       DOMAIN_WITH_DC_CACHE::EnterCriticalSection

    SYNOPSIS:   Locks the cache for lookup or change

    RETURNS:    NERR_Success if the cache was successfully locked

    NOTES:

    HISTORY:
        Johnl   13-Dec-1992     Created

********************************************************************/

APIERR DOMAIN_WITH_DC_CACHE::EnterCriticalSection( void )
{
    APIERR err = NERR_Success ;

    //
    //  Created semaphore protection for the cache table before we start
    //  using the cache
    //
    if ( DOMAIN_WITH_DC_CACHE::_hCacheSema4 == NULL )
    {
        if ( (DOMAIN_WITH_DC_CACHE::_hCacheSema4 = ::CreateSemaphore(
                                                       NULL,
                                                       1,
                                                       1,
                                                       NULL )) == NULL )
        {
            return ::GetLastError() ;
        }
    }

    switch ( WaitForSingleObject( DOMAIN_WITH_DC_CACHE::_hCacheSema4, INFINITE ) )
    {
    case 0:
        break ;

    default:
        err = ::GetLastError() ;
        break ;
    }

    return err ;
}

void DOMAIN_WITH_DC_CACHE::LeaveCriticalSection( void )
{
    REQUIRE( ReleaseSemaphore( DOMAIN_WITH_DC_CACHE::_hCacheSema4, 1, NULL ) ) ;
}


DC_CACHE_ENTRY * DOMAIN_WITH_DC_CACHE::_pAnyDcCacheTable = NULL ;

DC_CACHE_ENTRY * DOMAIN_WITH_DC_CACHE::_pPrimaryDcCacheTable = NULL ;

HANDLE DOMAIN_WITH_DC_CACHE::_hCacheSema4 = NULL ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmodev.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*  HISTORY:
 *      RustanL     07-Dec-1990     Created
 *      ChuckC      08-Jan-1991     Added more meat
 *      ChuckC      20-Jan-1991     Added ITER_DEVICE
 *      beng        11-Feb-1991     Uses lmui.hxx
 *      rustanl     06-Mar-1991     Change PSZ Connect param to const TCHAR *
 *      ChuckC      06-Mar-1991     Code Review changes from 2/28/91
 *                                  (chuckc,johnl,rustanl,annmc,jonshu)
 *      ChuckC      22-Mar-1991     Validation moves to GetInfo()
 *      ChuckC      27-Mar-1991     Code Review changes (chuckc,gregj,
 *                                  jonn,ericch)
 *      ChuckC      12-Apr-1991     Made pchAlias const (AliasToUNC)
 *      terryk      10-Oct-1991     type changes for NT
 *      KeithMo     10/8/91         Now includes LMOBJP.HXX.
 *      terryk      10/17/91        WIN 32 conversion
 *      terryk      10/21/91        WIN 32 conversion (part 2)
 *      terryk      10/29/91        add DEVICE2 object
 *      terryk      11/08/91        DEVICE2 code review changes
 *      terryk      11/18/91        change I_GetInfo to CallAPI
 *                                  change W_GetInfo to SetInfo
 *                                  change #ifndef WIN32 to #ifdef LAN_SERVER
 *      jonn        05/19/92        Added LMO_DEV_ALLDEVICES
 *
 *  CODEWORK - DEVICE and DEVICE2 are inconsistent in the way they
 *             handle deviceless connections. This module deserves
 *             serious surgery.
 */

#include "pchlmobj.hxx"  // Precompiled header



/************************* DEVICE *****************************************/


/**********************************************************\

   NAME:       DEVICE::DEVICE

   SYNOPSIS:   constructor for the device type

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

DEVICE::DEVICE( const TCHAR * pchName ) :
    _nlsDeviceName(pchName),
    _pBuf( NULL )
{
    /*
     * if parent not constructed bag out
     */
    if (IsUnconstructed())
        return ;

    /*
     * make sure string was alloced ok
     */
    if (_nlsDeviceName.QueryError() != NERR_Success)
    {
        MakeUnconstructed() ;
        return ;
    }

    /*
     * setup initial values
     * set both the device state (remote, unavail, etc. to error
     * initially. Ditto for the device type (disk, spool, etc).
     */
    _szServerName[0] = TCH('\0') ;
    _szRemoteName[0] = TCH('\0') ;
    _lmoDevState = LMO_DEV_BADSTATE ;
    _lmoDevType = LMO_DEV_ERROR ;
    _uStatus = USE_NETERR ;
    _uRemoteType = 0 ;

    /*
     * canonicalize name
     */
    _nlsDeviceName._strupr() ;

    MakeConstructed();
    return;
}


/**********************************************************\

   NAME:       DEVICE::~DEVICE

   SYNOPSIS:   destructor for the device class

   ENTRY:

   EXIT:

   NOTES:       nothing more to do

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

DEVICE::~DEVICE()
{
    ;
}


/**********************************************************\

   NAME:       DEVICE::QueryName

   SYNOPSIS:   return the device name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * DEVICE::QueryName( VOID ) const
{
    if (IsUnconstructed())
        return NULL ;

    return (_nlsDeviceName.QueryPch()) ;
}  // DEVICE::QueryName

/**********************************************************\

   NAME:       DEVICE::QueryServerName

   SYNOPSIS:   returns the server name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Johnl   14-Aug-1991     Created

\**********************************************************/

const TCHAR * DEVICE::QueryServer( VOID ) const
{
    if (IsUnconstructed())
        return NULL ;

    return (_szServerName) ;
}  // DEVICE::QueryServerName


/**********************************************************\

   NAME:       DEVICE::GetInfo

   SYNOPSIS:   get the information about the device

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        terryk      31-Oct-1991     Add CallAPI worker function

\**********************************************************/

APIERR DEVICE::GetInfo( VOID )
{
    /*
     * must be constructed
     */
    if (IsUnconstructed())
        return ERROR_GEN_FAILURE;

    /*
     * init to no such device and invalid. we will setup properly
     * if all goes well.
     */
    _lmoDevState = LMO_DEV_NOSUCH ;
    MakeInvalid() ;

    /*
     * special case the empty string
     */
    if (_nlsDeviceName.strlen() == 0)
    {
        _lmoDevState = LMO_DEV_UNKNOWN ;
        _lmoDevType = LMO_DEV_ANY ;
    }

    /*
     * validate the name. This has side effect
     * of setting the type, _lmoDevType.
     */
    if (ValidateName() != NERR_Success)
        return(ERROR_INVALID_PARAMETER);

    switch (_lmoDevType)
    {
        case LMO_DEV_DISK :
            if (CheckLocalDrive(_nlsDeviceName.QueryPch()) == NERR_Success)
                _lmoDevState = LMO_DEV_LOCAL ;     // its local
            break ;                                // to remote checking

        case LMO_DEV_PRINT :
            if (CheckLocalLpt(_nlsDeviceName.QueryPch()) == NERR_Success)
                _lmoDevState = LMO_DEV_LOCAL ;     // its local
            break ;                                // to remote checking

        case LMO_DEV_COMM :
            if (CheckLocalComm(_nlsDeviceName.QueryPch()) == NERR_Success)
                _lmoDevState = LMO_DEV_LOCAL ;     // its local
            break ;                                // to remote checking

        case LMO_DEV_ANY :
            _lmoDevState = LMO_DEV_UNKNOWN ;       // unknown since null dev
            break ;                                // to remote checking
        case LMO_DEV_ERROR :
        default:
            UIASSERT(!SZ("DEVICE object passed invalid dev type"));
            return NERR_InternalError;
    }

    /*
     * make it valid. we know it is either local or no such device
     */
    MakeValid();

    /*
     * here we call NET APIs to see if remote.
     * we declare a buffer big enuff for the API call.
     * CODEWORK - this assumption not good under NT.
     */
    APIERR Err = CallAPI( );
    switch( Err )
    {
    case NERR_Success:
        /*
         * if redirected, overwrite current value with Remote
         */
        _lmoDevState = LMO_DEV_REMOTE;
        break;

    case NERR_WkstaNotStarted:
    case NERR_NetNotStarted:
    case NERR_UseNotFound:
    default:
        /*
         * if NetUseGetInfo fails we see if it is an unavail drive.
         */
        INT sType ;
        if (CheckUnavailDevice(_nlsDeviceName.QueryPch(),
                               _szRemoteName,
                               &sType) == NERR_Success)
        {
            /* above would have set _szRemoteName, set the rest now */
            _lmoDevState = LMO_DEV_UNAVAIL ;
            _lmoDevType = ::NetTypeToLMOType(sType) ;
        }
        ::MNetApiBufferFree( &_pBuf );
        return(NERR_Success);
    }

    /*
     * only get here if have redirected device
     */
     SetInfo( );

    /* Copy the server name to _szServerName
     */
    TCHAR * pszEndServerName = ::strchrf( _szRemoteName+2, TCH('\\') ) ;
    UIASSERT( pszEndServerName != NULL ) ;
    ::strncpyf( _szServerName, _szRemoteName,
                (ULONG)(pszEndServerName - _szRemoteName)) ;
    *(_szServerName + (pszEndServerName-_szRemoteName)) = TCH('\0') ;
    UIASSERT( ::strlenf( _szServerName ) <= MAX_PATH ) ;
    ::MNetApiBufferFree( &_pBuf );

    return NERR_Success;

}  // DEVICE::GetInfo

/*******************************************************************

    NAME:       DEVICE::CallAPI

    SYNOPSIS:   worker function for GetInfo - get the info

    RETURNS:    APIERR - return MNetUseGetInfo error code

    HISTORY:
                terryk  13-Oct-1991     Created

********************************************************************/

APIERR DEVICE::CallAPI( )
{
    return ::MNetUseGetInfo( NULL, _nlsDeviceName.QueryPch(), 1, &_pBuf );
}

/*******************************************************************

    NAME:       DEVICE::SetInfo

    SYNOPSIS:   worker function for GetInfo - setup the internal
                variables

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE::SetInfo( )
{
    struct use_info_1 *pui1 = (struct use_info_1 *)_pBuf;

    _lmoDevType = ::NetTypeToLMOType ( pui1->ui1_asg_type ) ;
    _uStatus = (UINT)pui1->ui1_status;
    _uRemoteType = (UINT)pui1->ui1_asg_type ;
    ::strcpyf( _szRemoteName, pui1->ui1_remote );
}

/**********************************************************\

   NAME:       DEVICE::WriteInfo

   SYNOPSIS:   Write the device information

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

APIERR DEVICE::WriteInfo( VOID )
{
    UIASSERT(!SZ("WriteInfo not defined for DEVICE objects"));
    return ERROR_GEN_FAILURE ;
}  // DEVICE::WriteInfo


/**********************************************************\

   NAME:       DEVICE::QueryType

   SYNOPSIS:   reutrn _lmoDevType

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::QueryType( VOID ) const
{
    if ( ! IsValid())
        return LMO_DEV_ERROR;

    return _lmoDevType;

}  // DEVICE::QueryType


/**********************************************************\

   NAME:       DEVICE::QueryState

   SYNOPSIS:   check for device state

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

LMO_DEV_STATE DEVICE::QueryState( VOID ) const
{
    if ( ! IsValid())
        return LMO_DEV_BADSTATE;

    return _lmoDevState;

}  // DEVICE::QueryState


/**********************************************************\

   NAME:       DEVICE::QueryStatus

   SYNOPSIS:   check for device status

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::QueryStatus( VOID ) const
{
    if ( QueryState() != LMO_DEV_REMOTE )
        return (UINT) -1;

    return _uStatus;

}  // DEVICE::QueryStatus


/**********************************************************\

   NAME:       DEVICE::QueryRemoteType

   SYNOPSIS:   check for remote type

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::QueryRemoteType( VOID ) const
{
    if ( QueryState() != LMO_DEV_REMOTE && QueryState() != LMO_DEV_UNAVAIL )
        return (UINT)-1;

    return _uRemoteType;

}  // DEVICE::QueryRemoteType


/**********************************************************\

   NAME:       DEVICE::QueryRemoteName

   SYNOPSIS:   check for remote name of the deivce

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * DEVICE::QueryRemoteName( VOID ) const
{
    if ( QueryState() != LMO_DEV_REMOTE && QueryState() != LMO_DEV_UNAVAIL )
        return NULL;
    return (_szRemoteName) ;

}  // DEVICE::QueryRemoteName



/**********************************************************\

   NAME:       DEVICE::Connect

   SYNOPSIS:   set up connection

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

APIERR DEVICE::Connect( const TCHAR * pszResource, const TCHAR * pszPassword )
{
    struct use_info_1 UseInfo ;
    TCHAR szRemoteName[MAX_PATH+1] ;
    // JonN 1/21/02 PREFIX 240190
    ::ZeroMemory( szRemoteName, sizeof(szRemoteName) );
    APIERR Err ;

    if (!IsValid())
    {
        UIASSERT(!SZ("Connect called on InValid device")) ;
        return(ERROR_GEN_FAILURE);
    }

    // setup API buffer
    COPYTOARRAY( UseInfo.ui1_local, (TCHAR *) _nlsDeviceName.QueryPch());
    UseInfo.ui1_asg_type = ::LMOTypeToNetType(_lmoDevType) ;

    /*
     * if Resource we are trying to connect to does not start
     * with \\ we try as alias.
     */
    if (!(*pszResource == TCH('\\') && *(pszResource+1) == TCH('\\')))
    {
        /*
         * validate alias as SHARE. The reason we do this is to
         * catch an invalid name as soon as we can.
         * If the user typed a bogus netpath without the leading \\
         * on a domain that does not support aliases, better we
         * fail with bad name before going out to the PDC and come
         * back with some other error.
         */
        if ((Err = ::I_MNetNameValidate(NULL,pszResource,NAMETYPE_SHARE,0L))
            != NERR_Success)
            return(ERROR_INVALID_PARAMETER) ;
#ifdef LAN_SERVER
        if ((Err = AliasToUNC(szRemoteName, (TCHAR *)pszResource))
            != NERR_Success)
            return(Err);
#endif
    }
    else
    {
        // no need validate here, NetUseAdd will fail us appropriately.
        ::strcpyf(szRemoteName,pszResource) ;
    }

    // setup rest of UseInfo struct
    UseInfo.ui1_remote   = szRemoteName ;
    UseInfo.ui1_password = (TCHAR *) pszPassword ;

    // make the connection
    Err = ::MNetUseAdd ( NULL, 1, (BYTE *)&UseInfo, sizeof(UseInfo)) ;
    if (Err == NERR_Success)
    {
        _lmoDevState = LMO_DEV_REMOTE;
        _uStatus = USE_OK;
        ::strcpyf(_szRemoteName,szRemoteName) ;
    }
    return(Err) ;

}  // DEVICE::Connect


/**********************************************************\

   NAME:       DEVICE::Disconnect

   SYNOPSIS:   disconnect the device

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

APIERR DEVICE::Disconnect( UINT uiForce )
{
    APIERR Err ;

    Err =  ::MNetUseDel( NULL,
                         _nlsDeviceName.strlen() ?
                             _nlsDeviceName.QueryPch() : _szRemoteName,
                         uiForce );

    if (Err == NERR_Success)
        MakeConstructed() ;     // no longer valid, force another GetInfo call.

    return(Err) ;

}  // DEVICE::Disconnect

APIERR DEVICE::Disconnect( const TCHAR *pszRemote, UINT uiForce )
{
    UIASSERT(QueryType() == LMO_DEV_ANY) ;

    APIERR Err ;
    Err =  ::MNetUseDel( NULL,
                           pszRemote,
                           uiForce );

    if (Err == NERR_Success)
        MakeConstructed() ;     // no longer valid, force another GetInfo call.

    return(Err) ;

}  // DEVICE::Disconnect

/******************************** ITER_DEVICE *******************************/

/**********************************************************\

   NAME:       ITER_DEVICE::ITER_DEVICE

   SYNOPSIS:   constructor for the iterator device

   ENTRY:

   EXIT:

   NOTES:
      constructor takes 2 flags,
      DevType tells us if Drive/LPT/Comm, as defined by LMO_DEVICE enum,
      Usage tells us what kind of state we are interested in.

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

ITER_DEVICE::ITER_DEVICE(LMO_DEVICE DevType, LMO_DEV_USAGE Usage)
{
    _DevType = DevType ;
    _Usage  = Usage ;           // store it, EnumLPTs, etc will use it.

    switch (DevType)
    {
        case LMO_DEV_PRINT :
            _pszDevices = (TCHAR *)EnumLPTs() ;
            break ;
        case LMO_DEV_DISK :
            _pszDevices = (TCHAR *)EnumDrives() ;
            break ;
        case LMO_DEV_COMM :
            _pszDevices = (TCHAR *)EnumComms() ;
            break ;
        case LMO_DEV_ANY :
        case LMO_DEV_ERROR :
        default:
            _pszDevices = NULL ;                        // this error state
    }

    _pszNext = _pszDevices ;
}

/**********************************************************\

   NAME:       ITER_DEVICE::~ITER_DEVICE

   SYNOPSIS:   destructor of ITER_DEVICE

   ENTRY:

   EXIT:

   NOTES:      destructor just frees the memory we allocated

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

ITER_DEVICE::~ITER_DEVICE()
{
   delete _pszDevices ;
   _pszDevices = NULL ;
}

/**********************************************************\

   NAME:       ITER_DEVICE::Next

   SYNOPSIS:
      Next returns the next item in the list. During constructor we
      expect to generate list of devices separated by spaces.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * ITER_DEVICE::Next( VOID )
{
    TCHAR * pszTmp ;

    if (!_pszNext || !*_pszNext)
        return(NULL) ;

    pszTmp = _pszNext ;
    _pszNext = (TCHAR *) ::strpbrkf((TCHAR *)_pszNext,SZ(" ")) ;
    if (_pszNext)
    {
        *_pszNext = TCH('\0') ;         // null terminate it
        if (! * ++ _pszNext )           // if there anything after it?
            _pszNext = NULL ;
    }
    return(pszTmp);
}

/**********************************************************\

   NAME:       ITER_DEVICE::EnumDrives

   SYNOPSIS:
      EnumDrives is called by constructor to enumarate the drives
      of interest. Uses member _Usage.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        JonN        19-May-1992     Added LMO_DEV_ALLDEVICES

\**********************************************************/

const TCHAR * ITER_DEVICE:: EnumDrives()
{
    ULONG ulMap;
    UINT  uiCount ;
    TCHAR  szTmp[DEVLEN + 1] ;

    /*
     * allocate worst case memory requirements
     */
    if ( !(_pszDevices = new TCHAR [(DEVLEN + 1) * 26]) )
        return (NULL) ;

    switch (_Usage)
    {
        case LMO_DEV_CANCONNECT :
            // we define 'can connect' as all drives not already used
            ulMap = ~(EnumLocalDrives() | EnumNetDrives()) ;
            break ;
        case LMO_DEV_CANDISCONNECT :
            // we define 'can disconnect' as all redirected or unavail ones
            ulMap = EnumNetDrives() | EnumUnavailDrives() ;
            break ;
        case LMO_DEV_ISCONNECTED :
            // net drives is net drives
            ulMap = EnumNetDrives() ;
            break ;
        case LMO_DEV_ALLDEVICES :
            // all valid drive designations
            ulMap = EnumAllDrives();
            break ;
        default:
            ulMap = 0L ;
    }

    /*
     * below does not worry about DBCS, nor does it need to
     */
    *_pszDevices = TCH('\0') ;
    ::strcpyf(szTmp,SZ("A: ")) ;
    for (uiCount = 0 ; uiCount < 26; uiCount++ )
    {
        /*
         * if its of interest, add to string
         */
        if (ulMap & 1L)
            ::strcatf((TCHAR *)_pszDevices,szTmp) ;
        ulMap >>= 1 ;
        ++szTmp[0] ;
    }

    return(_pszDevices) ;
}

/**********************************************************\

   NAME:       ITER_DEVICE::EnumLPTs

   SYNOPSIS:
      EnumLPTs is called by constructor to enumarate the lpts
      of interest. Uses member _Usage.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        JonN        19-May-1992     Added LMO_DEV_ALLDEVICES

\**********************************************************/

const TCHAR * ITER_DEVICE:: EnumLPTs()
{
    ULONG ulMap;
    UINT  uiCount ;
    TCHAR szTmp[DEVLEN+1] ;

    /*
     * allocate worst case memory requirements.
     */
    if ( !(_pszDevices = new TCHAR [(DEVLEN + 1) * 11]) )
        return (NULL) ;

    switch (_Usage)
    {
        case LMO_DEV_CANCONNECT :
            // can connect to all that are not redirected
            ulMap = (EnumLocalLPTs() & ~EnumNetLPTs()) ;
            break ;
        case LMO_DEV_CANDISCONNECT :
            // can disconnect to redirected or unavail
            ulMap = EnumNetLPTs() | EnumUnavailLPTs() ;
            break ;
        case LMO_DEV_ISCONNECTED :
            // isconnected = redirected
            ulMap = EnumNetLPTs() ;
            break ;
        case LMO_DEV_ALLDEVICES :
            // all valid LPT designations
            ulMap = EnumAllLPTs();
            break ;
        default:
            ulMap = 0L ;
    }

    /*
     * below does not worry about DBCS, nor does it need to
     * our convention is that bit 0 is LPT1, ... bit 8 is LPT9,
     * bit 9 is LPT1.OS2, bit 10 is LPT2.OS2
     */
    *_pszDevices = TCH('\0') ;
    ::strcpyf(szTmp,SZ("LPT1: ")) ;
    for (uiCount = 0 ; uiCount < 9; uiCount++ )
    {
        /*
         * if its of interest, add to string
         */
        if (ulMap & 1L)
            ::strcatf((TCHAR *)_pszDevices,szTmp) ;
        ulMap >>= 1 ;
        ++szTmp[3] ;
    }

    /*
     * as above, except handle LPT1.OS2, LPT2.OS2
     */
    ::strcpyf(szTmp,SZ("LPT1.OS2 ")) ;
    for (uiCount = 0 ; uiCount < 2; uiCount++ )
    {
        /*
         * if its of interest, add to string
         */
        if (ulMap & 1L)
            ::strcatf((TCHAR *)_pszDevices,szTmp) ;
        ulMap >>= 1 ;
        ++szTmp[3] ;
    }

    return(_pszDevices);
}

/**********************************************************\

   NAME:       ITER_DEVICE::EnumComms

   SYNOPSIS:
      EnumComms is called by constructor to enumarate the Comm ports
      of interest. Uses member _Usage.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * ITER_DEVICE:: EnumComms()
{
    // BUGBUG not implemented
    UIASSERT(!SZ("EnumComms is not implemented")) ;
    return(NULL);
}



/*
 * NetTypeToLMOType takes a NETAPI device type as defined
 * by USE.H (ie for uiX_asg_type field) and maps it to
 * an LMOBJ device type.
 */
LMO_DEVICE NetTypeToLMOType( ULONG netDevType)
{
    switch (netDevType)
    {
    case USE_DISKDEV:
        return(LMO_DEV_DISK);
    case USE_SPOOLDEV:
        return(LMO_DEV_PRINT);
    case USE_CHARDEV:
        return(LMO_DEV_COMM);
    case USE_WILDCARD:
        return(LMO_DEV_ANY);
    default:
        return(LMO_DEV_ERROR);
    }
}

/*
 * LMOTypeToNetType takes an LMOBJ device type as defined by
 * LMOBJ.HXX and maps it to a device type NETAPI understands,
 * as defined in USE.H. Note that LMOBJ devices do not have a
 * wildcard. If we return the wildcard type it means we do not
 * understand it, and hence it is an error.
 */
INT LMOTypeToNetType(LMO_DEVICE lmoDevType)
{
    switch (lmoDevType)
    {
        case LMO_DEV_DISK:
            return(USE_DISKDEV) ;
        case LMO_DEV_PRINT:
            return(USE_SPOOLDEV) ;
        case LMO_DEV_COMM:
            return(USE_CHARDEV) ;
        case LMO_DEV_ANY:
            return(USE_WILDCARD);
        case LMO_DEV_ERROR:
        default:
            UIASSERT(SZ("bad Dev type")) ;
            return(USE_WILDCARD);
    }
}

#ifdef LAN_SERVER
/**********************************************************\

   NAME:       DEVICE::AliasToUNC

   SYNOPSIS:   Map Alias name to UNC name.

   ENTRY:
      pchRemoteName - where remote name is returned
      we assume this is at least MAX_PATH+1,
      it is the caller's responsibilty.
      pchAlias      - alias name

   RETURN:
      0 - success
      API error code otherwise

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::AliasToUNC(TCHAR *pchRemoteName, const TCHAR *pchAlias)
{
    APIERR             Err;
    TCHAR               szPDC[MAX_PATH+1];          /* domain controller */
    share_info_92     *ShareInfo92;

    /*
     * use wksta object to get logon domain. If cannot get,
     * cant do much anyway, return error now.
     */
    WKSTA_10 wksta ;
    if ( (Err = wksta.GetInfo()) != NERR_Success )
        return(Err) ;
    TCHAR *pchDomain = (TCHAR *)wksta.QueryLogonDomain() ;

    /*
     * use domain object to get PDC. If cannot get, return no DC.
     */
    DOMAIN domain(pchDomain);
    if (domain.GetInfo() == NERR_Success)
    {
        strcpyf(szPDC,domain.QueryPDC()) ;
    }
    else
        return( NERR_DCNotFound );

    /*
     * use buffer object to get alias stuff. We
     * derive max size from the components and add 16 for safety.
     */
    BYTE *pBuffer = NULL;

    if( Err = ::MNetShareGetInfo( szPDC,
                                    (TCHAR *)pchAlias,
                                    92,
                                    &pBuffer ))
    {
        /*
         * if we get an error and it is in the alias range, we map
         * to something we can understand. Else user sees ERROR xxxx.
         * BUGBUG, need define upper bound in NETERR.H
         */
        if (Err >= ALERR_BASE)
            Err = ERROR_BAD_NETPATH ;
        return(Err);
    }

    ShareInfo92 = ( share_info_92 * ) pBuffer;
    ShareInfo92->shi92_alias = (TCHAR *)pchAlias;
    /*
     * copy the info over
     */
    ::strcpyf( pchRemoteName, ShareInfo92->shi92_server );
    ::strcatf( pchRemoteName, SZ("\\") );
    ::strcatf( pchRemoteName, ShareInfo92->shi92_netname );
    ::MNetApiBufferFree( &pBuffer );
    return(NERR_Success) ;
}
#endif

/**********************************************************\

   NAME:       DEVICE::ValidateName

   SYNOPSIS:   validate device name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        Johnl       19-Feb-1992     Added check for UNC name, changed
                                    comparisons to be case insensitive

\**********************************************************/

APIERR DEVICE::ValidateName()
{
    TCHAR *pszDev = (TCHAR *) _nlsDeviceName.QueryPch() ;

    /*
     * check for null case and for invalid length
     */
    UINT uiLen ;
    if (pszDev[0] == TCH('\0') ||
        ( pszDev[0] == TCH('\\') && pszDev[1] == TCH('\\') ))
    {
        _lmoDevType = LMO_DEV_ANY ;
        return(NERR_Success) ;
    }

    if ((uiLen = strlenf( pszDev )) > DEVLEN )
    {
        return(ERROR_INVALID_PARAMETER) ;
    }

    /*
     * now validate the string as valid device and set type
     */
    // try as disk
    if ( uiLen == 2 && pszDev[1] == TCH(':') &&
        ((pszDev[0] >= TCH('A') && pszDev[0] <= TCH('Z')) ||
         (pszDev[0] >= TCH('a') && pszDev[0] <= TCH('a')) ))
    {
        // it is a drive letter
        _lmoDevType = LMO_DEV_DISK ;
        return(NERR_Success) ;
    }

    /*
     * By now we know it is not a disk, so we make sure it is at least 4
     * chars long, and if there is colon insist it is last.
     */
    TCHAR *    pszColon;
    if (uiLen < 4)
        return(ERROR_INVALID_PARAMETER) ;
    if (pszColon = ::strpbrkf(pszDev, SZ(":")))
    {
        /*
         * found a colon
         */
        if ( *(pszColon+1) != TCH('\0') )
            return(ERROR_INVALID_PARAMETER) ; // if colon, it must be last char

        // we decrement usLen to ignore the colon in further checks
        --uiLen ;
    }

    /*
     * try as print device, we are assured of at least 4 chars.
     * first we try match LPT[1-9]. If this succeeds,
     * we need assure usLen==4 or it is one of those LPTx.OS2
     * drives. usLen will be 4 iff:
     *          it is LPTx or
     *          it is LPTx:
     * note we did the decrement to ignore the colon a few lines back.
     */
    if (::strnicmpf(pszDev,SZ("LPT"),3) == 0 &&
             pszDev[3] >= TCH('1') && pszDev[3] <= TCH('9'))
    {
        if (uiLen == 4 ||
            ::strnicmpf( pszDev,
                         SZ("LPT1.OS2"),8) == 0 ||
            ::strnicmpf( pszDev,SZ("LPT2.OS2"),8) == 0)
        {
            _lmoDevType = LMO_DEV_PRINT ;
            return(NERR_Success) ;
        }
        return(ERROR_INVALID_PARAMETER) ;
    }

    /*
     * try comm. same assumptions as above.
     */
    if (::strnicmpf( pszDev,SZ("COM"),3) == 0
        && (pszDev[3] >= TCH('1') && pszDev[3] <= TCH('9'))
        && (uiLen == 4))
    {
        _lmoDevType = LMO_DEV_COMM ;
        return(NERR_Success) ;
    }

    /*
     * if get here, it must be bad
     */
    return(ERROR_INVALID_PARAMETER) ;
}

/*******************************************************************

    NAME:       DEVICE::SetRemoteName

    SYNOPSIS:   set the remote name of the device

    ENTRY:      const TCHAR * pszRemoteName - new remote name

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE::SetRemoteName( const TCHAR * pszRemoteName )
{
    ::strcpy( _szRemoteName, pszRemoteName );
}

/*******************************************************************

    NAME:       DEVICE::SetServerName

    SYNOPSIS:   set the server name

    ENTRY:      const TCHAR * pszServername - new server name

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE::SetServerName( const TCHAR * pszServerName )
{
    strcpyf(_szServerName, pszServerName) ;
}

#ifdef WIN32

/*******************************************************************

    NAME:       DEVICE2::DEVICE2

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszName - device name

    HISTORY:
                terryk  31-Oct-91       Created
                JohnL   30-Jan-1992     Added Domain Name

********************************************************************/

DEVICE2::DEVICE2( const TCHAR * pszName )
    : DEVICE( pszName ),
      _nlsUsername(),
      _nlsDomainName()
{
    APIERR err ;
    if ( (err = _nlsUsername.QueryError()) ||
         (err = _nlsDomainName.QueryError()) )
    {
        return;
    }
}

/*******************************************************************

    NAME:       DEVICE2::CallAPI

    SYNOPSIS:   worker function for get info - get net info

    RETURNS:    APIERR - net api error code

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

APIERR DEVICE2::CallAPI( )
{
    BYTE *pBuf = NULL;
    APIERR err = ::MNetUseGetInfo( NULL, QueryName(), 2, &pBuf );
    SetBufPtr( pBuf );
    return err;
}

/*******************************************************************

    NAME:       DEVICE2::SetInfo

    SYNOPSIS:   worker function get GetInfo - set internal variables

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE2::SetInfo( )
{
    struct use_info_2 * pui2 = (struct use_info_2 *)QueryBufPtr();
    SetUsername( pui2->ui2_username );
    SetDomainName( pui2->ui2_domainname ) ;
    SetDevType( ::NetTypeToLMOType ( pui2->ui2_asg_type )) ;
    SetStatus( (UINT) pui2->ui2_status );
    SetRemoteType( (UINT) pui2->ui2_asg_type );
    SetRemoteName( pui2->ui2_remote );
}


/*******************************************************************

    NAME:       DEVICE2::Connect

    SYNOPSIS:   connect device 2 to the network

    ENTRY:      const TCHAR *pszResource - resource name
                const TCHAR *pszPassword - password
                const TCHAR *pszUsername - username
                const TCHAR *pszDomainName - Domain name
                ULONG ulFlags - flags for NetUseAdd level 3
                    (defaults to 0, in which case this is the
                    same as calling NetUseAdd level 2)

    RETURNS:    APIERR - net api error code

    HISTORY:
                terryk   31-Oct-91      Created
                anirudhs 16-Jan-96      Changed to level 3 call

********************************************************************/

APIERR DEVICE2::Connect( const TCHAR * pszResource,
                         const TCHAR * pszPassword,
                         const TCHAR * pszUsername,
                         const TCHAR * pszDomainName,
                         ULONG ulFlags )
{
    USE_INFO_3 UseInfo ;
    TCHAR szRemoteName[MAX_PATH+1] ;
    APIERR Err ;

    if (!IsValid())
    {
        UIASSERT(!SZ("Connect called on InValid device")) ;
        return(ERROR_GEN_FAILURE);
    }

    // setup API buffer
    COPYTOARRAY( UseInfo.ui3_ui2.ui2_local, (TCHAR *)QueryName());
    UseInfo.ui3_ui2.ui2_asg_type = ::LMOTypeToNetType(QueryDevType()) ;

    if ( pszUsername != NULL && *pszUsername != TCH('\0') )
    {
        if (( Err = ::I_NetNameValidate( NULL, (TCHAR *)pszUsername, NAMETYPE_USER,
            0L)) != NERR_Success )
        {
            return Err ;
        }
    }

    /*
     * if Resource we are trying to connect to does not start
     * with \\ we try as alias.
     */
    if (!(*pszResource == TCH('\\') && *(pszResource+1) == TCH('\\')))
    {
        /*
         * validate alias as SHARE. The reason we do this is to
         * catch an invalid name as soon as we can.
         * If the user typed a bogus netpath without the leading \\
         * on a domain that does not support aliases, better we
         * fail with bad name before going out to the PDC and come
         * back with some other error.
         */
        if ((Err = ::I_MNetNameValidate(NULL,pszResource,NAMETYPE_SHARE,0L))
            != NERR_Success)
            return(ERROR_INVALID_PARAMETER) ;
#ifdef LAN_SERVER
        if ((Err = AliasToUNC(szRemoteName, (TCHAR *)pszResource))
            != NERR_Success)
            return(Err);
#endif
    }
    else
    {
        // no need validate here, NetUseAdd will fail us appropriately.
        ::strcpyf(szRemoteName,pszResource) ;
    }

    // setup rest of UseInfo struct
    UseInfo.ui3_ui2.ui2_remote   = szRemoteName ;
    UseInfo.ui3_ui2.ui2_password = (TCHAR *) pszPassword ;
    UseInfo.ui3_ui2.ui2_username = (TCHAR *) pszUsername;
    UseInfo.ui3_ui2.ui2_domainname = (TCHAR *) pszDomainName ;
    UseInfo.ui3_flags = ulFlags;

    // make the connection
    Err = ::MNetUseAdd ( NULL, 3, (BYTE *)&UseInfo, sizeof(UseInfo)) ;
    if (Err == NERR_Success)
    {
        SetDevState( LMO_DEV_REMOTE );
        SetStatus( USE_OK );
        SetRemoteName(szRemoteName) ;
    }
    return(Err) ;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmofile.cxx ===
/**********************************************************************/
/**              Microsoft LAN Manager                               **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    lmofile.cxx
	LM_FILE source file.

	LM_FILE object is use to handle the ::NetFileClose2 and
	::NetFileGetInfo2 netapi.

    FILE HISTORY:
	terryk	16-Aug-1991	Created
	terryk	20-Aug-1991	Add QueryError to constructor
	terryk	26-Aug-1991	Code review changed. Attend: Chuckc
				Keithmo hui-lich terryk
	terryk	10-Oct-1991	type changes for NT
	KeithMo	08-Oct-1991	Now includes LMOBJP.HXX.
	terryk	17-Oct-1991	WIN 32 conversion
	terryk	21-Oct-1991	cast _pBuffer variable

*/

#include "pchlmobj.hxx"  // Precompiled header


/**********************************************************\

    NAME:       LM_FILE::LM_FILE

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszServer - server name
		ULONG ulFileId - file id of the file

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE::LM_FILE( const TCHAR * pszServer, ULONG ulFileId )
    : NEW_LM_OBJ(),
    _nlsServer( pszServer ),
    _ulFileId( ulFileId )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE error: construction failure.") );
	ReportError( err );
	return;
    }

    err = _nlsServer.QueryError();
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE error: construction failure.") );
	ReportError( err );
	return;
    }
}

/**********************************************************\

    NAME:       LM_FILE::~LM_FILE

    SYNOPSIS:   destructor

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE::~LM_FILE()
{
    // do nothing
}

/**********************************************************\

    NAME:       LM_FILE::QueryFileId

    SYNOPSIS:   return the current file id of the object

    RETURN:     ULONG - the current file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

ULONG LM_FILE::QueryFileId() const
{
    return _ulFileId;
}

/**********************************************************\

    NAME:       LM_FILE::QueryServer

    SYNOPSIS:   return the server name

    RETURN:     const TCHAR * - the server name

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

const TCHAR * LM_FILE::QueryServer() const
{
    return _nlsServer.QueryPch();
}

/**********************************************************\

    NAME:       LM_FILE::SetFileId

    SYNOPSIS:   set the object file id to the new value

    ENTRY:      ULONG ulFileId - new file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE::SetFileId( ULONG ulFileId )
{
    _ulFileId = ulFileId;
    return NERR_Success;
}

/**********************************************************\

    NAME:       LM_FILE::SetServer

    SYNOPSIS:   set the object server name to the new value

    ENTRY:      const TCHAR * pszServer - new server name

    RETURN:	APIERR for set string error

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE::SetServer( const TCHAR * pszServer )
{
    _nlsServer = pszServer;
    return _nlsServer.QueryError();
}

/**********************************************************\

    NAME:       LM_FILE::CloseFile

    SYNOPSIS:   close the file

    RETURN:	return the APIERR for NetFileClose2

    NOTES:      It will call ::NetFileClose2 to close the file

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE::CloseFile()
{
    return ::MNetFileClose( QueryServer(), QueryFileId() );
}

/**********************************************************\

    NAME:       LM_FILE_2::LM_FILE_2

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszServer - server name
		ULONG ulFileId - file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE_2::LM_FILE_2( const TCHAR * pszServer, ULONG ulFileId )
    : LM_FILE( pszServer, ulFileId )
{
    APIERR err = QueryError();

    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE_2 error: construction failure.") );
	ReportError( err );
	return;
    }
}

/**********************************************************\

    NAME:       LM_FILE_2::I_GetInfo

    SYNOPSIS:   level 2 get file information

    RETURN:     APIERR - NERR_Success for sucess. Failure otherwise.

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE_2::I_GetInfo()
{
    struct file_info_2	*pfi2 = NULL;

    // since fi2 does not contain any pointer reference, we don't need
    // to allocate a buffer for it.
    APIERR err = ::MNetFileGetInfo( QueryServer(), QueryFileId(), 2,
	(BYTE ** )&pfi2 );

    if ( err == NERR_Success )
    {
	err = SetFileId( pfi2->fi2_id );
    }

    ::MNetApiBufferFree( (BYTE **)&pfi2 );

    return err;
}

/**********************************************************\

    NAME:       LM_FILE_3::LM_FILE_3

    SYNOPSIS:   file level 3 object. It will return the permission
		and number of locks information.

    ENTRY:      const TCHAR * pszServer - the server name
		ULONG ulFileId - file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE_3::LM_FILE_3( const TCHAR * pszServer, ULONG ulFileId )
    : LM_FILE_2( pszServer, ulFileId ),
    _uLock( 0 ),
    _uPermission( 0 ),
    _nlsPathname(),
    _nlsUsername()
{
    APIERR err = QueryError();

    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE_3 error: construction failure.") );
	ReportError( err );
	return;
    }

    if ((( err = _nlsPathname.QueryError()) != NERR_Success ) ||
	(( err = _nlsUsername.QueryError()) != NERR_Success ))
    {
	UIASSERT( !SZ("LM_FILE_3 error: construction failure.") );
	ReportError( err );
	return;
    }
}


/**********************************************************\

    NAME:       LM_FILE_3::I_GetInfo

    SYNOPSIS:   get the level 3 file information

    NOTES:      It will call the ::NetGetInfo2() function will level 3
		specification. After it gets the information, it will
		set up the internal variables.

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE_3::I_GetInfo()
{
    BYTE *pBuffer = NULL;
    APIERR err = ::MNetFileGetInfo( QueryServer(), QueryFileId(), 3,
	 &pBuffer );

    struct file_info_3 * fi3 = ( struct file_info_3 * )pBuffer;

    if ( err == NERR_Success )
    {
	err = SetFileId( fi3->fi3_id );
	UIASSERT( err == NERR_Success );

	_uPermission  = (UINT)fi3->fi3_permissions;
	_uLock        = (UINT)fi3->fi3_num_locks;
	_nlsPathname  = fi3->fi3_pathname;
	err = _nlsPathname.QueryError();
	if ( err != NERR_Success )
	{
	    ::MNetApiBufferFree( &pBuffer );
	    return ( err );
	}
	_nlsUsername  = fi3->fi3_username;
	err = _nlsUsername.QueryError();
	if ( err != NERR_Success )
	{
	    ::MNetApiBufferFree( &pBuffer );
	    return ( err );
	}
    }

    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryPathname

    SYNOPSIS:   return the pathname of the currect object

    RETURN:     const TCHAR * - return the path name

    NOTES:      must call after GetInfo is called.

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

const TCHAR * LM_FILE_3::QueryPathname() const
{
    return _nlsPathname.QueryPch();
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryUsername

    SYNOPSIS:   return the username of the current object

    ENTRY:      const TCHAR * - return the user name

    NOTES:      must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

const TCHAR * LM_FILE_3::QueryUsername() const
{
    return _nlsUsername.QueryPch();
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryNumLock

    SYNOPSIS:   return the number of lock to the current file

    RETURN:     UINT - the total number of locks

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

UINT LM_FILE_3::QueryNumLock() const
{
    return _uLock;
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryPermission

    SYNOPSIS:   return the permission field of the object

    RETURN:     UINT - permission field of the object

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

UINT LM_FILE_3::QueryPermission() const
{
    return _uPermission;
}

/**********************************************************\

    NAME:       LM_FILE_3::IsPermRead

    SYNOPSIS:   return whether the current object is readable or not

    RETURN:     BOOL - TRUE for readable, FALSE otherwise.

    NOTES:	must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

BOOL LM_FILE_3::IsPermRead() const
{
    return ( _uPermission & PERM_FILE_READ ) != 0;
}

/**********************************************************\

    NAME:       LM_FILE_3::IsPermWrite

    SYNOPSIS:   return whether the current object is writable or not

    RETURN:     BOOL - TRUE for writable, FALSE otherwise.

    NOTES:	must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

BOOL LM_FILE_3::IsPermWrite() const
{
    return ( _uPermission & PERM_FILE_WRITE ) != 0;
}

/**********************************************************\

    NAME:       LM_FILE_3::IsPermCreate

    SYNOPSIS:   return whether the current object( directory ) can
		created file or not

    RETURN:     BOOL - TRUE for can, FALSE otherwise.

    NOTES:	must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

BOOL LM_FILE_3::IsPermCreate() const
{
    return ( _uPermission & PERM_FILE_CREATE ) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmolocrg.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*  HISTORY:
 *      jonn    4/21/92         Added LOCATION_NT_TYPE to CheckIfNT()
 *
 *  This form of CheckIfNT is kept seperate from the smaller form so that
 *  clients which do not need to distinguish between WinNt and LanManNt
 *  will not have to link with the registry APIs.
 */

#include "pchlmobj.hxx"  // Precompiled header

#include "lmow32.hxx"    // ::GetW32ComputerName


#define REGPATH SZ("SYSTEM\\CurrentControlSet\\Control\\ProductOptions")
#define REGKEY  SZ("ProductType")
#define REGVALUE_WINNT SZ("WinNt")
#define REGVALUE_LANMANNT SZ("LanManNt")
#define REGVALUE_SERVERNT SZ("ServerNt")


/*******************************************************************

    NAME:	LOCATION::CheckIfNT

    SYNOPSIS:	Sets the passed bool to TRUE if the location this location
		object is "pointing" at is an NT machine.  If we are pointing
		at a domain, then the PDC of the domain is checked.

    ENTRY:	pfIsNT - Pointer to BOOL that will be set if NERR_Success
		    is returned.

                plocnttype - Pointer to LOCATION_NT_TYPE that will be set
                    if the pointer is not NULL, if the target is an NT
                    machine and if NERR_Success is returned.

    RETURNS:	NERR_Success if successful, error code otherwise.

    NOTES:	If we are pointing at a domain, then this method checks
		the PDC of the domain.

		This method assumes that the NT NOS (Network OS) can be
		determined by its major version (i.e., NOSs > 3.x are
		NT only).  This is easy to rectify if this isn't the case.

    HISTORY:
        JonN    06-May-1992     Enabled registry check

********************************************************************/

APIERR LOCATION::CheckIfNT( BOOL * pfIsNT,
                            enum LOCATION_NT_TYPE * plocnttype )
{
    if ( QueryError() )
	return QueryError() ;

    APIERR err  = CheckIfNT( pfIsNT );
    if ( err != NERR_Success )
        return err;

    if (   (*pfIsNT)
        && (plocnttype != NULL)
        && (_locnttype == LOC_NT_TYPE_UNKNOWN ) )
    {
        REG_KEY * pregkeyRoot = NULL;
        do { // false loop

            //
            // Check whether this is the local machine
            //

            const TCHAR * pchServer = QueryServer();
            BOOL fLocalComputer = (    pchServer == NULL
                                   || *pchServer == TCH('\0') );
            if (!fLocalComputer)
            {
                NLS_STR nlsLocalComputer;
                if (   (err = nlsLocalComputer.QueryError()) != NERR_Success
                    || (err = ::GetW32ComputerName( nlsLocalComputer ))
                                != NERR_Success
                   )
                {
                    DBGEOL(   "LOCATION::CheckIfNT: ::GetW32ComputerName err "
                           << err );
                    break;
                }
                fLocalComputer = !(::I_MNetComputerNameCompare(
                        (LPTSTR)pchServer,
                        nlsLocalComputer.QueryPch() ));
            }

            if (fLocalComputer) {
                pregkeyRoot = new REG_KEY( HKEY_LOCAL_MACHINE );
            } else {
                pregkeyRoot = new REG_KEY( HKEY_LOCAL_MACHINE, pchServer );
            }
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   (pregkeyRoot == NULL)
                || ((err = pregkeyRoot->QueryError()) != NERR_Success)
               )
            {
                DBGEOL(   "LOCATION::CheckIfNT: Could not open pregkeyRoot "
                       << err );
                break;
            }

            ALIAS_STR nlsPath( REGPATH );
            REG_KEY regkeyNode( *pregkeyRoot, nlsPath );
            REG_VALUE_INFO_STRUCT rviStruct;
            BUFFER buf( MAXPATHLEN );

            if (   (err = regkeyNode.QueryError()) != NERR_Success
                || (err = rviStruct.nlsValueName.CopyFrom( REGKEY )) != NERR_Success
                || (err = buf.QueryError()) != NERR_Success
               )
            {
                DBGEOL(   "LOCATION::CheckIfNT: Could not open regkeyNode "
                       << err );
                break;
            }

            rviStruct.ulTitle = 0;
            rviStruct.ulType = 0;
            rviStruct.pwcData = buf.QueryPtr();
            rviStruct.ulDataLength = buf.QuerySize();

            err = regkeyNode.QueryValue( &rviStruct );

            if (err != NERR_Success)
            {
                DBGEOL(   "LOCATION::CheckIfNT: Could not query regkeyNode "
                       << err );
                break;
            }

            if (rviStruct.ulType != REG_SZ)
            {
                DBGEOL(   "LOCATION::CheckIfNT: regkeyNode value bad type "
                       << rviStruct.ulType );
                UIASSERT( FALSE );
                err = ERROR_INVALID_PARAMETER;
                break;
            }

            TCHAR * pchEos = (TCHAR *) (rviStruct.pwcData + rviStruct.ulDataLengthOut);
            *pchEos = TCH('\0');

            TCHAR * pchData = (TCHAR *) rviStruct.pwcData;
            // BUGBUG BUGBUG strings
            if ( !::stricmpf( pchData, REGVALUE_LANMANNT ))
            {
                DBGEOL( "LOCATION::CheckIfNT: focus on LanManNt" );
                _locnttype = LOC_NT_TYPE_LANMANNT;
            }
            else if ( !::stricmpf( pchData, REGVALUE_WINNT ))
            {
                DBGEOL( "LOCATION::CheckIfNT: focus on WinNt" );
                _locnttype = LOC_NT_TYPE_WINDOWSNT;
            }
            else if ( !::stricmpf( pchData, REGVALUE_SERVERNT ))
            {
                DBGEOL( "LOCATION::CheckIfNT: focus on WinNt(Server)" );
                _locnttype = LOC_NT_TYPE_SERVERNT;
            }
#ifdef DEBUG
            else
            {
                DBGEOL(    "LOCATION::CheckIfNT: invalid regkeyNode value "
                        << pchData );
                UIASSERT( FALSE );
                _locnttype = LOC_NT_TYPE_WINDOWSNT;
            }
#endif // DEBUG

        } while (FALSE);

        delete pregkeyRoot;
    }

    if (err == NERR_Success && plocnttype != NULL)
        *plocnttype = _locnttype;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmoloc.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990, 1991          **/
/**********************************************************************/

/*  HISTORY:
 *      gregj   5/21/91         Removed from USER for general use
 *      gregj   5/22/91         Added LOCATION_TYPE constructor
 *      rustanl 6/14/91         Inherit from LM_OBJ
 *      rustanl 7/01/91         Code review changes from code review
 *                              attended by TerryK, JonN, o-SimoP, RustanL.
 *                              Main change:  inherit from BASE.
 *      rustanl 7/15/91         Code review changes from code review
 *                              attended by ChuckC, Hui-LiCh, TerryK, RustanL.
 *      jonn    7/26/91         added Set(const LOCATION & loc);
 *      terryk  10/7/91         type changes for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      terryk  10/21/91        WIN 32 conversion part 2
 *      Yi-HsinS 1/24/92        Check if the workstation service is started.
 *      jonn    4/21/92         Added LOCATION_NT_TYPE to CheckIfNT()
 *      Yi-HsinS 5/13/92        Added QueryDisplayName
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


/* These define the starting level of the NOS for NT.  All versions greater
 * or equal to this are assumed to be NT.
 */
#define NT_NOS_MAJOR_VER    3
#define NT_NOS_MINOR_VER    0

/*******************************************************************

    NAME:       LOCATION::LOCATION

    SYNOPSIS:   constructor for the LOCATION object

    ENTRY:      pszLocation -   server or domain name to validate;
                                NULL or "" means the local computer;
                                default is NULL.

                loctype -       type of local location, local computer
                                or logon domain

                loc -           LOCATION object to be copied; must be
                                a valid LOCATION object; new object
                                will not refresh information, but rather
                                copies everything verbatim from loc

    EXIT:       Object is constructed

    NOTES:      Validation is not done until Validate() is called.

    HISTORY:
        gregj   5/21/91         Created
        gregj   5/22/91         Added LOCATION_TYPE constructor
        jonn    4/21/92         Added LOCATION_NT_TYPE to CheckIfNT()

********************************************************************/

LOCATION::LOCATION( const TCHAR * pszLocation, BOOL fGetPDC )
    :   CT_NLS_STR( _nlsDomain ),
        CT_NLS_STR( _nlsServer ),
        _loctype( LOC_TYPE_LOCAL ),
        _locnttype( LOC_NT_TYPE_UNKNOWN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = W_Set( pszLocation, LOC_TYPE_LOCAL, fGetPDC );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOCATION::LOCATION


LOCATION::LOCATION( enum LOCATION_TYPE loctype, BOOL fGetPDC )
    :   CT_NLS_STR( _nlsDomain ),
        CT_NLS_STR( _nlsServer ),
        _loctype( LOC_TYPE_LOCAL ),
        _locnttype( LOC_NT_TYPE_UNKNOWN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = W_Set( NULL, loctype, fGetPDC );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOCATION::LOCATION


LOCATION::LOCATION( const LOCATION & loc )
    :   CT_NLS_STR( _nlsDomain ),
        CT_NLS_STR( _nlsServer ),
        _loctype( LOC_TYPE_LOCAL ),
        _locnttype( LOC_NT_TYPE_UNKNOWN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = Set( loc );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOCATION::LOCATION


/*******************************************************************

    NAME:       LOCATION::~LOCATION

    SYNOPSIS:   LOCATION destructor

    HISTORY:
        rustanl     01-Jul-1991     Created

********************************************************************/

LOCATION::~LOCATION()
{
    // nothing else to do

}  // LOCATION::~LOCATION


/*******************************************************************

    NAME:       LOCATION::W_Set

    SYNOPSIS:   Sets the object to have a new value.  "Snaps back"
                to previous value if an error occurs.

    ENTRY:      pszLocation -   Pointer to server or domain name
                loctype -       Location type

                pszLocation and loctype can be one of the following
                combinations:

                pszLocation     loctype                 means
                -----------     -------                 -----
                NULL or empty   LOC_TYPE_LOCAL          use local wksta
                    string
                NULL            LOC_TYPE_LOGONDOMAIN    use logon domain
                \\server        LOC_TYPE_LOCAL          use specified server
                domain          LOC_TYPE_LOCAL         use specified domain


                Note, when pszLocation is non-NULL, loctype must be passed
                in as LOC_TYPE_LOCAL.  The reason is that the constructor
                or Set method that is calling W_Set may have received an
                empty string rather than a \\server or domain string.
                Instead of it doing the checking for empty string or NULL,
                loctype is passed in as LOC_TYPE_LOCAL.  Then, this method
                (whose reason for existence is to provide a common place
                to accomodate all the above cases) can easily treat
                this case along with the others.

                fGetPDC -       BOOL that says whether or not to get the PDC
                                name for the domain passed in, so that
                                subsequent calls to QueryServer will return
                                the PDC name in the event of domains.
                                THIS WAS DONE AS AN OPTIMIZATION SO THAT
                                YOU DON'T HAVE TO HAVE THE OVERHEAD OF
                                NETGETDCNAME.

    EXIT:       Object is set to new value if successful; otherwise,
                object snaps back to the state it was in on entry.

    RETURNS:    An API return code, which is NERR_Success on success.

    NOTES:      This method is always defined--even on objects that were
                not constructed properly.  The reason is that this
                method really reconstructs the object.  Note, if this
                class is subclassed, subclasses must be updated somehow
                as well.  This is currently not accounted for.

    HISTORY:
        rustanl     01-Jul-1991 Created from GetInfo
        beng        22-Nov-1991 Remove STR_OWNERALLOC
        Yi-HsinS    24-Jan-1992 Remove multiple declaration of APIERR err.

********************************************************************/

APIERR LOCATION::W_Set( const TCHAR * pszLocation,
                        enum LOCATION_TYPE loctype,
                        BOOL fGetPDC )
{
    //  Note, QueryError is not called, since this method is valid on both
    //  constructed and unconstructed objects.

    APIERR err = NERR_Success;

    //
    // JonN 3/10/99: Removed use of STACK_NLS_STR,
    // invalid server/domain names can cause us to assert below.
    //
    NLS_STR nlsDomain;
    NLS_STR nlsServer;
    BOOL fLogndomainIsLocal = FALSE;

    if ( loctype == LOC_TYPE_LOGONDOMAIN )
    {
        UIASSERT( pszLocation == NULL );

        WKSTA_10 wksta;
        err = wksta.GetInfo();
        if ( err != NERR_Success )
            return err;

        nlsDomain = wksta.QueryLogonDomain();

#ifdef WIN32

        DWORD cch = MAX_COMPUTERNAME_LENGTH+1;
        BUFFER buf( sizeof(TCHAR)*(cch) );
        if (!buf)
            return buf.QueryError();

        // BUGBUG should have own class
        if ( !::GetComputerName( (LPTSTR)(buf.QueryPtr()),
                                 &cch ))
        {
            DWORD errLast = ::GetLastError();
            DBGEOL(   SZ("NETUI: LOCATION::W_Set: ::GetComputerName() failed with ")
                   << errLast );
            return errLast; // BUGBUG map this?
        }

        TRACEEOL(   SZ("NETUI: LOCATION::W_Set: Comparing ")
                 << wksta.QueryLogonDomain()
                 << SZ(" and ")
                 << (TCHAR *)(buf.QueryPtr()) );

        fLogndomainIsLocal =
                        !::I_MNetComputerNameCompare( wksta.QueryLogonDomain(),
                                                      (TCHAR *)buf.QueryPtr() );
#endif // WIN32

    }
    else
    {
        if ( pszLocation == NULL || pszLocation[ 0 ] == TCH('\0') )
        {
            //  local wksta; nlsDomain and nlsServer are
            //  already set to the correct values
        }
        else
        {
            //  Need to cast pszLocation from const TCHAR * to TCHAR *
            //  in order to create nlsLocation.  To justify this,
            //  nlsLocation is declared as a const object.
            const ALIAS_STR nlsLocation( pszLocation );
            ISTR istr( nlsLocation );

            if ( nlsLocation.QueryChar(   istr ) == TCH('\\') &&
                 nlsLocation.QueryChar( ++istr ) == TCH('\\') &&
                 nlsLocation.QueryChar( ++istr ) != TCH('\0') )
            {
                err = ::I_MNetNameValidate( NULL,
                                            nlsLocation.QueryPch(istr),
                                            NAMETYPE_COMPUTER, 0L );
                if ( err != NERR_Success )
                {
                    UIDEBUG( SZ("LOCATION::W_Set given invalid server name") );
                    return err;
                }

                //  nlsLocation is a valid server name, prepended with two
                //  backslashes
                nlsServer = nlsLocation;
            }
            else
            {
                //  pszLocation does not start with two backslashes followed
                //  by at least one more character.  Attempt to validate as
                //  domain name.
                err = ::I_MNetNameValidate( NULL, pszLocation,
                                            NAMETYPE_DOMAIN, 0L );
                if ( err != NERR_Success )
                {
                    UIDEBUG( SZ("LOCATION::W_Set given invalid domain name") );
                    return err;
                }

                //  pszLocation is a domain name
                nlsDomain = pszLocation;
            }
        }
    }


    /*  Nothing should have been assigned to nlsServer or nlsDomain that
     *  would have caused an error.
     */

    UIASSERT( nlsServer.QueryError() == NERR_Success );
    UIASSERT( nlsDomain.QueryError() == NERR_Success );


    if ( fGetPDC )
    {
        /*      If domain is filled in, fill in the server field, too  */

        if ( nlsDomain.strlen() > 0 )
        {
            if (fLogndomainIsLocal)
            {
                nlsServer = SZ("\\\\");
                nlsServer += nlsDomain;
            }
            else
            {
                //  The above should not have assigned nlsServer
                UIASSERT( nlsServer.strlen() == 0 );

                DOMAIN domain( nlsDomain.QueryPch());
                err = domain.GetInfo();
                if ( err != NERR_Success )
                    return err;

                nlsServer = domain.QueryPDC();
            }
        }
    }


    /*  At this time, nlsServer, nlsDomain, and loctype contain the
     *  value that we want to set to the private data members of the
     *  LOCATION object.
     */
    _nlsDomain     = nlsDomain;
    _nlsServer     = nlsServer;
    _loctype       = loctype;
    _locnttype     = LOC_NT_TYPE_UNKNOWN; // we do not know this anymore
    _uiNOSMajorVer = 0 ;
    _uiNOSMinorVer = 0 ;

    /*  _nlsDomain and _nlsServer should be big enough to hold a domain
     *  and server name, respectively.
     */
    UIASSERT( _nlsDomain.QueryError() == NERR_Success );
    UIASSERT( _nlsServer.QueryError() == NERR_Success );

    /*  If the object had not constructed properly until this call,
     *  report success as the 'error'.
     */
    if ( QueryError() != NERR_Success )
        ReportError( NERR_Success );

    return NERR_Success;

}  // LOCATION::W_Set


/*******************************************************************

    NAME:       LOCATION::Set

    SYNOPSIS:   This form of Set simply copies an existing LOCATION
                object.

    ENTRY:      loc -           an existing LOCATION object which
                                should not be in an error state

    EXIT:       Object is set to new value if successful; otherwise,
                object remains in the state it was in on entry.

    RETURNS:    An API return code, which is NERR_Success on success.

    HISTORY:
        jonn        26-Jul-1991     Created

********************************************************************/

APIERR LOCATION::Set( const LOCATION & loc )
{
    //  Note, QueryError is not called, since this method is valid on both
    //  constructed and unconstructed objects.


    if ( loc.QueryError() != NERR_Success )
    {
        UIASSERT( !SZ("Attempted LOCATION::Set from bad LOCATION object") );
        return ERROR_INVALID_PARAMETER;
    }

    _nlsDomain     = loc._nlsDomain;
    _nlsServer     = loc._nlsServer;
    _loctype       = loc._loctype;
    _locnttype     = loc._locnttype;
    _uiNOSMajorVer = loc._uiNOSMajorVer ;
    _uiNOSMinorVer = loc._uiNOSMinorVer ;

    UIASSERT( _nlsDomain.QueryError() == NERR_Success );
    UIASSERT( _nlsServer.QueryError() == NERR_Success );

    /*  If the object had not constructed properly until this call,
     *  report success as the 'error'.
     */
    if ( QueryError() != NERR_Success )
        ReportError( NERR_Success );

    return NERR_Success;

}  // LOCATION::Set

/*******************************************************************

    NAME:       LOCATION::CheckIfNT

    SYNOPSIS:   Sets the passed bool to TRUE if the location this location
                object is "pointing" at is an NT machine.  If we are pointing
                at a domain, then the PDC of the domain is checked.

    ENTRY:      pfIsNT - Pointer to BOOL that will be set if NERR_Success
                    is returned.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      If we are pointing at a domain, then this method checks
                the PDC of the domain.

                This method assumes that the NT NOS (Network OS) can be
                determined by its major version (i.e., NOSs > 3.x are
                NT only).  This is easy to rectify if this isn't the case.

    HISTORY:
        Johnl   15-Nov-1991     Created

********************************************************************/

APIERR LOCATION::CheckIfNT( BOOL * pfIsNT )
{
    ASSERT( pfIsNT != NULL );

    if ( QueryError() )
        return QueryError() ;

    APIERR err ;
    if ( err = QueryNOSVersion( &_uiNOSMajorVer, &_uiNOSMinorVer ) )
        return err ;

    *pfIsNT = _uiNOSMajorVer >= NT_NOS_MAJOR_VER ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       LOCATION::QueryNOSVersion

    SYNOPSIS:   Gets the Network Operating System version number

    ENTRY:      puiVersMajor - pointer to UINT that will receive the major NOS version
                puiVersMinor - pointer to UINT that will receive the minor NOS version

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      It is safe to call this method passing in the
                _uiNOSMajorVer and _uiNOSMinorVer private members
                as parameters.

                This method will also retrieve the version number of a
                domain by retrieving the version number of the PDC.

    HISTORY:
        Johnl   02-Dec-1991     Created
        Yi-HsinS24-Jan-1992     Check version number of local machine without
                                having the workstaiton started

********************************************************************/

APIERR LOCATION::QueryNOSVersion( UINT * puiVersMajor, UINT * puiVersMinor )
{
    if ( QueryError() )
        return QueryError() ;

    /* If the version numbers are zero, then we haven't been called
     * yet.
     */
    if ( !_uiNOSMajorVer && !_uiNOSMinorVer )
    {
        /* If this is a domain location and we haven't gotten the PDC, then
         * get it.
         */
        if ( IsDomain() && _nlsServer.strlen() == 0 )
        {
            DOMAIN domain( QueryDomain() );
            APIERR err = domain.GetInfo();
            if ( err != NERR_Success )
                return err;

            _nlsServer = domain.QueryPDC();
            if ( _nlsServer.QueryError() )
                return _nlsServer.QueryError() ;
        }

#if defined(WIN32)
        if ( _nlsServer.strlen() != 0 )
        {
#endif
            SERVER_1 srv1( QueryServer() ) ;
            APIERR err = srv1.GetInfo();

            // BUGBUG : Have to check for specific error. Will wait
            //          till API maps the error from RPC
            if ( err != NERR_Success )
            {
                WKSTA_10 wksta( QueryServer() );
                err = wksta.GetInfo();
                switch (err)
                {
                case NERR_Success:
                    _uiNOSMajorVer = (UINT) wksta.QueryMajorVer();
                    _uiNOSMinorVer = (UINT) wksta.QueryMinorVer();
                    break;
#if defined(WIN32)
                case NERR_WkstaNotStarted:
                case NERR_NetNotStarted:
                    _uiNOSMajorVer = NT_NOS_MAJOR_VER;
                    _uiNOSMinorVer = NT_NOS_MINOR_VER;
                    break;

                default:
                    return err;
#endif
                }
            }
            else
            {
                _uiNOSMajorVer = (UINT) srv1.QueryMajorVer();
                _uiNOSMinorVer = (UINT) srv1.QueryMinorVer();
            }

#if defined(WIN32)
        }
        else
        {

            // BUGBUG: Not safe on 16 bit side.

            _uiNOSMajorVer = NT_NOS_MAJOR_VER;
            _uiNOSMinorVer = NT_NOS_MINOR_VER;
        }
#endif
    }

    *puiVersMajor = _uiNOSMajorVer ;
    *puiVersMinor = _uiNOSMinorVer ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       LOCATION::IsDomain

    SYNOPSIS:   Returns TRUE if the current location was constructed
                as a domain

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        Johnl       31-May-1991     Created
        rustanl     01-Jul-1991     Call QueryError (no longer IsValid())

********************************************************************/

BOOL LOCATION::IsDomain( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    return ( _nlsDomain.strlen() > 0 );

}  // LOCATION::IsDomain


/*******************************************************************

    NAME:       LOCATION::IsServer

    SYNOPSIS:   Returns TRUE if the current location was constructed
                as a server

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     15-Jul-1991     Code review change:  move to .cxx file

********************************************************************/

BOOL LOCATION::IsServer( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    return ( ! IsDomain());

}  // LOCATION::IsServer


/*******************************************************************

    NAME:       LOCATION::QueryServer

    SYNOPSIS:   Returns the server name of the location.

    RETURNS:    The server name of the location.  This server name
                is the given one, if the object was constructed with
                a server name (or NULL if local wksta was specified),
                or the PDC of the domain, if the object was constructed
                specifying a domain.

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     14-Jun-1991     Clarified behavior
        rustanl     01-Jul-1991     Changed to use _nlsServer

********************************************************************/

const TCHAR * LOCATION::QueryServer( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( _nlsServer.strlen() == 0 )
        return NULL;        // return NULL rather than empty string

    return _nlsServer.QueryPch();

}  // LOCATION::QueryServer


/*******************************************************************

    NAME:       LOCATION::QueryDomain

    SYNOPSIS:   Returns the domain name of the location

    RETURNS:    The domain name of the location, if it was constructed
                specifying a domain, or NULL otherwise.

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     14-Jun-1991     Clarified behavior

********************************************************************/

const TCHAR * LOCATION::QueryDomain() const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( _nlsDomain.strlen() == 0 )
        return NULL;        // return NULL rather than empty string

    return _nlsDomain.QueryPch();

}  // LOCATION::QueryDomain


/*******************************************************************

    NAME:       LOCATION::QueryName

    SYNOPSIS:   Returns the name of the location

    RETURNS:    The name passed in to specify the location.  It is:
                    NULL                if local wksta was specified
                    the server name     if one was passed in
                    domain name         if one was specified

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     14-Jun-1991     Created

********************************************************************/

const TCHAR * LOCATION::QueryName( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( IsDomain())
        return QueryDomain();

    return QueryServer();

}  // LOCATION::QueryName

/*******************************************************************

    NAME:       LOCATION::QueryDisplayName

    SYNOPSIS:   Returns the display name of the location

    RETURNS:    The name passed in to specify the location.  It is:
                    NULL                if local wksta was specified
                    the server name     if one was passed in
                    domain name         if one was specified

    NOTES:      This does not depend on the workstation or server
                service being started.

    HISTORY:
        Yi-HsinS     20-May-1991     Created

********************************************************************/

APIERR LOCATION::QueryDisplayName( NLS_STR *pnls ) const
{
    UIASSERT( QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    if ( IsDomain())
    {
        *pnls = QueryDomain();
    }
    else
    {
        if ( _nlsServer.QueryTextLength() != 0 )
        {
            *pnls = QueryServer();
        }
        else
        {
            TCHAR pszServer[ MAX_COMPUTERNAME_LENGTH+1 ];
            DWORD dwLength = sizeof(pszServer) / sizeof(TCHAR);

            if ( ::GetComputerName( pszServer, &dwLength ) )
            {
                *pnls = SZ("\\\\");
                err = pnls->Append( pszServer );
            }
            else
            {
                err = ::GetLastError();
            }
        }
    }


    return ( err? err : pnls->QueryError() );

}  // LOCATION::QueryDisplayName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmomemb.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmomemb.cxx
    MEMBERSHIP_LM_OBJ class implementation


    FILE HISTORY:
        rustanl     20-Aug-1991     Created
        KeithMo     08-Oct-1991     Now includes LMOBJP.HXX.
        jonn        14-Oct-1991     Added GROUP_MEMB::SetName, I_CreateNew
        terryk      17-Oct-1991     WIN 32 conversion
        terryk      21-Oct-1991     cast _pBuffer variable to TCHAR *
        o-SimoP     12-Dec-1991     Create/ChangeToNew rips off any
                                    user priv group
        jonn        07-Jun-1992     Added _slAddedNames to MEMBERSHIP_LM_OBJ
*/

#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::ENUM_CALLER_LM_OBJ

    SYNOPSIS:   ENUM_CALLER_LM_OBJ constructor

    ENTRY:      loc -       Location at which all network operations
                            will take place

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

ENUM_CALLER_LM_OBJ::ENUM_CALLER_LM_OBJ( const LOCATION & loc )
  : LOC_LM_OBJ( loc ),
    ENUM_CALLER()
{
    if ( QueryError() != NERR_Success )
        return;

}  // ENUM_CALLER_LM_OBJ::ENUM_CALLER_LM_OBJ


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::EC_QueryBufferPtr

    SYNOPSIS:   Returns the pointer to the buffer used in the API
                calls

    RETURNS:    Pointer to said buffer area

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

BYTE * ENUM_CALLER_LM_OBJ::EC_QueryBufferPtr() const
{
    return (BYTE *)QueryBufferPtr();

}  // ENUM_CALLER_LM_OBJ::EC_QueryBufferPtr

APIERR ENUM_CALLER_LM_OBJ::EC_SetBufferPtr( BYTE * pBuffer )
{
    SetBufferPtr( pBuffer );
    // BUGBUG
    // need to set the size here
    return NERR_Success;
}


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::EC_QueryBufferSize

    SYNOPSIS:   Returns the size of the buffer used in the API calls.

    RETURNS:    The said size

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

UINT ENUM_CALLER_LM_OBJ::EC_QueryBufferSize() const
{
    return QueryBufferSize();

}  // ENUM_CALLER_LM_OBJ::EC_QueryBufferSize


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::EC_ResizeBuffer

    SYNOPSIS:   Resizes the buffer used in API calls

    ENTRY:      cbNewRequestedSize -    Requested new buffer size

    EXIT:       On success, buffer will be able to store
                cbNewRequestedSize bytes
                On failure, buffer will not have changed

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR ENUM_CALLER_LM_OBJ::EC_ResizeBuffer( UINT cNewRequestedSize )
{
    return ResizeBuffer( cNewRequestedSize );

}  // ENUM_CALLER_LM_OBJ::EC_ResizeBuffer


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::W_CreateNew

    SYNOPSIS:   Sets up shadow members for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created
        jonn        05-Sep-1991     Changed from I_CreateNew

********************************************************************/

APIERR ENUM_CALLER_LM_OBJ::W_CreateNew()
{
    SetCount( 0 );

    return NERR_Success;

}  // ENUM_CALLER_LM_OBJ::W_CreateNew


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Creates this ENUM_CALLER_LM_OBJ object from another one

    ENTRY:      eclmobj -   Source of clone operation

    EXIT:       On success, *this will be a clone of eclmobj

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     22-Aug-1991     Created

********************************************************************/

APIERR ENUM_CALLER_LM_OBJ::W_CloneFrom( const ENUM_CALLER_LM_OBJ & eclmobj )
{
    APIERR err = LOC_LM_OBJ::W_CloneFrom( eclmobj );
    if ( err != NERR_Success )
        return err;

    SetCount( eclmobj.QueryCount());

    return NERR_Success;

}  // ENUM_CALLER_LM_OBJ::W_CloneFrom


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::MEMBERSHIP_LM_OBJ

    SYNOPSIS:   MEMBERSHIP_LM_OBJ constructor

    ENTRY:      loc -               Location at which network operations
                                    will take place
                usAssocNameType -   NAMETYPE_ value of associated items

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

MEMBERSHIP_LM_OBJ::MEMBERSHIP_LM_OBJ( const LOCATION & loc,
                                      UINT             uAssocNameType )
  : ENUM_CALLER_LM_OBJ( loc ),
    _uAssocNameType( uAssocNameType )
{
    if ( QueryError() != NERR_Success )
        return;

    //  This class supports groups and users

    UIASSERT( _uAssocNameType == NAMETYPE_GROUP ||
              _uAssocNameType == NAMETYPE_USER     );

}  // MEMBERSHIP_LM_OBJ::MEMBERSHIP_LM_OBJ


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::I_WriteNew

    SYNOPSIS:   Creates a new membership object

    RETURNS:    An API return code, which is NERR_Success on success

    NOTES:      It is assumed that write new is the same as
                write info.  If this proves to be an invalid assumption
                in the future, subclasses can always override this.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::I_WriteNew()
{
    return I_WriteInfo();

}  // MEMBERSHIP_LM_OBJ::I_WriteNew


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::I_GetInfo

    SYNOPSIS:   Gets membership information from the network

    RETURNS:    An API error value, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::I_GetInfo()
{
    return W_GetInfo();

}  // MEMBERSHIP_LM_OBJ::I_GetInfo


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::QueryItemSize

    SYNOPSIS:   Returns the size of an enumeration item

    RETURNS:    Size of said item

    NOTES:      This method assumes that the user_info_0 and
                group_info_0 structures are the only structures
                that subclasses will ever use.  Moreoever, it
                assumes that these structures have the same
                size and format.  This is true today (8/21/91).
                It this will no longer stay true in the future,
                this class needs to be rewritten, most easily
                accomplished by simply making appropriate methods
                virtual and replacing them in subclasses.

                See also note in class declaration header.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

UINT MEMBERSHIP_LM_OBJ::QueryItemSize() const
{
    //  CODEWORK.  Could do some more checks here.  For example,
    //  davidhov's data member offset macro could be used.  Also,
    //  it would be nice if these tests were made at compile-time
    //  rather than at run-time.
    UIASSERT( sizeof( struct user_info_0 ) == sizeof( struct group_info_0 ));

    return sizeof( struct user_info_0 );

}  // MEMBERSHIP_LM_OBJ::QueryItemSize


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::QueryAssocName

    SYNOPSIS:   Returns the name of a particular associated item

    ENTRY:      i -     Valid index of item whose name is to be
                        retured

    RETURNS:    Pointer to name of specified item

    NOTES:      See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

const TCHAR * MEMBERSHIP_LM_OBJ::QueryAssocName( UINT i ) const
{
    UIASSERT( i <= QueryCount());

    struct user_info_0 * puiBase = (struct user_info_0 *)QueryBufferPtr();
    return puiBase[ i ].usri0_name;

}  // MEMBERSHIP_LM_OBJ::QueryAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::FindAssocName

    SYNOPSIS:   Finds a particular associated name

    ENTRY:      pszName -       Pointer to associated name to be
                                found
                pi -            Pointer to location where the index
                                of the found item should be placed.
                                *pi will only be valid when this
                                method returns TRUE

    EXIT:       On success, *pi will be the lowest index of an item with
                the given name.

    RETURNS:    TRUE if an item was found; FALSE otherwise

    NOTES:      See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

BOOL MEMBERSHIP_LM_OBJ::FindAssocName( const TCHAR * pszName, UINT * pi )
{
    UIASSERT( pi != NULL );

    struct user_info_0 * pui = (struct user_info_0 *)QueryBufferPtr();

    for ( UINT i = 0; i < QueryCount(); i++, pui++ )
    {
        if ( ::I_MNetNameCompare( NULL,
                               pszName,
                               pui->usri0_name,
                               _uAssocNameType,
                               0L ) == NERR_Success )
        {
            *pi = i;
            return TRUE;    // found
        }
    }

    return FALSE;           // not found

}  // MEMBERSHIP_LM_OBJ::FindAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::AddAssocName

    SYNOPSIS:   Adds an associated name

    ENTRY:      pszName -       Name to be added

    EXIT:       On success, item is added.  On failure, object is
                unchanged.

    RETURNS:    An API return code, which is NERR_Success on success

    NOTES:      See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

                Under Win32, the new user_info_0 may step on memory used
                by a string to which some other user_info_0 points.
                Therefore, we move all strings out of the buffer and
                into the STRLIST before proceeding.  We also place the
                new string in the STRLIST.

    HISTORY:
        rustanl     21-Aug-1991     Created
        jonn        07-Jun-1992     Added _slAddedNames to MEMBERSHIP_LM_OBJ

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::AddAssocName( const TCHAR * pszName )
{
    APIERR err = ::I_MNetNameValidate( NULL, pszName, _uAssocNameType, 0L );
    if ( err != NERR_Success )
    {
        DBGEOL( "MEMBERSHIP_LM_OBJ::AddAssocName: given invalid name " << err );
        return err;
    }

    INT cNewTotal = QueryCount() + 1;

    UIASSERT( QueryBufferSize() >= QueryCount() * QueryItemSize());

#ifdef WIN32

    struct user_info_0 * puiBaseOld = (struct user_info_0 *)QueryBufferPtr();

    BYTE * pbBegin = QueryBufferPtr();
    BYTE * pbEnd   = pbBegin + QueryBufferSize();
    INT i;
    for (i = 0; i < (INT)QueryCount(); i++)
    {
        const TCHAR * pchAssocName = QueryAssocName(i);
        if ( ((BYTE *)pchAssocName >= pbBegin) && ((BYTE *)pchAssocName < pbEnd) )
        {
            // CODEWORK should clean this repeated code into a method
            NLS_STR * pnls = new NLS_STR( pchAssocName );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pnls == NULL
                || (err = pnls->QueryError()) != NERR_Success
                || (err = _slAddedNames.Add( pnls )) != NERR_Success
               )
            {
               delete pnls;
               return err;
            }
            puiBaseOld[ i ].usri0_name = (TCHAR *)(pnls->QueryPch());
        }
    }

#endif // WIN32

    err = ResizeBuffer( cNewTotal * QueryItemSize());
    if ( err != NERR_Success )
        return err;

    struct user_info_0 * puiBaseNew = (struct user_info_0 *)QueryBufferPtr();


#ifdef WIN32

    NLS_STR * pnls = new NLS_STR( pszName );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pnls == NULL
        || (err = pnls->QueryError()) != NERR_Success
        || (err = _slAddedNames.Add( pnls )) != NERR_Success
       )
    {
       delete pnls;
       return err;
    }
    puiBaseNew[ QueryCount() ].usri0_name = (TCHAR *)(pnls->QueryPch());

#else // WIN32

    COPYTOARRAY( puiBaseNew[ QueryCount() ].usri0_name, (TCHAR *)pszName );

#endif // WIN32


    SetCount( cNewTotal );

    return NERR_Success;

}  // MEMBERSHIP_LM_OBJ::AddAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::DeleteAssocName

    SYNOPSIS:   Deletes an associated name

    ENTRY:      pszName -       Existing name to be deleted (if more
                                than one exists, the first is deleted)
                    --OR--
                i -             Valid index of item to be deleted

    EXIT:       On success, associated name deleted.  On failure,
                object is unchanged.

    RETURNS:    An API return code, which is NERR_Success on success.

    NOTES:      After the deletion, indices for all items may have
                changed

                These methods assume that the specified item does exist.

                See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

                Under WIN32, we keep the added strings in a STRLIST,
                so that the caller does not have to keep them around.
                At this point, we must check whether the deleted string
                is one that the user added and should thus be removed
                from the array.  JonN 07-Jun-1992

    HISTORY:
        rustanl     21-Aug-1991     Created
        jonn        07-Jun-1992     Added _slAddedNames to MEMBERSHIP_LM_OBJ

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::DeleteAssocName( const TCHAR * pszName )
{
    UINT i;
    REQUIRE( FindAssocName( pszName, &i ));

    return DeleteAssocName( i );

}  // MEMBERSHIP_LM_OBJ::DeleteAssocName


APIERR MEMBERSHIP_LM_OBJ::DeleteAssocName( UINT i )
{
    UIASSERT( i < QueryCount());

    struct user_info_0 * puiBase = (struct user_info_0 *)QueryBufferPtr();
    UIASSERT( puiBase != NULL );

    UINT cNewTotal = QueryCount() - 1;

    struct user_info_0 * puiDel = puiBase + i ;
    struct user_info_0 * puiLast = puiBase + cNewTotal;

#ifdef WIN32

    ITER_STRLIST itersl( _slAddedNames );
    NLS_STR *pnls = NULL;
    while ( (pnls = itersl.Next()) != NULL )
    {
        if ( puiDel->usri0_name == pnls->QueryPch() )
        {
            pnls = _slAddedNames.Remove( itersl );
            delete pnls;
            pnls = NULL;
            break;
        }
    }

#endif

    *puiDel = *puiLast; // copy entire user_info_0 structure

    SetCount( cNewTotal );

    return NERR_Success;

}  // MEMBERSHIP_LM_OBJ::DeleteAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Creates this ENUM_CALLER_LM_OBJ object from another one

    ENTRY:      eclmobj -   Source of clone operation

    EXIT:       On success, *this will be a clone of eclmobj

    RETURNS:    An API error, which is NERR_Success on success

                Since the NT variant of these buffers can contain
                internal pointers, we must fix these pointers.
                Also, those pointers which point to elements in the
                STRLIST must point to elements in a copy of the
                STRLIST.

    HISTORY:
        jonn        07-Jun-1992     Created

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::W_CloneFrom( const MEMBERSHIP_LM_OBJ & memblmobj )
{
    APIERR err = ENUM_CALLER_LM_OBJ::W_CloneFrom( memblmobj );
    if ( err != NERR_Success )
        return err;

#ifdef WIN32

    _slAddedNames.Clear();

    struct user_info_0 * puiBaseNew = (struct user_info_0 *)QueryBufferPtr();

    UINT i;
    for (i = 0; (err == NERR_Success) && (i < QueryCount()); i++)
    {
        BOOL fFixedPointer = FALSE;
        const TCHAR * pchClonedMemb = QueryAssocName( i );
        ITER_STRLIST itersl( *((STRLIST *) & memblmobj._slAddedNames) );
        NLS_STR *pnlsIter = NULL;
        while (   (err == NERR_Success)
               && ((pnlsIter = itersl.Next()) != NULL)
               && (!fFixedPointer)
              )
        {
            if ( pchClonedMemb == pnlsIter->QueryPch() )
            {

                NLS_STR * pnlsNew = new NLS_STR( *pnlsIter );
                err = ERROR_NOT_ENOUGH_MEMORY;
                if (   pnlsNew == NULL
                    || (err = pnlsNew->QueryError()) != NERR_Success
                    || (err = _slAddedNames.Add( pnlsNew )) != NERR_Success
                   )
                {
                    delete pnlsNew;
                    break;
                }

                puiBaseNew[ i ].usri0_name = (TCHAR *)(pnlsNew->QueryPch());

                fFixedPointer = TRUE;
            }
        }

        // If the string was not in the STRLIST, it must be in the buffer.
        // We must patch it.

        if ( (err == NERR_Success) && (!fFixedPointer) )
        {
            FixupPointer( (TCHAR **)&(puiBaseNew[i].usri0_name), &memblmobj );
        }

    }

#endif

    return err;

}  // MEMBERSHIP_LM_OBJ::W_CloneFrom


/*******************************************************************

    NAME:       USER_MEMB::USER_MEMB

    SYNOPSIS:   USER_MEMB constructor

    ENTRY:      loc -           Location at which all network operations
                                will take place

                pszUser -       Pointer to user name, whose group
                                memberships will be revealed by
                                this class

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

USER_MEMB::USER_MEMB( const LOCATION & loc,
                      const TCHAR     * pszUser )
  : MEMBERSHIP_LM_OBJ( loc, NAMETYPE_GROUP ), // 2nd param: ASSOC.-name type
    CT_NLS_STR(_nlsUser)
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsUser.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( (pszUser != NULL) && (strlenf(pszUser) > 0) )
    {
        err = SetName( pszUser );
        if ( err != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }

}  // USER_MEMB::USER_MEMB


/*******************************************************************

    NAME:       USER_MEMB::~USER_MEMB

    SYNOPSIS:   USER_MEMB destructor

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

USER_MEMB::~USER_MEMB()
{
    // do nothing else

}  // USER_MEMB::~USER_MEMB


/*******************************************************************

    NAME:       USER_MEMB::CallAPI

    SYNOPSIS:   Calls the NetUserGetGroups API to get the groups
                in which the user is a member

    ENTRY:      pBuffer -           Pointer to buffer to be used
                cbBufSize -         Size of buffer pointed to by
                                    pBuffer
                pcEntriesRead -     Pointer to location receiving the
                                    number of entries read

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR USER_MEMB::CallAPI( BYTE ** pBuffer,
                           UINT * pcEntriesRead )
{
    return ::MNetUserGetGroups( QueryServer(),
                               _nlsUser.QueryPch(),
                               0,
                               pBuffer,
                               pcEntriesRead );

}  // USER_MEMB::CallAPI


/*******************************************************************

    NAME:       USER_MEMB::I_WriteInfo

    SYNOPSIS:   Calls NetUserSetGroups to set the group memberships
                of the user

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR USER_MEMB::I_WriteInfo()
{
    return ::MNetUserSetGroups( (TCHAR *)QueryServer(),
                                (TCHAR *)_nlsUser.QueryPch(),
                                0,
                                QueryBufferPtr(),
                                QueryBufferSize(),
                                QueryCount() );

}  // USER_MEMB::I_WriteInfo


/*******************************************************************

    NAME:       USER_MEMB::I_CreateNew

    SYNOPSIS:   Sets up object for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     26-Aug-1991     Created
        o-SimoP     12-Dec-1991     Now new user hasn't any group
********************************************************************/

APIERR USER_MEMB::I_CreateNew()
{
    //  Normally, work is done, and then the parent W_CreateNew is
    //  called.  Here, however, the parent must be called first,
    //  since it will call SetCount.  This method will then make
    //  another call to SetCount to set the count of associated names
    //  appropriately for this class.

    return W_CreateNew();

}  // USER_MEMB::I_CreateNew


/*******************************************************************

    NAME:       USER_MEMB::W_CreateNew

    SYNOPSIS:   Sets up shadow members for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        jonn        05-Sep-1991     Split from I_CreateNew

********************************************************************/

APIERR USER_MEMB::W_CreateNew()
{
    APIERR err = MEMBERSHIP_LM_OBJ::W_CreateNew();
    if ( err != NERR_Success )
        return err;

    err = SetName( NULL );
    if ( err != NERR_Success )
        return err;

    return NERR_Success;

}  // USER_MEMB::W_CreateNew


/**********************************************************\

    NAME:       USER_MEMB::I_ChangeToNew

    SYNOPSIS:   NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
                to NEW status only when a corresponding I_ChangeToNew()
                exists.  The API buffer is the same for new and valid objects,
                so this nethod doesn't have to do much.

    HISTORY:
        JonN        06-Sep-1991     Templated from USER_2
        o-SimoP     12-Dec-1991     Takes a special group away, there
                                    shouldn't be more than one special group
\**********************************************************/

APIERR USER_MEMB::I_ChangeToNew()
{
    UINT i;
    if(    FindAssocName( (TCHAR *)GROUP_SPECIALGRP_USERS, &i )
        || FindAssocName( (TCHAR *)GROUP_SPECIALGRP_ADMINS, &i )
        || FindAssocName( (TCHAR *)GROUP_SPECIALGRP_GUESTS, &i ) )
        DeleteAssocName( i );
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:       USER_MEMB::CloneFrom

    SYNOPSIS:   Clones a USER_MEMB object

    ENTRY:      umemb -         Source of clone operation

    EXIT:       On success, *this is a clone of umemb

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        rustanl     26-Aug-1991     Created

********************************************************************/

APIERR USER_MEMB::CloneFrom( const USER_MEMB & umemb )
{
    //  This class doesn't have an W_CloneFrom method, so this will
    //  call that of the parent class.

    return W_CloneFrom( umemb );

}  // USER_MEMB::CloneFrom


/*******************************************************************

    NAME:       USER_MEMB::QueryName

    SYNOPSIS:   Returns the account name of a user

    EXIT:       Returns a pointer to the account name

    NOTES:      Valid for objects in CONSTRUCTED state, thus no CHECK_OK

    HISTORY:
        jonn    9/05/91         Templated from USER

********************************************************************/

const TCHAR *USER_MEMB::QueryName() const
{
    return _nlsUser.QueryPch();
}


/*******************************************************************

    NAME:       USER_MEMB::SetName

    SYNOPSIS:   Changes the account name of a user

    ENTRY:      new account name

    EXIT:       Returns an API error code

    HISTORY:
        jonn    9/05/91         Templated from USER

********************************************************************/

APIERR USER_MEMB::SetName( const TCHAR * pszAccount )
{
    if ( (pszAccount != NULL) && (strlenf(pszAccount) > UNLEN) )
        return ERROR_INVALID_PARAMETER;
    else
    {
        if ( (pszAccount != NULL) && ( strlenf(pszAccount) > 0 ) )
        {
            // BUGBUG should return some other error
            APIERR err = ::I_MNetNameValidate( NULL, pszAccount, NAMETYPE_USER, 0L );
            if ( err != NERR_Success )
                return err;
        }

        return _nlsUser.CopyFrom( pszAccount );
    }
}


/*******************************************************************

    NAME:       GROUP_MEMB::GROUP_MEMB

    SYNOPSIS:   GROUP_MEMB constructor

    ENTRY:      loc -           Location at which all network operations
                                will take place

                pszGroup -      Pointer to group name, whose user
                                members will be revealed by
                                this class

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

GROUP_MEMB::GROUP_MEMB( const LOCATION & loc,
                        const TCHAR     * pszGroup )
  : MEMBERSHIP_LM_OBJ( loc, NAMETYPE_USER ), // 2nd param: ASSOC.-name type
    CT_NLS_STR(_nlsGroup)
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsGroup.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( (pszGroup != NULL) && (strlenf(pszGroup) > 0) )
    {
        err = SetName( pszGroup );
        if ( err != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }

}  // GROUP_MEMB::GROUP_MEMB


/*******************************************************************

    NAME:       GROUP_MEMB::~GROUP_MEMB

    SYNOPSIS:   GROUP_MEMB destructor

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

GROUP_MEMB::~GROUP_MEMB()
{
    // do nothing else

}  // GROUP_MEMB::~GROUP_MEMB


/*******************************************************************

    NAME:       GROUP_MEMB::CallAPI

    SYNOPSIS:   Calls the NetGroupGetUsers API to retrieve the group
                members of the group

    ENTRY:      pBuffer -           Pointer to buffer to be used
                pcEntriesRead -     Pointer to location receiving the
                                    number of entries read

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR GROUP_MEMB::CallAPI( BYTE ** pBuffer,
                            UINT * pcEntriesRead )
{
    // BUGBUG pcTotalAvail should not needed to cast
    return ::MNetGroupGetUsers( QueryServer(),
                                _nlsGroup.QueryPch(),
                                0,
                                pBuffer,
                                pcEntriesRead);

}  // GROUP_MEMB::CallAPI


/*******************************************************************

    NAME:       GROUP_MEMB::I_WriteInfo

    SYNOPSIS:   Calls NetGroupSetUsers to set the members of this
                group

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR GROUP_MEMB::I_WriteInfo()
{
    return ::MNetGroupSetUsers( (TCHAR *)QueryServer(),
                                (TCHAR *)_nlsGroup.QueryPch(),
                                0,
                                QueryBufferPtr(),
                                QueryBufferSize(),
                                QueryCount());

}  // GROUP_MEMB::I_WriteInfo


/*******************************************************************

    NAME:       GROUP_MEMB::I_CreateNew

    SYNOPSIS:   Sets up object for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        JonN        14-Sep-1991     Templated from GROUP_1

********************************************************************/

APIERR GROUP_MEMB::I_CreateNew()
{
    APIERR err = W_CreateNew();
    if ( err != NERR_Success )
        return err;

    return NERR_Success;

}  // GROUP_MEMB::I_CreateNew


/*******************************************************************

    NAME:       GROUP_MEMB::W_CreateNew

    SYNOPSIS:   Sets up shadow members for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        JonN        14-Sep-1991     Templated from GROUP_1

********************************************************************/

APIERR GROUP_MEMB::W_CreateNew()
{
    APIERR err = MEMBERSHIP_LM_OBJ::W_CreateNew();
    if ( err != NERR_Success )
        return err;

    err = SetName( NULL );
    if ( err != NERR_Success )
        return err;

    return NERR_Success;

}  // GROUP_MEMB::W_CreateNew


/**********************************************************\

    NAME:       GROUP_MEMB::I_ChangeToNew

    SYNOPSIS:   NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
                to NEW status only when a corresponding I_ChangeToNew()
                exists.  The API buffer is the same for new and valid objects,
                so this nethod doesn't have to do much.

    HISTORY:
        JonN        14-Sep-1991     Templated from GROUP_1

\**********************************************************/

APIERR GROUP_MEMB::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:       GROUP_MEMB::CloneFrom

    SYNOPSIS:   Clones a GROUP_MEMB object

    ENTRY:      gmemb -         Source of clone operation

    EXIT:       On success, *this is a clone of gmemb

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        rustanl     26-Aug-1991     Created

********************************************************************/

APIERR GROUP_MEMB::CloneFrom( const GROUP_MEMB & gmemb )
{
    //  This class doesn't have an W_CloneFrom method, so this will
    //  call that of the parent class.

    return W_CloneFrom( gmemb );

}  // GROUP_MEMB::CloneFrom


/*******************************************************************

    NAME:       GROUP_MEMB::QueryName

    SYNOPSIS:   Returns the account name of a group

    EXIT:       Returns a pointer to the account name

    NOTES:      Valid for objects in CONSTRUCTED state, thus no CHECK_OK

    HISTORY:
        jonn    10/11/91        Templated from USER_MEMB

********************************************************************/

const TCHAR *GROUP_MEMB::QueryName() const
{
    return _nlsGroup.QueryPch();
}


/*******************************************************************

    NAME:       GROUP_MEMB::SetName

    SYNOPSIS:   Changes the account name of a group

    ENTRY:      new account name

    EXIT:       Returns an API error code

    HISTORY:
        jonn    10/11/91        Templated from USER_MEMB

********************************************************************/

APIERR GROUP_MEMB::SetName( const TCHAR * pszAccount )
{
    if ( (pszAccount != NULL) && (strlenf(pszAccount) > GNLEN) )
        return ERROR_INVALID_PARAMETER;
    else
    {
        if ( (pszAccount != NULL) && ( strlenf(pszAccount) > 0 ) )
        {
            // BUGBUG should return some other error
            APIERR err = ::I_MNetNameValidate( NULL, pszAccount,
                NAMETYPE_GROUP, 0L );
            if ( err != NERR_Success )
                return err;
        }

        return _nlsGroup.CopyFrom( pszAccount );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmogroup.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
 *  lmogroup.cxx
 *
 *  HISTORY:
 *	o-SimoP	12-Aug-1991	Created, cloned from lmouser.cxx
 *	o-SimoP 20-Apr-91	CR changes, attended by ChuckC,	
 *				ErichCh, RustanL, JonN and me
 *	terryk	07-Oct-91	type changes for NT
 *	KeithMo	10/8/91		Now includes LMOBJP.HXX.
 *	jonn	09-Oct-91	Added GROUP_0 and GROUP_1
 *	terryk	17-Oct-91	WIN 32 conversion
 *	terryk	21-Oct-91	cast _pBuffer variable to TCHAR *
 *	jonn	31-Oct-91	Removed SetBufferSize
 *
 */
#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME:	GROUP::GROUP

    SYNOPSIS:	constructor for the GROUP object

    ENTRY:	pszGroup -	account name

		pszLocation -	server or domain name to execute on;
				default (NULL) means the local computer
		OR:
		loctype -	type of location, local computer or
				logon domain
		OR:
		loc -		location, local computer or logon domain

    NOTE:	Constructors differs only in param that is passed to
    		LOC_LM_OBJ

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

GROUP::GROUP(const TCHAR *pszGroup, const TCHAR *pszLocation)
	: LOC_LM_OBJ( pszLocation ),
	  _nlsGroup()
{

    if ( QueryError() != NERR_Success )
	return;

    CtAux( pszGroup );
}


GROUP::GROUP(const TCHAR *pszGroup, enum LOCATION_TYPE loctype)
	: LOC_LM_OBJ( loctype ),
	  _nlsGroup()
{

    if ( QueryError() != NERR_Success )
	return;
	
    CtAux( pszGroup );
}


GROUP::GROUP(const TCHAR *pszGroup, const LOCATION & loc )
	: LOC_LM_OBJ( loc ),
	  _nlsGroup()
{

    if ( QueryError() != NERR_Success )
	return;
	
    CtAux( pszGroup );
}



/*******************************************************************

    NAME:	GROUP::CtAux

    SYNOPSIS:	Worker function for constructors

    HISTORY:
    	o-SimoP	12-Aug-1991	Created
		
********************************************************************/

VOID GROUP::CtAux( const TCHAR * pszGroup )
{
    APIERR err = _nlsGroup.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    err = SetName( pszGroup );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }
}


/*******************************************************************

    NAME:	GROUP::~GROUP

    SYNOPSIS:	Destructor for GROUP class

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

GROUP::~GROUP()
{
}


/*******************************************************************

    NAME:	GROUP::W_CloneFrom

    SYNOPSIS:	Copies information on the group

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP::W_CloneFrom( const GROUP & group )
{
    APIERR err = LOC_LM_OBJ::W_CloneFrom( group );
    if ( err != NERR_Success )
	return err;

    return _nlsGroup.CopyFrom( group.QueryName() );
}


/*******************************************************************

    NAME:	GROUP::QueryName

    SYNOPSIS:	Returns the name of the group

    EXIT:	Returns a pointer to the group name

    NOTES:	Will be the same as the account name supplied at
		construction.

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

const TCHAR *GROUP::QueryName() const
{
    return _nlsGroup.QueryPch();
}


/*******************************************************************

    NAME:	GROUP::SetName

    SYNOPSIS:	Changes the name of the group

    ENTRY:	new group name

    EXIT:	Returns an API error code

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

APIERR GROUP::SetName( const TCHAR * pszGroup )
{
    APIERR err;	
    if ( pszGroup != NULL && strlenf( pszGroup ) != 0 )
    {
	err = ::I_MNetNameValidate(
		NULL,
		pszGroup,
		NAMETYPE_GROUP,
		0L );
        if ( err != NERR_Success )
	    return err;
    }

// BUGBUG use NLS_STR safe copy
    _nlsGroup = pszGroup;
    err = _nlsGroup.QueryError();
    if( err != NERR_Success )
	_nlsGroup.Reset();
    return err;
}


/*******************************************************************

    NAME:	GROUP::I_Delete

    SYNOPSIS:	Deletes the group (calls NET API)

    RETURNS:	Returns an API error code

    HISTORY:	
    	o-SimoP		13-Aug-91	Created
********************************************************************/

APIERR GROUP::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    return ::MNetGroupDel( QueryServer(), (TCHAR *)QueryName() );
}


/*******************************************************************

    NAME:	GROUP_1::GROUP_1

    SYNOPSIS:	constructor for the GROUP_1 object

    ENTRY:	pszGroup -	account name

		pszLocation -	server or domain name to execute on;
				default (NULL) means the local computer
		OR:
		loctype -	type of location, local computer or
				logon domain
		OR:
		loc -		location, local computer or logon domain

    NOTE:	Constructors differs only in param that is passed to
    		LOC_LM_OBJ

    HISTORY:
    	JonN	09-Oct-1991	Created

********************************************************************/

GROUP_1::GROUP_1(const TCHAR *pszGroup, const TCHAR *pszLocation)
    : GROUP_0( pszGroup, pszLocation ),
      _nlsComment()
{
    CtAux();
}

GROUP_1::GROUP_1(const TCHAR *pszGroup, enum LOCATION_TYPE loctype)
    : GROUP_0( pszGroup, loctype ),
      _nlsComment()
{
    CtAux();
}

GROUP_1::GROUP_1(const TCHAR *pszGroup, const LOCATION & loc)
    : GROUP_0( pszGroup, loc ),
      _nlsComment()
{
    CtAux();
}

GROUP_1::~GROUP_1()
{
}

VOID GROUP_1::CtAux()
{
    APIERR err = _nlsComment.QueryError();
    if ( err != NERR_Success )
	ReportError( err );
}



/*******************************************************************

    NAME:	GROUP_1::I_GetInfo

    SYNOPSIS:	Gets information about the group

    ENTRY:

    EXIT:	Returns a standard LANMAN error code

    HISTORY:
	jonn	    09-Oct-1991     Templated from USER_11
	jonn	    31-Oct-1991     Removed SetBufferSize

********************************************************************/

APIERR GROUP_1::I_GetInfo()
{

    // BUGBUG who validates group name?

    BYTE *pBuffer = NULL;
    APIERR err = ::MNetGroupGetInfo ( QueryServer(), (TCHAR *)QueryName(), 1,
			&pBuffer );

    if ( err != NERR_Success )
	return err;

    SetBufferPtr( pBuffer );

    struct group_info_1 *lpgi1 = (struct group_info_1 *)QueryBufferPtr();
    UIASSERT( lpgi1 != NULL );


    if (   ((err = SetComment( lpgi1->grpi1_comment )) != NERR_Success)
       )
    {
	return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	GROUP_1::I_WriteInfo

    SYNOPSIS:	Writes information about the group

    EXIT:	Returns API error code

    HISTORY:
	jonn	    09-Oct-91	    Created

********************************************************************/

APIERR GROUP_1::I_WriteInfo()
{
    APIERR err = W_Write();
    if ( err != NERR_Success )
	return err;

    return ::MNetGroupSetInfo ( QueryServer(), (TCHAR *)QueryName(), 1,
				QueryBufferPtr(),
				sizeof(struct group_info_1 ), PARMNUM_ALL );
}



APIERR GROUP_1::I_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = W_CreateNew()) != NERR_Success )
	|| ((err = ResizeBuffer( sizeof(group_info_1) )) != NERR_Success )
	|| ((err = ClearBuffer()) != NERR_Success )
       )
    {
	return err;
    }

    return NERR_Success;

}

APIERR GROUP_1::I_WriteNew()
{

    APIERR err = W_Write();
    if ( err != NERR_Success )
	return err;

/*
    We pass size sizeof(struct group_info_1) instead of QueryBufferSize()
    to force all pointers to point outside of the buffer.
*/

    return ::MNetGroupAdd ( QueryServer(), 1,
			    QueryBufferPtr(),
			    sizeof( struct group_info_1 ) );
}


/**********************************************************\

    NAME:	GROUP_1::I_ChangeToNew

    SYNOPSIS:	NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
		to NEW status only when a corresponding I_ChangeToNew()
		exists.  The group_info_1 API buffer is the same for new
		and valid objects, so this nethod doesn't have to do
		much.

    HISTORY:
   	JonN	    09-Oct-1991     Created

\**********************************************************/

APIERR GROUP_1::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:	GROUP_1::CloneFrom

    SYNOPSIS:	Copies information on the group

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP_1::CloneFrom( const GROUP_1 & group1 )
{
    APIERR err = W_CloneFrom( group1 );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("GROUP_1::W_CloneFrom failed with error code ") );
	UIDEBUGNUM( (LONG)err );
	UIDEBUG( SZ("\r\n") );

	ReportError( err ); // BUGBUG make unconstructed here??
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	GROUP_1::W_Write

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer

    EXIT:	Returns API error code

    HISTORY:
	jonn	    10/9/91	    Created

********************************************************************/

APIERR GROUP_1::W_Write()
{
    struct group_info_1 *lpgi1 = (struct group_info_1 *)QueryBufferPtr();
    ASSERT( lpgi1 != NULL );
    ASSERT( strlenf(QueryName()) <= GNLEN );
    // grpi1_name is a buffer rather than a pointer
    COPYTOARRAY(lpgi1->grpi1_name, (TCHAR *)QueryName() );
    lpgi1->grpi1_comment = (TCHAR *)QueryComment();

    return NERR_Success;
}


/*******************************************************************

    NAME:	GROUP_1::W_CreateNew

    SYNOPSIS:	initializes private data members for new object

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP_1::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = GROUP::W_CreateNew()) != NERR_Success )
	|| ((err = SetComment( NULL )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("GROUP_1::W_CreateNew failed\r\n") );
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	GROUP_1::W_CloneFrom

    SYNOPSIS:	Copies information on the group

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP_1::W_CloneFrom( const GROUP_1 & group1 )
{
    APIERR err = NERR_Success;
    if (   ((err = GROUP::W_CloneFrom( group1 )) != NERR_Success )
	|| ((err = SetComment( group1.QueryComment() )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("GROUP_1::W_CloneFrom failed\r\n") );
	return err;
    }

    return NERR_Success;
}



APIERR GROUP_1::SetComment( const TCHAR * pszComment )
{
    return _nlsComment.CopyFrom( pszComment );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmomisc.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    LM_MISC.CXX
	Misc. objects

	LOGON_USER - wrapper class which handles NetWkstaSetUID2() net
	    api call
	TIME_DAY_SERVER - wrapper class which handles NetRemoteTOD() net
	    api
	LM_MESSAGE - wrapper class which handles NetMessageBuffSend()
	    net api

    FILE HISTORY:
	terryk	    6-Sep-91	    Created
	terryk	    11-Sep-91	    Code review changes. Attend: jimh
				    yi-hsins jonn
	terryk	    20-Sep-91	    Move LOGON_USER from lmouser.cxx to here
	terryk	    07-Oct-91	    type changes for NT
	KeithMo	    08-Oct-91	    Now includes LMOBJP.HXX.
	terryk	    17-Oct-91	    WIN 32 conversion
	terryk	    21-Oct-91	    remove LOGON_USER from NT

*/

#include "pchlmobj.hxx"  // Precompiled header


#ifndef WIN32

/*******************************************************************

    NAME:	LOGON_USER::LOGON_USER

    SYNOPSIS:	Constructor for the logon user object.

    ENTRY:	TCHAR * pszUsername - user name
		TCHAR * pszServername

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

LOGON_USER::LOGON_USER( const TCHAR * pszUsername, const TCHAR * pszDomain )
    : BASE( ),
    _state( INVALID_STATE ),
    _fValid( TRUE ),
    _pszPasswd( NULL ),
    _buffer( 0 ),
    _nlsDomain( pszDomain ),
    _nlsUsername( pszUsername )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
    APIERR err;

    if ((( err = _buffer.QueryError()) != NERR_Success ) ||
	(( err = _nlsDomain.QueryError()) != NERR_Success ) ||
	(( err = _nlsUsername.QueryError()) != NERR_Success ))
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }

    // CheckName validation
    if ((( _nlsUsername.strlen() != 0 ) && ( err = ::I_MNetNameValidate(
	NULL, (TCHAR *)_nlsUsername.QueryPch(), NAMETYPE_USER, 0 )) !=
	NERR_Success ))
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }
    if ((( _nlsDomain.strlen() != 0 ) && ( err =
	::I_MNetNameValidate( NULL, (TCHAR *)_nlsDomain.QueryPch(),
	NAMETYPE_DOMAIN, 0 )) != NERR_Success ))
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }
}

// BUGBUG - we need to change it for NT
#define USER_LOGON_INFO_SIZE ( sizeof( struct user_logon_info_1 ) + \
	MAX_PATH + DNLEN + PATHLEN + 3 )

/*******************************************************************

    NAME:	LOGON_USER::Logon

    SYNOPSIS:	Logon the user.

    ENTRY:	TCHAR * pszPasswd
		APIERR *pLogonRetCode - return the logon code within the
		    usr_logoninfo_1 object

    RETURNS:	APIERR - NERR_Success if succeed.

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR LOGON_USER::Logon( const TCHAR * pszPasswd, APIERR *pLogonRetCode )
{
    UINT cTotalAvail;

    _fValid = FALSE;
    _state = LOGGED_ON;
    APIERR err = ::I_MNetNameValidate( NULL, pszPasswd, NAMETYPE_PASSWORD, 0 );
    if ( err != NERR_Success )
    {
	return NERR_BadPassword;
    }
    _pszPasswd = ( TCHAR * )pszPasswd;
    err = _buffer.Resize( USER_LOGON_INFO_SIZE );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("LOGON_USER error: cannot resize buffer.\n\r") );
	return err;
    }
    err = ::MNetWkstaSetUID( NULL, (TCHAR *)_nlsDomain.QueryPch(),
	(TCHAR *)_nlsUsername.QueryPch(), _pszPasswd, SZ(""), 0, 1,
	_buffer.QueryPtr(), _buffer.QuerySize(), &cTotalAvail );
    *pLogonRetCode = QueryLogonInfo()->usrlog1_code;
    if (( err == NERR_Success ) || ( *pLogonRetCode == NERR_Success ))
    {
	_fValid = TRUE;
    }
    return err;
}

/*******************************************************************

    NAME:	LOGON_USER::Logoff

    SYNOPSIS:	Logoff the user.

    ENTRY:	UINT uslogoff_level - these are 4 level of
		logoff
		WKSTA_NOFORCE - log off the user if the user has no
		    connections to redirected resources. Do not log off if
		    the user has connections.
		WKSTA_FORCE - log off the user with connections to redirected
		    resources. Do not log off if the user has pending
		    activities on redirected resources, or if the user uses
		    the resource as the current drive.
		WKSTA_LOTS_OF_FORCE - log off the user with connections or
		    pending activities on redirected resources. Do not log
		    off if a user process uses the resource as the current
		    drive.
		WKSTA_MAX_FORCE - log off the user under any conditions.
		APIERR *pLogoffRetCode - return code for the
		    usr_logoffInfo_1 object

    RETURNS:	APIERR - NERR_Success if the function encountered no
		errors.

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR LOGON_USER::Logoff( UINT uslogoff_level, APIERR *pLogoffRetCode )
{
    UINT cTotalAvail;
    APIERR err;

    _state = LOGGED_OFF;
    _fValid = FALSE;
    err = _buffer.Resize( sizeof( struct user_logoff_info_1 ));
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("LOGON_USER error: cannot resize buffer.\n\r") );
	return err;
    }
    err = ::MNetWkstaSetUID( NULL, NULL, NULL, NULL, SZ(""),
	uslogoff_level, 1, _buffer.QueryPtr(),
	_buffer.QuerySize(), &cTotalAvail );
    *pLogoffRetCode = QueryLogoffInfo()->usrlogf1_code;
    if (( err == NERR_Success ) || ( *pLogoffRetCode == NERR_Success ))
    {
	_fValid = TRUE;
    }
    return err;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogonInfo

    SYNOPSIS:	return the user_logon_info_1 struct pointer

    RETURNS:	return the user_logon_info_1 struct pointer

    NOTES:	It will also check the state and see whether the object
		is in logon state or not.

    HISTORY:
		terryk	9-Sep-91	Created

********************************************************************/

struct user_logon_info_1 * LOGON_USER::QueryLogonInfo() const
{
    UIASSERT( _state == LOGGED_ON );
    return  ( struct user_logon_info_1 *) _buffer.QueryPtr();
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogoffInfo

    SYNOPSIS:	return the user_logoff_info_1 struct pointer

    RETURNS:	return the user_logoff_info_1 struct pointer

    NOTES:	It will also check the state and see whether the object
		is in logoff state or not.

    HISTORY:
		terryk	9-Sep-91	Created

********************************************************************/

struct user_logoff_info_1 * LOGON_USER::QueryLogoffInfo() const
{
    UIASSERT( _state == LOGGED_OFF );
    return  ( struct user_logoff_info_1 *) _buffer.QueryPtr();
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPriv

    SYNOPSIS:	return the user's privilege level

    RETURNS:	UINT level.
		   It specifies the user's privilege level. The ACCESS.H
		   header file defines these possible values:
		   CODE			VALUE	MEANING
		   USER_PRIV_GUEST	0	Guest privilege
		   USER_PRIV_USER	1	User privilege
		   USER_PRIV_ADMIN	2	Admin privilege
					10	ERROR

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

UINT LOGON_USER::QueryPriv() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 10;
    }
    return QueryLogonInfo()->usrlog1_priv;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPasswdAge

    SYNOPSIS:	return the time since the user password was changed

    RETURNS:	LONG time - the time specifies in seconds
		-1 if the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

LONG LOGON_USER::QueryPasswdAge() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return -1;
    }
    return QueryLogonInfo()->usrlog1_password_age;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPasswdCanChange

    SYNOPSIS:	return the specifies time when the user is allowed to
		change the password.

    RETURNS:	ULONG userlog1_pw_can_change. This value is stored as
		the number of seconds elapsed since 00:00:00, January 1, 1970.
		A value of -1 means the user can never change the
		password.
		A value of 0 means object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryPasswdCanChange() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 0;
    }
    return QueryLogonInfo()->usrlog1_pw_can_change;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPasswdMustChange

    SYNOPSIS:	return the time when the user must change the password.

    RETURNS:	ULONG userlog1_pw_must_change. This value is stored as
		the number of seconds elapsed since 00:00:00, January 1, 1970.
		A value of 0 means object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryPasswdMustChange() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 0;
    }
    return QueryLogonInfo()->usrlog1_pw_must_change;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogonComputer

    SYNOPSIS:	return the computer where the user is logged on

    RETURNS:	TCHAR * computer name
		NULL means the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

const TCHAR * LOGON_USER::QueryLogonComputer() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return NULL;
    }
    return QueryLogonInfo()->usrlog1_computer;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogonDomain

    SYNOPSIS:	return the domain where the user is logged on

    RETURNS:	TCHAR * domain name
		NULL means the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

const TCHAR * LOGON_USER::QueryLogonDomain() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return NULL;
    }
    return QueryLogonInfo()->usrlog1_domain;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogoffDuration

    SYNOPSIS:	return the logon return code.

    RETURNS:	APIERR err - apierr code. NERR_Success for succeed.
		-1 means the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryLogoffDuration() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return ((ULONG)-1);
    }
    return QueryLogoffInfo()->usrlogf1_duration;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogoffNumLogons

    SYNOPSIS:	return the logon return code.

    RETURNS:	APIERR err - apierr code. NERR_Success for succeed.
		0 means the objects in in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryLogoffNumLogons() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 0;
    }
    return QueryLogoffInfo()->usrlogf1_num_logons;
}

#endif

/*******************************************************************

    NAME:	LM_MESSAGE::LM_MESSAGE

    SYNOPSIS:	message class constructor

    ENTRY:	one of the following parameters
		    enum LOCATION_TYPE loctype;
		    TCHAR * pszLocation;
		    LOCATION & loc;

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

LM_MESSAGE::LM_MESSAGE( enum LOCATION_TYPE loctype )
    : LOC_LM_OBJ( loctype )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

LM_MESSAGE::LM_MESSAGE( const TCHAR * pszLocation )
    : LOC_LM_OBJ( pszLocation )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

LM_MESSAGE::LM_MESSAGE( LOCATION & loc )
    : LOC_LM_OBJ( loc )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

/*******************************************************************

    NAME:	LM_MESSAGE::SendBuffer

    SYNOPSIS:	send a buffer of data to the recipient

    ENTRY:	const TCHAR * pszRecipient
		one of the followings:
		BUFFER & buffer;
		OR
		const TCHAR * pbBuffer;
		UINT cbBufferSize;

    RETURNS:	APIERR - NERR_Success for succeed.

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR LM_MESSAGE::SendBuffer( const TCHAR * pszRecipient, const BUFFER & buffer )
{
    UIASSERT( buffer.QueryError() == NERR_Success );
    return ::MNetMessageBufferSend( QueryServer(), (TCHAR *)pszRecipient,
	buffer.QueryPtr(), buffer.QuerySize());
}

APIERR LM_MESSAGE::SendBuffer( const TCHAR * pszRecipient, const TCHAR *
    pbBuffer, UINT cbBuffer )
{
    UIASSERT( pbBuffer != NULL );
    return ::MNetMessageBufferSend( QueryServer(), (TCHAR *)pszRecipient,
	(BYTE *)pbBuffer, cbBuffer );
}

/*******************************************************************

    NAME:	TIME_OF_DAY::TIME_OF_DAY

    SYNOPSIS:	constructor. This object will get the server time and
		date information.

    ENTRY:	One of the followings:
		const TCHAR * pszLocation
		enum LOCATION_TYPE loctype
		LOCATION & loc

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

TIME_OF_DAY::TIME_OF_DAY( const TCHAR * pszLocation )
    : LOC_LM_OBJ( pszLocation ),
    _ptodi( NULL )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

TIME_OF_DAY::TIME_OF_DAY( LOCATION & loc )
    : LOC_LM_OBJ( loc ),
    _ptodi( NULL )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

TIME_OF_DAY::TIME_OF_DAY( enum LOCATION_TYPE loctype )
    : LOC_LM_OBJ( loctype ),
    _ptodi( NULL )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

/*******************************************************************

    NAME:	TIME_OF_DAY::~TIME_OF_DAY

    SYNOPSIS:	destructor - free up the memory

    HISTORY:
		terryk	15-Oct-91	Created

********************************************************************/

TIME_OF_DAY::~TIME_OF_DAY()
{
    ::MNetApiBufferFree( (BYTE **)&_ptodi );
}


/*******************************************************************

    NAME:	TIME_OF_DAY::I_GetInfo

    SYNOPSIS:	Worker function for GetInfo. It will actually set up the
		connection and get the time/day information.

    RETURNS:	APIERR - NERR_Success for succeed

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR TIME_OF_DAY::I_GetInfo()
{
    ::MNetApiBufferFree( (BYTE **)&_ptodi );

    return ::MNetRemoteTOD( QueryServer(), (BYTE **)&_ptodi );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmomod.cxx ===
/**********************************************************************/
/**           Microsoft LAN Manager                                  **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
 * lmomod.cxx
 *
 * History
 *  o-SimoP 6/12/91     Created
 *  o-SimoP 7/02/91     Code Review changes and
 *                      changes in LOCATION obj
 *  terryk  10/7/91	type changes for NT
 *  KeithMo 10/8/91	Now includes LMOBJP.HXX.
 *  terryk  10/17/91	WIN 32 conversion
 *  terryk  10/21/91	change UINT to USHORT2ULONG
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


/**********************************************************\

   NAME:       USER_MODALS::USER_MODALS

   SYNOPSIS:   constructor for the user_modals class

   ENTRY:      pszDomain - name of domain or server

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

USER_MODALS::USER_MODALS( const TCHAR * pszDomain )
    :   _loc( pszDomain )
{
    if( IsUnconstructed() )
        return;

}  // USER_MODALS::USER_MODALS



/**********************************************************\

   NAME:       USER_MODALS::GetInfo

   SYNOPSIS:   get information about the user_modals

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

APIERR USER_MODALS::GetInfo( VOID )
{
    if ( IsUnconstructed() )
    {
        DBGEOL( "USER_MODALS::GetInfo: IsUnconstructed" );
        return ERROR_GEN_FAILURE;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err = _loc.QueryError();
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS::GetInfo: _loc.QueryError error " << err );
        return err;
    }

    user_modals_info_0 *pModals = NULL;
    err = ::MNetUserModalsGet ( _loc.QueryServer(),
            0, (BYTE **)&pModals );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS::GetInfo: error in NUModalsGet " << err );
	::MNetApiBufferFree( (BYTE **)&pModals );
        return err;
    }

    _uMinPasswdLen  = (UINT)pModals->usrmod0_min_passwd_len;
    _ulMaxPasswdAge = pModals->usrmod0_max_passwd_age;
    _ulMinPasswdAge = pModals->usrmod0_min_passwd_age;
    _ulForceLogoff  = pModals->usrmod0_force_logoff;
    _uPasswdHistLen = (UINT)pModals->usrmod0_password_hist_len;
    ::MNetApiBufferFree( (BYTE **)&pModals );

    MakeValid();

    return NERR_Success;

}  // USER_MODALS::GetInfo


/**********************************************************\

   NAME:       USER_MODALS::WriteInfo

   SYNOPSIS:   Write information about the user_modals

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

APIERR USER_MODALS::WriteInfo( VOID )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    if( _ulMinPasswdAge > _ulMaxPasswdAge )
    {
        DBGEOL( "USER_MODALS::WriteInfo: PasswdMinAge > MaxAge" );
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    user_modals_info_0 modals;

    modals.usrmod0_min_passwd_len = _uMinPasswdLen;
    modals.usrmod0_max_passwd_age = _ulMaxPasswdAge;
    modals.usrmod0_min_passwd_age = _ulMinPasswdAge;
    modals.usrmod0_force_logoff = _ulForceLogoff;
    modals.usrmod0_password_hist_len = _uPasswdHistLen;
    // where is this one coming from??
    //modals.usrmod0_lockout_count = 0;

    APIERR err = ::MNetUserModalsSet ( _loc.QueryServer(),
           0, (BYTE *)&modals,
           sizeof( modals ), PARMNUM_ALL );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS::WriteInfo: error " << err );
    }

    return err;

}  // USER_MODALS::WriteInfo


/**********************************************************\

   NAME:       USER_MODALS::QueryName

   SYNOPSIS:   query the user_modals name

   RETURNS:    if ok returns pointer to name (given in
               constructor).
               otherwise NULL.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

const TCHAR * USER_MODALS::QueryName( VOID ) const
{
    CHECK_VALID( NULL );

    return _loc.QueryName();
}  // USER_MODALS::QueryName



/**********************************************************\

   NAME:       USER_MODALS::QueryMinPasswdLen

   SYNOPSIS:   get information about the min passwd len

   RETURNS:    returns minpasswdlen if ok.
               otherwise -1.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

UINT USER_MODALS::QueryMinPasswdLen( VOID ) const
{
    CHECK_VALID( (UINT)-1 );

    return _uMinPasswdLen;
}  // USER_MODALS::QueryMinPasswdLen



/**********************************************************\

   NAME:       USER_MODALS::QueryMaxPasswdAge

   SYNOPSIS:   get information about the max passwd age

   RETURNS:    maxpasswdage if ok.
               otherwise 0.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

ULONG USER_MODALS::QueryMaxPasswdAge( VOID ) const
{
    CHECK_VALID( 0 );

    return _ulMaxPasswdAge;
}  // USER_MODALS::QueryMaxPasswdAge


/**********************************************************\

   NAME:       USER_MODALS::QueryMinPasswdAge

   SYNOPSIS:   get information about the min passwd age

   RETURNS:    Minpasswdage if ok.
               otherwise -1.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

ULONG USER_MODALS::QueryMinPasswdAge( VOID ) const
{
    CHECK_VALID((ULONG) -1 );

    return _ulMinPasswdAge;
}  // USER_MODALS::QueryMinPasswdAge


/**********************************************************\

   NAME:       USER_MODALS::QueryForceLogoff

   SYNOPSIS:   get information about the force logoff time

   RETURNS:    force logoff time if ok.
               otherwise 0.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

ULONG USER_MODALS::QueryForceLogoff( VOID ) const
{
    CHECK_VALID( 0 );

    return _ulForceLogoff;
}  // USER_MODALS::QueryForceLogoff



/**********************************************************\

   NAME:       USER_MODALS::QueryPasswdHistLen

   SYNOPSIS:   get information about the passwd history lenght

   RETURNS:    passwd history lenght if ok.
               otherwise -1.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

UINT USER_MODALS::QueryPasswdHistLen( VOID ) const
{
    CHECK_VALID( (UINT)-1 );

    return _uPasswdHistLen;
}  // USER_MODALS::QueryPasswdHistLen




/**********************************************************\

   NAME:       USER_MODALS::SetMinPasswdLen

   SYNOPSIS:   set information about the USER_MODALS object

   RETURNS:    ERROR_GEN_FAILURE if USER_MODALS obj not valid
               ERROR_INVALID_PARAM if input param invalid
               NERR_Success if ok.

   HISTORY:
     o-SimoP    13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetMinPasswdLen( UINT uMinLen )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    if( uMinLen > PWLEN )
    {
        DBGEOL( "USER_MODALS::SetMinPasswdLen: uMinLen > PWLEN" );
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    _uMinPasswdLen = uMinLen;
    return NERR_Success;

} // USER_MODALS::SetMinPasswdLen


/**********************************************************\

    NAME:       USER_MODALS::SetMaxPasswdAge

    SYNOPSIS:   set the max password age

    HISTORY:
        o-SimoP 13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetMaxPasswdAge( ULONG ulMaxAge )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    if( ulMaxAge < ONE_DAY )
    {
        DBGEOL( "USER_MODALS::SetMaxPasswdAge: ulMaxAge < ONE_DAY" );
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    _ulMaxPasswdAge = ulMaxAge;
    return NERR_Success;

} // USER_MODALS::SetMaxPasswdAge


/**********************************************************\

    NAME:       USER_MODALS::SetMinPasswdAge

    SYNOPSIS:   set the min password age

    HISTORY:
        o-SimoP 13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetMinPasswdAge( ULONG ulMinAge )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _ulMinPasswdAge = ulMinAge;
    return NERR_Success;

} // USER_MODALS::SetMinPasswdAge


/**********************************************************\

    NAME:       USER_MODALS::SetForceLogoff

    SYNOPSIS:   set the force logoff

    HISTORY:
        o-SimoP 13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetForceLogoff( ULONG ulForceLogoff )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _ulForceLogoff = ulForceLogoff;
    return NERR_Success;

} // USER_MODALS::SetForceLogoff


/**********************************************************\

    NAME:       USER_MODALS::SetPasswdHistLen

    SYNOPSIS:   set the password history len

    HISTORY:
        o-SimoP 13-Jun-1991 Created
        JonN    17-Jun-1994 Removed DEF_MAX_PWHIST limitation -- this was
                            always meant to be a default, not an upper limit

\**********************************************************/

APIERR  USER_MODALS::SetPasswdHistLen( UINT uHistLen )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _uPasswdHistLen = uHistLen;
    return NERR_Success;

} // USER_MODALS::SetPasswdHistLen




/**********************************************************\

   NAME:       USER_MODALS_3::USER_MODALS_3

   SYNOPSIS:   constructor for the USER_MODALS_3 class

   ENTRY:      pszDomain - name of domain or server

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

USER_MODALS_3::USER_MODALS_3( const TCHAR * pszDomain )
    :   _loc( pszDomain )
{
    if( IsUnconstructed() )
        return;

}  // USER_MODALS_3::USER_MODALS_3



/**********************************************************\

   NAME:       USER_MODALS_3::GetInfo

   SYNOPSIS:   get information about the USER_MODALS_3

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR USER_MODALS_3::GetInfo( VOID )
{
    if ( IsUnconstructed() )
    {
        DBGEOL( "USER_MODALS_3::GetInfo: IsUnconstructed" );
        return ERROR_GEN_FAILURE;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err = _loc.QueryError();
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS_3::GetInfo: _loc error" << err );
        return err;
    }

    USER_MODALS_INFO_3 *pModals = NULL;
    err = ::MNetUserModalsGet ( _loc.QueryServer(),
            3, (BYTE **)&pModals );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS_3::GetInfo: NUModalsGet error " << err );
	::MNetApiBufferFree( (BYTE **)&pModals );
        return err;
    }

    _dwDuration    = pModals->usrmod3_lockout_duration;
    _dwObservation = pModals->usrmod3_lockout_observation_window;
    _dwThreshold   = pModals->usrmod3_lockout_threshold;
    ::MNetApiBufferFree( (BYTE **)&pModals );

    MakeValid();

    return NERR_Success;

}  // USER_MODALS_3::GetInfo


/**********************************************************\

   NAME:       USER_MODALS_3::WriteInfo

   SYNOPSIS:   Write information about the USER_MODALS_3

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR USER_MODALS_3::WriteInfo( VOID )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    USER_MODALS_INFO_3 modals;

    modals.usrmod3_lockout_duration           = _dwDuration;
    modals.usrmod3_lockout_observation_window = _dwObservation;
    modals.usrmod3_lockout_threshold          = _dwThreshold;

    APIERR err = ::MNetUserModalsSet ( _loc.QueryServer(),
           3, (BYTE *)&modals,
           sizeof( modals ), PARMNUM_ALL );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS_3::WriteInfo error " << err );
    }

    return err;

}  // USER_MODALS_3::WriteInfo


/**********************************************************\

   NAME:       USER_MODALS_3::QueryName

   SYNOPSIS:   query the USER_MODALS_3 name

   RETURNS:    if ok returns pointer to name (given in
               constructor).
               otherwise NULL.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

const TCHAR * USER_MODALS_3::QueryName( VOID ) const
{
    CHECK_VALID( NULL );

    return _loc.QueryName();
}  // USER_MODALS_3::QueryName



/**********************************************************\

   NAME:       USER_MODALS_3::QueryDuration

   SYNOPSIS:   get information about the lockout duration

   RETURNS:    returns duration if ok.
               otherwise 0.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

DWORD USER_MODALS_3::QueryDuration( VOID ) const
{
    CHECK_VALID( 0 );

    return _dwDuration;
}  // USER_MODALS_3::QueryDuration



/**********************************************************\

   NAME:       USER_MODALS_3::QueryObservation

   SYNOPSIS:   get information about the lockout observation window

   RETURNS:    observation window if ok.
               otherwise 0.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

DWORD USER_MODALS_3::QueryObservation( VOID ) const
{
    CHECK_VALID( 0 );

    return _dwObservation;
}  // USER_MODALS_3::QueryObservation


/**********************************************************\

   NAME:       USER_MODALS_3::QueryThreshold

   SYNOPSIS:   get information about the lockout threshold

   RETURNS:    Threshold if ok.
               otherwise -1.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

DWORD USER_MODALS_3::QueryThreshold( VOID ) const
{
    CHECK_VALID( 0 );

    return _dwThreshold;
}  // USER_MODALS_3::QueryThreshold;




/**********************************************************\

   NAME:       USER_MODALS_3::SetDuration

   SYNOPSIS:   set information about the USER_MODALS_3 object

   RETURNS:    ERROR_GEN_FAILURE if USER_MODALS_3 obj not valid
               ERROR_INVALID_PARAM if input param invalid
               NERR_Success if ok.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR  USER_MODALS_3::SetDuration( DWORD dwDuration )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _dwDuration = dwDuration;
    return NERR_Success;

} // USER_MODALS_3::SetDuration


/**********************************************************\

    NAME:       USER_MODALS_3::SetObservation

    SYNOPSIS:   set the lockout observation window

    HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR  USER_MODALS_3::SetObservation( DWORD dwObservation )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _dwObservation = dwObservation;
    return NERR_Success;

} // USER_MODALS_3::SetObservation


/**********************************************************\

    NAME:       USER_MODALS_3::SetThreshold

    SYNOPSIS:   set the lockout threshold

    HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR  USER_MODALS_3::SetThreshold( DWORD dwThreshold )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _dwThreshold = dwThreshold;
    return NERR_Success;

} // USER_MODALS_3::SetThreshold
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmosess.cxx ===
/**********************************************************************/
/**              Microsoft NT Windows                                **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    lmosess.cxx
        LM_SESSION source file.

        The LM_SESSION is as of the followings:
                LOC_LM_OBJ
                    LM_SESSION_0
                        LM_SESSION_10
                            LM_SESSION_1
                                LM_SESSION_2

    FILE HISTORY:
        terryk  20-Aug-91       Created
        terryk  26-Aug-91       Code review. Attened: keithmo chuckc
                                terryk
        terryk  07-Oct-91       type changes for NT
        KeithMo 08-Oct-1991     Now includes LMOBJP.HXX.
        terryk  17-Oct-91       WIN 32 conversion
        terryk  21-Oct-91       WIN 32 conversion

*/

#include "pchlmobj.hxx"  // Precompiled header


/**********************************************************\

    NAME:       LM_SESSION::LM_SESSION

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszClientname - client computer name
                The second parameter can be one of the following:
                const TCHAR * pszLocation - location name
                enum LOCATION_TYPE location_type - location type
                const LOCATION &loc - location object

    HISTORY:
                terryk    20-Aug-91    Created

\**********************************************************/

LM_SESSION::LM_SESSION(const TCHAR *pszComputername, const TCHAR *pszLocation )
    : LOC_LM_OBJ( pszLocation ),
    _nlsComputername()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ULONG ulPathType;
    APIERR err = ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L );
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }
    if ( ulPathType != ITYPE_UNC_COMPNAME)
    {
        ReportError( NERR_InvalidComputer );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }

    _nlsComputername = pszComputername;
    err = _nlsComputername.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( !SZ("LM_SESSION error: construction failure.") );
        return;
    }
}

LM_SESSION::LM_SESSION(const TCHAR *pszComputername, enum LOCATION_TYPE loctype)
    : LOC_LM_OBJ( loctype ),
    _nlsComputername()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ULONG ulPathType;
    APIERR err = ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L );
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }
    if ( ulPathType != ITYPE_UNC_COMPNAME)
    {
        ReportError( NERR_InvalidComputer );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }

    _nlsComputername = pszComputername;
    err = _nlsComputername.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( !SZ("LM_SESSION error: construction failure.") );
        return;
    }
}

LM_SESSION::LM_SESSION(const TCHAR *pszComputername, const LOCATION & loc)
    : LOC_LM_OBJ( loc ),
    _nlsComputername()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ULONG ulPathType;
    APIERR err = ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L );
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }
    if ( ulPathType != ITYPE_UNC_COMPNAME)
    {
        ReportError( NERR_InvalidComputer );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }

    _nlsComputername = pszComputername;
    err = _nlsComputername.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( !SZ("LM_SESSION error: construction failure.") );
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION::QueryName

    SYNOPSIS:   return the client name

    RETURN:     TCHAR * pszClientname - the client name

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

const TCHAR * LM_SESSION::QueryName( VOID ) const
{
    return _nlsComputername.QueryPch();
}

/**********************************************************\

    NAME:       LM_SESSION::I_Delete

    SYNOPSIS:   delete the current session

    ENTRY:      UINT usForce - unused

    RETURN:     APIERR err - return the netapi error code

    NOTES:      It will call ::NetSessionClose to close the session

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    UIASSERT( uiForce == 0 );
    return ::MNetSessionDel( QueryServer(), QueryName(), NULL );
}

/**********************************************************\

    NAME:       LM_SESSION::SetName

    SYNOPSIS:   set the client name

    ENTRY:      const TCHAR * pszClientname

    RETURN:     APIERR err - return from the set NLS_STR

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION::SetName( const TCHAR * pszComputername )
{
    ULONG ulPathType;

    UIASSERT(( ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L ) == NERR_Success ) && ( ulPathType ==
        ITYPE_UNC_COMPNAME ));

    _nlsComputername = pszComputername;
    return _nlsComputername.QueryError();
}

/**********************************************************\

    NAME:       LM_SESSION_0::LM_SESSION_0

    SYNOPSIS:   level 0 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_0::LM_SESSION_0( const TCHAR * pszComputername, const TCHAR *
        pszLocation )
    : LM_SESSION( pszComputername, pszLocation )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_0::LM_SESSION_0( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION( pszComputername, loctype )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_0::LM_SESSION_0( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION( pszComputername, loc )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_0::I_GetInfo

    SYNOPSIS:   get the level 0 session information

    RETURN:     APIERR err - err code returned by ::NetSessionGetInfo

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_0::I_GetInfo( VOID )
{
    // BUGBUG. No buffer allocation for NT
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        0, &pBuffer );

    // Do nothing. Since we don't need the computer name
    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_SESSION_10::LM_SESSION_10

    SYNOPSIS:   level 10 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_10::LM_SESSION_10( const TCHAR * pszComputername, const TCHAR *
        pszLocation )
    : LM_SESSION_0( pszComputername, pszLocation ),
    _nlsUsername(),
    _ulTime( 0 ),
    _ulIdleTime( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( !SZ("LM_SESSION_10 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_10::LM_SESSION_10( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION_0( pszComputername, loctype ),
    _nlsUsername(),
    _ulTime( 0 ),
    _ulIdleTime( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( !SZ("LM_SESSION_10 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_10::LM_SESSION_10( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION_0( pszComputername, loc ),
    _nlsUsername(),
    _ulTime( 0 ),
    _ulIdleTime( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( !SZ("LM_SESSION_10 error: construction failure.") );
        ReportError( err );
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_10::I_GetInfo

    SYNOPSIS:   call the netapi and get the information

    RETURN:     APIERR err - the netapi error code

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_10::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        10, &pBuffer );

    if ( err == NERR_Success )
    {
        struct session_info_10 *si10 = ( struct session_info_10 * )
            pBuffer;
        err = SetUsername( si10->sesi10_username );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        SetTime( si10->sesi10_time );
        SetIdleTime( si10->sesi10_idle_time );
    }

    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_SESSION_10::QueryUsername

    SYNOPSIS:   return the username

    RETURN:     const TCHAR * pszUsername - return the username string

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

const TCHAR * LM_SESSION_10::QueryUsername( VOID ) const
{
    // CODEWORK: Check GetInfo state
    return _nlsUsername.QueryPch();
}

/**********************************************************\

    NAME:       LM_SESSION_10::QueryTime

    SYNOPSIS:   query how long ( in seconds ) a session has been active

    RETURN:     ULONG - return the session active time in seconds

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

ULONG LM_SESSION_10::QueryTime( VOID ) const
{
    // CODEWORK: Check GetInfo state
    return _ulTime;
}

/**********************************************************\

    NAME:       LM_SESSION_10::QueryIdleTime

    SYNOPSIS:   query how long ( in seconds ) a session has been idle

    RETURN:     ULONG - return the session idle time in seconds

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

ULONG LM_SESSION_10::QueryIdleTime( VOID ) const
{
    // CODEWORK: Check GetInfo state
    return _ulIdleTime;
}

/**********************************************************\

    NAME:       LM_SESSION_10::SetUsername

    SYNOPSIS:   Protected method to change the user name

    ENTRY:      const TCHAR * pszUsername - username to be changed to

    RETURN:     APIERR err - string assignment error flag

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_10::SetUsername( const TCHAR * pszUsername )
{
    UIASSERT( ::I_MNetNameValidate( QueryServer(), pszUsername,
        NAMETYPE_USER, 0 ) == NERR_Success );

    _nlsUsername = pszUsername;
    return _nlsUsername.QueryError();
}

/**********************************************************\

    NAME:       LM_SESSION_10::SetTime

    SYNOPSIS:   protected method to change the connection time variable

    ENTRY:      ULONG ulTime - new connection time

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_10::SetTime( ULONG ulTime )
{
    _ulTime = ulTime;
}

/**********************************************************\

    NAME:       LM_SESSION_10::SetIdleTime

    SYNOPSIS:   protected method to change the idle connection time
                variable

    ENTRY:      ULONG ulTime - new idle time

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_10::SetIdleTime( ULONG ulTime )
{
    _ulIdleTime = ulTime;
}

/**********************************************************\

    NAME:       LM_SESSION_1::LM_SESSION_1

    SYNOPSIS:   level 1 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_1::LM_SESSION_1( const TCHAR * pszComputername, const TCHAR *
        pszLocation )
    : LM_SESSION_10( pszComputername, pszLocation ),
#ifndef WIN32
    _uiNumConns( 0 ),
    _uiNumUsers( 0 ),
#endif
    _uNumOpens( 0 ),
    _ulUserFlags( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_1::LM_SESSION_1( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION_10( pszComputername, loctype ),
#ifndef WIN32
    _uiNumConns( 0 ),
    _uiNumUsers( 0 ),
#endif
    _uNumOpens( 0 ),
    _ulUserFlags( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_1::LM_SESSION_1( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION_10( pszComputername, loc ),
#ifndef WIN32
    _uiNumConns( 0 ),
    _uiNumUsers( 0 ),
#endif
    _uNumOpens( 0 ),
    _ulUserFlags( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_1::I_GetInfo

    SYNOPSIS:   Get the session information. Worker function for
                GetInfo().

    RETURN:     APIERR err - the error code for ::NetSessionGetInfo

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_1::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        1, &pBuffer );

    if ( err == NERR_Success )
    {
        struct session_info_1 *si1 = ( struct session_info_1 * )
            pBuffer;
        err = SetUsername( si1->sesi1_username );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        SetTime( si1->sesi1_time );
        SetIdleTime( si1->sesi1_idle_time );
#ifndef WIN32
        // WIN32BUGBUG
        SetNumConns( (UINT)si1->sesi1_num_conns );
        SetNumUsers( si1->sesi1_num_users );
#endif
        SetNumOpens( si1->sesi1_num_opens );
        SetUserFlags( si1->sesi1_user_flags );
    }
    ::MNetApiBufferFree( &pBuffer );

    return err;
}

#ifndef WIN32
/**********************************************************\

    NAME:       LM_SESSION_1::QueryNumConns

    SYNOPSIS:   query how many connections have been made during the
                session

    RETURN:     UINT - connections number

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

UINT LM_SESSION_1::QueryNumConns( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _uiNumConns;
}

/**********************************************************\

    NAME:       LM_SESSION_1::QueryNumUsers

    SYNOPSIS:   query how many user have made connections via the
                session

    RETURN:     UINT - user number

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

UINT LM_SESSION_1::QueryNumUsers( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _uiNumUsers;
}

#endif

/**********************************************************\

    NAME:       LM_SESSION_1::QueryNumOpens

    SYNOPSIS:   query how many files, devices, and pipes have been
                opened during the session

    RETURN:     UINT - files, devices, and pipes opened number

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

UINT LM_SESSION_1::QueryNumOpens( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _uNumOpens;
}

/**********************************************************\

    NAME:       LM_SESSION_1::QueryUserFlags

    SYNOPSIS:   query how the user established the session. The shares.h
                header file defines this bit mask for sesil_user_flags.

    RETURN:     ULONG user_flags - user flags
                SESS_GUEST      1       User specified by sesil_username
                                        established the session using a
                                        guest account
                SESS_NOENCRYPTION       2       User specified by
                                                sesil_username established
                                                the session without using
                                                password encryption

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

ULONG LM_SESSION_1::QueryUserFlags( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _ulUserFlags;
}

/**********************************************************\

    NAME:       LM_SESSION_1::IsGuest

    SYNOPSIS:   return whether the session is a guest account

    RETURN:     BOOL which indicates the session is a guest account or
                not

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  23-Aug-91       Created

\**********************************************************/

BOOL LM_SESSION_1::IsGuest( VOID ) const
{
    // CODEWORK: check GetInfo State
    return ( _ulUserFlags & SESS_GUEST ) != 0;
}

/**********************************************************\

    NAME:       LM_SESSION_1::IsEncrypted

    SYNOPSIS:   return whether the session is using password encryption
                or not

    RETURN:     BOOL which indicates the session is using encryption or
                not

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  23-Aug-91       Created

\**********************************************************/

BOOL LM_SESSION_1::IsEncrypted( VOID ) const
{
    // CODEWORK: check GetInfo State
    return ( _ulUserFlags & SESS_NOENCRYPTION ) == 0;
}

#ifndef WIN32
/**********************************************************\

    NAME:       LM_SESSION_1::SetNumConns

    SYNOPSIS:   Protected method which is used to change the number of
                connections variable.

    ENTRY:      UINT uiNumConns - the new number of connections number

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetNumConns( UINT uiNumConns )
{
    _uiNumConns = uiNumConns;
}

/**********************************************************\

    NAME:       LM_SESSION_1::SetNumUsers

    SYNOPSIS:   protected method which used to set the new number of
                users

    ENTRY:      UINT uiNumUser - number of new user

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetNumUsers( UINT uiNumUser )
{
    _uiNumUsers = uiNumUser;
}

#endif

/**********************************************************\

    NAME:       LM_SESSION_1::SetNumOpens

    SYNOPSIS:   protected method which is used to set the number of
                opens device

    ENTRY:      UINT uiNumOpens - new open devices and files number

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetNumOpens( UINT uNumOpens )
{
    _uNumOpens = uNumOpens;
}

/**********************************************************\

    NAME:       LM_SESSION_1::SetUserFlags

    SYNOPSIS:   protected method which used to set the new user flags

    ENTRY:      ULONG ulUserFlags - new user flags

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetUserFlags( ULONG ulUserFlags )
{
    _ulUserFlags = ulUserFlags;
}

/**********************************************************\

    NAME:       LM_SESSION_2::LM_SESSION_2

    SYNOPSIS:   level 2 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_2::LM_SESSION_2( const TCHAR *pszComputername,
        const TCHAR *pszLocation )
    : LM_SESSION_1( pszComputername , pszLocation ),
    _nlsClientType()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsClientType.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( SZ("LM_SESSION_2 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_2::LM_SESSION_2( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION_1( pszComputername, loctype ),
    _nlsClientType()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsClientType.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( SZ("LM_SESSION_2 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_2::LM_SESSION_2( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION_1( pszComputername, loc ),
    _nlsClientType()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsClientType.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( SZ("LM_SESSION_2 error: construction failure.") );
        ReportError( err );
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_2::I_GetInfo

    SYNOPSIS:   get the server information

    RETURN:     APIERR - from the netapi call

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_2::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        2, &pBuffer );

    if ( err == NERR_Success )
    {
        struct session_info_2 *si2 = ( struct session_info_2 * ) pBuffer;
        err = SetUsername( si2->sesi2_username );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        err = SetClientType( si2->sesi2_cltype_name );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        SetTime( si2->sesi2_time );
        SetIdleTime( si2->sesi2_idle_time );
#ifndef WIN32
        SetNumConns( (UINT)si2->sesi2_num_conns );
        SetNumUsers( si2->sesi2_num_users );
#endif
        SetNumOpens( si2->sesi2_num_opens );
        SetUserFlags( si2->sesi2_user_flags );
    }
    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_SESSION_2::QueryClientType

    SYNOPSIS:   query the type of client that established the session

    RETURN:     TCHAR * - an ASCIIZ string
                NAME                    TYPE
                DOWN LEVEL      Old clients
                DOS LM          LAN Manager 1.0 for ms-dos client &
                                LAN Manager 2.0 for ms-dos basic clients
                DOS LM 2.0      LAN Manager 2.0 for ms-dos enhanced
                                clients
                OS/2 LM 1.0     LAN Manager 1.0 for ms os/2 client or
                                LAN Manager 2.0 for ms os/2 with ms os/2 1.1
                OS/2 LM 2.0     LAN Manager 2.0 for MS os/2 clients

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

const TCHAR * LM_SESSION_2::QueryClientType( VOID ) const
{
    // CODEWORK: check GetInfo state
    return _nlsClientType.QueryPch();
}

/**********************************************************\

    NAME:       LM_SESSION_2::SetClientType

    SYNOPSIS:   protected method which used to set the cltype_name
                variable

    ENTRY:      const TCHAR * pszClientType - new cltype_name

    RETURN:     APIERR err - error flag for assignment

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_2::SetClientType( const TCHAR * pszClientType )
{
    _nlsClientType = pszClientType;
    return _nlsClientType.QueryError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmoshare.cxx ===
/**********************************************************************/
/**                     Microsoft NT Windows 			     **/
/**		Copyright(c) Microsoft Corp., 1991	             **/
/**********************************************************************/

/*
 *  lmoshare.cxx
 *
 *  This file contains the implementation of share classes.
 *
 *  HISTORY:
 *	t-yis	8/9/91		Created
 *	rustanl 8/27/91 	Changed CloneFrom param from * to &
 *	terryk	10/7/91		types change for NT
 *	KeithMo	10/8/91		Now includes LMOBJP.HXX.
 *	terryk	10/17/91	WIN 32 conversion
 *	terryk	10/21/91	WIN 32 conversion
 *	jonn	10/31/91	Removed SetBufferSize
 *      Yi-HsinS 12/9/91        Remove SetPath in cloneFrom and I_GetInfo
 *				because we don't need to do extra validation.
 *      Yi-HsinS 1/21/92        Remove the strupr of password and move it
 *			        to the UI level.
 *      Yi-HsinS 11/20/92       Add fNew to SetWriteBuffer
 *
 */
#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:	SHARE::SHARE

    SYNOPSIS:	constructor for the SHARE object

    ENTRY:	pszShareName  -	share name
            	pszServerName -	server name
				default (NULL) means the local computer

    EXIT:	Object is constructed, validation is done

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

SHARE::SHARE( const TCHAR *pszShareName,
              const TCHAR *pszServerName,
              BOOL fValidate )
	: LOC_LM_OBJ( pszServerName, fValidate ),
	  _nlsShareName()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    // Validate share name, server name is validated in LOC_LM_OBJ
    if ( ( err = SetName( pszShareName )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:	SHARE::~SHARE

    SYNOPSIS:	Destructor for SHARE class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE::~SHARE()
{
}


/*******************************************************************

    NAME:	SHARE::SetName

    SYNOPSIS:	Set the name of the share ( used in
                creating a new share )

    ENTRY:	pszShareName  -	share name

    EXIT:	Return an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE::SetName( const TCHAR *pszShareName )
{
    APIERR err = NERR_Success;

    if ( pszShareName != NULL )
    {
        if ( IsValidationOn() )
            err = ::I_MNetNameValidate( NULL, pszShareName, NAMETYPE_SHARE, 0L);

        if ( err == NERR_Success )
        {
  	    _nlsShareName.CopyFrom( pszShareName );
	    if ( (err = _nlsShareName.QueryError()) != NERR_Success )
	        _nlsShareName.Reset();
        }
    }

    return err;

}

/*******************************************************************

    NAME:	SHARE::W_CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share - reference to the SHARE to copy from

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE::W_CloneFrom( const SHARE & share )
{

    APIERR err = LOC_LM_OBJ::W_CloneFrom( share );

    // Don't want to call SetName because we don't need to validate the name
    // The name is validated when constructing share
    _nlsShareName = share.QueryName();

    if (   ( err != NERR_Success )
       || (( err = _nlsShareName.QueryError() ) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE::W_CreateNew

    SYNOPSIS:	Set up default new share

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE::W_CreateNew( VOID )
{

    APIERR err = LOC_LM_OBJ::W_CreateNew();
    if ( err != NERR_Success )
    {
        return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE::I_Delete

    SYNOPSIS:	Delete the share

    EXIT:	Returns an API error code

    NOTE:       usForce is ignored

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/
APIERR SHARE::I_Delete( UINT uiForce )
{

    UNREFERENCED( uiForce );

    // The last parameter in NetShareDel is not the force, it is
    //  reserved and has to be zero.
    return ::MNetShareDel( QueryServer(), QueryName(), 0);

}

/*******************************************************************

    NAME:	SHARE_1::SHARE_1

    SYNOPSIS:	Constructor for SHARE_1 class

    ENTRY:	pszShareName - share name
                pszServerName -	server name to execute on
		                default (NULL) means the logon domain

    EXIT:	Object is constructed

    NOTES:      share name and server name are validated in parent classes

    CAVEATS:	

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_1::SHARE_1( const TCHAR *pszShareName,
                  const TCHAR *pszServerName,
                  BOOL fValidate )
	: SHARE( pszShareName, pszServerName, fValidate ),
          _uResourceType( (UINT)-1 ), // initialized to invalid value
          _fAdminOnly( FALSE ),
	  _nlsComment()
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _nlsComment.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

}

/*******************************************************************

    NAME:	SHARE_1::~SHARE_1

    SYNOPSIS:	Destructor for SHARE_1 class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_1::~SHARE_1()
{
}


/*******************************************************************

    NAME:	SHARE_1::I_GetInfo

    SYNOPSIS:	Get the information about the share

    ENTRY:

    EXIT:	Returns a standard LANMAN error code

    HISTORY:
	t-yis	8/9/1991		Created
	jonn	10/31/1991		Removed SetBufferSize

********************************************************************/

APIERR SHARE_1::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;
    APIERR err = ::MNetShareGetInfo( QueryServer(), QueryName(), 1,
		    &pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
	return err ;

    struct share_info_1 *lpsi1 = (struct share_info_1 *) QueryBufferPtr();
    UIASSERT( lpsi1 != NULL );

#if defined(WIN32)
    SetAdminOnly( (lpsi1->shi1_type & STYPE_SPECIAL) != 0 );
    lpsi1->shi1_type &= ~STYPE_SPECIAL;
#endif

    if (   (( err = SetResourceType( (UINT)lpsi1->shi1_type )) != NERR_Success )
        || (( err = SetComment( lpsi1->shi1_remark )) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_1::I_WriteInfo

    SYNOPSIS:	Writes information about the share

    EXIT:	Returns API error code

    HISTORY:
	t-yis	    8/9/91	    Created

********************************************************************/

APIERR SHARE_1::I_WriteInfo( VOID )
{

    struct share_info_1 *lpsi1 = (struct share_info_1 *) QueryBufferPtr();
    UIASSERT( lpsi1 != NULL );

    lpsi1->shi1_remark = (TCHAR *) QueryComment();

    return ::MNetShareSetInfo ( QueryServer(),
      	                        QueryName(), 1,
			        QueryBufferPtr(),
			        sizeof( share_info_1 ), PARMNUM_ALL);

}


/*******************************************************************

    NAME:	SHARE_1::CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share1 - reference to the share to copy information from

    EXIT:	Returns an API error code

    NOTES:	W_CloneFrom copies all member objects, but it does not
    		update the otherwise unused pointers in the API buffer.
		This is left for the outermost routine, CloneFrom().
		Only the otherwise unused pointers need to be fixed
		here, the rest will be fixed in WriteInfo/WriteNew.

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_1::CloneFrom( const SHARE_1 & share1 )
{
    APIERR err = W_CloneFrom( share1 );

    if ( err != NERR_Success )
    {
	ReportError( err );
	return err;
    }

    /*
     *  No unused pointers - don't need to fix up pointers
     */

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_1::W_CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share1 - reference to the share to copy information from

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_1::W_CloneFrom( const SHARE_1 & share1 )
{

    APIERR err = SHARE::W_CloneFrom( share1 );

    if (   ( err != NERR_Success )
	|| (( err = SetResourceType( share1.QueryResourceType())) != NERR_Success)
	|| (( err = SetComment( share1.QueryComment())) != NERR_Success)
       )
    {
	return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_1::W_CreateNew

    SYNOPSIS:	Sets default on the new share

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_1::W_CreateNew( VOID )
{

    APIERR err = SHARE::W_CreateNew();

    if ( err != NERR_Success )
    {
	return err;
    }

    _uResourceType = (UINT)(-1);
    _nlsComment = NULL;
    if ( (err = _nlsComment.QueryError()) != NERR_Success )
    {
        return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_1::SetComment

    SYNOPSIS:	Changes the comment set for the share

    ENTRY:      pszComment - comment

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_1::SetComment( const TCHAR *pszComment )
{

    APIERR err = NERR_Success;

    if ( pszComment != NULL )
    {
        ALIAS_STR nlsComment( pszComment );

        if ( IsValidationOn() )
            err = ::I_MNetNameValidate( NULL, pszComment, NAMETYPE_COMMENT, 0L);

        if ( err == NERR_Success )
        {
            err = _nlsComment.CopyFrom( nlsComment );
            if ( err != NERR_Success )
	        _nlsComment.Reset();
        }
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_1::SetResourceType

    SYNOPSIS:	Set the share's resource type

    ENTRY:      usResourceType - Type of the share

    EXIT:	error code.

    NOTE:       Used only when creating a new share (SHARE_2)

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_1::SetResourceType( UINT uResourceType )
{

    if ( IsValidationOn() )
    {
        // Validate Resource Type
        switch ( uResourceType )
        {
            case STYPE_DISKTREE:
            case STYPE_PRINTQ:
            case STYPE_DEVICE:
            case STYPE_IPC:
                 break;

            default:
                 return ERROR_INVALID_PARAMETER;
        }
    }

    _uResourceType = uResourceType;
    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::SHARE_2

    SYNOPSIS:	Constructor for SHARE_2 class

    ENTRY:	pszShareName -	share name
                pszServerName -	server name
                    	        default (NULL) means the local server

    EXIT:	Object is constructed and validated

    NOTES:      Share name and server name are validated in parent classes

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_2::SHARE_2( const TCHAR *pszShareName,
                  const TCHAR *pszServerName,
                  BOOL fValidate )
	: SHARE_1( pszShareName, pszServerName, fValidate ),
          _uMaxUses( (UINT)-1 ),
          _uCurrentUses(0),
          _fs2lPermissions(0),
	  _nlsPath(),
	  _nlsPassword()
{

    if ( QueryError() != NERR_Success )
    	return;

    APIERR err = NERR_Success;
    if (   (( err = _nlsPath.QueryError()) != NERR_Success )
        || (( err = _nlsPassword.QueryErr